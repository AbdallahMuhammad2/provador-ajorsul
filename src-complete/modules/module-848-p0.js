/*
 * Module 848 (Pattern 0)
 * Params: d, o, c
 * Size: 1237751 chars
 */

// === MODULE CONTENT ===
function module848(d, o, c) {
c.d(o, {
            $EB: function() {
                return St
            },
            $Kf: function() {
                return K0
            },
            $NF: function() {
                return O_
            },
            $O9: function() {
                return Xn
            },
            $_I: function() {
                return vo
            },
            $ei: function() {
                return Jt
            },
            $p8: function() {
                return kA
            },
            A$4: function() {
                return co
            },
            AKb: function() {
                return AS
            },
            ALV: function() {
                return k0
            },
            AT1: function() {
                return o_
            },
            Am1: function() {
                return OS
            },
            B69: function() {
                return Mo
            },
            B6O: function() {
                return Xx
            },
            BH$: function() {
                return Z0
            },
            BKk: function() {
                return zl
            },
            BND: function() {
                return fE
            },
            BRH: function() {
                return PS
            },
            BXX: function() {
                return Bl
            },
            B_h: function() {
                return cu
            },
            BdL: function() {
                return V0
            },
            CMB: function() {
                return Vn
            },
            CR7: function() {
                return Q_
            },
            CSG: function() {
                return H0
            },
            CV9: function() {
                return ly
            },
            CVz: function() {
                return G_
            },
            CWW: function() {
                return ap
            },
            Cfg: function() {
                return En
            },
            CmU: function() {
                return OA
            },
            CwR: function() {
                return GS
            },
            D$Q: function() {
                return dA
            },
            DAe: function() {
                return Xp
            },
            DAr: function() {
                return ps
            },
            DXC: function() {
                return iu
            },
            Df: function() {
                return mA
            },
            E0M: function() {
                return _E
            },
            EAD: function() {
                return Lv
            },
            EQC: function() {
                return $p
            },
            EZo: function() {
                return It
            },
            EdD: function() {
                return Gt
            },
            F1T: function() {
                return Gy
            },
            F1l: function() {
                return aE
            },
            FCc: function() {
                return Hx
            },
            FFZ: function() {
                return Y_
            },
            FNr: function() {
                return _A
            },
            FV: function() {
                return pr
            },
            FXf: function() {
                return Ut
            },
            FZo: function() {
                return LA
            },
            Fn: function() {
                return sp
            },
            Fpm: function() {
                return oE
            },
            FvD: function() {
                return jv
            },
            Fvt: function() {
                return vA
            },
            G3T: function() {
                return ku
            },
            GBG: function() {
                return wA
            },
            GJx: function() {
                return Tn
            },
            GOR: function() {
                return dS
            },
            GTy: function() {
                return At
            },
            GWd: function() {
                return as
            },
            GYF: function() {
                return Pm
            },
            GZZ: function() {
                return sy
            },
            G_z: function() {
                return gA
            },
            Gu$: function() {
                return I_
            },
            Gwm: function() {
                return rn
            },
            GxU: function() {
                return Rt
            },
            H23: function() {
                return jm
            },
            HLH: function() {
                return Wm
            },
            HO_: function() {
                return zm
            },
            HPb: function() {
                return $m
            },
            HXV: function() {
                return Lm
            },
            HgN: function() {
                return e_
            },
            HiM: function() {
                return RA
            },
            Hit: function() {
                return D_
            },
            Ho_: function() {
                return Im
            },
            Hrb: function() {
                return zn
            },
            Hrq: function() {
                return J_
            },
            I46: function() {
                return Bx
            },
            I9Y: function() {
                return mn
            },
            IE4: function() {
                return xs
            },
            IUQ: function() {
                return Lo
            },
            IWo: function() {
                return mE
            },
            Ipv: function() {
                return Hl
            },
            Iw4: function() {
                return XS
            },
            IzY: function() {
                return vE
            },
            JeP: function() {
                return xx
            },
            Jnc: function() {
                return it
            },
            K52: function() {
                return hn
            },
            KDk: function() {
                return Zs
            },
            KLL: function() {
                return Vo
            },
            KPJ: function() {
                return vy
            },
            KRh: function() {
                return qn
            },
            Ke9: function() {
                return Hm
            },
            Kef: function() {
                return z_
            },
            Ktl: function() {
                return K_
            },
            Kwu: function() {
                return Dt
            },
            Kzg: function() {
                return LS
            },
            Kzv: function() {
                return Ln
            },
            Ld9: function() {
                return yE
            },
            LiQ: function() {
                return ar
            },
            LlO: function() {
                return Vy
            },
            LoY: function() {
                return bo
            },
            LuO: function() {
                return JS
            },
            MBL: function() {
                return Dm
            },
            MOq: function() {
                return Zp
            },
            MSw: function() {
                return n0
            },
            MW4: function() {
                return Ts
            },
            Mjd: function() {
                return xn
            },
            N1A: function() {
                return ep
            },
            N2s: function() {
                return qA
            },
            N5j: function() {
                return Qm
            },
            NRn: function() {
                return Tl
            },
            NTi: function() {
                return Pt
            },
            NZq: function() {
                return Hn
            },
            Nt7: function() {
                return cr
            },
            Nv2: function() {
                return aS
            },
            Nwf: function() {
                return Ro
            },
            Nz6: function() {
                return Js
            },
            O0B: function() {
                return nv
            },
            O3Y: function() {
                return o0
            },
            O49: function() {
                return H_
            },
            O9p: function() {
                return $u
            },
            ONl: function() {
                return Wx
            },
            OUM: function() {
                return $n
            },
            Oax: function() {
                return ks
            },
            Om: function() {
                return Mn
            },
            OuU: function() {
                return gr
            },
            P5j: function() {
                return qS
            },
            PFK: function() {
                return pE
            },
            PJ3: function() {
                return lp
            },
            PPD: function() {
                return Av
            },
            PTz: function() {
                return Is
            },
            Pdi: function() {
                return bA
            },
            Pem: function() {
                return lS
            },
            Pf$: function() {
                return US
            },
            Pq0: function() {
                return Er
            },
            Q1f: function() {
                return Gn
            },
            QCA: function() {
                return e0
            },
            QP0: function() {
                return pt
            },
            Qev: function() {
                return As
            },
            Qrf: function() {
                return op
            },
            R1W: function() {
                return cE
            },
            RJ4: function() {
                return Ll
            },
            ROr: function() {
                return E0
            },
            RQf: function() {
                return ss
            },
            RcT: function() {
                return Yl
            },
            RiT: function() {
                return B_
            },
            Riy: function() {
                return lu
            },
            Rkk: function() {
                return up
            },
            RlV: function() {
                return Qu
            },
            RoJ: function() {
                return q0
            },
            Ru$: function() {
                return T0
            },
            RyA: function() {
                return _t
            },
            S$4: function() {
                return Wp
            },
            S20: function() {
                return Vv
            },
            S2Q: function() {
                return Ol
            },
            S3G: function() {
                return bx
            },
            SUR: function() {
                return NA
            },
            ScU: function() {
                return CS
            },
            T6I: function() {
                return _y
            },
            TDQ: function() {
                return eA
            },
            THS: function() {
                return mr
            },
            TMh: function() {
                return Xm
            },
            Tap: function() {
                return MS
            },
            TdN: function() {
                return Qs
            },
            TiK: function() {
                return q_
            },
            TkQ: function() {
                return yo
            },
            U3G: function() {
                return Zr
            },
            UJ6: function() {
                return Ql
            },
            UPV: function() {
                return s0
            },
            UTZ: function() {
                return jr
            },
            Ua6: function() {
                return _h
            },
            Ufg: function() {
                return R_
            },
            UpK: function() {
                return Px
            },
            UtB: function() {
                return nE
            },
            UtX: function() {
                return wy
            },
            V3x: function() {
                return Ps
            },
            V58: function() {
                return m_
            },
            V5c: function() {
                return dp
            },
            V9B: function() {
                return nu
            },
            VCu: function() {
                return yx
            },
            VT0: function() {
                return Sl
            },
            VVr: function() {
                return Yp
            },
            Vb5: function() {
                return nt
            },
            VnP: function() {
                return Jx
            },
            Vnu: function() {
                return gu
            },
            VxR: function() {
                return No
            },
            W9U: function() {
                return Vm
            },
            WBB: function() {
                return t0
            },
            WNZ: function() {
                return _e
            },
            WTh: function() {
                return hE
            },
            Wdf: function() {
                return Ym
            },
            Wew: function() {
                return $l
            },
            Wk7: function() {
                return ht
            },
            Wyr: function() {
                return Jl
            },
            XG_: function() {
                return Gm
            },
            XIg: function() {
                return Et
            },
            XJ7: function() {
                return aA
            },
            XTe: function() {
                return DS
            },
            XrR: function() {
                return mo
            },
            Y9S: function() {
                return su
            },
            YHV: function() {
                return tE
            },
            YJl: function() {
                return Am
            },
            YOZ: function() {
                return Ip
            },
            YRT: function() {
                return TS
            },
            Yhb: function() {
                return AA
            },
            Yuy: function() {
                return $o
            },
            Z0B: function() {
                return oy
            },
            Z58: function() {
                return Ax
            },
            ZLX: function() {
                return Fx
            },
            ZM4: function() {
                return gE
            },
            ZQM: function() {
                return Ks
            },
            Zcv: function() {
                return _d
            },
            Zpd: function() {
                return i0
            },
            Zr2: function() {
                return Xo
            },
            ZyN: function() {
                return IA
            },
            _4j: function() {
                return hy
            },
            _QJ: function() {
                return zp
            },
            _xc: function() {
                return sE
            },
            a$r: function() {
                return Qn
            },
            a5J: function() {
                return uu
            },
            aEY: function() {
                return wr
            },
            aHM: function() {
                return $s
            },
            aMy: function() {
                return Du
            },
            aVO: function() {
                return Q0
            },
            agE: function() {
                return Nu
            },
            amv: function() {
                return mu
            },
            b4q: function() {
                return f_
            },
            bC7: function() {
                return Qp
            },
            bCz: function() {
                return Bt
            },
            bI3: function() {
                return El
            },
            bTm: function() {
                return ut
            },
            baL: function() {
                return $r
            },
            bdM: function() {
                return g_
            },
            bkx: function() {
                return Yo
            },
            brA: function() {
                return fr
            },
            bw0: function() {
                return Nn
            },
            c5h: function() {
                return uS
            },
            c90: function() {
                return ko
            },
            cHt: function() {
                return Zo
            },
            cRK: function() {
                return Pv
            },
            cZY: function() {
                return iE
            },
            caT: function() {
                return Wn
            },
            cj9: function() {
                return ev
            },
            czI: function() {
                return Gp
            },
            dAo: function() {
                return ay
            },
            dYF: function() {
                return i_
            },
            dcC: function() {
                return Eo
            },
            dhZ: function() {
                return cp
            },
            dth: function() {
                return EA
            },
            dwI: function() {
                return lo
            },
            dzP: function() {
                return KS
            },
            eB$: function() {
                return Rv
            },
            eHc: function() {
                return Cr
            },
            eHs: function() {
                return Cp
            },
            eaF: function() {
                return gs
            },
            eoi: function() {
                return $_
            },
            er$: function() {
                return jo
            },
            ezk: function() {
                return gy
            },
            f4X: function() {
                return lr
            },
            fBL: function() {
                return zo
            },
            fCn: function() {
                return Dn
            },
            fJr: function() {
                return qm
            },
            fP5: function() {
                return QA
            },
            fTw: function() {
                return uE
            },
            fc6: function() {
                return vn
            },
            g7M: function() {
                return Ir
            },
            gJ2: function() {
                return wl
            },
            gO9: function() {
                return kt
            },
            gPd: function() {
                return Ho
            },
            gWB: function() {
                return Kl
            },
            ghU: function() {
                return wn
            },
            h2z: function() {
                return pu
            },
            hB5: function() {
                return vt
            },
            hIf: function() {
                return Jp
            },
            hZF: function() {
                return kp
            },
            h_9: function() {
                return SA
            },
            hdd: function() {
                return dr
            },
            hfX: function() {
                return _x
            },
            hgQ: function() {
                return Rr
            },
            hjs: function() {
                return rE
            },
            hsX: function() {
                return bt
            },
            hxR: function() {
                return fn
            },
            hy7: function() {
                return Qr
            },
            hzE: function() {
                return dE
            },
            i7d: function() {
                return xv
            },
            i7u: function() {
                return na
            },
            iNn: function() {
                return Zu
            },
            iOZ: function() {
                return cS
            },
            iUH: function() {
                return Bo
            },
            ibB: function() {
                return $x
            },
            ie2: function() {
                return hr
            },
            imn: function() {
                return hs
            },
            ix0: function() {
                return Os
            },
            iyt: function() {
                return Ws
            },
            j6: function() {
                return a0
            },
            jGm: function() {
                return Zx
            },
            jR7: function() {
                return bs
            },
            jUj: function() {
                return Mv
            },
            jf0: function() {
                return Oo
            },
            jsO: function() {
                return Kp
            },
            jut: function() {
                return l0
            },
            jzd: function() {
                return X_
            },
            k6Q: function() {
                return Bm
            },
            k6q: function() {
                return Rn
            },
            kBv: function() {
                return _
            },
            kEx: function() {
                return ES
            },
            kG0: function() {
                return pp
            },
            kLi: function() {
                return ga
            },
            kO0: function() {
                return fp
            },
            kRr: function() {
                return Yn
            },
            kTW: function() {
                return Cn
            },
            kTp: function() {
                return Vp
            },
            kYr: function() {
                return hp
            },
            keZ: function() {
                return NS
            },
            klZ: function() {
                return W_
            },
            kn4: function() {
                return no
            },
            kqe: function() {
                return Hs
            },
            kxk: function() {
                return Tx
            },
            kyO: function() {
                return nn
            },
            l2R: function() {
                return Eu
            },
            lGu: function() {
                return tr
            },
            lGw: function() {
                return k_
            },
            lMl: function() {
                return Es
            },
            lPF: function() {
                return Zm
            },
            lc7: function() {
                return qp
            },
            ljd: function() {
                return Bu
            },
            lyL: function() {
                return Hp
            },
            mrM: function() {
                return Gs
            },
            nCl: function() {
                return PA
            },
            nEu: function() {
                return qv
            },
            nNL: function() {
                return ur
            },
            nST: function() {
                return Ht
            },
            nWS: function() {
                return Rs
            },
            nZQ: function() {
                return vx
            },
            nc$: function() {
                return Ty
            },
            nzx: function() {
                return T_
            },
            o6l: function() {
                return zy
            },
            oVO: function() {
                return C0
            },
            oh6: function() {
                return ZS
            },
            ojh: function() {
                return or
            },
            ojs: function() {
                return Iu
            },
            pBf: function() {
                return Om
            },
            pFK: function() {
                return tp
            },
            pHI: function() {
                return bn
            },
            pPE: function() {
                return $A
            },
            paN: function() {
                return ds
            },
            ppV: function() {
                return Do
            },
            psI: function() {
                return Nm
            },
            q2: function() {
                return uA
            },
            qBx: function() {
                return fA
            },
            qFE: function() {
                return Wv
            },
            qIQ: function() {
                return hu
            },
            qU7: function() {
                return Hv
            },
            qUd: function() {
                return Sv
            },
            qa3: function() {
                return Xl
            },
            qad: function() {
                return ir
            },
            qtW: function() {
                return Fn
            },
            r6x: function() {
                return Ay
            },
            rFo: function() {
                return im
            },
            rKP: function() {
                return r0
            },
            rOG: function() {
                return xo
            },
            rQf: function() {
                return du
            },
            rSH: function() {
                return Ru
            },
            rYR: function() {
                return S0
            },
            s0K: function() {
                return Kx
            },
            sKt: function() {
                return mp
            },
            sPf: function() {
                return h
            },
            tBo: function() {
                return eE
            },
            tJf: function() {
                return ao
            },
            tXL: function() {
                return hA
            },
            tcD: function() {
                return Qv
            },
            tgE: function() {
                return ts
            },
            tz3: function() {
                return L_
            },
            uB5: function() {
                return Fm
            },
            uSd: function() {
                return pA
            },
            uV5: function() {
                return gn
            },
            uWO: function() {
                return Mm
            },
            uXQ: function() {
                return P0
            },
            ubm: function() {
                return Cs
            },
            uov: function() {
                return M0
            },
            ure: function() {
                return DA
            },
            veJ: function() {
                return rp
            },
            vim: function() {
                return fu
            },
            vmz: function() {
                return is
            },
            vxI: function() {
                return go
            },
            vyJ: function() {
                return Lu
            },
            wAk: function() {
                return E_
            },
            wfO: function() {
                return qr
            },
            wn6: function() {
                return Ar
            },
            wqq: function() {
                return Ou
            },
            wrO: function() {
                return ys
            },
            wtR: function() {
                return b
            },
            wvS: function() {
                return Tr
            },
            xFO: function() {
                return Or
            },
            xJ6: function() {
                return ou
            },
            xOk: function() {
                return BA
            },
            xSv: function() {
                return vr
            },
            xZx: function() {
                return VS
            },
            xfg: function() {
                return cy
            },
            y3Z: function() {
                return Um
            },
            y9J: function() {
                return n_
            },
            y_p: function() {
                return Ur
            },
            ypk: function() {
                return Pp
            },
            ywQ: function() {
                return at
            },
            z5: function() {
                return Wo
            },
            zD7: function() {
                return GA
            },
            zdS: function() {
                return Ys
            },
            zgK: function() {
                return um
            },
            zkh: function() {
                return qs
            },
            znC: function() {
                return Kt
            }
        });
        const h = "157"
          , _ = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }
          , b = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }
          , _e = 0
          , nt = 1
          , it = 2
          , at = 3
          , ut = 0
          , pt = 1
          , ht = 2
          , _t = 3
          , vt = 0
          , bt = 1
          , St = 2
          , At = 2
          , Et = 0
          , Pt = 1
          , It = 2
          , Dt = 3
          , Gt = 4
          , Bt = 5
          , kt = 100
          , Ut = 101
          , Ht = 102
          , Kt = 103
          , Jt = 104
          , or = 200
          , ir = 201
          , lr = 202
          , ar = 203
          , hr = 204
          , gr = 205
          , dr = 206
          , cr = 207
          , Ar = 208
          , wr = 209
          , Rr = 210
          , Cr = 0
          , tr = 1
          , fr = 2
          , vr = 3
          , Zr = 4
          , rn = 5
          , hn = 6
          , Nn = 7
          , Wn = 0
          , qn = 1
          , mo = 2
          , Ur = 0
          , nn = 1
          , xn = 2
          , ur = 3
          , pr = 4
          , Ir = 5
          , jr = 300
          , Qr = 301
          , Or = 302
          , qr = 303
          , gn = 304
          , Mn = 306
          , Tn = 1e3
          , wn = 1001
          , Cn = 1002
          , fn = 1003
          , bn = 1004
          , Xn = 1004
          , En = 1005
          , Qn = 1005
          , Rn = 1006
          , Yn = 1007
          , Bo = 1007
          , vo = 1008
          , Hn = 1008
          , $n = 1009
          , ao = 1010
          , zo = 1011
          , Zo = 1012
          , $o = 1013
          , Yo = 1014
          , ss = 1015
          , Os = 1016
          , $l = 1017
          , wl = 1018
          , Ps = 1020
          , ys = 1021
          , as = 1023
          , Ln = 1024
          , Vn = 1025
          , Ys = 1026
          , Eo = 1027
          , Sl = 1028
          , Ks = 1029
          , ds = 1030
          , yo = 1031
          , ko = 1033
          , xs = 33776
          , Js = 33777
          , bs = 33778
          , Bl = 33779
          , Bm = 35840
          , Vp = 35841
          , Lm = 35842
          , Om = 35843
          , G_ = 36196
          , lu = 37492
          , Zs = 37496
          , Xl = 37808
          , cu = 37809
          , Gp = 37810
          , Ru = 37811
          , op = 37812
          , Nm = 37813
          , uu = 37814
          , zp = 37815
          , Fm = 37816
          , Hp = 37817
          , Qp = 37818
          , Um = 37819
          , Iu = 37820
          , Wp = 37821
          , sp = 36492
          , jm = 36494
          , Vm = 36495
          , z_ = 36283
          , Gm = 36284
          , zm = 36285
          , ap = 36286
          , ku = 2200
          , Du = 2201
          , qp = 2202
          , Bu = 2300
          , lp = 2301
          , $p = 2302
          , du = 2400
          , pu = 2401
          , cp = 2402
          , Hm = 2500
          , Xp = 2501
          , Ll = 0
          , H_ = 1
          , S0 = 2
          , ts = 3e3
          , Ol = 3001
          , up = 3200
          , Qm = 3201
          , El = 0
          , Lu = 1
          , Oo = ""
          , jo = "srgb"
          , Xo = "srgb-linear"
          , dp = "display-p3"
          , hu = "display-p3-linear"
          , ps = "rgbm-16"
          , No = "linear"
          , Vo = "srgb"
          , Wo = "rec709"
          , Ou = "p3"
          , Hs = 0
          , Yp = 7680
          , pp = 7681
          , Wm = 7682
          , E0 = 7683
          , T0 = 34055
          , qm = 34056
          , C0 = 5386
          , $m = 512
          , hp = 513
          , Kp = 514
          , Q_ = 515
          , Yl = 516
          , W_ = 517
          , Xm = 518
          , mp = 519
          , mu = 512
          , fu = 513
          , fp = 514
          , q_ = 515
          , $_ = 516
          , X_ = 517
          , Kl = 518
          , Y_ = 519
          , Nu = 35044
          , gu = 35048
          , K_ = 35040
          , P0 = 35045
          , Jp = 35049
          , M0 = 35041
          , J_ = 35046
          , Zp = 35050
          , xo = 35042
          , Jl = "100"
          , Ym = "300 es"
          , _h = 1035
          , Qs = 2e3
          , na = 2001;
        class As {
            addEventListener(tt, lt) {
                this._listeners === void 0 && (this._listeners = {});
                const mt = this._listeners;
                mt[tt] === void 0 && (mt[tt] = []),
                mt[tt].indexOf(lt) === -1 && mt[tt].push(lt)
            }
            hasEventListener(tt, lt) {
                if (this._listeners === void 0)
                    return !1;
                const mt = this._listeners;
                return mt[tt] !== void 0 && mt[tt].indexOf(lt) !== -1
            }
            removeEventListener(tt, lt) {
                if (this._listeners === void 0)
                    return;
                const mt = this._listeners[tt];
                if (mt !== void 0) {
                    const ft = mt.indexOf(lt);
                    ft !== -1 && mt.splice(ft, 1)
                }
            }
            dispatchEvent(tt) {
                if (this._listeners === void 0)
                    return;
                const lt = this._listeners[tt.type];
                if (lt !== void 0) {
                    tt.target = this;
                    const mt = lt.slice(0);
                    for (let ft = 0, xt = mt.length; ft < xt; ft++)
                        mt[ft].call(this, tt);
                    tt.target = null
                }
            }
        }
        const Go = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let Z_ = 1234567;
        const Zl = Math.PI / 180
          , _u = 180 / Math.PI;
        function Ms() {
            const Tt = 4294967295 * Math.random() | 0
              , tt = 4294967295 * Math.random() | 0
              , lt = 4294967295 * Math.random() | 0
              , mt = 4294967295 * Math.random() | 0;
            return (Go[255 & Tt] + Go[Tt >> 8 & 255] + Go[Tt >> 16 & 255] + Go[Tt >> 24 & 255] + "-" + Go[255 & tt] + Go[tt >> 8 & 255] + "-" + Go[tt >> 16 & 15 | 64] + Go[tt >> 24 & 255] + "-" + Go[63 & lt | 128] + Go[lt >> 8 & 255] + "-" + Go[lt >> 16 & 255] + Go[lt >> 24 & 255] + Go[255 & mt] + Go[mt >> 8 & 255] + Go[mt >> 16 & 255] + Go[mt >> 24 & 255]).toLowerCase()
        }
        function qo(Tt, tt, lt) {
            return Math.max(tt, Math.min(lt, Tt))
        }
        function em(Tt, tt) {
            return (Tt % tt + tt) % tt
        }
        function Fu(Tt, tt, lt) {
            return (1 - lt) * Tt + lt * tt
        }
        function tm(Tt) {
            return !(Tt & Tt - 1) && Tt !== 0
        }
        function Km(Tt) {
            return Math.pow(2, Math.ceil(Math.log(Tt) / Math.LN2))
        }
        function gp(Tt) {
            return Math.pow(2, Math.floor(Math.log(Tt) / Math.LN2))
        }
        function ws(Tt, tt) {
            switch (tt.constructor) {
            case Float32Array:
                return Tt;
            case Uint32Array:
                return Tt / 4294967295;
            case Uint16Array:
                return Tt / 65535;
            case Uint8Array:
                return Tt / 255;
            case Int32Array:
                return Math.max(Tt / 2147483647, -1);
            case Int16Array:
                return Math.max(Tt / 32767, -1);
            case Int8Array:
                return Math.max(Tt / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function oo(Tt, tt) {
            switch (tt.constructor) {
            case Float32Array:
                return Tt;
            case Uint32Array:
                return Math.round(4294967295 * Tt);
            case Uint16Array:
                return Math.round(65535 * Tt);
            case Uint8Array:
                return Math.round(255 * Tt);
            case Int32Array:
                return Math.round(2147483647 * Tt);
            case Int16Array:
                return Math.round(32767 * Tt);
            case Int8Array:
                return Math.round(127 * Tt);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const ev = {
            DEG2RAD: Zl,
            RAD2DEG: _u,
            generateUUID: Ms,
            clamp: qo,
            euclideanModulo: em,
            mapLinear: function(Tt, tt, lt, mt, ft) {
                return mt + (Tt - tt) * (ft - mt) / (lt - tt)
            },
            inverseLerp: function(Tt, tt, lt) {
                return Tt !== tt ? (lt - Tt) / (tt - Tt) : 0
            },
            lerp: Fu,
            damp: function(Tt, tt, lt, mt) {
                return Fu(Tt, tt, 1 - Math.exp(-lt * mt))
            },
            pingpong: function(Tt, tt=1) {
                return tt - Math.abs(em(Tt, 2 * tt) - tt)
            },
            smoothstep: function(Tt, tt, lt) {
                return Tt <= tt ? 0 : Tt >= lt ? 1 : (Tt = (Tt - tt) / (lt - tt)) * Tt * (3 - 2 * Tt)
            },
            smootherstep: function(Tt, tt, lt) {
                return Tt <= tt ? 0 : Tt >= lt ? 1 : (Tt = (Tt - tt) / (lt - tt)) * Tt * Tt * (Tt * (6 * Tt - 15) + 10)
            },
            randInt: function(Tt, tt) {
                return Tt + Math.floor(Math.random() * (tt - Tt + 1))
            },
            randFloat: function(Tt, tt) {
                return Tt + Math.random() * (tt - Tt)
            },
            randFloatSpread: function(Tt) {
                return Tt * (.5 - Math.random())
            },
            seededRandom: function(Tt) {
                Tt !== void 0 && (Z_ = Tt);
                let tt = Z_ += 1831565813;
                return tt = Math.imul(tt ^ tt >>> 15, 1 | tt),
                tt ^= tt + Math.imul(tt ^ tt >>> 7, 61 | tt),
                ((tt ^ tt >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(Tt) {
                return Tt * Zl
            },
            radToDeg: function(Tt) {
                return Tt * _u
            },
            isPowerOfTwo: tm,
            ceilPowerOfTwo: Km,
            floorPowerOfTwo: gp,
            setQuaternionFromProperEuler: function(Tt, tt, lt, mt, ft) {
                const xt = Math.cos
                  , Ct = Math.sin
                  , Mt = xt(lt / 2)
                  , Lt = Ct(lt / 2)
                  , Nt = xt((tt + mt) / 2)
                  , jt = Ct((tt + mt) / 2)
                  , Wt = xt((tt - mt) / 2)
                  , Qt = Ct((tt - mt) / 2)
                  , qt = xt((mt - tt) / 2)
                  , Xt = Ct((mt - tt) / 2);
                switch (ft) {
                case "XYX":
                    Tt.set(Mt * jt, Lt * Wt, Lt * Qt, Mt * Nt);
                    break;
                case "YZY":
                    Tt.set(Lt * Qt, Mt * jt, Lt * Wt, Mt * Nt);
                    break;
                case "ZXZ":
                    Tt.set(Lt * Wt, Lt * Qt, Mt * jt, Mt * Nt);
                    break;
                case "XZX":
                    Tt.set(Mt * jt, Lt * Xt, Lt * qt, Mt * Nt);
                    break;
                case "YXY":
                    Tt.set(Lt * qt, Mt * jt, Lt * Xt, Mt * Nt);
                    break;
                case "ZYZ":
                    Tt.set(Lt * Xt, Lt * qt, Mt * jt, Mt * Nt);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + ft)
                }
            },
            normalize: oo,
            denormalize: ws
        };
        class mn {
            constructor(tt=0, lt=0) {
                mn.prototype.isVector2 = !0,
                this.x = tt,
                this.y = lt
            }
            get width() {
                return this.x
            }
            set width(tt) {
                this.x = tt
            }
            get height() {
                return this.y
            }
            set height(tt) {
                this.y = tt
            }
            set(tt, lt) {
                return this.x = tt,
                this.y = lt,
                this
            }
            setScalar(tt) {
                return this.x = tt,
                this.y = tt,
                this
            }
            setX(tt) {
                return this.x = tt,
                this
            }
            setY(tt) {
                return this.y = tt,
                this
            }
            setComponent(tt, lt) {
                switch (tt) {
                case 0:
                    this.x = lt;
                    break;
                case 1:
                    this.y = lt;
                    break;
                default:
                    throw new Error("index is out of range: " + tt)
                }
                return this
            }
            getComponent(tt) {
                switch (tt) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + tt)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(tt) {
                return this.x = tt.x,
                this.y = tt.y,
                this
            }
            add(tt) {
                return this.x += tt.x,
                this.y += tt.y,
                this
            }
            addScalar(tt) {
                return this.x += tt,
                this.y += tt,
                this
            }
            addVectors(tt, lt) {
                return this.x = tt.x + lt.x,
                this.y = tt.y + lt.y,
                this
            }
            addScaledVector(tt, lt) {
                return this.x += tt.x * lt,
                this.y += tt.y * lt,
                this
            }
            sub(tt) {
                return this.x -= tt.x,
                this.y -= tt.y,
                this
            }
            subScalar(tt) {
                return this.x -= tt,
                this.y -= tt,
                this
            }
            subVectors(tt, lt) {
                return this.x = tt.x - lt.x,
                this.y = tt.y - lt.y,
                this
            }
            multiply(tt) {
                return this.x *= tt.x,
                this.y *= tt.y,
                this
            }
            multiplyScalar(tt) {
                return this.x *= tt,
                this.y *= tt,
                this
            }
            divide(tt) {
                return this.x /= tt.x,
                this.y /= tt.y,
                this
            }
            divideScalar(tt) {
                return this.multiplyScalar(1 / tt)
            }
            applyMatrix3(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = tt.elements;
                return this.x = ft[0] * lt + ft[3] * mt + ft[6],
                this.y = ft[1] * lt + ft[4] * mt + ft[7],
                this
            }
            min(tt) {
                return this.x = Math.min(this.x, tt.x),
                this.y = Math.min(this.y, tt.y),
                this
            }
            max(tt) {
                return this.x = Math.max(this.x, tt.x),
                this.y = Math.max(this.y, tt.y),
                this
            }
            clamp(tt, lt) {
                return this.x = Math.max(tt.x, Math.min(lt.x, this.x)),
                this.y = Math.max(tt.y, Math.min(lt.y, this.y)),
                this
            }
            clampScalar(tt, lt) {
                return this.x = Math.max(tt, Math.min(lt, this.x)),
                this.y = Math.max(tt, Math.min(lt, this.y)),
                this
            }
            clampLength(tt, lt) {
                const mt = this.length();
                return this.divideScalar(mt || 1).multiplyScalar(Math.max(tt, Math.min(lt, mt)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(tt) {
                return this.x * tt.x + this.y * tt.y
            }
            cross(tt) {
                return this.x * tt.y - this.y * tt.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(tt) {
                const lt = Math.sqrt(this.lengthSq() * tt.lengthSq());
                if (lt === 0)
                    return Math.PI / 2;
                const mt = this.dot(tt) / lt;
                return Math.acos(qo(mt, -1, 1))
            }
            distanceTo(tt) {
                return Math.sqrt(this.distanceToSquared(tt))
            }
            distanceToSquared(tt) {
                const lt = this.x - tt.x
                  , mt = this.y - tt.y;
                return lt * lt + mt * mt
            }
            manhattanDistanceTo(tt) {
                return Math.abs(this.x - tt.x) + Math.abs(this.y - tt.y)
            }
            setLength(tt) {
                return this.normalize().multiplyScalar(tt)
            }
            lerp(tt, lt) {
                return this.x += (tt.x - this.x) * lt,
                this.y += (tt.y - this.y) * lt,
                this
            }
            lerpVectors(tt, lt, mt) {
                return this.x = tt.x + (lt.x - tt.x) * mt,
                this.y = tt.y + (lt.y - tt.y) * mt,
                this
            }
            equals(tt) {
                return tt.x === this.x && tt.y === this.y
            }
            fromArray(tt, lt=0) {
                return this.x = tt[lt],
                this.y = tt[lt + 1],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.x,
                tt[lt + 1] = this.y,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.x = tt.getX(lt),
                this.y = tt.getY(lt),
                this
            }
            rotateAround(tt, lt) {
                const mt = Math.cos(lt)
                  , ft = Math.sin(lt)
                  , xt = this.x - tt.x
                  , Ct = this.y - tt.y;
                return this.x = xt * mt - Ct * ft + tt.x,
                this.y = xt * ft + Ct * mt + tt.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class lo {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                lo.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                tt !== void 0 && this.set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt)
            }
            set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                const jt = this.elements;
                return jt[0] = tt,
                jt[1] = ft,
                jt[2] = Mt,
                jt[3] = lt,
                jt[4] = xt,
                jt[5] = Lt,
                jt[6] = mt,
                jt[7] = Ct,
                jt[8] = Nt,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                return lt[0] = mt[0],
                lt[1] = mt[1],
                lt[2] = mt[2],
                lt[3] = mt[3],
                lt[4] = mt[4],
                lt[5] = mt[5],
                lt[6] = mt[6],
                lt[7] = mt[7],
                lt[8] = mt[8],
                this
            }
            extractBasis(tt, lt, mt) {
                return tt.setFromMatrix3Column(this, 0),
                lt.setFromMatrix3Column(this, 1),
                mt.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(tt) {
                const lt = tt.elements;
                return this.set(lt[0], lt[4], lt[8], lt[1], lt[5], lt[9], lt[2], lt[6], lt[10]),
                this
            }
            multiply(tt) {
                return this.multiplyMatrices(this, tt)
            }
            premultiply(tt) {
                return this.multiplyMatrices(tt, this)
            }
            multiplyMatrices(tt, lt) {
                const mt = tt.elements
                  , ft = lt.elements
                  , xt = this.elements
                  , Ct = mt[0]
                  , Mt = mt[3]
                  , Lt = mt[6]
                  , Nt = mt[1]
                  , jt = mt[4]
                  , Wt = mt[7]
                  , Qt = mt[2]
                  , qt = mt[5]
                  , Xt = mt[8]
                  , Zt = ft[0]
                  , Yt = ft[3]
                  , sr = ft[6]
                  , er = ft[1]
                  , rr = ft[4]
                  , xr = ft[7]
                  , br = ft[2]
                  , yr = ft[5]
                  , Pr = ft[8];
                return xt[0] = Ct * Zt + Mt * er + Lt * br,
                xt[3] = Ct * Yt + Mt * rr + Lt * yr,
                xt[6] = Ct * sr + Mt * xr + Lt * Pr,
                xt[1] = Nt * Zt + jt * er + Wt * br,
                xt[4] = Nt * Yt + jt * rr + Wt * yr,
                xt[7] = Nt * sr + jt * xr + Wt * Pr,
                xt[2] = Qt * Zt + qt * er + Xt * br,
                xt[5] = Qt * Yt + qt * rr + Xt * yr,
                xt[8] = Qt * sr + qt * xr + Xt * Pr,
                this
            }
            multiplyScalar(tt) {
                const lt = this.elements;
                return lt[0] *= tt,
                lt[3] *= tt,
                lt[6] *= tt,
                lt[1] *= tt,
                lt[4] *= tt,
                lt[7] *= tt,
                lt[2] *= tt,
                lt[5] *= tt,
                lt[8] *= tt,
                this
            }
            determinant() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[1]
                  , ft = tt[2]
                  , xt = tt[3]
                  , Ct = tt[4]
                  , Mt = tt[5]
                  , Lt = tt[6]
                  , Nt = tt[7]
                  , jt = tt[8];
                return lt * Ct * jt - lt * Mt * Nt - mt * xt * jt + mt * Mt * Lt + ft * xt * Nt - ft * Ct * Lt
            }
            invert() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[1]
                  , ft = tt[2]
                  , xt = tt[3]
                  , Ct = tt[4]
                  , Mt = tt[5]
                  , Lt = tt[6]
                  , Nt = tt[7]
                  , jt = tt[8]
                  , Wt = jt * Ct - Mt * Nt
                  , Qt = Mt * Lt - jt * xt
                  , qt = Nt * xt - Ct * Lt
                  , Xt = lt * Wt + mt * Qt + ft * qt;
                if (Xt === 0)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const Zt = 1 / Xt;
                return tt[0] = Wt * Zt,
                tt[1] = (ft * Nt - jt * mt) * Zt,
                tt[2] = (Mt * mt - ft * Ct) * Zt,
                tt[3] = Qt * Zt,
                tt[4] = (jt * lt - ft * Lt) * Zt,
                tt[5] = (ft * xt - Mt * lt) * Zt,
                tt[6] = qt * Zt,
                tt[7] = (mt * Lt - Nt * lt) * Zt,
                tt[8] = (Ct * lt - mt * xt) * Zt,
                this
            }
            transpose() {
                let tt;
                const lt = this.elements;
                return tt = lt[1],
                lt[1] = lt[3],
                lt[3] = tt,
                tt = lt[2],
                lt[2] = lt[6],
                lt[6] = tt,
                tt = lt[5],
                lt[5] = lt[7],
                lt[7] = tt,
                this
            }
            getNormalMatrix(tt) {
                return this.setFromMatrix4(tt).invert().transpose()
            }
            transposeIntoArray(tt) {
                const lt = this.elements;
                return tt[0] = lt[0],
                tt[1] = lt[3],
                tt[2] = lt[6],
                tt[3] = lt[1],
                tt[4] = lt[4],
                tt[5] = lt[7],
                tt[6] = lt[2],
                tt[7] = lt[5],
                tt[8] = lt[8],
                this
            }
            setUvTransform(tt, lt, mt, ft, xt, Ct, Mt) {
                const Lt = Math.cos(xt)
                  , Nt = Math.sin(xt);
                return this.set(mt * Lt, mt * Nt, -mt * (Lt * Ct + Nt * Mt) + Ct + tt, -ft * Nt, ft * Lt, -ft * (-Nt * Ct + Lt * Mt) + Mt + lt, 0, 0, 1),
                this
            }
            scale(tt, lt) {
                return this.premultiply(rm.makeScale(tt, lt)),
                this
            }
            rotate(tt) {
                return this.premultiply(rm.makeRotation(-tt)),
                this
            }
            translate(tt, lt) {
                return this.premultiply(rm.makeTranslation(tt, lt)),
                this
            }
            makeTranslation(tt, lt) {
                return tt.isVector2 ? this.set(1, 0, tt.x, 0, 1, tt.y, 0, 0, 1) : this.set(1, 0, tt, 0, 1, lt, 0, 0, 1),
                this
            }
            makeRotation(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(lt, -mt, 0, mt, lt, 0, 0, 0, 1),
                this
            }
            makeScale(tt, lt) {
                return this.set(tt, 0, 0, 0, lt, 0, 0, 0, 1),
                this
            }
            equals(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                for (let ft = 0; ft < 9; ft++)
                    if (lt[ft] !== mt[ft])
                        return !1;
                return !0
            }
            fromArray(tt, lt=0) {
                for (let mt = 0; mt < 9; mt++)
                    this.elements[mt] = tt[mt + lt];
                return this
            }
            toArray(tt=[], lt=0) {
                const mt = this.elements;
                return tt[lt] = mt[0],
                tt[lt + 1] = mt[1],
                tt[lt + 2] = mt[2],
                tt[lt + 3] = mt[3],
                tt[lt + 4] = mt[4],
                tt[lt + 5] = mt[5],
                tt[lt + 6] = mt[6],
                tt[lt + 7] = mt[7],
                tt[lt + 8] = mt[8],
                tt
            }
            clone() {
                return new this.constructor().fromArray(this.elements)
            }
        }
        const rm = new lo;
        function tv(Tt) {
            for (let tt = Tt.length - 1; tt >= 0; --tt)
                if (Tt[tt] >= 65535)
                    return !0;
            return !1
        }
        const Jm = {
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        };
        function vu(Tt, tt) {
            return new Jm[Tt](tt)
        }
        function yu(Tt) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", Tt)
        }
        function Zm() {
            const Tt = yu("canvas");
            return Tt.style.display = "block",
            Tt
        }
        const _f = {};
        function xu(Tt) {
            Tt in _f || (_f[Tt] = !0,
            console.warn(Tt))
        }
        const _g = new lo().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
          , rv = new lo().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
          , bu = {
            [Xo]: {
                transfer: No,
                primaries: Wo,
                toReference: Tt => Tt,
                fromReference: Tt => Tt
            },
            [jo]: {
                transfer: Vo,
                primaries: Wo,
                toReference: Tt => Tt.convertSRGBToLinear(),
                fromReference: Tt => Tt.convertLinearToSRGB()
            },
            [hu]: {
                transfer: No,
                primaries: Ou,
                toReference: Tt => Tt.applyMatrix3(rv),
                fromReference: Tt => Tt.applyMatrix3(_g)
            },
            [dp]: {
                transfer: Vo,
                primaries: Ou,
                toReference: Tt => Tt.convertSRGBToLinear().applyMatrix3(rv),
                fromReference: Tt => Tt.applyMatrix3(_g).convertLinearToSRGB()
            }
        }
          , R0 = new Set([Xo, hu])
          , Do = {
            enabled: !0,
            _workingColorSpace: Xo,
            get legacyMode() {
                return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                !this.enabled
            },
            set legacyMode(Tt) {
                console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                this.enabled = !Tt
            },
            get workingColorSpace() {
                return this._workingColorSpace
            },
            set workingColorSpace(Tt) {
                if (!R0.has(Tt))
                    throw new Error(`Unsupported working color space, "${
Tt}".`);
                this._workingColorSpace = Tt
            },
            convert: function(Tt, tt, lt) {
                if (this.enabled === !1 || tt === lt || !tt || !lt)
                    return Tt;
                const mt = bu[tt].toReference;
                return (0,
                bu[lt].fromReference)(mt(Tt))
            },
            fromWorkingColorSpace: function(Tt, tt) {
                return this.convert(Tt, this._workingColorSpace, tt)
            },
            toWorkingColorSpace: function(Tt, tt) {
                return this.convert(Tt, tt, this._workingColorSpace)
            },
            getPrimaries: function(Tt) {
                return bu[Tt].primaries
            },
            getTransfer: function(Tt) {
                return Tt === Oo || Tt === ps ? No : bu[Tt].transfer
            }
        };
        function Uu(Tt) {
            return Tt < .04045 ? .0773993808 * Tt : Math.pow(.9478672986 * Tt + .0521327014, 2.4)
        }
        function nm(Tt) {
            return Tt < .0031308 ? 12.92 * Tt : 1.055 * Math.pow(Tt, .41666) - .055
        }
        let ju;
        class e_ {
            static getDataURL(tt, lt=!1) {
                if (/^data:/i.test(tt.src) || typeof HTMLCanvasElement > "u")
                    return tt.src;
                let mt;
                if (tt instanceof HTMLCanvasElement)
                    mt = tt;
                else {
                    ju === void 0 && (ju = yu("canvas")),
                    ju.width = tt.width,
                    ju.height = tt.height;
                    const ft = ju.getContext("2d");
                    tt instanceof ImageData ? ft.putImageData(tt, 0, 0) : ft.drawImage(tt, 0, 0, tt.width, tt.height),
                    mt = ju
                }
                return !lt && (mt.width > 2048 || mt.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", tt),
                mt.toDataURL("image/jpeg", .6)) : mt.toDataURL("image/png")
            }
            static sRGBToLinear(tt) {
                if (typeof HTMLImageElement < "u" && tt instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && tt instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && tt instanceof ImageBitmap) {
                    const lt = yu("canvas");
                    lt.width = tt.width,
                    lt.height = tt.height;
                    const mt = lt.getContext("2d");
                    mt.drawImage(tt, 0, 0, tt.width, tt.height);
                    const ft = mt.getImageData(0, 0, tt.width, tt.height)
                      , xt = ft.data;
                    for (let Ct = 0; Ct < xt.length; Ct++)
                        xt[Ct] = 255 * Uu(xt[Ct] / 255);
                    return mt.putImageData(ft, 0, 0),
                    lt
                }
                if (tt.data) {
                    const lt = tt.data.slice(0);
                    for (let mt = 0; mt < lt.length; mt++)
                        lt instanceof Uint8Array || lt instanceof Uint8ClampedArray ? lt[mt] = Math.floor(255 * Uu(lt[mt] / 255)) : lt[mt] = Uu(lt[mt]);
                    return {
                        data: lt,
                        width: tt.width,
                        height: tt.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                tt
            }
        }
        let t_ = 0;
        class ga {
            constructor(tt=null) {
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: t_++
                }),
                this.uuid = Ms(),
                this.data = tt,
                this.version = 0
            }
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string";
                if (!lt && tt.images[this.uuid] !== void 0)
                    return tt.images[this.uuid];
                const mt = {
                    uuid: this.uuid,
                    url: ""
                }
                  , ft = this.data;
                if (ft !== null) {
                    let xt;
                    if (Array.isArray(ft)) {
                        xt = [];
                        for (let Ct = 0, Mt = ft.length; Ct < Mt; Ct++)
                            ft[Ct].isDataTexture ? xt.push(r_(ft[Ct].image)) : xt.push(r_(ft[Ct]))
                    } else
                        xt = r_(ft);
                    mt.url = xt
                }
                return lt || (tt.images[this.uuid] = mt),
                mt
            }
        }
        function r_(Tt) {
            if (typeof HTMLImageElement < "u" && Tt instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Tt instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Tt instanceof ImageBitmap)
                return e_.getDataURL(Tt);
            if (Tt.data) {
                let tt = [];
                try {
                    tt = Array.from(Tt.data)
                } catch (lt) {
                    lt.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(lt),
                    tt = Tt.data
                }
                return {
                    data: tt,
                    width: Tt.width,
                    height: Tt.height,
                    type: Tt.data.constructor.name
                }
            }
            return Tt.url !== void 0 ? Tt.url : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let I0 = 0;
        class Ho extends As {
            constructor(tt=Ho.DEFAULT_IMAGE, lt=Ho.DEFAULT_MAPPING, mt=wn, ft=wn, xt=Rn, Ct=vo, Mt=as, Lt=$n, Nt=Ho.DEFAULT_ANISOTROPY, jt=Oo) {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: I0++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.source = new ga(tt),
                this.mipmaps = [],
                this.mapping = lt,
                this.channel = 0,
                this.wrapS = mt,
                this.wrapT = ft,
                this.magFilter = xt,
                this.minFilter = Ct,
                this.anisotropy = Nt,
                this.format = Mt,
                this.internalFormat = null,
                this.type = Lt,
                this.offset = new mn(0,0),
                this.repeat = new mn(1,1),
                this.center = new mn(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new lo,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                typeof jt == "string" ? this.colorSpace = jt : (xu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = jt === Ol ? jo : Oo),
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1,
                tt instanceof ImageData && (this.needsUpdate = !0)
            }
            get image() {
                return this.source.data
            }
            set image(tt=null) {
                this.source.data = tt
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.name = tt.name,
                this.source = tt.source,
                this.mipmaps = tt.mipmaps.slice(0),
                this.mapping = tt.mapping,
                this.channel = tt.channel,
                this.wrapS = tt.wrapS,
                this.wrapT = tt.wrapT,
                this.magFilter = tt.magFilter,
                this.minFilter = tt.minFilter,
                this.anisotropy = tt.anisotropy,
                this.format = tt.format,
                this.internalFormat = tt.internalFormat,
                this.type = tt.type,
                this.offset.copy(tt.offset),
                this.repeat.copy(tt.repeat),
                this.center.copy(tt.center),
                this.rotation = tt.rotation,
                this.matrixAutoUpdate = tt.matrixAutoUpdate,
                this.matrix.copy(tt.matrix),
                this.generateMipmaps = tt.generateMipmaps,
                this.premultiplyAlpha = tt.premultiplyAlpha,
                this.flipY = tt.flipY,
                this.unpackAlignment = tt.unpackAlignment,
                this.colorSpace = tt.colorSpace,
                this.userData = JSON.parse(JSON.stringify(tt.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string";
                if (!lt && tt.textures && tt.textures[this.uuid] !== void 0)
                    return tt.textures[this.uuid];
                const mt = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(tt).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    encoding: this.colorSpace === jo ? Ol : ts,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (mt.userData = this.userData),
                !lt && tt.textures && (tt.textures[this.uuid] = mt),
                mt
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(tt) {
                if (this.mapping !== jr)
                    return tt;
                if (tt.applyMatrix3(this.matrix),
                tt.x < 0 || tt.x > 1)
                    switch (this.wrapS) {
                    case Tn:
                        tt.x = tt.x - Math.floor(tt.x);
                        break;
                    case wn:
                        tt.x = tt.x < 0 ? 0 : 1;
                        break;
                    case Cn:
                        Math.abs(Math.floor(tt.x) % 2) === 1 ? tt.x = Math.ceil(tt.x) - tt.x : tt.x = tt.x - Math.floor(tt.x)
                    }
                if (tt.y < 0 || tt.y > 1)
                    switch (this.wrapT) {
                    case Tn:
                        tt.y = tt.y - Math.floor(tt.y);
                        break;
                    case wn:
                        tt.y = tt.y < 0 ? 0 : 1;
                        break;
                    case Cn:
                        Math.abs(Math.floor(tt.y) % 2) === 1 ? tt.y = Math.ceil(tt.y) - tt.y : tt.y = tt.y - Math.floor(tt.y)
                    }
                return this.flipY && (tt.y = 1 - tt.y),
                tt
            }
            set needsUpdate(tt) {
                tt === !0 && (this.version++,
                this.source.needsUpdate = !0,
                this.dispatchEvent({
                    type: "update"
                }))
            }
            get encoding() {
                return xu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace === jo ? Ol : ts
            }
            set encoding(tt) {
                xu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = tt === Ol ? jo : Oo
            }
        }
        Ho.DEFAULT_IMAGE = null,
        Ho.DEFAULT_MAPPING = jr,
        Ho.DEFAULT_ANISOTROPY = 1;
        class Lo {
            constructor(tt=0, lt=0, mt=0, ft=1) {
                Lo.prototype.isVector4 = !0,
                this.x = tt,
                this.y = lt,
                this.z = mt,
                this.w = ft
            }
            get width() {
                return this.z
            }
            set width(tt) {
                this.z = tt
            }
            get height() {
                return this.w
            }
            set height(tt) {
                this.w = tt
            }
            set(tt, lt, mt, ft) {
                return this.x = tt,
                this.y = lt,
                this.z = mt,
                this.w = ft,
                this
            }
            setScalar(tt) {
                return this.x = tt,
                this.y = tt,
                this.z = tt,
                this.w = tt,
                this
            }
            setX(tt) {
                return this.x = tt,
                this
            }
            setY(tt) {
                return this.y = tt,
                this
            }
            setZ(tt) {
                return this.z = tt,
                this
            }
            setW(tt) {
                return this.w = tt,
                this
            }
            setComponent(tt, lt) {
                switch (tt) {
                case 0:
                    this.x = lt;
                    break;
                case 1:
                    this.y = lt;
                    break;
                case 2:
                    this.z = lt;
                    break;
                case 3:
                    this.w = lt;
                    break;
                default:
                    throw new Error("index is out of range: " + tt)
                }
                return this
            }
            getComponent(tt) {
                switch (tt) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + tt)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(tt) {
                return this.x = tt.x,
                this.y = tt.y,
                this.z = tt.z,
                this.w = tt.w !== void 0 ? tt.w : 1,
                this
            }
            add(tt) {
                return this.x += tt.x,
                this.y += tt.y,
                this.z += tt.z,
                this.w += tt.w,
                this
            }
            addScalar(tt) {
                return this.x += tt,
                this.y += tt,
                this.z += tt,
                this.w += tt,
                this
            }
            addVectors(tt, lt) {
                return this.x = tt.x + lt.x,
                this.y = tt.y + lt.y,
                this.z = tt.z + lt.z,
                this.w = tt.w + lt.w,
                this
            }
            addScaledVector(tt, lt) {
                return this.x += tt.x * lt,
                this.y += tt.y * lt,
                this.z += tt.z * lt,
                this.w += tt.w * lt,
                this
            }
            sub(tt) {
                return this.x -= tt.x,
                this.y -= tt.y,
                this.z -= tt.z,
                this.w -= tt.w,
                this
            }
            subScalar(tt) {
                return this.x -= tt,
                this.y -= tt,
                this.z -= tt,
                this.w -= tt,
                this
            }
            subVectors(tt, lt) {
                return this.x = tt.x - lt.x,
                this.y = tt.y - lt.y,
                this.z = tt.z - lt.z,
                this.w = tt.w - lt.w,
                this
            }
            multiply(tt) {
                return this.x *= tt.x,
                this.y *= tt.y,
                this.z *= tt.z,
                this.w *= tt.w,
                this
            }
            multiplyScalar(tt) {
                return this.x *= tt,
                this.y *= tt,
                this.z *= tt,
                this.w *= tt,
                this
            }
            applyMatrix4(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = this.w
                  , Ct = tt.elements;
                return this.x = Ct[0] * lt + Ct[4] * mt + Ct[8] * ft + Ct[12] * xt,
                this.y = Ct[1] * lt + Ct[5] * mt + Ct[9] * ft + Ct[13] * xt,
                this.z = Ct[2] * lt + Ct[6] * mt + Ct[10] * ft + Ct[14] * xt,
                this.w = Ct[3] * lt + Ct[7] * mt + Ct[11] * ft + Ct[15] * xt,
                this
            }
            divideScalar(tt) {
                return this.multiplyScalar(1 / tt)
            }
            setAxisAngleFromQuaternion(tt) {
                this.w = 2 * Math.acos(tt.w);
                const lt = Math.sqrt(1 - tt.w * tt.w);
                return lt < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = tt.x / lt,
                this.y = tt.y / lt,
                this.z = tt.z / lt),
                this
            }
            setAxisAngleFromRotationMatrix(tt) {
                let lt, mt, ft, xt;
                const Lt = tt.elements
                  , Nt = Lt[0]
                  , jt = Lt[4]
                  , Wt = Lt[8]
                  , Qt = Lt[1]
                  , qt = Lt[5]
                  , Xt = Lt[9]
                  , Zt = Lt[2]
                  , Yt = Lt[6]
                  , sr = Lt[10];
                if (Math.abs(jt - Qt) < .01 && Math.abs(Wt - Zt) < .01 && Math.abs(Xt - Yt) < .01) {
                    if (Math.abs(jt + Qt) < .1 && Math.abs(Wt + Zt) < .1 && Math.abs(Xt + Yt) < .1 && Math.abs(Nt + qt + sr - 3) < .1)
                        return this.set(1, 0, 0, 0),
                        this;
                    lt = Math.PI;
                    const rr = (Nt + 1) / 2
                      , xr = (qt + 1) / 2
                      , br = (sr + 1) / 2
                      , yr = (jt + Qt) / 4
                      , Pr = (Wt + Zt) / 4
                      , zr = (Xt + Yt) / 4;
                    return rr > xr && rr > br ? rr < .01 ? (mt = 0,
                    ft = .707106781,
                    xt = .707106781) : (mt = Math.sqrt(rr),
                    ft = yr / mt,
                    xt = Pr / mt) : xr > br ? xr < .01 ? (mt = .707106781,
                    ft = 0,
                    xt = .707106781) : (ft = Math.sqrt(xr),
                    mt = yr / ft,
                    xt = zr / ft) : br < .01 ? (mt = .707106781,
                    ft = .707106781,
                    xt = 0) : (xt = Math.sqrt(br),
                    mt = Pr / xt,
                    ft = zr / xt),
                    this.set(mt, ft, xt, lt),
                    this
                }
                let er = Math.sqrt((Yt - Xt) * (Yt - Xt) + (Wt - Zt) * (Wt - Zt) + (Qt - jt) * (Qt - jt));
                return Math.abs(er) < .001 && (er = 1),
                this.x = (Yt - Xt) / er,
                this.y = (Wt - Zt) / er,
                this.z = (Qt - jt) / er,
                this.w = Math.acos((Nt + qt + sr - 1) / 2),
                this
            }
            min(tt) {
                return this.x = Math.min(this.x, tt.x),
                this.y = Math.min(this.y, tt.y),
                this.z = Math.min(this.z, tt.z),
                this.w = Math.min(this.w, tt.w),
                this
            }
            max(tt) {
                return this.x = Math.max(this.x, tt.x),
                this.y = Math.max(this.y, tt.y),
                this.z = Math.max(this.z, tt.z),
                this.w = Math.max(this.w, tt.w),
                this
            }
            clamp(tt, lt) {
                return this.x = Math.max(tt.x, Math.min(lt.x, this.x)),
                this.y = Math.max(tt.y, Math.min(lt.y, this.y)),
                this.z = Math.max(tt.z, Math.min(lt.z, this.z)),
                this.w = Math.max(tt.w, Math.min(lt.w, this.w)),
                this
            }
            clampScalar(tt, lt) {
                return this.x = Math.max(tt, Math.min(lt, this.x)),
                this.y = Math.max(tt, Math.min(lt, this.y)),
                this.z = Math.max(tt, Math.min(lt, this.z)),
                this.w = Math.max(tt, Math.min(lt, this.w)),
                this
            }
            clampLength(tt, lt) {
                const mt = this.length();
                return this.divideScalar(mt || 1).multiplyScalar(Math.max(tt, Math.min(lt, mt)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(tt) {
                return this.x * tt.x + this.y * tt.y + this.z * tt.z + this.w * tt.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(tt) {
                return this.normalize().multiplyScalar(tt)
            }
            lerp(tt, lt) {
                return this.x += (tt.x - this.x) * lt,
                this.y += (tt.y - this.y) * lt,
                this.z += (tt.z - this.z) * lt,
                this.w += (tt.w - this.w) * lt,
                this
            }
            lerpVectors(tt, lt, mt) {
                return this.x = tt.x + (lt.x - tt.x) * mt,
                this.y = tt.y + (lt.y - tt.y) * mt,
                this.z = tt.z + (lt.z - tt.z) * mt,
                this.w = tt.w + (lt.w - tt.w) * mt,
                this
            }
            equals(tt) {
                return tt.x === this.x && tt.y === this.y && tt.z === this.z && tt.w === this.w
            }
            fromArray(tt, lt=0) {
                return this.x = tt[lt],
                this.y = tt[lt + 1],
                this.z = tt[lt + 2],
                this.w = tt[lt + 3],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.x,
                tt[lt + 1] = this.y,
                tt[lt + 2] = this.z,
                tt[lt + 3] = this.w,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.x = tt.getX(lt),
                this.y = tt.getY(lt),
                this.z = tt.getZ(lt),
                this.w = tt.getW(lt),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class nv extends As {
            constructor(tt=1, lt=1, mt={}) {
                super(),
                this.isRenderTarget = !0,
                this.width = tt,
                this.height = lt,
                this.depth = 1,
                this.scissor = new Lo(0,0,tt,lt),
                this.scissorTest = !1,
                this.viewport = new Lo(0,0,tt,lt);
                const ft = {
                    width: tt,
                    height: lt,
                    depth: 1
                };
                mt.encoding !== void 0 && (xu("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
                mt.colorSpace = mt.encoding === Ol ? jo : Oo),
                mt = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: Rn,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, mt),
                this.texture = new Ho(ft,mt.mapping,mt.wrapS,mt.wrapT,mt.magFilter,mt.minFilter,mt.format,mt.type,mt.anisotropy,mt.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.flipY = !1,
                this.texture.generateMipmaps = mt.generateMipmaps,
                this.texture.internalFormat = mt.internalFormat,
                this.depthBuffer = mt.depthBuffer,
                this.stencilBuffer = mt.stencilBuffer,
                this.depthTexture = mt.depthTexture,
                this.samples = mt.samples
            }
            setSize(tt, lt, mt=1) {
                this.width === tt && this.height === lt && this.depth === mt || (this.width = tt,
                this.height = lt,
                this.depth = mt,
                this.texture.image.width = tt,
                this.texture.image.height = lt,
                this.texture.image.depth = mt,
                this.dispose()),
                this.viewport.set(0, 0, tt, lt),
                this.scissor.set(0, 0, tt, lt)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                this.width = tt.width,
                this.height = tt.height,
                this.depth = tt.depth,
                this.scissor.copy(tt.scissor),
                this.scissorTest = tt.scissorTest,
                this.viewport.copy(tt.viewport),
                this.texture = tt.texture.clone(),
                this.texture.isRenderTargetTexture = !0;
                const lt = Object.assign({}, tt.texture.image);
                return this.texture.source = new ga(lt),
                this.depthBuffer = tt.depthBuffer,
                this.stencilBuffer = tt.stencilBuffer,
                tt.depthTexture && (this.depthTexture = tt.depthTexture.clone()),
                this.samples = tt.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Rs extends nv {
            constructor(tt=1, lt=1, mt={}) {
                super(tt, lt, mt),
                this.isWebGLRenderTarget = !0
            }
        }
        class im extends Ho {
            constructor(tt=null, lt=1, mt=1, ft=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: tt,
                    width: lt,
                    height: mt,
                    depth: ft
                },
                this.magFilter = fn,
                this.minFilter = fn,
                this.wrapR = wn,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class n_ extends Rs {
            constructor(tt=1, lt=1, mt=1) {
                super(tt, lt),
                this.isWebGLArrayRenderTarget = !0,
                this.depth = mt,
                this.texture = new im(null,tt,lt,mt),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class i_ extends Ho {
            constructor(tt=null, lt=1, mt=1, ft=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: tt,
                    width: lt,
                    height: mt,
                    depth: ft
                },
                this.magFilter = fn,
                this.minFilter = fn,
                this.wrapR = wn,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class k0 extends Rs {
            constructor(tt=1, lt=1, mt=1) {
                super(tt, lt),
                this.isWebGL3DRenderTarget = !0,
                this.depth = mt,
                this.texture = new i_(null,tt,lt,mt),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class o_ extends Rs {
            constructor(tt=1, lt=1, mt=1, ft={}) {
                super(tt, lt, ft),
                this.isWebGLMultipleRenderTargets = !0;
                const xt = this.texture;
                this.texture = [];
                for (let Ct = 0; Ct < mt; Ct++)
                    this.texture[Ct] = xt.clone(),
                    this.texture[Ct].isRenderTargetTexture = !0
            }
            setSize(tt, lt, mt=1) {
                if (this.width !== tt || this.height !== lt || this.depth !== mt) {
                    this.width = tt,
                    this.height = lt,
                    this.depth = mt;
                    for (let ft = 0, xt = this.texture.length; ft < xt; ft++)
                        this.texture[ft].image.width = tt,
                        this.texture[ft].image.height = lt,
                        this.texture[ft].image.depth = mt;
                    this.dispose()
                }
                this.viewport.set(0, 0, tt, lt),
                this.scissor.set(0, 0, tt, lt)
            }
            copy(tt) {
                this.dispose(),
                this.width = tt.width,
                this.height = tt.height,
                this.depth = tt.depth,
                this.scissor.copy(tt.scissor),
                this.scissorTest = tt.scissorTest,
                this.viewport.copy(tt.viewport),
                this.depthBuffer = tt.depthBuffer,
                this.stencilBuffer = tt.stencilBuffer,
                tt.depthTexture !== null && (this.depthTexture = tt.depthTexture.clone()),
                this.texture.length = 0;
                for (let lt = 0, mt = tt.texture.length; lt < mt; lt++)
                    this.texture[lt] = tt.texture[lt].clone(),
                    this.texture[lt].isRenderTargetTexture = !0;
                return this
            }
        }
        class Is {
            constructor(tt=0, lt=0, mt=0, ft=1) {
                this.isQuaternion = !0,
                this._x = tt,
                this._y = lt,
                this._z = mt,
                this._w = ft
            }
            static slerpFlat(tt, lt, mt, ft, xt, Ct, Mt) {
                let Lt = mt[ft + 0]
                  , Nt = mt[ft + 1]
                  , jt = mt[ft + 2]
                  , Wt = mt[ft + 3];
                const Qt = xt[Ct + 0]
                  , qt = xt[Ct + 1]
                  , Xt = xt[Ct + 2]
                  , Zt = xt[Ct + 3];
                if (Mt === 0)
                    return tt[lt + 0] = Lt,
                    tt[lt + 1] = Nt,
                    tt[lt + 2] = jt,
                    void (tt[lt + 3] = Wt);
                if (Mt === 1)
                    return tt[lt + 0] = Qt,
                    tt[lt + 1] = qt,
                    tt[lt + 2] = Xt,
                    void (tt[lt + 3] = Zt);
                if (Wt !== Zt || Lt !== Qt || Nt !== qt || jt !== Xt) {
                    let Yt = 1 - Mt;
                    const sr = Lt * Qt + Nt * qt + jt * Xt + Wt * Zt
                      , er = sr >= 0 ? 1 : -1
                      , rr = 1 - sr * sr;
                    if (rr > Number.EPSILON) {
                        const br = Math.sqrt(rr)
                          , yr = Math.atan2(br, sr * er);
                        Yt = Math.sin(Yt * yr) / br,
                        Mt = Math.sin(Mt * yr) / br
                    }
                    const xr = Mt * er;
                    if (Lt = Lt * Yt + Qt * xr,
                    Nt = Nt * Yt + qt * xr,
                    jt = jt * Yt + Xt * xr,
                    Wt = Wt * Yt + Zt * xr,
                    Yt === 1 - Mt) {
                        const br = 1 / Math.sqrt(Lt * Lt + Nt * Nt + jt * jt + Wt * Wt);
                        Lt *= br,
                        Nt *= br,
                        jt *= br,
                        Wt *= br
                    }
                }
                tt[lt] = Lt,
                tt[lt + 1] = Nt,
                tt[lt + 2] = jt,
                tt[lt + 3] = Wt
            }
            static multiplyQuaternionsFlat(tt, lt, mt, ft, xt, Ct) {
                const Mt = mt[ft]
                  , Lt = mt[ft + 1]
                  , Nt = mt[ft + 2]
                  , jt = mt[ft + 3]
                  , Wt = xt[Ct]
                  , Qt = xt[Ct + 1]
                  , qt = xt[Ct + 2]
                  , Xt = xt[Ct + 3];
                return tt[lt] = Mt * Xt + jt * Wt + Lt * qt - Nt * Qt,
                tt[lt + 1] = Lt * Xt + jt * Qt + Nt * Wt - Mt * qt,
                tt[lt + 2] = Nt * Xt + jt * qt + Mt * Qt - Lt * Wt,
                tt[lt + 3] = jt * Xt - Mt * Wt - Lt * Qt - Nt * qt,
                tt
            }
            get x() {
                return this._x
            }
            set x(tt) {
                this._x = tt,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(tt) {
                this._y = tt,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(tt) {
                this._z = tt,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(tt) {
                this._w = tt,
                this._onChangeCallback()
            }
            set(tt, lt, mt, ft) {
                return this._x = tt,
                this._y = lt,
                this._z = mt,
                this._w = ft,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(tt) {
                return this._x = tt.x,
                this._y = tt.y,
                this._z = tt.z,
                this._w = tt.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(tt, lt) {
                const mt = tt._x
                  , ft = tt._y
                  , xt = tt._z
                  , Ct = tt._order
                  , Mt = Math.cos
                  , Lt = Math.sin
                  , Nt = Mt(mt / 2)
                  , jt = Mt(ft / 2)
                  , Wt = Mt(xt / 2)
                  , Qt = Lt(mt / 2)
                  , qt = Lt(ft / 2)
                  , Xt = Lt(xt / 2);
                switch (Ct) {
                case "XYZ":
                    this._x = Qt * jt * Wt + Nt * qt * Xt,
                    this._y = Nt * qt * Wt - Qt * jt * Xt,
                    this._z = Nt * jt * Xt + Qt * qt * Wt,
                    this._w = Nt * jt * Wt - Qt * qt * Xt;
                    break;
                case "YXZ":
                    this._x = Qt * jt * Wt + Nt * qt * Xt,
                    this._y = Nt * qt * Wt - Qt * jt * Xt,
                    this._z = Nt * jt * Xt - Qt * qt * Wt,
                    this._w = Nt * jt * Wt + Qt * qt * Xt;
                    break;
                case "ZXY":
                    this._x = Qt * jt * Wt - Nt * qt * Xt,
                    this._y = Nt * qt * Wt + Qt * jt * Xt,
                    this._z = Nt * jt * Xt + Qt * qt * Wt,
                    this._w = Nt * jt * Wt - Qt * qt * Xt;
                    break;
                case "ZYX":
                    this._x = Qt * jt * Wt - Nt * qt * Xt,
                    this._y = Nt * qt * Wt + Qt * jt * Xt,
                    this._z = Nt * jt * Xt - Qt * qt * Wt,
                    this._w = Nt * jt * Wt + Qt * qt * Xt;
                    break;
                case "YZX":
                    this._x = Qt * jt * Wt + Nt * qt * Xt,
                    this._y = Nt * qt * Wt + Qt * jt * Xt,
                    this._z = Nt * jt * Xt - Qt * qt * Wt,
                    this._w = Nt * jt * Wt - Qt * qt * Xt;
                    break;
                case "XZY":
                    this._x = Qt * jt * Wt - Nt * qt * Xt,
                    this._y = Nt * qt * Wt - Qt * jt * Xt,
                    this._z = Nt * jt * Xt + Qt * qt * Wt,
                    this._w = Nt * jt * Wt + Qt * qt * Xt;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + Ct)
                }
                return lt !== !1 && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(tt, lt) {
                const mt = lt / 2
                  , ft = Math.sin(mt);
                return this._x = tt.x * ft,
                this._y = tt.y * ft,
                this._z = tt.z * ft,
                this._w = Math.cos(mt),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(tt) {
                const lt = tt.elements
                  , mt = lt[0]
                  , ft = lt[4]
                  , xt = lt[8]
                  , Ct = lt[1]
                  , Mt = lt[5]
                  , Lt = lt[9]
                  , Nt = lt[2]
                  , jt = lt[6]
                  , Wt = lt[10]
                  , Qt = mt + Mt + Wt;
                if (Qt > 0) {
                    const qt = .5 / Math.sqrt(Qt + 1);
                    this._w = .25 / qt,
                    this._x = (jt - Lt) * qt,
                    this._y = (xt - Nt) * qt,
                    this._z = (Ct - ft) * qt
                } else if (mt > Mt && mt > Wt) {
                    const qt = 2 * Math.sqrt(1 + mt - Mt - Wt);
                    this._w = (jt - Lt) / qt,
                    this._x = .25 * qt,
                    this._y = (ft + Ct) / qt,
                    this._z = (xt + Nt) / qt
                } else if (Mt > Wt) {
                    const qt = 2 * Math.sqrt(1 + Mt - mt - Wt);
                    this._w = (xt - Nt) / qt,
                    this._x = (ft + Ct) / qt,
                    this._y = .25 * qt,
                    this._z = (Lt + jt) / qt
                } else {
                    const qt = 2 * Math.sqrt(1 + Wt - mt - Mt);
                    this._w = (Ct - ft) / qt,
                    this._x = (xt + Nt) / qt,
                    this._y = (Lt + jt) / qt,
                    this._z = .25 * qt
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(tt, lt) {
                let mt = tt.dot(lt) + 1;
                return mt < Number.EPSILON ? (mt = 0,
                Math.abs(tt.x) > Math.abs(tt.z) ? (this._x = -tt.y,
                this._y = tt.x,
                this._z = 0,
                this._w = mt) : (this._x = 0,
                this._y = -tt.z,
                this._z = tt.y,
                this._w = mt)) : (this._x = tt.y * lt.z - tt.z * lt.y,
                this._y = tt.z * lt.x - tt.x * lt.z,
                this._z = tt.x * lt.y - tt.y * lt.x,
                this._w = mt),
                this.normalize()
            }
            angleTo(tt) {
                return 2 * Math.acos(Math.abs(qo(this.dot(tt), -1, 1)))
            }
            rotateTowards(tt, lt) {
                const mt = this.angleTo(tt);
                if (mt === 0)
                    return this;
                const ft = Math.min(1, lt / mt);
                return this.slerp(tt, ft),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(tt) {
                return this._x * tt._x + this._y * tt._y + this._z * tt._z + this._w * tt._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let tt = this.length();
                return tt === 0 ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (tt = 1 / tt,
                this._x = this._x * tt,
                this._y = this._y * tt,
                this._z = this._z * tt,
                this._w = this._w * tt),
                this._onChangeCallback(),
                this
            }
            multiply(tt) {
                return this.multiplyQuaternions(this, tt)
            }
            premultiply(tt) {
                return this.multiplyQuaternions(tt, this)
            }
            multiplyQuaternions(tt, lt) {
                const mt = tt._x
                  , ft = tt._y
                  , xt = tt._z
                  , Ct = tt._w
                  , Mt = lt._x
                  , Lt = lt._y
                  , Nt = lt._z
                  , jt = lt._w;
                return this._x = mt * jt + Ct * Mt + ft * Nt - xt * Lt,
                this._y = ft * jt + Ct * Lt + xt * Mt - mt * Nt,
                this._z = xt * jt + Ct * Nt + mt * Lt - ft * Mt,
                this._w = Ct * jt - mt * Mt - ft * Lt - xt * Nt,
                this._onChangeCallback(),
                this
            }
            slerp(tt, lt) {
                if (lt === 0)
                    return this;
                if (lt === 1)
                    return this.copy(tt);
                const mt = this._x
                  , ft = this._y
                  , xt = this._z
                  , Ct = this._w;
                let Mt = Ct * tt._w + mt * tt._x + ft * tt._y + xt * tt._z;
                if (Mt < 0 ? (this._w = -tt._w,
                this._x = -tt._x,
                this._y = -tt._y,
                this._z = -tt._z,
                Mt = -Mt) : this.copy(tt),
                Mt >= 1)
                    return this._w = Ct,
                    this._x = mt,
                    this._y = ft,
                    this._z = xt,
                    this;
                const Lt = 1 - Mt * Mt;
                if (Lt <= Number.EPSILON) {
                    const qt = 1 - lt;
                    return this._w = qt * Ct + lt * this._w,
                    this._x = qt * mt + lt * this._x,
                    this._y = qt * ft + lt * this._y,
                    this._z = qt * xt + lt * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const Nt = Math.sqrt(Lt)
                  , jt = Math.atan2(Nt, Mt)
                  , Wt = Math.sin((1 - lt) * jt) / Nt
                  , Qt = Math.sin(lt * jt) / Nt;
                return this._w = Ct * Wt + this._w * Qt,
                this._x = mt * Wt + this._x * Qt,
                this._y = ft * Wt + this._y * Qt,
                this._z = xt * Wt + this._z * Qt,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(tt, lt, mt) {
                return this.copy(tt).slerp(lt, mt)
            }
            random() {
                const tt = Math.random()
                  , lt = Math.sqrt(1 - tt)
                  , mt = Math.sqrt(tt)
                  , ft = 2 * Math.PI * Math.random()
                  , xt = 2 * Math.PI * Math.random();
                return this.set(lt * Math.cos(ft), mt * Math.sin(xt), mt * Math.cos(xt), lt * Math.sin(ft))
            }
            equals(tt) {
                return tt._x === this._x && tt._y === this._y && tt._z === this._z && tt._w === this._w
            }
            fromArray(tt, lt=0) {
                return this._x = tt[lt],
                this._y = tt[lt + 1],
                this._z = tt[lt + 2],
                this._w = tt[lt + 3],
                this._onChangeCallback(),
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this._x,
                tt[lt + 1] = this._y,
                tt[lt + 2] = this._z,
                tt[lt + 3] = this._w,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this._x = tt.getX(lt),
                this._y = tt.getY(lt),
                this._z = tt.getZ(lt),
                this._w = tt.getW(lt),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(tt) {
                return this._onChangeCallback = tt,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class Er {
            constructor(tt=0, lt=0, mt=0) {
                Er.prototype.isVector3 = !0,
                this.x = tt,
                this.y = lt,
                this.z = mt
            }
            set(tt, lt, mt) {
                return mt === void 0 && (mt = this.z),
                this.x = tt,
                this.y = lt,
                this.z = mt,
                this
            }
            setScalar(tt) {
                return this.x = tt,
                this.y = tt,
                this.z = tt,
                this
            }
            setX(tt) {
                return this.x = tt,
                this
            }
            setY(tt) {
                return this.y = tt,
                this
            }
            setZ(tt) {
                return this.z = tt,
                this
            }
            setComponent(tt, lt) {
                switch (tt) {
                case 0:
                    this.x = lt;
                    break;
                case 1:
                    this.y = lt;
                    break;
                case 2:
                    this.z = lt;
                    break;
                default:
                    throw new Error("index is out of range: " + tt)
                }
                return this
            }
            getComponent(tt) {
                switch (tt) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + tt)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(tt) {
                return this.x = tt.x,
                this.y = tt.y,
                this.z = tt.z,
                this
            }
            add(tt) {
                return this.x += tt.x,
                this.y += tt.y,
                this.z += tt.z,
                this
            }
            addScalar(tt) {
                return this.x += tt,
                this.y += tt,
                this.z += tt,
                this
            }
            addVectors(tt, lt) {
                return this.x = tt.x + lt.x,
                this.y = tt.y + lt.y,
                this.z = tt.z + lt.z,
                this
            }
            addScaledVector(tt, lt) {
                return this.x += tt.x * lt,
                this.y += tt.y * lt,
                this.z += tt.z * lt,
                this
            }
            sub(tt) {
                return this.x -= tt.x,
                this.y -= tt.y,
                this.z -= tt.z,
                this
            }
            subScalar(tt) {
                return this.x -= tt,
                this.y -= tt,
                this.z -= tt,
                this
            }
            subVectors(tt, lt) {
                return this.x = tt.x - lt.x,
                this.y = tt.y - lt.y,
                this.z = tt.z - lt.z,
                this
            }
            multiply(tt) {
                return this.x *= tt.x,
                this.y *= tt.y,
                this.z *= tt.z,
                this
            }
            multiplyScalar(tt) {
                return this.x *= tt,
                this.y *= tt,
                this.z *= tt,
                this
            }
            multiplyVectors(tt, lt) {
                return this.x = tt.x * lt.x,
                this.y = tt.y * lt.y,
                this.z = tt.z * lt.z,
                this
            }
            applyEuler(tt) {
                return this.applyQuaternion(om.setFromEuler(tt))
            }
            applyAxisAngle(tt, lt) {
                return this.applyQuaternion(om.setFromAxisAngle(tt, lt))
            }
            applyMatrix3(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.elements;
                return this.x = xt[0] * lt + xt[3] * mt + xt[6] * ft,
                this.y = xt[1] * lt + xt[4] * mt + xt[7] * ft,
                this.z = xt[2] * lt + xt[5] * mt + xt[8] * ft,
                this
            }
            applyNormalMatrix(tt) {
                return this.applyMatrix3(tt).normalize()
            }
            applyMatrix4(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.elements
                  , Ct = 1 / (xt[3] * lt + xt[7] * mt + xt[11] * ft + xt[15]);
                return this.x = (xt[0] * lt + xt[4] * mt + xt[8] * ft + xt[12]) * Ct,
                this.y = (xt[1] * lt + xt[5] * mt + xt[9] * ft + xt[13]) * Ct,
                this.z = (xt[2] * lt + xt[6] * mt + xt[10] * ft + xt[14]) * Ct,
                this
            }
            applyQuaternion(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.x
                  , Ct = tt.y
                  , Mt = tt.z
                  , Lt = tt.w
                  , Nt = Lt * lt + Ct * ft - Mt * mt
                  , jt = Lt * mt + Mt * lt - xt * ft
                  , Wt = Lt * ft + xt * mt - Ct * lt
                  , Qt = -xt * lt - Ct * mt - Mt * ft;
                return this.x = Nt * Lt + Qt * -xt + jt * -Mt - Wt * -Ct,
                this.y = jt * Lt + Qt * -Ct + Wt * -xt - Nt * -Mt,
                this.z = Wt * Lt + Qt * -Mt + Nt * -Ct - jt * -xt,
                this
            }
            project(tt) {
                return this.applyMatrix4(tt.matrixWorldInverse).applyMatrix4(tt.projectionMatrix)
            }
            unproject(tt) {
                return this.applyMatrix4(tt.projectionMatrixInverse).applyMatrix4(tt.matrixWorld)
            }
            transformDirection(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.elements;
                return this.x = xt[0] * lt + xt[4] * mt + xt[8] * ft,
                this.y = xt[1] * lt + xt[5] * mt + xt[9] * ft,
                this.z = xt[2] * lt + xt[6] * mt + xt[10] * ft,
                this.normalize()
            }
            divide(tt) {
                return this.x /= tt.x,
                this.y /= tt.y,
                this.z /= tt.z,
                this
            }
            divideScalar(tt) {
                return this.multiplyScalar(1 / tt)
            }
            min(tt) {
                return this.x = Math.min(this.x, tt.x),
                this.y = Math.min(this.y, tt.y),
                this.z = Math.min(this.z, tt.z),
                this
            }
            max(tt) {
                return this.x = Math.max(this.x, tt.x),
                this.y = Math.max(this.y, tt.y),
                this.z = Math.max(this.z, tt.z),
                this
            }
            clamp(tt, lt) {
                return this.x = Math.max(tt.x, Math.min(lt.x, this.x)),
                this.y = Math.max(tt.y, Math.min(lt.y, this.y)),
                this.z = Math.max(tt.z, Math.min(lt.z, this.z)),
                this
            }
            clampScalar(tt, lt) {
                return this.x = Math.max(tt, Math.min(lt, this.x)),
                this.y = Math.max(tt, Math.min(lt, this.y)),
                this.z = Math.max(tt, Math.min(lt, this.z)),
                this
            }
            clampLength(tt, lt) {
                const mt = this.length();
                return this.divideScalar(mt || 1).multiplyScalar(Math.max(tt, Math.min(lt, mt)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(tt) {
                return this.x * tt.x + this.y * tt.y + this.z * tt.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(tt) {
                return this.normalize().multiplyScalar(tt)
            }
            lerp(tt, lt) {
                return this.x += (tt.x - this.x) * lt,
                this.y += (tt.y - this.y) * lt,
                this.z += (tt.z - this.z) * lt,
                this
            }
            lerpVectors(tt, lt, mt) {
                return this.x = tt.x + (lt.x - tt.x) * mt,
                this.y = tt.y + (lt.y - tt.y) * mt,
                this.z = tt.z + (lt.z - tt.z) * mt,
                this
            }
            cross(tt) {
                return this.crossVectors(this, tt)
            }
            crossVectors(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = lt.x
                  , Mt = lt.y
                  , Lt = lt.z;
                return this.x = ft * Lt - xt * Mt,
                this.y = xt * Ct - mt * Lt,
                this.z = mt * Mt - ft * Ct,
                this
            }
            projectOnVector(tt) {
                const lt = tt.lengthSq();
                if (lt === 0)
                    return this.set(0, 0, 0);
                const mt = tt.dot(this) / lt;
                return this.copy(tt).multiplyScalar(mt)
            }
            projectOnPlane(tt) {
                return s_.copy(this).projectOnVector(tt),
                this.sub(s_)
            }
            reflect(tt) {
                return this.sub(s_.copy(tt).multiplyScalar(2 * this.dot(tt)))
            }
            angleTo(tt) {
                const lt = Math.sqrt(this.lengthSq() * tt.lengthSq());
                if (lt === 0)
                    return Math.PI / 2;
                const mt = this.dot(tt) / lt;
                return Math.acos(qo(mt, -1, 1))
            }
            distanceTo(tt) {
                return Math.sqrt(this.distanceToSquared(tt))
            }
            distanceToSquared(tt) {
                const lt = this.x - tt.x
                  , mt = this.y - tt.y
                  , ft = this.z - tt.z;
                return lt * lt + mt * mt + ft * ft
            }
            manhattanDistanceTo(tt) {
                return Math.abs(this.x - tt.x) + Math.abs(this.y - tt.y) + Math.abs(this.z - tt.z)
            }
            setFromSpherical(tt) {
                return this.setFromSphericalCoords(tt.radius, tt.phi, tt.theta)
            }
            setFromSphericalCoords(tt, lt, mt) {
                const ft = Math.sin(lt) * tt;
                return this.x = ft * Math.sin(mt),
                this.y = Math.cos(lt) * tt,
                this.z = ft * Math.cos(mt),
                this
            }
            setFromCylindrical(tt) {
                return this.setFromCylindricalCoords(tt.radius, tt.theta, tt.y)
            }
            setFromCylindricalCoords(tt, lt, mt) {
                return this.x = tt * Math.sin(lt),
                this.y = mt,
                this.z = tt * Math.cos(lt),
                this
            }
            setFromMatrixPosition(tt) {
                const lt = tt.elements;
                return this.x = lt[12],
                this.y = lt[13],
                this.z = lt[14],
                this
            }
            setFromMatrixScale(tt) {
                const lt = this.setFromMatrixColumn(tt, 0).length()
                  , mt = this.setFromMatrixColumn(tt, 1).length()
                  , ft = this.setFromMatrixColumn(tt, 2).length();
                return this.x = lt,
                this.y = mt,
                this.z = ft,
                this
            }
            setFromMatrixColumn(tt, lt) {
                return this.fromArray(tt.elements, 4 * lt)
            }
            setFromMatrix3Column(tt, lt) {
                return this.fromArray(tt.elements, 3 * lt)
            }
            setFromEuler(tt) {
                return this.x = tt._x,
                this.y = tt._y,
                this.z = tt._z,
                this
            }
            setFromColor(tt) {
                return this.x = tt.r,
                this.y = tt.g,
                this.z = tt.b,
                this
            }
            equals(tt) {
                return tt.x === this.x && tt.y === this.y && tt.z === this.z
            }
            fromArray(tt, lt=0) {
                return this.x = tt[lt],
                this.y = tt[lt + 1],
                this.z = tt[lt + 2],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.x,
                tt[lt + 1] = this.y,
                tt[lt + 2] = this.z,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.x = tt.getX(lt),
                this.y = tt.getY(lt),
                this.z = tt.getZ(lt),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const tt = 2 * (Math.random() - .5)
                  , lt = Math.random() * Math.PI * 2
                  , mt = Math.sqrt(1 - tt ** 2);
                return this.x = mt * Math.cos(lt),
                this.y = mt * Math.sin(lt),
                this.z = tt,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const s_ = new Er
          , om = new Is;
        class Tl {
            constructor(tt=new Er(1 / 0,1 / 0,1 / 0), lt=new Er(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = tt,
                this.max = lt
            }
            set(tt, lt) {
                return this.min.copy(tt),
                this.max.copy(lt),
                this
            }
            setFromArray(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.length; lt < mt; lt += 3)
                    this.expandByPoint(xa.fromArray(tt, lt));
                return this
            }
            setFromBufferAttribute(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.count; lt < mt; lt++)
                    this.expandByPoint(xa.fromBufferAttribute(tt, lt));
                return this
            }
            setFromPoints(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.length; lt < mt; lt++)
                    this.expandByPoint(tt[lt]);
                return this
            }
            setFromCenterAndSize(tt, lt) {
                const mt = xa.copy(lt).multiplyScalar(.5);
                return this.min.copy(tt).sub(mt),
                this.max.copy(tt).add(mt),
                this
            }
            setFromObject(tt, lt=!1) {
                return this.makeEmpty(),
                this.expandByObject(tt, lt)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.min.copy(tt.min),
                this.max.copy(tt.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(tt) {
                return this.isEmpty() ? tt.set(0, 0, 0) : tt.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(tt) {
                return this.isEmpty() ? tt.set(0, 0, 0) : tt.subVectors(this.max, this.min)
            }
            expandByPoint(tt) {
                return this.min.min(tt),
                this.max.max(tt),
                this
            }
            expandByVector(tt) {
                return this.min.sub(tt),
                this.max.add(tt),
                this
            }
            expandByScalar(tt) {
                return this.min.addScalar(-tt),
                this.max.addScalar(tt),
                this
            }
            expandByObject(tt, lt=!1) {
                if (tt.updateWorldMatrix(!1, !1),
                tt.boundingBox !== void 0)
                    tt.boundingBox === null && tt.computeBoundingBox(),
                    Vu.copy(tt.boundingBox),
                    Vu.applyMatrix4(tt.matrixWorld),
                    this.union(Vu);
                else {
                    const ft = tt.geometry;
                    if (ft !== void 0)
                        if (lt && ft.attributes !== void 0 && ft.attributes.position !== void 0) {
                            const xt = ft.attributes.position;
                            for (let Ct = 0, Mt = xt.count; Ct < Mt; Ct++)
                                xa.fromBufferAttribute(xt, Ct).applyMatrix4(tt.matrixWorld),
                                this.expandByPoint(xa)
                        } else
                            ft.boundingBox === null && ft.computeBoundingBox(),
                            Vu.copy(ft.boundingBox),
                            Vu.applyMatrix4(tt.matrixWorld),
                            this.union(Vu)
                }
                const mt = tt.children;
                for (let ft = 0, xt = mt.length; ft < xt; ft++)
                    this.expandByObject(mt[ft], lt);
                return this
            }
            containsPoint(tt) {
                return !(tt.x < this.min.x || tt.x > this.max.x || tt.y < this.min.y || tt.y > this.max.y || tt.z < this.min.z || tt.z > this.max.z)
            }
            containsBox(tt) {
                return this.min.x <= tt.min.x && tt.max.x <= this.max.x && this.min.y <= tt.min.y && tt.max.y <= this.max.y && this.min.z <= tt.min.z && tt.max.z <= this.max.z
            }
            getParameter(tt, lt) {
                return lt.set((tt.x - this.min.x) / (this.max.x - this.min.x), (tt.y - this.min.y) / (this.max.y - this.min.y), (tt.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(tt) {
                return !(tt.max.x < this.min.x || tt.min.x > this.max.x || tt.max.y < this.min.y || tt.min.y > this.max.y || tt.max.z < this.min.z || tt.min.z > this.max.z)
            }
            intersectsSphere(tt) {
                return this.clampPoint(tt.center, xa),
                xa.distanceToSquared(tt.center) <= tt.radius * tt.radius
            }
            intersectsPlane(tt) {
                let lt, mt;
                return tt.normal.x > 0 ? (lt = tt.normal.x * this.min.x,
                mt = tt.normal.x * this.max.x) : (lt = tt.normal.x * this.max.x,
                mt = tt.normal.x * this.min.x),
                tt.normal.y > 0 ? (lt += tt.normal.y * this.min.y,
                mt += tt.normal.y * this.max.y) : (lt += tt.normal.y * this.max.y,
                mt += tt.normal.y * this.min.y),
                tt.normal.z > 0 ? (lt += tt.normal.z * this.min.z,
                mt += tt.normal.z * this.max.z) : (lt += tt.normal.z * this.max.z,
                mt += tt.normal.z * this.min.z),
                lt <= -tt.constant && mt >= -tt.constant
            }
            intersectsTriangle(tt) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(_p),
                sm.subVectors(this.max, _p),
                Gu.subVectors(tt.a, _p),
                zu.subVectors(tt.b, _p),
                Hu.subVectors(tt.c, _p),
                Cl.subVectors(zu, Gu),
                _c.subVectors(Hu, zu),
                Au.subVectors(Gu, Hu);
                let lt = [0, -Cl.z, Cl.y, 0, -_c.z, _c.y, 0, -Au.z, Au.y, Cl.z, 0, -Cl.x, _c.z, 0, -_c.x, Au.z, 0, -Au.x, -Cl.y, Cl.x, 0, -_c.y, _c.x, 0, -Au.y, Au.x, 0];
                return !!Pl(lt, Gu, zu, Hu, sm) && (lt = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!Pl(lt, Gu, zu, Hu, sm) && (am.crossVectors(Cl, _c),
                lt = [am.x, am.y, am.z],
                Pl(lt, Gu, zu, Hu, sm)))
            }
            clampPoint(tt, lt) {
                return lt.copy(tt).clamp(this.min, this.max)
            }
            distanceToPoint(tt) {
                return this.clampPoint(tt, xa).distanceTo(tt)
            }
            getBoundingSphere(tt) {
                return this.isEmpty() ? tt.makeEmpty() : (this.getCenter(tt.center),
                tt.radius = .5 * this.getSize(xa).length()),
                tt
            }
            intersect(tt) {
                return this.min.max(tt.min),
                this.max.min(tt.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(tt) {
                return this.min.min(tt.min),
                this.max.max(tt.max),
                this
            }
            applyMatrix4(tt) {
                return this.isEmpty() || (Nl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(tt),
                Nl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(tt),
                Nl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(tt),
                Nl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(tt),
                Nl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(tt),
                Nl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(tt),
                Nl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(tt),
                Nl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(tt),
                this.setFromPoints(Nl)),
                this
            }
            translate(tt) {
                return this.min.add(tt),
                this.max.add(tt),
                this
            }
            equals(tt) {
                return tt.min.equals(this.min) && tt.max.equals(this.max)
            }
        }
        const Nl = [new Er, new Er, new Er, new Er, new Er, new Er, new Er, new Er]
          , xa = new Er
          , Vu = new Tl
          , Gu = new Er
          , zu = new Er
          , Hu = new Er
          , Cl = new Er
          , _c = new Er
          , Au = new Er
          , _p = new Er
          , sm = new Er
          , am = new Er
          , wu = new Er;
        function Pl(Tt, tt, lt, mt, ft) {
            for (let xt = 0, Ct = Tt.length - 3; xt <= Ct; xt += 3) {
                wu.fromArray(Tt, xt);
                const Mt = ft.x * Math.abs(wu.x) + ft.y * Math.abs(wu.y) + ft.z * Math.abs(wu.z)
                  , Lt = tt.dot(wu)
                  , Nt = lt.dot(wu)
                  , jt = mt.dot(wu);
                if (Math.max(-Math.max(Lt, Nt, jt), Math.min(Lt, Nt, jt)) > Mt)
                    return !1
            }
            return !0
        }
        const iv = new Tl
          , vp = new Er
          , yp = new Er;
        class Ws {
            constructor(tt=new Er, lt=-1) {
                this.center = tt,
                this.radius = lt
            }
            set(tt, lt) {
                return this.center.copy(tt),
                this.radius = lt,
                this
            }
            setFromPoints(tt, lt) {
                const mt = this.center;
                lt !== void 0 ? mt.copy(lt) : iv.setFromPoints(tt).getCenter(mt);
                let ft = 0;
                for (let xt = 0, Ct = tt.length; xt < Ct; xt++)
                    ft = Math.max(ft, mt.distanceToSquared(tt[xt]));
                return this.radius = Math.sqrt(ft),
                this
            }
            copy(tt) {
                return this.center.copy(tt.center),
                this.radius = tt.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(tt) {
                return tt.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(tt) {
                return tt.distanceTo(this.center) - this.radius
            }
            intersectsSphere(tt) {
                const lt = this.radius + tt.radius;
                return tt.center.distanceToSquared(this.center) <= lt * lt
            }
            intersectsBox(tt) {
                return tt.intersectsSphere(this)
            }
            intersectsPlane(tt) {
                return Math.abs(tt.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(tt, lt) {
                const mt = this.center.distanceToSquared(tt);
                return lt.copy(tt),
                mt > this.radius * this.radius && (lt.sub(this.center).normalize(),
                lt.multiplyScalar(this.radius).add(this.center)),
                lt
            }
            getBoundingBox(tt) {
                return this.isEmpty() ? (tt.makeEmpty(),
                tt) : (tt.set(this.center, this.center),
                tt.expandByScalar(this.radius),
                tt)
            }
            applyMatrix4(tt) {
                return this.center.applyMatrix4(tt),
                this.radius = this.radius * tt.getMaxScaleOnAxis(),
                this
            }
            translate(tt) {
                return this.center.add(tt),
                this
            }
            expandByPoint(tt) {
                if (this.isEmpty())
                    return this.center.copy(tt),
                    this.radius = 0,
                    this;
                vp.subVectors(tt, this.center);
                const lt = vp.lengthSq();
                if (lt > this.radius * this.radius) {
                    const mt = Math.sqrt(lt)
                      , ft = .5 * (mt - this.radius);
                    this.center.addScaledVector(vp, ft / mt),
                    this.radius += ft
                }
                return this
            }
            union(tt) {
                return tt.isEmpty() ? this : this.isEmpty() ? (this.copy(tt),
                this) : (this.center.equals(tt.center) === !0 ? this.radius = Math.max(this.radius, tt.radius) : (yp.subVectors(tt.center, this.center).setLength(tt.radius),
                this.expandByPoint(vp.copy(tt.center).add(yp)),
                this.expandByPoint(vp.copy(tt.center).sub(yp))),
                this)
            }
            equals(tt) {
                return tt.center.equals(this.center) && tt.radius === this.radius
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const Ml = new Er
          , a_ = new Er
          , ba = new Er
          , Fl = new Er
          , eu = new Er
          , lm = new Er
          , Rl = new Er;
        class Qu {
            constructor(tt=new Er, lt=new Er(0,0,-1)) {
                this.origin = tt,
                this.direction = lt
            }
            set(tt, lt) {
                return this.origin.copy(tt),
                this.direction.copy(lt),
                this
            }
            copy(tt) {
                return this.origin.copy(tt.origin),
                this.direction.copy(tt.direction),
                this
            }
            at(tt, lt) {
                return lt.copy(this.origin).addScaledVector(this.direction, tt)
            }
            lookAt(tt) {
                return this.direction.copy(tt).sub(this.origin).normalize(),
                this
            }
            recast(tt) {
                return this.origin.copy(this.at(tt, Ml)),
                this
            }
            closestPointToPoint(tt, lt) {
                lt.subVectors(tt, this.origin);
                const mt = lt.dot(this.direction);
                return mt < 0 ? lt.copy(this.origin) : lt.copy(this.origin).addScaledVector(this.direction, mt)
            }
            distanceToPoint(tt) {
                return Math.sqrt(this.distanceSqToPoint(tt))
            }
            distanceSqToPoint(tt) {
                const lt = Ml.subVectors(tt, this.origin).dot(this.direction);
                return lt < 0 ? this.origin.distanceToSquared(tt) : (Ml.copy(this.origin).addScaledVector(this.direction, lt),
                Ml.distanceToSquared(tt))
            }
            distanceSqToSegment(tt, lt, mt, ft) {
                a_.copy(tt).add(lt).multiplyScalar(.5),
                ba.copy(lt).sub(tt).normalize(),
                Fl.copy(this.origin).sub(a_);
                const xt = .5 * tt.distanceTo(lt)
                  , Ct = -this.direction.dot(ba)
                  , Mt = Fl.dot(this.direction)
                  , Lt = -Fl.dot(ba)
                  , Nt = Fl.lengthSq()
                  , jt = Math.abs(1 - Ct * Ct);
                let Wt, Qt, qt, Xt;
                if (jt > 0)
                    if (Wt = Ct * Lt - Mt,
                    Qt = Ct * Mt - Lt,
                    Xt = xt * jt,
                    Wt >= 0)
                        if (Qt >= -Xt)
                            if (Qt <= Xt) {
                                const Zt = 1 / jt;
                                Wt *= Zt,
                                Qt *= Zt,
                                qt = Wt * (Wt + Ct * Qt + 2 * Mt) + Qt * (Ct * Wt + Qt + 2 * Lt) + Nt
                            } else
                                Qt = xt,
                                Wt = Math.max(0, -(Ct * Qt + Mt)),
                                qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt;
                        else
                            Qt = -xt,
                            Wt = Math.max(0, -(Ct * Qt + Mt)),
                            qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt;
                    else
                        Qt <= -Xt ? (Wt = Math.max(0, -(-Ct * xt + Mt)),
                        Qt = Wt > 0 ? -xt : Math.min(Math.max(-xt, -Lt), xt),
                        qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt) : Qt <= Xt ? (Wt = 0,
                        Qt = Math.min(Math.max(-xt, -Lt), xt),
                        qt = Qt * (Qt + 2 * Lt) + Nt) : (Wt = Math.max(0, -(Ct * xt + Mt)),
                        Qt = Wt > 0 ? xt : Math.min(Math.max(-xt, -Lt), xt),
                        qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt);
                else
                    Qt = Ct > 0 ? -xt : xt,
                    Wt = Math.max(0, -(Ct * Qt + Mt)),
                    qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt;
                return mt && mt.copy(this.origin).addScaledVector(this.direction, Wt),
                ft && ft.copy(a_).addScaledVector(ba, Qt),
                qt
            }
            intersectSphere(tt, lt) {
                Ml.subVectors(tt.center, this.origin);
                const mt = Ml.dot(this.direction)
                  , ft = Ml.dot(Ml) - mt * mt
                  , xt = tt.radius * tt.radius;
                if (ft > xt)
                    return null;
                const Ct = Math.sqrt(xt - ft)
                  , Mt = mt - Ct
                  , Lt = mt + Ct;
                return Lt < 0 ? null : Mt < 0 ? this.at(Lt, lt) : this.at(Mt, lt)
            }
            intersectsSphere(tt) {
                return this.distanceSqToPoint(tt.center) <= tt.radius * tt.radius
            }
            distanceToPlane(tt) {
                const lt = tt.normal.dot(this.direction);
                if (lt === 0)
                    return tt.distanceToPoint(this.origin) === 0 ? 0 : null;
                const mt = -(this.origin.dot(tt.normal) + tt.constant) / lt;
                return mt >= 0 ? mt : null
            }
            intersectPlane(tt, lt) {
                const mt = this.distanceToPlane(tt);
                return mt === null ? null : this.at(mt, lt)
            }
            intersectsPlane(tt) {
                const lt = tt.distanceToPoint(this.origin);
                return lt === 0 || tt.normal.dot(this.direction) * lt < 0
            }
            intersectBox(tt, lt) {
                let mt, ft, xt, Ct, Mt, Lt;
                const Nt = 1 / this.direction.x
                  , jt = 1 / this.direction.y
                  , Wt = 1 / this.direction.z
                  , Qt = this.origin;
                return Nt >= 0 ? (mt = (tt.min.x - Qt.x) * Nt,
                ft = (tt.max.x - Qt.x) * Nt) : (mt = (tt.max.x - Qt.x) * Nt,
                ft = (tt.min.x - Qt.x) * Nt),
                jt >= 0 ? (xt = (tt.min.y - Qt.y) * jt,
                Ct = (tt.max.y - Qt.y) * jt) : (xt = (tt.max.y - Qt.y) * jt,
                Ct = (tt.min.y - Qt.y) * jt),
                mt > Ct || xt > ft ? null : ((xt > mt || isNaN(mt)) && (mt = xt),
                (Ct < ft || isNaN(ft)) && (ft = Ct),
                Wt >= 0 ? (Mt = (tt.min.z - Qt.z) * Wt,
                Lt = (tt.max.z - Qt.z) * Wt) : (Mt = (tt.max.z - Qt.z) * Wt,
                Lt = (tt.min.z - Qt.z) * Wt),
                mt > Lt || Mt > ft ? null : ((Mt > mt || mt != mt) && (mt = Mt),
                (Lt < ft || ft != ft) && (ft = Lt),
                ft < 0 ? null : this.at(mt >= 0 ? mt : ft, lt)))
            }
            intersectsBox(tt) {
                return this.intersectBox(tt, Ml) !== null
            }
            intersectTriangle(tt, lt, mt, ft, xt) {
                eu.subVectors(lt, tt),
                lm.subVectors(mt, tt),
                Rl.crossVectors(eu, lm);
                let Ct, Mt = this.direction.dot(Rl);
                if (Mt > 0) {
                    if (ft)
                        return null;
                    Ct = 1
                } else {
                    if (!(Mt < 0))
                        return null;
                    Ct = -1,
                    Mt = -Mt
                }
                Fl.subVectors(this.origin, tt);
                const Lt = Ct * this.direction.dot(lm.crossVectors(Fl, lm));
                if (Lt < 0)
                    return null;
                const Nt = Ct * this.direction.dot(eu.cross(Fl));
                if (Nt < 0 || Lt + Nt > Mt)
                    return null;
                const jt = -Ct * Fl.dot(Rl);
                return jt < 0 ? null : this.at(jt / Mt, xt)
            }
            applyMatrix4(tt) {
                return this.origin.applyMatrix4(tt),
                this.direction.transformDirection(tt),
                this
            }
            equals(tt) {
                return tt.origin.equals(this.origin) && tt.direction.equals(this.direction)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class no {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt, qt, Xt, Zt, Yt) {
                no.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                tt !== void 0 && this.set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt, qt, Xt, Zt, Yt)
            }
            set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt, qt, Xt, Zt, Yt) {
                const sr = this.elements;
                return sr[0] = tt,
                sr[4] = lt,
                sr[8] = mt,
                sr[12] = ft,
                sr[1] = xt,
                sr[5] = Ct,
                sr[9] = Mt,
                sr[13] = Lt,
                sr[2] = Nt,
                sr[6] = jt,
                sr[10] = Wt,
                sr[14] = Qt,
                sr[3] = qt,
                sr[7] = Xt,
                sr[11] = Zt,
                sr[15] = Yt,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return new no().fromArray(this.elements)
            }
            copy(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                return lt[0] = mt[0],
                lt[1] = mt[1],
                lt[2] = mt[2],
                lt[3] = mt[3],
                lt[4] = mt[4],
                lt[5] = mt[5],
                lt[6] = mt[6],
                lt[7] = mt[7],
                lt[8] = mt[8],
                lt[9] = mt[9],
                lt[10] = mt[10],
                lt[11] = mt[11],
                lt[12] = mt[12],
                lt[13] = mt[13],
                lt[14] = mt[14],
                lt[15] = mt[15],
                this
            }
            copyPosition(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                return lt[12] = mt[12],
                lt[13] = mt[13],
                lt[14] = mt[14],
                this
            }
            setFromMatrix3(tt) {
                const lt = tt.elements;
                return this.set(lt[0], lt[3], lt[6], 0, lt[1], lt[4], lt[7], 0, lt[2], lt[5], lt[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(tt, lt, mt) {
                return tt.setFromMatrixColumn(this, 0),
                lt.setFromMatrixColumn(this, 1),
                mt.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(tt, lt, mt) {
                return this.set(tt.x, lt.x, mt.x, 0, tt.y, lt.y, mt.y, 0, tt.z, lt.z, mt.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(tt) {
                const lt = this.elements
                  , mt = tt.elements
                  , ft = 1 / Wu.setFromMatrixColumn(tt, 0).length()
                  , xt = 1 / Wu.setFromMatrixColumn(tt, 1).length()
                  , Ct = 1 / Wu.setFromMatrixColumn(tt, 2).length();
                return lt[0] = mt[0] * ft,
                lt[1] = mt[1] * ft,
                lt[2] = mt[2] * ft,
                lt[3] = 0,
                lt[4] = mt[4] * xt,
                lt[5] = mt[5] * xt,
                lt[6] = mt[6] * xt,
                lt[7] = 0,
                lt[8] = mt[8] * Ct,
                lt[9] = mt[9] * Ct,
                lt[10] = mt[10] * Ct,
                lt[11] = 0,
                lt[12] = 0,
                lt[13] = 0,
                lt[14] = 0,
                lt[15] = 1,
                this
            }
            makeRotationFromEuler(tt) {
                const lt = this.elements
                  , mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = Math.cos(mt)
                  , Mt = Math.sin(mt)
                  , Lt = Math.cos(ft)
                  , Nt = Math.sin(ft)
                  , jt = Math.cos(xt)
                  , Wt = Math.sin(xt);
                if (tt.order === "XYZ") {
                    const Qt = Ct * jt
                      , qt = Ct * Wt
                      , Xt = Mt * jt
                      , Zt = Mt * Wt;
                    lt[0] = Lt * jt,
                    lt[4] = -Lt * Wt,
                    lt[8] = Nt,
                    lt[1] = qt + Xt * Nt,
                    lt[5] = Qt - Zt * Nt,
                    lt[9] = -Mt * Lt,
                    lt[2] = Zt - Qt * Nt,
                    lt[6] = Xt + qt * Nt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "YXZ") {
                    const Qt = Lt * jt
                      , qt = Lt * Wt
                      , Xt = Nt * jt
                      , Zt = Nt * Wt;
                    lt[0] = Qt + Zt * Mt,
                    lt[4] = Xt * Mt - qt,
                    lt[8] = Ct * Nt,
                    lt[1] = Ct * Wt,
                    lt[5] = Ct * jt,
                    lt[9] = -Mt,
                    lt[2] = qt * Mt - Xt,
                    lt[6] = Zt + Qt * Mt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "ZXY") {
                    const Qt = Lt * jt
                      , qt = Lt * Wt
                      , Xt = Nt * jt
                      , Zt = Nt * Wt;
                    lt[0] = Qt - Zt * Mt,
                    lt[4] = -Ct * Wt,
                    lt[8] = Xt + qt * Mt,
                    lt[1] = qt + Xt * Mt,
                    lt[5] = Ct * jt,
                    lt[9] = Zt - Qt * Mt,
                    lt[2] = -Ct * Nt,
                    lt[6] = Mt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "ZYX") {
                    const Qt = Ct * jt
                      , qt = Ct * Wt
                      , Xt = Mt * jt
                      , Zt = Mt * Wt;
                    lt[0] = Lt * jt,
                    lt[4] = Xt * Nt - qt,
                    lt[8] = Qt * Nt + Zt,
                    lt[1] = Lt * Wt,
                    lt[5] = Zt * Nt + Qt,
                    lt[9] = qt * Nt - Xt,
                    lt[2] = -Nt,
                    lt[6] = Mt * Lt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "YZX") {
                    const Qt = Ct * Lt
                      , qt = Ct * Nt
                      , Xt = Mt * Lt
                      , Zt = Mt * Nt;
                    lt[0] = Lt * jt,
                    lt[4] = Zt - Qt * Wt,
                    lt[8] = Xt * Wt + qt,
                    lt[1] = Wt,
                    lt[5] = Ct * jt,
                    lt[9] = -Mt * jt,
                    lt[2] = -Nt * jt,
                    lt[6] = qt * Wt + Xt,
                    lt[10] = Qt - Zt * Wt
                } else if (tt.order === "XZY") {
                    const Qt = Ct * Lt
                      , qt = Ct * Nt
                      , Xt = Mt * Lt
                      , Zt = Mt * Nt;
                    lt[0] = Lt * jt,
                    lt[4] = -Wt,
                    lt[8] = Nt * jt,
                    lt[1] = Qt * Wt + Zt,
                    lt[5] = Ct * jt,
                    lt[9] = qt * Wt - Xt,
                    lt[2] = Xt * Wt - qt,
                    lt[6] = Mt * jt,
                    lt[10] = Zt * Wt + Qt
                }
                return lt[3] = 0,
                lt[7] = 0,
                lt[11] = 0,
                lt[12] = 0,
                lt[13] = 0,
                lt[14] = 0,
                lt[15] = 1,
                this
            }
            makeRotationFromQuaternion(tt) {
                return this.compose(qu, tt, ov)
            }
            lookAt(tt, lt, mt) {
                const ft = this.elements;
                return Ss.subVectors(tt, lt),
                Ss.lengthSq() === 0 && (Ss.z = 1),
                Ss.normalize(),
                tu.crossVectors(mt, Ss),
                tu.lengthSq() === 0 && (Math.abs(mt.z) === 1 ? Ss.x += 1e-4 : Ss.z += 1e-4,
                Ss.normalize(),
                tu.crossVectors(mt, Ss)),
                tu.normalize(),
                cm.crossVectors(Ss, tu),
                ft[0] = tu.x,
                ft[4] = cm.x,
                ft[8] = Ss.x,
                ft[1] = tu.y,
                ft[5] = cm.y,
                ft[9] = Ss.y,
                ft[2] = tu.z,
                ft[6] = cm.z,
                ft[10] = Ss.z,
                this
            }
            multiply(tt) {
                return this.multiplyMatrices(this, tt)
            }
            premultiply(tt) {
                return this.multiplyMatrices(tt, this)
            }
            multiplyMatrices(tt, lt) {
                const mt = tt.elements
                  , ft = lt.elements
                  , xt = this.elements
                  , Ct = mt[0]
                  , Mt = mt[4]
                  , Lt = mt[8]
                  , Nt = mt[12]
                  , jt = mt[1]
                  , Wt = mt[5]
                  , Qt = mt[9]
                  , qt = mt[13]
                  , Xt = mt[2]
                  , Zt = mt[6]
                  , Yt = mt[10]
                  , sr = mt[14]
                  , er = mt[3]
                  , rr = mt[7]
                  , xr = mt[11]
                  , br = mt[15]
                  , yr = ft[0]
                  , Pr = ft[4]
                  , zr = ft[8]
                  , Nr = ft[12]
                  , Vr = ft[1]
                  , Gr = ft[5]
                  , Hr = ft[9]
                  , _n = ft[13]
                  , dn = ft[2]
                  , kn = ft[6]
                  , Bn = ft[10]
                  , cn = ft[14]
                  , Yr = ft[3]
                  , Jr = ft[7]
                  , sn = ft[11]
                  , on = ft[15];
                return xt[0] = Ct * yr + Mt * Vr + Lt * dn + Nt * Yr,
                xt[4] = Ct * Pr + Mt * Gr + Lt * kn + Nt * Jr,
                xt[8] = Ct * zr + Mt * Hr + Lt * Bn + Nt * sn,
                xt[12] = Ct * Nr + Mt * _n + Lt * cn + Nt * on,
                xt[1] = jt * yr + Wt * Vr + Qt * dn + qt * Yr,
                xt[5] = jt * Pr + Wt * Gr + Qt * kn + qt * Jr,
                xt[9] = jt * zr + Wt * Hr + Qt * Bn + qt * sn,
                xt[13] = jt * Nr + Wt * _n + Qt * cn + qt * on,
                xt[2] = Xt * yr + Zt * Vr + Yt * dn + sr * Yr,
                xt[6] = Xt * Pr + Zt * Gr + Yt * kn + sr * Jr,
                xt[10] = Xt * zr + Zt * Hr + Yt * Bn + sr * sn,
                xt[14] = Xt * Nr + Zt * _n + Yt * cn + sr * on,
                xt[3] = er * yr + rr * Vr + xr * dn + br * Yr,
                xt[7] = er * Pr + rr * Gr + xr * kn + br * Jr,
                xt[11] = er * zr + rr * Hr + xr * Bn + br * sn,
                xt[15] = er * Nr + rr * _n + xr * cn + br * on,
                this
            }
            multiplyScalar(tt) {
                const lt = this.elements;
                return lt[0] *= tt,
                lt[4] *= tt,
                lt[8] *= tt,
                lt[12] *= tt,
                lt[1] *= tt,
                lt[5] *= tt,
                lt[9] *= tt,
                lt[13] *= tt,
                lt[2] *= tt,
                lt[6] *= tt,
                lt[10] *= tt,
                lt[14] *= tt,
                lt[3] *= tt,
                lt[7] *= tt,
                lt[11] *= tt,
                lt[15] *= tt,
                this
            }
            determinant() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[4]
                  , ft = tt[8]
                  , xt = tt[12]
                  , Ct = tt[1]
                  , Mt = tt[5]
                  , Lt = tt[9]
                  , Nt = tt[13]
                  , jt = tt[2]
                  , Wt = tt[6]
                  , Qt = tt[10]
                  , qt = tt[14];
                return tt[3] * (+xt * Lt * Wt - ft * Nt * Wt - xt * Mt * Qt + mt * Nt * Qt + ft * Mt * qt - mt * Lt * qt) + tt[7] * (+lt * Lt * qt - lt * Nt * Qt + xt * Ct * Qt - ft * Ct * qt + ft * Nt * jt - xt * Lt * jt) + tt[11] * (+lt * Nt * Wt - lt * Mt * qt - xt * Ct * Wt + mt * Ct * qt + xt * Mt * jt - mt * Nt * jt) + tt[15] * (-ft * Mt * jt - lt * Lt * Wt + lt * Mt * Qt + ft * Ct * Wt - mt * Ct * Qt + mt * Lt * jt)
            }
            transpose() {
                const tt = this.elements;
                let lt;
                return lt = tt[1],
                tt[1] = tt[4],
                tt[4] = lt,
                lt = tt[2],
                tt[2] = tt[8],
                tt[8] = lt,
                lt = tt[6],
                tt[6] = tt[9],
                tt[9] = lt,
                lt = tt[3],
                tt[3] = tt[12],
                tt[12] = lt,
                lt = tt[7],
                tt[7] = tt[13],
                tt[13] = lt,
                lt = tt[11],
                tt[11] = tt[14],
                tt[14] = lt,
                this
            }
            setPosition(tt, lt, mt) {
                const ft = this.elements;
                return tt.isVector3 ? (ft[12] = tt.x,
                ft[13] = tt.y,
                ft[14] = tt.z) : (ft[12] = tt,
                ft[13] = lt,
                ft[14] = mt),
                this
            }
            invert() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[1]
                  , ft = tt[2]
                  , xt = tt[3]
                  , Ct = tt[4]
                  , Mt = tt[5]
                  , Lt = tt[6]
                  , Nt = tt[7]
                  , jt = tt[8]
                  , Wt = tt[9]
                  , Qt = tt[10]
                  , qt = tt[11]
                  , Xt = tt[12]
                  , Zt = tt[13]
                  , Yt = tt[14]
                  , sr = tt[15]
                  , er = Wt * Yt * Nt - Zt * Qt * Nt + Zt * Lt * qt - Mt * Yt * qt - Wt * Lt * sr + Mt * Qt * sr
                  , rr = Xt * Qt * Nt - jt * Yt * Nt - Xt * Lt * qt + Ct * Yt * qt + jt * Lt * sr - Ct * Qt * sr
                  , xr = jt * Zt * Nt - Xt * Wt * Nt + Xt * Mt * qt - Ct * Zt * qt - jt * Mt * sr + Ct * Wt * sr
                  , br = Xt * Wt * Lt - jt * Zt * Lt - Xt * Mt * Qt + Ct * Zt * Qt + jt * Mt * Yt - Ct * Wt * Yt
                  , yr = lt * er + mt * rr + ft * xr + xt * br;
                if (yr === 0)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const Pr = 1 / yr;
                return tt[0] = er * Pr,
                tt[1] = (Zt * Qt * xt - Wt * Yt * xt - Zt * ft * qt + mt * Yt * qt + Wt * ft * sr - mt * Qt * sr) * Pr,
                tt[2] = (Mt * Yt * xt - Zt * Lt * xt + Zt * ft * Nt - mt * Yt * Nt - Mt * ft * sr + mt * Lt * sr) * Pr,
                tt[3] = (Wt * Lt * xt - Mt * Qt * xt - Wt * ft * Nt + mt * Qt * Nt + Mt * ft * qt - mt * Lt * qt) * Pr,
                tt[4] = rr * Pr,
                tt[5] = (jt * Yt * xt - Xt * Qt * xt + Xt * ft * qt - lt * Yt * qt - jt * ft * sr + lt * Qt * sr) * Pr,
                tt[6] = (Xt * Lt * xt - Ct * Yt * xt - Xt * ft * Nt + lt * Yt * Nt + Ct * ft * sr - lt * Lt * sr) * Pr,
                tt[7] = (Ct * Qt * xt - jt * Lt * xt + jt * ft * Nt - lt * Qt * Nt - Ct * ft * qt + lt * Lt * qt) * Pr,
                tt[8] = xr * Pr,
                tt[9] = (Xt * Wt * xt - jt * Zt * xt - Xt * mt * qt + lt * Zt * qt + jt * mt * sr - lt * Wt * sr) * Pr,
                tt[10] = (Ct * Zt * xt - Xt * Mt * xt + Xt * mt * Nt - lt * Zt * Nt - Ct * mt * sr + lt * Mt * sr) * Pr,
                tt[11] = (jt * Mt * xt - Ct * Wt * xt - jt * mt * Nt + lt * Wt * Nt + Ct * mt * qt - lt * Mt * qt) * Pr,
                tt[12] = br * Pr,
                tt[13] = (jt * Zt * ft - Xt * Wt * ft + Xt * mt * Qt - lt * Zt * Qt - jt * mt * Yt + lt * Wt * Yt) * Pr,
                tt[14] = (Xt * Mt * ft - Ct * Zt * ft - Xt * mt * Lt + lt * Zt * Lt + Ct * mt * Yt - lt * Mt * Yt) * Pr,
                tt[15] = (Ct * Wt * ft - jt * Mt * ft + jt * mt * Lt - lt * Wt * Lt - Ct * mt * Qt + lt * Mt * Qt) * Pr,
                this
            }
            scale(tt) {
                const lt = this.elements
                  , mt = tt.x
                  , ft = tt.y
                  , xt = tt.z;
                return lt[0] *= mt,
                lt[4] *= ft,
                lt[8] *= xt,
                lt[1] *= mt,
                lt[5] *= ft,
                lt[9] *= xt,
                lt[2] *= mt,
                lt[6] *= ft,
                lt[10] *= xt,
                lt[3] *= mt,
                lt[7] *= ft,
                lt[11] *= xt,
                this
            }
            getMaxScaleOnAxis() {
                const tt = this.elements
                  , lt = tt[0] * tt[0] + tt[1] * tt[1] + tt[2] * tt[2]
                  , mt = tt[4] * tt[4] + tt[5] * tt[5] + tt[6] * tt[6]
                  , ft = tt[8] * tt[8] + tt[9] * tt[9] + tt[10] * tt[10];
                return Math.sqrt(Math.max(lt, mt, ft))
            }
            makeTranslation(tt, lt, mt) {
                return tt.isVector3 ? this.set(1, 0, 0, tt.x, 0, 1, 0, tt.y, 0, 0, 1, tt.z, 0, 0, 0, 1) : this.set(1, 0, 0, tt, 0, 1, 0, lt, 0, 0, 1, mt, 0, 0, 0, 1),
                this
            }
            makeRotationX(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(1, 0, 0, 0, 0, lt, -mt, 0, 0, mt, lt, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(lt, 0, mt, 0, 0, 1, 0, 0, -mt, 0, lt, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(lt, -mt, 0, 0, mt, lt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(tt, lt) {
                const mt = Math.cos(lt)
                  , ft = Math.sin(lt)
                  , xt = 1 - mt
                  , Ct = tt.x
                  , Mt = tt.y
                  , Lt = tt.z
                  , Nt = xt * Ct
                  , jt = xt * Mt;
                return this.set(Nt * Ct + mt, Nt * Mt - ft * Lt, Nt * Lt + ft * Mt, 0, Nt * Mt + ft * Lt, jt * Mt + mt, jt * Lt - ft * Ct, 0, Nt * Lt - ft * Mt, jt * Lt + ft * Ct, xt * Lt * Lt + mt, 0, 0, 0, 0, 1),
                this
            }
            makeScale(tt, lt, mt) {
                return this.set(tt, 0, 0, 0, 0, lt, 0, 0, 0, 0, mt, 0, 0, 0, 0, 1),
                this
            }
            makeShear(tt, lt, mt, ft, xt, Ct) {
                return this.set(1, mt, xt, 0, tt, 1, Ct, 0, lt, ft, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(tt, lt, mt) {
                const ft = this.elements
                  , xt = lt._x
                  , Ct = lt._y
                  , Mt = lt._z
                  , Lt = lt._w
                  , Nt = xt + xt
                  , jt = Ct + Ct
                  , Wt = Mt + Mt
                  , Qt = xt * Nt
                  , qt = xt * jt
                  , Xt = xt * Wt
                  , Zt = Ct * jt
                  , Yt = Ct * Wt
                  , sr = Mt * Wt
                  , er = Lt * Nt
                  , rr = Lt * jt
                  , xr = Lt * Wt
                  , br = mt.x
                  , yr = mt.y
                  , Pr = mt.z;
                return ft[0] = (1 - (Zt + sr)) * br,
                ft[1] = (qt + xr) * br,
                ft[2] = (Xt - rr) * br,
                ft[3] = 0,
                ft[4] = (qt - xr) * yr,
                ft[5] = (1 - (Qt + sr)) * yr,
                ft[6] = (Yt + er) * yr,
                ft[7] = 0,
                ft[8] = (Xt + rr) * Pr,
                ft[9] = (Yt - er) * Pr,
                ft[10] = (1 - (Qt + Zt)) * Pr,
                ft[11] = 0,
                ft[12] = tt.x,
                ft[13] = tt.y,
                ft[14] = tt.z,
                ft[15] = 1,
                this
            }
            decompose(tt, lt, mt) {
                const ft = this.elements;
                let xt = Wu.set(ft[0], ft[1], ft[2]).length();
                const Ct = Wu.set(ft[4], ft[5], ft[6]).length()
                  , Mt = Wu.set(ft[8], ft[9], ft[10]).length();
                this.determinant() < 0 && (xt = -xt),
                tt.x = ft[12],
                tt.y = ft[13],
                tt.z = ft[14],
                $a.copy(this);
                const Lt = 1 / xt
                  , Nt = 1 / Ct
                  , jt = 1 / Mt;
                return $a.elements[0] *= Lt,
                $a.elements[1] *= Lt,
                $a.elements[2] *= Lt,
                $a.elements[4] *= Nt,
                $a.elements[5] *= Nt,
                $a.elements[6] *= Nt,
                $a.elements[8] *= jt,
                $a.elements[9] *= jt,
                $a.elements[10] *= jt,
                lt.setFromRotationMatrix($a),
                mt.x = xt,
                mt.y = Ct,
                mt.z = Mt,
                this
            }
            makePerspective(tt, lt, mt, ft, xt, Ct, Mt=Qs) {
                const Lt = this.elements
                  , Nt = 2 * xt / (lt - tt)
                  , jt = 2 * xt / (mt - ft)
                  , Wt = (lt + tt) / (lt - tt)
                  , Qt = (mt + ft) / (mt - ft);
                let qt, Xt;
                if (Mt === Qs)
                    qt = -(Ct + xt) / (Ct - xt),
                    Xt = -2 * Ct * xt / (Ct - xt);
                else {
                    if (Mt !== na)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + Mt);
                    qt = -Ct / (Ct - xt),
                    Xt = -Ct * xt / (Ct - xt)
                }
                return Lt[0] = Nt,
                Lt[4] = 0,
                Lt[8] = Wt,
                Lt[12] = 0,
                Lt[1] = 0,
                Lt[5] = jt,
                Lt[9] = Qt,
                Lt[13] = 0,
                Lt[2] = 0,
                Lt[6] = 0,
                Lt[10] = qt,
                Lt[14] = Xt,
                Lt[3] = 0,
                Lt[7] = 0,
                Lt[11] = -1,
                Lt[15] = 0,
                this
            }
            makeOrthographic(tt, lt, mt, ft, xt, Ct, Mt=Qs) {
                const Lt = this.elements
                  , Nt = 1 / (lt - tt)
                  , jt = 1 / (mt - ft)
                  , Wt = 1 / (Ct - xt)
                  , Qt = (lt + tt) * Nt
                  , qt = (mt + ft) * jt;
                let Xt, Zt;
                if (Mt === Qs)
                    Xt = (Ct + xt) * Wt,
                    Zt = -2 * Wt;
                else {
                    if (Mt !== na)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + Mt);
                    Xt = xt * Wt,
                    Zt = -1 * Wt
                }
                return Lt[0] = 2 * Nt,
                Lt[4] = 0,
                Lt[8] = 0,
                Lt[12] = -Qt,
                Lt[1] = 0,
                Lt[5] = 2 * jt,
                Lt[9] = 0,
                Lt[13] = -qt,
                Lt[2] = 0,
                Lt[6] = 0,
                Lt[10] = Zt,
                Lt[14] = -Xt,
                Lt[3] = 0,
                Lt[7] = 0,
                Lt[11] = 0,
                Lt[15] = 1,
                this
            }
            equals(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                for (let ft = 0; ft < 16; ft++)
                    if (lt[ft] !== mt[ft])
                        return !1;
                return !0
            }
            fromArray(tt, lt=0) {
                for (let mt = 0; mt < 16; mt++)
                    this.elements[mt] = tt[mt + lt];
                return this
            }
            toArray(tt=[], lt=0) {
                const mt = this.elements;
                return tt[lt] = mt[0],
                tt[lt + 1] = mt[1],
                tt[lt + 2] = mt[2],
                tt[lt + 3] = mt[3],
                tt[lt + 4] = mt[4],
                tt[lt + 5] = mt[5],
                tt[lt + 6] = mt[6],
                tt[lt + 7] = mt[7],
                tt[lt + 8] = mt[8],
                tt[lt + 9] = mt[9],
                tt[lt + 10] = mt[10],
                tt[lt + 11] = mt[11],
                tt[lt + 12] = mt[12],
                tt[lt + 13] = mt[13],
                tt[lt + 14] = mt[14],
                tt[lt + 15] = mt[15],
                tt
            }
        }
        const Wu = new Er
          , $a = new no
          , qu = new Er(0,0,0)
          , ov = new Er(1,1,1)
          , tu = new Er
          , cm = new Er
          , Ss = new Er
          , sv = new no
          , Su = new Is;
        class $u {
            constructor(tt=0, lt=0, mt=0, ft=$u.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = tt,
                this._y = lt,
                this._z = mt,
                this._order = ft
            }
            get x() {
                return this._x
            }
            set x(tt) {
                this._x = tt,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(tt) {
                this._y = tt,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(tt) {
                this._z = tt,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(tt) {
                this._order = tt,
                this._onChangeCallback()
            }
            set(tt, lt, mt, ft=this._order) {
                return this._x = tt,
                this._y = lt,
                this._z = mt,
                this._order = ft,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(tt) {
                return this._x = tt._x,
                this._y = tt._y,
                this._z = tt._z,
                this._order = tt._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(tt, lt=this._order, mt=!0) {
                const ft = tt.elements
                  , xt = ft[0]
                  , Ct = ft[4]
                  , Mt = ft[8]
                  , Lt = ft[1]
                  , Nt = ft[5]
                  , jt = ft[9]
                  , Wt = ft[2]
                  , Qt = ft[6]
                  , qt = ft[10];
                switch (lt) {
                case "XYZ":
                    this._y = Math.asin(qo(Mt, -1, 1)),
                    Math.abs(Mt) < .9999999 ? (this._x = Math.atan2(-jt, qt),
                    this._z = Math.atan2(-Ct, xt)) : (this._x = Math.atan2(Qt, Nt),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-qo(jt, -1, 1)),
                    Math.abs(jt) < .9999999 ? (this._y = Math.atan2(Mt, qt),
                    this._z = Math.atan2(Lt, Nt)) : (this._y = Math.atan2(-Wt, xt),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(qo(Qt, -1, 1)),
                    Math.abs(Qt) < .9999999 ? (this._y = Math.atan2(-Wt, qt),
                    this._z = Math.atan2(-Ct, Nt)) : (this._y = 0,
                    this._z = Math.atan2(Lt, xt));
                    break;
                case "ZYX":
                    this._y = Math.asin(-qo(Wt, -1, 1)),
                    Math.abs(Wt) < .9999999 ? (this._x = Math.atan2(Qt, qt),
                    this._z = Math.atan2(Lt, xt)) : (this._x = 0,
                    this._z = Math.atan2(-Ct, Nt));
                    break;
                case "YZX":
                    this._z = Math.asin(qo(Lt, -1, 1)),
                    Math.abs(Lt) < .9999999 ? (this._x = Math.atan2(-jt, Nt),
                    this._y = Math.atan2(-Wt, xt)) : (this._x = 0,
                    this._y = Math.atan2(Mt, qt));
                    break;
                case "XZY":
                    this._z = Math.asin(-qo(Ct, -1, 1)),
                    Math.abs(Ct) < .9999999 ? (this._x = Math.atan2(Qt, Nt),
                    this._y = Math.atan2(Mt, xt)) : (this._x = Math.atan2(-jt, qt),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + lt)
                }
                return this._order = lt,
                mt === !0 && this._onChangeCallback(),
                this
            }
            setFromQuaternion(tt, lt, mt) {
                return sv.makeRotationFromQuaternion(tt),
                this.setFromRotationMatrix(sv, lt, mt)
            }
            setFromVector3(tt, lt=this._order) {
                return this.set(tt.x, tt.y, tt.z, lt)
            }
            reorder(tt) {
                return Su.setFromEuler(this),
                this.setFromQuaternion(Su, tt)
            }
            equals(tt) {
                return tt._x === this._x && tt._y === this._y && tt._z === this._z && tt._order === this._order
            }
            fromArray(tt) {
                return this._x = tt[0],
                this._y = tt[1],
                this._z = tt[2],
                tt[3] !== void 0 && (this._order = tt[3]),
                this._onChangeCallback(),
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this._x,
                tt[lt + 1] = this._y,
                tt[lt + 2] = this._z,
                tt[lt + 3] = this._order,
                tt
            }
            _onChange(tt) {
                return this._onChangeCallback = tt,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        $u.DEFAULT_ORDER = "XYZ";
        class um {
            constructor() {
                this.mask = 1
            }
            set(tt) {
                this.mask = 1 << tt >>> 0
            }
            enable(tt) {
                this.mask |= 1 << tt
            }
            enableAll() {
                this.mask = -1
            }
            toggle(tt) {
                this.mask ^= 1 << tt
            }
            disable(tt) {
                this.mask &= ~(1 << tt)
            }
            disableAll() {
                this.mask = 0
            }
            test(tt) {
                return !!(this.mask & tt.mask)
            }
            isEnabled(tt) {
                return !!(this.mask & 1 << tt)
            }
        }
        let D0 = 0;
        const av = new Er
          , Xu = new Is
          , Ns = new no
          , xp = new Er
          , bp = new Er
          , l_ = new Er
          , lv = new Is
          , cv = new Er(1,0,0)
          , dm = new Er(0,1,0)
          , uv = new Er(0,0,1)
          , ru = {
            type: "added"
        }
          , B0 = {
            type: "removed"
        };
        class Mo extends As {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: D0++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = Mo.DEFAULT_UP.clone();
                const tt = new Er
                  , lt = new $u
                  , mt = new Is
                  , ft = new Er(1,1,1);
                lt._onChange(function() {
                    mt.setFromEuler(lt, !1)
                }),
                mt._onChange(function() {
                    lt.setFromQuaternion(mt, void 0, !1)
                }),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: tt
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: lt
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: mt
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: ft
                    },
                    modelViewMatrix: {
                        value: new no
                    },
                    normalMatrix: {
                        value: new lo
                    }
                }),
                this.matrix = new no,
                this.matrixWorld = new no,
                this.matrixAutoUpdate = Mo.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.matrixWorldAutoUpdate = Mo.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.layers = new um,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeRender(tt, lt, mt, ft, xt, Ct) {
                this.dispatchEvent({
                    type: "beforeRender",
                    renderer: tt,
                    scene: lt,
                    camera: mt,
                    geometry: ft,
                    material: xt,
                    group: Ct
                })
            }
            onAfterRender(tt, lt, mt, ft, xt, Ct) {
                this.dispatchEvent({
                    type: "afterRender",
                    renderer: tt,
                    scene: lt,
                    camera: mt,
                    geometry: ft,
                    material: xt,
                    group: Ct
                })
            }
            applyMatrix4(tt) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(tt),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(tt) {
                return this.quaternion.premultiply(tt),
                this
            }
            setRotationFromAxisAngle(tt, lt) {
                this.quaternion.setFromAxisAngle(tt, lt)
            }
            setRotationFromEuler(tt) {
                this.quaternion.setFromEuler(tt, !0)
            }
            setRotationFromMatrix(tt) {
                this.quaternion.setFromRotationMatrix(tt)
            }
            setRotationFromQuaternion(tt) {
                this.quaternion.copy(tt)
            }
            rotateOnAxis(tt, lt) {
                return Xu.setFromAxisAngle(tt, lt),
                this.quaternion.multiply(Xu),
                this
            }
            rotateOnWorldAxis(tt, lt) {
                return Xu.setFromAxisAngle(tt, lt),
                this.quaternion.premultiply(Xu),
                this
            }
            rotateX(tt) {
                return this.rotateOnAxis(cv, tt)
            }
            rotateY(tt) {
                return this.rotateOnAxis(dm, tt)
            }
            rotateZ(tt) {
                return this.rotateOnAxis(uv, tt)
            }
            translateOnAxis(tt, lt) {
                return av.copy(tt).applyQuaternion(this.quaternion),
                this.position.add(av.multiplyScalar(lt)),
                this
            }
            translateX(tt) {
                return this.translateOnAxis(cv, tt)
            }
            translateY(tt) {
                return this.translateOnAxis(dm, tt)
            }
            translateZ(tt) {
                return this.translateOnAxis(uv, tt)
            }
            localToWorld(tt) {
                return this.updateWorldMatrix(!0, !1),
                tt.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(tt) {
                return this.updateWorldMatrix(!0, !1),
                tt.applyMatrix4(Ns.copy(this.matrixWorld).invert())
            }
            lookAt(tt, lt, mt) {
                tt.isVector3 ? xp.copy(tt) : xp.set(tt, lt, mt);
                const ft = this.parent;
                this.updateWorldMatrix(!0, !1),
                bp.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Ns.lookAt(bp, xp, this.up) : Ns.lookAt(xp, bp, this.up),
                this.quaternion.setFromRotationMatrix(Ns),
                ft && (Ns.extractRotation(ft.matrixWorld),
                Xu.setFromRotationMatrix(Ns),
                this.quaternion.premultiply(Xu.invert()))
            }
            add(tt) {
                if (arguments.length > 1) {
                    for (let lt = 0; lt < arguments.length; lt++)
                        this.add(arguments[lt]);
                    return this
                }
                return tt === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", tt),
                this) : (tt && tt.isObject3D ? (tt.parent !== null && tt.parent.remove(tt),
                tt.parent = this,
                this.children.push(tt),
                tt.dispatchEvent(ru)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", tt),
                this)
            }
            remove(tt) {
                if (arguments.length > 1) {
                    for (let mt = 0; mt < arguments.length; mt++)
                        this.remove(arguments[mt]);
                    return this
                }
                const lt = this.children.indexOf(tt);
                return lt !== -1 && (tt.parent = null,
                this.children.splice(lt, 1),
                tt.dispatchEvent(B0)),
                this
            }
            removeFromParent() {
                const tt = this.parent;
                return tt !== null && tt.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(tt) {
                return this.updateWorldMatrix(!0, !1),
                Ns.copy(this.matrixWorld).invert(),
                tt.parent !== null && (tt.parent.updateWorldMatrix(!0, !1),
                Ns.multiply(tt.parent.matrixWorld)),
                tt.applyMatrix4(Ns),
                this.add(tt),
                tt.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(tt) {
                return this.getObjectByProperty("id", tt)
            }
            getObjectByName(tt) {
                return this.getObjectByProperty("name", tt)
            }
            getObjectByProperty(tt, lt) {
                if (this[tt] === lt)
                    return this;
                for (let mt = 0, ft = this.children.length; mt < ft; mt++) {
                    const xt = this.children[mt].getObjectByProperty(tt, lt);
                    if (xt !== void 0)
                        return xt
                }
            }
            getObjectsByProperty(tt, lt) {
                let mt = [];
                this[tt] === lt && mt.push(this);
                for (let ft = 0, xt = this.children.length; ft < xt; ft++) {
                    const Ct = this.children[ft].getObjectsByProperty(tt, lt);
                    Ct.length > 0 && (mt = mt.concat(Ct))
                }
                return mt
            }
            getWorldPosition(tt) {
                return this.updateWorldMatrix(!0, !1),
                tt.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(tt) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(bp, tt, l_),
                tt
            }
            getWorldScale(tt) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(bp, lv, tt),
                tt
            }
            getWorldDirection(tt) {
                this.updateWorldMatrix(!0, !1);
                const lt = this.matrixWorld.elements;
                return tt.set(lt[8], lt[9], lt[10]).normalize()
            }
            raycast() {}
            traverse(tt) {
                tt(this);
                const lt = this.children;
                for (let mt = 0, ft = lt.length; mt < ft; mt++)
                    lt[mt].traverse(tt)
            }
            traverseVisible(tt) {
                if (this.visible === !1)
                    return;
                tt(this);
                const lt = this.children;
                for (let mt = 0, ft = lt.length; mt < ft; mt++)
                    lt[mt].traverseVisible(tt)
            }
            traverseAncestors(tt) {
                const lt = this.parent;
                lt !== null && (tt(lt),
                lt.traverseAncestors(tt))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(tt) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || tt) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                tt = !0);
                const lt = this.children;
                for (let mt = 0, ft = lt.length; mt < ft; mt++) {
                    const xt = lt[mt];
                    xt.matrixWorldAutoUpdate !== !0 && tt !== !0 || xt.updateMatrixWorld(tt)
                }
            }
            updateWorldMatrix(tt, lt) {
                const mt = this.parent;
                if (tt === !0 && mt !== null && mt.matrixWorldAutoUpdate === !0 && mt.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                lt === !0) {
                    const ft = this.children;
                    for (let xt = 0, Ct = ft.length; xt < Ct; xt++) {
                        const Mt = ft[xt];
                        Mt.matrixWorldAutoUpdate === !0 && Mt.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string"
                  , mt = {};
                lt && (tt = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {},
                    extras: {}
                },
                mt.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const ft = {};
                function xt(Mt, Lt) {
                    return Mt[Lt.uuid] === void 0 && (Mt[Lt.uuid] = Lt.toJSON(tt)),
                    Lt.uuid
                }
                if (ft.uuid = this.uuid,
                ft.type = this.type,
                this.name !== "" && (ft.name = this.name),
                this.castShadow === !0 && (ft.castShadow = !0),
                this.receiveShadow === !0 && (ft.receiveShadow = !0),
                this.visible === !1 && (ft.visible = !1),
                this.frustumCulled === !1 && (ft.frustumCulled = !1),
                this.renderOrder !== 0 && (ft.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (ft.userData = this.userData),
                ft.layers = this.layers.mask,
                ft.matrix = this.matrix.toArray(),
                ft.up = this.up.toArray(),
                this.matrixAutoUpdate === !1 && (ft.matrixAutoUpdate = !1),
                this.isInstancedMesh && (ft.type = "InstancedMesh",
                ft.count = this.count,
                ft.instanceMatrix = this.instanceMatrix.toJSON(),
                this.instanceColor !== null && (ft.instanceColor = this.instanceColor.toJSON())),
                this.isScene)
                    this.background && (this.background.isColor ? ft.background = this.background.toJSON() : this.background.isTexture && (ft.background = this.background.toJSON(tt).uuid)),
                    this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (ft.environment = this.environment.toJSON(tt).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    ft.geometry = xt(tt.geometries, this.geometry);
                    const Mt = this.geometry.parameters;
                    if (Mt !== void 0 && Mt.shapes !== void 0) {
                        const Lt = Mt.shapes;
                        if (Array.isArray(Lt))
                            for (let Nt = 0, jt = Lt.length; Nt < jt; Nt++) {
                                const Wt = Lt[Nt];
                                xt(tt.shapes, Wt)
                            }
                        else
                            xt(tt.shapes, Lt)
                    }
                }
                if (this.isSkinnedMesh && (ft.bindMode = this.bindMode,
                ft.bindMatrix = this.bindMatrix.toArray(),
                this.skeleton !== void 0 && (xt(tt.skeletons, this.skeleton),
                ft.skeleton = this.skeleton.uuid)),
                this.material !== void 0)
                    if (Array.isArray(this.material)) {
                        const Mt = [];
                        for (let Lt = 0, Nt = this.material.length; Lt < Nt; Lt++)
                            Mt.push(xt(tt.materials, this.material[Lt]));
                        ft.material = Mt
                    } else
                        ft.material = xt(tt.materials, this.material);
                if (this.children.length > 0) {
                    ft.children = [];
                    for (let Mt = 0; Mt < this.children.length; Mt++)
                        ft.children.push(this.children[Mt].toJSON(tt).object)
                }
                if (this.animations.length > 0) {
                    ft.animations = [];
                    for (let Mt = 0; Mt < this.animations.length; Mt++) {
                        const Lt = this.animations[Mt];
                        ft.animations.push(xt(tt.animations, Lt))
                    }
                }
                if (lt) {
                    const Mt = Ct(tt.geometries)
                      , Lt = Ct(tt.materials)
                      , Nt = Ct(tt.textures)
                      , jt = Ct(tt.images)
                      , Wt = Ct(tt.shapes)
                      , Qt = Ct(tt.skeletons)
                      , qt = Ct(tt.animations)
                      , Xt = Ct(tt.nodes);
                    Mt.length > 0 && (mt.geometries = Mt),
                    Lt.length > 0 && (mt.materials = Lt),
                    Nt.length > 0 && (mt.textures = Nt),
                    jt.length > 0 && (mt.images = jt),
                    Wt.length > 0 && (mt.shapes = Wt),
                    Qt.length > 0 && (mt.skeletons = Qt),
                    qt.length > 0 && (mt.animations = qt),
                    Xt.length > 0 && (mt.nodes = Xt)
                }
                return mt.object = ft,
                mt;
                function Ct(Mt) {
                    const Lt = [];
                    for (const Nt in Mt) {
                        const jt = Mt[Nt];
                        delete jt.metadata,
                        Lt.push(jt)
                    }
                    return Lt
                }
            }
            clone(tt) {
                return new this.constructor().copy(this, tt)
            }
            copy(tt, lt=!0) {
                this.name = tt.name,
                this.up.copy(tt.up),
                this.position.copy(tt.position),
                this.rotation.order = tt.rotation.order,
                this.quaternion.copy(tt.quaternion),
                this.scale.copy(tt.scale),
                this.matrix.copy(tt.matrix),
                this.matrixWorld.copy(tt.matrixWorld),
                this.matrixAutoUpdate = tt.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = tt.matrixWorldNeedsUpdate,
                this.matrixWorldAutoUpdate = tt.matrixWorldAutoUpdate,
                this.layers.mask = tt.layers.mask,
                this.visible = tt.visible,
                this.castShadow = tt.castShadow,
                this.receiveShadow = tt.receiveShadow,
                this.frustumCulled = tt.frustumCulled,
                this.renderOrder = tt.renderOrder,
                this.animations = tt.animations.slice(),
                this.userData = {};
                for (const [mt,ft] of Object.entries(tt.userData))
                    this.userData[mt] = !ft || ft && (ft.isTexture || ft.isObject3D) ? ft : JSON.parse(JSON.stringify(ft));
                if (lt === !0)
                    for (let mt = 0; mt < tt.children.length; mt++) {
                        const ft = tt.children[mt];
                        this.add(ft.clone())
                    }
                return this
            }
        }
        Mo.DEFAULT_UP = new Er(0,1,0),
        Mo.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        Mo.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const Fs = new Er
          , Il = new Er
          , c_ = new Er
          , Ul = new Er
          , Yu = new Er
          , Ku = new Er
          , dv = new Er
          , u_ = new Er
          , _l = new Er
          , pm = new Er;
        let hm = !1;
        class Es {
            constructor(tt=new Er, lt=new Er, mt=new Er) {
                this.a = tt,
                this.b = lt,
                this.c = mt
            }
            static getNormal(tt, lt, mt, ft) {
                ft.subVectors(mt, lt),
                Fs.subVectors(tt, lt),
                ft.cross(Fs);
                const xt = ft.lengthSq();
                return xt > 0 ? ft.multiplyScalar(1 / Math.sqrt(xt)) : ft.set(0, 0, 0)
            }
            static getBarycoord(tt, lt, mt, ft, xt) {
                Fs.subVectors(ft, lt),
                Il.subVectors(mt, lt),
                c_.subVectors(tt, lt);
                const Ct = Fs.dot(Fs)
                  , Mt = Fs.dot(Il)
                  , Lt = Fs.dot(c_)
                  , Nt = Il.dot(Il)
                  , jt = Il.dot(c_)
                  , Wt = Ct * Nt - Mt * Mt;
                if (Wt === 0)
                    return xt.set(-2, -1, -1);
                const Qt = 1 / Wt
                  , qt = (Nt * Lt - Mt * jt) * Qt
                  , Xt = (Ct * jt - Mt * Lt) * Qt;
                return xt.set(1 - qt - Xt, Xt, qt)
            }
            static containsPoint(tt, lt, mt, ft) {
                return this.getBarycoord(tt, lt, mt, ft, Ul),
                Ul.x >= 0 && Ul.y >= 0 && Ul.x + Ul.y <= 1
            }
            static getUV(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                return hm === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                hm = !0),
                this.getInterpolation(tt, lt, mt, ft, xt, Ct, Mt, Lt)
            }
            static getInterpolation(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                return this.getBarycoord(tt, lt, mt, ft, Ul),
                Lt.setScalar(0),
                Lt.addScaledVector(xt, Ul.x),
                Lt.addScaledVector(Ct, Ul.y),
                Lt.addScaledVector(Mt, Ul.z),
                Lt
            }
            static isFrontFacing(tt, lt, mt, ft) {
                return Fs.subVectors(mt, lt),
                Il.subVectors(tt, lt),
                Fs.cross(Il).dot(ft) < 0
            }
            set(tt, lt, mt) {
                return this.a.copy(tt),
                this.b.copy(lt),
                this.c.copy(mt),
                this
            }
            setFromPointsAndIndices(tt, lt, mt, ft) {
                return this.a.copy(tt[lt]),
                this.b.copy(tt[mt]),
                this.c.copy(tt[ft]),
                this
            }
            setFromAttributeAndIndices(tt, lt, mt, ft) {
                return this.a.fromBufferAttribute(tt, lt),
                this.b.fromBufferAttribute(tt, mt),
                this.c.fromBufferAttribute(tt, ft),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.a.copy(tt.a),
                this.b.copy(tt.b),
                this.c.copy(tt.c),
                this
            }
            getArea() {
                return Fs.subVectors(this.c, this.b),
                Il.subVectors(this.a, this.b),
                .5 * Fs.cross(Il).length()
            }
            getMidpoint(tt) {
                return tt.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(tt) {
                return Es.getNormal(this.a, this.b, this.c, tt)
            }
            getPlane(tt) {
                return tt.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(tt, lt) {
                return Es.getBarycoord(tt, this.a, this.b, this.c, lt)
            }
            getUV(tt, lt, mt, ft, xt) {
                return hm === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                hm = !0),
                Es.getInterpolation(tt, this.a, this.b, this.c, lt, mt, ft, xt)
            }
            getInterpolation(tt, lt, mt, ft, xt) {
                return Es.getInterpolation(tt, this.a, this.b, this.c, lt, mt, ft, xt)
            }
            containsPoint(tt) {
                return Es.containsPoint(tt, this.a, this.b, this.c)
            }
            isFrontFacing(tt) {
                return Es.isFrontFacing(this.a, this.b, this.c, tt)
            }
            intersectsBox(tt) {
                return tt.intersectsTriangle(this)
            }
            closestPointToPoint(tt, lt) {
                const mt = this.a
                  , ft = this.b
                  , xt = this.c;
                let Ct, Mt;
                Yu.subVectors(ft, mt),
                Ku.subVectors(xt, mt),
                u_.subVectors(tt, mt);
                const Lt = Yu.dot(u_)
                  , Nt = Ku.dot(u_);
                if (Lt <= 0 && Nt <= 0)
                    return lt.copy(mt);
                _l.subVectors(tt, ft);
                const jt = Yu.dot(_l)
                  , Wt = Ku.dot(_l);
                if (jt >= 0 && Wt <= jt)
                    return lt.copy(ft);
                const Qt = Lt * Wt - jt * Nt;
                if (Qt <= 0 && Lt >= 0 && jt <= 0)
                    return Ct = Lt / (Lt - jt),
                    lt.copy(mt).addScaledVector(Yu, Ct);
                pm.subVectors(tt, xt);
                const qt = Yu.dot(pm)
                  , Xt = Ku.dot(pm);
                if (Xt >= 0 && qt <= Xt)
                    return lt.copy(xt);
                const Zt = qt * Nt - Lt * Xt;
                if (Zt <= 0 && Nt >= 0 && Xt <= 0)
                    return Mt = Nt / (Nt - Xt),
                    lt.copy(mt).addScaledVector(Ku, Mt);
                const Yt = jt * Xt - qt * Wt;
                if (Yt <= 0 && Wt - jt >= 0 && qt - Xt >= 0)
                    return dv.subVectors(xt, ft),
                    Mt = (Wt - jt) / (Wt - jt + (qt - Xt)),
                    lt.copy(ft).addScaledVector(dv, Mt);
                const sr = 1 / (Yt + Zt + Qt);
                return Ct = Zt * sr,
                Mt = Qt * sr,
                lt.copy(mt).addScaledVector(Yu, Ct).addScaledVector(Ku, Mt)
            }
            equals(tt) {
                return tt.a.equals(this.a) && tt.b.equals(this.b) && tt.c.equals(this.c)
            }
        }
        let L0 = 0;
        class hs extends As {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: L0++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.type = "Material",
                this.blending = Pt,
                this.side = vt,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = hr,
                this.blendDst = gr,
                this.blendEquation = kt,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = vr,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = mp,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = Yp,
                this.stencilZFail = Yp,
                this.stencilZPass = Yp,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(tt) {
                this._alphaTest > 0 != tt > 0 && this.version++,
                this._alphaTest = tt
            }
            onBuild() {}
            onBeforeRender() {}
            onAfterRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(tt) {
                if (tt !== void 0)
                    for (const lt in tt) {
                        const mt = tt[lt];
                        if (mt === void 0) {
                            console.warn(`THREE.Material: parameter '${
lt}' has value of undefined.`);
                            continue
                        }
                        const ft = this[lt];
                        ft !== void 0 && (ft && ft.isColor ? ft.set(mt) : ft && ft.isVector3 && mt && mt.isVector3 ? ft.copy(mt) : Array.isArray(mt) && ft && typeof ft.fromArray == "function" ? ft.fromArray(mt) : this[lt] = mt)
                    }
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string";
                lt && (tt = {
                    textures: {},
                    images: {}
                });
                const mt = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function ft(xt) {
                    const Ct = [];
                    for (const Mt in xt) {
                        const Lt = xt[Mt];
                        delete Lt.metadata,
                        Ct.push(Lt)
                    }
                    return Ct
                }
                if (mt.uuid = this.uuid,
                mt.type = this.type,
                this.name !== "" && (mt.name = this.name),
                this.color && this.color.isColor && (mt.color = this.color.getHex()),
                this.roughness !== void 0 && (mt.roughness = this.roughness),
                this.metalness !== void 0 && (mt.metalness = this.metalness),
                this.sheen !== void 0 && (mt.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (mt.sheenColor = this.sheenColor.getHex()),
                this.sheenRoughness !== void 0 && (mt.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (mt.emissive = this.emissive.getHex()),
                this.emissiveIntensity && this.emissiveIntensity !== 1 && (mt.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (mt.specular = this.specular.getHex()),
                this.specularIntensity !== void 0 && (mt.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (mt.specularColor = this.specularColor.getHex()),
                this.shininess !== void 0 && (mt.shininess = this.shininess),
                this.clearcoat !== void 0 && (mt.clearcoat = this.clearcoat),
                this.clearcoatRoughness !== void 0 && (mt.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (mt.clearcoatMap = this.clearcoatMap.toJSON(tt).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (mt.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(tt).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (mt.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(tt).uuid,
                mt.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.iridescence !== void 0 && (mt.iridescence = this.iridescence),
                this.iridescenceIOR !== void 0 && (mt.iridescenceIOR = this.iridescenceIOR),
                this.iridescenceThicknessRange !== void 0 && (mt.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (mt.iridescenceMap = this.iridescenceMap.toJSON(tt).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (mt.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(tt).uuid),
                this.anisotropy !== void 0 && (mt.anisotropy = this.anisotropy),
                this.anisotropyRotation !== void 0 && (mt.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (mt.anisotropyMap = this.anisotropyMap.toJSON(tt).uuid),
                this.map && this.map.isTexture && (mt.map = this.map.toJSON(tt).uuid),
                this.matcap && this.matcap.isTexture && (mt.matcap = this.matcap.toJSON(tt).uuid),
                this.alphaMap && this.alphaMap.isTexture && (mt.alphaMap = this.alphaMap.toJSON(tt).uuid),
                this.lightMap && this.lightMap.isTexture && (mt.lightMap = this.lightMap.toJSON(tt).uuid,
                mt.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (mt.aoMap = this.aoMap.toJSON(tt).uuid,
                mt.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (mt.bumpMap = this.bumpMap.toJSON(tt).uuid,
                mt.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (mt.normalMap = this.normalMap.toJSON(tt).uuid,
                mt.normalMapType = this.normalMapType,
                mt.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (mt.displacementMap = this.displacementMap.toJSON(tt).uuid,
                mt.displacementScale = this.displacementScale,
                mt.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (mt.roughnessMap = this.roughnessMap.toJSON(tt).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (mt.metalnessMap = this.metalnessMap.toJSON(tt).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (mt.emissiveMap = this.emissiveMap.toJSON(tt).uuid),
                this.specularMap && this.specularMap.isTexture && (mt.specularMap = this.specularMap.toJSON(tt).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (mt.specularIntensityMap = this.specularIntensityMap.toJSON(tt).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (mt.specularColorMap = this.specularColorMap.toJSON(tt).uuid),
                this.envMap && this.envMap.isTexture && (mt.envMap = this.envMap.toJSON(tt).uuid,
                this.combine !== void 0 && (mt.combine = this.combine)),
                this.envMapIntensity !== void 0 && (mt.envMapIntensity = this.envMapIntensity),
                this.reflectivity !== void 0 && (mt.reflectivity = this.reflectivity),
                this.refractionRatio !== void 0 && (mt.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (mt.gradientMap = this.gradientMap.toJSON(tt).uuid),
                this.transmission !== void 0 && (mt.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (mt.transmissionMap = this.transmissionMap.toJSON(tt).uuid),
                this.thickness !== void 0 && (mt.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (mt.thicknessMap = this.thicknessMap.toJSON(tt).uuid),
                this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (mt.attenuationDistance = this.attenuationDistance),
                this.attenuationColor !== void 0 && (mt.attenuationColor = this.attenuationColor.getHex()),
                this.size !== void 0 && (mt.size = this.size),
                this.shadowSide !== null && (mt.shadowSide = this.shadowSide),
                this.sizeAttenuation !== void 0 && (mt.sizeAttenuation = this.sizeAttenuation),
                this.blending !== Pt && (mt.blending = this.blending),
                this.side !== vt && (mt.side = this.side),
                this.vertexColors === !0 && (mt.vertexColors = !0),
                this.opacity < 1 && (mt.opacity = this.opacity),
                this.transparent === !0 && (mt.transparent = !0),
                mt.depthFunc = this.depthFunc,
                mt.depthTest = this.depthTest,
                mt.depthWrite = this.depthWrite,
                mt.colorWrite = this.colorWrite,
                mt.stencilWrite = this.stencilWrite,
                mt.stencilWriteMask = this.stencilWriteMask,
                mt.stencilFunc = this.stencilFunc,
                mt.stencilRef = this.stencilRef,
                mt.stencilFuncMask = this.stencilFuncMask,
                mt.stencilFail = this.stencilFail,
                mt.stencilZFail = this.stencilZFail,
                mt.stencilZPass = this.stencilZPass,
                this.rotation !== void 0 && this.rotation !== 0 && (mt.rotation = this.rotation),
                this.polygonOffset === !0 && (mt.polygonOffset = !0),
                this.polygonOffsetFactor !== 0 && (mt.polygonOffsetFactor = this.polygonOffsetFactor),
                this.polygonOffsetUnits !== 0 && (mt.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth !== void 0 && this.linewidth !== 1 && (mt.linewidth = this.linewidth),
                this.dashSize !== void 0 && (mt.dashSize = this.dashSize),
                this.gapSize !== void 0 && (mt.gapSize = this.gapSize),
                this.scale !== void 0 && (mt.scale = this.scale),
                this.dithering === !0 && (mt.dithering = !0),
                this.alphaTest > 0 && (mt.alphaTest = this.alphaTest),
                this.alphaHash === !0 && (mt.alphaHash = !0),
                this.alphaToCoverage === !0 && (mt.alphaToCoverage = !0),
                this.premultipliedAlpha === !0 && (mt.premultipliedAlpha = !0),
                this.forceSinglePass === !0 && (mt.forceSinglePass = !0),
                this.wireframe === !0 && (mt.wireframe = !0),
                this.wireframeLinewidth > 1 && (mt.wireframeLinewidth = this.wireframeLinewidth),
                this.wireframeLinecap !== "round" && (mt.wireframeLinecap = this.wireframeLinecap),
                this.wireframeLinejoin !== "round" && (mt.wireframeLinejoin = this.wireframeLinejoin),
                this.flatShading === !0 && (mt.flatShading = !0),
                this.visible === !1 && (mt.visible = !1),
                this.toneMapped === !1 && (mt.toneMapped = !1),
                this.fog === !1 && (mt.fog = !1),
                Object.keys(this.userData).length > 0 && (mt.userData = this.userData),
                lt) {
                    const xt = ft(tt.textures)
                      , Ct = ft(tt.images);
                    xt.length > 0 && (mt.textures = xt),
                    Ct.length > 0 && (mt.images = Ct)
                }
                return mt
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                this.name = tt.name,
                this.blending = tt.blending,
                this.side = tt.side,
                this.vertexColors = tt.vertexColors,
                this.opacity = tt.opacity,
                this.transparent = tt.transparent,
                this.blendSrc = tt.blendSrc,
                this.blendDst = tt.blendDst,
                this.blendEquation = tt.blendEquation,
                this.blendSrcAlpha = tt.blendSrcAlpha,
                this.blendDstAlpha = tt.blendDstAlpha,
                this.blendEquationAlpha = tt.blendEquationAlpha,
                this.depthFunc = tt.depthFunc,
                this.depthTest = tt.depthTest,
                this.depthWrite = tt.depthWrite,
                this.stencilWriteMask = tt.stencilWriteMask,
                this.stencilFunc = tt.stencilFunc,
                this.stencilRef = tt.stencilRef,
                this.stencilFuncMask = tt.stencilFuncMask,
                this.stencilFail = tt.stencilFail,
                this.stencilZFail = tt.stencilZFail,
                this.stencilZPass = tt.stencilZPass,
                this.stencilWrite = tt.stencilWrite;
                const lt = tt.clippingPlanes;
                let mt = null;
                if (lt !== null) {
                    const ft = lt.length;
                    mt = new Array(ft);
                    for (let xt = 0; xt !== ft; ++xt)
                        mt[xt] = lt[xt].clone()
                }
                return this.clippingPlanes = mt,
                this.clipIntersection = tt.clipIntersection,
                this.clipShadows = tt.clipShadows,
                this.shadowSide = tt.shadowSide,
                this.colorWrite = tt.colorWrite,
                this.precision = tt.precision,
                this.polygonOffset = tt.polygonOffset,
                this.polygonOffsetFactor = tt.polygonOffsetFactor,
                this.polygonOffsetUnits = tt.polygonOffsetUnits,
                this.dithering = tt.dithering,
                this.alphaTest = tt.alphaTest,
                this.alphaHash = tt.alphaHash,
                this.alphaToCoverage = tt.alphaToCoverage,
                this.premultipliedAlpha = tt.premultipliedAlpha,
                this.forceSinglePass = tt.forceSinglePass,
                this.visible = tt.visible,
                this.toneMapped = tt.toneMapped,
                this.userData = d_({}, tt.userData),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
        }
        function d_(Tt, tt) {
            if (!tt)
                return Tt;
            for (const lt of Object.keys(tt)) {
                if (lt.startsWith("__") || typeof Tt[lt] == "function" || typeof tt[lt] == "function")
                    continue;
                const mt = tt[lt]
                  , ft = !mt || mt.isTexture || mt.isObject3D || mt.isMaterial;
                ft || typeof tt[lt].clone != "function" ? ft || typeof tt[lt] != "object" && !Array.isArray(tt[lt]) ? Tt[lt] = tt[lt] : Tt[lt] = d_(Array.isArray(tt[lt]) ? [] : {}, tt[lt]) : Tt[lt] = tt[lt].clone()
            }
            return Tt
        }
        const p_ = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Vl = {
            h: 0,
            s: 0,
            l: 0
        }
          , mm = {
            h: 0,
            s: 0,
            l: 0
        };
        function h_(Tt, tt, lt) {
            return lt < 0 && (lt += 1),
            lt > 1 && (lt -= 1),
            lt < 1 / 6 ? Tt + 6 * (tt - Tt) * lt : lt < .5 ? tt : lt < 2 / 3 ? Tt + 6 * (tt - Tt) * (2 / 3 - lt) : Tt
        }
        class Gn {
            constructor(tt, lt, mt) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(tt, lt, mt)
            }
            set(tt, lt, mt) {
                if (lt === void 0 && mt === void 0) {
                    const ft = tt;
                    ft && ft.isColor ? this.copy(ft) : typeof ft == "number" ? this.setHex(ft) : typeof ft == "string" && this.setStyle(ft)
                } else
                    this.setRGB(tt, lt, mt);
                return this
            }
            setScalar(tt) {
                return this.r = tt,
                this.g = tt,
                this.b = tt,
                this
            }
            setHex(tt, lt=jo) {
                return tt = Math.floor(tt),
                this.r = (tt >> 16 & 255) / 255,
                this.g = (tt >> 8 & 255) / 255,
                this.b = (255 & tt) / 255,
                Do.toWorkingColorSpace(this, lt),
                this
            }
            setRGB(tt, lt, mt, ft=Do.workingColorSpace) {
                return this.r = tt,
                this.g = lt,
                this.b = mt,
                Do.toWorkingColorSpace(this, ft),
                this
            }
            setHSL(tt, lt, mt, ft=Do.workingColorSpace) {
                if (tt = em(tt, 1),
                lt = qo(lt, 0, 1),
                mt = qo(mt, 0, 1),
                lt === 0)
                    this.r = this.g = this.b = mt;
                else {
                    const xt = mt <= .5 ? mt * (1 + lt) : mt + lt - mt * lt
                      , Ct = 2 * mt - xt;
                    this.r = h_(Ct, xt, tt + 1 / 3),
                    this.g = h_(Ct, xt, tt),
                    this.b = h_(Ct, xt, tt - 1 / 3)
                }
                return Do.toWorkingColorSpace(this, ft),
                this
            }
            setStyle(tt, lt=jo) {
                function mt(xt) {
                    xt !== void 0 && parseFloat(xt) < 1 && console.warn("THREE.Color: Alpha component of " + tt + " will be ignored.")
                }
                let ft;
                if (ft = /^(\w+)\(([^\)]*)\)/.exec(tt)) {
                    let xt;
                    const Ct = ft[1]
                      , Mt = ft[2];
                    switch (Ct) {
                    case "rgb":
                    case "rgba":
                        if (xt = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Mt))
                            return mt(xt[4]),
                            this.setRGB(Math.min(255, parseInt(xt[1], 10)) / 255, Math.min(255, parseInt(xt[2], 10)) / 255, Math.min(255, parseInt(xt[3], 10)) / 255, lt);
                        if (xt = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Mt))
                            return mt(xt[4]),
                            this.setRGB(Math.min(100, parseInt(xt[1], 10)) / 100, Math.min(100, parseInt(xt[2], 10)) / 100, Math.min(100, parseInt(xt[3], 10)) / 100, lt);
                        break;
                    case "hsl":
                    case "hsla":
                        if (xt = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Mt))
                            return mt(xt[4]),
                            this.setHSL(parseFloat(xt[1]) / 360, parseFloat(xt[2]) / 100, parseFloat(xt[3]) / 100, lt);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + tt)
                    }
                } else if (ft = /^\#([A-Fa-f\d]+)$/.exec(tt)) {
                    const xt = ft[1]
                      , Ct = xt.length;
                    if (Ct === 3)
                        return this.setRGB(parseInt(xt.charAt(0), 16) / 15, parseInt(xt.charAt(1), 16) / 15, parseInt(xt.charAt(2), 16) / 15, lt);
                    if (Ct === 6)
                        return this.setHex(parseInt(xt, 16), lt);
                    console.warn("THREE.Color: Invalid hex color " + tt)
                } else if (tt && tt.length > 0)
                    return this.setColorName(tt, lt);
                return this
            }
            setColorName(tt, lt=jo) {
                const mt = p_[tt.toLowerCase()];
                return mt !== void 0 ? this.setHex(mt, lt) : console.warn("THREE.Color: Unknown color " + tt),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(tt) {
                return this.r = tt.r,
                this.g = tt.g,
                this.b = tt.b,
                this
            }
            copySRGBToLinear(tt) {
                return this.r = Uu(tt.r),
                this.g = Uu(tt.g),
                this.b = Uu(tt.b),
                this
            }
            copyLinearToSRGB(tt) {
                return this.r = nm(tt.r),
                this.g = nm(tt.g),
                this.b = nm(tt.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(tt=jo) {
                return Do.fromWorkingColorSpace(ms.copy(this), tt),
                65536 * Math.round(qo(255 * ms.r, 0, 255)) + 256 * Math.round(qo(255 * ms.g, 0, 255)) + Math.round(qo(255 * ms.b, 0, 255))
            }
            getHexString(tt=jo) {
                return ("000000" + this.getHex(tt).toString(16)).slice(-6)
            }
            getHSL(tt, lt=Do.workingColorSpace) {
                Do.fromWorkingColorSpace(ms.copy(this), lt);
                const mt = ms.r
                  , ft = ms.g
                  , xt = ms.b
                  , Ct = Math.max(mt, ft, xt)
                  , Mt = Math.min(mt, ft, xt);
                let Lt, Nt;
                const jt = (Mt + Ct) / 2;
                if (Mt === Ct)
                    Lt = 0,
                    Nt = 0;
                else {
                    const Wt = Ct - Mt;
                    switch (Nt = jt <= .5 ? Wt / (Ct + Mt) : Wt / (2 - Ct - Mt),
                    Ct) {
                    case mt:
                        Lt = (ft - xt) / Wt + (ft < xt ? 6 : 0);
                        break;
                    case ft:
                        Lt = (xt - mt) / Wt + 2;
                        break;
                    case xt:
                        Lt = (mt - ft) / Wt + 4
                    }
                    Lt /= 6
                }
                return tt.h = Lt,
                tt.s = Nt,
                tt.l = jt,
                tt
            }
            getRGB(tt, lt=Do.workingColorSpace) {
                return Do.fromWorkingColorSpace(ms.copy(this), lt),
                tt.r = ms.r,
                tt.g = ms.g,
                tt.b = ms.b,
                tt
            }
            getStyle(tt=jo) {
                Do.fromWorkingColorSpace(ms.copy(this), tt);
                const lt = ms.r
                  , mt = ms.g
                  , ft = ms.b;
                return tt !== jo ? `color(${
tt} ${
lt.toFixed(3)} ${
mt.toFixed(3)} ${
ft.toFixed(3)})` : `rgb(${
Math.round(255 * lt)},${
Math.round(255 * mt)},${
Math.round(255 * ft)})`
            }
            offsetHSL(tt, lt, mt) {
                return this.getHSL(Vl),
                this.setHSL(Vl.h + tt, Vl.s + lt, Vl.l + mt)
            }
            add(tt) {
                return this.r += tt.r,
                this.g += tt.g,
                this.b += tt.b,
                this
            }
            addColors(tt, lt) {
                return this.r = tt.r + lt.r,
                this.g = tt.g + lt.g,
                this.b = tt.b + lt.b,
                this
            }
            addScalar(tt) {
                return this.r += tt,
                this.g += tt,
                this.b += tt,
                this
            }
            sub(tt) {
                return this.r = Math.max(0, this.r - tt.r),
                this.g = Math.max(0, this.g - tt.g),
                this.b = Math.max(0, this.b - tt.b),
                this
            }
            multiply(tt) {
                return this.r *= tt.r,
                this.g *= tt.g,
                this.b *= tt.b,
                this
            }
            multiplyScalar(tt) {
                return this.r *= tt,
                this.g *= tt,
                this.b *= tt,
                this
            }
            lerp(tt, lt) {
                return this.r += (tt.r - this.r) * lt,
                this.g += (tt.g - this.g) * lt,
                this.b += (tt.b - this.b) * lt,
                this
            }
            lerpColors(tt, lt, mt) {
                return this.r = tt.r + (lt.r - tt.r) * mt,
                this.g = tt.g + (lt.g - tt.g) * mt,
                this.b = tt.b + (lt.b - tt.b) * mt,
                this
            }
            lerpHSL(tt, lt) {
                this.getHSL(Vl),
                tt.getHSL(mm);
                const mt = Fu(Vl.h, mm.h, lt)
                  , ft = Fu(Vl.s, mm.s, lt)
                  , xt = Fu(Vl.l, mm.l, lt);
                return this.setHSL(mt, ft, xt),
                this
            }
            setFromVector3(tt) {
                return this.r = tt.x,
                this.g = tt.y,
                this.b = tt.z,
                this
            }
            applyMatrix3(tt) {
                const lt = this.r
                  , mt = this.g
                  , ft = this.b
                  , xt = tt.elements;
                return this.r = xt[0] * lt + xt[3] * mt + xt[6] * ft,
                this.g = xt[1] * lt + xt[4] * mt + xt[7] * ft,
                this.b = xt[2] * lt + xt[5] * mt + xt[8] * ft,
                this
            }
            equals(tt) {
                return tt.r === this.r && tt.g === this.g && tt.b === this.b
            }
            fromArray(tt, lt=0) {
                return this.r = tt[lt],
                this.g = tt[lt + 1],
                this.b = tt[lt + 2],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.r,
                tt[lt + 1] = this.g,
                tt[lt + 2] = this.b,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.r = tt.getX(lt),
                this.g = tt.getY(lt),
                this.b = tt.getZ(lt),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const ms = new Gn;
        Gn.NAMES = p_;
        class nu extends hs {
            constructor(tt) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Wn,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.specularMap = tt.specularMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.combine = tt.combine,
                this.reflectivity = tt.reflectivity,
                this.refractionRatio = tt.refractionRatio,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.fog = tt.fog,
                this
            }
        }
        const Dl = O0();
        function O0() {
            const Tt = new ArrayBuffer(4)
              , tt = new Float32Array(Tt)
              , lt = new Uint32Array(Tt)
              , mt = new Uint32Array(512)
              , ft = new Uint32Array(512);
            for (let Lt = 0; Lt < 256; ++Lt) {
                const Nt = Lt - 127;
                Nt < -27 ? (mt[Lt] = 0,
                mt[256 | Lt] = 32768,
                ft[Lt] = 24,
                ft[256 | Lt] = 24) : Nt < -14 ? (mt[Lt] = 1024 >> -Nt - 14,
                mt[256 | Lt] = 1024 >> -Nt - 14 | 32768,
                ft[Lt] = -Nt - 1,
                ft[256 | Lt] = -Nt - 1) : Nt <= 15 ? (mt[Lt] = Nt + 15 << 10,
                mt[256 | Lt] = Nt + 15 << 10 | 32768,
                ft[Lt] = 13,
                ft[256 | Lt] = 13) : Nt < 128 ? (mt[Lt] = 31744,
                mt[256 | Lt] = 64512,
                ft[Lt] = 24,
                ft[256 | Lt] = 24) : (mt[Lt] = 31744,
                mt[256 | Lt] = 64512,
                ft[Lt] = 13,
                ft[256 | Lt] = 13)
            }
            const xt = new Uint32Array(2048)
              , Ct = new Uint32Array(64)
              , Mt = new Uint32Array(64);
            for (let Lt = 1; Lt < 1024; ++Lt) {
                let Nt = Lt << 13
                  , jt = 0;
                for (; !(8388608 & Nt); )
                    Nt <<= 1,
                    jt -= 8388608;
                Nt &= -8388609,
                jt += 947912704,
                xt[Lt] = Nt | jt
            }
            for (let Lt = 1024; Lt < 2048; ++Lt)
                xt[Lt] = 939524096 + (Lt - 1024 << 13);
            for (let Lt = 1; Lt < 31; ++Lt)
                Ct[Lt] = Lt << 23;
            Ct[31] = 1199570944,
            Ct[32] = 2147483648;
            for (let Lt = 33; Lt < 63; ++Lt)
                Ct[Lt] = 2147483648 + (Lt - 32 << 23);
            Ct[63] = 3347054592;
            for (let Lt = 1; Lt < 64; ++Lt)
                Lt !== 32 && (Mt[Lt] = 1024);
            return {
                floatView: tt,
                uint32View: lt,
                baseTable: mt,
                shiftTable: ft,
                mantissaTable: xt,
                exponentTable: Ct,
                offsetTable: Mt
            }
        }
        function Vt(Tt) {
            Math.abs(Tt) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            Tt = qo(Tt, -65504, 65504),
            Dl.floatView[0] = Tt;
            const tt = Dl.uint32View[0]
              , lt = tt >> 23 & 511;
            return Dl.baseTable[lt] + ((8388607 & tt) >> Dl.shiftTable[lt])
        }
        function wt(Tt) {
            const tt = Tt >> 10;
            return Dl.uint32View[0] = Dl.mantissaTable[Dl.offsetTable[tt] + (1023 & Tt)] + Dl.exponentTable[tt],
            Dl.floatView[0]
        }
        const Rt = {
            toHalfFloat: Vt,
            fromHalfFloat: wt
        }
          , zt = new Er
          , nr = new mn;
        class mr {
            constructor(tt, lt, mt=!1) {
                if (Array.isArray(tt))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = tt,
                this.itemSize = lt,
                this.count = tt !== void 0 ? tt.length / lt : 0,
                this.normalized = mt,
                this.usage = Nu,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.gpuType = ss,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            setUsage(tt) {
                return this.usage = tt,
                this
            }
            copy(tt) {
                return this.name = tt.name,
                this.array = new tt.array.constructor(tt.array),
                this.itemSize = tt.itemSize,
                this.count = tt.count,
                this.normalized = tt.normalized,
                this.usage = tt.usage,
                this.gpuType = tt.gpuType,
                this
            }
            copyAt(tt, lt, mt) {
                tt *= this.itemSize,
                mt *= lt.itemSize;
                for (let ft = 0, xt = this.itemSize; ft < xt; ft++)
                    this.array[tt + ft] = lt.array[mt + ft];
                return this
            }
            copyArray(tt) {
                return this.array.set(tt),
                this
            }
            applyMatrix3(tt) {
                if (this.itemSize === 2)
                    for (let lt = 0, mt = this.count; lt < mt; lt++)
                        nr.fromBufferAttribute(this, lt),
                        nr.applyMatrix3(tt),
                        this.setXY(lt, nr.x, nr.y);
                else if (this.itemSize === 3)
                    for (let lt = 0, mt = this.count; lt < mt; lt++)
                        zt.fromBufferAttribute(this, lt),
                        zt.applyMatrix3(tt),
                        this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            applyMatrix4(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    zt.fromBufferAttribute(this, lt),
                    zt.applyMatrix4(tt),
                    this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            applyNormalMatrix(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    zt.fromBufferAttribute(this, lt),
                    zt.applyNormalMatrix(tt),
                    this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            transformDirection(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    zt.fromBufferAttribute(this, lt),
                    zt.transformDirection(tt),
                    this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            set(tt, lt=0) {
                return this.array.set(tt, lt),
                this
            }
            getComponent(tt, lt) {
                let mt = this.array[tt * this.itemSize + lt];
                return this.normalized && (mt = ws(mt, this.array)),
                mt
            }
            setComponent(tt, lt, mt) {
                return this.normalized && (mt = oo(mt, this.array)),
                this.array[tt * this.itemSize + lt] = mt,
                this
            }
            getX(tt) {
                let lt = this.array[tt * this.itemSize];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setX(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize] = lt,
                this
            }
            getY(tt) {
                let lt = this.array[tt * this.itemSize + 1];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setY(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 1] = lt,
                this
            }
            getZ(tt) {
                let lt = this.array[tt * this.itemSize + 2];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setZ(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 2] = lt,
                this
            }
            getW(tt) {
                let lt = this.array[tt * this.itemSize + 3];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setW(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 3] = lt,
                this
            }
            setXY(tt, lt, mt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array)),
                this.array[tt + 0] = lt,
                this.array[tt + 1] = mt,
                this
            }
            setXYZ(tt, lt, mt, ft) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array)),
                this.array[tt + 0] = lt,
                this.array[tt + 1] = mt,
                this.array[tt + 2] = ft,
                this
            }
            setXYZW(tt, lt, mt, ft, xt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array),
                xt = oo(xt, this.array)),
                this.array[tt + 0] = lt,
                this.array[tt + 1] = mt,
                this.array[tt + 2] = ft,
                this.array[tt + 3] = xt,
                this
            }
            onUpload(tt) {
                return this.onUploadCallback = tt,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const tt = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return this.name !== "" && (tt.name = this.name),
                this.usage !== Nu && (tt.usage = this.usage),
                this.updateRange.offset === 0 && this.updateRange.count === -1 || (tt.updateRange = this.updateRange),
                tt
            }
        }
        class Tr extends mr {
            constructor(tt, lt, mt) {
                super(new Int8Array(tt), lt, mt)
            }
        }
        class $r extends mr {
            constructor(tt, lt, mt) {
                super(new Uint8Array(tt), lt, mt)
            }
        }
        class vn extends mr {
            constructor(tt, lt, mt) {
                super(new Uint8ClampedArray(tt), lt, mt)
            }
        }
        class zn extends mr {
            constructor(tt, lt, mt) {
                super(new Int16Array(tt), lt, mt)
            }
        }
        class co extends mr {
            constructor(tt, lt, mt) {
                super(new Uint16Array(tt), lt, mt)
            }
        }
        class is extends mr {
            constructor(tt, lt, mt) {
                super(new Int32Array(tt), lt, mt)
            }
        }
        class Ts extends mr {
            constructor(tt, lt, mt) {
                super(new Uint32Array(tt), lt, mt)
            }
        }
        class ks extends mr {
            constructor(tt, lt, mt) {
                super(new Uint16Array(tt), lt, mt),
                this.isFloat16BufferAttribute = !0
            }
            getX(tt) {
                let lt = wt(this.array[tt * this.itemSize]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setX(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize] = Vt(lt),
                this
            }
            getY(tt) {
                let lt = wt(this.array[tt * this.itemSize + 1]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setY(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 1] = Vt(lt),
                this
            }
            getZ(tt) {
                let lt = wt(this.array[tt * this.itemSize + 2]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setZ(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 2] = Vt(lt),
                this
            }
            getW(tt) {
                let lt = wt(this.array[tt * this.itemSize + 3]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setW(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 3] = Vt(lt),
                this
            }
            setXY(tt, lt, mt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array)),
                this.array[tt + 0] = Vt(lt),
                this.array[tt + 1] = Vt(mt),
                this
            }
            setXYZ(tt, lt, mt, ft) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array)),
                this.array[tt + 0] = Vt(lt),
                this.array[tt + 1] = Vt(mt),
                this.array[tt + 2] = Vt(ft),
                this
            }
            setXYZW(tt, lt, mt, ft, xt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array),
                xt = oo(xt, this.array)),
                this.array[tt + 0] = Vt(lt),
                this.array[tt + 1] = Vt(mt),
                this.array[tt + 2] = Vt(ft),
                this.array[tt + 3] = Vt(xt),
                this
            }
        }
        class Fn extends mr {
            constructor(tt, lt, mt) {
                super(new Float32Array(tt), lt, mt)
            }
        }
        class m_ extends mr {
            constructor(tt, lt, mt) {
                super(new Float64Array(tt), lt, mt)
            }
        }
        let fm = 0;
        const Ds = new no
          , Ju = new Mo
          , Gl = new Er
          , Us = new Tl
          , Ap = new Tl
          , fs = new Er;
        class bo extends As {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: fm++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(tt) {
                return Array.isArray(tt) ? this.index = new (tv(tt) ? Ts : co)(tt,1) : this.index = tt,
                this
            }
            getAttribute(tt) {
                return this.attributes[tt]
            }
            setAttribute(tt, lt) {
                return this.attributes[tt] = lt,
                this
            }
            deleteAttribute(tt) {
                return delete this.attributes[tt],
                this
            }
            hasAttribute(tt) {
                return this.attributes[tt] !== void 0
            }
            addGroup(tt, lt, mt=0) {
                this.groups.push({
                    start: tt,
                    count: lt,
                    materialIndex: mt
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(tt, lt) {
                this.drawRange.start = tt,
                this.drawRange.count = lt
            }
            applyMatrix4(tt) {
                const lt = this.attributes.position;
                lt !== void 0 && (lt.applyMatrix4(tt),
                lt.needsUpdate = !0);
                const mt = this.attributes.normal;
                if (mt !== void 0) {
                    const xt = new lo().getNormalMatrix(tt);
                    mt.applyNormalMatrix(xt),
                    mt.needsUpdate = !0
                }
                const ft = this.attributes.tangent;
                return ft !== void 0 && (ft.transformDirection(tt),
                ft.needsUpdate = !0),
                this.boundingBox !== null && this.computeBoundingBox(),
                this.boundingSphere !== null && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(tt) {
                return Ds.makeRotationFromQuaternion(tt),
                this.applyMatrix4(Ds),
                this
            }
            rotateX(tt) {
                return Ds.makeRotationX(tt),
                this.applyMatrix4(Ds),
                this
            }
            rotateY(tt) {
                return Ds.makeRotationY(tt),
                this.applyMatrix4(Ds),
                this
            }
            rotateZ(tt) {
                return Ds.makeRotationZ(tt),
                this.applyMatrix4(Ds),
                this
            }
            translate(tt, lt, mt) {
                return Ds.makeTranslation(tt, lt, mt),
                this.applyMatrix4(Ds),
                this
            }
            scale(tt, lt, mt) {
                return Ds.makeScale(tt, lt, mt),
                this.applyMatrix4(Ds),
                this
            }
            lookAt(tt) {
                return Ju.lookAt(tt),
                Ju.updateMatrix(),
                this.applyMatrix4(Ju.matrix),
                this
            }
            center(tt=void 0) {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Gl).negate(),
                this.translate(Gl.x, Gl.y, Gl.z),
                tt && tt.copy(Gl),
                this
            }
            setFromPoints(tt) {
                const lt = [];
                for (let mt = 0, ft = tt.length; mt < ft; mt++) {
                    const xt = tt[mt];
                    lt.push(xt.x, xt.y, xt.z || 0)
                }
                return this.setAttribute("position", new Fn(lt,3)),
                this
            }
            computeBoundingBox() {
                this.boundingBox === null && (this.boundingBox = new Tl);
                const tt = this.attributes.position
                  , lt = this.morphAttributes.position;
                if (tt && tt.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new Er(-1 / 0,-1 / 0,-1 / 0), new Er(1 / 0,1 / 0,1 / 0));
                if (tt !== void 0) {
                    if (this.boundingBox.setFromBufferAttribute(tt),
                    lt)
                        for (let mt = 0, ft = lt.length; mt < ft; mt++) {
                            const xt = lt[mt];
                            Us.setFromBufferAttribute(xt),
                            this.morphTargetsRelative ? (fs.addVectors(this.boundingBox.min, Us.min),
                            this.boundingBox.expandByPoint(fs),
                            fs.addVectors(this.boundingBox.max, Us.max),
                            this.boundingBox.expandByPoint(fs)) : (this.boundingBox.expandByPoint(Us.min),
                            this.boundingBox.expandByPoint(Us.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                this.boundingSphere === null && (this.boundingSphere = new Ws);
                const tt = this.attributes.position
                  , lt = this.morphAttributes.position;
                if (tt && tt.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new Er, 1 / 0);
                if (tt) {
                    const mt = this.boundingSphere.center;
                    if (Us.setFromBufferAttribute(tt),
                    lt)
                        for (let xt = 0, Ct = lt.length; xt < Ct; xt++) {
                            const Mt = lt[xt];
                            Ap.setFromBufferAttribute(Mt),
                            this.morphTargetsRelative ? (fs.addVectors(Us.min, Ap.min),
                            Us.expandByPoint(fs),
                            fs.addVectors(Us.max, Ap.max),
                            Us.expandByPoint(fs)) : (Us.expandByPoint(Ap.min),
                            Us.expandByPoint(Ap.max))
                        }
                    Us.getCenter(mt);
                    let ft = 0;
                    for (let xt = 0, Ct = tt.count; xt < Ct; xt++)
                        fs.fromBufferAttribute(tt, xt),
                        ft = Math.max(ft, mt.distanceToSquared(fs));
                    if (lt)
                        for (let xt = 0, Ct = lt.length; xt < Ct; xt++) {
                            const Mt = lt[xt]
                              , Lt = this.morphTargetsRelative;
                            for (let Nt = 0, jt = Mt.count; Nt < jt; Nt++)
                                fs.fromBufferAttribute(Mt, Nt),
                                Lt && (Gl.fromBufferAttribute(tt, Nt),
                                fs.add(Gl)),
                                ft = Math.max(ft, mt.distanceToSquared(fs))
                        }
                    this.boundingSphere.radius = Math.sqrt(ft),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const tt = this.index
                  , lt = this.attributes;
                if (tt === null || lt.position === void 0 || lt.normal === void 0 || lt.uv === void 0)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const mt = tt.array
                  , ft = lt.position.array
                  , xt = lt.normal.array
                  , Ct = lt.uv.array
                  , Mt = ft.length / 3;
                this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new mr(new Float32Array(4 * Mt),4));
                const Lt = this.getAttribute("tangent").array
                  , Nt = []
                  , jt = [];
                for (let Vr = 0; Vr < Mt; Vr++)
                    Nt[Vr] = new Er,
                    jt[Vr] = new Er;
                const Wt = new Er
                  , Qt = new Er
                  , qt = new Er
                  , Xt = new mn
                  , Zt = new mn
                  , Yt = new mn
                  , sr = new Er
                  , er = new Er;
                function rr(Vr, Gr, Hr) {
                    Wt.fromArray(ft, 3 * Vr),
                    Qt.fromArray(ft, 3 * Gr),
                    qt.fromArray(ft, 3 * Hr),
                    Xt.fromArray(Ct, 2 * Vr),
                    Zt.fromArray(Ct, 2 * Gr),
                    Yt.fromArray(Ct, 2 * Hr),
                    Qt.sub(Wt),
                    qt.sub(Wt),
                    Zt.sub(Xt),
                    Yt.sub(Xt);
                    const _n = 1 / (Zt.x * Yt.y - Yt.x * Zt.y);
                    isFinite(_n) && (sr.copy(Qt).multiplyScalar(Yt.y).addScaledVector(qt, -Zt.y).multiplyScalar(_n),
                    er.copy(qt).multiplyScalar(Zt.x).addScaledVector(Qt, -Yt.x).multiplyScalar(_n),
                    Nt[Vr].add(sr),
                    Nt[Gr].add(sr),
                    Nt[Hr].add(sr),
                    jt[Vr].add(er),
                    jt[Gr].add(er),
                    jt[Hr].add(er))
                }
                let xr = this.groups;
                xr.length === 0 && (xr = [{
                    start: 0,
                    count: mt.length
                }]);
                for (let Vr = 0, Gr = xr.length; Vr < Gr; ++Vr) {
                    const Hr = xr[Vr]
                      , _n = Hr.start;
                    for (let dn = _n, kn = _n + Hr.count; dn < kn; dn += 3)
                        rr(mt[dn + 0], mt[dn + 1], mt[dn + 2])
                }
                const br = new Er
                  , yr = new Er
                  , Pr = new Er
                  , zr = new Er;
                function Nr(Vr) {
                    Pr.fromArray(xt, 3 * Vr),
                    zr.copy(Pr);
                    const Gr = Nt[Vr];
                    br.copy(Gr),
                    br.sub(Pr.multiplyScalar(Pr.dot(Gr))).normalize(),
                    yr.crossVectors(zr, Gr);
                    const Hr = yr.dot(jt[Vr]) < 0 ? -1 : 1;
                    Lt[4 * Vr] = br.x,
                    Lt[4 * Vr + 1] = br.y,
                    Lt[4 * Vr + 2] = br.z,
                    Lt[4 * Vr + 3] = Hr
                }
                for (let Vr = 0, Gr = xr.length; Vr < Gr; ++Vr) {
                    const Hr = xr[Vr]
                      , _n = Hr.start;
                    for (let dn = _n, kn = _n + Hr.count; dn < kn; dn += 3)
                        Nr(mt[dn + 0]),
                        Nr(mt[dn + 1]),
                        Nr(mt[dn + 2])
                }
            }
            computeVertexNormals() {
                const tt = this.index
                  , lt = this.getAttribute("position");
                if (lt !== void 0) {
                    let mt = this.getAttribute("normal");
                    if (mt === void 0)
                        mt = new mr(new Float32Array(3 * lt.count),3),
                        this.setAttribute("normal", mt);
                    else
                        for (let Qt = 0, qt = mt.count; Qt < qt; Qt++)
                            mt.setXYZ(Qt, 0, 0, 0);
                    const ft = new Er
                      , xt = new Er
                      , Ct = new Er
                      , Mt = new Er
                      , Lt = new Er
                      , Nt = new Er
                      , jt = new Er
                      , Wt = new Er;
                    if (tt)
                        for (let Qt = 0, qt = tt.count; Qt < qt; Qt += 3) {
                            const Xt = tt.getX(Qt + 0)
                              , Zt = tt.getX(Qt + 1)
                              , Yt = tt.getX(Qt + 2);
                            ft.fromBufferAttribute(lt, Xt),
                            xt.fromBufferAttribute(lt, Zt),
                            Ct.fromBufferAttribute(lt, Yt),
                            jt.subVectors(Ct, xt),
                            Wt.subVectors(ft, xt),
                            jt.cross(Wt),
                            Mt.fromBufferAttribute(mt, Xt),
                            Lt.fromBufferAttribute(mt, Zt),
                            Nt.fromBufferAttribute(mt, Yt),
                            Mt.add(jt),
                            Lt.add(jt),
                            Nt.add(jt),
                            mt.setXYZ(Xt, Mt.x, Mt.y, Mt.z),
                            mt.setXYZ(Zt, Lt.x, Lt.y, Lt.z),
                            mt.setXYZ(Yt, Nt.x, Nt.y, Nt.z)
                        }
                    else
                        for (let Qt = 0, qt = lt.count; Qt < qt; Qt += 3)
                            ft.fromBufferAttribute(lt, Qt + 0),
                            xt.fromBufferAttribute(lt, Qt + 1),
                            Ct.fromBufferAttribute(lt, Qt + 2),
                            jt.subVectors(Ct, xt),
                            Wt.subVectors(ft, xt),
                            jt.cross(Wt),
                            mt.setXYZ(Qt + 0, jt.x, jt.y, jt.z),
                            mt.setXYZ(Qt + 1, jt.x, jt.y, jt.z),
                            mt.setXYZ(Qt + 2, jt.x, jt.y, jt.z);
                    this.normalizeNormals(),
                    mt.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const tt = this.attributes.normal;
                for (let lt = 0, mt = tt.count; lt < mt; lt++)
                    fs.fromBufferAttribute(tt, lt),
                    fs.normalize(),
                    tt.setXYZ(lt, fs.x, fs.y, fs.z)
            }
            toNonIndexed() {
                function tt(Mt, Lt) {
                    const Nt = Mt.array
                      , jt = Mt.itemSize
                      , Wt = Mt.normalized
                      , Qt = new Nt.constructor(Lt.length * jt);
                    let qt = 0
                      , Xt = 0;
                    for (let Zt = 0, Yt = Lt.length; Zt < Yt; Zt++) {
                        qt = Mt.isInterleavedBufferAttribute ? Lt[Zt] * Mt.data.stride + Mt.offset : Lt[Zt] * jt;
                        for (let sr = 0; sr < jt; sr++)
                            Qt[Xt++] = Nt[qt++]
                    }
                    return new mr(Qt,jt,Wt)
                }
                if (this.index === null)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const lt = new bo
                  , mt = this.index.array
                  , ft = this.attributes;
                for (const Mt in ft) {
                    const Lt = tt(ft[Mt], mt);
                    lt.setAttribute(Mt, Lt)
                }
                const xt = this.morphAttributes;
                for (const Mt in xt) {
                    const Lt = []
                      , Nt = xt[Mt];
                    for (let jt = 0, Wt = Nt.length; jt < Wt; jt++) {
                        const Qt = tt(Nt[jt], mt);
                        Lt.push(Qt)
                    }
                    lt.morphAttributes[Mt] = Lt
                }
                lt.morphTargetsRelative = this.morphTargetsRelative;
                const Ct = this.groups;
                for (let Mt = 0, Lt = Ct.length; Mt < Lt; Mt++) {
                    const Nt = Ct[Mt];
                    lt.addGroup(Nt.start, Nt.count, Nt.materialIndex)
                }
                return lt
            }
            toJSON() {
                const tt = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (tt.uuid = this.uuid,
                tt.type = this.type,
                this.name !== "" && (tt.name = this.name),
                Object.keys(this.userData).length > 0 && (tt.userData = this.userData),
                this.parameters !== void 0) {
                    const Lt = this.parameters;
                    for (const Nt in Lt)
                        Lt[Nt] !== void 0 && (tt[Nt] = Lt[Nt]);
                    return tt
                }
                tt.data = {
                    attributes: {}
                };
                const lt = this.index;
                lt !== null && (tt.data.index = {
                    type: lt.array.constructor.name,
                    array: Array.prototype.slice.call(lt.array)
                });
                const mt = this.attributes;
                for (const Lt in mt) {
                    const Nt = mt[Lt];
                    tt.data.attributes[Lt] = Nt.toJSON(tt.data)
                }
                const ft = {};
                let xt = !1;
                for (const Lt in this.morphAttributes) {
                    const Nt = this.morphAttributes[Lt]
                      , jt = [];
                    for (let Wt = 0, Qt = Nt.length; Wt < Qt; Wt++) {
                        const qt = Nt[Wt];
                        jt.push(qt.toJSON(tt.data))
                    }
                    jt.length > 0 && (ft[Lt] = jt,
                    xt = !0)
                }
                xt && (tt.data.morphAttributes = ft,
                tt.data.morphTargetsRelative = this.morphTargetsRelative);
                const Ct = this.groups;
                Ct.length > 0 && (tt.data.groups = JSON.parse(JSON.stringify(Ct)));
                const Mt = this.boundingSphere;
                return Mt !== null && (tt.data.boundingSphere = {
                    center: Mt.center.toArray(),
                    radius: Mt.radius
                }),
                tt
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const lt = {};
                this.name = tt.name;
                const mt = tt.index;
                mt !== null && this.setIndex(mt.clone(lt));
                const ft = tt.attributes;
                for (const Nt in ft) {
                    const jt = ft[Nt];
                    this.setAttribute(Nt, jt.clone(lt))
                }
                const xt = tt.morphAttributes;
                for (const Nt in xt) {
                    const jt = []
                      , Wt = xt[Nt];
                    for (let Qt = 0, qt = Wt.length; Qt < qt; Qt++)
                        jt.push(Wt[Qt].clone(lt));
                    this.morphAttributes[Nt] = jt
                }
                this.morphTargetsRelative = tt.morphTargetsRelative;
                const Ct = tt.groups;
                for (let Nt = 0, jt = Ct.length; Nt < jt; Nt++) {
                    const Wt = Ct[Nt];
                    this.addGroup(Wt.start, Wt.count, Wt.materialIndex)
                }
                const Mt = tt.boundingBox;
                Mt !== null && (this.boundingBox = Mt.clone());
                const Lt = tt.boundingSphere;
                return Lt !== null && (this.boundingSphere = Lt.clone()),
                this.drawRange.start = tt.drawRange.start,
                this.drawRange.count = tt.drawRange.count,
                this.userData = tt.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Ly = new no
          , wp = new Qu
          , pv = new Ws
          , Oy = new Er
          , gm = new Er
          , _m = new Er
          , vm = new Er
          , N0 = new Er
          , hv = new Er
          , mv = new mn
          , fv = new mn
          , gv = new mn
          , Ny = new Er
          , Fy = new Er
          , Uy = new Er
          , _v = new Er
          , vv = new Er;
        class gs extends Mo {
            constructor(tt=new bo, lt=new nu) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = tt,
                this.material = lt,
                this.updateMorphTargets()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.isMesh ? (tt.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = tt.morphTargetInfluences.slice()),
                tt.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, tt.morphTargetDictionary)),
                this.material = Array.isArray(tt.material) ? tt.material.slice() : tt.material,
                this.geometry = tt.geometry,
                this) : this
            }
            updateMorphTargets() {
                const tt = this.geometry.morphAttributes
                  , lt = Object.keys(tt);
                if (lt.length > 0) {
                    const mt = tt[lt[0]];
                    if (mt !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                            const Ct = mt[ft].name || String(ft);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[Ct] = ft
                        }
                    }
                }
            }
            getVertexPosition(tt, lt) {
                const mt = this.geometry
                  , ft = mt.attributes.position
                  , xt = mt.morphAttributes.position
                  , Ct = mt.morphTargetsRelative;
                lt.fromBufferAttribute(ft, tt);
                const Mt = this.morphTargetInfluences;
                if (xt && Mt) {
                    hv.set(0, 0, 0);
                    for (let Lt = 0, Nt = xt.length; Lt < Nt; Lt++) {
                        const jt = Mt[Lt]
                          , Wt = xt[Lt];
                        jt !== 0 && (N0.fromBufferAttribute(Wt, tt),
                        Ct ? hv.addScaledVector(N0, jt) : hv.addScaledVector(N0.sub(lt), jt))
                    }
                    lt.add(hv)
                }
                return lt
            }
            raycast(tt, lt) {
                const mt = this.geometry
                  , ft = this.material
                  , xt = this.matrixWorld;
                if (ft !== void 0) {
                    if (mt.boundingSphere === null && mt.computeBoundingSphere(),
                    pv.copy(mt.boundingSphere),
                    pv.applyMatrix4(xt),
                    wp.copy(tt.ray).recast(tt.near),
                    pv.containsPoint(wp.origin) === !1 && (wp.intersectSphere(pv, Oy) === null || wp.origin.distanceToSquared(Oy) > (tt.far - tt.near) ** 2))
                        return;
                    Ly.copy(xt).invert(),
                    wp.copy(tt.ray).applyMatrix4(Ly),
                    mt.boundingBox !== null && wp.intersectsBox(mt.boundingBox) === !1 || this._computeIntersections(tt, lt, wp)
                }
            }
            _computeIntersections(tt, lt, mt) {
                let ft;
                const xt = this.geometry
                  , Ct = this.material
                  , Mt = xt.index
                  , Lt = xt.attributes.position
                  , Nt = xt.attributes.uv
                  , jt = xt.attributes.uv1
                  , Wt = xt.attributes.normal
                  , Qt = xt.groups
                  , qt = xt.drawRange;
                if (Mt !== null)
                    if (Array.isArray(Ct))
                        for (let Xt = 0, Zt = Qt.length; Xt < Zt; Xt++) {
                            const Yt = Qt[Xt]
                              , sr = Ct[Yt.materialIndex];
                            for (let er = Math.max(Yt.start, qt.start), rr = Math.min(Mt.count, Math.min(Yt.start + Yt.count, qt.start + qt.count)); er < rr; er += 3)
                                ft = yv(this, sr, tt, mt, Nt, jt, Wt, Mt.getX(er), Mt.getX(er + 1), Mt.getX(er + 2)),
                                ft && (ft.faceIndex = Math.floor(er / 3),
                                ft.face.materialIndex = Yt.materialIndex,
                                lt.push(ft))
                        }
                    else
                        for (let Xt = Math.max(0, qt.start), Zt = Math.min(Mt.count, qt.start + qt.count); Xt < Zt; Xt += 3)
                            ft = yv(this, Ct, tt, mt, Nt, jt, Wt, Mt.getX(Xt), Mt.getX(Xt + 1), Mt.getX(Xt + 2)),
                            ft && (ft.faceIndex = Math.floor(Xt / 3),
                            lt.push(ft));
                else if (Lt !== void 0)
                    if (Array.isArray(Ct))
                        for (let Xt = 0, Zt = Qt.length; Xt < Zt; Xt++) {
                            const Yt = Qt[Xt]
                              , sr = Ct[Yt.materialIndex];
                            for (let er = Math.max(Yt.start, qt.start), rr = Math.min(Lt.count, Math.min(Yt.start + Yt.count, qt.start + qt.count)); er < rr; er += 3)
                                ft = yv(this, sr, tt, mt, Nt, jt, Wt, er, er + 1, er + 2),
                                ft && (ft.faceIndex = Math.floor(er / 3),
                                ft.face.materialIndex = Yt.materialIndex,
                                lt.push(ft))
                        }
                    else
                        for (let Xt = Math.max(0, qt.start), Zt = Math.min(Lt.count, qt.start + qt.count); Xt < Zt; Xt += 3)
                            ft = yv(this, Ct, tt, mt, Nt, jt, Wt, Xt, Xt + 1, Xt + 2),
                            ft && (ft.faceIndex = Math.floor(Xt / 3),
                            lt.push(ft))
            }
        }
        function yv(Tt, tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
            Tt.getVertexPosition(Mt, gm),
            Tt.getVertexPosition(Lt, _m),
            Tt.getVertexPosition(Nt, vm);
            const jt = function(Wt, Qt, qt, Xt, Zt, Yt, sr, er) {
                let rr;
                if (rr = Qt.side === bt ? Xt.intersectTriangle(sr, Yt, Zt, !0, er) : Xt.intersectTriangle(Zt, Yt, sr, Qt.side === vt, er),
                rr === null)
                    return null;
                vv.copy(er),
                vv.applyMatrix4(Wt.matrixWorld);
                const xr = qt.ray.origin.distanceTo(vv);
                return xr < qt.near || xr > qt.far ? null : {
                    distance: xr,
                    point: vv.clone(),
                    object: Wt
                }
            }(Tt, tt, lt, mt, gm, _m, vm, _v);
            if (jt) {
                ft && (mv.fromBufferAttribute(ft, Mt),
                fv.fromBufferAttribute(ft, Lt),
                gv.fromBufferAttribute(ft, Nt),
                jt.uv = Es.getInterpolation(_v, gm, _m, vm, mv, fv, gv, new mn)),
                xt && (mv.fromBufferAttribute(xt, Mt),
                fv.fromBufferAttribute(xt, Lt),
                gv.fromBufferAttribute(xt, Nt),
                jt.uv1 = Es.getInterpolation(_v, gm, _m, vm, mv, fv, gv, new mn),
                jt.uv2 = jt.uv1),
                Ct && (Ny.fromBufferAttribute(Ct, Mt),
                Fy.fromBufferAttribute(Ct, Lt),
                Uy.fromBufferAttribute(Ct, Nt),
                jt.normal = Es.getInterpolation(_v, gm, _m, vm, Ny, Fy, Uy, new Er),
                jt.normal.dot(mt.direction) > 0 && jt.normal.multiplyScalar(-1));
                const Wt = {
                    a: Mt,
                    b: Lt,
                    c: Nt,
                    normal: new Er,
                    materialIndex: 0
                };
                Es.getNormal(gm, _m, vm, Wt.normal),
                jt.face = Wt
            }
            return jt
        }
        class Zu extends bo {
            constructor(tt=1, lt=1, mt=1, ft=1, xt=1, Ct=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: tt,
                    height: lt,
                    depth: mt,
                    widthSegments: ft,
                    heightSegments: xt,
                    depthSegments: Ct
                };
                const Mt = this;
                ft = Math.floor(ft),
                xt = Math.floor(xt),
                Ct = Math.floor(Ct);
                const Lt = []
                  , Nt = []
                  , jt = []
                  , Wt = [];
                let Qt = 0
                  , qt = 0;
                function Xt(Zt, Yt, sr, er, rr, xr, br, yr, Pr, zr, Nr) {
                    const Vr = xr / Pr
                      , Gr = br / zr
                      , Hr = xr / 2
                      , _n = br / 2
                      , dn = yr / 2
                      , kn = Pr + 1
                      , Bn = zr + 1;
                    let cn = 0
                      , Yr = 0;
                    const Jr = new Er;
                    for (let sn = 0; sn < Bn; sn++) {
                        const on = sn * Gr - _n;
                        for (let Un = 0; Un < kn; Un++) {
                            const ro = Un * Vr - Hr;
                            Jr[Zt] = ro * er,
                            Jr[Yt] = on * rr,
                            Jr[sr] = dn,
                            Nt.push(Jr.x, Jr.y, Jr.z),
                            Jr[Zt] = 0,
                            Jr[Yt] = 0,
                            Jr[sr] = yr > 0 ? 1 : -1,
                            jt.push(Jr.x, Jr.y, Jr.z),
                            Wt.push(Un / Pr),
                            Wt.push(1 - sn / zr),
                            cn += 1
                        }
                    }
                    for (let sn = 0; sn < zr; sn++)
                        for (let on = 0; on < Pr; on++) {
                            const Un = Qt + on + kn * sn
                              , ro = Qt + on + kn * (sn + 1)
                              , Zn = Qt + (on + 1) + kn * (sn + 1)
                              , jn = Qt + (on + 1) + kn * sn;
                            Lt.push(Un, ro, jn),
                            Lt.push(ro, Zn, jn),
                            Yr += 6
                        }
                    Mt.addGroup(qt, Yr, Nr),
                    qt += Yr,
                    Qt += cn
                }
                Xt("z", "y", "x", -1, -1, mt, lt, tt, Ct, xt, 0),
                Xt("z", "y", "x", 1, -1, mt, lt, -tt, Ct, xt, 1),
                Xt("x", "z", "y", 1, 1, tt, mt, lt, ft, Ct, 2),
                Xt("x", "z", "y", 1, -1, tt, mt, -lt, ft, Ct, 3),
                Xt("x", "y", "z", 1, -1, tt, lt, mt, ft, xt, 4),
                Xt("x", "y", "z", -1, -1, tt, lt, -mt, ft, xt, 5),
                this.setIndex(Lt),
                this.setAttribute("position", new Fn(Nt,3)),
                this.setAttribute("normal", new Fn(jt,3)),
                this.setAttribute("uv", new Fn(Wt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new Zu(tt.width,tt.height,tt.depth,tt.widthSegments,tt.heightSegments,tt.depthSegments)
            }
        }
        function Sp(Tt) {
            const tt = {};
            for (const lt in Tt) {
                tt[lt] = {};
                for (const mt in Tt[lt]) {
                    const ft = Tt[lt][mt];
                    ft && (ft.isColor || ft.isMatrix3 || ft.isMatrix4 || ft.isVector2 || ft.isVector3 || ft.isVector4 || ft.isTexture || ft.isQuaternion) ? ft.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    tt[lt][mt] = null) : tt[lt][mt] = ft.clone() : Array.isArray(ft) ? tt[lt][mt] = ft.slice() : tt[lt][mt] = ft
                }
            }
            return tt
        }
        function js(Tt) {
            const tt = {};
            for (let lt = 0; lt < Tt.length; lt++) {
                const mt = Sp(Tt[lt]);
                for (const ft in mt)
                    tt[ft] = mt[ft]
            }
            return tt
        }
        function jy(Tt) {
            return Tt.getRenderTarget() === null ? Tt.outputColorSpace : Do.workingColorSpace
        }
        const Vy = {
            clone: Sp,
            merge: js
        };
        class zl extends hs {
            constructor(tt) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
                this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                tt !== void 0 && this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.fragmentShader = tt.fragmentShader,
                this.vertexShader = tt.vertexShader,
                this.uniforms = Sp(tt.uniforms),
                this.uniformsGroups = function(lt) {
                    const mt = [];
                    for (let ft = 0; ft < lt.length; ft++)
                        mt.push(lt[ft].clone());
                    return mt
                }(tt.uniformsGroups),
                this.defines = Object.assign({}, tt.defines),
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.fog = tt.fog,
                this.lights = tt.lights,
                this.clipping = tt.clipping,
                this.extensions = Object.assign({}, tt.extensions),
                this.glslVersion = tt.glslVersion,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                lt.glslVersion = this.glslVersion,
                lt.uniforms = {};
                for (const ft in this.uniforms) {
                    const xt = this.uniforms[ft].value;
                    xt && xt.isTexture ? lt.uniforms[ft] = {
                        type: "t",
                        value: xt.toJSON(tt).uuid
                    } : xt && xt.isColor ? lt.uniforms[ft] = {
                        type: "c",
                        value: xt.getHex()
                    } : xt && xt.isVector2 ? lt.uniforms[ft] = {
                        type: "v2",
                        value: xt.toArray()
                    } : xt && xt.isVector3 ? lt.uniforms[ft] = {
                        type: "v3",
                        value: xt.toArray()
                    } : xt && xt.isVector4 ? lt.uniforms[ft] = {
                        type: "v4",
                        value: xt.toArray()
                    } : xt && xt.isMatrix3 ? lt.uniforms[ft] = {
                        type: "m3",
                        value: xt.toArray()
                    } : xt && xt.isMatrix4 ? lt.uniforms[ft] = {
                        type: "m4",
                        value: xt.toArray()
                    } : lt.uniforms[ft] = {
                        value: xt
                    }
                }
                Object.keys(this.defines).length > 0 && (lt.defines = this.defines),
                lt.vertexShader = this.vertexShader,
                lt.fragmentShader = this.fragmentShader,
                lt.lights = this.lights,
                lt.clipping = this.clipping;
                const mt = {};
                for (const ft in this.extensions)
                    this.extensions[ft] === !0 && (mt[ft] = !0);
                return Object.keys(mt).length > 0 && (lt.extensions = mt),
                lt
            }
        }
        class xv extends Mo {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new no,
                this.projectionMatrix = new no,
                this.projectionMatrixInverse = new no,
                this.coordinateSystem = Qs
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.matrixWorldInverse.copy(tt.matrixWorldInverse),
                this.projectionMatrix.copy(tt.projectionMatrix),
                this.projectionMatrixInverse.copy(tt.projectionMatrixInverse),
                this.coordinateSystem = tt.coordinateSystem,
                this
            }
            getWorldDirection(tt) {
                return super.getWorldDirection(tt).negate()
            }
            updateMatrixWorld(tt) {
                super.updateMatrixWorld(tt),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(tt, lt) {
                super.updateWorldMatrix(tt, lt),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class Cs extends xv {
            constructor(tt=50, lt=1, mt=.1, ft=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = tt,
                this.zoom = 1,
                this.near = mt,
                this.far = ft,
                this.focus = 10,
                this.aspect = lt,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.fov = tt.fov,
                this.zoom = tt.zoom,
                this.near = tt.near,
                this.far = tt.far,
                this.focus = tt.focus,
                this.aspect = tt.aspect,
                this.view = tt.view === null ? null : Object.assign({}, tt.view),
                this.filmGauge = tt.filmGauge,
                this.filmOffset = tt.filmOffset,
                this
            }
            setFocalLength(tt) {
                const lt = .5 * this.getFilmHeight() / tt;
                this.fov = 2 * _u * Math.atan(lt),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const tt = Math.tan(.5 * Zl * this.fov);
                return .5 * this.getFilmHeight() / tt
            }
            getEffectiveFOV() {
                return 2 * _u * Math.atan(Math.tan(.5 * Zl * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(tt, lt, mt, ft, xt, Ct) {
                this.aspect = tt / lt,
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = tt,
                this.view.fullHeight = lt,
                this.view.offsetX = mt,
                this.view.offsetY = ft,
                this.view.width = xt,
                this.view.height = Ct,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const tt = this.near;
                let lt = tt * Math.tan(.5 * Zl * this.fov) / this.zoom
                  , mt = 2 * lt
                  , ft = this.aspect * mt
                  , xt = -.5 * ft;
                const Ct = this.view;
                if (this.view !== null && this.view.enabled) {
                    const Lt = Ct.fullWidth
                      , Nt = Ct.fullHeight;
                    xt += Ct.offsetX * ft / Lt,
                    lt -= Ct.offsetY * mt / Nt,
                    ft *= Ct.width / Lt,
                    mt *= Ct.height / Nt
                }
                const Mt = this.filmOffset;
                Mt !== 0 && (xt += tt * Mt / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(xt, xt + ft, lt, lt - mt, tt, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.fov = this.fov,
                lt.object.zoom = this.zoom,
                lt.object.near = this.near,
                lt.object.far = this.far,
                lt.object.focus = this.focus,
                lt.object.aspect = this.aspect,
                this.view !== null && (lt.object.view = Object.assign({}, this.view)),
                lt.object.filmGauge = this.filmGauge,
                lt.object.filmOffset = this.filmOffset,
                lt
            }
        }
        const ym = -90;
        class Gy extends Mo {
            constructor(tt, lt, mt) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = mt,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const ft = new Cs(ym,1,tt,lt);
                ft.layers = this.layers,
                this.add(ft);
                const xt = new Cs(ym,1,tt,lt);
                xt.layers = this.layers,
                this.add(xt);
                const Ct = new Cs(ym,1,tt,lt);
                Ct.layers = this.layers,
                this.add(Ct);
                const Mt = new Cs(ym,1,tt,lt);
                Mt.layers = this.layers,
                this.add(Mt);
                const Lt = new Cs(ym,1,tt,lt);
                Lt.layers = this.layers,
                this.add(Lt);
                const Nt = new Cs(ym,1,tt,lt);
                Nt.layers = this.layers,
                this.add(Nt)
            }
            updateCoordinateSystem() {
                const tt = this.coordinateSystem
                  , lt = this.children.concat()
                  , [mt,ft,xt,Ct,Mt,Lt] = lt;
                for (const Nt of lt)
                    this.remove(Nt);
                if (tt === Qs)
                    mt.up.set(0, 1, 0),
                    mt.lookAt(1, 0, 0),
                    ft.up.set(0, 1, 0),
                    ft.lookAt(-1, 0, 0),
                    xt.up.set(0, 0, -1),
                    xt.lookAt(0, 1, 0),
                    Ct.up.set(0, 0, 1),
                    Ct.lookAt(0, -1, 0),
                    Mt.up.set(0, 1, 0),
                    Mt.lookAt(0, 0, 1),
                    Lt.up.set(0, 1, 0),
                    Lt.lookAt(0, 0, -1);
                else {
                    if (tt !== na)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + tt);
                    mt.up.set(0, -1, 0),
                    mt.lookAt(-1, 0, 0),
                    ft.up.set(0, -1, 0),
                    ft.lookAt(1, 0, 0),
                    xt.up.set(0, 0, 1),
                    xt.lookAt(0, 1, 0),
                    Ct.up.set(0, 0, -1),
                    Ct.lookAt(0, -1, 0),
                    Mt.up.set(0, -1, 0),
                    Mt.lookAt(0, 0, 1),
                    Lt.up.set(0, -1, 0),
                    Lt.lookAt(0, 0, -1)
                }
                for (const Nt of lt)
                    this.add(Nt),
                    Nt.updateMatrixWorld()
            }
            update(tt, lt) {
                this.parent === null && this.updateMatrixWorld();
                const {
renderTarget: mt, activeMipmapLevel: ft} = this;
                this.coordinateSystem !== tt.coordinateSystem && (this.coordinateSystem = tt.coordinateSystem,
                this.updateCoordinateSystem());
                const [xt,Ct,Mt,Lt,Nt,jt] = this.children
                  , Wt = tt.getRenderTarget()
                  , Qt = tt.getActiveCubeFace()
                  , qt = tt.getActiveMipmapLevel()
                  , Xt = tt.xr.enabled;
                tt.xr.enabled = !1;
                const Zt = mt.texture.generateMipmaps;
                mt.texture.generateMipmaps = !1,
                tt.setRenderTarget(mt, 0, ft),
                tt.render(lt, xt),
                tt.setRenderTarget(mt, 1, ft),
                tt.render(lt, Ct),
                tt.setRenderTarget(mt, 2, ft),
                tt.render(lt, Mt),
                tt.setRenderTarget(mt, 3, ft),
                tt.render(lt, Lt),
                tt.setRenderTarget(mt, 4, ft),
                tt.render(lt, Nt),
                mt.texture.generateMipmaps = Zt,
                tt.setRenderTarget(mt, 5, ft),
                tt.render(lt, jt),
                tt.setRenderTarget(Wt, Qt, qt),
                tt.xr.enabled = Xt,
                mt.texture.needsPMREMUpdate = !0
            }
        }
        class f_ extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt) {
                super(tt = tt !== void 0 ? tt : [], lt = lt !== void 0 ? lt : Qr, mt, ft, xt, Ct, Mt, Lt, Nt, jt),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(tt) {
                this.image = tt
            }
        }
        class zy extends Rs {
            constructor(tt=1, lt={}) {
                super(tt, tt, lt),
                this.isWebGLCubeRenderTarget = !0;
                const mt = {
                    width: tt,
                    height: tt,
                    depth: 1
                }
                  , ft = [mt, mt, mt, mt, mt, mt];
                lt.encoding !== void 0 && (xu("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
                lt.colorSpace = lt.encoding === Ol ? jo : Oo),
                this.texture = new f_(ft,lt.mapping,lt.wrapS,lt.wrapT,lt.magFilter,lt.minFilter,lt.format,lt.type,lt.anisotropy,lt.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = lt.generateMipmaps !== void 0 && lt.generateMipmaps,
                this.texture.minFilter = lt.minFilter !== void 0 ? lt.minFilter : Rn
            }
            fromEquirectangularTexture(tt, lt) {
                this.texture.type = lt.type,
                this.texture.colorSpace = lt.colorSpace,
                this.texture.generateMipmaps = lt.generateMipmaps,
                this.texture.minFilter = lt.minFilter,
                this.texture.magFilter = lt.magFilter;
                const mt = {
                    tEquirect: {
                        value: null
                    }
                }
                  , ft = `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
                  , xt = `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                  , Ct = new Zu(5,5,5)
                  , Mt = new zl({
                    name: "CubemapFromEquirect",
                    uniforms: Sp(mt),
                    vertexShader: ft,
                    fragmentShader: xt,
                    side: bt,
                    blending: Et
                });
                Mt.uniforms.tEquirect.value = lt;
                const Lt = new gs(Ct,Mt)
                  , Nt = lt.minFilter;
                return lt.minFilter === vo && (lt.minFilter = Rn),
                new Gy(1,10,this).update(tt, Lt),
                lt.minFilter = Nt,
                Lt.geometry.dispose(),
                Lt.material.dispose(),
                this
            }
            clear(tt, lt, mt, ft) {
                const xt = tt.getRenderTarget();
                for (let Ct = 0; Ct < 6; Ct++)
                    tt.setRenderTarget(this, Ct),
                    tt.clear(lt, mt, ft);
                tt.setRenderTarget(xt)
            }
        }
        const F0 = new Er
          , Aw = new Er
          , ww = new lo;
        class _d {
            constructor(tt=new Er(1,0,0), lt=0) {
                this.isPlane = !0,
                this.normal = tt,
                this.constant = lt
            }
            set(tt, lt) {
                return this.normal.copy(tt),
                this.constant = lt,
                this
            }
            setComponents(tt, lt, mt, ft) {
                return this.normal.set(tt, lt, mt),
                this.constant = ft,
                this
            }
            setFromNormalAndCoplanarPoint(tt, lt) {
                return this.normal.copy(tt),
                this.constant = -lt.dot(this.normal),
                this
            }
            setFromCoplanarPoints(tt, lt, mt) {
                const ft = F0.subVectors(mt, lt).cross(Aw.subVectors(tt, lt)).normalize();
                return this.setFromNormalAndCoplanarPoint(ft, tt),
                this
            }
            copy(tt) {
                return this.normal.copy(tt.normal),
                this.constant = tt.constant,
                this
            }
            normalize() {
                const tt = 1 / this.normal.length();
                return this.normal.multiplyScalar(tt),
                this.constant *= tt,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(tt) {
                return this.normal.dot(tt) + this.constant
            }
            distanceToSphere(tt) {
                return this.distanceToPoint(tt.center) - tt.radius
            }
            projectPoint(tt, lt) {
                return lt.copy(tt).addScaledVector(this.normal, -this.distanceToPoint(tt))
            }
            intersectLine(tt, lt) {
                const mt = tt.delta(F0)
                  , ft = this.normal.dot(mt);
                if (ft === 0)
                    return this.distanceToPoint(tt.start) === 0 ? lt.copy(tt.start) : null;
                const xt = -(tt.start.dot(this.normal) + this.constant) / ft;
                return xt < 0 || xt > 1 ? null : lt.copy(tt.start).addScaledVector(mt, xt)
            }
            intersectsLine(tt) {
                const lt = this.distanceToPoint(tt.start)
                  , mt = this.distanceToPoint(tt.end);
                return lt < 0 && mt > 0 || mt < 0 && lt > 0
            }
            intersectsBox(tt) {
                return tt.intersectsPlane(this)
            }
            intersectsSphere(tt) {
                return tt.intersectsPlane(this)
            }
            coplanarPoint(tt) {
                return tt.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(tt, lt) {
                const mt = lt || ww.getNormalMatrix(tt)
                  , ft = this.coplanarPoint(F0).applyMatrix4(tt)
                  , xt = this.normal.applyMatrix3(mt).normalize();
                return this.constant = -ft.dot(xt),
                this
            }
            translate(tt) {
                return this.constant -= tt.dot(this.normal),
                this
            }
            equals(tt) {
                return tt.normal.equals(this.normal) && tt.constant === this.constant
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const Ep = new Ws
          , bv = new Er;
        class Av {
            constructor(tt=new _d, lt=new _d, mt=new _d, ft=new _d, xt=new _d, Ct=new _d) {
                this.planes = [tt, lt, mt, ft, xt, Ct]
            }
            set(tt, lt, mt, ft, xt, Ct) {
                const Mt = this.planes;
                return Mt[0].copy(tt),
                Mt[1].copy(lt),
                Mt[2].copy(mt),
                Mt[3].copy(ft),
                Mt[4].copy(xt),
                Mt[5].copy(Ct),
                this
            }
            copy(tt) {
                const lt = this.planes;
                for (let mt = 0; mt < 6; mt++)
                    lt[mt].copy(tt.planes[mt]);
                return this
            }
            setFromProjectionMatrix(tt, lt=Qs) {
                const mt = this.planes
                  , ft = tt.elements
                  , xt = ft[0]
                  , Ct = ft[1]
                  , Mt = ft[2]
                  , Lt = ft[3]
                  , Nt = ft[4]
                  , jt = ft[5]
                  , Wt = ft[6]
                  , Qt = ft[7]
                  , qt = ft[8]
                  , Xt = ft[9]
                  , Zt = ft[10]
                  , Yt = ft[11]
                  , sr = ft[12]
                  , er = ft[13]
                  , rr = ft[14]
                  , xr = ft[15];
                if (mt[0].setComponents(Lt - xt, Qt - Nt, Yt - qt, xr - sr).normalize(),
                mt[1].setComponents(Lt + xt, Qt + Nt, Yt + qt, xr + sr).normalize(),
                mt[2].setComponents(Lt + Ct, Qt + jt, Yt + Xt, xr + er).normalize(),
                mt[3].setComponents(Lt - Ct, Qt - jt, Yt - Xt, xr - er).normalize(),
                mt[4].setComponents(Lt - Mt, Qt - Wt, Yt - Zt, xr - rr).normalize(),
                lt === Qs)
                    mt[5].setComponents(Lt + Mt, Qt + Wt, Yt + Zt, xr + rr).normalize();
                else {
                    if (lt !== na)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + lt);
                    mt[5].setComponents(Mt, Wt, Zt, rr).normalize()
                }
                return this
            }
            intersectsObject(tt) {
                if (tt.boundingSphere !== void 0)
                    tt.boundingSphere === null && tt.computeBoundingSphere(),
                    Ep.copy(tt.boundingSphere).applyMatrix4(tt.matrixWorld);
                else {
                    const lt = tt.geometry;
                    lt.boundingSphere === null && lt.computeBoundingSphere(),
                    Ep.copy(lt.boundingSphere).applyMatrix4(tt.matrixWorld)
                }
                return this.intersectsSphere(Ep)
            }
            intersectsSprite(tt) {
                return Ep.center.set(0, 0, 0),
                Ep.radius = .7071067811865476,
                Ep.applyMatrix4(tt.matrixWorld),
                this.intersectsSphere(Ep)
            }
            intersectsSphere(tt) {
                const lt = this.planes
                  , mt = tt.center
                  , ft = -tt.radius;
                for (let xt = 0; xt < 6; xt++)
                    if (lt[xt].distanceToPoint(mt) < ft)
                        return !1;
                return !0
            }
            intersectsBox(tt) {
                const lt = this.planes;
                for (let mt = 0; mt < 6; mt++) {
                    const ft = lt[mt];
                    if (bv.x = ft.normal.x > 0 ? tt.max.x : tt.min.x,
                    bv.y = ft.normal.y > 0 ? tt.max.y : tt.min.y,
                    bv.z = ft.normal.z > 0 ? tt.max.z : tt.min.z,
                    ft.distanceToPoint(bv) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(tt) {
                const lt = this.planes;
                for (let mt = 0; mt < 6; mt++)
                    if (lt[mt].distanceToPoint(tt) < 0)
                        return !1;
                return !0
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        function Hy() {
            let Tt = null
              , tt = !1
              , lt = null
              , mt = null;
            function ft(xt, Ct) {
                lt(xt, Ct),
                mt = Tt.requestAnimationFrame(ft)
            }
            return {
                start: function() {
                    tt !== !0 && lt !== null && (mt = Tt.requestAnimationFrame(ft),
                    tt = !0)
                },
                stop: function() {
                    Tt.cancelAnimationFrame(mt),
                    tt = !1
                },
                setAnimationLoop: function(xt) {
                    lt = xt
                },
                setContext: function(xt) {
                    Tt = xt
                }
            }
        }
        function Sw(Tt, tt) {
            const lt = tt.isWebGL2
              , mt = new WeakMap;
            return {
                get: function(ft) {
                    return ft.isInterleavedBufferAttribute && (ft = ft.data),
                    mt.get(ft)
                },
                remove: function(ft) {
                    ft.isInterleavedBufferAttribute && (ft = ft.data);
                    const xt = mt.get(ft);
                    xt && (Tt.deleteBuffer(xt.buffer),
                    mt.delete(ft))
                },
                update: function(ft, xt) {
                    if (ft.isGLBufferAttribute) {
                        const Mt = mt.get(ft);
                        return void ((!Mt || Mt.version < ft.version) && mt.set(ft, {
                            buffer: ft.buffer,
                            type: ft.type,
                            bytesPerElement: ft.elementSize,
                            version: ft.version
                        }))
                    }
                    ft.isInterleavedBufferAttribute && (ft = ft.data);
                    const Ct = mt.get(ft);
                    Ct === void 0 ? mt.set(ft, function(Mt, Lt) {
                        const Nt = Mt.array
                          , jt = Mt.usage
                          , Wt = Tt.createBuffer();
                        let Qt;
                        if (Tt.bindBuffer(Lt, Wt),
                        Tt.bufferData(Lt, Nt, jt),
                        Mt.onUploadCallback(),
                        Nt instanceof Float32Array)
                            Qt = Tt.FLOAT;
                        else if (Nt instanceof Uint16Array)
                            if (Mt.isFloat16BufferAttribute) {
                                if (!lt)
                                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                Qt = Tt.HALF_FLOAT
                            } else
                                Qt = Tt.UNSIGNED_SHORT;
                        else if (Nt instanceof Int16Array)
                            Qt = Tt.SHORT;
                        else if (Nt instanceof Uint32Array)
                            Qt = Tt.UNSIGNED_INT;
                        else if (Nt instanceof Int32Array)
                            Qt = Tt.INT;
                        else if (Nt instanceof Int8Array)
                            Qt = Tt.BYTE;
                        else if (Nt instanceof Uint8Array)
                            Qt = Tt.UNSIGNED_BYTE;
                        else {
                            if (!(Nt instanceof Uint8ClampedArray))
                                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + Nt);
                            Qt = Tt.UNSIGNED_BYTE
                        }
                        return {
                            buffer: Wt,
                            type: Qt,
                            bytesPerElement: Nt.BYTES_PER_ELEMENT,
                            version: Mt.version
                        }
                    }(ft, xt)) : Ct.version < ft.version && (function(Mt, Lt, Nt) {
                        const jt = Lt.array
                          , Wt = Lt.updateRange;
                        Tt.bindBuffer(Nt, Mt),
                        Wt.count === -1 ? Tt.bufferSubData(Nt, 0, jt) : (lt ? Tt.bufferSubData(Nt, Wt.offset * jt.BYTES_PER_ELEMENT, jt, Wt.offset, Wt.count) : Tt.bufferSubData(Nt, Wt.offset * jt.BYTES_PER_ELEMENT, jt.subarray(Wt.offset, Wt.offset + Wt.count)),
                        Wt.count = -1),
                        Lt.onUploadCallback()
                    }(Ct.buffer, ft, xt),
                    Ct.version = ft.version)
                }
            }
        }
        class g_ extends bo {
            constructor(tt=1, lt=1, mt=1, ft=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: tt,
                    height: lt,
                    widthSegments: mt,
                    heightSegments: ft
                };
                const xt = tt / 2
                  , Ct = lt / 2
                  , Mt = Math.floor(mt)
                  , Lt = Math.floor(ft)
                  , Nt = Mt + 1
                  , jt = Lt + 1
                  , Wt = tt / Mt
                  , Qt = lt / Lt
                  , qt = []
                  , Xt = []
                  , Zt = []
                  , Yt = [];
                for (let sr = 0; sr < jt; sr++) {
                    const er = sr * Qt - Ct;
                    for (let rr = 0; rr < Nt; rr++) {
                        const xr = rr * Wt - xt;
                        Xt.push(xr, -er, 0),
                        Zt.push(0, 0, 1),
                        Yt.push(rr / Mt),
                        Yt.push(1 - sr / Lt)
                    }
                }
                for (let sr = 0; sr < Lt; sr++)
                    for (let er = 0; er < Mt; er++) {
                        const rr = er + Nt * sr
                          , xr = er + Nt * (sr + 1)
                          , br = er + 1 + Nt * (sr + 1)
                          , yr = er + 1 + Nt * sr;
                        qt.push(rr, xr, yr),
                        qt.push(xr, br, yr)
                    }
                this.setIndex(qt),
                this.setAttribute("position", new Fn(Xt,3)),
                this.setAttribute("normal", new Fn(Zt,3)),
                this.setAttribute("uv", new Fn(Yt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new g_(tt.width,tt.height,tt.widthSegments,tt.heightSegments)
            }
        }
        const go = {
            alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
            alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
            alphamap_fragment: `#ifdef USE_ALPHAMAP
	#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1
	diffuseColor.a *= 1.0-texture2D( alphaMap, vAlphaMapUv ).g;
	#else
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
	#endif
#endif`,
            alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
            alphatest_fragment: `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
            alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
            aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
            aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
            begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
            beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
            bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
            iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
            bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
            clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
            clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
            clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
            clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
            color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
            color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
            color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
            color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
            common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
            cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
            defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
            displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
            displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
            emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
            emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 RGBM16ToLinear( in vec4 value ) {
	return vec4( value.rgb * value.a * 16.0, 1.0 );
}
vec4 LinearToRGBM16( in vec4 value ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / 16.0, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * 16.0 ), M );
}`,
            envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
            envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	mat4 rotationMatrix(vec3 axis, float angle) {
		axis = normalize(axis);
		float s = sin(angle);
		float c = cos(angle);
		float oc = 1.0 - c;
		return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
					oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
					oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
					0.0,                                0.0,                                0.0,                                1.0);
	}
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform float envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,
            envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
            envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
            envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
		#if defined( FIX_ENV_DIRECTION )
			vec3 worldNormal = normal;
		#else
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#endif
			worldNormal = transformDirection(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#if !defined( FIX_ENV_DIRECTION )
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			#endif
			reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
            envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
            fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
            fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
            fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
            fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
            gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
            lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
            lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
            lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
            lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
            lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
            lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
            lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
            lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
            lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
            lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
            lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#if defined( USE_ANISOTROPY ) || defined( USE_ANISOTROPY_BRDF )
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
            lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal;
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
            lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
            lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
            logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
            logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
            logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
            logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
            map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
            map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
            map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
            map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
            metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
            metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
            morphcolor_vertex: `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
            morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
            morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
            morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
            normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
            normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
            normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
            normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
            normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
            normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
            clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
            clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
            clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
            iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
            opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
diffuseColor.a = min(max(diffuseColor.a, 0.), 1.);
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
            packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;
const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
            premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
            project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
            dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
            dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
            roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
            roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
            shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
            shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
            shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
            shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
            skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
            skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
            skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
            skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
            specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
            specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
            tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
            tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
            transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
            transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	#ifndef WebGL2Context
	#define textureLod texture2DLodEXT
	#define textureSize(s, lod) vec2(1024./pow(2.,float(lod)),1024./pow(2.,float(lod)))
	#define isinf(x) (x > 1e20 || x < -1e20)
	#endif
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		if(roughness == 0.0) return transmissionSamplerMapTexelToLinear( texture2D( transmissionSamplerMap, fragCoord.xy ) );
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return transmissionSamplerMapTexelToLinear( textureBicubic( transmissionSamplerMap, fragCoord.xy, lod ) );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) || attenuationDistance == 0.0) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
            uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
            uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
            uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
            worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
            background_vert: `#ifdef HAS_TEXTURE
varying vec2 vUv;
uniform mat3 uvTransform;
uniform bool flipX;
uniform bool flipY;
#endif
void main() {
#ifdef HAS_TEXTURE
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;
    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;
#endif
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
            background_frag: `#ifdef HAS_TEXTURE
uniform sampler2D t2D;
varying vec2 vUv;
#endif
uniform float backgroundIntensity;
uniform vec3 backgroundColor;
void main() {
#ifdef HAS_TEXTURE
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
#else
	vec4 texColor = vec4( 1.0 );
#endif
	texColor.rgb *= backgroundColor * backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            backgroundCube_frag: `#include <envmap_common_pars_fragment>
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
void main() {
	vec3 vReflect = vWorldDirection;
	vReflect = transformDirection(vReflect, rotationMatrix(vec3(0,1,0), envMapRotation));
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vReflect.x, vReflect.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vReflect, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	texColor.rgb *= envMapIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
            depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
            distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
            distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
            equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
            equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
            meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
            meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
            meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
            meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
            meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
            points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
            sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
        }
          , Dn = {
            common: {
                diffuse: {
                    value: new Gn(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new lo
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lo
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new lo
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: 0
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new lo
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new lo
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new lo
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new lo
                },
                normalScale: {
                    value: new mn(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new lo
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new lo
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new lo
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new lo
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Gn(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Gn(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lo
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new lo
                }
            },
            sprite: {
                diffuse: {
                    value: new Gn(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new mn(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new lo
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lo
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , qs = {
            basic: {
                uniforms: js([Dn.common, Dn.specularmap, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.fog]),
                vertexShader: go.meshbasic_vert,
                fragmentShader: go.meshbasic_frag
            },
            lambert: {
                uniforms: js([Dn.common, Dn.specularmap, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    }
                }]),
                vertexShader: go.meshlambert_vert,
                fragmentShader: go.meshlambert_frag
            },
            phong: {
                uniforms: js([Dn.common, Dn.specularmap, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    },
                    specular: {
                        value: new Gn(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: go.meshphong_vert,
                fragmentShader: go.meshphong_frag
            },
            standard: {
                uniforms: js([Dn.common, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.roughnessmap, Dn.metalnessmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: go.meshphysical_vert,
                fragmentShader: go.meshphysical_frag
            },
            toon: {
                uniforms: js([Dn.common, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.gradientmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    }
                }]),
                vertexShader: go.meshtoon_vert,
                fragmentShader: go.meshtoon_frag
            },
            matcap: {
                uniforms: js([Dn.common, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: go.meshmatcap_vert,
                fragmentShader: go.meshmatcap_frag
            },
            points: {
                uniforms: js([Dn.points, Dn.fog]),
                vertexShader: go.points_vert,
                fragmentShader: go.points_frag
            },
            dashed: {
                uniforms: js([Dn.common, Dn.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: go.linedashed_vert,
                fragmentShader: go.linedashed_frag
            },
            depth: {
                uniforms: js([Dn.common, Dn.displacementmap]),
                vertexShader: go.depth_vert,
                fragmentShader: go.depth_frag
            },
            normal: {
                uniforms: js([Dn.common, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.meshnormal_vert,
                fragmentShader: go.meshnormal_frag
            },
            sprite: {
                uniforms: js([Dn.sprite, Dn.fog]),
                vertexShader: go.sprite_vert,
                fragmentShader: go.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new lo
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundColor: {
                        value: new Gn(16777215)
                    },
                    flipX: {
                        value: !1
                    },
                    flipY: {
                        value: !1
                    }
                },
                vertexShader: go.background_vert,
                fragmentShader: go.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    envMapRotation: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: go.backgroundCube_vert,
                fragmentShader: go.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: go.cube_vert,
                fragmentShader: go.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: go.equirect_vert,
                fragmentShader: go.equirect_frag
            },
            distanceRGBA: {
                uniforms: js([Dn.common, Dn.displacementmap, {
                    referencePosition: {
                        value: new Er
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: go.distanceRGBA_vert,
                fragmentShader: go.distanceRGBA_frag
            },
            shadow: {
                uniforms: js([Dn.lights, Dn.fog, {
                    color: {
                        value: new Gn(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.shadow_vert,
                fragmentShader: go.shadow_frag
            }
        };
        qs.physical = {
            uniforms: js([qs.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new lo
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new lo
                },
                clearcoatNormalScale: {
                    value: new mn(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new lo
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new lo
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new lo
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Gn(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new lo
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new lo
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new lo
                },
                transmissionSamplerSize: {
                    value: new mn
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new lo
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Gn(0)
                },
                specularColor: {
                    value: new Gn(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new lo
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new lo
                },
                anisotropyVector: {
                    value: new mn
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new lo
                }
            }]),
            vertexShader: go.meshphysical_vert,
            fragmentShader: go.meshphysical_frag
        };
        const wv = {
            r: 0,
            b: 0,
            g: 0
        };
        function Ew(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = new Gn(0);
            let Lt, Nt, jt = xt === !0 ? 0 : 1, Wt = null, Qt = 0, qt = null;
            function Xt(Zt, Yt) {
                Zt.getRGB(wv, jy(Tt)),
                mt.buffers.color.setClear(wv.r, wv.g, wv.b, Yt, Ct)
            }
            return {
                getClearColor: function() {
                    return Mt
                },
                setClearColor: function(Zt, Yt=1) {
                    Mt.set(Zt),
                    jt = Yt,
                    Xt(Mt, jt)
                },
                getClearAlpha: function() {
                    return jt
                },
                setClearAlpha: function(Zt) {
                    jt = Zt,
                    Xt(Mt, jt)
                },
                getPlaneMesh: function() {
                    return Lt
                },
                getBoxMesh: function() {
                    return Nt
                },
                getBoxMesh2: function() {
                    return Nt === void 0 && (Nt = new gs(new Zu(1,1,1),new zl({
                        name: "BackgroundCubeMaterial",
                        uniforms: Sp(qs.backgroundCube.uniforms),
                        vertexShader: qs.backgroundCube.vertexShader,
                        fragmentShader: qs.backgroundCube.fragmentShader,
                        side: bt,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    Nt.geometry.deleteAttribute("normal"),
                    Nt.geometry.deleteAttribute("uv"),
                    Nt.onBeforeRender = function(Zt, Yt, sr) {
                        this.matrixWorld.copyPosition(sr.matrixWorld)
                    }
                    ,
                    Object.defineProperty(Nt.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    ft.update(Nt)),
                    Nt
                },
                render: function(Zt, Yt) {
                    let sr = !1
                      , er = Yt.isScene === !0 ? Yt.background : null;
                    const rr = Yt.isScene && Yt.backgroundColor !== void 0 ? Yt.backgroundColor : null;
                    er === "environment" && (er = Yt.environment),
                    er && er.isTexture && (er = (Yt.backgroundBlurriness > 0 ? lt : tt).get(er)),
                    er === null ? Xt(Mt, jt) : er && er.isColor && (Xt(er, 1),
                    sr = !0);
                    const xr = Tt.xr.getEnvironmentBlendMode();
                    if (xr === "additive" ? mt.buffers.color.setClear(0, 0, 0, 1, Ct) : xr === "alpha-blend" && mt.buffers.color.setClear(0, 0, 0, 0, Ct),
                    (Tt.autoClear || sr) && Tt.clear(Tt.autoClearColor, Tt.autoClearDepth, Tt.autoClearStencil),
                    er && (er.isCubeTexture || er.mapping === Mn))
                        Nt === void 0 && (Nt = new gs(new Zu(1,1,1),new zl({
                            name: "BackgroundCubeMaterial",
                            uniforms: Sp(qs.backgroundCube.uniforms),
                            vertexShader: qs.backgroundCube.vertexShader,
                            fragmentShader: qs.backgroundCube.fragmentShader,
                            side: bt,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        Nt.geometry.deleteAttribute("normal"),
                        Nt.geometry.deleteAttribute("uv"),
                        Nt.onBeforeRender = function(br, yr, Pr) {
                            this.matrixWorld.copyPosition(Pr.matrixWorld)
                        }
                        ,
                        Object.defineProperty(Nt.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        ft.update(Nt)),
                        Nt.material.uniforms.envMap.value = er,
                        Nt.material.uniforms.envMapRotation.value = er && er.rotation || 0,
                        Nt.material.uniforms.envMapIntensity.value = er === Yt.environment && Yt.envMapIntensity || 1,
                        Nt.material.uniforms.flipEnvMap.value = er.isCubeTexture && er.isRenderTargetTexture === !1 ? -1 : 1,
                        Nt.material.uniforms.backgroundBlurriness.value = Yt.backgroundBlurriness,
                        Nt.material.uniforms.backgroundIntensity.value = Yt.backgroundIntensity,
                        Nt.material.toneMapped = Do.getTransfer(er.colorSpace) !== Vo,
                        Wt === er && Qt === er.version && qt === Tt.toneMapping || (Nt.material.needsUpdate = !0,
                        Wt = er,
                        Qt = er.version,
                        qt = Tt.toneMapping),
                        Nt.layers.enableAll(),
                        Zt.unshift(Nt, Nt.geometry, Nt.material, 0, 0, null);
                    else if (er && er.isTexture || !er && rr) {
                        Lt === void 0 && (Lt = new gs(new g_(2,2),new zl({
                            name: "BackgroundMaterial",
                            uniforms: Sp(qs.background.uniforms),
                            vertexShader: qs.background.vertexShader,
                            fragmentShader: qs.background.fragmentShader,
                            side: vt,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        Lt.geometry.deleteAttribute("normal"),
                        Object.defineProperty(Lt.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        ft.update(Lt)),
                        Lt.material.uniforms.backgroundColor.value.set(rr || 16777215),
                        Lt.material.uniforms.t2D.value = er,
                        Lt.material.uniforms.backgroundIntensity.value = Yt.backgroundIntensity,
                        er ? (Lt.material.toneMapped = Do.getTransfer(er.colorSpace) !== Vo,
                        Lt.material.uniforms.flipX.value = er.userData.flipX || !1,
                        Lt.material.uniforms.flipY.value = er.userData.flipY || !1,
                        er.matrixAutoUpdate === !0 && er.updateMatrix(),
                        Lt.material.uniforms.uvTransform.value.copy(er.matrix),
                        Lt.material.defines.HAS_TEXTURE = "1") : Lt.material.defines.HAS_TEXTURE && delete Lt.material.defines.HAS_TEXTURE;
                        const br = er ? er.version : -1;
                        Wt === er && Qt === br && qt === Tt.toneMapping || (Lt.material.needsUpdate = !0,
                        Wt = er,
                        Qt = br,
                        qt = Tt.toneMapping),
                        Lt.layers.enableAll(),
                        Zt.unshift(Lt, Lt.geometry, Lt.material, 0, 0, null)
                    }
                }
            }
        }
        function Tw(Tt, tt, lt, mt) {
            const ft = Tt.getParameter(Tt.MAX_VERTEX_ATTRIBS)
              , xt = mt.isWebGL2 ? null : tt.get("OES_vertex_array_object")
              , Ct = mt.isWebGL2 || xt !== null
              , Mt = {}
              , Lt = qt(null);
            let Nt = Lt
              , jt = !1;
            function Wt(br) {
                return mt.isWebGL2 ? Tt.bindVertexArray(br) : xt.bindVertexArrayOES(br)
            }
            function Qt(br) {
                return mt.isWebGL2 ? Tt.deleteVertexArray(br) : xt.deleteVertexArrayOES(br)
            }
            function qt(br) {
                const yr = []
                  , Pr = []
                  , zr = [];
                for (let Nr = 0; Nr < ft; Nr++)
                    yr[Nr] = 0,
                    Pr[Nr] = 0,
                    zr[Nr] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: yr,
                    enabledAttributes: Pr,
                    attributeDivisors: zr,
                    object: br,
                    attributes: {},
                    index: null
                }
            }
            function Xt() {
                const br = Nt.newAttributes;
                for (let yr = 0, Pr = br.length; yr < Pr; yr++)
                    br[yr] = 0
            }
            function Zt(br) {
                Yt(br, 0)
            }
            function Yt(br, yr) {
                const Pr = Nt.newAttributes
                  , zr = Nt.enabledAttributes
                  , Nr = Nt.attributeDivisors;
                Pr[br] = 1,
                zr[br] === 0 && (Tt.enableVertexAttribArray(br),
                zr[br] = 1),
                Nr[br] !== yr && ((mt.isWebGL2 ? Tt : tt.get("ANGLE_instanced_arrays"))[mt.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](br, yr),
                Nr[br] = yr)
            }
            function sr() {
                const br = Nt.newAttributes
                  , yr = Nt.enabledAttributes;
                for (let Pr = 0, zr = yr.length; Pr < zr; Pr++)
                    yr[Pr] !== br[Pr] && (Tt.disableVertexAttribArray(Pr),
                    yr[Pr] = 0)
            }
            function er(br, yr, Pr, zr, Nr, Vr, Gr) {
                Gr === !0 ? Tt.vertexAttribIPointer(br, yr, Pr, Nr, Vr) : Tt.vertexAttribPointer(br, yr, Pr, zr, Nr, Vr)
            }
            function rr() {
                xr(),
                jt = !0,
                Nt !== Lt && (Nt = Lt,
                Wt(Nt.object))
            }
            function xr() {
                Lt.geometry = null,
                Lt.program = null,
                Lt.wireframe = !1
            }
            return {
                setup: function(br, yr, Pr, zr, Nr) {
                    let Vr = !1;
                    if (Ct) {
                        const Gr = function(Hr, _n, dn) {
                            const kn = dn.wireframe === !0;
                            let Bn = Mt[Hr.id];
                            Bn === void 0 && (Bn = {},
                            Mt[Hr.id] = Bn);
                            let cn = Bn[_n.id];
                            cn === void 0 && (cn = {},
                            Bn[_n.id] = cn);
                            let Yr = cn[kn];
                            return Yr === void 0 && (Yr = qt(mt.isWebGL2 ? Tt.createVertexArray() : xt.createVertexArrayOES()),
                            cn[kn] = Yr),
                            Yr
                        }(zr, Pr, yr);
                        Nt !== Gr && (Nt = Gr,
                        Wt(Nt.object)),
                        Vr = function(Hr, _n, dn, kn) {
                            const Bn = Nt.attributes
                              , cn = _n.attributes;
                            let Yr = 0;
                            const Jr = dn.getAttributes();
                            for (const sn in Jr)
                                if (Jr[sn].location >= 0) {
                                    const on = Bn[sn];
                                    let Un = cn[sn];
                                    if (Un === void 0 && (sn === "instanceMatrix" && Hr.instanceMatrix && (Un = Hr.instanceMatrix),
                                    sn === "instanceColor" && Hr.instanceColor && (Un = Hr.instanceColor)),
                                    on === void 0 || on.attribute !== Un || Un && on.data !== Un.data)
                                        return !0;
                                    Yr++
                                }
                            return Nt.attributesNum !== Yr || Nt.index !== kn
                        }(br, zr, Pr, Nr),
                        Vr && function(Hr, _n, dn, kn) {
                            const Bn = {}
                              , cn = _n.attributes;
                            let Yr = 0;
                            const Jr = dn.getAttributes();
                            for (const sn in Jr)
                                if (Jr[sn].location >= 0) {
                                    let on = cn[sn];
                                    on === void 0 && (sn === "instanceMatrix" && Hr.instanceMatrix && (on = Hr.instanceMatrix),
                                    sn === "instanceColor" && Hr.instanceColor && (on = Hr.instanceColor));
                                    const Un = {};
                                    Un.attribute = on,
                                    on && on.data && (Un.data = on.data),
                                    Bn[sn] = Un,
                                    Yr++
                                }
                            Nt.attributes = Bn,
                            Nt.attributesNum = Yr,
                            Nt.index = kn
                        }(br, zr, Pr, Nr)
                    } else {
                        const Gr = yr.wireframe === !0;
                        Nt.geometry === zr.id && Nt.program === Pr.id && Nt.wireframe === Gr || (Nt.geometry = zr.id,
                        Nt.program = Pr.id,
                        Nt.wireframe = Gr,
                        Vr = !0)
                    }
                    Nr !== null && lt.update(Nr, Tt.ELEMENT_ARRAY_BUFFER),
                    (Vr || jt) && (jt = !1,
                    function(Gr, Hr, _n, dn) {
                        if (mt.isWebGL2 === !1 && (Gr.isInstancedMesh || dn.isInstancedBufferGeometry) && tt.get("ANGLE_instanced_arrays") === null)
                            return;
                        Xt();
                        const kn = dn.attributes
                          , Bn = _n.getAttributes()
                          , cn = Hr.defaultAttributeValues;
                        for (const Yr in Bn) {
                            const Jr = Bn[Yr];
                            if (Jr.location >= 0) {
                                let sn = kn[Yr];
                                if (sn === void 0 && (Yr === "instanceMatrix" && Gr.instanceMatrix && (sn = Gr.instanceMatrix),
                                Yr === "instanceColor" && Gr.instanceColor && (sn = Gr.instanceColor)),
                                sn !== void 0) {
                                    const on = sn.normalized
                                      , Un = sn.itemSize
                                      , ro = lt.get(sn);
                                    if (ro === void 0)
                                        continue;
                                    const Zn = ro.buffer
                                      , jn = ro.type
                                      , uo = ro.bytesPerElement
                                      , Dr = mt.isWebGL2 === !0 && (jn === Tt.INT || jn === Tt.UNSIGNED_INT || sn.gpuType === $o);
                                    if (sn.isInterleavedBufferAttribute) {
                                        const Sr = sn.data
                                          , Fr = Sr.stride
                                          , Wr = sn.offset;
                                        if (Sr.isInstancedInterleavedBuffer) {
                                            for (let kr = 0; kr < Jr.locationSize; kr++)
                                                Yt(Jr.location + kr, Sr.meshPerAttribute);
                                            Gr.isInstancedMesh !== !0 && dn._maxInstanceCount === void 0 && (dn._maxInstanceCount = Sr.meshPerAttribute * Sr.count)
                                        } else
                                            for (let kr = 0; kr < Jr.locationSize; kr++)
                                                Zt(Jr.location + kr);
                                        Tt.bindBuffer(Tt.ARRAY_BUFFER, Zn);
                                        for (let kr = 0; kr < Jr.locationSize; kr++)
                                            er(Jr.location + kr, Un / Jr.locationSize, jn, on, Fr * uo, (Wr + Un / Jr.locationSize * kr) * uo, Dr)
                                    } else {
                                        if (sn.isInstancedBufferAttribute) {
                                            for (let Sr = 0; Sr < Jr.locationSize; Sr++)
                                                Yt(Jr.location + Sr, sn.meshPerAttribute);
                                            Gr.isInstancedMesh !== !0 && dn._maxInstanceCount === void 0 && (dn._maxInstanceCount = sn.meshPerAttribute * sn.count)
                                        } else
                                            for (let Sr = 0; Sr < Jr.locationSize; Sr++)
                                                Zt(Jr.location + Sr);
                                        Tt.bindBuffer(Tt.ARRAY_BUFFER, Zn);
                                        for (let Sr = 0; Sr < Jr.locationSize; Sr++)
                                            er(Jr.location + Sr, Un / Jr.locationSize, jn, on, Un * uo, Un / Jr.locationSize * Sr * uo, Dr)
                                    }
                                } else if (cn !== void 0) {
                                    const on = cn[Yr];
                                    if (on !== void 0)
                                        switch (on.length) {
                                        case 2:
                                            Tt.vertexAttrib2fv(Jr.location, on);
                                            break;
                                        case 3:
                                            Tt.vertexAttrib3fv(Jr.location, on);
                                            break;
                                        case 4:
                                            Tt.vertexAttrib4fv(Jr.location, on);
                                            break;
                                        default:
                                            Tt.vertexAttrib1fv(Jr.location, on)
                                        }
                                }
                            }
                        }
                        sr()
                    }(br, yr, Pr, zr),
                    Nr !== null && Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, lt.get(Nr).buffer))
                },
                reset: rr,
                resetDefaultState: xr,
                dispose: function() {
                    rr();
                    for (const br in Mt) {
                        const yr = Mt[br];
                        for (const Pr in yr) {
                            const zr = yr[Pr];
                            for (const Nr in zr)
                                Qt(zr[Nr].object),
                                delete zr[Nr];
                            delete yr[Pr]
                        }
                        delete Mt[br]
                    }
                },
                releaseStatesOfGeometry: function(br) {
                    if (Mt[br.id] === void 0)
                        return;
                    const yr = Mt[br.id];
                    for (const Pr in yr) {
                        const zr = yr[Pr];
                        for (const Nr in zr)
                            Qt(zr[Nr].object),
                            delete zr[Nr];
                        delete yr[Pr]
                    }
                    delete Mt[br.id]
                },
                releaseStatesOfProgram: function(br) {
                    for (const yr in Mt) {
                        const Pr = Mt[yr];
                        if (Pr[br.id] === void 0)
                            continue;
                        const zr = Pr[br.id];
                        for (const Nr in zr)
                            Qt(zr[Nr].object),
                            delete zr[Nr];
                        delete Pr[br.id]
                    }
                },
                initAttributes: Xt,
                enableAttribute: Zt,
                disableUnusedAttributes: sr
            }
        }
        function Cw(Tt, tt, lt, mt) {
            const ft = mt.isWebGL2;
            let xt;
            this.setMode = function(Ct) {
                xt = Ct
            }
            ,
            this.render = function(Ct, Mt) {
                Tt.drawArrays(xt, Ct, Mt),
                lt.update(Mt, xt, 1)
            }
            ,
            this.renderInstances = function(Ct, Mt, Lt) {
                if (Lt === 0)
                    return;
                let Nt, jt;
                if (ft)
                    Nt = Tt,
                    jt = "drawArraysInstanced";
                else if (Nt = tt.get("ANGLE_instanced_arrays"),
                jt = "drawArraysInstancedANGLE",
                Nt === null)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                Nt[jt](xt, Ct, Mt, Lt),
                lt.update(Mt, xt, Lt)
            }
        }
        function Pw(Tt, tt, lt) {
            let mt;
            function ft(xr) {
                if (xr === "highp") {
                    if (Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.HIGH_FLOAT).precision > 0 && Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.HIGH_FLOAT).precision > 0)
                        return "highp";
                    xr = "mediump"
                }
                return xr === "mediump" && Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.MEDIUM_FLOAT).precision > 0 && Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const xt = typeof WebGL2RenderingContext < "u" && Tt.constructor.name === "WebGL2RenderingContext";
            let Ct = lt.precision !== void 0 ? lt.precision : "highp";
            const Mt = ft(Ct);
            Mt !== Ct && (console.warn("THREE.WebGLRenderer:", Ct, "not supported, using", Mt, "instead."),
            Ct = Mt);
            const Lt = xt || tt.has("WEBGL_draw_buffers")
              , Nt = lt.logarithmicDepthBuffer === !0
              , jt = Tt.getParameter(Tt.MAX_TEXTURE_IMAGE_UNITS)
              , Wt = Tt.getParameter(Tt.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , Qt = Tt.getParameter(Tt.MAX_TEXTURE_SIZE)
              , qt = Tt.getParameter(Tt.MAX_CUBE_MAP_TEXTURE_SIZE)
              , Xt = Tt.getParameter(Tt.MAX_VERTEX_ATTRIBS)
              , Zt = Tt.getParameter(Tt.MAX_VERTEX_UNIFORM_VECTORS)
              , Yt = Tt.getParameter(Tt.MAX_VARYING_VECTORS)
              , sr = Tt.getParameter(Tt.MAX_FRAGMENT_UNIFORM_VECTORS)
              , er = Wt > 0
              , rr = xt || tt.has("OES_texture_float");
            return {
                isWebGL2: xt,
                drawBuffers: Lt,
                getMaxAnisotropy: function() {
                    if (mt !== void 0)
                        return mt;
                    if (tt.has("EXT_texture_filter_anisotropic") === !0) {
                        const xr = tt.get("EXT_texture_filter_anisotropic");
                        mt = Tt.getParameter(xr.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        mt = 0;
                    return mt
                },
                getMaxPrecision: ft,
                precision: Ct,
                logarithmicDepthBuffer: Nt,
                maxTextures: jt,
                maxVertexTextures: Wt,
                maxTextureSize: Qt,
                maxCubemapSize: qt,
                maxAttributes: Xt,
                maxVertexUniforms: Zt,
                maxVaryings: Yt,
                maxFragmentUniforms: sr,
                vertexTextures: er,
                floatFragmentTextures: rr,
                floatVertexTextures: er && rr,
                maxSamples: xt ? Tt.getParameter(Tt.MAX_SAMPLES) : 0
            }
        }
        function Mw(Tt) {
            const tt = this;
            let lt = null
              , mt = 0
              , ft = !1
              , xt = !1;
            const Ct = new _d
              , Mt = new lo
              , Lt = {
                value: null,
                needsUpdate: !1
            };
            function Nt(jt, Wt, Qt, qt) {
                const Xt = jt !== null ? jt.length : 0;
                let Zt = null;
                if (Xt !== 0) {
                    if (Zt = Lt.value,
                    qt !== !0 || Zt === null) {
                        const Yt = Qt + 4 * Xt
                          , sr = Wt.matrixWorldInverse;
                        Mt.getNormalMatrix(sr),
                        (Zt === null || Zt.length < Yt) && (Zt = new Float32Array(Yt));
                        for (let er = 0, rr = Qt; er !== Xt; ++er,
                        rr += 4)
                            Ct.copy(jt[er]).applyMatrix4(sr, Mt),
                            Ct.normal.toArray(Zt, rr),
                            Zt[rr + 3] = Ct.constant
                    }
                    Lt.value = Zt,
                    Lt.needsUpdate = !0
                }
                return tt.numPlanes = Xt,
                tt.numIntersection = 0,
                Zt
            }
            this.uniform = Lt,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(jt, Wt) {
                const Qt = jt.length !== 0 || Wt || mt !== 0 || ft;
                return ft = Wt,
                mt = jt.length,
                Qt
            }
            ,
            this.beginShadows = function() {
                xt = !0,
                Nt(null)
            }
            ,
            this.endShadows = function() {
                xt = !1
            }
            ,
            this.setGlobalState = function(jt, Wt) {
                lt = Nt(jt, Wt, 0)
            }
            ,
            this.setState = function(jt, Wt, Qt) {
                const qt = jt.clippingPlanes
                  , Xt = jt.clipIntersection
                  , Zt = jt.clipShadows
                  , Yt = Tt.get(jt);
                if (!ft || qt === null || qt.length === 0 || xt && !Zt)
                    xt ? Nt(null) : (Lt.value !== lt && (Lt.value = lt,
                    Lt.needsUpdate = mt > 0),
                    tt.numPlanes = mt,
                    tt.numIntersection = 0);
                else {
                    const sr = xt ? 0 : mt
                      , er = 4 * sr;
                    let rr = Yt.clippingState || null;
                    Lt.value = rr,
                    rr = Nt(qt, Wt, er, Qt);
                    for (let xr = 0; xr !== er; ++xr)
                        rr[xr] = lt[xr];
                    Yt.clippingState = rr,
                    this.numIntersection = Xt ? this.numPlanes : 0,
                    this.numPlanes += sr
                }
            }
        }
        function Rw(Tt) {
            let tt = new WeakMap;
            function lt(ft, xt) {
                return xt === qr ? ft.mapping = Qr : xt === gn && (ft.mapping = Or),
                ft
            }
            function mt(ft) {
                const xt = ft.target;
                xt.removeEventListener("dispose", mt);
                const Ct = tt.get(xt);
                Ct !== void 0 && (tt.delete(xt),
                Ct.dispose())
            }
            return {
                get: function(ft) {
                    if (ft && ft.isTexture && ft.isRenderTargetTexture === !1) {
                        const xt = ft.mapping;
                        if (xt === qr || xt === gn) {
                            if (tt.has(ft)) {
                                const Ct = tt.get(ft).texture;
                                return Ct.rotation = ft.rotation,
                                lt(Ct, ft.mapping)
                            }
                            {
                                const Ct = ft.image;
                                if (Ct && Ct.height > 0) {
                                    const Mt = new zy(Ct.height / 2);
                                    return Mt.fromEquirectangularTexture(Tt, ft),
                                    Mt.texture.rotation = ft.rotation,
                                    tt.set(ft, Mt),
                                    ft.addEventListener("dispose", mt),
                                    lt(Mt.texture, ft.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return ft
                },
                dispose: function() {
                    tt = new WeakMap
                }
            }
        }
        class Sv extends xv {
            constructor(tt=-1, lt=1, mt=1, ft=-1, xt=.1, Ct=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = tt,
                this.right = lt,
                this.top = mt,
                this.bottom = ft,
                this.near = xt,
                this.far = Ct,
                this.updateProjectionMatrix()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.left = tt.left,
                this.right = tt.right,
                this.top = tt.top,
                this.bottom = tt.bottom,
                this.near = tt.near,
                this.far = tt.far,
                this.zoom = tt.zoom,
                this.view = tt.view === null ? null : Object.assign({}, tt.view),
                this
            }
            setViewOffset(tt, lt, mt, ft, xt, Ct) {
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = tt,
                this.view.fullHeight = lt,
                this.view.offsetX = mt,
                this.view.offsetY = ft,
                this.view.width = xt,
                this.view.height = Ct,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const tt = (this.right - this.left) / (2 * this.zoom)
                  , lt = (this.top - this.bottom) / (2 * this.zoom)
                  , mt = (this.right + this.left) / 2
                  , ft = (this.top + this.bottom) / 2;
                let xt = mt - tt
                  , Ct = mt + tt
                  , Mt = ft + lt
                  , Lt = ft - lt;
                if (this.view !== null && this.view.enabled) {
                    const Nt = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , jt = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    xt += Nt * this.view.offsetX,
                    Ct = xt + Nt * this.view.width,
                    Mt -= jt * this.view.offsetY,
                    Lt = Mt - jt * this.view.height
                }
                this.projectionMatrix.makeOrthographic(xt, Ct, Mt, Lt, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.zoom = this.zoom,
                lt.object.left = this.left,
                lt.object.right = this.right,
                lt.object.top = this.top,
                lt.object.bottom = this.bottom,
                lt.object.near = this.near,
                lt.object.far = this.far,
                this.view !== null && (lt.object.view = Object.assign({}, this.view)),
                lt
            }
        }
        const Qy = [.125, .215, .35, .446, .526, .582]
          , U0 = new Sv
          , Wy = new Gn;
        let j0 = null;
        const Tp = (1 + Math.sqrt(5)) / 2
          , xm = 1 / Tp
          , qy = [new Er(1,1,1), new Er(-1,1,1), new Er(1,1,-1), new Er(-1,1,-1), new Er(0,Tp,xm), new Er(0,Tp,-xm), new Er(xm,0,Tp), new Er(-xm,0,Tp), new Er(Tp,xm,0), new Er(-Tp,xm,0)];
        class V0 {
            constructor(tt) {
                this._renderer = tt,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(tt, lt=0, mt=.1, ft=100) {
                j0 = this._renderer.getRenderTarget(),
                this._setSize(256);
                const xt = this._allocateTargets();
                return xt.depthBuffer = !0,
                this._sceneToCubeUV(tt, mt, ft, xt),
                lt > 0 && this._blur(xt, 0, 0, lt),
                this._applyPMREM(xt),
                this._cleanup(xt),
                xt
            }
            fromEquirectangular(tt, lt=null) {
                return this._fromTexture(tt, lt)
            }
            fromCubemap(tt, lt=null) {
                return this._fromTexture(tt, lt)
            }
            compileCubemapShader() {
                this._cubemapMaterial === null && (this._cubemapMaterial = Yy(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                this._equirectMaterial === null && (this._equirectMaterial = Xy(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                this._equirectMaterial !== null && this._equirectMaterial.dispose()
            }
            _setSize(tt) {
                this._lodMax = Math.floor(Math.log2(tt)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                this._blurMaterial !== null && this._blurMaterial.dispose(),
                this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                for (let tt = 0; tt < this._lodPlanes.length; tt++)
                    this._lodPlanes[tt].dispose()
            }
            _cleanup(tt) {
                this._renderer.setRenderTarget(j0),
                tt.scissorTest = !1,
                Ev(tt, 0, 0, tt.width, tt.height)
            }
            _fromTexture(tt, lt) {
                tt.mapping === Qr || tt.mapping === Or ? this._setSize(tt.image.length === 0 ? 16 : tt.image[0].width || tt.image[0].image.width) : this._setSize(tt.image.width / 4),
                j0 = this._renderer.getRenderTarget();
                const mt = lt || this._allocateTargets();
                return this._textureToCubeUV(tt, mt),
                this._applyPMREM(mt),
                this._cleanup(mt),
                mt
            }
            _allocateTargets() {
                const tt = 3 * Math.max(this._cubeSize, 112)
                  , lt = 4 * this._cubeSize
                  , mt = {
                    magFilter: Rn,
                    minFilter: Rn,
                    generateMipmaps: !1,
                    type: Os,
                    format: as,
                    colorSpace: Xo,
                    depthBuffer: !1
                }
                  , ft = $y(tt, lt, mt);
                if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== tt || this._pingPongRenderTarget.height !== lt) {
                    this._pingPongRenderTarget !== null && this._dispose(),
                    this._pingPongRenderTarget = $y(tt, lt, mt);
                    const {_lodMax: xt} = this;
                    ({
sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(Ct) {
                        const Mt = []
                          , Lt = []
                          , Nt = [];
                        let jt = Ct;
                        const Wt = Ct - 4 + 1 + Qy.length;
                        for (let Qt = 0; Qt < Wt; Qt++) {
                            const qt = Math.pow(2, jt);
                            Lt.push(qt);
                            let Xt = 1 / qt;
                            Qt > Ct - 4 ? Xt = Qy[Qt - Ct + 4 - 1] : Qt === 0 && (Xt = 0),
                            Nt.push(Xt);
                            const Zt = 1 / (qt - 2)
                              , Yt = -Zt
                              , sr = 1 + Zt
                              , er = [Yt, Yt, sr, Yt, sr, sr, Yt, Yt, sr, sr, Yt, sr]
                              , rr = 6
                              , xr = 6
                              , br = 3
                              , yr = 2
                              , Pr = 1
                              , zr = new Float32Array(br * xr * rr)
                              , Nr = new Float32Array(yr * xr * rr)
                              , Vr = new Float32Array(Pr * xr * rr);
                            for (let Hr = 0; Hr < rr; Hr++) {
                                const _n = Hr % 3 * 2 / 3 - 1
                                  , dn = Hr > 2 ? 0 : -1
                                  , kn = [_n, dn, 0, _n + 2 / 3, dn, 0, _n + 2 / 3, dn + 1, 0, _n, dn, 0, _n + 2 / 3, dn + 1, 0, _n, dn + 1, 0];
                                zr.set(kn, br * xr * Hr),
                                Nr.set(er, yr * xr * Hr);
                                const Bn = [Hr, Hr, Hr, Hr, Hr, Hr];
                                Vr.set(Bn, Pr * xr * Hr)
                            }
                            const Gr = new bo;
                            Gr.setAttribute("position", new mr(zr,br)),
                            Gr.setAttribute("uv", new mr(Nr,yr)),
                            Gr.setAttribute("faceIndex", new mr(Vr,Pr)),
                            Mt.push(Gr),
                            jt > 4 && jt--
                        }
                        return {
                            lodPlanes: Mt,
                            sizeLods: Lt,
                            sigmas: Nt
                        }
                    }(xt)),
                    this._blurMaterial = function(Ct, Mt, Lt) {
                        const Nt = new Float32Array(20)
                          , jt = new Er(0,1,0);
                        return new zl({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / Mt,
                                CUBEUV_TEXEL_HEIGHT: 1 / Lt,
                                CUBEUV_MAX_MIP: `${
Ct}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: Nt
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: jt
                                }
                            },
                            vertexShader: `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`,
                            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                            blending: Et,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(xt, tt, lt)
                }
                return ft
            }
            _compileMaterial(tt) {
                const lt = new gs(this._lodPlanes[0],tt);
                this._renderer.compile(lt, U0)
            }
            _sceneToCubeUV(tt, lt, mt, ft) {
                const xt = new Cs(90,1,lt,mt)
                  , Ct = [1, -1, 1, 1, 1, 1]
                  , Mt = [1, 1, 1, -1, -1, -1]
                  , Lt = this._renderer
                  , Nt = Lt.autoClear
                  , jt = Lt.toneMapping;
                Lt.getClearColor(Wy),
                Lt.toneMapping = Ur,
                Lt.autoClear = !1;
                const Wt = new nu({
                    name: "PMREM.Background",
                    side: bt,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , Qt = new gs(new Zu,Wt);
                let qt = !1;
                const Xt = tt.background;
                Xt ? Xt.isColor && (Wt.color.copy(Xt),
                tt.background = null,
                qt = !0) : (Wt.color.copy(Wy),
                qt = !0);
                for (let Zt = 0; Zt < 6; Zt++) {
                    const Yt = Zt % 3;
                    Yt === 0 ? (xt.up.set(0, Ct[Zt], 0),
                    xt.lookAt(Mt[Zt], 0, 0)) : Yt === 1 ? (xt.up.set(0, 0, Ct[Zt]),
                    xt.lookAt(0, Mt[Zt], 0)) : (xt.up.set(0, Ct[Zt], 0),
                    xt.lookAt(0, 0, Mt[Zt]));
                    const sr = this._cubeSize;
                    Ev(ft, Yt * sr, Zt > 2 ? sr : 0, sr, sr),
                    Lt.setRenderTarget(ft),
                    qt && Lt.render(Qt, xt),
                    Lt.render(tt, xt)
                }
                Qt.geometry.dispose(),
                Qt.material.dispose(),
                Lt.toneMapping = jt,
                Lt.autoClear = Nt,
                tt.background = Xt
            }
            _textureToCubeUV(tt, lt) {
                const mt = this._renderer
                  , ft = tt.mapping === Qr || tt.mapping === Or;
                ft ? (this._cubemapMaterial === null && (this._cubemapMaterial = Yy()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = tt.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Xy());
                const xt = ft ? this._cubemapMaterial : this._equirectMaterial
                  , Ct = new gs(this._lodPlanes[0],xt);
                xt.uniforms.envMap.value = tt;
                const Mt = this._cubeSize;
                Ev(lt, 0, 0, 3 * Mt, 2 * Mt),
                mt.setRenderTarget(lt),
                mt.render(Ct, U0)
            }
            _applyPMREM(tt) {
                const lt = this._renderer
                  , mt = lt.autoClear;
                lt.autoClear = !1;
                for (let ft = 1; ft < this._lodPlanes.length; ft++) {
                    const xt = Math.sqrt(this._sigmas[ft] * this._sigmas[ft] - this._sigmas[ft - 1] * this._sigmas[ft - 1])
                      , Ct = qy[(ft - 1) % qy.length];
                    this._blur(tt, ft - 1, ft, xt, Ct)
                }
                lt.autoClear = mt
            }
            _blur(tt, lt, mt, ft, xt) {
                const Ct = this._pingPongRenderTarget;
                this._halfBlur(tt, Ct, lt, mt, ft, "latitudinal", xt),
                this._halfBlur(Ct, tt, mt, mt, ft, "longitudinal", xt)
            }
            _halfBlur(tt, lt, mt, ft, xt, Ct, Mt) {
                const Lt = this._renderer
                  , Nt = this._blurMaterial;
                Ct !== "latitudinal" && Ct !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                const jt = new gs(this._lodPlanes[ft],Nt)
                  , Wt = Nt.uniforms
                  , Qt = this._sizeLods[mt] - 1
                  , qt = isFinite(xt) ? Math.PI / (2 * Qt) : 2 * Math.PI / 39
                  , Xt = xt / qt
                  , Zt = isFinite(xt) ? 1 + Math.floor(3 * Xt) : 20;
                Zt > 20 && console.warn(`sigmaRadians, ${
xt}, is too large and will clip, as it requested ${
Zt} samples when the maximum is set to 20`);
                const Yt = [];
                let sr = 0;
                for (let xr = 0; xr < 20; ++xr) {
                    const br = xr / Xt
                      , yr = Math.exp(-br * br / 2);
                    Yt.push(yr),
                    xr === 0 ? sr += yr : xr < Zt && (sr += 2 * yr)
                }
                for (let xr = 0; xr < Yt.length; xr++)
                    Yt[xr] = Yt[xr] / sr;
                Wt.envMap.value = tt.texture,
                Wt.samples.value = Zt,
                Wt.weights.value = Yt,
                Wt.latitudinal.value = Ct === "latitudinal",
                Mt && (Wt.poleAxis.value = Mt);
                const {_lodMax: er} = this;
                Wt.dTheta.value = qt,
                Wt.mipInt.value = er - mt;
                const rr = this._sizeLods[ft];
                Ev(lt, 3 * rr * (ft > er - 4 ? ft - er + 4 : 0), 4 * (this._cubeSize - rr), 3 * rr, 2 * rr),
                Lt.setRenderTarget(lt),
                Lt.render(jt, U0)
            }
        }
        function $y(Tt, tt, lt) {
            const mt = new Rs(Tt,tt,lt);
            return mt.texture.mapping = Mn,
            mt.texture.name = "PMREM.cubeUv",
            mt.scissorTest = !0,
            mt
        }
        function Ev(Tt, tt, lt, mt, ft) {
            Tt.viewport.set(tt, lt, mt, ft),
            Tt.scissor.set(tt, lt, mt, ft)
        }
        function Xy() {
            return new zl({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`,
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                blending: Et,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Yy() {
            return new zl({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`,
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                blending: Et,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Iw(Tt) {
            let tt = new WeakMap
              , lt = null;
            function mt(ft) {
                const xt = ft.target;
                xt.removeEventListener("dispose", mt);
                const Ct = tt.get(xt);
                Ct !== void 0 && (tt.delete(xt),
                Ct.dispose())
            }
            return {
                get: function(ft) {
                    if (ft && ft.isTexture) {
                        const xt = ft.mapping
                          , Ct = xt === qr || xt === gn
                          , Mt = xt === Qr || xt === Or;
                        if (Ct || Mt) {
                            if (ft.isRenderTargetTexture && ft.needsPMREMUpdate === !0) {
                                ft.needsPMREMUpdate = !1;
                                let Lt = tt.get(ft);
                                return lt === null && (lt = new V0(Tt)),
                                Lt = Ct ? lt.fromEquirectangular(ft, Lt) : lt.fromCubemap(ft, Lt),
                                tt.set(ft, Lt),
                                Lt.texture
                            }
                            if (tt.has(ft))
                                return tt.get(ft).texture;
                            {
                                const Lt = ft.image;
                                if (Ct && Lt && Lt.height > 0 || Mt && Lt && function(Nt) {
                                    let jt = 0;
                                    for (let Wt = 0; Wt < 6; Wt++)
                                        Nt[Wt] !== void 0 && jt++;
                                    return jt === 6
                                }(Lt)) {
                                    lt === null && (lt = new V0(Tt));
                                    const Nt = Ct ? lt.fromEquirectangular(ft) : lt.fromCubemap(ft);
                                    return tt.set(ft, Nt),
                                    ft.addEventListener("dispose", mt),
                                    Nt.texture
                                }
                                return null
                            }
                        }
                    }
                    return ft
                },
                dispose: function() {
                    tt = new WeakMap,
                    lt !== null && (lt.dispose(),
                    lt = null)
                }
            }
        }
        function kw(Tt) {
            const tt = {};
            function lt(mt) {
                if (tt[mt] !== void 0)
                    return tt[mt];
                let ft;
                switch (mt) {
                case "WEBGL_depth_texture":
                    ft = Tt.getExtension("WEBGL_depth_texture") || Tt.getExtension("MOZ_WEBGL_depth_texture") || Tt.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    ft = Tt.getExtension("EXT_texture_filter_anisotropic") || Tt.getExtension("MOZ_EXT_texture_filter_anisotropic") || Tt.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    ft = Tt.getExtension("WEBGL_compressed_texture_s3tc") || Tt.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || Tt.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    ft = Tt.getExtension("WEBGL_compressed_texture_pvrtc") || Tt.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    ft = Tt.getExtension(mt)
                }
                return tt[mt] = ft,
                ft
            }
            return {
                has: function(mt) {
                    return lt(mt) !== null
                },
                init: function(mt) {
                    mt.isWebGL2 ? lt("EXT_color_buffer_float") : (lt("WEBGL_depth_texture"),
                    lt("OES_texture_float"),
                    lt("OES_texture_half_float"),
                    lt("OES_texture_half_float_linear"),
                    lt("OES_standard_derivatives"),
                    lt("OES_element_index_uint"),
                    lt("OES_vertex_array_object"),
                    lt("ANGLE_instanced_arrays")),
                    lt("OES_texture_float_linear"),
                    lt("EXT_color_buffer_half_float"),
                    lt("WEBGL_multisampled_render_to_texture")
                },
                get: function(mt) {
                    const ft = lt(mt);
                    return ft === null && console.warn("THREE.WebGLRenderer: " + mt + " extension not supported."),
                    ft
                }
            }
        }
        function Dw(Tt, tt, lt, mt) {
            const ft = {}
              , xt = new WeakMap;
            function Ct(Lt) {
                const Nt = Lt.target;
                Nt.index !== null && tt.remove(Nt.index);
                for (const Wt in Nt.attributes)
                    tt.remove(Nt.attributes[Wt]);
                for (const Wt in Nt.morphAttributes) {
                    const Qt = Nt.morphAttributes[Wt];
                    for (let qt = 0, Xt = Qt.length; qt < Xt; qt++)
                        tt.remove(Qt[qt])
                }
                Nt.removeEventListener("dispose", Ct),
                delete ft[Nt.id];
                const jt = xt.get(Nt);
                jt && (tt.remove(jt),
                xt.delete(Nt)),
                mt.releaseStatesOfGeometry(Nt),
                Nt.isInstancedBufferGeometry === !0 && delete Nt._maxInstanceCount,
                lt.memory.geometries--
            }
            function Mt(Lt) {
                const Nt = []
                  , jt = Lt.index
                  , Wt = Lt.attributes.position;
                let Qt = 0;
                if (jt !== null) {
                    const Zt = jt.array;
                    Qt = jt.version;
                    for (let Yt = 0, sr = Zt.length; Yt < sr; Yt += 3) {
                        const er = Zt[Yt + 0]
                          , rr = Zt[Yt + 1]
                          , xr = Zt[Yt + 2];
                        Nt.push(er, rr, rr, xr, xr, er)
                    }
                } else {
                    if (Wt === void 0)
                        return;
                    {
                        const Zt = Wt.array;
                        Qt = Wt.version;
                        for (let Yt = 0, sr = Zt.length / 3 - 1; Yt < sr; Yt += 3) {
                            const er = Yt + 0
                              , rr = Yt + 1
                              , xr = Yt + 2;
                            Nt.push(er, rr, rr, xr, xr, er)
                        }
                    }
                }
                const qt = new (tv(Nt) ? Ts : co)(Nt,1);
                qt.version = Qt;
                const Xt = xt.get(Lt);
                Xt && tt.remove(Xt),
                xt.set(Lt, qt)
            }
            return {
                get: function(Lt, Nt) {
                    return ft[Nt.id] === !0 || (Nt.addEventListener("dispose", Ct),
                    ft[Nt.id] = !0,
                    lt.memory.geometries++),
                    Nt
                },
                update: function(Lt) {
                    const Nt = Lt.attributes;
                    for (const Wt in Nt)
                        tt.update(Nt[Wt], Tt.ARRAY_BUFFER);
                    const jt = Lt.morphAttributes;
                    for (const Wt in jt) {
                        const Qt = jt[Wt];
                        for (let qt = 0, Xt = Qt.length; qt < Xt; qt++)
                            tt.update(Qt[qt], Tt.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(Lt) {
                    const Nt = xt.get(Lt);
                    if (Nt) {
                        const jt = Lt.index;
                        jt !== null && Nt.version < jt.version && Mt(Lt)
                    } else
                        Mt(Lt);
                    return xt.get(Lt)
                }
            }
        }
        function Bw(Tt, tt, lt, mt) {
            const ft = mt.isWebGL2;
            let xt, Ct, Mt;
            this.setMode = function(Lt) {
                xt = Lt
            }
            ,
            this.setIndex = function(Lt) {
                Ct = Lt.type,
                Mt = Lt.bytesPerElement
            }
            ,
            this.render = function(Lt, Nt) {
                Tt.drawElements(xt, Nt, Ct, Lt * Mt),
                lt.update(Nt, xt, 1)
            }
            ,
            this.renderInstances = function(Lt, Nt, jt) {
                if (jt === 0)
                    return;
                let Wt, Qt;
                if (ft)
                    Wt = Tt,
                    Qt = "drawElementsInstanced";
                else if (Wt = tt.get("ANGLE_instanced_arrays"),
                Qt = "drawElementsInstancedANGLE",
                Wt === null)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                Wt[Qt](xt, Nt, Ct, Lt * Mt, jt),
                lt.update(Nt, xt, jt)
            }
        }
        function Lw(Tt) {
            const tt = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: tt,
                programs: null,
                autoReset: !0,
                reset: function() {
                    tt.calls = 0,
                    tt.triangles = 0,
                    tt.points = 0,
                    tt.lines = 0
                },
                update: function(lt, mt, ft) {
                    switch (tt.calls++,
                    mt) {
                    case Tt.TRIANGLES:
                        tt.triangles += ft * (lt / 3);
                        break;
                    case Tt.LINES:
                        tt.lines += ft * (lt / 2);
                        break;
                    case Tt.LINE_STRIP:
                        tt.lines += ft * (lt - 1);
                        break;
                    case Tt.LINE_LOOP:
                        tt.lines += ft * lt;
                        break;
                    case Tt.POINTS:
                        tt.points += ft * lt;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", mt)
                    }
                }
            }
        }
        function Ow(Tt, tt) {
            return Tt[0] - tt[0]
        }
        function Nw(Tt, tt) {
            return Math.abs(tt[1]) - Math.abs(Tt[1])
        }
        function Fw(Tt, tt, lt) {
            const mt = {}
              , ft = new Float32Array(8)
              , xt = new WeakMap
              , Ct = new Lo
              , Mt = [];
            for (let Lt = 0; Lt < 8; Lt++)
                Mt[Lt] = [Lt, 0];
            return {
                update: function(Lt, Nt, jt) {
                    const Wt = Lt.morphTargetInfluences;
                    if (tt.isWebGL2 === !0) {
                        const Qt = Nt.morphAttributes.position || Nt.morphAttributes.normal || Nt.morphAttributes.color
                          , qt = Qt !== void 0 ? Qt.length : 0;
                        let Xt = xt.get(Nt);
                        if (Xt === void 0 || Xt.count !== qt) {
                            let _n = function() {
                                Gr.dispose(),
                                xt.delete(Nt),
                                Nt.removeEventListener("dispose", _n)
                            };
                            Xt !== void 0 && Xt.texture.dispose();
                            const sr = Nt.morphAttributes.position !== void 0
                              , er = Nt.morphAttributes.normal !== void 0
                              , rr = Nt.morphAttributes.color !== void 0
                              , xr = Nt.morphAttributes.position || []
                              , br = Nt.morphAttributes.normal || []
                              , yr = Nt.morphAttributes.color || [];
                            let Pr = 0;
                            sr === !0 && (Pr = 1),
                            er === !0 && (Pr = 2),
                            rr === !0 && (Pr = 3);
                            let zr = Nt.attributes.position.count * Pr
                              , Nr = 1;
                            zr > tt.maxTextureSize && (Nr = Math.ceil(zr / tt.maxTextureSize),
                            zr = tt.maxTextureSize);
                            const Vr = new Float32Array(zr * Nr * 4 * qt)
                              , Gr = new im(Vr,zr,Nr,qt);
                            Gr.type = ss,
                            Gr.needsUpdate = !0;
                            const Hr = 4 * Pr;
                            for (let dn = 0; dn < qt; dn++) {
                                const kn = xr[dn]
                                  , Bn = br[dn]
                                  , cn = yr[dn]
                                  , Yr = zr * Nr * 4 * dn;
                                for (let Jr = 0; Jr < kn.count; Jr++) {
                                    const sn = Jr * Hr;
                                    sr === !0 && (Ct.fromBufferAttribute(kn, Jr),
                                    Vr[Yr + sn + 0] = Ct.x,
                                    Vr[Yr + sn + 1] = Ct.y,
                                    Vr[Yr + sn + 2] = Ct.z,
                                    Vr[Yr + sn + 3] = 0),
                                    er === !0 && (Ct.fromBufferAttribute(Bn, Jr),
                                    Vr[Yr + sn + 4] = Ct.x,
                                    Vr[Yr + sn + 5] = Ct.y,
                                    Vr[Yr + sn + 6] = Ct.z,
                                    Vr[Yr + sn + 7] = 0),
                                    rr === !0 && (Ct.fromBufferAttribute(cn, Jr),
                                    Vr[Yr + sn + 8] = Ct.x,
                                    Vr[Yr + sn + 9] = Ct.y,
                                    Vr[Yr + sn + 10] = Ct.z,
                                    Vr[Yr + sn + 11] = cn.itemSize === 4 ? Ct.w : 1)
                                }
                            }
                            Xt = {
                                count: qt,
                                texture: Gr,
                                size: new mn(zr,Nr)
                            },
                            xt.set(Nt, Xt),
                            Nt.addEventListener("dispose", _n)
                        }
                        let Zt = 0;
                        for (let sr = 0; sr < Wt.length; sr++)
                            Zt += Wt[sr];
                        const Yt = Nt.morphTargetsRelative ? 1 : 1 - Zt;
                        jt.getUniforms().setValue(Tt, "morphTargetBaseInfluence", Yt),
                        jt.getUniforms().setValue(Tt, "morphTargetInfluences", Wt),
                        jt.getUniforms().setValue(Tt, "morphTargetsTexture", Xt.texture, lt),
                        jt.getUniforms().setValue(Tt, "morphTargetsTextureSize", Xt.size)
                    } else {
                        const Qt = Wt === void 0 ? 0 : Wt.length;
                        let qt = mt[Nt.id];
                        if (qt === void 0 || qt.length !== Qt) {
                            qt = [];
                            for (let er = 0; er < Qt; er++)
                                qt[er] = [er, 0];
                            mt[Nt.id] = qt
                        }
                        for (let er = 0; er < Qt; er++) {
                            const rr = qt[er];
                            rr[0] = er,
                            rr[1] = Wt[er]
                        }
                        qt.sort(Nw);
                        for (let er = 0; er < 8; er++)
                            er < Qt && qt[er][1] ? (Mt[er][0] = qt[er][0],
                            Mt[er][1] = qt[er][1]) : (Mt[er][0] = Number.MAX_SAFE_INTEGER,
                            Mt[er][1] = 0);
                        Mt.sort(Ow);
                        const Xt = Nt.morphAttributes.position
                          , Zt = Nt.morphAttributes.normal;
                        let Yt = 0;
                        for (let er = 0; er < 8; er++) {
                            const rr = Mt[er]
                              , xr = rr[0]
                              , br = rr[1];
                            xr !== Number.MAX_SAFE_INTEGER && br ? (Xt && Nt.getAttribute("morphTarget" + er) !== Xt[xr] && Nt.setAttribute("morphTarget" + er, Xt[xr]),
                            Zt && Nt.getAttribute("morphNormal" + er) !== Zt[xr] && Nt.setAttribute("morphNormal" + er, Zt[xr]),
                            ft[er] = br,
                            Yt += br) : (Xt && Nt.hasAttribute("morphTarget" + er) === !0 && Nt.deleteAttribute("morphTarget" + er),
                            Zt && Nt.hasAttribute("morphNormal" + er) === !0 && Nt.deleteAttribute("morphNormal" + er),
                            ft[er] = 0)
                        }
                        const sr = Nt.morphTargetsRelative ? 1 : 1 - Yt;
                        jt.getUniforms().setValue(Tt, "morphTargetBaseInfluence", sr),
                        jt.getUniforms().setValue(Tt, "morphTargetInfluences", ft)
                    }
                }
            }
        }
        function Uw(Tt, tt, lt, mt) {
            let ft = new WeakMap;
            function xt(Ct) {
                const Mt = Ct.target;
                Mt.removeEventListener("dispose", xt),
                lt.remove(Mt.instanceMatrix),
                Mt.instanceColor !== null && lt.remove(Mt.instanceColor)
            }
            return {
                update: function(Ct) {
                    const Mt = mt.render.frame
                      , Lt = Ct.geometry
                      , Nt = tt.get(Ct, Lt);
                    if (ft.get(Nt) !== Mt && (tt.update(Nt),
                    ft.set(Nt, Mt)),
                    Ct.isInstancedMesh && (Ct.hasEventListener("dispose", xt) === !1 && Ct.addEventListener("dispose", xt),
                    ft.get(Ct) !== Mt && (lt.update(Ct.instanceMatrix, Tt.ARRAY_BUFFER),
                    Ct.instanceColor !== null && lt.update(Ct.instanceColor, Tt.ARRAY_BUFFER),
                    ft.set(Ct, Mt))),
                    Ct.isSkinnedMesh) {
                        const jt = Ct.skeleton;
                        ft.get(jt) !== Mt && (jt.update(),
                        ft.set(jt, Mt))
                    }
                    return Nt
                },
                dispose: function() {
                    ft = new WeakMap
                }
            }
        }
        const Ky = new Ho
          , Jy = new im
          , Zy = new i_
          , ex = new f_
          , tx = []
          , rx = []
          , nx = new Float32Array(16)
          , ix = new Float32Array(9)
          , ox = new Float32Array(4);
        function bm(Tt, tt, lt) {
            const mt = Tt[0];
            if (mt <= 0 || mt > 0)
                return Tt;
            const ft = tt * lt;
            let xt = tx[ft];
            if (xt === void 0 && (xt = new Float32Array(ft),
            tx[ft] = xt),
            tt !== 0) {
                mt.toArray(xt, 0);
                for (let Ct = 1, Mt = 0; Ct !== tt; ++Ct)
                    Mt += lt,
                    Tt[Ct].toArray(xt, Mt)
            }
            return xt
        }
        function cs(Tt, tt) {
            if (Tt.length !== tt.length)
                return !1;
            for (let lt = 0, mt = Tt.length; lt < mt; lt++)
                if (Tt[lt] !== tt[lt])
                    return !1;
            return !0
        }
        function us(Tt, tt) {
            for (let lt = 0, mt = tt.length; lt < mt; lt++)
                Tt[lt] = tt[lt]
        }
        function Tv(Tt, tt) {
            let lt = rx[tt];
            lt === void 0 && (lt = new Int32Array(tt),
            rx[tt] = lt);
            for (let mt = 0; mt !== tt; ++mt)
                lt[mt] = Tt.allocateTextureUnit();
            return lt
        }
        function jw(Tt, tt) {
            const lt = this.cache;
            lt[0] !== tt && (Tt.uniform1f(this.addr, tt),
            lt[0] = tt)
        }
        function Vw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y || (Tt.uniform2f(this.addr, tt.x, tt.y),
                lt[0] = tt.x,
                lt[1] = tt.y);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform2fv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Gw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z || (Tt.uniform3f(this.addr, tt.x, tt.y, tt.z),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z);
            else if (tt.r !== void 0)
                lt[0] === tt.r && lt[1] === tt.g && lt[2] === tt.b || (Tt.uniform3f(this.addr, tt.r, tt.g, tt.b),
                lt[0] = tt.r,
                lt[1] = tt.g,
                lt[2] = tt.b);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform3fv(this.addr, tt),
                us(lt, tt)
            }
        }
        function zw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z && lt[3] === tt.w || (Tt.uniform4f(this.addr, tt.x, tt.y, tt.z, tt.w),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z,
                lt[3] = tt.w);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform4fv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Hw(Tt, tt) {
            const lt = this.cache
              , mt = tt.elements;
            if (mt === void 0) {
                if (cs(lt, tt))
                    return;
                Tt.uniformMatrix2fv(this.addr, !1, tt),
                us(lt, tt)
            } else {
                if (cs(lt, mt))
                    return;
                ox.set(mt),
                Tt.uniformMatrix2fv(this.addr, !1, ox),
                us(lt, mt)
            }
        }
        function Qw(Tt, tt) {
            const lt = this.cache
              , mt = tt.elements;
            if (mt === void 0) {
                if (cs(lt, tt))
                    return;
                Tt.uniformMatrix3fv(this.addr, !1, tt),
                us(lt, tt)
            } else {
                if (cs(lt, mt))
                    return;
                ix.set(mt),
                Tt.uniformMatrix3fv(this.addr, !1, ix),
                us(lt, mt)
            }
        }
        function Ww(Tt, tt) {
            const lt = this.cache
              , mt = tt.elements;
            if (mt === void 0) {
                if (cs(lt, tt))
                    return;
                Tt.uniformMatrix4fv(this.addr, !1, tt),
                us(lt, tt)
            } else {
                if (cs(lt, mt))
                    return;
                nx.set(mt),
                Tt.uniformMatrix4fv(this.addr, !1, nx),
                us(lt, mt)
            }
        }
        function qw(Tt, tt) {
            const lt = this.cache;
            lt[0] !== tt && (Tt.uniform1i(this.addr, tt),
            lt[0] = tt)
        }
        function $w(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y || (Tt.uniform2i(this.addr, tt.x, tt.y),
                lt[0] = tt.x,
                lt[1] = tt.y);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform2iv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Xw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z || (Tt.uniform3i(this.addr, tt.x, tt.y, tt.z),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform3iv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Yw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z && lt[3] === tt.w || (Tt.uniform4i(this.addr, tt.x, tt.y, tt.z, tt.w),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z,
                lt[3] = tt.w);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform4iv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Kw(Tt, tt) {
            const lt = this.cache;
            lt[0] !== tt && (Tt.uniform1ui(this.addr, tt),
            lt[0] = tt)
        }
        function Jw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y || (Tt.uniform2ui(this.addr, tt.x, tt.y),
                lt[0] = tt.x,
                lt[1] = tt.y);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform2uiv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Zw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z || (Tt.uniform3ui(this.addr, tt.x, tt.y, tt.z),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform3uiv(this.addr, tt),
                us(lt, tt)
            }
        }
        function e1(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z && lt[3] === tt.w || (Tt.uniform4ui(this.addr, tt.x, tt.y, tt.z, tt.w),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z,
                lt[3] = tt.w);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform4uiv(this.addr, tt),
                us(lt, tt)
            }
        }
        function t1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTexture2D(tt || Ky, ft)
        }
        function r1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTexture3D(tt || Zy, ft)
        }
        function n1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTextureCube(tt || ex, ft)
        }
        function i1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTexture2DArray(tt || Jy, ft)
        }
        function o1(Tt, tt) {
            Tt.uniform1fv(this.addr, tt)
        }
        function s1(Tt, tt) {
            const lt = bm(tt, this.size, 2);
            Tt.uniform2fv(this.addr, lt)
        }
        function a1(Tt, tt) {
            const lt = bm(tt, this.size, 3);
            Tt.uniform3fv(this.addr, lt)
        }
        function l1(Tt, tt) {
            const lt = bm(tt, this.size, 4);
            Tt.uniform4fv(this.addr, lt)
        }
        function c1(Tt, tt) {
            const lt = bm(tt, this.size, 4);
            Tt.uniformMatrix2fv(this.addr, !1, lt)
        }
        function u1(Tt, tt) {
            const lt = bm(tt, this.size, 9);
            Tt.uniformMatrix3fv(this.addr, !1, lt)
        }
        function d1(Tt, tt) {
            const lt = bm(tt, this.size, 16);
            Tt.uniformMatrix4fv(this.addr, !1, lt)
        }
        function p1(Tt, tt) {
            Tt.uniform1iv(this.addr, tt)
        }
        function h1(Tt, tt) {
            Tt.uniform2iv(this.addr, tt)
        }
        function m1(Tt, tt) {
            Tt.uniform3iv(this.addr, tt)
        }
        function f1(Tt, tt) {
            Tt.uniform4iv(this.addr, tt)
        }
        function g1(Tt, tt) {
            Tt.uniform1uiv(this.addr, tt)
        }
        function _1(Tt, tt) {
            Tt.uniform2uiv(this.addr, tt)
        }
        function y1(Tt, tt) {
            Tt.uniform3uiv(this.addr, tt)
        }
        function x1(Tt, tt) {
            Tt.uniform4uiv(this.addr, tt)
        }
        function b1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTexture2D(tt[Ct] || Ky, xt[Ct])
        }
        function A1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTexture3D(tt[Ct] || Zy, xt[Ct])
        }
        function w1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTextureCube(tt[Ct] || ex, xt[Ct])
        }
        function S1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTexture2DArray(tt[Ct] || Jy, xt[Ct])
        }
        class E1 {
            constructor(tt, lt, mt) {
                this.id = tt,
                this.addr = mt,
                this.cache = [],
                this.setValue = function(ft) {
                    switch (ft) {
                    case 5126:
                        return jw;
                    case 35664:
                        return Vw;
                    case 35665:
                        return Gw;
                    case 35666:
                        return zw;
                    case 35674:
                        return Hw;
                    case 35675:
                        return Qw;
                    case 35676:
                        return Ww;
                    case 5124:
                    case 35670:
                        return qw;
                    case 35667:
                    case 35671:
                        return $w;
                    case 35668:
                    case 35672:
                        return Xw;
                    case 35669:
                    case 35673:
                        return Yw;
                    case 5125:
                        return Kw;
                    case 36294:
                        return Jw;
                    case 36295:
                        return Zw;
                    case 36296:
                        return e1;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return t1;
                    case 35679:
                    case 36299:
                    case 36307:
                        return r1;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return n1;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return i1
                    }
                }(lt.type)
            }
        }
        class T1 {
            constructor(tt, lt, mt) {
                this.id = tt,
                this.addr = mt,
                this.cache = [],
                this.size = lt.size,
                this.setValue = function(ft) {
                    switch (ft) {
                    case 5126:
                        return o1;
                    case 35664:
                        return s1;
                    case 35665:
                        return a1;
                    case 35666:
                        return l1;
                    case 35674:
                        return c1;
                    case 35675:
                        return u1;
                    case 35676:
                        return d1;
                    case 5124:
                    case 35670:
                        return p1;
                    case 35667:
                    case 35671:
                        return h1;
                    case 35668:
                    case 35672:
                        return m1;
                    case 35669:
                    case 35673:
                        return f1;
                    case 5125:
                        return g1;
                    case 36294:
                        return _1;
                    case 36295:
                        return y1;
                    case 36296:
                        return x1;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return b1;
                    case 35679:
                    case 36299:
                    case 36307:
                        return A1;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return w1;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return S1
                    }
                }(lt.type)
            }
        }
        class C1 {
            constructor(tt) {
                this.id = tt,
                this.seq = [],
                this.map = {}
            }
            setValue(tt, lt, mt) {
                const ft = this.seq;
                for (let xt = 0, Ct = ft.length; xt !== Ct; ++xt) {
                    const Mt = ft[xt];
                    Mt.setValue(tt, lt[Mt.id], mt)
                }
            }
        }
        const G0 = /(\w+)(\])?(\[|\.)?/g;
        function sx(Tt, tt) {
            Tt.seq.push(tt),
            Tt.map[tt.id] = tt
        }
        function P1(Tt, tt, lt) {
            const mt = Tt.name
              , ft = mt.length;
            for (G0.lastIndex = 0; ; ) {
                const xt = G0.exec(mt)
                  , Ct = G0.lastIndex;
                let Mt = xt[1];
                const Lt = xt[2] === "]"
                  , Nt = xt[3];
                if (Lt && (Mt |= 0),
                Nt === void 0 || Nt === "[" && Ct + 2 === ft) {
                    sx(lt, Nt === void 0 ? new E1(Mt,Tt,tt) : new T1(Mt,Tt,tt));
                    break
                }
                {
                    let jt = lt.map[Mt];
                    jt === void 0 && (jt = new C1(Mt),
                    sx(lt, jt)),
                    lt = jt
                }
            }
        }
        class Cv {
            constructor(tt, lt) {
                this.seq = [],
                this.map = {};
                const mt = tt.getProgramParameter(lt, tt.ACTIVE_UNIFORMS);
                for (let ft = 0; ft < mt; ++ft) {
                    const xt = tt.getActiveUniform(lt, ft);
                    P1(xt, tt.getUniformLocation(lt, xt.name), this)
                }
            }
            setValue(tt, lt, mt, ft) {
                const xt = this.map[lt];
                xt !== void 0 && xt.setValue(tt, mt, ft)
            }
            setOptional(tt, lt, mt) {
                const ft = lt[mt];
                ft !== void 0 && this.setValue(tt, mt, ft)
            }
            static upload(tt, lt, mt, ft) {
                for (let xt = 0, Ct = lt.length; xt !== Ct; ++xt) {
                    const Mt = lt[xt]
                      , Lt = mt[Mt.id];
                    Lt.needsUpdate !== !1 && Mt.setValue(tt, Lt.value, ft)
                }
            }
            static seqWithValue(tt, lt) {
                const mt = [];
                for (let ft = 0, xt = tt.length; ft !== xt; ++ft) {
                    const Ct = tt[ft];
                    Ct.id in lt && mt.push(Ct)
                }
                return mt
            }
        }
        function ax(Tt, tt, lt) {
            const mt = Tt.createShader(tt);
            return Tt.shaderSource(mt, lt),
            Tt.compileShader(mt),
            mt
        }
        let M1 = 0;
        function lx(Tt, tt, lt) {
            const mt = Tt.getShaderParameter(tt, Tt.COMPILE_STATUS)
              , ft = Tt.getShaderInfoLog(tt).trim();
            if (mt && ft === "")
                return "";
            const xt = /ERROR: 0:(\d+)/.exec(ft);
            if (xt) {
                const Ct = parseInt(xt[1]);
                return lt.toUpperCase() + `

` + ft + `

` + function(Mt, Lt) {
                    const Nt = Mt.split(`
`)
                      , jt = []
                      , Wt = Math.max(Lt - 6, 0)
                      , Qt = Math.min(Lt + 6, Nt.length);
                    for (let qt = Wt; qt < Qt; qt++) {
                        const Xt = qt + 1;
                        jt.push(`${
Xt === Lt ? ">" : " "} ${
Xt}: ${
Nt[qt]}`)
                    }
                    return jt.join(`
`)
                }(Tt.getShaderSource(tt), Ct)
            }
            return ft
        }
        function R1(Tt, tt) {
            let lt;
            switch (tt) {
            case Xo:
                lt = "";
                break;
            case jo:
                lt = "sRGBToLinear";
                break;
            case ps:
                lt = "RGBM16ToLinear";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported color space:", tt),
                lt = ""
            }
            return `vec4 ${
Tt}( vec4 value ) { return ${
lt} ( value ); }`
        }
        function I1(Tt, tt) {
            const lt = function(mt) {
                const ft = Do.getPrimaries(Do.workingColorSpace)
                  , xt = mt === Oo || mt === ps ? null : Do.getPrimaries(mt);
                let Ct;
                switch (ft !== xt && xt ? ft === Ou && xt === Wo ? Ct = "LinearDisplayP3ToLinearSRGB" : ft === Wo && xt === Ou && (Ct = "LinearSRGBToLinearDisplayP3") : Ct = "",
                mt) {
                case Oo:
                    return ["", ""];
                case Xo:
                case hu:
                    return [Ct, "LinearTransferOETF"];
                case jo:
                case dp:
                    return [Ct, "sRGBTransferOETF"];
                case ps:
                    return ["", "LinearToRGBM16"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", mt),
                    [Ct, "LinearTransferOETF"]
                }
            }(tt);
            return `vec4 ${
Tt}( vec4 value ) { return ${
lt[0]}( ${
lt[1]}( value ) ); }`
        }
        function k1(Tt, tt) {
            let lt;
            switch (tt) {
            case nn:
                lt = "Linear";
                break;
            case xn:
                lt = "Reinhard";
                break;
            case ur:
                lt = "OptimizedCineon";
                break;
            case pr:
                lt = "ACESFilmic";
                break;
            case Ir:
                lt = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", tt),
                lt = "Linear"
            }
            return "vec3 " + Tt + "( vec3 color ) { return " + lt + "ToneMapping( color ); }"
        }
        function __(Tt) {
            return Tt !== ""
        }
        function cx(Tt, tt) {
            const lt = tt.numSpotLightShadows + tt.numSpotLightMaps - tt.numSpotLightShadowsWithMaps;
            return Tt.replace(/NUM_DIR_LIGHTS/g, tt.numDirLights).replace(/NUM_SPOT_LIGHTS/g, tt.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, tt.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, lt).replace(/NUM_RECT_AREA_LIGHTS/g, tt.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, tt.numPointLights).replace(/NUM_HEMI_LIGHTS/g, tt.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, tt.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, tt.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, tt.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, tt.numPointLightShadows)
        }
        function ux(Tt, tt) {
            return Tt.replace(/NUM_CLIPPING_PLANES/g, tt.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, tt.numClippingPlanes - tt.numClipIntersection)
        }
        const D1 = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function z0(Tt) {
            return Tt.replace(D1, L1)
        }
        const B1 = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
        function L1(Tt, tt) {
            let lt = go[tt];
            if (lt === void 0) {
                const mt = B1.get(tt);
                if (mt === void 0)
                    throw new Error("Can not resolve #include <" + tt + ">");
                lt = go[mt],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', tt, mt)
            }
            return z0(lt)
        }
        const O1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function dx(Tt) {
            return Tt.replace(O1, N1)
        }
        function N1(Tt, tt, lt, mt) {
            let ft = "";
            for (let xt = parseInt(tt); xt < parseInt(lt); xt++)
                ft += mt.replace(/\[\s*i\s*\]/g, "[ " + xt + " ]").replace(/UNROLLED_LOOP_INDEX/g, xt);
            return ft
        }
        function hx(Tt) {
            let tt = "precision " + Tt.precision + ` float;
precision ` + Tt.precision + " int;";
            return Tt.precision === "highp" ? tt += `
#define HIGH_PRECISION` : Tt.precision === "mediump" ? tt += `
#define MEDIUM_PRECISION` : Tt.precision === "lowp" && (tt += `
#define LOW_PRECISION`),
            tt
        }
        function F1(Tt, tt, lt, mt) {
            const ft = Tt.getContext()
              , xt = lt.defines;
            let Ct = lt.vertexShader
              , Mt = lt.fragmentShader;
            const Lt = function(Nr) {
                let Vr = "SHADOWMAP_TYPE_BASIC";
                return Nr.shadowMapType === pt ? Vr = "SHADOWMAP_TYPE_PCF" : Nr.shadowMapType === ht ? Vr = "SHADOWMAP_TYPE_PCF_SOFT" : Nr.shadowMapType === _t && (Vr = "SHADOWMAP_TYPE_VSM"),
                Vr
            }(lt)
              , Nt = function(Nr) {
                let Vr = "ENVMAP_TYPE_CUBE";
                if (Nr.envMap)
                    switch (Nr.envMapMode) {
                    case Qr:
                    case Or:
                        Vr = "ENVMAP_TYPE_CUBE";
                        break;
                    case Mn:
                        Vr = "ENVMAP_TYPE_CUBE_UV"
                    }
                return Vr
            }(lt)
              , jt = function(Nr) {
                let Vr = "ENVMAP_MODE_REFLECTION";
                return Nr.envMap && Nr.envMapMode === Or && (Vr = "ENVMAP_MODE_REFRACTION"),
                Vr
            }(lt)
              , Wt = function(Nr) {
                let Vr = "ENVMAP_BLENDING_NONE";
                if (Nr.envMap)
                    switch (Nr.combine) {
                    case Wn:
                        Vr = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case qn:
                        Vr = "ENVMAP_BLENDING_MIX";
                        break;
                    case mo:
                        Vr = "ENVMAP_BLENDING_ADD"
                    }
                return Vr
            }(lt)
              , Qt = function(Nr) {
                const Vr = Nr.envMapCubeUVHeight;
                if (Vr === null)
                    return null;
                const Gr = Math.log2(Vr) - 2
                  , Hr = 1 / Vr;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, Gr), 112)),
                    texelHeight: Hr,
                    maxMip: Gr
                }
            }(lt)
              , qt = lt.isWebGL2 ? "" : function(Nr) {
                return [Nr.extensionDerivatives || Nr.envMapCubeUVHeight || Nr.bumpMap || Nr.normalMapTangentSpace || Nr.clearcoatNormalMap || Nr.flatShading || Nr.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (Nr.extensionFragDepth || Nr.logarithmicDepthBuffer) && Nr.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", Nr.extensionDrawBuffers && Nr.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (Nr.extensionShaderTextureLOD || Nr.envMap || Nr.transmission) && Nr.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(__).join(`
`)
            }(lt)
              , Xt = function(Nr) {
                const Vr = [];
                for (const Gr in Nr) {
                    const Hr = Nr[Gr];
                    Hr !== !1 && Vr.push("#define " + Gr + " " + Hr)
                }
                return Vr.join(`
`)
            }(xt)
              , Zt = ft.createProgram();
            let Yt, sr, er = lt.glslVersion ? "#version " + lt.glslVersion + `
` : "";
            lt.isRawShaderMaterial ? (Yt = ["#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt].filter(__).join(`
`),
            Yt.length > 0 && (Yt += `
`),
            sr = [qt, "#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt].filter(__).join(`
`),
            sr.length > 0 && (sr += `
`)) : (Yt = [hx(lt), "#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt, lt.instancing ? "#define USE_INSTANCING" : "", lt.instancingColor ? "#define USE_INSTANCING_COLOR" : "", lt.useFog && lt.fog ? "#define USE_FOG" : "", lt.useFog && lt.fogExp2 ? "#define FOG_EXP2" : "", lt.map ? "#define USE_MAP" : "", lt.envMap ? "#define USE_ENVMAP" : "", lt.envMap ? "#define " + jt : "", lt.lightMap ? "#define USE_LIGHTMAP" : "", lt.aoMap ? "#define USE_AOMAP" : "", lt.bumpMap ? "#define USE_BUMPMAP" : "", lt.normalMap ? "#define USE_NORMALMAP" : "", lt.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", lt.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", lt.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", lt.emissiveMap ? "#define USE_EMISSIVEMAP" : "", lt.anisotropy ? "#define USE_ANISOTROPY" : "", lt.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", lt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", lt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", lt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", lt.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", lt.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", lt.specularMap ? "#define USE_SPECULARMAP" : "", lt.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", lt.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", lt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", lt.metalnessMap ? "#define USE_METALNESSMAP" : "", lt.alphaMap ? "#define USE_ALPHAMAP" : "", lt.alphaHash ? "#define USE_ALPHAHASH" : "", lt.transmission ? "#define USE_TRANSMISSION" : "", lt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", lt.thicknessMap ? "#define USE_THICKNESSMAP" : "", lt.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", lt.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", lt.mapUv ? "#define MAP_UV " + lt.mapUv : "", lt.alphaMapUv ? "#define ALPHAMAP_UV " + lt.alphaMapUv : "", lt.lightMapUv ? "#define LIGHTMAP_UV " + lt.lightMapUv : "", lt.aoMapUv ? "#define AOMAP_UV " + lt.aoMapUv : "", lt.emissiveMapUv ? "#define EMISSIVEMAP_UV " + lt.emissiveMapUv : "", lt.bumpMapUv ? "#define BUMPMAP_UV " + lt.bumpMapUv : "", lt.normalMapUv ? "#define NORMALMAP_UV " + lt.normalMapUv : "", lt.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + lt.displacementMapUv : "", lt.metalnessMapUv ? "#define METALNESSMAP_UV " + lt.metalnessMapUv : "", lt.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + lt.roughnessMapUv : "", lt.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + lt.anisotropyMapUv : "", lt.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + lt.clearcoatMapUv : "", lt.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + lt.clearcoatNormalMapUv : "", lt.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + lt.clearcoatRoughnessMapUv : "", lt.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + lt.iridescenceMapUv : "", lt.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + lt.iridescenceThicknessMapUv : "", lt.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + lt.sheenColorMapUv : "", lt.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + lt.sheenRoughnessMapUv : "", lt.specularMapUv ? "#define SPECULARMAP_UV " + lt.specularMapUv : "", lt.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + lt.specularColorMapUv : "", lt.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + lt.specularIntensityMapUv : "", lt.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + lt.transmissionMapUv : "", lt.thicknessMapUv ? "#define THICKNESSMAP_UV " + lt.thicknessMapUv : "", lt.vertexTangents && lt.flatShading === !1 ? "#define USE_TANGENT" : "", lt.vertexColors ? "#define USE_COLOR" : "", lt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", lt.vertexUv1s ? "#define USE_UV1" : "", lt.vertexUv2s ? "#define USE_UV2" : "", lt.vertexUv3s ? "#define USE_UV3" : "", lt.pointsUvs ? "#define USE_POINTS_UV" : "", lt.flatShading ? "#define FLAT_SHADED" : "", lt.skinning ? "#define USE_SKINNING" : "", lt.morphTargets ? "#define USE_MORPHTARGETS" : "", lt.morphNormals && lt.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", lt.morphColors && lt.isWebGL2 ? "#define USE_MORPHCOLORS" : "", lt.morphTargetsCount > 0 && lt.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", lt.morphTargetsCount > 0 && lt.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + lt.morphTextureStride : "", lt.morphTargetsCount > 0 && lt.isWebGL2 ? "#define MORPHTARGETS_COUNT " + lt.morphTargetsCount : "", lt.doubleSided ? "#define DOUBLE_SIDED" : "", lt.flipSided ? "#define FLIP_SIDED" : "", lt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", lt.shadowMapEnabled ? "#define " + Lt : "", lt.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", lt.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", lt.useLegacyLights ? "#define LEGACY_LIGHTS" : "", lt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", lt.logarithmicDepthBuffer && lt.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(__).join(`
`),
            sr = [qt, hx(lt), "#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt, lt.instancing ? "#define USE_INSTANCING" : "", lt.instancingColor ? "#define USE_INSTANCING_COLOR" : "", lt.useFog && lt.fog ? "#define USE_FOG" : "", lt.useFog && lt.fogExp2 ? "#define FOG_EXP2" : "", lt.map ? "#define USE_MAP" : "", lt.matcap ? "#define USE_MATCAP" : "", lt.envMap ? "#define USE_ENVMAP" : "", lt.envMap ? "#define " + Nt : "", lt.envMap ? "#define " + jt : "", lt.envMap ? "#define " + Wt : "", Qt ? "#define CUBEUV_TEXEL_WIDTH " + Qt.texelWidth : "", Qt ? "#define CUBEUV_TEXEL_HEIGHT " + Qt.texelHeight : "", Qt ? "#define CUBEUV_MAX_MIP " + Qt.maxMip + ".0" : "", lt.lightMap ? "#define USE_LIGHTMAP" : "", lt.aoMap ? "#define USE_AOMAP" : "", lt.bumpMap ? "#define USE_BUMPMAP" : "", lt.normalMap ? "#define USE_NORMALMAP" : "", lt.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", lt.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", lt.emissiveMap ? "#define USE_EMISSIVEMAP" : "", lt.anisotropy ? "#define USE_ANISOTROPY" : "", lt.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", lt.clearcoat ? "#define USE_CLEARCOAT" : "", lt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", lt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", lt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", lt.iridescence ? "#define USE_IRIDESCENCE" : "", lt.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", lt.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", lt.specularMap ? "#define USE_SPECULARMAP" : "", lt.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", lt.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", lt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", lt.metalnessMap ? "#define USE_METALNESSMAP" : "", lt.alphaMap ? "#define USE_ALPHAMAP" : "", lt.alphaTest ? "#define USE_ALPHATEST" : "", lt.alphaHash ? "#define USE_ALPHAHASH" : "", lt.sheen ? "#define USE_SHEEN" : "", lt.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", lt.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", lt.transmission ? "#define USE_TRANSMISSION" : "", lt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", lt.thicknessMap ? "#define USE_THICKNESSMAP" : "", lt.vertexTangents && lt.flatShading === !1 ? "#define USE_TANGENT" : "", lt.vertexColors || lt.instancingColor ? "#define USE_COLOR" : "", lt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", lt.vertexUv1s ? "#define USE_UV1" : "", lt.vertexUv2s ? "#define USE_UV2" : "", lt.vertexUv3s ? "#define USE_UV3" : "", lt.pointsUvs ? "#define USE_POINTS_UV" : "", lt.gradientMap ? "#define USE_GRADIENTMAP" : "", lt.flatShading ? "#define FLAT_SHADED" : "", lt.doubleSided ? "#define DOUBLE_SIDED" : "", lt.flipSided ? "#define FLIP_SIDED" : "", lt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", lt.shadowMapEnabled ? "#define " + Lt : "", lt.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", lt.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", lt.useLegacyLights ? "#define LEGACY_LIGHTS" : "", lt.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", lt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", lt.logarithmicDepthBuffer && lt.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", lt.toneMapping !== Ur ? "#define TONE_MAPPING" : "", lt.toneMapping !== Ur ? go.tonemapping_pars_fragment : "", lt.toneMapping !== Ur ? k1("toneMapping", lt.toneMapping) : "", lt.dithering ? "#define DITHERING" : "", lt.opaque ? "#define OPAQUE" : "", go.colorspace_pars_fragment, I1("linearToOutputTexel", lt.outputColorSpace), lt.transmissionSamplerMapEncoding ? R1("transmissionSamplerMapTexelToLinear", lt.transmissionSamplerMapEncoding) : "", lt.useDepthPacking ? "#define DEPTH_PACKING " + lt.depthPacking : "", `
`].filter(__).join(`
`)),
            Ct = z0(Ct),
            Ct = cx(Ct, lt),
            Ct = ux(Ct, lt),
            Mt = z0(Mt),
            Mt = cx(Mt, lt),
            Mt = ux(Mt, lt),
            Ct = dx(Ct),
            Mt = dx(Mt),
            lt.isWebGL2 && lt.isRawShaderMaterial !== !0 && (er = `#version 300 es
`,
            Yt = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + Yt,
            sr = ["#define varying in", lt.glslVersion === Ym ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", lt.glslVersion === Ym ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad", "#define WebGL2Context 1"].join(`
`) + `
` + sr);
            const rr = er + Yt + Ct
              , xr = er + sr + Mt
              , br = ax(ft, ft.VERTEX_SHADER, rr)
              , yr = ax(ft, ft.FRAGMENT_SHADER, xr);
            if (ft.attachShader(Zt, br),
            ft.attachShader(Zt, yr),
            lt.index0AttributeName !== void 0 ? ft.bindAttribLocation(Zt, 0, lt.index0AttributeName) : lt.morphTargets === !0 && ft.bindAttribLocation(Zt, 0, "position"),
            ft.linkProgram(Zt),
            Tt.debug.checkShaderErrors) {
                const Nr = ft.getProgramInfoLog(Zt).trim()
                  , Vr = ft.getShaderInfoLog(br).trim()
                  , Gr = ft.getShaderInfoLog(yr).trim();
                let Hr = !0
                  , _n = !0;
                if (ft.getProgramParameter(Zt, ft.LINK_STATUS) === !1)
                    if (Hr = !1,
                    typeof Tt.debug.onShaderError == "function")
                        Tt.debug.onShaderError(ft, Zt, br, yr);
                    else {
                        const dn = lx(ft, br, "vertex")
                          , kn = lx(ft, yr, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + ft.getError() + " - VALIDATE_STATUS " + ft.getProgramParameter(Zt, ft.VALIDATE_STATUS) + `

Program Info Log: ` + Nr + `
` + dn + `
` + kn)
                    }
                else
                    Nr !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Nr) : Vr !== "" && Gr !== "" || (_n = !1);
                _n && (this.diagnostics = {
                    runnable: Hr,
                    programLog: Nr,
                    vertexShader: {
                        log: Vr,
                        prefix: Yt
                    },
                    fragmentShader: {
                        log: Gr,
                        prefix: sr
                    }
                })
            }
            let Pr, zr;
            return ft.deleteShader(br),
            ft.deleteShader(yr),
            this.getUniforms = function() {
                return Pr === void 0 && (Pr = new Cv(ft,Zt)),
                Pr
            }
            ,
            this.getAttributes = function() {
                return zr === void 0 && (zr = function(Nr, Vr) {
                    const Gr = {}
                      , Hr = Nr.getProgramParameter(Vr, Nr.ACTIVE_ATTRIBUTES);
                    for (let _n = 0; _n < Hr; _n++) {
                        const dn = Nr.getActiveAttrib(Vr, _n)
                          , kn = dn.name;
                        let Bn = 1;
                        dn.type === Nr.FLOAT_MAT2 && (Bn = 2),
                        dn.type === Nr.FLOAT_MAT3 && (Bn = 3),
                        dn.type === Nr.FLOAT_MAT4 && (Bn = 4),
                        Gr[kn] = {
                            type: dn.type,
                            location: Nr.getAttribLocation(Vr, kn),
                            locationSize: Bn
                        }
                    }
                    return Gr
                }(ft, Zt)),
                zr
            }
            ,
            this.destroy = function() {
                mt.releaseStatesOfProgram(this),
                ft.deleteProgram(Zt),
                this.program = void 0
            }
            ,
            this.type = lt.shaderType,
            this.name = lt.shaderName,
            this.id = M1++,
            this.cacheKey = tt,
            this.usedTimes = 1,
            this.program = Zt,
            this.vertexShader = br,
            this.fragmentShader = yr,
            this
        }
        let U1 = 0;
        class j1 {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(tt) {
                const lt = tt.vertexShader
                  , mt = tt.fragmentShader
                  , ft = this._getShaderStage(lt)
                  , xt = this._getShaderStage(mt)
                  , Ct = this._getShaderCacheForMaterial(tt);
                return Ct.has(ft) === !1 && (Ct.add(ft),
                ft.usedTimes++),
                Ct.has(xt) === !1 && (Ct.add(xt),
                xt.usedTimes++),
                this
            }
            remove(tt) {
                const lt = this.materialCache.get(tt);
                for (const mt of lt)
                    mt.usedTimes--,
                    mt.usedTimes === 0 && this.shaderCache.delete(mt.code);
                return this.materialCache.delete(tt),
                this
            }
            getVertexShaderID(tt) {
                return this._getShaderStage(tt.vertexShader).id
            }
            getFragmentShaderID(tt) {
                return this._getShaderStage(tt.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(tt) {
                const lt = this.materialCache;
                let mt = lt.get(tt);
                return mt === void 0 && (mt = new Set,
                lt.set(tt, mt)),
                mt
            }
            _getShaderStage(tt) {
                const lt = this.shaderCache;
                let mt = lt.get(tt);
                return mt === void 0 && (mt = new V1(tt),
                lt.set(tt, mt)),
                mt
            }
        }
        class V1 {
            constructor(tt) {
                this.id = U1++,
                this.code = tt,
                this.usedTimes = 0
            }
        }
        function G1(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = new um
              , Lt = new j1
              , Nt = []
              , jt = ft.isWebGL2
              , Wt = ft.logarithmicDepthBuffer
              , Qt = ft.vertexTextures;
            let qt = ft.precision;
            const Xt = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function Zt(Yt) {
                return Yt === 0 ? "uv" : `uv${
Yt}`
            }
            return {
                getParameters: function(Yt, sr, er, rr, xr) {
                    const br = rr.fog
                      , yr = xr.geometry
                      , Pr = Yt.isMeshStandardMaterial ? rr.environment : null
                      , zr = (Yt.isMeshStandardMaterial ? lt : tt).get(Yt.envMap || Pr)
                      , Nr = zr && zr.mapping === Mn ? zr.image.height : null
                      , Vr = Xt[Yt.type];
                    Yt.precision !== null && (qt = ft.getMaxPrecision(Yt.precision),
                    qt !== Yt.precision && console.warn("THREE.WebGLProgram.getParameters:", Yt.precision, "not supported, using", qt, "instead."));
                    const Gr = yr.morphAttributes.position || yr.morphAttributes.normal || yr.morphAttributes.color
                      , Hr = Gr !== void 0 ? Gr.length : 0;
                    let _n, dn, kn, Bn, cn = 0;
                    if (yr.morphAttributes.position !== void 0 && (cn = 1),
                    yr.morphAttributes.normal !== void 0 && (cn = 2),
                    yr.morphAttributes.color !== void 0 && (cn = 3),
                    Vr) {
                        const F_ = qs[Vr];
                        _n = F_.vertexShader,
                        dn = F_.fragmentShader
                    } else
                        _n = Yt.vertexShader,
                        dn = Yt.fragmentShader,
                        Lt.update(Yt),
                        kn = Lt.getVertexShaderID(Yt),
                        Bn = Lt.getFragmentShaderID(Yt);
                    const Yr = Tt.getRenderTarget()
                      , Jr = Tt.userData && Tt.userData.transmissionRenderTarget
                      , sn = Yr ? Array.isArray(Yr.texture) ? Yr.texture[0] : Yr.texture : null
                      , on = xr.isInstancedMesh === !0
                      , Un = !!Yt.map
                      , ro = !!Yt.matcap
                      , Zn = !!zr
                      , jn = !!Yt.aoMap
                      , uo = !!Yt.lightMap
                      , Dr = !!Yt.bumpMap
                      , Sr = !!Yt.normalMap
                      , Fr = !!Yt.displacementMap
                      , Wr = !!Yt.emissiveMap
                      , kr = !!Yt.metalnessMap
                      , _r = !!Yt.roughnessMap
                      , Br = Yt.anisotropy > 0
                      , Lr = Yt.clearcoat > 0
                      , Xr = Yt.iridescence > 0
                      , Kr = Yt.sheen > 0
                      , An = Yt.transmission > 0
                      , pn = Br && !!Yt.anisotropyMap
                      , _o = Lr && !!Yt.clearcoatMap
                      , to = Lr && !!Yt.clearcoatNormalMap
                      , Pn = Lr && !!Yt.clearcoatRoughnessMap
                      , eo = Xr && !!Yt.iridescenceMap
                      , Kn = Xr && !!Yt.iridescenceThicknessMap
                      , po = Kr && !!Yt.sheenColorMap
                      , Ao = Kr && !!Yt.sheenRoughnessMap
                      , Fo = !!Yt.specularMap
                      , Io = !!Yt.specularColorMap
                      , Jn = !!Yt.specularIntensityMap
                      , Co = An && !!Yt.transmissionMap
                      , yl = An && !!Yt.thicknessMap
                      , ho = !!Yt.gradientMap
                      , Qo = !!Yt.alphaMap
                      , Po = Yt.alphaTest > 0
                      , Cu = !!Yt.alphaHash
                      , Pu = !!Yt.extensions
                      , en = !!yr.attributes.uv1
                      , g0 = !!yr.attributes.uv2
                      , _0 = !!yr.attributes.uv3;
                    let Bs = Ur;
                    return Yt.toneMapped && (Yr !== null && Yr.isXRRenderTarget !== !0 || (Bs = Tt.toneMapping)),
                    {
                        isWebGL2: jt,
                        shaderID: Vr,
                        shaderType: Yt.type,
                        shaderName: Yt.name,
                        vertexShader: _n,
                        fragmentShader: dn,
                        defines: Yt.defines,
                        customVertexShaderID: kn,
                        customFragmentShaderID: Bn,
                        isRawShaderMaterial: Yt.isRawShaderMaterial === !0,
                        glslVersion: Yt.glslVersion,
                        precision: qt,
                        instancing: on,
                        instancingColor: on && xr.instanceColor !== null,
                        supportsVertexTextures: Qt,
                        outputColorSpace: Yr === null ? Tt.outputColorSpace : Yr.isXRRenderTarget === !0 || sn.colorSpace && sn.colorSpace !== jo ? sn.colorSpace : Xo,
                        map: Un,
                        matcap: ro,
                        envMap: Zn,
                        envMapMode: Zn && zr.mapping,
                        envMapCubeUVHeight: Nr,
                        aoMap: jn,
                        lightMap: uo,
                        bumpMap: Dr,
                        normalMap: Sr,
                        displacementMap: Qt && Fr,
                        emissiveMap: Wr,
                        normalMapObjectSpace: Sr && Yt.normalMapType === Lu,
                        normalMapTangentSpace: Sr && Yt.normalMapType === El,
                        metalnessMap: kr,
                        roughnessMap: _r,
                        anisotropy: Br,
                        anisotropyMap: pn,
                        clearcoat: Lr,
                        clearcoatMap: _o,
                        clearcoatNormalMap: to,
                        clearcoatRoughnessMap: Pn,
                        iridescence: Xr,
                        iridescenceMap: eo,
                        iridescenceThicknessMap: Kn,
                        sheen: Kr,
                        sheenColorMap: po,
                        sheenRoughnessMap: Ao,
                        specularMap: Fo,
                        specularColorMap: Io,
                        specularIntensityMap: Jn,
                        transmission: An,
                        transmissionMap: Co,
                        thicknessMap: yl,
                        transmissionSamplerMapEncoding: Jr && Jr.texture.colorSpace || Xo,
                        gradientMap: ho,
                        opaque: Yt.transparent === !1 && Yt.blending === Pt && !(Yt.transmission > 0),
                        alphaMap: Qo,
                        alphaTest: Po,
                        alphaHash: Cu,
                        combine: Yt.combine,
                        mapUv: Un && Zt(Yt.map.channel),
                        aoMapUv: jn && Zt(Yt.aoMap.channel),
                        lightMapUv: uo && Zt(Yt.lightMap.channel),
                        bumpMapUv: Dr && Zt(Yt.bumpMap.channel),
                        normalMapUv: Sr && Zt(Yt.normalMap.channel),
                        displacementMapUv: Fr && Zt(Yt.displacementMap.channel),
                        emissiveMapUv: Wr && Zt(Yt.emissiveMap.channel),
                        metalnessMapUv: kr && Zt(Yt.metalnessMap.channel),
                        roughnessMapUv: _r && Zt(Yt.roughnessMap.channel),
                        anisotropyMapUv: pn && Zt(Yt.anisotropyMap.channel),
                        clearcoatMapUv: _o && Zt(Yt.clearcoatMap.channel),
                        clearcoatNormalMapUv: to && Zt(Yt.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: Pn && Zt(Yt.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: eo && Zt(Yt.iridescenceMap.channel),
                        iridescenceThicknessMapUv: Kn && Zt(Yt.iridescenceThicknessMap.channel),
                        sheenColorMapUv: po && Zt(Yt.sheenColorMap.channel),
                        sheenRoughnessMapUv: Ao && Zt(Yt.sheenRoughnessMap.channel),
                        specularMapUv: Fo && Zt(Yt.specularMap.channel),
                        specularColorMapUv: Io && Zt(Yt.specularColorMap.channel),
                        specularIntensityMapUv: Jn && Zt(Yt.specularIntensityMap.channel),
                        transmissionMapUv: Co && Zt(Yt.transmissionMap.channel),
                        thicknessMapUv: yl && Zt(Yt.thicknessMap.channel),
                        alphaMapUv: Qo && Zt(Yt.alphaMap.channel),
                        vertexTangents: !!yr.attributes.tangent && (Sr || Br || yr.userData.__forceUseTangent),
                        vertexColors: Yt.vertexColors,
                        vertexAlphas: Yt.vertexColors === !0 && !!yr.attributes.color && yr.attributes.color.itemSize === 4,
                        vertexUv1s: en,
                        vertexUv2s: g0,
                        vertexUv3s: _0,
                        pointsUvs: xr.isPoints === !0 && !!yr.attributes.uv && (Un || Qo),
                        fog: !!br,
                        useFog: Yt.fog === !0,
                        fogExp2: br && br.isFogExp2,
                        flatShading: Yt.flatShading === !0,
                        sizeAttenuation: Yt.sizeAttenuation === !0,
                        logarithmicDepthBuffer: Wt,
                        skinning: xr.isSkinnedMesh === !0,
                        morphTargets: yr.morphAttributes.position !== void 0,
                        morphNormals: yr.morphAttributes.normal !== void 0,
                        morphColors: yr.morphAttributes.color !== void 0,
                        morphTargetsCount: Hr,
                        morphTextureStride: cn,
                        numDirLights: sr.directional.length,
                        numPointLights: sr.point.length,
                        numSpotLights: sr.spot.length,
                        numSpotLightMaps: sr.spotLightMap.length,
                        numRectAreaLights: sr.rectArea.length,
                        numHemiLights: sr.hemi.length,
                        numDirLightShadows: sr.directionalShadowMap.length,
                        numPointLightShadows: sr.pointShadowMap.length,
                        numSpotLightShadows: sr.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: sr.numSpotLightShadowsWithMaps,
                        numLightProbes: sr.numLightProbes,
                        numClippingPlanes: Ct.numPlanes,
                        numClipIntersection: Ct.numIntersection,
                        dithering: Yt.dithering,
                        shadowMapEnabled: Tt.shadowMap.enabled && er.length > 0,
                        shadowMapType: Tt.shadowMap.type,
                        toneMapping: Bs,
                        useLegacyLights: Tt._useLegacyLights,
                        decodeVideoTexture: Un && Yt.map.isVideoTexture === !0 && Do.getTransfer(Yt.map.colorSpace) === Vo,
                        premultipliedAlpha: Yt.premultipliedAlpha,
                        doubleSided: Yt.side === St,
                        flipSided: Yt.side === bt,
                        useDepthPacking: Yt.depthPacking >= 0,
                        depthPacking: Yt.depthPacking || 0,
                        index0AttributeName: Yt.index0AttributeName,
                        extensionDerivatives: Pu && Yt.extensions.derivatives === !0,
                        extensionFragDepth: Pu && Yt.extensions.fragDepth === !0,
                        extensionDrawBuffers: Pu && Yt.extensions.drawBuffers === !0,
                        extensionShaderTextureLOD: Pu && Yt.extensions.shaderTextureLOD === !0,
                        rendererExtensionFragDepth: jt || mt.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: jt || mt.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: jt || mt.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: Yt.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(Yt) {
                    const sr = [];
                    if (Yt.shaderID ? sr.push(Yt.shaderID) : (sr.push(Yt.customVertexShaderID),
                    sr.push(Yt.customFragmentShaderID)),
                    Yt.defines !== void 0)
                        for (const er in Yt.defines)
                            sr.push(er),
                            sr.push(Yt.defines[er]);
                    return Yt.isRawShaderMaterial === !1 && (function(er, rr) {
                        er.push(rr.precision),
                        er.push(rr.outputColorSpace),
                        er.push(rr.envMapMode),
                        er.push(rr.envMapCubeUVHeight),
                        er.push(rr.mapUv),
                        er.push(rr.alphaMapUv),
                        er.push(rr.lightMapUv),
                        er.push(rr.aoMapUv),
                        er.push(rr.bumpMapUv),
                        er.push(rr.normalMapUv),
                        er.push(rr.displacementMapUv),
                        er.push(rr.emissiveMapUv),
                        er.push(rr.metalnessMapUv),
                        er.push(rr.roughnessMapUv),
                        er.push(rr.anisotropyMapUv),
                        er.push(rr.clearcoatMapUv),
                        er.push(rr.clearcoatNormalMapUv),
                        er.push(rr.clearcoatRoughnessMapUv),
                        er.push(rr.iridescenceMapUv),
                        er.push(rr.iridescenceThicknessMapUv),
                        er.push(rr.sheenColorMapUv),
                        er.push(rr.sheenRoughnessMapUv),
                        er.push(rr.specularMapUv),
                        er.push(rr.specularColorMapUv),
                        er.push(rr.specularIntensityMapUv),
                        er.push(rr.transmissionMapUv),
                        er.push(rr.thicknessMapUv),
                        er.push(rr.combine),
                        er.push(rr.fogExp2),
                        er.push(rr.sizeAttenuation),
                        er.push(rr.morphTargetsCount),
                        er.push(rr.morphAttributeCount),
                        er.push(rr.numDirLights),
                        er.push(rr.numPointLights),
                        er.push(rr.numSpotLights),
                        er.push(rr.numSpotLightMaps),
                        er.push(rr.numHemiLights),
                        er.push(rr.numRectAreaLights),
                        er.push(rr.numDirLightShadows),
                        er.push(rr.numPointLightShadows),
                        er.push(rr.numSpotLightShadows),
                        er.push(rr.numSpotLightShadowsWithMaps),
                        er.push(rr.numLightProbes),
                        er.push(rr.shadowMapType),
                        er.push(rr.toneMapping),
                        er.push(rr.numClippingPlanes),
                        er.push(rr.numClipIntersection),
                        er.push(rr.depthPacking)
                    }(sr, Yt),
                    function(er, rr) {
                        Mt.disableAll(),
                        rr.isWebGL2 && Mt.enable(0),
                        rr.supportsVertexTextures && Mt.enable(1),
                        rr.instancing && Mt.enable(2),
                        rr.instancingColor && Mt.enable(3),
                        rr.matcap && Mt.enable(4),
                        rr.envMap && Mt.enable(5),
                        rr.normalMapObjectSpace && Mt.enable(6),
                        rr.normalMapTangentSpace && Mt.enable(7),
                        rr.clearcoat && Mt.enable(8),
                        rr.iridescence && Mt.enable(9),
                        rr.alphaTest && Mt.enable(10),
                        rr.vertexColors && Mt.enable(11),
                        rr.vertexAlphas && Mt.enable(12),
                        rr.vertexUv1s && Mt.enable(13),
                        rr.vertexUv2s && Mt.enable(14),
                        rr.vertexUv3s && Mt.enable(15),
                        rr.vertexTangents && Mt.enable(16),
                        rr.anisotropy && Mt.enable(17),
                        er.push(Mt.mask),
                        Mt.disableAll(),
                        rr.fog && Mt.enable(0),
                        rr.useFog && Mt.enable(1),
                        rr.flatShading && Mt.enable(2),
                        rr.logarithmicDepthBuffer && Mt.enable(3),
                        rr.skinning && Mt.enable(4),
                        rr.morphTargets && Mt.enable(5),
                        rr.morphNormals && Mt.enable(6),
                        rr.morphColors && Mt.enable(7),
                        rr.premultipliedAlpha && Mt.enable(8),
                        rr.shadowMapEnabled && Mt.enable(9),
                        rr.useLegacyLights && Mt.enable(10),
                        rr.doubleSided && Mt.enable(11),
                        rr.flipSided && Mt.enable(12),
                        rr.useDepthPacking && Mt.enable(13),
                        rr.dithering && Mt.enable(14),
                        rr.transmission && Mt.enable(15),
                        rr.sheen && Mt.enable(16),
                        rr.opaque && Mt.enable(17),
                        rr.pointsUvs && Mt.enable(18),
                        rr.decodeVideoTexture && Mt.enable(19),
                        er.push(Mt.mask)
                    }(sr, Yt),
                    sr.push(Tt.outputColorSpace)),
                    sr.push(Yt.customProgramCacheKey),
                    sr.join()
                },
                getUniforms: function(Yt) {
                    const sr = Xt[Yt.type];
                    let er;
                    if (sr) {
                        const rr = qs[sr];
                        er = Vy.clone(rr.uniforms)
                    } else
                        er = Yt.uniforms;
                    return er
                },
                acquireProgram: function(Yt, sr) {
                    let er;
                    for (let rr = 0, xr = Nt.length; rr < xr; rr++) {
                        const br = Nt[rr];
                        if (br.cacheKey === sr) {
                            er = br,
                            ++er.usedTimes;
                            break
                        }
                    }
                    return er === void 0 && (er = new F1(Tt,sr,Yt,xt),
                    Nt.push(er)),
                    er
                },
                releaseProgram: function(Yt) {
                    if (--Yt.usedTimes == 0) {
                        const sr = Nt.indexOf(Yt);
                        Nt[sr] = Nt[Nt.length - 1],
                        Nt.pop(),
                        Yt.destroy()
                    }
                },
                releaseShaderCache: function(Yt) {
                    Lt.remove(Yt)
                },
                programs: Nt,
                dispose: function() {
                    Lt.dispose()
                }
            }
        }
        function z1() {
            let Tt = new WeakMap;
            return {
                get: function(tt) {
                    let lt = Tt.get(tt);
                    return lt === void 0 && (lt = {},
                    Tt.set(tt, lt)),
                    lt
                },
                remove: function(tt) {
                    Tt.delete(tt)
                },
                update: function(tt, lt, mt) {
                    Tt.get(tt)[lt] = mt
                },
                dispose: function() {
                    Tt = new WeakMap
                }
            }
        }
        function H1(Tt, tt) {
            return Tt.groupOrder !== tt.groupOrder ? Tt.groupOrder - tt.groupOrder : Tt.renderOrder !== tt.renderOrder ? Tt.renderOrder - tt.renderOrder : Tt.material.id !== tt.material.id ? Tt.material.id - tt.material.id : Tt.z !== tt.z ? Tt.z - tt.z : Tt.id - tt.id
        }
        function mx(Tt, tt) {
            return Tt.groupOrder !== tt.groupOrder ? Tt.groupOrder - tt.groupOrder : Tt.renderOrder !== tt.renderOrder ? Tt.renderOrder - tt.renderOrder : Tt.z !== tt.z ? tt.z - Tt.z : Tt.id - tt.id
        }
        function fx() {
            const Tt = [];
            let tt = 0;
            const lt = []
              , mt = []
              , ft = [];
            function xt(Ct, Mt, Lt, Nt, jt, Wt) {
                let Qt = Tt[tt];
                return Qt === void 0 ? (Qt = {
                    id: Ct.id,
                    object: Ct,
                    geometry: Mt,
                    material: Lt,
                    groupOrder: Nt,
                    renderOrder: Ct.renderOrder,
                    z: jt,
                    group: Wt
                },
                Tt[tt] = Qt) : (Qt.id = Ct.id,
                Qt.object = Ct,
                Qt.geometry = Mt,
                Qt.material = Lt,
                Qt.groupOrder = Nt,
                Qt.renderOrder = Ct.renderOrder,
                Qt.z = jt,
                Qt.group = Wt),
                tt++,
                Qt
            }
            return {
                opaque: lt,
                transmissive: mt,
                transparent: ft,
                init: function() {
                    tt = 0,
                    lt.length = 0,
                    mt.length = 0,
                    ft.length = 0
                },
                push: function(Ct, Mt, Lt, Nt, jt, Wt) {
                    const Qt = xt(Ct, Mt, Lt, Nt, jt, Wt);
                    Lt.transmission > 0 ? mt.push(Qt) : Lt.transparent === !0 ? ft.push(Qt) : lt.push(Qt)
                },
                unshift: function(Ct, Mt, Lt, Nt, jt, Wt) {
                    const Qt = xt(Ct, Mt, Lt, Nt, jt, Wt);
                    Lt.transmission > 0 ? mt.unshift(Qt) : Lt.transparent === !0 ? ft.unshift(Qt) : lt.unshift(Qt)
                },
                finish: function() {
                    for (let Ct = tt, Mt = Tt.length; Ct < Mt; Ct++) {
                        const Lt = Tt[Ct];
                        if (Lt.id === null)
                            break;
                        Lt.id = null,
                        Lt.object = null,
                        Lt.geometry = null,
                        Lt.material = null,
                        Lt.group = null
                    }
                },
                sort: function(Ct, Mt) {
                    lt.length > 1 && lt.sort(Ct || H1),
                    mt.length > 1 && mt.sort(Mt || mx),
                    ft.length > 1 && ft.sort(Mt || mx)
                }
            }
        }
        function Q1() {
            let Tt = new WeakMap;
            return {
                get: function(tt, lt) {
                    const mt = Tt.get(tt);
                    let ft;
                    return mt === void 0 ? (ft = new fx,
                    Tt.set(tt, [ft])) : lt >= mt.length ? (ft = new fx,
                    mt.push(ft)) : ft = mt[lt],
                    ft
                },
                dispose: function() {
                    Tt = new WeakMap
                }
            }
        }
        function W1() {
            const Tt = {};
            return {
                get: function(tt) {
                    if (Tt[tt.id] !== void 0)
                        return Tt[tt.id];
                    let lt;
                    switch (tt.type) {
                    case "DirectionalLight":
                        lt = {
                            direction: new Er,
                            color: new Gn
                        };
                        break;
                    case "SpotLight":
                        lt = {
                            position: new Er,
                            direction: new Er,
                            color: new Gn,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        lt = {
                            position: new Er,
                            color: new Gn,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        lt = {
                            direction: new Er,
                            skyColor: new Gn,
                            groundColor: new Gn
                        };
                        break;
                    case "RectAreaLight":
                        lt = {
                            color: new Gn,
                            position: new Er,
                            halfWidth: new Er,
                            halfHeight: new Er
                        }
                    }
                    return Tt[tt.id] = lt,
                    lt
                }
            }
        }
        let q1 = 0;
        function $1(Tt, tt) {
            return (tt.castShadow ? 2 : 0) - (Tt.castShadow ? 2 : 0) + (tt.map ? 1 : 0) - (Tt.map ? 1 : 0)
        }
        function X1(Tt, tt) {
            const lt = new W1
              , mt = function() {
                const Lt = {};
                return {
                    get: function(Nt) {
                        if (Lt[Nt.id] !== void 0)
                            return Lt[Nt.id];
                        let jt;
                        switch (Nt.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            jt = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new mn
                            };
                            break;
                        case "PointLight":
                            jt = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new mn,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return Lt[Nt.id] = jt,
                        jt
                    }
                }
            }()
              , ft = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let Lt = 0; Lt < 9; Lt++)
                ft.probe.push(new Er);
            const xt = new Er
              , Ct = new no
              , Mt = new no;
            return {
                setup: function(Lt, Nt) {
                    let jt = 0
                      , Wt = 0
                      , Qt = 0;
                    for (let Vr = 0; Vr < 9; Vr++)
                        ft.probe[Vr].set(0, 0, 0);
                    let qt = 0
                      , Xt = 0
                      , Zt = 0
                      , Yt = 0
                      , sr = 0
                      , er = 0
                      , rr = 0
                      , xr = 0
                      , br = 0
                      , yr = 0
                      , Pr = 0;
                    Lt.sort($1);
                    const zr = Nt === !0 ? Math.PI : 1;
                    for (let Vr = 0, Gr = Lt.length; Vr < Gr; Vr++) {
                        const Hr = Lt[Vr]
                          , _n = Hr.color
                          , dn = Hr.intensity
                          , kn = Hr.distance
                          , Bn = Hr.shadow && Hr.shadow.map ? Hr.shadow.map.texture : null;
                        if (Hr.isAmbientLight)
                            jt += _n.r * dn * zr,
                            Wt += _n.g * dn * zr,
                            Qt += _n.b * dn * zr;
                        else if (Hr.isLightProbe) {
                            for (let cn = 0; cn < 9; cn++)
                                ft.probe[cn].addScaledVector(Hr.sh.coefficients[cn], dn);
                            Pr++
                        } else if (Hr.isDirectionalLight) {
                            const cn = lt.get(Hr);
                            if (cn.color.copy(Hr.color).multiplyScalar(Hr.intensity * zr),
                            Hr.castShadow) {
                                const Yr = Hr.shadow
                                  , Jr = mt.get(Hr);
                                Jr.shadowBias = Yr.bias,
                                Jr.shadowNormalBias = Yr.normalBias,
                                Jr.shadowRadius = Yr.radius,
                                Jr.shadowMapSize = Yr.mapSize,
                                ft.directionalShadow[qt] = Jr,
                                ft.directionalShadowMap[qt] = Bn,
                                ft.directionalShadowMatrix[qt] = Hr.shadow.matrix,
                                er++
                            }
                            ft.directional[qt] = cn,
                            qt++
                        } else if (Hr.isSpotLight) {
                            const cn = lt.get(Hr);
                            cn.position.setFromMatrixPosition(Hr.matrixWorld),
                            cn.color.copy(_n).multiplyScalar(dn * zr),
                            cn.distance = kn,
                            cn.coneCos = Math.cos(Hr.angle),
                            cn.penumbraCos = Math.cos(Hr.angle * (1 - Hr.penumbra)),
                            cn.decay = Hr.decay,
                            ft.spot[Zt] = cn;
                            const Yr = Hr.shadow;
                            if (Hr.map && (ft.spotLightMap[br] = Hr.map,
                            br++,
                            Yr.updateMatrices(Hr),
                            Hr.castShadow && yr++),
                            ft.spotLightMatrix[Zt] = Yr.matrix,
                            Hr.castShadow) {
                                const Jr = mt.get(Hr);
                                Jr.shadowBias = Yr.bias,
                                Jr.shadowNormalBias = Yr.normalBias,
                                Jr.shadowRadius = Yr.radius,
                                Jr.shadowMapSize = Yr.mapSize,
                                ft.spotShadow[Zt] = Jr,
                                ft.spotShadowMap[Zt] = Bn,
                                xr++
                            }
                            Zt++
                        } else if (Hr.isRectAreaLight) {
                            const cn = lt.get(Hr);
                            cn.color.copy(_n).multiplyScalar(dn),
                            cn.halfWidth.set(.5 * Hr.width, 0, 0),
                            cn.halfHeight.set(0, .5 * Hr.height, 0),
                            ft.rectArea[Yt] = cn,
                            Yt++
                        } else if (Hr.isPointLight) {
                            const cn = lt.get(Hr);
                            if (cn.color.copy(Hr.color).multiplyScalar(Hr.intensity * zr),
                            cn.distance = Hr.distance,
                            cn.decay = Hr.decay,
                            Hr.castShadow) {
                                const Yr = Hr.shadow
                                  , Jr = mt.get(Hr);
                                Jr.shadowBias = Yr.bias,
                                Jr.shadowNormalBias = Yr.normalBias,
                                Jr.shadowRadius = Yr.radius,
                                Jr.shadowMapSize = Yr.mapSize,
                                Jr.shadowCameraNear = Yr.camera.near,
                                Jr.shadowCameraFar = Yr.camera.far,
                                ft.pointShadow[Xt] = Jr,
                                ft.pointShadowMap[Xt] = Bn,
                                ft.pointShadowMatrix[Xt] = Hr.shadow.matrix,
                                rr++
                            }
                            ft.point[Xt] = cn,
                            Xt++
                        } else if (Hr.isHemisphereLight) {
                            const cn = lt.get(Hr);
                            cn.skyColor.copy(Hr.color).multiplyScalar(dn * zr),
                            cn.groundColor.copy(Hr.groundColor).multiplyScalar(dn * zr),
                            ft.hemi[sr] = cn,
                            sr++
                        }
                    }
                    Yt > 0 && (tt.isWebGL2 || Tt.has("OES_texture_float_linear") === !0 ? (ft.rectAreaLTC1 = Dn.LTC_FLOAT_1,
                    ft.rectAreaLTC2 = Dn.LTC_FLOAT_2) : Tt.has("OES_texture_half_float_linear") === !0 ? (ft.rectAreaLTC1 = Dn.LTC_HALF_1,
                    ft.rectAreaLTC2 = Dn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    ft.ambient[0] = jt,
                    ft.ambient[1] = Wt,
                    ft.ambient[2] = Qt;
                    const Nr = ft.hash;
                    Nr.directionalLength === qt && Nr.pointLength === Xt && Nr.spotLength === Zt && Nr.rectAreaLength === Yt && Nr.hemiLength === sr && Nr.numDirectionalShadows === er && Nr.numPointShadows === rr && Nr.numSpotShadows === xr && Nr.numSpotMaps === br && Nr.numLightProbes === Pr || (ft.directional.length = qt,
                    ft.spot.length = Zt,
                    ft.rectArea.length = Yt,
                    ft.point.length = Xt,
                    ft.hemi.length = sr,
                    ft.directionalShadow.length = er,
                    ft.directionalShadowMap.length = er,
                    ft.pointShadow.length = rr,
                    ft.pointShadowMap.length = rr,
                    ft.spotShadow.length = xr,
                    ft.spotShadowMap.length = xr,
                    ft.directionalShadowMatrix.length = er,
                    ft.pointShadowMatrix.length = rr,
                    ft.spotLightMatrix.length = xr + br - yr,
                    ft.spotLightMap.length = br,
                    ft.numSpotLightShadowsWithMaps = yr,
                    ft.numLightProbes = Pr,
                    Nr.directionalLength = qt,
                    Nr.pointLength = Xt,
                    Nr.spotLength = Zt,
                    Nr.rectAreaLength = Yt,
                    Nr.hemiLength = sr,
                    Nr.numDirectionalShadows = er,
                    Nr.numPointShadows = rr,
                    Nr.numSpotShadows = xr,
                    Nr.numSpotMaps = br,
                    Nr.numLightProbes = Pr,
                    ft.version = q1++)
                },
                setupView: function(Lt, Nt) {
                    let jt = 0
                      , Wt = 0
                      , Qt = 0
                      , qt = 0
                      , Xt = 0;
                    const Zt = Nt.matrixWorldInverse;
                    for (let Yt = 0, sr = Lt.length; Yt < sr; Yt++) {
                        const er = Lt[Yt];
                        if (er.isDirectionalLight) {
                            const rr = ft.directional[jt];
                            rr.direction.setFromMatrixPosition(er.matrixWorld),
                            xt.setFromMatrixPosition(er.target.matrixWorld),
                            rr.direction.sub(xt),
                            rr.direction.transformDirection(Zt),
                            jt++
                        } else if (er.isSpotLight) {
                            const rr = ft.spot[Qt];
                            rr.position.setFromMatrixPosition(er.matrixWorld),
                            rr.position.applyMatrix4(Zt),
                            rr.direction.setFromMatrixPosition(er.matrixWorld),
                            xt.setFromMatrixPosition(er.target.matrixWorld),
                            rr.direction.sub(xt),
                            rr.direction.transformDirection(Zt),
                            Qt++
                        } else if (er.isRectAreaLight) {
                            const rr = ft.rectArea[qt];
                            rr.position.setFromMatrixPosition(er.matrixWorld),
                            rr.position.applyMatrix4(Zt),
                            Mt.identity(),
                            Ct.copy(er.matrixWorld),
                            Ct.premultiply(Zt),
                            Mt.extractRotation(Ct),
                            rr.halfWidth.set(.5 * er.width, 0, 0),
                            rr.halfHeight.set(0, .5 * er.height, 0),
                            rr.halfWidth.applyMatrix4(Mt),
                            rr.halfHeight.applyMatrix4(Mt),
                            qt++
                        } else if (er.isPointLight) {
                            const rr = ft.point[Wt];
                            rr.position.setFromMatrixPosition(er.matrixWorld),
                            rr.position.applyMatrix4(Zt),
                            Wt++
                        } else if (er.isHemisphereLight) {
                            const rr = ft.hemi[Xt];
                            rr.direction.setFromMatrixPosition(er.matrixWorld),
                            rr.direction.transformDirection(Zt),
                            Xt++
                        }
                    }
                },
                state: ft
            }
        }
        function gx(Tt, tt) {
            const lt = new X1(Tt,tt)
              , mt = []
              , ft = [];
            return {
                init: function() {
                    mt.length = 0,
                    ft.length = 0
                },
                state: {
                    lightsArray: mt,
                    shadowsArray: ft,
                    lights: lt
                },
                setupLights: function(xt) {
                    lt.setup(mt, xt)
                },
                setupLightsView: function(xt) {
                    lt.setupView(mt, xt)
                },
                pushLight: function(xt) {
                    mt.push(xt)
                },
                pushShadow: function(xt) {
                    ft.push(xt)
                }
            }
        }
        function Y1(Tt, tt) {
            let lt = new WeakMap;
            return {
                get: function(mt, ft=0) {
                    const xt = lt.get(mt);
                    let Ct;
                    return xt === void 0 ? (Ct = new gx(Tt,tt),
                    lt.set(mt, [Ct])) : ft >= xt.length ? (Ct = new gx(Tt,tt),
                    xt.push(Ct)) : Ct = xt[ft],
                    Ct
                },
                dispose: function() {
                    lt = new WeakMap
                }
            }
        }
        class H0 extends hs {
            constructor(tt) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = up,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.depthPacking = tt.depthPacking,
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this
            }
        }
        class Q0 extends hs {
            constructor(tt) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this
            }
        }
        function K1(Tt, tt, lt) {
            let mt = new Av;
            const ft = new mn
              , xt = new mn
              , Ct = new Lo
              , Mt = new H0({
                depthPacking: Qm
            })
              , Lt = new Q0
              , Nt = {}
              , jt = lt.maxTextureSize
              , Wt = {
                [vt]: bt,
                [bt]: vt,
                [St]: St
            }
              , Qt = new zl({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new mn
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
                fragmentShader: `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
            })
              , qt = Qt.clone();
            qt.defines.HORIZONTAL_PASS = 1;
            const Xt = new bo;
            Xt.setAttribute("position", new mr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const Zt = new gs(Xt,Qt)
              , Yt = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = pt;
            let sr = this.type;
            function er(br, yr) {
                const Pr = tt.update(Zt);
                Qt.defines.VSM_SAMPLES !== br.blurSamples && (Qt.defines.VSM_SAMPLES = br.blurSamples,
                qt.defines.VSM_SAMPLES = br.blurSamples,
                Qt.needsUpdate = !0,
                qt.needsUpdate = !0),
                br.mapPass === null && (br.mapPass = new Rs(ft.x,ft.y)),
                Qt.uniforms.shadow_pass.value = br.map.texture,
                Qt.uniforms.resolution.value = br.mapSize,
                Qt.uniforms.radius.value = br.radius,
                Tt.setRenderTarget(br.mapPass),
                Tt.clear(),
                Tt.renderBufferDirect(yr, null, Pr, Qt, Zt, null),
                qt.uniforms.shadow_pass.value = br.mapPass.texture,
                qt.uniforms.resolution.value = br.mapSize,
                qt.uniforms.radius.value = br.radius,
                Tt.setRenderTarget(br.map),
                Tt.clear(),
                Tt.renderBufferDirect(yr, null, Pr, qt, Zt, null)
            }
            function rr(br, yr, Pr, zr) {
                let Nr = null;
                const Vr = Pr.isPointLight === !0 ? br.customDistanceMaterial : br.customDepthMaterial;
                if (Vr !== void 0)
                    Nr = Vr;
                else if (Nr = Pr.isPointLight === !0 ? Lt : Mt,
                Tt.localClippingEnabled && yr.clipShadows === !0 && Array.isArray(yr.clippingPlanes) && yr.clippingPlanes.length !== 0 || yr.displacementMap && yr.displacementScale !== 0 || yr.alphaMap && yr.alphaTest > 0 || yr.map && yr.alphaTest > 0) {
                    const Gr = Nr.uuid
                      , Hr = yr.uuid;
                    let _n = Nt[Gr];
                    _n === void 0 && (_n = {},
                    Nt[Gr] = _n);
                    let dn = _n[Hr];
                    dn === void 0 && (dn = Nr.clone(),
                    _n[Hr] = dn),
                    Nr = dn
                }
                return Nr.visible = yr.visible,
                Nr.wireframe = yr.wireframe,
                Nr.side = zr === _t ? yr.shadowSide !== null ? yr.shadowSide : yr.side : yr.shadowSide !== null ? yr.shadowSide : Wt[yr.side],
                Nr.alphaMap = yr.alphaMap,
                Nr.alphaTest = yr.alphaTest,
                Nr.map = yr.map,
                Nr.clipShadows = yr.clipShadows,
                Nr.clippingPlanes = yr.clippingPlanes,
                Nr.clipIntersection = yr.clipIntersection,
                Nr.displacementMap = yr.displacementMap,
                Nr.displacementScale = yr.displacementScale,
                Nr.displacementBias = yr.displacementBias,
                Nr.wireframeLinewidth = yr.wireframeLinewidth,
                Nr.linewidth = yr.linewidth,
                Pr.isPointLight === !0 && Nr.isMeshDistanceMaterial === !0 && (Tt.properties.get(Nr).light = Pr),
                Nr
            }
            function xr(br, yr, Pr, zr, Nr) {
                if (br.visible === !1)
                    return;
                if (br.layers.test(yr.layers) && (br.isMesh || br.isLine || br.isPoints) && (br.castShadow || br.receiveShadow && Nr === _t) && (!br.frustumCulled || mt.intersectsObject(br))) {
                    br.modelViewMatrix.multiplyMatrices(Pr.matrixWorldInverse, br.matrixWorld);
                    const Gr = tt.update(br)
                      , Hr = br.material;
                    if (Array.isArray(Hr)) {
                        const _n = Gr.groups;
                        for (let dn = 0, kn = _n.length; dn < kn; dn++) {
                            const Bn = _n[dn]
                              , cn = Hr[Bn.materialIndex];
                            if (cn && cn.visible) {
                                const Yr = rr(br, cn, zr, Nr);
                                Tt.renderBufferDirect(Pr, null, Gr, Yr, br, Bn)
                            }
                        }
                    } else if (Hr.visible) {
                        const _n = rr(br, Hr, zr, Nr);
                        Tt.renderBufferDirect(Pr, null, Gr, _n, br, null)
                    }
                }
                const Vr = br.children;
                for (let Gr = 0, Hr = Vr.length; Gr < Hr; Gr++)
                    xr(Vr[Gr], yr, Pr, zr, Nr)
            }
            this.render = function(br, yr, Pr) {
                if (Yt.enabled === !1 || Yt.autoUpdate === !1 && Yt.needsUpdate === !1 || br.length === 0)
                    return;
                const zr = Tt.getRenderTarget()
                  , Nr = Tt.getActiveCubeFace()
                  , Vr = Tt.getActiveMipmapLevel()
                  , Gr = Tt.state;
                Gr.setBlending(Et),
                Gr.buffers.color.setClear(1, 1, 1, 1),
                Gr.buffers.depth.setTest(!0),
                Gr.setScissorTest(!1);
                const Hr = sr !== _t && this.type === _t
                  , _n = sr === _t && this.type !== _t;
                for (let dn = 0, kn = br.length; dn < kn; dn++) {
                    const Bn = br[dn]
                      , cn = Bn.shadow;
                    if (cn === void 0) {
                        console.warn("THREE.WebGLShadowMap:", Bn, "has no shadow.");
                        continue
                    }
                    if (cn.autoUpdate === !1 && cn.needsUpdate === !1)
                        continue;
                    ft.copy(cn.mapSize);
                    const Yr = cn.getFrameExtents();
                    if (ft.multiply(Yr),
                    xt.copy(cn.mapSize),
                    (ft.x > jt || ft.y > jt) && (ft.x > jt && (xt.x = Math.floor(jt / Yr.x),
                    ft.x = xt.x * Yr.x,
                    cn.mapSize.x = xt.x),
                    ft.y > jt && (xt.y = Math.floor(jt / Yr.y),
                    ft.y = xt.y * Yr.y,
                    cn.mapSize.y = xt.y)),
                    cn.map === null || Hr === !0 || _n === !0) {
                        const sn = this.type !== _t ? {
                            minFilter: fn,
                            magFilter: fn
                        } : {};
                        cn.map !== null && cn.map.dispose(),
                        cn.map = new Rs(ft.x,ft.y,sn),
                        cn.map.texture.name = Bn.name + ".shadowMap",
                        cn.camera.updateProjectionMatrix()
                    }
                    Tt.setRenderTarget(cn.map),
                    Tt.clear();
                    const Jr = cn.getViewportCount();
                    for (let sn = 0; sn < Jr; sn++) {
                        const on = cn.getViewport(sn);
                        Ct.set(xt.x * on.x, xt.y * on.y, xt.x * on.z, xt.y * on.w),
                        Gr.viewport(Ct),
                        cn.updateMatrices(Bn, sn),
                        mt = cn.getFrustum(),
                        xr(yr, Pr, cn.camera, Bn, this.type)
                    }
                    cn.isPointLightShadow !== !0 && this.type === _t && er(cn, Pr),
                    cn.needsUpdate = !1
                }
                sr = this.type,
                Yt.needsUpdate = !1,
                Tt.setRenderTarget(zr, Nr, Vr)
            }
        }
        function J1(Tt, tt, lt) {
            const mt = lt.isWebGL2
              , ft = new function() {
                let _r = !1;
                const Br = new Lo;
                let Lr = null;
                const Xr = new Lo(0,0,0,0);
                return {
                    setMask: function(Kr) {
                        Lr === Kr || _r || (Tt.colorMask(Kr, Kr, Kr, Kr),
                        Lr = Kr)
                    },
                    setLocked: function(Kr) {
                        _r = Kr
                    },
                    setClear: function(Kr, An, pn, _o, to) {
                        to === !0 && (Kr *= _o,
                        An *= _o,
                        pn *= _o),
                        Br.set(Kr, An, pn, _o),
                        Xr.equals(Br) === !1 && (Tt.clearColor(Kr, An, pn, _o),
                        Xr.copy(Br))
                    },
                    reset: function() {
                        _r = !1,
                        Lr = null,
                        Xr.set(-1, 0, 0, 0)
                    }
                }
            }
              , xt = new function() {
                let _r = !1
                  , Br = null
                  , Lr = null
                  , Xr = null;
                return {
                    setTest: function(Kr) {
                        Kr ? Zn(Tt.DEPTH_TEST) : jn(Tt.DEPTH_TEST)
                    },
                    setMask: function(Kr) {
                        Br === Kr || _r || (Tt.depthMask(Kr),
                        Br = Kr)
                    },
                    setFunc: function(Kr) {
                        if (Lr !== Kr) {
                            switch (Kr) {
                            case Cr:
                                Tt.depthFunc(Tt.NEVER);
                                break;
                            case tr:
                                Tt.depthFunc(Tt.ALWAYS);
                                break;
                            case fr:
                                Tt.depthFunc(Tt.LESS);
                                break;
                            case vr:
                                Tt.depthFunc(Tt.LEQUAL);
                                break;
                            case Zr:
                                Tt.depthFunc(Tt.EQUAL);
                                break;
                            case rn:
                                Tt.depthFunc(Tt.GEQUAL);
                                break;
                            case hn:
                                Tt.depthFunc(Tt.GREATER);
                                break;
                            case Nn:
                                Tt.depthFunc(Tt.NOTEQUAL);
                                break;
                            default:
                                Tt.depthFunc(Tt.LEQUAL)
                            }
                            Lr = Kr
                        }
                    },
                    setLocked: function(Kr) {
                        _r = Kr
                    },
                    setClear: function(Kr) {
                        Xr !== Kr && (Tt.clearDepth(Kr),
                        Xr = Kr)
                    },
                    reset: function() {
                        _r = !1,
                        Br = null,
                        Lr = null,
                        Xr = null
                    }
                }
            }
              , Ct = new function() {
                let _r = !1
                  , Br = null
                  , Lr = null
                  , Xr = null
                  , Kr = null
                  , An = null
                  , pn = null
                  , _o = null
                  , to = null;
                return {
                    setTest: function(Pn) {
                        _r || (Pn ? Zn(Tt.STENCIL_TEST) : jn(Tt.STENCIL_TEST))
                    },
                    setMask: function(Pn) {
                        Br === Pn || _r || (Tt.stencilMask(Pn),
                        Br = Pn)
                    },
                    setFunc: function(Pn, eo, Kn) {
                        Lr === Pn && Xr === eo && Kr === Kn || (Tt.stencilFunc(Pn, eo, Kn),
                        Lr = Pn,
                        Xr = eo,
                        Kr = Kn)
                    },
                    setOp: function(Pn, eo, Kn) {
                        An === Pn && pn === eo && _o === Kn || (Tt.stencilOp(Pn, eo, Kn),
                        An = Pn,
                        pn = eo,
                        _o = Kn)
                    },
                    setLocked: function(Pn) {
                        _r = Pn
                    },
                    setClear: function(Pn) {
                        to !== Pn && (Tt.clearStencil(Pn),
                        to = Pn)
                    },
                    reset: function() {
                        _r = !1,
                        Br = null,
                        Lr = null,
                        Xr = null,
                        Kr = null,
                        An = null,
                        pn = null,
                        _o = null,
                        to = null
                    }
                }
            }
              , Mt = new WeakMap
              , Lt = new WeakMap;
            let Nt = {}
              , jt = {}
              , Wt = new WeakMap
              , Qt = []
              , qt = null
              , Xt = !1
              , Zt = null
              , Yt = null
              , sr = null
              , er = null
              , rr = null
              , xr = null
              , br = null
              , yr = !1
              , Pr = null
              , zr = null
              , Nr = null
              , Vr = null
              , Gr = null;
            const Hr = Tt.getParameter(Tt.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let _n = !1
              , dn = 0;
            const kn = Tt.getParameter(Tt.VERSION);
            kn.indexOf("WebGL") !== -1 ? (dn = parseFloat(/^WebGL (\d)/.exec(kn)[1]),
            _n = dn >= 1) : kn.indexOf("OpenGL ES") !== -1 && (dn = parseFloat(/^OpenGL ES (\d)/.exec(kn)[1]),
            _n = dn >= 2);
            let Bn = null
              , cn = {};
            const Yr = Tt.getParameter(Tt.SCISSOR_BOX)
              , Jr = Tt.getParameter(Tt.VIEWPORT)
              , sn = new Lo().fromArray(Yr)
              , on = new Lo().fromArray(Jr);
            function Un(_r, Br, Lr, Xr) {
                const Kr = new Uint8Array(4)
                  , An = Tt.createTexture();
                Tt.bindTexture(_r, An),
                Tt.texParameteri(_r, Tt.TEXTURE_MIN_FILTER, Tt.NEAREST),
                Tt.texParameteri(_r, Tt.TEXTURE_MAG_FILTER, Tt.NEAREST);
                for (let pn = 0; pn < Lr; pn++)
                    !mt || _r !== Tt.TEXTURE_3D && _r !== Tt.TEXTURE_2D_ARRAY ? Tt.texImage2D(Br + pn, 0, Tt.RGBA, 1, 1, 0, Tt.RGBA, Tt.UNSIGNED_BYTE, Kr) : Tt.texImage3D(Br, 0, Tt.RGBA, 1, 1, Xr, 0, Tt.RGBA, Tt.UNSIGNED_BYTE, Kr);
                return An
            }
            const ro = {};
            function Zn(_r) {
                Nt[_r] !== !0 && (Tt.enable(_r),
                Nt[_r] = !0)
            }
            function jn(_r) {
                Nt[_r] !== !1 && (Tt.disable(_r),
                Nt[_r] = !1)
            }
            ro[Tt.TEXTURE_2D] = Un(Tt.TEXTURE_2D, Tt.TEXTURE_2D, 1),
            ro[Tt.TEXTURE_CUBE_MAP] = Un(Tt.TEXTURE_CUBE_MAP, Tt.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            mt && (ro[Tt.TEXTURE_2D_ARRAY] = Un(Tt.TEXTURE_2D_ARRAY, Tt.TEXTURE_2D_ARRAY, 1, 1),
            ro[Tt.TEXTURE_3D] = Un(Tt.TEXTURE_3D, Tt.TEXTURE_3D, 1, 1)),
            ft.setClear(0, 0, 0, 1),
            xt.setClear(1),
            Ct.setClear(0),
            Zn(Tt.DEPTH_TEST),
            xt.setFunc(vr),
            Fr(!1),
            Wr(nt),
            Zn(Tt.CULL_FACE),
            Sr(Et);
            const uo = {
                [kt]: Tt.FUNC_ADD,
                [Ut]: Tt.FUNC_SUBTRACT,
                [Ht]: Tt.FUNC_REVERSE_SUBTRACT
            };
            if (mt)
                uo[Kt] = Tt.MIN,
                uo[Jt] = Tt.MAX;
            else {
                const _r = tt.get("EXT_blend_minmax");
                _r !== null && (uo[Kt] = _r.MIN_EXT,
                uo[Jt] = _r.MAX_EXT)
            }
            const Dr = {
                [or]: Tt.ZERO,
                [ir]: Tt.ONE,
                [lr]: Tt.SRC_COLOR,
                [hr]: Tt.SRC_ALPHA,
                [Rr]: Tt.SRC_ALPHA_SATURATE,
                [Ar]: Tt.DST_COLOR,
                [dr]: Tt.DST_ALPHA,
                [ar]: Tt.ONE_MINUS_SRC_COLOR,
                [gr]: Tt.ONE_MINUS_SRC_ALPHA,
                [wr]: Tt.ONE_MINUS_DST_COLOR,
                [cr]: Tt.ONE_MINUS_DST_ALPHA
            };
            function Sr(_r, Br, Lr, Xr, Kr, An, pn, _o) {
                if (_r !== Et) {
                    if (Xt === !1 && (Zn(Tt.BLEND),
                    Xt = !0),
                    _r === Bt)
                        Kr = Kr || Br,
                        An = An || Lr,
                        pn = pn || Xr,
                        Br === Yt && Kr === rr || (Tt.blendEquationSeparate(uo[Br], uo[Kr]),
                        Yt = Br,
                        rr = Kr),
                        Lr === sr && Xr === er && An === xr && pn === br || (Tt.blendFuncSeparate(Dr[Lr], Dr[Xr], Dr[An], Dr[pn]),
                        sr = Lr,
                        er = Xr,
                        xr = An,
                        br = pn),
                        Zt = _r,
                        yr = !1;
                    else if (_r !== Zt || _o !== yr) {
                        if (Yt === kt && rr === kt || (Tt.blendEquation(Tt.FUNC_ADD),
                        Yt = kt,
                        rr = kt),
                        _o)
                            switch (_r) {
                            case Pt:
                                Tt.blendFuncSeparate(Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA, Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA);
                                break;
                            case It:
                                Tt.blendFunc(Tt.ONE, Tt.ONE);
                                break;
                            case Dt:
                                Tt.blendFuncSeparate(Tt.ZERO, Tt.ONE_MINUS_SRC_COLOR, Tt.ZERO, Tt.ONE);
                                break;
                            case Gt:
                                Tt.blendFuncSeparate(Tt.ZERO, Tt.SRC_COLOR, Tt.ZERO, Tt.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", _r)
                            }
                        else
                            switch (_r) {
                            case Pt:
                                Tt.blendFuncSeparate(Tt.SRC_ALPHA, Tt.ONE_MINUS_SRC_ALPHA, Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA);
                                break;
                            case It:
                                Tt.blendFunc(Tt.SRC_ALPHA, Tt.ONE);
                                break;
                            case Dt:
                                Tt.blendFuncSeparate(Tt.ZERO, Tt.ONE_MINUS_SRC_COLOR, Tt.ZERO, Tt.ONE);
                                break;
                            case Gt:
                                Tt.blendFunc(Tt.ZERO, Tt.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", _r)
                            }
                        sr = null,
                        er = null,
                        xr = null,
                        br = null,
                        Zt = _r,
                        yr = _o
                    }
                } else
                    Xt === !0 && (jn(Tt.BLEND),
                    Xt = !1)
            }
            function Fr(_r) {
                Pr !== _r && (_r ? Tt.frontFace(Tt.CW) : Tt.frontFace(Tt.CCW),
                Pr = _r)
            }
            function Wr(_r) {
                _r !== _e ? (Zn(Tt.CULL_FACE),
                _r !== zr && (_r === nt ? Tt.cullFace(Tt.BACK) : _r === it ? Tt.cullFace(Tt.FRONT) : Tt.cullFace(Tt.FRONT_AND_BACK))) : jn(Tt.CULL_FACE),
                zr = _r
            }
            function kr(_r, Br, Lr) {
                _r ? (Zn(Tt.POLYGON_OFFSET_FILL),
                Vr === Br && Gr === Lr || (Tt.polygonOffset(Br, Lr),
                Vr = Br,
                Gr = Lr)) : jn(Tt.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: ft,
                    depth: xt,
                    stencil: Ct
                },
                enable: Zn,
                disable: jn,
                bindFramebuffer: function(_r, Br) {
                    return jt[_r] !== Br && (Tt.bindFramebuffer(_r, Br),
                    jt[_r] = Br,
                    mt && (_r === Tt.DRAW_FRAMEBUFFER && (jt[Tt.FRAMEBUFFER] = Br),
                    _r === Tt.FRAMEBUFFER && (jt[Tt.DRAW_FRAMEBUFFER] = Br)),
                    !0)
                },
                drawBuffers: function(_r, Br) {
                    let Lr = Qt
                      , Xr = !1;
                    if (_r)
                        if (Lr = Wt.get(Br),
                        Lr === void 0 && (Lr = [],
                        Wt.set(Br, Lr)),
                        _r.isWebGLMultipleRenderTargets) {
                            const Kr = _r.texture;
                            if (Lr.length !== Kr.length || Lr[0] !== Tt.COLOR_ATTACHMENT0) {
                                for (let An = 0, pn = Kr.length; An < pn; An++)
                                    Lr[An] = Tt.COLOR_ATTACHMENT0 + An;
                                Lr.length = Kr.length,
                                Xr = !0
                            }
                        } else
                            Lr[0] !== Tt.COLOR_ATTACHMENT0 && (Lr[0] = Tt.COLOR_ATTACHMENT0,
                            Xr = !0);
                    else
                        Lr[0] !== Tt.BACK && (Lr[0] = Tt.BACK,
                        Xr = !0);
                    Xr && (lt.isWebGL2 ? Tt.drawBuffers(Lr) : tt.get("WEBGL_draw_buffers").drawBuffersWEBGL(Lr))
                },
                useProgram: function(_r) {
                    return qt !== _r && (Tt.useProgram(_r),
                    qt = _r,
                    !0)
                },
                setBlending: Sr,
                setMaterial: function(_r, Br) {
                    _r.side === St ? jn(Tt.CULL_FACE) : Zn(Tt.CULL_FACE);
                    let Lr = _r.side === bt;
                    Br && (Lr = !Lr),
                    Fr(Lr),
                    _r.blending === Pt && _r.transparent === !1 ? Sr(Et) : Sr(_r.blending, _r.blendEquation, _r.blendSrc, _r.blendDst, _r.blendEquationAlpha, _r.blendSrcAlpha, _r.blendDstAlpha, _r.premultipliedAlpha),
                    xt.setFunc(_r.depthFunc),
                    xt.setTest(_r.depthTest),
                    xt.setMask(_r.depthWrite),
                    ft.setMask(_r.colorWrite);
                    const Xr = _r.stencilWrite;
                    Ct.setTest(Xr),
                    Xr && (Ct.setMask(_r.stencilWriteMask),
                    Ct.setFunc(_r.stencilFunc, _r.stencilRef, _r.stencilFuncMask),
                    Ct.setOp(_r.stencilFail, _r.stencilZFail, _r.stencilZPass)),
                    kr(_r.polygonOffset, _r.polygonOffsetFactor, _r.polygonOffsetUnits),
                    _r.alphaToCoverage === !0 ? Zn(Tt.SAMPLE_ALPHA_TO_COVERAGE) : jn(Tt.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: Fr,
                setCullFace: Wr,
                setLineWidth: function(_r) {
                    _r !== Nr && (_n && Tt.lineWidth(_r),
                    Nr = _r)
                },
                setPolygonOffset: kr,
                setScissorTest: function(_r) {
                    _r ? Zn(Tt.SCISSOR_TEST) : jn(Tt.SCISSOR_TEST)
                },
                activeTexture: function(_r) {
                    _r === void 0 && (_r = Tt.TEXTURE0 + Hr - 1),
                    Bn !== _r && (Tt.activeTexture(_r),
                    Bn = _r)
                },
                bindTexture: function(_r, Br, Lr) {
                    Lr === void 0 && (Lr = Bn === null ? Tt.TEXTURE0 + Hr - 1 : Bn);
                    let Xr = cn[Lr];
                    Xr === void 0 && (Xr = {
                        type: void 0,
                        texture: void 0
                    },
                    cn[Lr] = Xr),
                    Xr.type === _r && Xr.texture === Br || (Bn !== Lr && (Tt.activeTexture(Lr),
                    Bn = Lr),
                    Tt.bindTexture(_r, Br || ro[_r]),
                    Xr.type = _r,
                    Xr.texture = Br)
                },
                unbindTexture: function() {
                    const _r = cn[Bn];
                    _r !== void 0 && _r.type !== void 0 && (Tt.bindTexture(_r.type, null),
                    _r.type = void 0,
                    _r.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        Tt.compressedTexImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        Tt.compressedTexImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texImage2D: function() {
                    try {
                        Tt.texImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texImage3D: function() {
                    try {
                        Tt.texImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                updateUBOMapping: function(_r, Br) {
                    let Lr = Lt.get(Br);
                    Lr === void 0 && (Lr = new WeakMap,
                    Lt.set(Br, Lr));
                    let Xr = Lr.get(_r);
                    Xr === void 0 && (Xr = Tt.getUniformBlockIndex(Br, _r.name),
                    Lr.set(_r, Xr))
                },
                uniformBlockBinding: function(_r, Br) {
                    const Lr = Lt.get(Br).get(_r);
                    Mt.get(Br) !== Lr && (Tt.uniformBlockBinding(Br, Lr, _r.__bindingPointIndex),
                    Mt.set(Br, Lr))
                },
                texStorage2D: function() {
                    try {
                        Tt.texStorage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texStorage3D: function() {
                    try {
                        Tt.texStorage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texSubImage2D: function() {
                    try {
                        Tt.texSubImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texSubImage3D: function() {
                    try {
                        Tt.texSubImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        Tt.compressedTexSubImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        Tt.compressedTexSubImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                scissor: function(_r) {
                    sn.equals(_r) === !1 && (Tt.scissor(_r.x, _r.y, _r.z, _r.w),
                    sn.copy(_r))
                },
                viewport: function(_r) {
                    on.equals(_r) === !1 && (Tt.viewport(_r.x, _r.y, _r.z, _r.w),
                    on.copy(_r))
                },
                reset: function() {
                    Tt.disable(Tt.BLEND),
                    Tt.disable(Tt.CULL_FACE),
                    Tt.disable(Tt.DEPTH_TEST),
                    Tt.disable(Tt.POLYGON_OFFSET_FILL),
                    Tt.disable(Tt.SCISSOR_TEST),
                    Tt.disable(Tt.STENCIL_TEST),
                    Tt.disable(Tt.SAMPLE_ALPHA_TO_COVERAGE),
                    Tt.blendEquation(Tt.FUNC_ADD),
                    Tt.blendFunc(Tt.ONE, Tt.ZERO),
                    Tt.blendFuncSeparate(Tt.ONE, Tt.ZERO, Tt.ONE, Tt.ZERO),
                    Tt.colorMask(!0, !0, !0, !0),
                    Tt.clearColor(0, 0, 0, 0),
                    Tt.depthMask(!0),
                    Tt.depthFunc(Tt.LESS),
                    Tt.clearDepth(1),
                    Tt.stencilMask(4294967295),
                    Tt.stencilFunc(Tt.ALWAYS, 0, 4294967295),
                    Tt.stencilOp(Tt.KEEP, Tt.KEEP, Tt.KEEP),
                    Tt.clearStencil(0),
                    Tt.cullFace(Tt.BACK),
                    Tt.frontFace(Tt.CCW),
                    Tt.polygonOffset(0, 0),
                    Tt.activeTexture(Tt.TEXTURE0),
                    Tt.bindFramebuffer(Tt.FRAMEBUFFER, null),
                    mt === !0 && (Tt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, null),
                    Tt.bindFramebuffer(Tt.READ_FRAMEBUFFER, null)),
                    Tt.useProgram(null),
                    Tt.lineWidth(1),
                    Tt.scissor(0, 0, Tt.canvas.width, Tt.canvas.height),
                    Tt.viewport(0, 0, Tt.canvas.width, Tt.canvas.height),
                    Nt = {},
                    Bn = null,
                    cn = {},
                    jt = {},
                    Wt = new WeakMap,
                    Qt = [],
                    qt = null,
                    Xt = !1,
                    Zt = null,
                    Yt = null,
                    sr = null,
                    er = null,
                    rr = null,
                    xr = null,
                    br = null,
                    yr = !1,
                    Pr = null,
                    zr = null,
                    Nr = null,
                    Vr = null,
                    Gr = null,
                    sn.set(0, 0, Tt.canvas.width, Tt.canvas.height),
                    on.set(0, 0, Tt.canvas.width, Tt.canvas.height),
                    ft.reset(),
                    xt.reset(),
                    Ct.reset()
                }
            }
        }
        function Z1(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = ft.isWebGL2
              , Lt = ft.maxTextures
              , Nt = ft.maxCubemapSize
              , jt = ft.maxTextureSize
              , Wt = ft.maxSamples
              , Qt = tt.has("WEBGL_multisampled_render_to_texture") ? tt.get("WEBGL_multisampled_render_to_texture") : null
              , qt = typeof navigator < "u" && /OculusBrowser/g.test(navigator.userAgent)
              , Xt = new WeakMap;
            let Zt;
            const Yt = new WeakMap;
            let sr = !1;
            try {
                sr = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
            } catch {}
            function er(Dr, Sr) {
                return sr ? new OffscreenCanvas(Dr,Sr) : yu("canvas")
            }
            function rr(Dr, Sr, Fr, Wr) {
                let kr = 1;
                if ((Dr.width > Wr || Dr.height > Wr) && (kr = Wr / Math.max(Dr.width, Dr.height)),
                kr < 1 || Sr === !0) {
                    if (typeof HTMLImageElement < "u" && Dr instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Dr instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Dr instanceof ImageBitmap) {
                        const _r = Sr ? gp : Math.floor
                          , Br = _r(kr * Dr.width)
                          , Lr = _r(kr * Dr.height);
                        Zt === void 0 && (Zt = er(Br, Lr));
                        const Xr = Fr ? er(Br, Lr) : Zt;
                        return Xr.width = Br,
                        Xr.height = Lr,
                        Xr.getContext("2d").drawImage(Dr, 0, 0, Br, Lr),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Dr.width + "x" + Dr.height + ") to (" + Br + "x" + Lr + ")."),
                        Xr
                    }
                    return "data"in Dr && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Dr.width + "x" + Dr.height + ")."),
                    Dr
                }
                return Dr
            }
            function xr(Dr) {
                return tm(Dr.width) && tm(Dr.height)
            }
            function br(Dr, Sr) {
                return Dr.generateMipmaps && Sr && Dr.minFilter !== fn && Dr.minFilter !== Rn
            }
            function yr(Dr) {
                Tt.generateMipmap(Dr)
            }
            function Pr(Dr, Sr, Fr, Wr, kr=!1) {
                if (Mt === !1)
                    return Sr;
                if (Dr !== null) {
                    if (Tt[Dr] !== void 0)
                        return Tt[Dr];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Dr + "'")
                }
                let _r = Sr;
                if (Sr === Tt.RED && (Fr === Tt.FLOAT && (_r = Tt.R32F),
                Fr === Tt.HALF_FLOAT && (_r = Tt.R16F),
                Fr === Tt.UNSIGNED_BYTE && (_r = Tt.R8)),
                Sr === Tt.RED_INTEGER && (Fr === Tt.UNSIGNED_BYTE && (_r = Tt.R8UI),
                Fr === Tt.UNSIGNED_SHORT && (_r = Tt.R16UI),
                Fr === Tt.UNSIGNED_INT && (_r = Tt.R32UI),
                Fr === Tt.BYTE && (_r = Tt.R8I),
                Fr === Tt.SHORT && (_r = Tt.R16I),
                Fr === Tt.INT && (_r = Tt.R32I)),
                Sr === Tt.RG && (Fr === Tt.FLOAT && (_r = Tt.RG32F),
                Fr === Tt.HALF_FLOAT && (_r = Tt.RG16F),
                Fr === Tt.UNSIGNED_BYTE && (_r = Tt.RG8)),
                Sr === Tt.RGBA) {
                    const Br = kr ? No : Do.getTransfer(Wr);
                    Fr === Tt.FLOAT && (_r = Tt.RGBA32F),
                    Fr === Tt.HALF_FLOAT && (_r = Tt.RGBA16F),
                    Fr === Tt.UNSIGNED_BYTE && (_r = Br === Vo ? Tt.SRGB8_ALPHA8 : Tt.RGBA8),
                    Fr === Tt.UNSIGNED_SHORT_4_4_4_4 && (_r = Tt.RGBA4),
                    Fr === Tt.UNSIGNED_SHORT_5_5_5_1 && (_r = Tt.RGB5_A1)
                }
                return _r !== Tt.R16F && _r !== Tt.R32F && _r !== Tt.RG16F && _r !== Tt.RG32F && _r !== Tt.RGBA16F && _r !== Tt.RGBA32F || tt.get("EXT_color_buffer_float"),
                _r
            }
            function zr(Dr, Sr, Fr) {
                return br(Dr, Fr) === !0 || Dr.isFramebufferTexture && Dr.minFilter !== fn && Dr.minFilter !== Rn ? Math.log2(Math.max(Sr.width, Sr.height)) + 1 : Dr.mipmaps !== void 0 && Dr.mipmaps.length > 0 ? Dr.mipmaps.length : Dr.isCompressedTexture && Array.isArray(Dr.image) ? Sr.mipmaps.length : 1
            }
            function Nr(Dr) {
                return Dr === fn || Dr === bn || Dr === En ? Tt.NEAREST : Tt.LINEAR
            }
            function Vr(Dr) {
                const Sr = Dr.target;
                Sr.removeEventListener("dispose", Vr),
                function(Fr) {
                    const Wr = mt.get(Fr);
                    if (Wr.__webglInit === void 0)
                        return;
                    const kr = Fr.source
                      , _r = Yt.get(kr);
                    if (_r) {
                        const Br = _r[Wr.__cacheKey];
                        Br.usedTimes--,
                        Br.usedTimes === 0 && Hr(Fr),
                        Object.keys(_r).length === 0 && Yt.delete(kr)
                    }
                    mt.remove(Fr)
                }(Sr),
                Sr.isVideoTexture && Xt.delete(Sr)
            }
            function Gr(Dr) {
                const Sr = Dr.target;
                Sr.removeEventListener("dispose", Gr),
                function(Fr) {
                    const Wr = Fr.texture
                      , kr = mt.get(Fr)
                      , _r = mt.get(Wr);
                    if (_r.__webglTexture !== void 0 && (Tt.deleteTexture(_r.__webglTexture),
                    Ct.memory.textures--),
                    Fr.depthTexture && Fr.depthTexture.dispose(),
                    Fr.isWebGLCubeRenderTarget)
                        for (let Br = 0; Br < 6; Br++) {
                            if (Array.isArray(kr.__webglFramebuffer[Br]))
                                for (let Lr = 0; Lr < kr.__webglFramebuffer[Br].length; Lr++)
                                    Tt.deleteFramebuffer(kr.__webglFramebuffer[Br][Lr]);
                            else
                                Tt.deleteFramebuffer(kr.__webglFramebuffer[Br]);
                            kr.__webglDepthbuffer && Tt.deleteRenderbuffer(kr.__webglDepthbuffer[Br])
                        }
                    else {
                        if (Array.isArray(kr.__webglFramebuffer))
                            for (let Br = 0; Br < kr.__webglFramebuffer.length; Br++)
                                Tt.deleteFramebuffer(kr.__webglFramebuffer[Br]);
                        else
                            Tt.deleteFramebuffer(kr.__webglFramebuffer);
                        if (kr.__webglDepthbuffer && Tt.deleteRenderbuffer(kr.__webglDepthbuffer),
                        kr.__webglMultisampledFramebuffer && Tt.deleteFramebuffer(kr.__webglMultisampledFramebuffer),
                        kr.__webglColorRenderbuffer)
                            for (let Br = 0; Br < kr.__webglColorRenderbuffer.length; Br++)
                                kr.__webglColorRenderbuffer[Br] && Tt.deleteRenderbuffer(kr.__webglColorRenderbuffer[Br]);
                        kr.__webglDepthRenderbuffer && Tt.deleteRenderbuffer(kr.__webglDepthRenderbuffer)
                    }
                    if (Fr.isWebGLMultipleRenderTargets)
                        for (let Br = 0, Lr = Wr.length; Br < Lr; Br++) {
                            const Xr = mt.get(Wr[Br]);
                            Xr.__webglTexture && (Tt.deleteTexture(Xr.__webglTexture),
                            Ct.memory.textures--),
                            mt.remove(Wr[Br])
                        }
                    mt.remove(Wr),
                    mt.remove(Fr)
                }(Sr)
            }
            function Hr(Dr) {
                const Sr = mt.get(Dr);
                Tt.deleteTexture(Sr.__webglTexture);
                const Fr = Dr.source;
                delete Yt.get(Fr)[Sr.__cacheKey],
                Ct.memory.textures--
            }
            let _n = 0;
            function dn(Dr, Sr) {
                const Fr = mt.get(Dr);
                if (Dr.isVideoTexture && function(Wr) {
                    const kr = Ct.render.frame;
                    Xt.get(Wr) !== kr && (Xt.set(Wr, kr),
                    Wr.update())
                }(Dr),
                Dr.isRenderTargetTexture === !1 && Dr.version > 0 && Fr.__version !== Dr.version) {
                    const Wr = Dr.image;
                    if (Wr === null)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (Wr.complete !== !1)
                            return void sn(Fr, Dr, Sr);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                lt.bindTexture(Tt.TEXTURE_2D, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            const kn = {
                [Tn]: Tt.REPEAT,
                [wn]: Tt.CLAMP_TO_EDGE,
                [Cn]: Tt.MIRRORED_REPEAT
            }
              , Bn = {
                [fn]: Tt.NEAREST,
                [bn]: Tt.NEAREST_MIPMAP_NEAREST,
                [En]: Tt.NEAREST_MIPMAP_LINEAR,
                [Rn]: Tt.LINEAR,
                [Yn]: Tt.LINEAR_MIPMAP_NEAREST,
                [vo]: Tt.LINEAR_MIPMAP_LINEAR
            }
              , cn = {
                [mu]: Tt.NEVER,
                [Y_]: Tt.ALWAYS,
                [fu]: Tt.LESS,
                [q_]: Tt.LEQUAL,
                [fp]: Tt.EQUAL,
                [Kl]: Tt.GEQUAL,
                [$_]: Tt.GREATER,
                [X_]: Tt.NOTEQUAL
            };
            function Yr(Dr, Sr, Fr) {
                if (Fr ? (Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_S, kn[Sr.wrapS]),
                Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_T, kn[Sr.wrapT]),
                Dr !== Tt.TEXTURE_3D && Dr !== Tt.TEXTURE_2D_ARRAY || Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_R, kn[Sr.wrapR]),
                Tt.texParameteri(Dr, Tt.TEXTURE_MAG_FILTER, Bn[Sr.magFilter]),
                Tt.texParameteri(Dr, Tt.TEXTURE_MIN_FILTER, Bn[Sr.minFilter])) : (Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_S, Tt.CLAMP_TO_EDGE),
                Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_T, Tt.CLAMP_TO_EDGE),
                Dr !== Tt.TEXTURE_3D && Dr !== Tt.TEXTURE_2D_ARRAY || Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_R, Tt.CLAMP_TO_EDGE),
                Sr.wrapS === wn && Sr.wrapT === wn || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                Tt.texParameteri(Dr, Tt.TEXTURE_MAG_FILTER, Nr(Sr.magFilter)),
                Tt.texParameteri(Dr, Tt.TEXTURE_MIN_FILTER, Nr(Sr.minFilter)),
                Sr.minFilter !== fn && Sr.minFilter !== Rn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                Sr.compareFunction && (Tt.texParameteri(Dr, Tt.TEXTURE_COMPARE_MODE, Tt.COMPARE_REF_TO_TEXTURE),
                Tt.texParameteri(Dr, Tt.TEXTURE_COMPARE_FUNC, cn[Sr.compareFunction])),
                tt.has("EXT_texture_filter_anisotropic") === !0) {
                    const Wr = tt.get("EXT_texture_filter_anisotropic");
                    if (Sr.magFilter === fn || Sr.minFilter !== En && Sr.minFilter !== vo || Sr.type === ss && tt.has("OES_texture_float_linear") === !1 || Mt === !1 && Sr.type === Os && tt.has("OES_texture_half_float_linear") === !1)
                        return;
                    (Sr.anisotropy > 1 || mt.get(Sr).__currentAnisotropy) && (Tt.texParameterf(Dr, Wr.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Sr.anisotropy, ft.getMaxAnisotropy())),
                    mt.get(Sr).__currentAnisotropy = Sr.anisotropy)
                }
            }
            function Jr(Dr, Sr) {
                let Fr = !1;
                Dr.__webglInit === void 0 && (Dr.__webglInit = !0,
                Sr.addEventListener("dispose", Vr));
                const Wr = Sr.source;
                let kr = Yt.get(Wr);
                kr === void 0 && (kr = {},
                Yt.set(Wr, kr));
                const _r = function(Br) {
                    const Lr = [];
                    return Lr.push(Br.wrapS),
                    Lr.push(Br.wrapT),
                    Lr.push(Br.wrapR || 0),
                    Lr.push(Br.magFilter),
                    Lr.push(Br.minFilter),
                    Lr.push(Br.anisotropy),
                    Lr.push(Br.internalFormat),
                    Lr.push(Br.format),
                    Lr.push(Br.type),
                    Lr.push(Br.generateMipmaps),
                    Lr.push(Br.premultiplyAlpha),
                    Lr.push(Br.flipY),
                    Lr.push(Br.unpackAlignment),
                    Lr.push(Br.colorSpace),
                    Lr.join()
                }(Sr);
                if (_r !== Dr.__cacheKey) {
                    kr[_r] === void 0 && (kr[_r] = {
                        texture: Tt.createTexture(),
                        usedTimes: 0
                    },
                    Ct.memory.textures++,
                    Fr = !0),
                    kr[_r].usedTimes++;
                    const Br = kr[Dr.__cacheKey];
                    Br !== void 0 && (kr[Dr.__cacheKey].usedTimes--,
                    Br.usedTimes === 0 && Hr(Sr)),
                    Dr.__cacheKey = _r,
                    Dr.__webglTexture = kr[_r].texture
                }
                return Fr
            }
            function sn(Dr, Sr, Fr) {
                let Wr = Tt.TEXTURE_2D;
                (Sr.isDataArrayTexture || Sr.isCompressedArrayTexture) && (Wr = Tt.TEXTURE_2D_ARRAY),
                Sr.isData3DTexture && (Wr = Tt.TEXTURE_3D);
                const kr = Jr(Dr, Sr)
                  , _r = Sr.source;
                lt.bindTexture(Wr, Dr.__webglTexture, Tt.TEXTURE0 + Fr);
                const Br = mt.get(_r);
                if (_r.version !== Br.__version || kr === !0) {
                    lt.activeTexture(Tt.TEXTURE0 + Fr);
                    const Lr = Do.getPrimaries(Do.workingColorSpace)
                      , Xr = Sr.colorSpace === Oo || Sr.colorSpace === ps ? null : Do.getPrimaries(Sr.colorSpace)
                      , Kr = Sr.colorSpace === Oo || Sr.colorSpace === ps || Lr === Xr ? Tt.NONE : Tt.BROWSER_DEFAULT_WEBGL;
                    Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, Sr.flipY),
                    Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Sr.premultiplyAlpha),
                    Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, Sr.unpackAlignment),
                    Tt.pixelStorei(Tt.UNPACK_COLORSPACE_CONVERSION_WEBGL, Kr);
                    const An = function(Jn) {
                        return !Mt && (Jn.wrapS !== wn || Jn.wrapT !== wn || Jn.minFilter !== fn && Jn.minFilter !== Rn)
                    }(Sr) && xr(Sr.image) === !1;
                    let pn = rr(Sr.image, An, !1, jt);
                    pn = uo(Sr, pn);
                    const _o = xr(pn) || Mt
                      , to = xt.convert(Sr.format, Sr.colorSpace);
                    let Pn, eo = xt.convert(Sr.type), Kn = Pr(Sr.internalFormat, to, eo, Sr.colorSpace, Sr.isVideoTexture);
                    Yr(Wr, Sr, _o);
                    const po = Sr.mipmaps
                      , Ao = Mt && Sr.isVideoTexture !== !0
                      , Fo = Br.__version === void 0 || kr === !0
                      , Io = zr(Sr, pn, _o);
                    if (Sr.isDepthTexture)
                        Kn = Tt.DEPTH_COMPONENT,
                        Mt ? Kn = Sr.type === ss ? Tt.DEPTH_COMPONENT32F : Sr.type === Yo ? Tt.DEPTH_COMPONENT24 : Sr.type === Ps ? Tt.DEPTH24_STENCIL8 : Tt.DEPTH_COMPONENT16 : Sr.type === ss && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                        Sr.format === Ys && Kn === Tt.DEPTH_COMPONENT && Sr.type !== Zo && Sr.type !== Yo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        Sr.type = Yo,
                        eo = xt.convert(Sr.type)),
                        Sr.format === Eo && Kn === Tt.DEPTH_COMPONENT && (Kn = Tt.DEPTH_STENCIL,
                        Sr.type !== Ps && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        Sr.type = Ps,
                        eo = xt.convert(Sr.type))),
                        Fo && (Ao ? lt.texStorage2D(Tt.TEXTURE_2D, 1, Kn, pn.width, pn.height) : lt.texImage2D(Tt.TEXTURE_2D, 0, Kn, pn.width, pn.height, 0, to, eo, null));
                    else if (Sr.isDataTexture)
                        if (po.length > 0 && _o) {
                            Ao && Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, po[0].width, po[0].height);
                            for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                                Pn = po[Jn],
                                Ao ? lt.texSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, Pn.width, Pn.height, to, eo, Pn.data) : lt.texImage2D(Tt.TEXTURE_2D, Jn, Kn, Pn.width, Pn.height, 0, to, eo, Pn.data);
                            Sr.generateMipmaps = !1
                        } else
                            Ao ? (Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, pn.width, pn.height),
                            lt.texSubImage2D(Tt.TEXTURE_2D, 0, 0, 0, pn.width, pn.height, to, eo, pn.data)) : lt.texImage2D(Tt.TEXTURE_2D, 0, Kn, pn.width, pn.height, 0, to, eo, pn.data);
                    else if (Sr.isCompressedTexture)
                        if (Sr.isCompressedArrayTexture) {
                            Ao && Fo && lt.texStorage3D(Tt.TEXTURE_2D_ARRAY, Io, Kn, po[0].width, po[0].height, pn.depth);
                            for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                                Pn = po[Jn],
                                Sr.format !== as ? to !== null ? Ao ? lt.compressedTexSubImage3D(Tt.TEXTURE_2D_ARRAY, Jn, 0, 0, 0, Pn.width, Pn.height, pn.depth, to, Pn.data, 0, 0) : lt.compressedTexImage3D(Tt.TEXTURE_2D_ARRAY, Jn, Kn, Pn.width, Pn.height, pn.depth, 0, Pn.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ao ? lt.texSubImage3D(Tt.TEXTURE_2D_ARRAY, Jn, 0, 0, 0, Pn.width, Pn.height, pn.depth, to, eo, Pn.data) : lt.texImage3D(Tt.TEXTURE_2D_ARRAY, Jn, Kn, Pn.width, Pn.height, pn.depth, 0, to, eo, Pn.data)
                        } else {
                            Ao && Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, po[0].width, po[0].height);
                            for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                                Pn = po[Jn],
                                Sr.format !== as ? to !== null ? Ao ? lt.compressedTexSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, Pn.width, Pn.height, to, Pn.data) : lt.compressedTexImage2D(Tt.TEXTURE_2D, Jn, Kn, Pn.width, Pn.height, 0, Pn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ao ? lt.texSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, Pn.width, Pn.height, to, eo, Pn.data) : lt.texImage2D(Tt.TEXTURE_2D, Jn, Kn, Pn.width, Pn.height, 0, to, eo, Pn.data)
                        }
                    else if (Sr.isDataArrayTexture)
                        Ao ? (Fo && lt.texStorage3D(Tt.TEXTURE_2D_ARRAY, Io, Kn, pn.width, pn.height, pn.depth),
                        lt.texSubImage3D(Tt.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pn.width, pn.height, pn.depth, to, eo, pn.data)) : lt.texImage3D(Tt.TEXTURE_2D_ARRAY, 0, Kn, pn.width, pn.height, pn.depth, 0, to, eo, pn.data);
                    else if (Sr.isData3DTexture)
                        Ao ? (Fo && lt.texStorage3D(Tt.TEXTURE_3D, Io, Kn, pn.width, pn.height, pn.depth),
                        lt.texSubImage3D(Tt.TEXTURE_3D, 0, 0, 0, 0, pn.width, pn.height, pn.depth, to, eo, pn.data)) : lt.texImage3D(Tt.TEXTURE_3D, 0, Kn, pn.width, pn.height, pn.depth, 0, to, eo, pn.data);
                    else if (Sr.isFramebufferTexture) {
                        if (Fo)
                            if (Ao)
                                lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, pn.width, pn.height);
                            else {
                                let Jn = pn.width
                                  , Co = pn.height;
                                for (let yl = 0; yl < Io; yl++)
                                    lt.texImage2D(Tt.TEXTURE_2D, yl, Kn, Jn, Co, 0, to, eo, null),
                                    Jn >>= 1,
                                    Co >>= 1
                            }
                    } else if (po.length > 0 && _o) {
                        Ao && Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, po[0].width, po[0].height);
                        for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                            Pn = po[Jn],
                            Ao ? lt.texSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, to, eo, Pn) : lt.texImage2D(Tt.TEXTURE_2D, Jn, Kn, to, eo, Pn);
                        Sr.generateMipmaps = !1
                    } else
                        Ao ? (Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, pn.width, pn.height),
                        lt.texSubImage2D(Tt.TEXTURE_2D, 0, 0, 0, to, eo, pn)) : lt.texImage2D(Tt.TEXTURE_2D, 0, Kn, to, eo, pn);
                    br(Sr, _o) && yr(Wr),
                    Br.__version = _r.version,
                    Sr.onUpdate && Sr.onUpdate(Sr)
                }
                Dr.__version = Sr.version
            }
            function on(Dr, Sr, Fr, Wr, kr, _r) {
                const Br = xt.convert(Fr.format, Fr.colorSpace)
                  , Lr = xt.convert(Fr.type)
                  , Xr = Pr(Fr.internalFormat, Br, Lr, Fr.colorSpace);
                if (!mt.get(Sr).__hasExternalTextures) {
                    const Kr = Math.max(1, Sr.width >> _r)
                      , An = Math.max(1, Sr.height >> _r);
                    kr === Tt.TEXTURE_3D || kr === Tt.TEXTURE_2D_ARRAY ? lt.texImage3D(kr, _r, Xr, Kr, An, Sr.depth, 0, Br, Lr, null) : lt.texImage2D(kr, _r, Xr, Kr, An, 0, Br, Lr, null)
                }
                lt.bindFramebuffer(Tt.FRAMEBUFFER, Dr),
                jn(Sr) ? Qt.framebufferTexture2DMultisampleEXT(Tt.FRAMEBUFFER, Wr, kr, mt.get(Fr).__webglTexture, 0, Zn(Sr)) : (kr === Tt.TEXTURE_2D || kr >= Tt.TEXTURE_CUBE_MAP_POSITIVE_X && kr <= Tt.TEXTURE_CUBE_MAP_NEGATIVE_Z) && Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Wr, kr, mt.get(Fr).__webglTexture, _r),
                lt.bindFramebuffer(Tt.FRAMEBUFFER, null)
            }
            function Un(Dr, Sr, Fr) {
                if (Tt.bindRenderbuffer(Tt.RENDERBUFFER, Dr),
                Sr.depthBuffer && !Sr.stencilBuffer) {
                    let Wr = Mt === !0 ? Tt.DEPTH_COMPONENT24 : Tt.DEPTH_COMPONENT16;
                    if (Fr || jn(Sr)) {
                        const kr = Sr.depthTexture;
                        kr && kr.isDepthTexture && (kr.type === ss ? Wr = Tt.DEPTH_COMPONENT32F : kr.type === Yo && (Wr = Tt.DEPTH_COMPONENT24));
                        const _r = Zn(Sr);
                        jn(Sr) ? Qt.renderbufferStorageMultisampleEXT(Tt.RENDERBUFFER, _r, Wr, Sr.width, Sr.height) : Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, _r, Wr, Sr.width, Sr.height)
                    } else
                        Tt.renderbufferStorage(Tt.RENDERBUFFER, Wr, Sr.width, Sr.height);
                    Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.RENDERBUFFER, Dr)
                } else if (Sr.depthBuffer && Sr.stencilBuffer) {
                    const Wr = Zn(Sr);
                    Fr && jn(Sr) === !1 ? Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, Wr, Tt.DEPTH24_STENCIL8, Sr.width, Sr.height) : jn(Sr) ? Qt.renderbufferStorageMultisampleEXT(Tt.RENDERBUFFER, Wr, Tt.DEPTH24_STENCIL8, Sr.width, Sr.height) : Tt.renderbufferStorage(Tt.RENDERBUFFER, Tt.DEPTH_STENCIL, Sr.width, Sr.height),
                    Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.RENDERBUFFER, Dr)
                } else {
                    const Wr = Sr.isWebGLMultipleRenderTargets === !0 ? Sr.texture : [Sr.texture];
                    for (let kr = 0; kr < Wr.length; kr++) {
                        const _r = Wr[kr]
                          , Br = xt.convert(_r.format, _r.colorSpace)
                          , Lr = xt.convert(_r.type)
                          , Xr = Pr(_r.internalFormat, Br, Lr, _r.colorSpace)
                          , Kr = Zn(Sr);
                        Fr && jn(Sr) === !1 ? Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, Kr, Xr, Sr.width, Sr.height) : jn(Sr) ? Qt.renderbufferStorageMultisampleEXT(Tt.RENDERBUFFER, Kr, Xr, Sr.width, Sr.height) : Tt.renderbufferStorage(Tt.RENDERBUFFER, Xr, Sr.width, Sr.height)
                    }
                }
                Tt.bindRenderbuffer(Tt.RENDERBUFFER, null)
            }
            function ro(Dr) {
                const Sr = mt.get(Dr)
                  , Fr = Dr.isWebGLCubeRenderTarget === !0;
                if (Dr.depthTexture && !Sr.__autoAllocateDepthBuffer) {
                    if (Fr)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    (function(Wr, kr) {
                        if (kr && kr.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (lt.bindFramebuffer(Tt.FRAMEBUFFER, Wr),
                        !kr.depthTexture || !kr.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        mt.get(kr.depthTexture).__webglTexture && kr.depthTexture.image.width === kr.width && kr.depthTexture.image.height === kr.height || (kr.depthTexture.image.width = kr.width,
                        kr.depthTexture.image.height = kr.height,
                        kr.depthTexture.needsUpdate = !0),
                        dn(kr.depthTexture, 0);
                        const _r = mt.get(kr.depthTexture).__webglTexture
                          , Br = Zn(kr);
                        if (kr.depthTexture.format === Ys)
                            jn(kr) ? Qt.framebufferTexture2DMultisampleEXT(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.TEXTURE_2D, _r, 0, Br) : Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.TEXTURE_2D, _r, 0);
                        else {
                            if (kr.depthTexture.format !== Eo)
                                throw new Error("Unknown depthTexture format");
                            jn(kr) ? Qt.framebufferTexture2DMultisampleEXT(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.TEXTURE_2D, _r, 0, Br) : Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.TEXTURE_2D, _r, 0)
                        }
                    }
                    )(Sr.__webglFramebuffer, Dr)
                } else if (Fr) {
                    Sr.__webglDepthbuffer = [];
                    for (let Wr = 0; Wr < 6; Wr++)
                        lt.bindFramebuffer(Tt.FRAMEBUFFER, Sr.__webglFramebuffer[Wr]),
                        Sr.__webglDepthbuffer[Wr] = Tt.createRenderbuffer(),
                        Un(Sr.__webglDepthbuffer[Wr], Dr, !1)
                } else
                    lt.bindFramebuffer(Tt.FRAMEBUFFER, Sr.__webglFramebuffer),
                    Sr.__webglDepthbuffer = Tt.createRenderbuffer(),
                    Un(Sr.__webglDepthbuffer, Dr, !1);
                lt.bindFramebuffer(Tt.FRAMEBUFFER, null)
            }
            function Zn(Dr) {
                return Math.min(Wt, Dr.samples)
            }
            function jn(Dr) {
                const Sr = mt.get(Dr);
                return Mt && Dr.samples > 0 && tt.has("WEBGL_multisampled_render_to_texture") === !0 && Sr.__useRenderToTexture !== !1
            }
            function uo(Dr, Sr) {
                const Fr = Dr.colorSpace
                  , Wr = Dr.format
                  , kr = Dr.type;
                return Dr.isCompressedTexture === !0 || Dr.isVideoTexture === !0 || Dr.format === _h || Fr !== Xo && Fr !== Oo && (Do.getTransfer(Fr) === Vo ? Mt === !1 ? tt.has("EXT_sRGB") === !0 && Wr === as ? (Dr.format = _h,
                Dr.minFilter = Rn,
                Dr.generateMipmaps = !1) : Sr = e_.sRGBToLinear(Sr) : Wr === as && kr === $n || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : Fr === ps || console.error("THREE.WebGLTextures: Unsupported texture color space:", Fr)),
                Sr
            }
            this.allocateTextureUnit = function() {
                const Dr = _n;
                return Dr >= Lt && console.warn("THREE.WebGLTextures: Trying to use " + Dr + " texture units while this GPU supports only " + Lt),
                _n += 1,
                Dr
            }
            ,
            this.resetTextureUnits = function() {
                _n = 0
            }
            ,
            this.setTexture2D = dn,
            this.setTexture2DArray = function(Dr, Sr) {
                const Fr = mt.get(Dr);
                Dr.version > 0 && Fr.__version !== Dr.version ? sn(Fr, Dr, Sr) : lt.bindTexture(Tt.TEXTURE_2D_ARRAY, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            ,
            this.setTexture3D = function(Dr, Sr) {
                const Fr = mt.get(Dr);
                Dr.version > 0 && Fr.__version !== Dr.version ? sn(Fr, Dr, Sr) : lt.bindTexture(Tt.TEXTURE_3D, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            ,
            this.setTextureCube = function(Dr, Sr) {
                const Fr = mt.get(Dr);
                Dr.version > 0 && Fr.__version !== Dr.version ? function(Wr, kr, _r) {
                    if (kr.image.length !== 6)
                        return;
                    const Br = Jr(Wr, kr)
                      , Lr = kr.source;
                    lt.bindTexture(Tt.TEXTURE_CUBE_MAP, Wr.__webglTexture, Tt.TEXTURE0 + _r);
                    const Xr = mt.get(Lr);
                    if (Lr.version !== Xr.__version || Br === !0) {
                        lt.activeTexture(Tt.TEXTURE0 + _r);
                        const Kr = Do.getPrimaries(Do.workingColorSpace)
                          , An = kr.colorSpace === Oo || kr.colorSpace === ps ? null : Do.getPrimaries(kr.colorSpace)
                          , pn = kr.colorSpace === Oo || kr.colorSpace === ps || Kr === An ? Tt.NONE : Tt.BROWSER_DEFAULT_WEBGL;
                        Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, kr.flipY),
                        Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, kr.premultiplyAlpha),
                        Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, kr.unpackAlignment),
                        Tt.pixelStorei(Tt.UNPACK_COLORSPACE_CONVERSION_WEBGL, pn);
                        const _o = kr.isCompressedTexture || kr.image[0].isCompressedTexture
                          , to = kr.image[0] && kr.image[0].isDataTexture
                          , Pn = [];
                        for (let ho = 0; ho < 6; ho++)
                            Pn[ho] = _o || to ? to ? kr.image[ho].image : kr.image[ho] : rr(kr.image[ho], !1, !0, Nt),
                            Pn[ho] = uo(kr, Pn[ho]);
                        const eo = Pn[0]
                          , Kn = xr(eo) || Mt
                          , po = xt.convert(kr.format, kr.colorSpace)
                          , Ao = xt.convert(kr.type)
                          , Fo = Pr(kr.internalFormat, po, Ao, kr.colorSpace)
                          , Io = Mt && kr.isVideoTexture !== !0
                          , Jn = Xr.__version === void 0 || Br === !0;
                        let Co, yl = zr(kr, eo, Kn);
                        if (Yr(Tt.TEXTURE_CUBE_MAP, kr, Kn),
                        _o) {
                            Io && Jn && lt.texStorage2D(Tt.TEXTURE_CUBE_MAP, yl, Fo, eo.width, eo.height);
                            for (let ho = 0; ho < 6; ho++) {
                                Co = Pn[ho].mipmaps;
                                for (let Qo = 0; Qo < Co.length; Qo++) {
                                    const Po = Co[Qo];
                                    kr.format !== as ? po !== null ? Io ? lt.compressedTexSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, 0, 0, Po.width, Po.height, po, Po.data) : lt.compressedTexImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, Fo, Po.width, Po.height, 0, Po.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, 0, 0, Po.width, Po.height, po, Ao, Po.data) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, Fo, Po.width, Po.height, 0, po, Ao, Po.data)
                                }
                            }
                        } else {
                            Co = kr.mipmaps,
                            Io && Jn && (Co.length > 0 && yl++,
                            lt.texStorage2D(Tt.TEXTURE_CUBE_MAP, yl, Fo, Pn[0].width, Pn[0].height));
                            for (let ho = 0; ho < 6; ho++)
                                if (to) {
                                    Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, 0, 0, Pn[ho].width, Pn[ho].height, po, Ao, Pn[ho].data) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, Fo, Pn[ho].width, Pn[ho].height, 0, po, Ao, Pn[ho].data);
                                    for (let Qo = 0; Qo < Co.length; Qo++) {
                                        const Po = Co[Qo].image[ho].image;
                                        Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, 0, 0, Po.width, Po.height, po, Ao, Po.data) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, Fo, Po.width, Po.height, 0, po, Ao, Po.data)
                                    }
                                } else {
                                    Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, 0, 0, po, Ao, Pn[ho]) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, Fo, po, Ao, Pn[ho]);
                                    for (let Qo = 0; Qo < Co.length; Qo++) {
                                        const Po = Co[Qo];
                                        Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, 0, 0, po, Ao, Po.image[ho]) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, Fo, po, Ao, Po.image[ho])
                                    }
                                }
                        }
                        br(kr, Kn) && yr(Tt.TEXTURE_CUBE_MAP),
                        Xr.__version = Lr.version,
                        kr.onUpdate && kr.onUpdate(kr)
                    }
                    Wr.__version = kr.version
                }(Fr, Dr, Sr) : lt.bindTexture(Tt.TEXTURE_CUBE_MAP, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            ,
            this.rebindTextures = function(Dr, Sr, Fr) {
                const Wr = mt.get(Dr);
                Sr !== void 0 && on(Wr.__webglFramebuffer, Dr, Dr.texture, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_2D, 0),
                Fr !== void 0 && ro(Dr)
            }
            ,
            this.setupRenderTarget = function(Dr) {
                const Sr = Dr.texture
                  , Fr = mt.get(Dr)
                  , Wr = mt.get(Sr);
                Dr.addEventListener("dispose", Gr),
                Dr.isWebGLMultipleRenderTargets !== !0 && (Wr.__webglTexture === void 0 && (Wr.__webglTexture = Tt.createTexture()),
                Wr.__version = Sr.version,
                Ct.memory.textures++);
                const kr = Dr.isWebGLCubeRenderTarget === !0
                  , _r = Dr.isWebGLMultipleRenderTargets === !0
                  , Br = xr(Dr) || Mt;
                if (kr) {
                    Fr.__webglFramebuffer = [];
                    for (let Lr = 0; Lr < 6; Lr++)
                        if (Mt && Sr.mipmaps && Sr.mipmaps.length > 0) {
                            Fr.__webglFramebuffer[Lr] = [];
                            for (let Xr = 0; Xr < Sr.mipmaps.length; Xr++)
                                Fr.__webglFramebuffer[Lr][Xr] = Tt.createFramebuffer()
                        } else
                            Fr.__webglFramebuffer[Lr] = Tt.createFramebuffer()
                } else {
                    if (Mt && Sr.mipmaps && Sr.mipmaps.length > 0) {
                        Fr.__webglFramebuffer = [];
                        for (let Lr = 0; Lr < Sr.mipmaps.length; Lr++)
                            Fr.__webglFramebuffer[Lr] = Tt.createFramebuffer()
                    } else
                        Fr.__webglFramebuffer = Tt.createFramebuffer();
                    if (_r)
                        if (ft.drawBuffers) {
                            const Lr = Dr.texture;
                            for (let Xr = 0, Kr = Lr.length; Xr < Kr; Xr++) {
                                const An = mt.get(Lr[Xr]);
                                An.__webglTexture === void 0 && (An.__webglTexture = Tt.createTexture(),
                                Ct.memory.textures++)
                            }
                        } else
                            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (Mt && Dr.samples > 0 && jn(Dr) === !1) {
                        const Lr = _r ? Sr : [Sr];
                        Fr.__webglMultisampledFramebuffer = Tt.createFramebuffer(),
                        Fr.__webglColorRenderbuffer = [],
                        lt.bindFramebuffer(Tt.FRAMEBUFFER, Fr.__webglMultisampledFramebuffer);
                        for (let Xr = 0; Xr < Lr.length; Xr++) {
                            const Kr = Lr[Xr];
                            Fr.__webglColorRenderbuffer[Xr] = Tt.createRenderbuffer(),
                            Tt.bindRenderbuffer(Tt.RENDERBUFFER, Fr.__webglColorRenderbuffer[Xr]);
                            const An = xt.convert(Kr.format, Kr.colorSpace)
                              , pn = xt.convert(Kr.type)
                              , _o = Pr(Kr.internalFormat, An, pn, Kr.colorSpace, Dr.isXRRenderTarget === !0)
                              , to = Zn(Dr);
                            Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, to, _o, Dr.width, Dr.height),
                            Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Xr, Tt.RENDERBUFFER, Fr.__webglColorRenderbuffer[Xr])
                        }
                        Tt.bindRenderbuffer(Tt.RENDERBUFFER, null),
                        Dr.depthBuffer && (Fr.__webglDepthRenderbuffer = Tt.createRenderbuffer(),
                        Un(Fr.__webglDepthRenderbuffer, Dr, !0)),
                        lt.bindFramebuffer(Tt.FRAMEBUFFER, null)
                    }
                }
                if (kr) {
                    lt.bindTexture(Tt.TEXTURE_CUBE_MAP, Wr.__webglTexture),
                    Yr(Tt.TEXTURE_CUBE_MAP, Sr, Br);
                    for (let Lr = 0; Lr < 6; Lr++)
                        if (Mt && Sr.mipmaps && Sr.mipmaps.length > 0)
                            for (let Xr = 0; Xr < Sr.mipmaps.length; Xr++)
                                on(Fr.__webglFramebuffer[Lr][Xr], Dr, Sr, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_CUBE_MAP_POSITIVE_X + Lr, Xr);
                        else
                            on(Fr.__webglFramebuffer[Lr], Dr, Sr, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_CUBE_MAP_POSITIVE_X + Lr, 0);
                    br(Sr, Br) && yr(Tt.TEXTURE_CUBE_MAP),
                    lt.unbindTexture()
                } else if (_r) {
                    const Lr = Dr.texture;
                    for (let Xr = 0, Kr = Lr.length; Xr < Kr; Xr++) {
                        const An = Lr[Xr]
                          , pn = mt.get(An);
                        lt.bindTexture(Tt.TEXTURE_2D, pn.__webglTexture),
                        Yr(Tt.TEXTURE_2D, An, Br),
                        on(Fr.__webglFramebuffer, Dr, An, Tt.COLOR_ATTACHMENT0 + Xr, Tt.TEXTURE_2D, 0),
                        br(An, Br) && yr(Tt.TEXTURE_2D)
                    }
                    lt.unbindTexture()
                } else {
                    let Lr = Tt.TEXTURE_2D;
                    if ((Dr.isWebGL3DRenderTarget || Dr.isWebGLArrayRenderTarget) && (Mt ? Lr = Dr.isWebGL3DRenderTarget ? Tt.TEXTURE_3D : Tt.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                    lt.bindTexture(Lr, Wr.__webglTexture),
                    Yr(Lr, Sr, Br),
                    Mt && Sr.mipmaps && Sr.mipmaps.length > 0)
                        for (let Xr = 0; Xr < Sr.mipmaps.length; Xr++)
                            on(Fr.__webglFramebuffer[Xr], Dr, Sr, Tt.COLOR_ATTACHMENT0, Lr, Xr);
                    else
                        on(Fr.__webglFramebuffer, Dr, Sr, Tt.COLOR_ATTACHMENT0, Lr, 0);
                    br(Sr, Br) && yr(Lr),
                    lt.unbindTexture()
                }
                Dr.depthBuffer && ro(Dr)
            }
            ,
            this.updateRenderTargetMipmap = function(Dr) {
                const Sr = xr(Dr) || Mt
                  , Fr = Dr.isWebGLMultipleRenderTargets === !0 ? Dr.texture : [Dr.texture]
                  , Wr = Dr.isWebGLCubeRenderTarget ? Tt.TEXTURE_CUBE_MAP : Tt.TEXTURE_2D;
                for (let kr = 0, _r = Fr.length; kr < _r; kr++) {
                    const Br = Fr[kr]
                      , Lr = mt.get(Br)
                      , Xr = Lr.__webglTexture;
                    Lr.__version !== Br.version && (lt.bindTexture(Wr, Xr),
                    Yr(Wr, Br, Sr),
                    lt.unbindTexture(),
                    Lr.__version = Br.version),
                    br(Br, Sr) && (lt.bindTexture(Wr, Xr),
                    yr(Wr),
                    lt.unbindTexture())
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(Dr) {
                if (Mt && Dr.samples > 0 && jn(Dr) === !1) {
                    const Sr = Dr.isWebGLMultipleRenderTargets ? Dr.texture : [Dr.texture]
                      , Fr = Dr.width
                      , Wr = Dr.height;
                    let kr = Tt.COLOR_BUFFER_BIT;
                    const _r = []
                      , Br = Dr.stencilBuffer ? Tt.DEPTH_STENCIL_ATTACHMENT : Tt.DEPTH_ATTACHMENT
                      , Lr = mt.get(Dr)
                      , Xr = Dr.isWebGLMultipleRenderTargets === !0;
                    if (Xr)
                        for (let Kr = 0; Kr < Sr.length; Kr++)
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglMultisampledFramebuffer),
                            Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.RENDERBUFFER, null),
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglFramebuffer),
                            Tt.framebufferTexture2D(Tt.DRAW_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.TEXTURE_2D, null, 0);
                    lt.bindFramebuffer(Tt.READ_FRAMEBUFFER, Lr.__webglMultisampledFramebuffer),
                    lt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, Lr.__webglFramebuffer);
                    for (let Kr = 0; Kr < Sr.length; Kr++) {
                        _r.push(Tt.COLOR_ATTACHMENT0 + Kr),
                        Dr.depthBuffer && _r.push(Br);
                        const An = Lr.__ignoreDepthValues !== void 0 && Lr.__ignoreDepthValues;
                        if (An === !1 && (Dr.depthBuffer && (kr |= Tt.DEPTH_BUFFER_BIT),
                        Dr.stencilBuffer && (kr |= Tt.STENCIL_BUFFER_BIT)),
                        Xr && Tt.framebufferRenderbuffer(Tt.READ_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, Tt.RENDERBUFFER, Lr.__webglColorRenderbuffer[Kr]),
                        An === !0 && (Tt.invalidateFramebuffer(Tt.READ_FRAMEBUFFER, [Br]),
                        Tt.invalidateFramebuffer(Tt.DRAW_FRAMEBUFFER, [Br])),
                        Xr) {
                            const pn = mt.get(Sr[Kr]).__webglTexture;
                            Tt.framebufferTexture2D(Tt.DRAW_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_2D, pn, 0)
                        }
                        Tt.blitFramebuffer(0, 0, Fr, Wr, 0, 0, Fr, Wr, kr, Tt.NEAREST),
                        qt && Tt.invalidateFramebuffer(Tt.READ_FRAMEBUFFER, _r)
                    }
                    if (lt.bindFramebuffer(Tt.READ_FRAMEBUFFER, null),
                    lt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, null),
                    Xr)
                        for (let Kr = 0; Kr < Sr.length; Kr++) {
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglMultisampledFramebuffer),
                            Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.RENDERBUFFER, Lr.__webglColorRenderbuffer[Kr]);
                            const An = mt.get(Sr[Kr]).__webglTexture;
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglFramebuffer),
                            Tt.framebufferTexture2D(Tt.DRAW_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.TEXTURE_2D, An, 0)
                        }
                    lt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, Lr.__webglMultisampledFramebuffer)
                }
            }
            ,
            this.setupDepthRenderbuffer = ro,
            this.setupFrameBufferTexture = on,
            this.useMultisampledRTT = jn
        }
        function _x(Tt, tt, lt) {
            const mt = lt.isWebGL2;
            return {
                convert: function(ft, xt=Oo) {
                    let Ct;
                    const Mt = Do.getTransfer(xt);
                    if (ft === $n)
                        return Tt.UNSIGNED_BYTE;
                    if (ft === $l)
                        return Tt.UNSIGNED_SHORT_4_4_4_4;
                    if (ft === wl)
                        return Tt.UNSIGNED_SHORT_5_5_5_1;
                    if (ft === ao)
                        return Tt.BYTE;
                    if (ft === zo)
                        return Tt.SHORT;
                    if (ft === Zo)
                        return Tt.UNSIGNED_SHORT;
                    if (ft === $o)
                        return Tt.INT;
                    if (ft === Yo)
                        return Tt.UNSIGNED_INT;
                    if (ft === ss)
                        return Tt.FLOAT;
                    if (ft === Os)
                        return mt ? Tt.HALF_FLOAT : (Ct = tt.get("OES_texture_half_float"),
                        Ct !== null ? Ct.HALF_FLOAT_OES : null);
                    if (ft === ys)
                        return Tt.ALPHA;
                    if (ft === as)
                        return Tt.RGBA;
                    if (ft === Ln)
                        return Tt.LUMINANCE;
                    if (ft === Vn)
                        return Tt.LUMINANCE_ALPHA;
                    if (ft === Ys)
                        return Tt.DEPTH_COMPONENT;
                    if (ft === Eo)
                        return Tt.DEPTH_STENCIL;
                    if (ft === _h)
                        return Ct = tt.get("EXT_sRGB"),
                        Ct !== null ? Ct.SRGB_ALPHA_EXT : null;
                    if (ft === Sl)
                        return Tt.RED;
                    if (ft === Ks)
                        return Tt.RED_INTEGER;
                    if (ft === ds)
                        return Tt.RG;
                    if (ft === yo)
                        return Tt.RG_INTEGER;
                    if (ft === ko)
                        return Tt.RGBA_INTEGER;
                    if (ft === xs || ft === Js || ft === bs || ft === Bl)
                        if (Mt === Vo) {
                            if (Ct = tt.get("WEBGL_compressed_texture_s3tc_srgb"),
                            Ct === null)
                                return null;
                            if (ft === xs)
                                return Ct.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (ft === Js)
                                return Ct.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (ft === bs)
                                return Ct.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (ft === Bl)
                                return Ct.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (Ct = tt.get("WEBGL_compressed_texture_s3tc"),
                            Ct === null)
                                return null;
                            if (ft === xs)
                                return Ct.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (ft === Js)
                                return Ct.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (ft === bs)
                                return Ct.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (ft === Bl)
                                return Ct.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (ft === Bm || ft === Vp || ft === Lm || ft === Om) {
                        if (Ct = tt.get("WEBGL_compressed_texture_pvrtc"),
                        Ct === null)
                            return null;
                        if (ft === Bm)
                            return Ct.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (ft === Vp)
                            return Ct.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (ft === Lm)
                            return Ct.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (ft === Om)
                            return Ct.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (ft === G_)
                        return Ct = tt.get("WEBGL_compressed_texture_etc1"),
                        Ct !== null ? Ct.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (ft === lu || ft === Zs) {
                        if (Ct = tt.get("WEBGL_compressed_texture_etc"),
                        Ct === null)
                            return null;
                        if (ft === lu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ETC2 : Ct.COMPRESSED_RGB8_ETC2;
                        if (ft === Zs)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : Ct.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (ft === Xl || ft === cu || ft === Gp || ft === Ru || ft === op || ft === Nm || ft === uu || ft === zp || ft === Fm || ft === Hp || ft === Qp || ft === Um || ft === Iu || ft === Wp) {
                        if (Ct = tt.get("WEBGL_compressed_texture_astc"),
                        Ct === null)
                            return null;
                        if (ft === Xl)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : Ct.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (ft === cu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : Ct.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (ft === Gp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : Ct.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (ft === Ru)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : Ct.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (ft === op)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : Ct.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (ft === Nm)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : Ct.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (ft === uu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : Ct.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (ft === zp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : Ct.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (ft === Fm)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : Ct.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (ft === Hp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : Ct.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (ft === Qp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : Ct.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (ft === Um)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : Ct.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (ft === Iu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : Ct.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (ft === Wp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : Ct.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (ft === sp || ft === jm || ft === Vm) {
                        if (Ct = tt.get("EXT_texture_compression_bptc"),
                        Ct === null)
                            return null;
                        if (ft === sp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : Ct.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (ft === jm)
                            return Ct.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (ft === Vm)
                            return Ct.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (ft === z_ || ft === Gm || ft === zm || ft === ap) {
                        if (Ct = tt.get("EXT_texture_compression_rgtc"),
                        Ct === null)
                            return null;
                        if (ft === sp)
                            return Ct.COMPRESSED_RED_RGTC1_EXT;
                        if (ft === Gm)
                            return Ct.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (ft === zm)
                            return Ct.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (ft === ap)
                            return Ct.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return ft === Ps ? mt ? Tt.UNSIGNED_INT_24_8 : (Ct = tt.get("WEBGL_depth_texture"),
                    Ct !== null ? Ct.UNSIGNED_INT_24_8_WEBGL : null) : Tt[ft] !== void 0 ? Tt[ft] : null
                }
            }
        }
        class vx extends Cs {
            constructor(tt=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = tt
            }
        }
        class Am extends Mo {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const eS = {
            type: "move"
        };
        class W0 {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return this._hand === null && (this._hand = new Am,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return this._targetRay === null && (this._targetRay = new Am,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new Er,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new Er),
                this._targetRay
            }
            getGripSpace() {
                return this._grip === null && (this._grip = new Am,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new Er,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new Er),
                this._grip
            }
            dispatchEvent(tt) {
                return this._targetRay !== null && this._targetRay.dispatchEvent(tt),
                this._grip !== null && this._grip.dispatchEvent(tt),
                this._hand !== null && this._hand.dispatchEvent(tt),
                this
            }
            connect(tt) {
                if (tt && tt.hand) {
                    const lt = this._hand;
                    if (lt)
                        for (const mt of tt.hand.values())
                            this._getHandJoint(lt, mt)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: tt
                }),
                this
            }
            disconnect(tt) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: tt
                }),
                this._targetRay !== null && (this._targetRay.visible = !1),
                this._grip !== null && (this._grip.visible = !1),
                this._hand !== null && (this._hand.visible = !1),
                this
            }
            update(tt, lt, mt) {
                let ft = null
                  , xt = null
                  , Ct = null;
                const Mt = this._targetRay
                  , Lt = this._grip
                  , Nt = this._hand;
                if (tt && lt.session.visibilityState !== "visible-blurred") {
                    if (Nt && tt.hand) {
                        Ct = !0;
                        for (const Zt of tt.hand.values()) {
                            const Yt = lt.getJointPose(Zt, mt)
                              , sr = this._getHandJoint(Nt, Zt);
                            Yt !== null && (sr.matrix.fromArray(Yt.transform.matrix),
                            sr.matrix.decompose(sr.position, sr.rotation, sr.scale),
                            sr.matrixWorldNeedsUpdate = !0,
                            sr.jointRadius = Yt.radius),
                            sr.visible = Yt !== null
                        }
                        const jt = Nt.joints["index-finger-tip"]
                          , Wt = Nt.joints["thumb-tip"]
                          , Qt = jt.position.distanceTo(Wt.position)
                          , qt = .02
                          , Xt = .005;
                        Nt.inputState.pinching && Qt > qt + Xt ? (Nt.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: tt.handedness,
                            target: this
                        })) : !Nt.inputState.pinching && Qt <= qt - Xt && (Nt.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: tt.handedness,
                            target: this
                        }))
                    } else
                        Lt !== null && tt.gripSpace && (xt = lt.getPose(tt.gripSpace, mt),
                        xt !== null && (Lt.matrix.fromArray(xt.transform.matrix),
                        Lt.matrix.decompose(Lt.position, Lt.rotation, Lt.scale),
                        Lt.matrixWorldNeedsUpdate = !0,
                        xt.linearVelocity ? (Lt.hasLinearVelocity = !0,
                        Lt.linearVelocity.copy(xt.linearVelocity)) : Lt.hasLinearVelocity = !1,
                        xt.angularVelocity ? (Lt.hasAngularVelocity = !0,
                        Lt.angularVelocity.copy(xt.angularVelocity)) : Lt.hasAngularVelocity = !1));
                    Mt !== null && (ft = lt.getPose(tt.targetRaySpace, mt),
                    ft === null && xt !== null && (ft = xt),
                    ft !== null && (Mt.matrix.fromArray(ft.transform.matrix),
                    Mt.matrix.decompose(Mt.position, Mt.rotation, Mt.scale),
                    Mt.matrixWorldNeedsUpdate = !0,
                    ft.linearVelocity ? (Mt.hasLinearVelocity = !0,
                    Mt.linearVelocity.copy(ft.linearVelocity)) : Mt.hasLinearVelocity = !1,
                    ft.angularVelocity ? (Mt.hasAngularVelocity = !0,
                    Mt.angularVelocity.copy(ft.angularVelocity)) : Mt.hasAngularVelocity = !1,
                    this.dispatchEvent(eS)))
                }
                return Mt !== null && (Mt.visible = ft !== null),
                Lt !== null && (Lt.visible = xt !== null),
                Nt !== null && (Nt.visible = Ct !== null),
                this
            }
            _getHandJoint(tt, lt) {
                if (tt.joints[lt.jointName] === void 0) {
                    const mt = new Am;
                    mt.matrixAutoUpdate = !1,
                    mt.visible = !1,
                    tt.joints[lt.jointName] = mt,
                    tt.add(mt)
                }
                return tt.joints[lt.jointName]
            }
        }
        class yx extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt) {
                if ((jt = jt !== void 0 ? jt : Ys) !== Ys && jt !== Eo)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                mt === void 0 && jt === Ys && (mt = Yo),
                mt === void 0 && jt === Eo && (mt = Ps),
                super(null, ft, xt, Ct, Mt, Lt, jt, mt, Nt),
                this.isDepthTexture = !0,
                this.image = {
                    width: tt,
                    height: lt
                },
                this.magFilter = Mt !== void 0 ? Mt : fn,
                this.minFilter = Lt !== void 0 ? Lt : fn,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(tt) {
                return super.copy(tt),
                this.compareFunction = tt.compareFunction,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return this.compareFunction !== null && (lt.compareFunction = this.compareFunction),
                lt
            }
        }
        class tS extends As {
            constructor(tt, lt) {
                super();
                const mt = this;
                let ft = null
                  , xt = 1
                  , Ct = null
                  , Mt = "local-floor"
                  , Lt = 1
                  , Nt = null
                  , jt = null
                  , Wt = null
                  , Qt = null
                  , qt = null
                  , Xt = null;
                const Zt = lt.getContextAttributes();
                let Yt = null
                  , sr = null;
                const er = []
                  , rr = []
                  , xr = new Cs;
                xr.layers.enable(1),
                xr.viewport = new Lo;
                const br = new Cs;
                br.layers.enable(2),
                br.viewport = new Lo;
                const yr = [xr, br]
                  , Pr = new vx;
                Pr.layers.enable(1),
                Pr.layers.enable(2);
                let zr = null
                  , Nr = null;
                function Vr(Yr) {
                    const Jr = rr.indexOf(Yr.inputSource);
                    if (Jr === -1)
                        return;
                    const sn = er[Jr];
                    sn !== void 0 && (sn.update(Yr.inputSource, Yr.frame, Nt || Ct),
                    sn.dispatchEvent({
                        type: Yr.type,
                        data: Yr.inputSource
                    }))
                }
                function Gr() {
                    ft.removeEventListener("select", Vr),
                    ft.removeEventListener("selectstart", Vr),
                    ft.removeEventListener("selectend", Vr),
                    ft.removeEventListener("squeeze", Vr),
                    ft.removeEventListener("squeezestart", Vr),
                    ft.removeEventListener("squeezeend", Vr),
                    ft.removeEventListener("end", Gr),
                    ft.removeEventListener("inputsourceschange", Hr);
                    for (let Yr = 0; Yr < er.length; Yr++) {
                        const Jr = rr[Yr];
                        Jr !== null && (rr[Yr] = null,
                        er[Yr].disconnect(Jr))
                    }
                    zr = null,
                    Nr = null,
                    tt.setRenderTarget(Yt),
                    qt = null,
                    Qt = null,
                    Wt = null,
                    ft = null,
                    sr = null,
                    cn.stop(),
                    mt.isPresenting = !1,
                    mt.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function Hr(Yr) {
                    for (let Jr = 0; Jr < Yr.removed.length; Jr++) {
                        const sn = Yr.removed[Jr]
                          , on = rr.indexOf(sn);
                        on >= 0 && (rr[on] = null,
                        er[on].disconnect(sn))
                    }
                    for (let Jr = 0; Jr < Yr.added.length; Jr++) {
                        const sn = Yr.added[Jr];
                        let on = rr.indexOf(sn);
                        if (on === -1) {
                            for (let ro = 0; ro < er.length; ro++) {
                                if (ro >= rr.length) {
                                    rr.push(sn),
                                    on = ro;
                                    break
                                }
                                if (rr[ro] === null) {
                                    rr[ro] = sn,
                                    on = ro;
                                    break
                                }
                            }
                            if (on === -1)
                                break
                        }
                        const Un = er[on];
                        Un && Un.connect(sn)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(Yr) {
                    let Jr = er[Yr];
                    return Jr === void 0 && (Jr = new W0,
                    er[Yr] = Jr),
                    Jr.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(Yr) {
                    let Jr = er[Yr];
                    return Jr === void 0 && (Jr = new W0,
                    er[Yr] = Jr),
                    Jr.getGripSpace()
                }
                ,
                this.getHand = function(Yr) {
                    let Jr = er[Yr];
                    return Jr === void 0 && (Jr = new W0,
                    er[Yr] = Jr),
                    Jr.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(Yr) {
                    xt = Yr,
                    mt.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(Yr) {
                    Mt = Yr,
                    mt.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return Nt || Ct
                }
                ,
                this.setReferenceSpace = function(Yr) {
                    Nt = Yr
                }
                ,
                this.getBaseLayer = function() {
                    return Qt !== null ? Qt : qt
                }
                ,
                this.getBinding = function() {
                    return Wt
                }
                ,
                this.getFrame = function() {
                    return Xt
                }
                ,
                this.getSession = function() {
                    return ft
                }
                ,
                this.setSession = async function(Yr) {
                    if (ft = Yr,
                    ft !== null) {
                        if (Yt = tt.getRenderTarget(),
                        ft.addEventListener("select", Vr),
                        ft.addEventListener("selectstart", Vr),
                        ft.addEventListener("selectend", Vr),
                        ft.addEventListener("squeeze", Vr),
                        ft.addEventListener("squeezestart", Vr),
                        ft.addEventListener("squeezeend", Vr),
                        ft.addEventListener("end", Gr),
                        ft.addEventListener("inputsourceschange", Hr),
                        Zt.xrCompatible !== !0 && await lt.makeXRCompatible(),
                        ft.renderState.layers === void 0 || tt.capabilities.isWebGL2 === !1) {
                            const Jr = {
                                antialias: ft.renderState.layers !== void 0 || Zt.antialias,
                                alpha: !0,
                                depth: Zt.depth,
                                stencil: Zt.stencil,
                                framebufferScaleFactor: xt
                            };
                            qt = new XRWebGLLayer(ft,lt,Jr),
                            ft.updateRenderState({
                                baseLayer: qt
                            }),
                            sr = new Rs(qt.framebufferWidth,qt.framebufferHeight,{
                                format: as,
                                type: $n,
                                colorSpace: tt.outputColorSpace,
                                stencilBuffer: Zt.stencil
                            })
                        } else {
                            let Jr = null
                              , sn = null
                              , on = null;
                            Zt.depth && (on = Zt.stencil ? lt.DEPTH24_STENCIL8 : lt.DEPTH_COMPONENT24,
                            Jr = Zt.stencil ? Eo : Ys,
                            sn = Zt.stencil ? Ps : Yo);
                            const Un = {
                                colorFormat: lt.RGBA8,
                                depthFormat: on,
                                scaleFactor: xt
                            };
                            Wt = new XRWebGLBinding(ft,lt),
                            Qt = Wt.createProjectionLayer(Un),
                            ft.updateRenderState({
                                layers: [Qt]
                            }),
                            sr = new Rs(Qt.textureWidth,Qt.textureHeight,{
                                format: as,
                                type: $n,
                                depthTexture: new yx(Qt.textureWidth,Qt.textureHeight,sn,void 0,void 0,void 0,void 0,void 0,void 0,Jr),
                                stencilBuffer: Zt.stencil,
                                colorSpace: tt.outputColorSpace,
                                samples: Zt.antialias ? 4 : 0
                            }),
                            tt.properties.get(sr).__ignoreDepthValues = Qt.ignoreDepthValues
                        }
                        sr.isXRRenderTarget = !0,
                        this.setFoveation(Lt),
                        Nt = null,
                        Ct = await ft.requestReferenceSpace(Mt),
                        cn.setContext(ft),
                        cn.start(),
                        mt.isPresenting = !0,
                        mt.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (ft !== null)
                        return ft.environmentBlendMode
                }
                ;
                const _n = new Er
                  , dn = new Er;
                function kn(Yr, Jr) {
                    Jr === null ? Yr.matrixWorld.copy(Yr.matrix) : Yr.matrixWorld.multiplyMatrices(Jr.matrixWorld, Yr.matrix),
                    Yr.matrixWorldInverse.copy(Yr.matrixWorld).invert()
                }
                this.updateCamera = function(Yr) {
                    if (ft === null)
                        return;
                    Pr.near = br.near = xr.near = Yr.near,
                    Pr.far = br.far = xr.far = Yr.far,
                    zr === Pr.near && Nr === Pr.far || (ft.updateRenderState({
                        depthNear: Pr.near,
                        depthFar: Pr.far
                    }),
                    zr = Pr.near,
                    Nr = Pr.far);
                    const Jr = Yr.parent
                      , sn = Pr.cameras;
                    kn(Pr, Jr);
                    for (let on = 0; on < sn.length; on++)
                        kn(sn[on], Jr);
                    sn.length === 2 ? function(on, Un, ro) {
                        _n.setFromMatrixPosition(Un.matrixWorld),
                        dn.setFromMatrixPosition(ro.matrixWorld);
                        const Zn = _n.distanceTo(dn)
                          , jn = Un.projectionMatrix.elements
                          , uo = ro.projectionMatrix.elements
                          , Dr = jn[14] / (jn[10] - 1)
                          , Sr = jn[14] / (jn[10] + 1)
                          , Fr = (jn[9] + 1) / jn[5]
                          , Wr = (jn[9] - 1) / jn[5]
                          , kr = (jn[8] - 1) / jn[0]
                          , _r = (uo[8] + 1) / uo[0]
                          , Br = Dr * kr
                          , Lr = Dr * _r
                          , Xr = Zn / (-kr + _r)
                          , Kr = Xr * -kr;
                        Un.matrixWorld.decompose(on.position, on.quaternion, on.scale),
                        on.translateX(Kr),
                        on.translateZ(Xr),
                        on.matrixWorld.compose(on.position, on.quaternion, on.scale),
                        on.matrixWorldInverse.copy(on.matrixWorld).invert();
                        const An = Dr + Xr
                          , pn = Sr + Xr
                          , _o = Br - Kr
                          , to = Lr + (Zn - Kr)
                          , Pn = Fr * Sr / pn * An
                          , eo = Wr * Sr / pn * An;
                        on.projectionMatrix.makePerspective(_o, to, Pn, eo, An, pn),
                        on.projectionMatrixInverse.copy(on.projectionMatrix).invert()
                    }(Pr, xr, br) : Pr.projectionMatrix.copy(xr.projectionMatrix),
                    function(on, Un, ro) {
                        ro === null ? on.matrix.copy(Un.matrixWorld) : (on.matrix.copy(ro.matrixWorld),
                        on.matrix.invert(),
                        on.matrix.multiply(Un.matrixWorld)),
                        on.matrix.decompose(on.position, on.quaternion, on.scale),
                        on.updateMatrixWorld(!0),
                        on.projectionMatrix.copy(Un.projectionMatrix),
                        on.projectionMatrixInverse.copy(Un.projectionMatrixInverse),
                        on.isPerspectiveCamera && (on.fov = 2 * _u * Math.atan(1 / on.projectionMatrix.elements[5]),
                        on.zoom = 1)
                    }(Yr, Pr, Jr)
                }
                ,
                this.getCamera = function() {
                    return Pr
                }
                ,
                this.getFoveation = function() {
                    if (Qt !== null || qt !== null)
                        return Lt
                }
                ,
                this.setFoveation = function(Yr) {
                    Lt = Yr,
                    Qt !== null && (Qt.fixedFoveation = Yr),
                    qt !== null && qt.fixedFoveation !== void 0 && (qt.fixedFoveation = Yr)
                }
                ;
                let Bn = null;
                this.onPreAnimationFrameCallback = null;
                const cn = new Hy;
                cn.setAnimationLoop(function(Yr, Jr) {
                    if (mt.onPreAnimationFrameCallback && mt.onPreAnimationFrameCallback(Yr, Jr),
                    jt = Jr.getViewerPose(Nt || Ct),
                    Xt = Jr,
                    jt !== null) {
                        const sn = jt.views;
                        qt !== null && (tt.setRenderTargetFramebuffer(sr, qt.framebuffer),
                        tt.setRenderTarget(sr));
                        let on = !1;
                        sn.length !== Pr.cameras.length && (Pr.cameras.length = 0,
                        on = !0);
                        for (let Un = 0; Un < sn.length; Un++) {
                            const ro = sn[Un];
                            let Zn = null;
                            if (qt !== null)
                                Zn = qt.getViewport(ro);
                            else {
                                const uo = Wt.getViewSubImage(Qt, ro);
                                Zn = uo.viewport,
                                Un === 0 && (tt.setRenderTargetTextures(sr, uo.colorTexture, Qt.ignoreDepthValues ? void 0 : uo.depthStencilTexture),
                                tt.setRenderTarget(sr))
                            }
                            let jn = yr[Un];
                            jn === void 0 && (jn = new Cs,
                            jn.layers.enable(Un),
                            jn.viewport = new Lo,
                            yr[Un] = jn),
                            jn.matrix.fromArray(ro.transform.matrix),
                            jn.matrix.decompose(jn.position, jn.quaternion, jn.scale),
                            jn.projectionMatrix.fromArray(ro.projectionMatrix),
                            jn.projectionMatrixInverse.copy(jn.projectionMatrix).invert(),
                            jn.viewport.set(Zn.x, Zn.y, Zn.width, Zn.height),
                            Un === 0 && (Pr.matrix.copy(jn.matrix),
                            Pr.matrix.decompose(Pr.position, Pr.quaternion, Pr.scale)),
                            on === !0 && Pr.cameras.push(jn)
                        }
                    }
                    for (let sn = 0; sn < er.length; sn++) {
                        const on = rr[sn]
                          , Un = er[sn];
                        on !== null && Un !== void 0 && Un.update(on, Jr, Nt || Ct)
                    }
                    Bn && Bn(Yr, Jr),
                    Jr.detectedPlanes && mt.dispatchEvent({
                        type: "planesdetected",
                        data: Jr
                    }),
                    Xt = null
                }),
                this.setAnimationLoop = function(Yr) {
                    Bn = Yr
                }
                ,
                this.dispose = function() {}
            }
        }
        function rS(Tt, tt) {
            function lt(ft, xt) {
                ft.matrixAutoUpdate === !0 && ft.updateMatrix(),
                xt.value.copy(ft.matrix)
            }
            function mt(ft, xt) {
                ft.opacity.value = xt.opacity,
                xt.color && ft.diffuse.value.copy(xt.color),
                xt.emissive && ft.emissive.value.copy(xt.emissive).multiplyScalar(xt.emissiveIntensity),
                xt.map && (ft.map.value = xt.map,
                lt(xt.map, ft.mapTransform)),
                xt.alphaMap && (ft.alphaMap.value = xt.alphaMap,
                lt(xt.alphaMap, ft.alphaMapTransform)),
                xt.bumpMap && (ft.bumpMap.value = xt.bumpMap,
                lt(xt.bumpMap, ft.bumpMapTransform),
                ft.bumpScale.value = xt.bumpScale,
                xt.side === bt && (ft.bumpScale.value *= -1)),
                xt.normalMap && (ft.normalMap.value = xt.normalMap,
                lt(xt.normalMap, ft.normalMapTransform),
                ft.normalScale.value.copy(xt.normalScale),
                xt.side === bt && ft.normalScale.value.negate()),
                xt.displacementMap && (ft.displacementMap.value = xt.displacementMap,
                lt(xt.displacementMap, ft.displacementMapTransform),
                ft.displacementScale.value = xt.displacementScale,
                ft.displacementBias.value = xt.displacementBias),
                xt.emissiveMap && (ft.emissiveMap.value = xt.emissiveMap,
                lt(xt.emissiveMap, ft.emissiveMapTransform)),
                xt.specularMap && (ft.specularMap.value = xt.specularMap,
                lt(xt.specularMap, ft.specularMapTransform)),
                xt.alphaTest > 0 && (ft.alphaTest.value = xt.alphaTest);
                const Ct = tt.get(xt).envMap;
                if (Ct) {
                    ft.envMap.value = Ct;
                    const Mt = xt.envMap || tt.get(xt).environment || Ct;
                    ft.envMapRotation.value = Mt ? Mt.rotation : 0,
                    ft.flipEnvMap.value = Ct.isCubeTexture && Ct.isRenderTargetTexture === !1 ? -1 : 1,
                    ft.reflectivity.value = xt.reflectivity,
                    ft.ior.value = xt.ior,
                    ft.refractionRatio.value = xt.refractionRatio
                }
                if (xt.lightMap) {
                    ft.lightMap.value = xt.lightMap;
                    const Mt = Tt._useLegacyLights === !0 ? Math.PI : 1;
                    ft.lightMapIntensity.value = xt.lightMapIntensity * Mt,
                    lt(xt.lightMap, ft.lightMapTransform)
                }
                xt.aoMap && (ft.aoMap.value = xt.aoMap,
                ft.aoMapIntensity.value = xt.aoMapIntensity,
                lt(xt.aoMap, ft.aoMapTransform))
            }
            return {
                refreshTransformUniform: lt,
                refreshFogUniforms: function(ft, xt) {
                    xt.color.getRGB(ft.fogColor.value, jy(Tt)),
                    xt.isFog ? (ft.fogNear.value = xt.near,
                    ft.fogFar.value = xt.far) : xt.isFogExp2 && (ft.fogDensity.value = xt.density)
                },
                refreshMaterialUniforms: function(ft, xt, Ct, Mt, Lt) {
                    xt.isMeshBasicMaterial || xt.isMeshLambertMaterial ? mt(ft, xt) : xt.isMeshToonMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        jt.gradientMap && (Nt.gradientMap.value = jt.gradientMap)
                    }(ft, xt)) : xt.isMeshPhongMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        Nt.specular.value.copy(jt.specular),
                        Nt.shininess.value = Math.max(jt.shininess, 1e-4)
                    }(ft, xt)) : xt.isMeshStandardMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        Nt.metalness.value = jt.metalness,
                        jt.metalnessMap && (Nt.metalnessMap.value = jt.metalnessMap,
                        lt(jt.metalnessMap, Nt.metalnessMapTransform)),
                        Nt.roughness.value = jt.roughness,
                        jt.roughnessMap && (Nt.roughnessMap.value = jt.roughnessMap,
                        lt(jt.roughnessMap, Nt.roughnessMapTransform)),
                        tt.get(jt).envMap && (Nt.envMapIntensity.value = jt.envMapIntensity)
                    }(ft, xt),
                    xt.isMeshPhysicalMaterial && function(Nt, jt, Wt) {
                        Nt.ior.value = jt.ior,
                        jt.sheen > 0 && (Nt.sheenColor.value.copy(jt.sheenColor).multiplyScalar(jt.sheen),
                        Nt.sheenRoughness.value = jt.sheenRoughness,
                        jt.sheenColorMap && (Nt.sheenColorMap.value = jt.sheenColorMap,
                        lt(jt.sheenColorMap, Nt.sheenColorMapTransform)),
                        jt.sheenRoughnessMap && (Nt.sheenRoughnessMap.value = jt.sheenRoughnessMap,
                        lt(jt.sheenRoughnessMap, Nt.sheenRoughnessMapTransform))),
                        jt.clearcoat > 0 && (Nt.clearcoat.value = jt.clearcoat,
                        Nt.clearcoatRoughness.value = jt.clearcoatRoughness,
                        jt.clearcoatMap && (Nt.clearcoatMap.value = jt.clearcoatMap,
                        lt(jt.clearcoatMap, Nt.clearcoatMapTransform)),
                        jt.clearcoatRoughnessMap && (Nt.clearcoatRoughnessMap.value = jt.clearcoatRoughnessMap,
                        lt(jt.clearcoatRoughnessMap, Nt.clearcoatRoughnessMapTransform)),
                        jt.clearcoatNormalMap && (Nt.clearcoatNormalMap.value = jt.clearcoatNormalMap,
                        lt(jt.clearcoatNormalMap, Nt.clearcoatNormalMapTransform),
                        Nt.clearcoatNormalScale.value.copy(jt.clearcoatNormalScale),
                        jt.side === bt && Nt.clearcoatNormalScale.value.negate())),
                        jt.iridescence > 0 && (Nt.iridescence.value = jt.iridescence,
                        Nt.iridescenceIOR.value = jt.iridescenceIOR,
                        Nt.iridescenceThicknessMinimum.value = jt.iridescenceThicknessRange[0],
                        Nt.iridescenceThicknessMaximum.value = jt.iridescenceThicknessRange[1],
                        jt.iridescenceMap && (Nt.iridescenceMap.value = jt.iridescenceMap,
                        lt(jt.iridescenceMap, Nt.iridescenceMapTransform)),
                        jt.iridescenceThicknessMap && (Nt.iridescenceThicknessMap.value = jt.iridescenceThicknessMap,
                        lt(jt.iridescenceThicknessMap, Nt.iridescenceThicknessMapTransform))),
                        jt.transmission > 0 && (Nt.transmission.value = jt.transmission,
                        Nt.transmissionSamplerMap.value = Wt.texture,
                        Nt.transmissionSamplerSize.value.set(Wt.width, Wt.height),
                        jt.transmissionMap && (Nt.transmissionMap.value = jt.transmissionMap,
                        lt(jt.transmissionMap, Nt.transmissionMapTransform)),
                        Nt.thickness.value = jt.thickness,
                        jt.thicknessMap && (Nt.thicknessMap.value = jt.thicknessMap,
                        lt(jt.thicknessMap, Nt.thicknessMapTransform)),
                        Nt.attenuationDistance.value = jt.attenuationDistance,
                        Nt.attenuationColor.value.copy(jt.attenuationColor)),
                        jt.anisotropy > 0 && (Nt.anisotropyVector.value.set(jt.anisotropy * Math.cos(jt.anisotropyRotation), jt.anisotropy * Math.sin(jt.anisotropyRotation)),
                        jt.anisotropyMap && (Nt.anisotropyMap.value = jt.anisotropyMap,
                        lt(jt.anisotropyMap, Nt.anisotropyMapTransform))),
                        Nt.specularIntensity.value = jt.specularIntensity,
                        Nt.specularColor.value.copy(jt.specularColor),
                        jt.specularColorMap && (Nt.specularColorMap.value = jt.specularColorMap,
                        lt(jt.specularColorMap, Nt.specularColorMapTransform)),
                        jt.specularIntensityMap && (Nt.specularIntensityMap.value = jt.specularIntensityMap,
                        lt(jt.specularIntensityMap, Nt.specularIntensityMapTransform))
                    }(ft, xt, Lt)) : xt.isMeshMatcapMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        jt.matcap && (Nt.matcap.value = jt.matcap)
                    }(ft, xt)) : xt.isMeshDepthMaterial ? mt(ft, xt) : xt.isMeshDistanceMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        const Wt = tt.get(jt).light;
                        Nt.referencePosition.value.setFromMatrixPosition(Wt.matrixWorld),
                        Nt.nearDistance.value = Wt.shadow.camera.near,
                        Nt.farDistance.value = Wt.shadow.camera.far
                    }(ft, xt)) : xt.isMeshNormalMaterial ? mt(ft, xt) : xt.isLineBasicMaterial ? (function(Nt, jt) {
                        Nt.diffuse.value.copy(jt.color),
                        Nt.opacity.value = jt.opacity,
                        jt.map && (Nt.map.value = jt.map,
                        lt(jt.map, Nt.mapTransform))
                    }(ft, xt),
                    xt.isLineDashedMaterial && function(Nt, jt) {
                        Nt.dashSize.value = jt.dashSize,
                        Nt.totalSize.value = jt.dashSize + jt.gapSize,
                        Nt.scale.value = jt.scale
                    }(ft, xt)) : xt.isPointsMaterial ? function(Nt, jt, Wt, Qt) {
                        Nt.diffuse.value.copy(jt.color),
                        Nt.opacity.value = jt.opacity,
                        Nt.size.value = jt.size * Wt,
                        Nt.scale.value = .5 * Qt,
                        jt.map && (Nt.map.value = jt.map,
                        lt(jt.map, Nt.uvTransform)),
                        jt.alphaMap && (Nt.alphaMap.value = jt.alphaMap,
                        lt(jt.alphaMap, Nt.alphaMapTransform)),
                        jt.alphaTest > 0 && (Nt.alphaTest.value = jt.alphaTest)
                    }(ft, xt, Ct, Mt) : xt.isSpriteMaterial ? function(Nt, jt) {
                        Nt.diffuse.value.copy(jt.color),
                        Nt.opacity.value = jt.opacity,
                        Nt.rotation.value = jt.rotation,
                        jt.map && (Nt.map.value = jt.map,
                        lt(jt.map, Nt.mapTransform)),
                        jt.alphaMap && (Nt.alphaMap.value = jt.alphaMap,
                        lt(jt.alphaMap, Nt.alphaMapTransform)),
                        jt.alphaTest > 0 && (Nt.alphaTest.value = jt.alphaTest)
                    }(ft, xt) : xt.isShadowMaterial ? (ft.color.value.copy(xt.color),
                    ft.opacity.value = xt.opacity) : xt.isShaderMaterial && (xt.transmission !== void 0 && (ft.transmission && (ft.transmission.value = xt.transmission),
                    ft.transmissionSamplerMap && Lt && (ft.transmissionSamplerMap.value = Lt ? Lt.texture : null),
                    ft.transmissionSamplerSize && Lt && ft.transmissionSamplerSize.value.set(Lt.width, Lt.height)),
                    xt.uniformsNeedUpdate = !1)
                }
            }
        }
        function nS(Tt, tt, lt, mt) {
            let ft = {}
              , xt = {}
              , Ct = [];
            const Mt = lt.isWebGL2 ? Tt.getParameter(Tt.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
            function Lt(Wt, Qt, qt) {
                const Xt = Wt.value;
                if (qt[Qt] === void 0) {
                    if (typeof Xt == "number")
                        qt[Qt] = Xt;
                    else {
                        const Zt = Array.isArray(Xt) ? Xt : [Xt]
                          , Yt = [];
                        for (let sr = 0; sr < Zt.length; sr++)
                            Yt.push(Zt[sr].clone());
                        qt[Qt] = Yt
                    }
                    return !0
                }
                if (typeof Xt == "number") {
                    if (qt[Qt] !== Xt)
                        return qt[Qt] = Xt,
                        !0
                } else {
                    const Zt = Array.isArray(qt[Qt]) ? qt[Qt] : [qt[Qt]]
                      , Yt = Array.isArray(Xt) ? Xt : [Xt];
                    for (let sr = 0; sr < Zt.length; sr++) {
                        const er = Zt[sr];
                        if (er.equals(Yt[sr]) === !1)
                            return er.copy(Yt[sr]),
                            !0
                    }
                }
                return !1
            }
            function Nt(Wt) {
                const Qt = {
                    boundary: 0,
                    storage: 0
                };
                return typeof Wt == "number" ? (Qt.boundary = 4,
                Qt.storage = 4) : Wt.isVector2 ? (Qt.boundary = 8,
                Qt.storage = 8) : Wt.isVector3 || Wt.isColor ? (Qt.boundary = 16,
                Qt.storage = 12) : Wt.isVector4 ? (Qt.boundary = 16,
                Qt.storage = 16) : Wt.isMatrix3 ? (Qt.boundary = 48,
                Qt.storage = 48) : Wt.isMatrix4 ? (Qt.boundary = 64,
                Qt.storage = 64) : Wt.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", Wt),
                Qt
            }
            function jt(Wt) {
                const Qt = Wt.target;
                Qt.removeEventListener("dispose", jt);
                const qt = Ct.indexOf(Qt.__bindingPointIndex);
                Ct.splice(qt, 1),
                Tt.deleteBuffer(ft[Qt.id]),
                delete ft[Qt.id],
                delete xt[Qt.id]
            }
            return {
                bind: function(Wt, Qt) {
                    const qt = Qt.program;
                    mt.uniformBlockBinding(Wt, qt)
                },
                update: function(Wt, Qt) {
                    let qt = ft[Wt.id];
                    qt === void 0 && (function(Yt) {
                        const sr = Yt.uniforms;
                        let er = 0
                          , rr = 0;
                        for (let xr = 0, br = sr.length; xr < br; xr++) {
                            const yr = sr[xr]
                              , Pr = {
                                boundary: 0,
                                storage: 0
                            }
                              , zr = Array.isArray(yr.value) ? yr.value : [yr.value];
                            for (let Nr = 0, Vr = zr.length; Nr < Vr; Nr++) {
                                const Gr = Nt(zr[Nr]);
                                Pr.boundary += Gr.boundary,
                                Pr.storage += Gr.storage
                            }
                            yr.__data = new Float32Array(Pr.storage / Float32Array.BYTES_PER_ELEMENT),
                            yr.__offset = er,
                            xr > 0 && (rr = er % 16,
                            rr !== 0 && 16 - rr - Pr.boundary < 0 && (er += 16 - rr,
                            yr.__offset = er)),
                            er += Pr.storage
                        }
                        rr = er % 16,
                        rr > 0 && (er += 16 - rr),
                        Yt.__size = er,
                        Yt.__cache = {}
                    }(Wt),
                    qt = function(Yt) {
                        const sr = function() {
                            for (let br = 0; br < Mt; br++)
                                if (Ct.indexOf(br) === -1)
                                    return Ct.push(br),
                                    br;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        Yt.__bindingPointIndex = sr;
                        const er = Tt.createBuffer()
                          , rr = Yt.__size
                          , xr = Yt.usage;
                        return Tt.bindBuffer(Tt.UNIFORM_BUFFER, er),
                        Tt.bufferData(Tt.UNIFORM_BUFFER, rr, xr),
                        Tt.bindBuffer(Tt.UNIFORM_BUFFER, null),
                        Tt.bindBufferBase(Tt.UNIFORM_BUFFER, sr, er),
                        er
                    }(Wt),
                    ft[Wt.id] = qt,
                    Wt.addEventListener("dispose", jt));
                    const Xt = Qt.program;
                    mt.updateUBOMapping(Wt, Xt);
                    const Zt = tt.render.frame;
                    xt[Wt.id] !== Zt && (function(Yt) {
                        const sr = ft[Yt.id]
                          , er = Yt.uniforms
                          , rr = Yt.__cache;
                        Tt.bindBuffer(Tt.UNIFORM_BUFFER, sr);
                        for (let xr = 0, br = er.length; xr < br; xr++) {
                            const yr = er[xr];
                            if (Lt(yr, xr, rr) === !0) {
                                const Pr = yr.__offset
                                  , zr = Array.isArray(yr.value) ? yr.value : [yr.value];
                                let Nr = 0;
                                for (let Vr = 0; Vr < zr.length; Vr++) {
                                    const Gr = zr[Vr]
                                      , Hr = Nt(Gr);
                                    typeof Gr == "number" ? (yr.__data[0] = Gr,
                                    Tt.bufferSubData(Tt.UNIFORM_BUFFER, Pr + Nr, yr.__data)) : Gr.isMatrix3 ? (yr.__data[0] = Gr.elements[0],
                                    yr.__data[1] = Gr.elements[1],
                                    yr.__data[2] = Gr.elements[2],
                                    yr.__data[3] = Gr.elements[0],
                                    yr.__data[4] = Gr.elements[3],
                                    yr.__data[5] = Gr.elements[4],
                                    yr.__data[6] = Gr.elements[5],
                                    yr.__data[7] = Gr.elements[0],
                                    yr.__data[8] = Gr.elements[6],
                                    yr.__data[9] = Gr.elements[7],
                                    yr.__data[10] = Gr.elements[8],
                                    yr.__data[11] = Gr.elements[0]) : (Gr.toArray(yr.__data, Nr),
                                    Nr += Hr.storage / Float32Array.BYTES_PER_ELEMENT)
                                }
                                Tt.bufferSubData(Tt.UNIFORM_BUFFER, Pr, yr.__data)
                            }
                        }
                        Tt.bindBuffer(Tt.UNIFORM_BUFFER, null)
                    }(Wt),
                    xt[Wt.id] = Zt)
                },
                dispose: function() {
                    for (const Wt in ft)
                        Tt.deleteBuffer(ft[Wt]);
                    Ct = [],
                    ft = {},
                    xt = {}
                }
            }
        }
        class xx {
            constructor(tt={}) {
                const {
canvas: lt=Zm(), context: mt=null, depth: ft=!0, stencil: xt=!0, alpha: Ct=!1, antialias: Mt=!1, premultipliedAlpha: Lt=!0, preserveDrawingBuffer: Nt=!1, powerPreference: jt="default", failIfMajorPerformanceCaveat: Wt=!1} = tt;
                let Qt;
                this.isWebGLRenderer = !0,
                Qt = mt !== null ? mt.getContextAttributes().alpha : Ct;
                const qt = new Uint32Array(4)
                  , Xt = new Int32Array(4);
                let Zt = null
                  , Yt = null;
                const sr = []
                  , er = [];
                this.domElement = lt,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = jo,
                this._useLegacyLights = !1,
                this.toneMapping = Ur,
                this.toneMappingExposure = 1,
                this.userData = {},
                this.onContextLost = () => {}
                ,
                this.onContextRestore = () => {}
                ,
                this.onContextCreationError = () => {}
                ;
                const rr = this;
                let xr = !1
                  , br = 0
                  , yr = 0
                  , Pr = null
                  , zr = -1
                  , Nr = null;
                const Vr = new Lo
                  , Gr = new Lo;
                let Hr = null;
                const _n = new Gn(0);
                let dn = 0
                  , kn = lt.width
                  , Bn = lt.height
                  , cn = 1
                  , Yr = null
                  , Jr = null;
                const sn = new Lo(0,0,kn,Bn)
                  , on = new Lo(0,0,kn,Bn);
                let Un = !1;
                const ro = new Av;
                let Zn = !1
                  , jn = !1
                  , uo = null;
                const Dr = new no
                  , Sr = new mn
                  , Fr = new Er
                  , Wr = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                function kr() {
                    return Pr === null ? cn : 1
                }
                let _r, Br, Lr, Xr, Kr, An, pn, _o, to, Pn, eo, Kn, po, Ao, Fo, Io, Jn, Co, yl, ho, Qo, Po, Cu, Pu, en = mt;
                function g0(Mr, tn) {
                    for (let an = 0; an < Mr.length; an++) {
                        const un = Mr[an]
                          , yn = lt.getContext(un, tn);
                        if (yn !== null)
                            return yn
                    }
                    return null
                }
                try {
                    const Mr = {
                        alpha: !0,
                        depth: ft,
                        stencil: xt,
                        antialias: Mt,
                        premultipliedAlpha: Lt,
                        preserveDrawingBuffer: Nt,
                        powerPreference: jt,
                        failIfMajorPerformanceCaveat: Wt
                    };
                    if ("setAttribute"in lt && lt.setAttribute("data-engine", `three.js r${
h}`),
                    lt.addEventListener("webglcontextlost", F_, !1),
                    lt.addEventListener("webglcontextrestored", ow, !1),
                    lt.addEventListener("webglcontextcreationerror", sw, !1),
                    en === null) {
                        const tn = ["webgl2", "webgl", "experimental-webgl"];
                        if (rr.isWebGL1Renderer === !0 && tn.shift(),
                        en = g0(tn, Mr),
                        en === null)
                            throw g0(tn) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    typeof WebGLRenderingContext < "u" && en instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
                    en.getShaderPrecisionFormat === void 0 && (en.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                    )
                } catch (Mr) {
                    throw console.error("THREE.WebGLRenderer: " + Mr.message),
                    Mr
                }
                function _0() {
                    _r = new kw(en),
                    Br = new Pw(en,_r,tt),
                    _r.init(Br),
                    Po = new _x(en,_r,Br),
                    Lr = new J1(en,_r,Br),
                    Xr = new Lw(en),
                    Kr = new z1,
                    An = new Z1(en,_r,Lr,Kr,Br,Po,Xr),
                    pn = new Rw(rr),
                    _o = new Iw(rr),
                    to = new Sw(en,Br),
                    Cu = new Tw(en,_r,to,Br),
                    Pn = new Dw(en,to,Xr,Cu),
                    eo = new Uw(en,Pn,to,Xr),
                    yl = new Fw(en,Br,An),
                    Io = new Mw(Kr),
                    Kn = new G1(rr,pn,_o,_r,Br,Cu,Io),
                    po = new rS(rr,Kr),
                    Ao = new Q1,
                    Fo = new Y1(_r,Br),
                    Co = new Ew(rr,pn,_o,Lr,eo,Qt,Lt),
                    Jn = new K1(rr,eo,Br),
                    Pu = new nS(en,Xr,Br,Lr),
                    ho = new Cw(en,_r,Xr,Br),
                    Qo = new Bw(en,_r,Xr,Br),
                    Xr.programs = Kn.programs,
                    rr.capabilities = Br,
                    rr.extensions = _r,
                    rr.properties = Kr,
                    rr.renderLists = Ao,
                    rr.shadowMap = Jn,
                    rr.state = Lr,
                    rr.info = Xr,
                    rr.background = Co,
                    rr.cubemaps = pn,
                    rr.cubeuvmaps = _o,
                    rr.materials = po
                }
                _0();
                const Bs = new tS(rr,en);
                function F_(Mr) {
                    Mr.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    xr = !0,
                    rr.onContextLost(Mr)
                }
                function ow() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    xr = !1;
                    const Mr = rr.info ? rr.info.autoReset : void 0
                      , tn = Jn.enabled
                      , an = Jn.autoUpdate
                      , un = Jn.needsUpdate
                      , yn = Jn.type;
                    _0(),
                    rr.info && Mr !== void 0 && (rr.info.autoReset = Mr),
                    Jn.enabled = tn,
                    Jn.autoUpdate = an,
                    Jn.needsUpdate = un,
                    Jn.type = yn,
                    rr.onContextRestore && rr.onContextRestore()
                }
                function sw(Mr) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Mr.statusMessage),
                    rr.onContextCreationError(Mr)
                }
                function aw(Mr) {
                    const tn = Mr.target;
                    tn.removeEventListener("dispose", aw),
                    function(an) {
                        (function(un) {
                            const yn = Kr.get(un).programs;
                            yn !== void 0 && (yn.forEach(function(On) {
                                Kn.releaseProgram(On)
                            }),
                            un.isShaderMaterial && Kn.releaseShaderCache(un))
                        }
                        )(an),
                        Kr.remove(an)
                    }(tn)
                }
                this.xr = Bs,
                this.getContext = function() {
                    return en
                }
                ,
                this.getContextAttributes = function() {
                    return en.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const Mr = _r.get("WEBGL_lose_context");
                    Mr && Mr.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const Mr = _r.get("WEBGL_lose_context");
                    Mr && Mr.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return cn
                }
                ,
                this.setPixelRatio = function(Mr) {
                    Mr !== void 0 && (cn = Mr,
                    this.setSize(kn, Bn, !1))
                }
                ,
                this.getSize = function(Mr) {
                    return Mr.set(kn, Bn)
                }
                ,
                this.setSize = function(Mr, tn, an=!0) {
                    Bs.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (kn = Mr,
                    Bn = tn,
                    lt.width = Math.floor(Mr * cn),
                    lt.height = Math.floor(tn * cn),
                    an === !0 && (lt.style.width = Mr + "px",
                    lt.style.height = tn + "px"),
                    this.setViewport(0, 0, Mr, tn))
                }
                ,
                this.getDrawingBufferSize = function(Mr) {
                    return Mr.set(kn * cn, Bn * cn).floor()
                }
                ,
                this.setDrawingBufferSize = function(Mr, tn, an) {
                    kn = Mr,
                    Bn = tn,
                    cn = an,
                    lt.width = Math.floor(Mr * an),
                    lt.height = Math.floor(tn * an),
                    this.setViewport(0, 0, Mr, tn)
                }
                ,
                this.getCurrentViewport = function(Mr) {
                    return Mr.copy(Vr)
                }
                ,
                this.getViewport = function(Mr) {
                    return Mr.copy(sn)
                }
                ,
                this.setViewport = function(Mr, tn, an, un) {
                    Mr.isVector4 ? sn.set(Mr.x, Mr.y, Mr.z, Mr.w) : sn.set(Mr, tn, an, un),
                    Lr.viewport(Vr.copy(sn).multiplyScalar(cn).floor())
                }
                ,
                this.getScissor = function(Mr) {
                    return Mr.copy(on)
                }
                ,
                this.setScissor = function(Mr, tn, an, un) {
                    Mr.isVector4 ? on.set(Mr.x, Mr.y, Mr.z, Mr.w) : on.set(Mr, tn, an, un),
                    Lr.scissor(Gr.copy(on).multiplyScalar(cn).floor())
                }
                ,
                this.getScissorTest = function() {
                    return Un
                }
                ,
                this.setScissorTest = function(Mr) {
                    Lr.setScissorTest(Un = Mr)
                }
                ,
                this.setOpaqueSort = function(Mr) {
                    Yr = Mr
                }
                ,
                this.setTransparentSort = function(Mr) {
                    Jr = Mr
                }
                ,
                this.getClearColor = function(Mr) {
                    return Mr.copy(Co.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    Co.setClearColor.apply(Co, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return Co.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    Co.setClearAlpha.apply(Co, arguments)
                }
                ,
                this.clear = function(Mr=!0, tn=!0, an=!0) {
                    let un = 0;
                    if (Mr) {
                        let yn = !1;
                        if (Pr !== null) {
                            const On = Pr.texture.format;
                            yn = On === ko || On === yo || On === Ks
                        }
                        if (yn) {
                            const On = Pr.texture.type
                              , To = On === $n || On === Yo || On === Zo || On === Ps || On === $l || On === wl
                              , _i = Co.getClearColor()
                              , fo = Co.getClearAlpha()
                              , wo = _i.r
                              , So = _i.g
                              , so = _i.b;
                            To ? (qt[0] = wo,
                            qt[1] = So,
                            qt[2] = so,
                            qt[3] = fo,
                            en.clearBufferuiv(en.COLOR, 0, qt)) : (Xt[0] = wo,
                            Xt[1] = So,
                            Xt[2] = so,
                            Xt[3] = fo,
                            en.clearBufferiv(en.COLOR, 0, Xt))
                        } else
                            un |= en.COLOR_BUFFER_BIT
                    }
                    tn && (un |= en.DEPTH_BUFFER_BIT),
                    an && (un |= en.STENCIL_BUFFER_BIT),
                    en.clear(un)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    lt.removeEventListener("webglcontextlost", F_, !1),
                    lt.removeEventListener("webglcontextrestored", ow, !1),
                    lt.removeEventListener("webglcontextcreationerror", sw, !1),
                    Ao.dispose(),
                    Fo.dispose(),
                    Kr.dispose(),
                    pn.dispose(),
                    _o.dispose(),
                    eo.dispose(),
                    Cu.dispose(),
                    Pu.dispose(),
                    Kn.dispose(),
                    Bs.dispose(),
                    Bs.removeEventListener("sessionstart", lw),
                    Bs.removeEventListener("sessionend", cw),
                    uo && (uo.dispose(),
                    uo = null),
                    Fp.stop()
                }
                ,
                this.renderBufferDirect = function(Mr, tn, an, un, yn, On) {
                    tn === null && (tn = Wr);
                    const To = yn.isMesh && yn.matrixWorld.determinant() < 0
                      , _i = function(ns, Al, Xs, io, Jo) {
                        Al.isScene !== !0 && (Al = Wr),
                        An.resetTextureUnits();
                        const U_ = Al.fog
                          , xE = io.userData && io.userData.envMapSlotKey && Al.textureSlots && Al.textureSlots[io.userData.envMapSlotKey] ? Al.textureSlots[io.userData.envMapSlotKey] : io.isMeshStandardMaterial ? Al.environment : null
                          , bE = Pr === null ? rr.outputColorSpace : Pr.isXRRenderTarget === !0 || Pr.texture.colorSpace && Pr.texture.colorSpace !== jo ? Pr.texture.colorSpace : Xo
                          , b0 = (io.isMeshStandardMaterial ? _o : pn).get(io.envMap || xE)
                          , AE = io.vertexColors === !0 && !!Xs.attributes.color && Xs.attributes.color.itemSize === 4
                          , wE = !!Xs.attributes.tangent && (!!io.normalMap || io.anisotropy > 0 || Xs.userData.__forceUseTangent)
                          , SE = !!Xs.morphAttributes.position
                          , EE = !!Xs.morphAttributes.normal
                          , TE = !!Xs.morphAttributes.color;
                        let mw = Ur;
                        io.toneMapped && (Pr !== null && Pr.isXRRenderTarget !== !0 || (mw = rr.toneMapping));
                        const fw = Xs.morphAttributes.position || Xs.morphAttributes.normal || Xs.morphAttributes.color
                          , CE = fw !== void 0 ? fw.length : 0
                          , Uo = Kr.get(io)
                          , PE = Yt.state.lights;
                        if (Zn === !0 && (jn === !0 || ns !== Nr)) {
                            const zs = ns === Nr && io.id === zr;
                            Io.setState(io, ns, zs)
                        }
                        let Mu = !1;
                        io.version === Uo.__version ? Uo.needsLights && Uo.lightsStateVersion !== PE.state.version || Uo.outputColorSpace !== bE || Jo.isInstancedMesh && Uo.instancing === !1 ? Mu = !0 : Jo.isInstancedMesh || Uo.instancing !== !0 ? Jo.isSkinnedMesh && Uo.skinning === !1 ? Mu = !0 : Jo.isSkinnedMesh || Uo.skinning !== !0 ? Jo.isInstancedMesh && Uo.instancingColor === !0 && Jo.instanceColor === null || Jo.isInstancedMesh && Uo.instancingColor === !1 && Jo.instanceColor !== null || Uo.envMap !== b0 || io.fog === !0 && Uo.fog !== U_ ? Mu = !0 : Uo.numClippingPlanes === void 0 || Uo.numClippingPlanes === Io.numPlanes && Uo.numIntersection === Io.numIntersection ? (Uo.vertexAlphas !== AE || Uo.vertexTangents !== wE || Uo.morphTargets !== SE || Uo.morphNormals !== EE || Uo.morphColors !== TE || Uo.toneMapping !== mw || Br.isWebGL2 === !0 && Uo.morphTargetsCount !== CE) && (Mu = !0) : Mu = !0 : Mu = !0 : Mu = !0 : (Mu = !0,
                        Uo.__version = io.version);
                        let Up = Uo.currentProgram;
                        Mu === !0 && (Up = x0(io, Al, Jo));
                        let gw = !1
                          , j_ = !1
                          , Iy = !1;
                        const Ls = Up.getUniforms()
                          , jp = Uo.uniforms;
                        if (Lr.useProgram(Up.program) && (gw = !0,
                        j_ = !0,
                        Iy = !0),
                        io.id !== zr && (zr = io.id,
                        j_ = !0),
                        gw || Nr !== ns) {
                            Ls.setValue(en, "projectionMatrix", ns.projectionMatrix),
                            Ls.setValue(en, "viewMatrix", ns.matrixWorldInverse);
                            const zs = Ls.map.cameraPosition;
                            zs !== void 0 && zs.setValue(en, Fr.setFromMatrixPosition(ns.matrixWorld)),
                            Br.logarithmicDepthBuffer && Ls.setValue(en, "logDepthBufFC", 2 / (Math.log(ns.far + 1) / Math.LN2)),
                            (io.isMeshPhongMaterial || io.isMeshToonMaterial || io.isMeshLambertMaterial || io.isMeshBasicMaterial || io.isMeshStandardMaterial || io.isShaderMaterial) && Ls.setValue(en, "isOrthographic", ns.isOrthographicCamera === !0),
                            Nr !== ns && (Nr = ns,
                            j_ = !0,
                            Iy = !0)
                        }
                        if (Jo.isSkinnedMesh) {
                            Ls.setOptional(en, Jo, "bindMatrix"),
                            Ls.setOptional(en, Jo, "bindMatrixInverse");
                            const zs = Jo.skeleton;
                            zs && (Br.floatVertexTextures ? (zs.boneTexture === null && zs.computeBoneTexture(),
                            Ls.setValue(en, "boneTexture", zs.boneTexture, An),
                            Ls.setValue(en, "boneTextureSize", zs.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        const ky = Xs.morphAttributes;
                        var au, Wl;
                        (ky.position !== void 0 || ky.normal !== void 0 || ky.color !== void 0 && Br.isWebGL2 === !0) && yl.update(Jo, Xs, Up),
                        (j_ || Uo.receiveShadow !== Jo.receiveShadow) && (Uo.receiveShadow = Jo.receiveShadow,
                        Ls.setValue(en, "receiveShadow", Jo.receiveShadow)),
                        io.isMeshGouraudMaterial && io.envMap !== null && (jp.envMap.value = b0,
                        jp.flipEnvMap.value = b0.isCubeTexture && b0.isRenderTargetTexture === !1 ? -1 : 1),
                        j_ && (Ls.setValue(en, "toneMappingExposure", rr.toneMappingExposure),
                        Uo.needsLights && (Wl = Iy,
                        (au = jp).ambientLightColor.needsUpdate = Wl,
                        au.lightProbe.needsUpdate = Wl,
                        au.directionalLights.needsUpdate = Wl,
                        au.directionalLightShadows.needsUpdate = Wl,
                        au.pointLights.needsUpdate = Wl,
                        au.pointLightShadows.needsUpdate = Wl,
                        au.spotLights.needsUpdate = Wl,
                        au.spotLightShadows.needsUpdate = Wl,
                        au.rectAreaLights.needsUpdate = Wl,
                        au.hemisphereLights.needsUpdate = Wl),
                        U_ && io.fog === !0 && po.refreshFogUniforms(jp, U_),
                        po.refreshMaterialUniforms(jp, io, cn, Bn, rr.userData.transmissionRenderTarget || uo),
                        Cv.upload(en, Uo.uniformsList, jp, An)),
                        io.isShaderMaterial && io.uniformsNeedUpdate === !0 && (Cv.upload(en, Uo.uniformsList, jp, An),
                        io.uniformsNeedUpdate = !1),
                        io.isSpriteMaterial && Ls.setValue(en, "center", Jo.center),
                        Ls.setValue(en, "modelViewMatrix", Jo.modelViewMatrix),
                        Ls.setValue(en, "normalMatrix", Jo.normalMatrix),
                        Ls.setValue(en, "modelMatrix", Jo.matrixWorld);
                        const _w = io.extraUniformsToUpload;
                        if (_w && Object.entries(_w).forEach( ([zs,V_]) => Ls.setValue(en, zs, V_.value, An)),
                        io.isShaderMaterial || io.isRawShaderMaterial) {
                            const zs = io.uniformsGroups;
                            for (let V_ = 0, ME = zs.length; V_ < ME; V_++)
                                if (Br.isWebGL2) {
                                    const yw = zs[V_];
                                    Pu.update(yw, Up),
                                    Pu.bind(yw, Up)
                                } else
                                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return Up
                    }(Mr, tn, an, un, yn);
                    Lr.setMaterial(un, To);
                    let fo = an.index
                      , wo = 1;
                    if (un.wireframe === !0) {
                        if (fo = Pn.getWireframeAttribute(an),
                        fo === void 0)
                            return;
                        wo = 2
                    }
                    const So = an.drawRange
                      , so = an.attributes.position;
                    let _s = So.start * wo
                      , xl = (So.start + So.count) * wo;
                    On !== null && (_s = Math.max(_s, On.start * wo),
                    xl = Math.min(xl, (On.start + On.count) * wo)),
                    fo !== null ? (_s = Math.max(_s, 0),
                    xl = Math.min(xl, fo.count)) : so != null && (_s = Math.max(_s, 0),
                    xl = Math.min(xl, so.count));
                    const vs = xl - _s;
                    if (vs < 0 || vs === 1 / 0)
                        return;
                    let ip;
                    Cu.setup(yn, un, _i, an, fo);
                    let ls = ho;
                    if (fo !== null && (ip = to.get(fo),
                    ls = Qo,
                    ls.setIndex(ip)),
                    yn.isMesh)
                        un.wireframe === !0 ? (Lr.setLineWidth(un.wireframeLinewidth * kr()),
                        ls.setMode(en.LINES)) : ls.setMode(en.TRIANGLES);
                    else if (yn.isLine) {
                        let ns = un.linewidth;
                        ns === void 0 && (ns = 1),
                        Lr.setLineWidth(ns * kr()),
                        yn.isLineSegments ? ls.setMode(en.LINES) : yn.isLineLoop ? ls.setMode(en.LINE_LOOP) : ls.setMode(en.LINE_STRIP)
                    } else
                        yn.isPoints ? ls.setMode(en.POINTS) : yn.isSprite && ls.setMode(en.TRIANGLES);
                    if (yn.isInstancedMesh)
                        ls.renderInstances(_s, vs, yn.count);
                    else if (an.isInstancedBufferGeometry) {
                        const ns = an._maxInstanceCount !== void 0 ? an._maxInstanceCount : 1 / 0
                          , Al = Math.min(an.instanceCount, ns);
                        ls.renderInstances(_s, vs, Al)
                    } else
                        ls.render(_s, vs)
                }
                ,
                this.compile = function(Mr, tn) {
                    function an(un, yn, On) {
                        un.transparent === !0 && un.side === St && un.forceSinglePass === !1 ? (un.side = bt,
                        un.needsUpdate = !0,
                        x0(un, yn, On),
                        un.side = vt,
                        un.needsUpdate = !0,
                        x0(un, yn, On),
                        un.side = St) : x0(un, yn, On)
                    }
                    Yt = Fo.get(Mr),
                    Yt.init(),
                    er.push(Yt),
                    Mr.traverseVisible(function(un) {
                        un.isLight && un.layers.test(tn.layers) && (Yt.pushLight(un),
                        un.castShadow && Yt.pushShadow(un))
                    }),
                    Yt.setupLights(rr._useLegacyLights),
                    Mr.traverse(function(un) {
                        const yn = un.material;
                        if (yn)
                            if (Array.isArray(yn))
                                for (let On = 0; On < yn.length; On++)
                                    an(yn[On], Mr, un);
                            else
                                an(yn, Mr, un)
                    }),
                    er.pop(),
                    Yt = null
                }
                ;
                let Ry = null;
                function lw() {
                    Fp.stop()
                }
                function cw() {
                    Fp.start()
                }
                const Fp = new Hy;
                function uw(Mr, tn, an, un) {
                    if (Mr.visible === !1)
                        return;
                    if (Mr.layers.test(tn.layers)) {
                        if (Mr.isGroup)
                            an = Mr.renderOrder;
                        else if (Mr.isLOD)
                            Mr.autoUpdate === !0 && Mr.update(tn);
                        else if (Mr.isLight)
                            Yt.pushLight(Mr),
                            Mr.castShadow && Yt.pushShadow(Mr);
                        else if (Mr.isSprite) {
                            if (!Mr.frustumCulled || ro.intersectsSprite(Mr)) {
                                un && Fr.setFromMatrixPosition(Mr.matrixWorld).applyMatrix4(Dr);
                                const On = eo.update(Mr)
                                  , To = Mr.material;
                                To.visible && Zt.push(Mr, On, To, an, Fr.z, null)
                            }
                        } else if ((Mr.isMesh || Mr.isLine || Mr.isPoints) && (!Mr.frustumCulled || ro.intersectsObject(Mr))) {
                            const On = eo.update(Mr)
                              , To = Mr.material;
                            if (un && (Mr.boundingSphere !== void 0 ? (Mr.boundingSphere === null && Mr.computeBoundingSphere(),
                            Fr.copy(Mr.boundingSphere.center)) : (On.boundingSphere === null && On.computeBoundingSphere(),
                            Fr.copy(On.boundingSphere.center)),
                            Fr.applyMatrix4(Mr.matrixWorld).applyMatrix4(Dr)),
                            Array.isArray(To)) {
                                const _i = On.groups;
                                for (let fo = 0, wo = _i.length; fo < wo; fo++) {
                                    const So = _i[fo]
                                      , so = To[So.materialIndex];
                                    so && so.visible && Zt.push(Mr, On, so, an, Fr.z, So)
                                }
                            } else
                                To.visible && Zt.push(Mr, On, To, an, Fr.z, null)
                        }
                    }
                    const yn = Mr.children;
                    for (let On = 0, To = yn.length; On < To; On++)
                        uw(yn[On], tn, an, un)
                }
                function dw(Mr, tn, an, un) {
                    const yn = Mr.opaque
                      , On = Mr.transmissive
                      , To = Mr.transparent;
                    if (Yt.setupLightsView(an),
                    Zn === !0 && Io.setGlobalState(rr.clippingPlanes, an),
                    rr.userData.transmissionRender === void 0 && rr.userData.renderTransmissionPass !== !1 && On.length > 0 && function(_i, fo, wo, So) {
                        console.warn("three.js internal render transmission pass should not be called");
                        const so = Br.isWebGL2;
                        uo === null && (uo = new Rs(1,1,{
                            generateMipmaps: !0,
                            type: _r.has("EXT_color_buffer_half_float") ? Os : $n,
                            minFilter: vo,
                            samples: so ? 4 : 0
                        })),
                        rr.getDrawingBufferSize(Sr),
                        so ? uo.setSize(Sr.x, Sr.y) : uo.setSize(gp(Sr.x), gp(Sr.y));
                        const _s = rr.getRenderTarget();
                        rr.setRenderTarget(uo),
                        rr.getClearColor(_n),
                        dn = rr.getClearAlpha(),
                        dn < 1 && rr.setClearColor(16777215, .5),
                        rr.clear();
                        const xl = rr.toneMapping;
                        rr.toneMapping = Ur,
                        y0(_i, wo, So),
                        An.updateMultisampleRenderTarget(uo),
                        An.updateRenderTargetMipmap(uo);
                        let vs = !1;
                        for (let ip = 0, ls = fo.length; ip < ls; ip++) {
                            const ns = fo[ip]
                              , Al = ns.object
                              , Xs = ns.geometry
                              , io = ns.material
                              , Jo = ns.group;
                            if (io.side === St && Al.layers.test(So.layers)) {
                                const U_ = io.side;
                                io.side = bt,
                                io.needsUpdate = !0,
                                pw(Al, wo, So, Xs, io, Jo),
                                io.side = U_,
                                io.needsUpdate = !0,
                                vs = !0
                            }
                        }
                        vs === !0 && (An.updateMultisampleRenderTarget(uo),
                        An.updateRenderTargetMipmap(uo)),
                        rr.setRenderTarget(_s),
                        rr.setClearColor(_n, dn),
                        rr.toneMapping = xl
                    }([...yn, ...To], On, tn, an),
                    un && Lr.viewport(Vr.copy(un)),
                    rr.userData.opaqueRender !== !1 && yn.length > 0 && y0(yn, tn, an),
                    rr.userData.transparentRender !== !1 && To.length > 0 && y0(To, tn, an),
                    rr.userData.transmissionRender !== !1 && On.length > 0) {
                        uo || (uo = new Rs(1,1));
                        const _i = (rr.userData.transmissionRenderTarget || uo).texture
                          , fo = Br.isWebGL2
                          , wo = _i.generateMipmaps
                          , So = _i.minFilter;
                        fo && rr.userData.blurTransmissionTarget && rr.userData.transmissionRenderTarget && (_i.generateMipmaps = !0,
                        _i.minFilter = vo,
                        _i.needsUpdate = !0,
                        An.updateMultisampleRenderTarget(rr.userData.transmissionRenderTarget),
                        An.updateRenderTargetMipmap(rr.userData.transmissionRenderTarget)),
                        y0(On, tn, an),
                        fo && rr.userData.blurTransmissionTarget && rr.userData.transmissionRenderTarget && (_i.generateMipmaps = wo,
                        _i.minFilter = So,
                        _i.needsUpdate = !0,
                        An.updateMultisampleRenderTarget(rr.userData.transmissionRenderTarget),
                        An.updateRenderTargetMipmap(rr.userData.transmissionRenderTarget))
                    }
                    Lr.buffers.depth.setTest(!0),
                    Lr.buffers.depth.setMask(!0),
                    Lr.buffers.color.setMask(!0),
                    Lr.setPolygonOffset(!1)
                }
                function y0(Mr, tn, an) {
                    const un = {
                        ...rr.userData
                    };
                    rr.userData.opaqueRender = void 0,
                    rr.userData.transparentRender = void 0,
                    rr.userData.transmissionRender = void 0,
                    rr.userData.backgroundRender = void 0;
                    const yn = tn.isScene === !0 ? tn.overrideMaterial : null;
                    for (let On = 0, To = Mr.length; On < To; On++) {
                        const _i = Mr[On]
                          , fo = _i.object
                          , wo = _i.geometry
                          , So = yn === null ? _i.material : yn
                          , so = _i.group;
                        fo.layers.test(an.layers) && pw(fo, tn, an, wo, So, so)
                    }
                    Object.assign(rr.userData, un)
                }
                function pw(Mr, tn, an, un, yn, On) {
                    Mr.onBeforeRender(rr, tn, an, un, yn, On),
                    Mr.modelViewMatrix.multiplyMatrices(an.matrixWorldInverse, Mr.matrixWorld),
                    Mr.normalMatrix.getNormalMatrix(Mr.modelViewMatrix),
                    yn.onBeforeRender(rr, tn, an, un, Mr, On),
                    yn.transparent === !0 && yn.side === St && yn.forceSinglePass === !1 ? (yn.side = bt,
                    yn.needsUpdate = !0,
                    rr.renderBufferDirect(an, tn, un, yn, Mr, On),
                    yn.side = vt,
                    yn.needsUpdate = !0,
                    rr.renderBufferDirect(an, tn, un, yn, Mr, On),
                    yn.side = St) : rr.renderBufferDirect(an, tn, un, yn, Mr, On),
                    Mr.onAfterRender(rr, tn, an, un, yn, On),
                    yn.onAfterRender(rr, tn, an, un, Mr, On)
                }
                function x0(Mr, tn, an) {
                    tn.isScene !== !0 && (tn = Wr);
                    const un = Kr.get(Mr)
                      , yn = Yt.state.lights
                      , On = Yt.state.shadowsArray
                      , To = yn.state.version
                      , _i = Kn.getParameters(Mr, yn.state, On, tn, an)
                      , fo = Kn.getProgramCacheKey(_i);
                    let wo = un.programs;
                    un.environment = Mr.userData && Mr.userData.envMapSlotKey && tn.textureSlots && tn.textureSlots[Mr.userData.envMapSlotKey] ? tn.textureSlots[Mr.userData.envMapSlotKey] : Mr.isMeshStandardMaterial ? tn.environment : null,
                    un.fog = tn.fog,
                    un.envMap = (Mr.isMeshStandardMaterial ? _o : pn).get(Mr.envMap || un.environment),
                    wo === void 0 && (Mr.addEventListener("dispose", aw),
                    wo = new Map,
                    un.programs = wo);
                    let So = wo.get(fo);
                    if (So !== void 0) {
                        if (un.currentProgram === So && un.lightsStateVersion === To)
                            return hw(Mr, _i),
                            So
                    } else
                        _i.uniforms = Kn.getUniforms(Mr),
                        Mr.onBuild(an, _i, rr),
                        Mr.onBeforeCompile(_i, rr),
                        So = Kn.acquireProgram(_i, fo),
                        wo.set(fo, So),
                        un.uniforms = _i.uniforms;
                    const so = un.uniforms;
                    (Mr.isShaderMaterial || Mr.isRawShaderMaterial) && Mr.clipping !== !0 || (so.clippingPlanes = Io.uniform),
                    hw(Mr, _i),
                    un.needsLights = function(vs) {
                        return vs.isMeshLambertMaterial || vs.isMeshToonMaterial || vs.isMeshPhongMaterial || vs.isMeshStandardMaterial || vs.isShadowMaterial || vs.isShaderMaterial && vs.lights === !0
                    }(Mr),
                    un.lightsStateVersion = To,
                    un.needsLights && (so.ambientLightColor.value = yn.state.ambient,
                    so.lightProbe.value = yn.state.probe,
                    so.directionalLights.value = yn.state.directional,
                    so.directionalLightShadows.value = yn.state.directionalShadow,
                    so.spotLights.value = yn.state.spot,
                    so.spotLightShadows.value = yn.state.spotShadow,
                    so.rectAreaLights.value = yn.state.rectArea,
                    so.ltc_1.value = yn.state.rectAreaLTC1,
                    so.ltc_2.value = yn.state.rectAreaLTC2,
                    so.pointLights.value = yn.state.point,
                    so.pointLightShadows.value = yn.state.pointShadow,
                    so.hemisphereLights.value = yn.state.hemi,
                    so.directionalShadowMap.value = yn.state.directionalShadowMap,
                    so.directionalShadowMatrix.value = yn.state.directionalShadowMatrix,
                    so.spotShadowMap.value = yn.state.spotShadowMap,
                    so.spotLightMatrix.value = yn.state.spotLightMatrix,
                    so.spotLightMap.value = yn.state.spotLightMap,
                    so.pointShadowMap.value = yn.state.pointShadowMap,
                    so.pointShadowMatrix.value = yn.state.pointShadowMatrix);
                    const _s = So.getUniforms()
                      , xl = Cv.seqWithValue(_s.seq, so);
                    return un.currentProgram = So,
                    un.uniformsList = xl,
                    So
                }
                function hw(Mr, tn) {
                    const an = Kr.get(Mr);
                    an.outputColorSpace = tn.outputColorSpace,
                    an.instancing = tn.instancing,
                    an.instancingColor = tn.instancingColor,
                    an.skinning = tn.skinning,
                    an.morphTargets = tn.morphTargets,
                    an.morphNormals = tn.morphNormals,
                    an.morphColors = tn.morphColors,
                    an.morphTargetsCount = tn.morphTargetsCount,
                    an.numClippingPlanes = tn.numClippingPlanes,
                    an.numIntersection = tn.numClipIntersection,
                    an.vertexAlphas = tn.vertexAlphas,
                    an.vertexTangents = tn.vertexTangents,
                    an.toneMapping = tn.toneMapping
                }
                Fp.setAnimationLoop(function(Mr) {
                    Ry && Ry(Mr)
                }),
                typeof self < "u" && Fp.setContext(self),
                this.setAnimationLoop = function(Mr) {
                    Ry = Mr,
                    Bs.setAnimationLoop(Mr),
                    Mr === null ? Fp.stop() : Fp.start()
                }
                ,
                Bs.addEventListener("sessionstart", lw),
                Bs.addEventListener("sessionend", cw),
                this.render = function(Mr, tn) {
                    if (tn === void 0 || tn.isCamera === !0) {
                        if (xr !== !0) {
                            if (Mr.matrixWorldAutoUpdate === !0 && Mr.updateMatrixWorld(),
                            tn.parent === null && tn.matrixWorldAutoUpdate === !0 && tn.updateMatrixWorld(),
                            Bs.enabled === !0 && Bs.isPresenting === !0 && (Bs.cameraAutoUpdate === !0 && Bs.updateCamera(tn),
                            tn = Bs.getCamera()),
                            Mr.isScene === !0 && Mr.onBeforeRender(rr, Mr, tn, Pr),
                            Yt = Fo.get(Mr, er.length),
                            Yt.init(),
                            er.push(Yt),
                            Dr.multiplyMatrices(tn.projectionMatrix, tn.matrixWorldInverse),
                            ro.setFromProjectionMatrix(Dr),
                            jn = this.localClippingEnabled,
                            Zn = Io.init(this.clippingPlanes, jn),
                            Zt = Ao.get(Mr, sr.length),
                            Zt.init(),
                            sr.push(Zt),
                            uw(Mr, tn, 0, rr.sortObjects),
                            Zt.finish(),
                            rr.sortObjects === !0 && Zt.sort(Yr, Jr),
                            this.info.render.frame++,
                            rr.userData.shadowMapRender !== !1) {
                                Zn === !0 && Io.beginShadows();
                                const an = Yt.state.shadowsArray;
                                an.length > 0 && Jn.render(an, Mr, tn),
                                Zn === !0 && Io.endShadows()
                            }
                            if (this.info.autoReset === !0 && this.info.reset(),
                            rr.userData.backgroundRender !== !1 && Co.render(Zt, Mr),
                            rr.userData.sceneRender !== !1)
                                if (Yt.setupLights(rr._useLegacyLights),
                                tn.isArrayCamera) {
                                    const an = tn.cameras;
                                    for (let un = 0, yn = an.length; un < yn; un++) {
                                        const On = an[un];
                                        dw(Zt, Mr, On, On.viewport)
                                    }
                                } else
                                    dw(Zt, Mr, tn);
                            Pr !== null && (An.updateMultisampleRenderTarget(Pr),
                            An.updateRenderTargetMipmap(Pr)),
                            Mr.isScene === !0 && Mr.onAfterRender(rr, Mr, tn),
                            Cu.resetDefaultState(),
                            zr = -1,
                            Nr = null,
                            er.pop(),
                            Yt = er.length > 0 ? er[er.length - 1] : null,
                            sr.pop(),
                            Zt = sr.length > 0 ? sr[sr.length - 1] : null
                        }
                    } else
                        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }
                ,
                this.getActiveCubeFace = function() {
                    return br
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return yr
                }
                ,
                this.getRenderTarget = function() {
                    return Pr
                }
                ,
                this.setRenderTargetTextures = function(Mr, tn, an) {
                    Kr.get(Mr.texture).__webglTexture = tn,
                    Kr.get(Mr.depthTexture).__webglTexture = an;
                    const un = Kr.get(Mr);
                    un.__hasExternalTextures = !0,
                    un.__hasExternalTextures && (un.__autoAllocateDepthBuffer = an === void 0,
                    un.__autoAllocateDepthBuffer || _r.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    un.__useRenderToTexture = !1))
                }
                ,
                this.setRenderTargetFramebuffer = function(Mr, tn) {
                    const an = Kr.get(Mr);
                    an.__webglFramebuffer = tn,
                    an.__useDefaultFramebuffer = tn === void 0
                }
                ,
                this.setRenderTarget = function(Mr, tn=0, an=0) {
                    Pr = Mr,
                    br = tn,
                    yr = an;
                    let un = !0
                      , yn = null
                      , On = !1
                      , To = !1;
                    if (Mr) {
                        const _i = Kr.get(Mr);
                        _i.__useDefaultFramebuffer !== void 0 ? (Lr.bindFramebuffer(en.FRAMEBUFFER, null),
                        un = !1) : _i.__webglFramebuffer === void 0 ? An.setupRenderTarget(Mr) : _i.__hasExternalTextures && An.rebindTextures(Mr, Kr.get(Mr.texture).__webglTexture, Kr.get(Mr.depthTexture).__webglTexture);
                        const fo = Mr.texture;
                        (fo.isData3DTexture || fo.isDataArrayTexture || fo.isCompressedArrayTexture) && (To = !0);
                        const wo = Kr.get(Mr).__webglFramebuffer;
                        Mr.isWebGLCubeRenderTarget ? (yn = Array.isArray(wo[tn]) ? wo[tn][an] : wo[tn],
                        On = !0) : yn = Br.isWebGL2 && Mr.samples > 0 && An.useMultisampledRTT(Mr) === !1 ? Kr.get(Mr).__webglMultisampledFramebuffer : Array.isArray(wo) ? wo[an] : wo,
                        Vr.copy(Mr.viewport),
                        Gr.copy(Mr.scissor),
                        Hr = Mr.scissorTest
                    } else
                        Vr.copy(sn).multiplyScalar(cn).floor(),
                        Gr.copy(on).multiplyScalar(cn).floor(),
                        Hr = Un;
                    if (Lr.bindFramebuffer(en.FRAMEBUFFER, yn) && Br.drawBuffers && un && Lr.drawBuffers(Mr, yn),
                    Lr.viewport(Vr),
                    Lr.scissor(Gr),
                    Lr.setScissorTest(Hr),
                    On) {
                        const _i = Kr.get(Mr.texture);
                        en.framebufferTexture2D(en.FRAMEBUFFER, en.COLOR_ATTACHMENT0, en.TEXTURE_CUBE_MAP_POSITIVE_X + tn, _i.__webglTexture, an)
                    } else if (To) {
                        const _i = Kr.get(Mr.texture)
                          , fo = tn || 0;
                        en.framebufferTextureLayer(en.FRAMEBUFFER, en.COLOR_ATTACHMENT0, _i.__webglTexture, an || 0, fo)
                    }
                    zr = -1
                }
                ,
                this.readRenderTargetPixels = function(Mr, tn, an, un, yn, On, To, _i) {
                    if (!Mr || !Mr.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let fo = Kr.get(Mr).__webglFramebuffer;
                    if (Mr.isWebGLCubeRenderTarget && To !== void 0 && (fo = fo[To]),
                    fo) {
                        Lr.bindFramebuffer(en.FRAMEBUFFER, fo);
                        try {
                            const wo = Array.isArray(Mr.texture) ? Mr.texture[_i || 0] : Mr.texture
                              , So = wo.format
                              , so = wo.type;
                            if (So !== as && Po.convert(So) !== en.getParameter(en.IMPLEMENTATION_COLOR_READ_FORMAT))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const _s = so === Os && (_r.has("EXT_color_buffer_half_float") || Br.isWebGL2 && _r.has("EXT_color_buffer_float"));
                            if (!(so === $n || Po.convert(so) === en.getParameter(en.IMPLEMENTATION_COLOR_READ_TYPE) || so === ss && (Br.isWebGL2 || _r.has("OES_texture_float") || _r.has("WEBGL_color_buffer_float")) || _s))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            tn >= 0 && tn <= Mr.width - un && an >= 0 && an <= Mr.height - yn && (Mr.isWebGLMultipleRenderTargets && en.readBuffer(en.COLOR_ATTACHMENT0 + _i),
                            en.readPixels(tn, an, un, yn, Po.convert(So), Po.convert(so), On))
                        } finally {
                            const wo = Pr ? Kr.get(Pr).__webglFramebuffer : null;
                            Lr.bindFramebuffer(en.FRAMEBUFFER, wo)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(Mr, tn, an=0) {
                    const un = Math.pow(2, -an)
                      , yn = Math.floor(tn.image.width * un)
                      , On = Math.floor(tn.image.height * un);
                    An.setTexture2D(tn, 0),
                    en.copyTexSubImage2D(en.TEXTURE_2D, an, 0, 0, Mr.x, Mr.y, yn, On),
                    Lr.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(Mr, tn, an, un=0) {
                    const yn = tn.image.width
                      , On = tn.image.height
                      , To = Po.convert(an.format)
                      , _i = Po.convert(an.type);
                    An.setTexture2D(an, 0),
                    en.pixelStorei(en.UNPACK_FLIP_Y_WEBGL, an.flipY),
                    en.pixelStorei(en.UNPACK_PREMULTIPLY_ALPHA_WEBGL, an.premultiplyAlpha),
                    en.pixelStorei(en.UNPACK_ALIGNMENT, an.unpackAlignment),
                    tn.isDataTexture ? en.texSubImage2D(en.TEXTURE_2D, un, Mr.x, Mr.y, yn, On, To, _i, tn.image.data) : tn.isCompressedTexture ? en.compressedTexSubImage2D(en.TEXTURE_2D, un, Mr.x, Mr.y, tn.mipmaps[0].width, tn.mipmaps[0].height, To, tn.mipmaps[0].data) : en.texSubImage2D(en.TEXTURE_2D, un, Mr.x, Mr.y, To, _i, tn.image),
                    un === 0 && an.generateMipmaps && en.generateMipmap(en.TEXTURE_2D),
                    Lr.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(Mr, tn, an, un, yn=0) {
                    if (rr.isWebGL1Renderer)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const On = Mr.max.x - Mr.min.x + 1
                      , To = Mr.max.y - Mr.min.y + 1
                      , _i = Mr.max.z - Mr.min.z + 1
                      , fo = Po.convert(un.format)
                      , wo = Po.convert(un.type);
                    let So;
                    if (un.isData3DTexture)
                        An.setTexture3D(un, 0),
                        So = en.TEXTURE_3D;
                    else {
                        if (!un.isDataArrayTexture)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        An.setTexture2DArray(un, 0),
                        So = en.TEXTURE_2D_ARRAY
                    }
                    en.pixelStorei(en.UNPACK_FLIP_Y_WEBGL, un.flipY),
                    en.pixelStorei(en.UNPACK_PREMULTIPLY_ALPHA_WEBGL, un.premultiplyAlpha),
                    en.pixelStorei(en.UNPACK_ALIGNMENT, un.unpackAlignment);
                    const so = en.getParameter(en.UNPACK_ROW_LENGTH)
                      , _s = en.getParameter(en.UNPACK_IMAGE_HEIGHT)
                      , xl = en.getParameter(en.UNPACK_SKIP_PIXELS)
                      , vs = en.getParameter(en.UNPACK_SKIP_ROWS)
                      , ip = en.getParameter(en.UNPACK_SKIP_IMAGES)
                      , ls = an.isCompressedTexture ? an.mipmaps[0] : an.image;
                    en.pixelStorei(en.UNPACK_ROW_LENGTH, ls.width),
                    en.pixelStorei(en.UNPACK_IMAGE_HEIGHT, ls.height),
                    en.pixelStorei(en.UNPACK_SKIP_PIXELS, Mr.min.x),
                    en.pixelStorei(en.UNPACK_SKIP_ROWS, Mr.min.y),
                    en.pixelStorei(en.UNPACK_SKIP_IMAGES, Mr.min.z),
                    an.isDataTexture || an.isData3DTexture ? en.texSubImage3D(So, yn, tn.x, tn.y, tn.z, On, To, _i, fo, wo, ls.data) : an.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                    en.compressedTexSubImage3D(So, yn, tn.x, tn.y, tn.z, On, To, _i, fo, ls.data)) : en.texSubImage3D(So, yn, tn.x, tn.y, tn.z, On, To, _i, fo, wo, ls),
                    en.pixelStorei(en.UNPACK_ROW_LENGTH, so),
                    en.pixelStorei(en.UNPACK_IMAGE_HEIGHT, _s),
                    en.pixelStorei(en.UNPACK_SKIP_PIXELS, xl),
                    en.pixelStorei(en.UNPACK_SKIP_ROWS, vs),
                    en.pixelStorei(en.UNPACK_SKIP_IMAGES, ip),
                    yn === 0 && un.generateMipmaps && en.generateMipmap(So),
                    Lr.unbindTexture()
                }
                ,
                this.initTexture = function(Mr) {
                    Mr.isCubeTexture ? An.setTextureCube(Mr, 0) : Mr.isData3DTexture ? An.setTexture3D(Mr, 0) : Mr.isDataArrayTexture || Mr.isCompressedArrayTexture ? An.setTexture2DArray(Mr, 0) : An.setTexture2D(Mr, 0),
                    Lr.unbindTexture()
                }
                ,
                this.resetState = function() {
                    br = 0,
                    yr = 0,
                    Pr = null,
                    Lr.reset(),
                    Cu.reset()
                }
                ,
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return Qs
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(tt) {
                this._outputColorSpace = tt;
                const lt = this.getContext();
                lt.drawingBufferColorSpace = tt === dp ? "display-p3" : "srgb",
                lt.unpackColorSpace = Do.workingColorSpace === hu ? "display-p3" : "srgb"
            }
            get physicallyCorrectLights() {
                return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                !this.useLegacyLights
            }
            set physicallyCorrectLights(tt) {
                console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                this.useLegacyLights = !tt
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace === jo ? Ol : ts
            }
            set outputEncoding(tt) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace = tt === Ol ? jo : Xo
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights
            }
            set useLegacyLights(tt) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights = tt
            }
        }
        class bx extends xx {
        }
        bx.prototype.isWebGL1Renderer = !0;
        class Pv {
            constructor(tt, lt=25e-5) {
                this.isFogExp2 = !0,
                this.name = "",
                this.color = new Gn(tt),
                this.density = lt
            }
            clone() {
                return new Pv(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    name: this.name,
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        class Mv {
            constructor(tt, lt=1, mt=1e3) {
                this.isFog = !0,
                this.name = "",
                this.color = new Gn(tt),
                this.near = lt,
                this.far = mt
            }
            clone() {
                return new Mv(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class Ax extends Mo {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.overrideMaterial = null,
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.background !== null && (this.background = tt.background.clone()),
                tt.environment !== null && (this.environment = tt.environment.clone()),
                tt.fog !== null && (this.fog = tt.fog.clone()),
                this.backgroundBlurriness = tt.backgroundBlurriness,
                this.backgroundIntensity = tt.backgroundIntensity,
                tt.overrideMaterial !== null && (this.overrideMaterial = tt.overrideMaterial.clone()),
                this.matrixAutoUpdate = tt.matrixAutoUpdate,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return this.fog !== null && (lt.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (lt.object.backgroundBlurriness = this.backgroundBlurriness),
                this.backgroundIntensity !== 1 && (lt.object.backgroundIntensity = this.backgroundIntensity),
                lt
            }
        }
        class Rv {
            constructor(tt, lt) {
                this.isInterleavedBuffer = !0,
                this.array = tt,
                this.stride = lt,
                this.count = tt !== void 0 ? tt.length / lt : 0,
                this.usage = Nu,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = Ms()
            }
            onUploadCallback() {}
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            setUsage(tt) {
                return this.usage = tt,
                this
            }
            copy(tt) {
                return this.array = new tt.array.constructor(tt.array),
                this.count = tt.count,
                this.stride = tt.stride,
                this.usage = tt.usage,
                this
            }
            copyAt(tt, lt, mt) {
                tt *= this.stride,
                mt *= lt.stride;
                for (let ft = 0, xt = this.stride; ft < xt; ft++)
                    this.array[tt + ft] = lt.array[mt + ft];
                return this
            }
            set(tt, lt=0) {
                return this.array.set(tt, lt),
                this
            }
            clone(tt) {
                tt.arrayBuffers === void 0 && (tt.arrayBuffers = {}),
                this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ms()),
                tt.arrayBuffers[this.array.buffer._uuid] === void 0 && (tt.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const lt = new this.array.constructor(tt.arrayBuffers[this.array.buffer._uuid])
                  , mt = new this.constructor(lt,this.stride);
                return mt.setUsage(this.usage),
                mt
            }
            onUpload(tt) {
                return this.onUploadCallback = tt,
                this
            }
            toJSON(tt) {
                return tt.arrayBuffers === void 0 && (tt.arrayBuffers = {}),
                this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ms()),
                tt.arrayBuffers[this.array.buffer._uuid] === void 0 && (tt.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const Vs = new Er;
        class Cp {
            constructor(tt, lt, mt, ft=!1) {
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = tt,
                this.itemSize = lt,
                this.offset = mt,
                this.normalized = ft
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(tt) {
                this.data.needsUpdate = tt
            }
            applyMatrix4(tt) {
                for (let lt = 0, mt = this.data.count; lt < mt; lt++)
                    Vs.fromBufferAttribute(this, lt),
                    Vs.applyMatrix4(tt),
                    this.setXYZ(lt, Vs.x, Vs.y, Vs.z);
                return this
            }
            applyNormalMatrix(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    Vs.fromBufferAttribute(this, lt),
                    Vs.applyNormalMatrix(tt),
                    this.setXYZ(lt, Vs.x, Vs.y, Vs.z);
                return this
            }
            transformDirection(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    Vs.fromBufferAttribute(this, lt),
                    Vs.transformDirection(tt),
                    this.setXYZ(lt, Vs.x, Vs.y, Vs.z);
                return this
            }
            setX(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset] = lt,
                this
            }
            setY(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset + 1] = lt,
                this
            }
            setZ(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset + 2] = lt,
                this
            }
            setW(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset + 3] = lt,
                this
            }
            getX(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            getY(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset + 1];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            getZ(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset + 2];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            getW(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset + 3];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setXY(tt, lt, mt) {
                return tt = tt * this.data.stride + this.offset,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array)),
                this.data.array[tt + 0] = lt,
                this.data.array[tt + 1] = mt,
                this
            }
            setXYZ(tt, lt, mt, ft) {
                return tt = tt * this.data.stride + this.offset,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array)),
                this.data.array[tt + 0] = lt,
                this.data.array[tt + 1] = mt,
                this.data.array[tt + 2] = ft,
                this
            }
            setXYZW(tt, lt, mt, ft, xt) {
                return tt = tt * this.data.stride + this.offset,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array),
                xt = oo(xt, this.array)),
                this.data.array[tt + 0] = lt,
                this.data.array[tt + 1] = mt,
                this.data.array[tt + 2] = ft,
                this.data.array[tt + 3] = xt,
                this
            }
            clone(tt) {
                if (tt === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const lt = [];
                    for (let mt = 0; mt < this.count; mt++) {
                        const ft = mt * this.data.stride + this.offset;
                        for (let xt = 0; xt < this.itemSize; xt++)
                            lt.push(this.data.array[ft + xt])
                    }
                    return new mr(new this.array.constructor(lt),this.itemSize,this.normalized)
                }
                return tt.interleavedBuffers === void 0 && (tt.interleavedBuffers = {}),
                tt.interleavedBuffers[this.data.uuid] === void 0 && (tt.interleavedBuffers[this.data.uuid] = this.data.clone(tt)),
                new Cp(tt.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(tt) {
                if (tt === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const lt = [];
                    for (let mt = 0; mt < this.count; mt++) {
                        const ft = mt * this.data.stride + this.offset;
                        for (let xt = 0; xt < this.itemSize; xt++)
                            lt.push(this.data.array[ft + xt])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: lt,
                        normalized: this.normalized
                    }
                }
                return tt.interleavedBuffers === void 0 && (tt.interleavedBuffers = {}),
                tt.interleavedBuffers[this.data.uuid] === void 0 && (tt.interleavedBuffers[this.data.uuid] = this.data.toJSON(tt)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        class q0 extends hs {
            constructor(tt) {
                super(),
                this.isSpriteMaterial = !0,
                this.type = "SpriteMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.rotation = tt.rotation,
                this.sizeAttenuation = tt.sizeAttenuation,
                this.fog = tt.fog,
                this
            }
        }
        let wm;
        const v_ = new Er
          , Sm = new Er
          , Em = new Er
          , Tm = new mn
          , y_ = new mn
          , wx = new no
          , Iv = new Er
          , x_ = new Er
          , kv = new Er
          , Sx = new mn
          , $0 = new mn
          , Ex = new mn;
        class Tx extends Mo {
            constructor(tt=new q0) {
                if (super(),
                this.isSprite = !0,
                this.type = "Sprite",
                wm === void 0) {
                    wm = new bo;
                    const lt = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                      , mt = new Rv(lt,5);
                    wm.setIndex([0, 1, 2, 0, 2, 3]),
                    wm.setAttribute("position", new Cp(mt,3,0,!1)),
                    wm.setAttribute("uv", new Cp(mt,2,3,!1))
                }
                this.geometry = wm,
                this.material = tt,
                this.center = new mn(.5,.5)
            }
            raycast(tt, lt) {
                tt.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                Sm.setFromMatrixScale(this.matrixWorld),
                wx.copy(tt.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(tt.camera.matrixWorldInverse, this.matrixWorld),
                Em.setFromMatrixPosition(this.modelViewMatrix),
                tt.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Sm.multiplyScalar(-Em.z);
                const mt = this.material.rotation;
                let ft, xt;
                mt !== 0 && (xt = Math.cos(mt),
                ft = Math.sin(mt));
                const Ct = this.center;
                Dv(Iv.set(-.5, -.5, 0), Em, Ct, Sm, ft, xt),
                Dv(x_.set(.5, -.5, 0), Em, Ct, Sm, ft, xt),
                Dv(kv.set(.5, .5, 0), Em, Ct, Sm, ft, xt),
                Sx.set(0, 0),
                $0.set(1, 0),
                Ex.set(1, 1);
                let Mt = tt.ray.intersectTriangle(Iv, x_, kv, !1, v_);
                if (Mt === null && (Dv(x_.set(-.5, .5, 0), Em, Ct, Sm, ft, xt),
                $0.set(0, 1),
                Mt = tt.ray.intersectTriangle(Iv, kv, x_, !1, v_),
                Mt === null))
                    return;
                const Lt = tt.ray.origin.distanceTo(v_);
                Lt < tt.near || Lt > tt.far || lt.push({
                    distance: Lt,
                    point: v_.clone(),
                    uv: Es.getInterpolation(v_, Iv, x_, kv, Sx, $0, Ex, new mn),
                    face: null,
                    object: this
                })
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.center !== void 0 && this.center.copy(tt.center),
                this.material = tt.material,
                this
            }
        }
        function Dv(Tt, tt, lt, mt, ft, xt) {
            Tm.subVectors(Tt, lt).addScalar(.5).multiply(mt),
            ft !== void 0 ? (y_.x = xt * Tm.x - ft * Tm.y,
            y_.y = ft * Tm.x + xt * Tm.y) : y_.copy(Tm),
            Tt.copy(tt),
            Tt.x += y_.x,
            Tt.y += y_.y,
            Tt.applyMatrix4(wx)
        }
        const Bv = new Er
          , Cx = new Er;
        class Px extends Mo {
            constructor() {
                super(),
                this._currentLevel = 0,
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }),
                this.autoUpdate = !0
            }
            copy(tt) {
                super.copy(tt, !1);
                const lt = tt.levels;
                for (let mt = 0, ft = lt.length; mt < ft; mt++) {
                    const xt = lt[mt];
                    this.addLevel(xt.object.clone(), xt.distance, xt.hysteresis)
                }
                return this.autoUpdate = tt.autoUpdate,
                this
            }
            addLevel(tt, lt=0, mt=0) {
                lt = Math.abs(lt);
                const ft = this.levels;
                let xt;
                for (xt = 0; xt < ft.length && !(lt < ft[xt].distance); xt++)
                    ;
                return ft.splice(xt, 0, {
                    distance: lt,
                    hysteresis: mt,
                    object: tt
                }),
                this.add(tt),
                this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(tt) {
                const lt = this.levels;
                if (lt.length > 0) {
                    let mt, ft;
                    for (mt = 1,
                    ft = lt.length; mt < ft; mt++) {
                        let xt = lt[mt].distance;
                        if (lt[mt].object.visible && (xt -= xt * lt[mt].hysteresis),
                        tt < xt)
                            break
                    }
                    return lt[mt - 1].object
                }
                return null
            }
            raycast(tt, lt) {
                if (this.levels.length > 0) {
                    Bv.setFromMatrixPosition(this.matrixWorld);
                    const mt = tt.ray.origin.distanceTo(Bv);
                    this.getObjectForDistance(mt).raycast(tt, lt)
                }
            }
            update(tt) {
                const lt = this.levels;
                if (lt.length > 1) {
                    Bv.setFromMatrixPosition(tt.matrixWorld),
                    Cx.setFromMatrixPosition(this.matrixWorld);
                    const mt = Bv.distanceTo(Cx) / tt.zoom;
                    let ft, xt;
                    for (lt[0].object.visible = !0,
                    ft = 1,
                    xt = lt.length; ft < xt; ft++) {
                        let Ct = lt[ft].distance;
                        if (lt[ft].object.visible && (Ct -= Ct * lt[ft].hysteresis),
                        !(mt >= Ct))
                            break;
                        lt[ft - 1].object.visible = !1,
                        lt[ft].object.visible = !0
                    }
                    for (this._currentLevel = ft - 1; ft < xt; ft++)
                        lt[ft].object.visible = !1
                }
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                this.autoUpdate === !1 && (lt.object.autoUpdate = !1),
                lt.object.levels = [];
                const mt = this.levels;
                for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                    const Ct = mt[ft];
                    lt.object.levels.push({
                        object: Ct.object.uuid,
                        distance: Ct.distance,
                        hysteresis: Ct.hysteresis
                    })
                }
                return lt
            }
        }
        const Mx = new Er
          , Rx = new Lo
          , Ix = new Lo
          , iS = new Er
          , kx = new no
          , Cm = new Er
          , X0 = new Ws
          , Dx = new no
          , Y0 = new Qu;
        class Bx extends gs {
            constructor(tt, lt) {
                super(tt, lt),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new no,
                this.bindMatrixInverse = new no,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const tt = this.geometry;
                this.boundingBox === null && (this.boundingBox = new Tl),
                this.boundingBox.makeEmpty();
                const lt = tt.getAttribute("position");
                for (let mt = 0; mt < lt.count; mt++)
                    Cm.fromBufferAttribute(lt, mt),
                    this.applyBoneTransform(mt, Cm),
                    this.boundingBox.expandByPoint(Cm)
            }
            computeBoundingSphere() {
                const tt = this.geometry;
                this.boundingSphere === null && (this.boundingSphere = new Ws),
                this.boundingSphere.makeEmpty();
                const lt = tt.getAttribute("position");
                for (let mt = 0; mt < lt.count; mt++)
                    Cm.fromBufferAttribute(lt, mt),
                    this.applyBoneTransform(mt, Cm),
                    this.boundingSphere.expandByPoint(Cm)
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.bindMode = tt.bindMode,
                this.bindMatrix.copy(tt.bindMatrix),
                this.bindMatrixInverse.copy(tt.bindMatrixInverse),
                this.skeleton = tt.skeleton,
                tt.boundingBox !== null && (this.boundingBox = tt.boundingBox.clone()),
                tt.boundingSphere !== null && (this.boundingSphere = tt.boundingSphere.clone()),
                this
            }
            raycast(tt, lt) {
                const mt = this.material
                  , ft = this.matrixWorld;
                mt !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                X0.copy(this.boundingSphere),
                X0.applyMatrix4(ft),
                tt.ray.intersectsSphere(X0) !== !1 && (Dx.copy(ft).invert(),
                Y0.copy(tt.ray).applyMatrix4(Dx),
                this.boundingBox !== null && Y0.intersectsBox(this.boundingBox) === !1 || this._computeIntersections(tt, lt, Y0)))
            }
            getVertexPosition(tt, lt) {
                return super.getVertexPosition(tt, lt),
                this.applyBoneTransform(tt, lt),
                lt
            }
            bind(tt, lt) {
                this.skeleton = tt,
                lt === void 0 && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                lt = this.matrixWorld),
                this.bindMatrix.copy(lt),
                this.bindMatrixInverse.copy(lt).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const tt = new Lo
                  , lt = this.geometry.attributes.skinWeight;
                for (let mt = 0, ft = lt.count; mt < ft; mt++) {
                    tt.fromBufferAttribute(lt, mt);
                    const xt = 1 / tt.manhattanLength();
                    xt !== 1 / 0 ? tt.multiplyScalar(xt) : tt.set(1, 0, 0, 0),
                    lt.setXYZW(mt, tt.x, tt.y, tt.z, tt.w)
                }
            }
            updateMatrixWorld(tt) {
                super.updateMatrixWorld(tt),
                this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(tt, lt) {
                const mt = this.skeleton
                  , ft = this.geometry;
                Rx.fromBufferAttribute(ft.attributes.skinIndex, tt),
                Ix.fromBufferAttribute(ft.attributes.skinWeight, tt),
                Mx.copy(lt).applyMatrix4(this.bindMatrix),
                lt.set(0, 0, 0);
                for (let xt = 0; xt < 4; xt++) {
                    const Ct = Ix.getComponent(xt);
                    if (Ct !== 0) {
                        const Mt = Rx.getComponent(xt);
                        kx.multiplyMatrices(mt.bones[Mt].matrixWorld, mt.boneInverses[Mt]),
                        lt.addScaledVector(iS.copy(Mx).applyMatrix4(kx), Ct)
                    }
                }
                return lt.applyMatrix4(this.bindMatrixInverse)
            }
            boneTransform(tt, lt) {
                return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
                this.applyBoneTransform(tt, lt)
            }
        }
        class K0 extends Mo {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class Pm extends Ho {
            constructor(tt=null, lt=1, mt=1, ft, xt, Ct, Mt, Lt, Nt=fn, jt=fn, Wt, Qt) {
                super(null, Ct, Mt, Lt, Nt, jt, ft, xt, Wt, Qt),
                this.isDataTexture = !0,
                this.image = {
                    data: tt,
                    width: lt,
                    height: mt
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Lx = new no
          , oS = new no;
        class Lv {
            constructor(tt=[], lt=[]) {
                this.uuid = Ms(),
                this.bones = tt.slice(0),
                this.boneInverses = lt,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.init()
            }
            init() {
                const tt = this.bones
                  , lt = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * tt.length),
                lt.length === 0)
                    this.calculateInverses();
                else if (tt.length !== lt.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let mt = 0, ft = this.bones.length; mt < ft; mt++)
                        this.boneInverses.push(new no)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let tt = 0, lt = this.bones.length; tt < lt; tt++) {
                    const mt = new no;
                    this.bones[tt] && mt.copy(this.bones[tt].matrixWorld).invert(),
                    this.boneInverses.push(mt)
                }
            }
            pose() {
                for (let tt = 0, lt = this.bones.length; tt < lt; tt++) {
                    const mt = this.bones[tt];
                    mt && mt.matrixWorld.copy(this.boneInverses[tt]).invert()
                }
                for (let tt = 0, lt = this.bones.length; tt < lt; tt++) {
                    const mt = this.bones[tt];
                    mt && (mt.parent && mt.parent.isBone ? (mt.matrix.copy(mt.parent.matrixWorld).invert(),
                    mt.matrix.multiply(mt.matrixWorld)) : mt.matrix.copy(mt.matrixWorld),
                    mt.matrix.decompose(mt.position, mt.quaternion, mt.scale))
                }
            }
            update() {
                const tt = this.bones
                  , lt = this.boneInverses
                  , mt = this.boneMatrices
                  , ft = this.boneTexture;
                for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                    const Mt = tt[xt] ? tt[xt].matrixWorld : oS;
                    Lx.multiplyMatrices(Mt, lt[xt]),
                    Lx.toArray(mt, 16 * xt)
                }
                ft !== null && (ft.needsUpdate = !0)
            }
            clone() {
                return new Lv(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let tt = Math.sqrt(4 * this.bones.length);
                tt = Km(tt),
                tt = Math.max(tt, 4);
                const lt = new Float32Array(tt * tt * 4);
                lt.set(this.boneMatrices);
                const mt = new Pm(lt,tt,tt,as,ss);
                return mt.needsUpdate = !0,
                this.boneMatrices = lt,
                this.boneTexture = mt,
                this.boneTextureSize = tt,
                this
            }
            getBoneByName(tt) {
                for (let lt = 0, mt = this.bones.length; lt < mt; lt++) {
                    const ft = this.bones[lt];
                    if (ft.name === tt)
                        return ft
                }
            }
            dispose() {
                this.boneTexture !== null && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(tt, lt) {
                this.uuid = tt.uuid;
                for (let mt = 0, ft = tt.bones.length; mt < ft; mt++) {
                    const xt = tt.bones[mt];
                    let Ct = lt[xt];
                    Ct === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", xt),
                    Ct = new K0),
                    this.bones.push(Ct),
                    this.boneInverses.push(new no().fromArray(tt.boneInverses[mt]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const tt = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                tt.uuid = this.uuid;
                const lt = this.bones
                  , mt = this.boneInverses;
                for (let ft = 0, xt = lt.length; ft < xt; ft++) {
                    const Ct = lt[ft];
                    tt.bones.push(Ct.uuid);
                    const Mt = mt[ft];
                    tt.boneInverses.push(Mt.toArray())
                }
                return tt
            }
        }
        class Mm extends mr {
            constructor(tt, lt, mt, ft=1) {
                super(tt, lt, mt),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = ft
            }
            copy(tt) {
                return super.copy(tt),
                this.meshPerAttribute = tt.meshPerAttribute,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.meshPerAttribute = this.meshPerAttribute,
                tt.isInstancedBufferAttribute = !0,
                tt
            }
        }
        const Rm = new no
          , Ox = new no
          , Ov = []
          , Nx = new Tl
          , sS = new no
          , b_ = new gs
          , A_ = new Ws;
        class Fx extends gs {
            constructor(tt, lt, mt) {
                super(tt, lt),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new Mm(new Float32Array(16 * mt),16),
                this.instanceColor = null,
                this.sourceTrs = null,
                this.count = mt,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let ft = 0; ft < mt; ft++)
                    this.setMatrixAt(ft, sS)
            }
            computeBoundingBox() {
                const tt = this.geometry
                  , lt = this.count;
                this.boundingBox === null && (this.boundingBox = new Tl),
                tt.boundingBox === null && tt.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let mt = 0; mt < lt; mt++)
                    this.getMatrixAt(mt, Rm),
                    Nx.copy(tt.boundingBox).applyMatrix4(Rm),
                    this.boundingBox.union(Nx)
            }
            computeBoundingSphere() {
                const tt = this.geometry
                  , lt = this.count;
                this.boundingSphere === null && (this.boundingSphere = new Ws),
                tt.boundingSphere === null && tt.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let mt = 0; mt < lt; mt++)
                    this.getMatrixAt(mt, Rm),
                    A_.copy(tt.boundingSphere).applyMatrix4(Rm),
                    this.boundingSphere.union(A_)
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.isInstancedMesh ? (this.instanceMatrix.copy(tt.instanceMatrix),
                tt.instanceColor !== null && (this.instanceColor = tt.instanceColor.clone()),
                this.count = tt.count,
                tt.boundingBox !== null && (this.boundingBox = tt.boundingBox.clone()),
                tt.boundingSphere !== null && (this.boundingSphere = tt.boundingSphere.clone()),
                this) : this
            }
            getColorAt(tt, lt) {
                lt.fromArray(this.instanceColor.array, 3 * tt)
            }
            getMatrixAt(tt, lt) {
                lt.fromArray(this.instanceMatrix.array, 16 * tt)
            }
            raycast(tt, lt) {
                const mt = this.matrixWorld
                  , ft = this.count;
                if (b_.geometry = this.geometry,
                b_.material = this.material,
                b_.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                A_.copy(this.boundingSphere),
                A_.applyMatrix4(mt),
                tt.ray.intersectsSphere(A_) !== !1))
                    for (let xt = 0; xt < ft; xt++) {
                        this.getMatrixAt(xt, Rm),
                        Ox.multiplyMatrices(mt, Rm),
                        b_.matrixWorld = Ox,
                        b_.raycast(tt, Ov);
                        for (let Ct = 0, Mt = Ov.length; Ct < Mt; Ct++) {
                            const Lt = Ov[Ct];
                            Lt.instanceId = xt,
                            Lt.object = this,
                            lt.push(Lt)
                        }
                        Ov.length = 0
                    }
            }
            setColorAt(tt, lt) {
                this.instanceColor === null && (this.instanceColor = new Mm(new Float32Array(3 * this.instanceMatrix.count),3)),
                lt.toArray(this.instanceColor.array, 3 * tt)
            }
            setMatrixAt(tt, lt) {
                lt.toArray(this.instanceMatrix.array, 16 * tt)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Gs extends hs {
            constructor(tt) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.linewidth = tt.linewidth,
                this.linecap = tt.linecap,
                this.linejoin = tt.linejoin,
                this.fog = tt.fog,
                this
            }
        }
        const Ux = new Er
          , jx = new Er
          , Vx = new no
          , J0 = new Qu
          , Nv = new Ws;
        class ep extends Mo {
            constructor(tt=new bo, lt=new Gs) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = tt,
                this.material = lt,
                this.updateMorphTargets()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.material = Array.isArray(tt.material) ? tt.material.slice() : tt.material,
                this.geometry = tt.geometry,
                this
            }
            computeLineDistances() {
                const tt = this.geometry;
                if (tt.index === null) {
                    const lt = tt.attributes.position
                      , mt = [0];
                    for (let ft = 1, xt = lt.count; ft < xt; ft++)
                        Ux.fromBufferAttribute(lt, ft - 1),
                        jx.fromBufferAttribute(lt, ft),
                        mt[ft] = mt[ft - 1],
                        mt[ft] += Ux.distanceTo(jx);
                    tt.setAttribute("lineDistance", new Fn(mt,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(tt, lt) {
                const mt = this.geometry
                  , ft = this.matrixWorld
                  , xt = tt.params.Line.threshold
                  , Ct = mt.drawRange;
                if (mt.boundingSphere === null && mt.computeBoundingSphere(),
                Nv.copy(mt.boundingSphere),
                Nv.applyMatrix4(ft),
                Nv.radius += xt,
                tt.ray.intersectsSphere(Nv) === !1)
                    return;
                Vx.copy(ft).invert(),
                J0.copy(tt.ray).applyMatrix4(Vx);
                const Mt = xt / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , Lt = Mt * Mt
                  , Nt = new Er
                  , jt = new Er
                  , Wt = new Er
                  , Qt = new Er
                  , qt = this.isLineSegments ? 2 : 1
                  , Xt = mt.index
                  , Zt = mt.attributes.position;
                if (Xt !== null)
                    for (let Yt = Math.max(0, Ct.start), sr = Math.min(Xt.count, Ct.start + Ct.count) - 1; Yt < sr; Yt += qt) {
                        const er = Xt.getX(Yt)
                          , rr = Xt.getX(Yt + 1);
                        if (Nt.fromBufferAttribute(Zt, er),
                        jt.fromBufferAttribute(Zt, rr),
                        J0.distanceSqToSegment(Nt, jt, Qt, Wt) > Lt)
                            continue;
                        Qt.applyMatrix4(this.matrixWorld);
                        const xr = tt.ray.origin.distanceTo(Qt);
                        xr < tt.near || xr > tt.far || lt.push({
                            distance: xr,
                            point: Wt.clone().applyMatrix4(this.matrixWorld),
                            index: Yt,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                else
                    for (let Yt = Math.max(0, Ct.start), sr = Math.min(Zt.count, Ct.start + Ct.count) - 1; Yt < sr; Yt += qt) {
                        if (Nt.fromBufferAttribute(Zt, Yt),
                        jt.fromBufferAttribute(Zt, Yt + 1),
                        J0.distanceSqToSegment(Nt, jt, Qt, Wt) > Lt)
                            continue;
                        Qt.applyMatrix4(this.matrixWorld);
                        const er = tt.ray.origin.distanceTo(Qt);
                        er < tt.near || er > tt.far || lt.push({
                            distance: er,
                            point: Wt.clone().applyMatrix4(this.matrixWorld),
                            index: Yt,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            }
            updateMorphTargets() {
                const tt = this.geometry.morphAttributes
                  , lt = Object.keys(tt);
                if (lt.length > 0) {
                    const mt = tt[lt[0]];
                    if (mt !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                            const Ct = mt[ft].name || String(ft);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[Ct] = ft
                        }
                    }
                }
            }
        }
        const Gx = new Er
          , zx = new Er;
        class iu extends ep {
            constructor(tt, lt) {
                super(tt, lt),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const tt = this.geometry;
                if (tt.index === null) {
                    const lt = tt.attributes.position
                      , mt = [];
                    for (let ft = 0, xt = lt.count; ft < xt; ft += 2)
                        Gx.fromBufferAttribute(lt, ft),
                        zx.fromBufferAttribute(lt, ft + 1),
                        mt[ft] = ft === 0 ? 0 : mt[ft - 1],
                        mt[ft + 1] = mt[ft] + Gx.distanceTo(zx);
                    tt.setAttribute("lineDistance", new Fn(mt,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class Hx extends ep {
            constructor(tt, lt) {
                super(tt, lt),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class Z0 extends hs {
            constructor(tt) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.size = tt.size,
                this.sizeAttenuation = tt.sizeAttenuation,
                this.fog = tt.fog,
                this
            }
        }
        const Qx = new no
          , ey = new Qu
          , Fv = new Ws
          , Uv = new Er;
        class Wx extends Mo {
            constructor(tt=new bo, lt=new Z0) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = tt,
                this.material = lt,
                this.updateMorphTargets()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.material = Array.isArray(tt.material) ? tt.material.slice() : tt.material,
                this.geometry = tt.geometry,
                this
            }
            raycast(tt, lt) {
                const mt = this.geometry
                  , ft = this.matrixWorld
                  , xt = tt.params.Points.threshold
                  , Ct = mt.drawRange;
                if (mt.boundingSphere === null && mt.computeBoundingSphere(),
                Fv.copy(mt.boundingSphere),
                Fv.applyMatrix4(ft),
                Fv.radius += xt,
                tt.ray.intersectsSphere(Fv) === !1)
                    return;
                Qx.copy(ft).invert(),
                ey.copy(tt.ray).applyMatrix4(Qx);
                const Mt = xt / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , Lt = Mt * Mt
                  , Nt = mt.index
                  , jt = mt.attributes.position;
                if (Nt !== null)
                    for (let Wt = Math.max(0, Ct.start), Qt = Math.min(Nt.count, Ct.start + Ct.count); Wt < Qt; Wt++) {
                        const qt = Nt.getX(Wt);
                        Uv.fromBufferAttribute(jt, qt),
                        qx(Uv, qt, Lt, ft, tt, lt, this)
                    }
                else
                    for (let Wt = Math.max(0, Ct.start), Qt = Math.min(jt.count, Ct.start + Ct.count); Wt < Qt; Wt++)
                        Uv.fromBufferAttribute(jt, Wt),
                        qx(Uv, Wt, Lt, ft, tt, lt, this)
            }
            updateMorphTargets() {
                const tt = this.geometry.morphAttributes
                  , lt = Object.keys(tt);
                if (lt.length > 0) {
                    const mt = tt[lt[0]];
                    if (mt !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                            const Ct = mt[ft].name || String(ft);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[Ct] = ft
                        }
                    }
                }
            }
        }
        function qx(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = ey.distanceSqToPoint(Tt);
            if (Mt < lt) {
                const Lt = new Er;
                ey.closestPointToPoint(Tt, Lt),
                Lt.applyMatrix4(mt);
                const Nt = ft.ray.origin.distanceTo(Lt);
                if (Nt < ft.near || Nt > ft.far)
                    return;
                xt.push({
                    distance: Nt,
                    distanceToRay: Math.sqrt(Mt),
                    point: Lt,
                    index: tt,
                    face: null,
                    object: Ct
                })
            }
        }
        class aS extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                super(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt),
                this.isVideoTexture = !0,
                this.minFilter = Ct !== void 0 ? Ct : Rn,
                this.magFilter = xt !== void 0 ? xt : Rn,
                this.generateMipmaps = !1;
                const jt = this;
                "requestVideoFrameCallback"in tt && tt.requestVideoFrameCallback(function Wt() {
                    jt.needsUpdate = !0,
                    tt.requestVideoFrameCallback(Wt)
                })
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const tt = this.image;
                !("requestVideoFrameCallback"in tt) && tt.readyState >= tt.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class lS extends Ho {
            constructor(tt, lt) {
                super({
                    width: tt,
                    height: lt
                }),
                this.isFramebufferTexture = !0,
                this.magFilter = fn,
                this.minFilter = fn,
                this.generateMipmaps = !1,
                this.needsUpdate = !0
            }
        }
        class jv extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt) {
                super(null, Ct, Mt, Lt, Nt, jt, ft, xt, Wt, Qt),
                this.isCompressedTexture = !0,
                this.image = {
                    width: lt,
                    height: mt
                },
                this.mipmaps = tt,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class cS extends jv {
            constructor(tt, lt, mt, ft, xt, Ct) {
                super(tt, lt, mt, xt, Ct),
                this.isCompressedArrayTexture = !0,
                this.image.depth = ft,
                this.wrapR = wn
            }
        }
        class uS extends jv {
            constructor(tt, lt, mt) {
                super(void 0, tt[0].width, tt[0].height, lt, mt, Qr),
                this.isCompressedCubeTexture = !0,
                this.isCubeTexture = !0,
                this.image = tt
            }
        }
        class dS extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                super(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt),
                this.isCanvasTexture = !0,
                this.needsUpdate = !0
            }
        }
        class Hl {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(tt, lt) {
                const mt = this.getUtoTmapping(tt);
                return this.getPoint(mt, lt)
            }
            getPoints(tt=5) {
                const lt = [];
                for (let mt = 0; mt <= tt; mt++)
                    lt.push(this.getPoint(mt / tt));
                return lt
            }
            getSpacedPoints(tt=5) {
                const lt = [];
                for (let mt = 0; mt <= tt; mt++)
                    lt.push(this.getPointAt(mt / tt));
                return lt
            }
            getLength() {
                const tt = this.getLengths();
                return tt[tt.length - 1]
            }
            getLengths(tt=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === tt + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const lt = [];
                let mt, ft = this.getPoint(0), xt = 0;
                lt.push(0);
                for (let Ct = 1; Ct <= tt; Ct++)
                    mt = this.getPoint(Ct / tt),
                    xt += mt.distanceTo(ft),
                    lt.push(xt),
                    ft = mt;
                return this.cacheArcLengths = lt,
                lt
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(tt, lt) {
                const mt = this.getLengths();
                let ft = 0;
                const xt = mt.length;
                let Ct;
                Ct = lt || tt * mt[xt - 1];
                let Mt, Lt = 0, Nt = xt - 1;
                for (; Lt <= Nt; )
                    if (ft = Math.floor(Lt + (Nt - Lt) / 2),
                    Mt = mt[ft] - Ct,
                    Mt < 0)
                        Lt = ft + 1;
                    else {
                        if (!(Mt > 0)) {
                            Nt = ft;
                            break
                        }
                        Nt = ft - 1
                    }
                if (ft = Nt,
                mt[ft] === Ct)
                    return ft / (xt - 1);
                const jt = mt[ft];
                return (ft + (Ct - jt) / (mt[ft + 1] - jt)) / (xt - 1)
            }
            getTangent(tt, lt) {
                let ft = tt - 1e-4
                  , xt = tt + 1e-4;
                ft < 0 && (ft = 0),
                xt > 1 && (xt = 1);
                const Ct = this.getPoint(ft)
                  , Mt = this.getPoint(xt)
                  , Lt = lt || (Ct.isVector2 ? new mn : new Er);
                return Lt.copy(Mt).sub(Ct).normalize(),
                Lt
            }
            getTangentAt(tt, lt) {
                const mt = this.getUtoTmapping(tt);
                return this.getTangent(mt, lt)
            }
            computeFrenetFrames(tt, lt) {
                const mt = new Er
                  , ft = []
                  , xt = []
                  , Ct = []
                  , Mt = new Er
                  , Lt = new no;
                for (let qt = 0; qt <= tt; qt++) {
                    const Xt = qt / tt;
                    ft[qt] = this.getTangentAt(Xt, new Er)
                }
                xt[0] = new Er,
                Ct[0] = new Er;
                let Nt = Number.MAX_VALUE;
                const jt = Math.abs(ft[0].x)
                  , Wt = Math.abs(ft[0].y)
                  , Qt = Math.abs(ft[0].z);
                jt <= Nt && (Nt = jt,
                mt.set(1, 0, 0)),
                Wt <= Nt && (Nt = Wt,
                mt.set(0, 1, 0)),
                Qt <= Nt && mt.set(0, 0, 1),
                Mt.crossVectors(ft[0], mt).normalize(),
                xt[0].crossVectors(ft[0], Mt),
                Ct[0].crossVectors(ft[0], xt[0]);
                for (let qt = 1; qt <= tt; qt++) {
                    if (xt[qt] = xt[qt - 1].clone(),
                    Ct[qt] = Ct[qt - 1].clone(),
                    Mt.crossVectors(ft[qt - 1], ft[qt]),
                    Mt.length() > Number.EPSILON) {
                        Mt.normalize();
                        const Xt = Math.acos(qo(ft[qt - 1].dot(ft[qt]), -1, 1));
                        xt[qt].applyMatrix4(Lt.makeRotationAxis(Mt, Xt))
                    }
                    Ct[qt].crossVectors(ft[qt], xt[qt])
                }
                if (lt === !0) {
                    let qt = Math.acos(qo(xt[0].dot(xt[tt]), -1, 1));
                    qt /= tt,
                    ft[0].dot(Mt.crossVectors(xt[0], xt[tt])) > 0 && (qt = -qt);
                    for (let Xt = 1; Xt <= tt; Xt++)
                        xt[Xt].applyMatrix4(Lt.makeRotationAxis(ft[Xt], qt * Xt)),
                        Ct[Xt].crossVectors(ft[Xt], xt[Xt])
                }
                return {
                    tangents: ft,
                    normals: xt,
                    binormals: Ct
                }
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.arcLengthDivisions = tt.arcLengthDivisions,
                this
            }
            toJSON() {
                const tt = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return tt.arcLengthDivisions = this.arcLengthDivisions,
                tt.type = this.type,
                tt
            }
            fromJSON(tt) {
                return this.arcLengthDivisions = tt.arcLengthDivisions,
                this
            }
        }
        class Vv extends Hl {
            constructor(tt=0, lt=0, mt=1, ft=1, xt=0, Ct=2 * Math.PI, Mt=!1, Lt=0) {
                super(),
                this.isEllipseCurve = !0,
                this.type = "EllipseCurve",
                this.aX = tt,
                this.aY = lt,
                this.xRadius = mt,
                this.yRadius = ft,
                this.aStartAngle = xt,
                this.aEndAngle = Ct,
                this.aClockwise = Mt,
                this.aRotation = Lt
            }
            getPoint(tt, lt) {
                const mt = lt || new mn
                  , ft = 2 * Math.PI;
                let xt = this.aEndAngle - this.aStartAngle;
                const Ct = Math.abs(xt) < Number.EPSILON;
                for (; xt < 0; )
                    xt += ft;
                for (; xt > ft; )
                    xt -= ft;
                xt < Number.EPSILON && (xt = Ct ? 0 : ft),
                this.aClockwise !== !0 || Ct || (xt === ft ? xt = -ft : xt -= ft);
                const Mt = this.aStartAngle + tt * xt;
                let Lt = this.aX + this.xRadius * Math.cos(Mt)
                  , Nt = this.aY + this.yRadius * Math.sin(Mt);
                if (this.aRotation !== 0) {
                    const jt = Math.cos(this.aRotation)
                      , Wt = Math.sin(this.aRotation)
                      , Qt = Lt - this.aX
                      , qt = Nt - this.aY;
                    Lt = Qt * jt - qt * Wt + this.aX,
                    Nt = Qt * Wt + qt * jt + this.aY
                }
                return mt.set(Lt, Nt)
            }
            copy(tt) {
                return super.copy(tt),
                this.aX = tt.aX,
                this.aY = tt.aY,
                this.xRadius = tt.xRadius,
                this.yRadius = tt.yRadius,
                this.aStartAngle = tt.aStartAngle,
                this.aEndAngle = tt.aEndAngle,
                this.aClockwise = tt.aClockwise,
                this.aRotation = tt.aRotation,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.aX = this.aX,
                tt.aY = this.aY,
                tt.xRadius = this.xRadius,
                tt.yRadius = this.yRadius,
                tt.aStartAngle = this.aStartAngle,
                tt.aEndAngle = this.aEndAngle,
                tt.aClockwise = this.aClockwise,
                tt.aRotation = this.aRotation,
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.aX = tt.aX,
                this.aY = tt.aY,
                this.xRadius = tt.xRadius,
                this.yRadius = tt.yRadius,
                this.aStartAngle = tt.aStartAngle,
                this.aEndAngle = tt.aEndAngle,
                this.aClockwise = tt.aClockwise,
                this.aRotation = tt.aRotation,
                this
            }
        }
        class $x extends Vv {
            constructor(tt, lt, mt, ft, xt, Ct) {
                super(tt, lt, mt, mt, ft, xt, Ct),
                this.isArcCurve = !0,
                this.type = "ArcCurve"
            }
        }
        function ty() {
            let Tt = 0
              , tt = 0
              , lt = 0
              , mt = 0;
            function ft(xt, Ct, Mt, Lt) {
                Tt = xt,
                tt = Mt,
                lt = -3 * xt + 3 * Ct - 2 * Mt - Lt,
                mt = 2 * xt - 2 * Ct + Mt + Lt
            }
            return {
                initCatmullRom: function(xt, Ct, Mt, Lt, Nt) {
                    ft(Ct, Mt, Nt * (Mt - xt), Nt * (Lt - Ct))
                },
                initNonuniformCatmullRom: function(xt, Ct, Mt, Lt, Nt, jt, Wt) {
                    let Qt = (Ct - xt) / Nt - (Mt - xt) / (Nt + jt) + (Mt - Ct) / jt
                      , qt = (Mt - Ct) / jt - (Lt - Ct) / (jt + Wt) + (Lt - Mt) / Wt;
                    Qt *= jt,
                    qt *= jt,
                    ft(Ct, Mt, Qt, qt)
                },
                calc: function(xt) {
                    const Ct = xt * xt;
                    return Tt + tt * xt + lt * Ct + mt * (Ct * xt)
                }
            }
        }
        const Gv = new Er
          , ry = new ty
          , ny = new ty
          , iy = new ty;
        class Xx extends Hl {
            constructor(tt=[], lt=!1, mt="centripetal", ft=.5) {
                super(),
                this.isCatmullRomCurve3 = !0,
                this.type = "CatmullRomCurve3",
                this.points = tt,
                this.closed = lt,
                this.curveType = mt,
                this.tension = ft
            }
            getPoint(tt, lt=new Er) {
                const mt = lt
                  , ft = this.points
                  , xt = ft.length
                  , Ct = (xt - (this.closed ? 0 : 1)) * tt;
                let Mt, Lt, Nt = Math.floor(Ct), jt = Ct - Nt;
                this.closed ? Nt += Nt > 0 ? 0 : (Math.floor(Math.abs(Nt) / xt) + 1) * xt : jt === 0 && Nt === xt - 1 && (Nt = xt - 2,
                jt = 1),
                this.closed || Nt > 0 ? Mt = ft[(Nt - 1) % xt] : (Gv.subVectors(ft[0], ft[1]).add(ft[0]),
                Mt = Gv);
                const Wt = ft[Nt % xt]
                  , Qt = ft[(Nt + 1) % xt];
                if (this.closed || Nt + 2 < xt ? Lt = ft[(Nt + 2) % xt] : (Gv.subVectors(ft[xt - 1], ft[xt - 2]).add(ft[xt - 1]),
                Lt = Gv),
                this.curveType === "centripetal" || this.curveType === "chordal") {
                    const qt = this.curveType === "chordal" ? .5 : .25;
                    let Xt = Math.pow(Mt.distanceToSquared(Wt), qt)
                      , Zt = Math.pow(Wt.distanceToSquared(Qt), qt)
                      , Yt = Math.pow(Qt.distanceToSquared(Lt), qt);
                    Zt < 1e-4 && (Zt = 1),
                    Xt < 1e-4 && (Xt = Zt),
                    Yt < 1e-4 && (Yt = Zt),
                    ry.initNonuniformCatmullRom(Mt.x, Wt.x, Qt.x, Lt.x, Xt, Zt, Yt),
                    ny.initNonuniformCatmullRom(Mt.y, Wt.y, Qt.y, Lt.y, Xt, Zt, Yt),
                    iy.initNonuniformCatmullRom(Mt.z, Wt.z, Qt.z, Lt.z, Xt, Zt, Yt)
                } else
                    this.curveType === "catmullrom" && (ry.initCatmullRom(Mt.x, Wt.x, Qt.x, Lt.x, this.tension),
                    ny.initCatmullRom(Mt.y, Wt.y, Qt.y, Lt.y, this.tension),
                    iy.initCatmullRom(Mt.z, Wt.z, Qt.z, Lt.z, this.tension));
                return mt.set(ry.calc(jt), ny.calc(jt), iy.calc(jt)),
                mt
            }
            copy(tt) {
                super.copy(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(ft.clone())
                }
                return this.closed = tt.closed,
                this.curveType = tt.curveType,
                this.tension = tt.tension,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.points = [];
                for (let lt = 0, mt = this.points.length; lt < mt; lt++) {
                    const ft = this.points[lt];
                    tt.points.push(ft.toArray())
                }
                return tt.closed = this.closed,
                tt.curveType = this.curveType,
                tt.tension = this.tension,
                tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(new Er().fromArray(ft))
                }
                return this.closed = tt.closed,
                this.curveType = tt.curveType,
                this.tension = tt.tension,
                this
            }
        }
        function Yx(Tt, tt, lt, mt, ft) {
            const xt = .5 * (mt - tt)
              , Ct = .5 * (ft - lt)
              , Mt = Tt * Tt;
            return (2 * lt - 2 * mt + xt + Ct) * (Tt * Mt) + (-3 * lt + 3 * mt - 2 * xt - Ct) * Mt + xt * Tt + lt
        }
        function w_(Tt, tt, lt, mt) {
            return function(ft, xt) {
                const Ct = 1 - ft;
                return Ct * Ct * xt
            }(Tt, tt) + function(ft, xt) {
                return 2 * (1 - ft) * ft * xt
            }(Tt, lt) + function(ft, xt) {
                return ft * ft * xt
            }(Tt, mt)
        }
        function S_(Tt, tt, lt, mt, ft) {
            return function(xt, Ct) {
                const Mt = 1 - xt;
                return Mt * Mt * Mt * Ct
            }(Tt, tt) + function(xt, Ct) {
                const Mt = 1 - xt;
                return 3 * Mt * Mt * xt * Ct
            }(Tt, lt) + function(xt, Ct) {
                return 3 * (1 - xt) * xt * xt * Ct
            }(Tt, mt) + function(xt, Ct) {
                return xt * xt * xt * Ct
            }(Tt, ft)
        }
        class oy extends Hl {
            constructor(tt=new mn, lt=new mn, mt=new mn, ft=new mn) {
                super(),
                this.isCubicBezierCurve = !0,
                this.type = "CubicBezierCurve",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt,
                this.v3 = ft
            }
            getPoint(tt, lt=new mn) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2
                  , Mt = this.v3;
                return mt.set(S_(tt, ft.x, xt.x, Ct.x, Mt.x), S_(tt, ft.y, xt.y, Ct.y, Mt.y)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this.v3.copy(tt.v3),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt.v3 = this.v3.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this.v3.fromArray(tt.v3),
                this
            }
        }
        class Kx extends Hl {
            constructor(tt=new Er, lt=new Er, mt=new Er, ft=new Er) {
                super(),
                this.isCubicBezierCurve3 = !0,
                this.type = "CubicBezierCurve3",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt,
                this.v3 = ft
            }
            getPoint(tt, lt=new Er) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2
                  , Mt = this.v3;
                return mt.set(S_(tt, ft.x, xt.x, Ct.x, Mt.x), S_(tt, ft.y, xt.y, Ct.y, Mt.y), S_(tt, ft.z, xt.z, Ct.z, Mt.z)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this.v3.copy(tt.v3),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt.v3 = this.v3.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this.v3.fromArray(tt.v3),
                this
            }
        }
        class sy extends Hl {
            constructor(tt=new mn, lt=new mn) {
                super(),
                this.isLineCurve = !0,
                this.type = "LineCurve",
                this.v1 = tt,
                this.v2 = lt
            }
            getPoint(tt, lt=new mn) {
                const mt = lt;
                return tt === 1 ? mt.copy(this.v2) : (mt.copy(this.v2).sub(this.v1),
                mt.multiplyScalar(tt).add(this.v1)),
                mt
            }
            getPointAt(tt, lt) {
                return this.getPoint(tt, lt)
            }
            getTangent(tt, lt=new mn) {
                return lt.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(tt, lt) {
                return this.getTangent(tt, lt)
            }
            copy(tt) {
                return super.copy(tt),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class Jx extends Hl {
            constructor(tt=new Er, lt=new Er) {
                super(),
                this.isLineCurve3 = !0,
                this.type = "LineCurve3",
                this.v1 = tt,
                this.v2 = lt
            }
            getPoint(tt, lt=new Er) {
                const mt = lt;
                return tt === 1 ? mt.copy(this.v2) : (mt.copy(this.v2).sub(this.v1),
                mt.multiplyScalar(tt).add(this.v1)),
                mt
            }
            getPointAt(tt, lt) {
                return this.getPoint(tt, lt)
            }
            getTangent(tt, lt=new Er) {
                return lt.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(tt, lt) {
                return this.getTangent(tt, lt)
            }
            copy(tt) {
                return super.copy(tt),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class ay extends Hl {
            constructor(tt=new mn, lt=new mn, mt=new mn) {
                super(),
                this.isQuadraticBezierCurve = !0,
                this.type = "QuadraticBezierCurve",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt
            }
            getPoint(tt, lt=new mn) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2;
                return mt.set(w_(tt, ft.x, xt.x, Ct.x), w_(tt, ft.y, xt.y, Ct.y)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class ly extends Hl {
            constructor(tt=new Er, lt=new Er, mt=new Er) {
                super(),
                this.isQuadraticBezierCurve3 = !0,
                this.type = "QuadraticBezierCurve3",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt
            }
            getPoint(tt, lt=new Er) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2;
                return mt.set(w_(tt, ft.x, xt.x, Ct.x), w_(tt, ft.y, xt.y, Ct.y), w_(tt, ft.z, xt.z, Ct.z)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class cy extends Hl {
            constructor(tt=[]) {
                super(),
                this.isSplineCurve = !0,
                this.type = "SplineCurve",
                this.points = tt
            }
            getPoint(tt, lt=new mn) {
                const mt = lt
                  , ft = this.points
                  , xt = (ft.length - 1) * tt
                  , Ct = Math.floor(xt)
                  , Mt = xt - Ct
                  , Lt = ft[Ct === 0 ? Ct : Ct - 1]
                  , Nt = ft[Ct]
                  , jt = ft[Ct > ft.length - 2 ? ft.length - 1 : Ct + 1]
                  , Wt = ft[Ct > ft.length - 3 ? ft.length - 1 : Ct + 2];
                return mt.set(Yx(Mt, Lt.x, Nt.x, jt.x, Wt.x), Yx(Mt, Lt.y, Nt.y, jt.y, Wt.y)),
                mt
            }
            copy(tt) {
                super.copy(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(ft.clone())
                }
                return this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.points = [];
                for (let lt = 0, mt = this.points.length; lt < mt; lt++) {
                    const ft = this.points[lt];
                    tt.points.push(ft.toArray())
                }
                return tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(new mn().fromArray(ft))
                }
                return this
            }
        }
        var zv = Object.freeze({
            __proto__: null,
            ArcCurve: $x,
            CatmullRomCurve3: Xx,
            CubicBezierCurve: oy,
            CubicBezierCurve3: Kx,
            EllipseCurve: Vv,
            LineCurve: sy,
            LineCurve3: Jx,
            QuadraticBezierCurve: ay,
            QuadraticBezierCurve3: ly,
            SplineCurve: cy
        });
        class Zx extends Hl {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(tt) {
                this.curves.push(tt)
            }
            closePath() {
                const tt = this.curves[0].getPoint(0)
                  , lt = this.curves[this.curves.length - 1].getPoint(1);
                if (!tt.equals(lt)) {
                    const mt = tt.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                    this.curves.push(new zv[mt](lt,tt))
                }
                return this
            }
            getPoint(tt, lt) {
                const mt = tt * this.getLength()
                  , ft = this.getCurveLengths();
                let xt = 0;
                for (; xt < ft.length; ) {
                    if (ft[xt] >= mt) {
                        const Ct = ft[xt] - mt
                          , Mt = this.curves[xt]
                          , Lt = Mt.getLength()
                          , Nt = Lt === 0 ? 0 : 1 - Ct / Lt;
                        return Mt.getPointAt(Nt, lt)
                    }
                    xt++
                }
                return null
            }
            getLength() {
                const tt = this.getCurveLengths();
                return tt[tt.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const tt = [];
                let lt = 0;
                for (let mt = 0, ft = this.curves.length; mt < ft; mt++)
                    lt += this.curves[mt].getLength(),
                    tt.push(lt);
                return this.cacheLengths = tt,
                tt
            }
            getSpacedPoints(tt=40) {
                const lt = [];
                for (let mt = 0; mt <= tt; mt++)
                    lt.push(this.getPoint(mt / tt));
                return this.autoClose && lt.push(lt[0]),
                lt
            }
            getPoints(tt=12) {
                const lt = [];
                let mt;
                for (let ft = 0, xt = this.curves; ft < xt.length; ft++) {
                    const Ct = xt[ft]
                      , Mt = Ct.isEllipseCurve ? 2 * tt : Ct.isLineCurve || Ct.isLineCurve3 ? 1 : Ct.isSplineCurve ? tt * Ct.points.length : tt
                      , Lt = Ct.getPoints(Mt);
                    for (let Nt = 0; Nt < Lt.length; Nt++) {
                        const jt = Lt[Nt];
                        mt && mt.equals(jt) || (lt.push(jt),
                        mt = jt)
                    }
                }
                return this.autoClose && lt.length > 1 && !lt[lt.length - 1].equals(lt[0]) && lt.push(lt[0]),
                lt
            }
            copy(tt) {
                super.copy(tt),
                this.curves = [];
                for (let lt = 0, mt = tt.curves.length; lt < mt; lt++) {
                    const ft = tt.curves[lt];
                    this.curves.push(ft.clone())
                }
                return this.autoClose = tt.autoClose,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.autoClose = this.autoClose,
                tt.curves = [];
                for (let lt = 0, mt = this.curves.length; lt < mt; lt++) {
                    const ft = this.curves[lt];
                    tt.curves.push(ft.toJSON())
                }
                return tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.autoClose = tt.autoClose,
                this.curves = [];
                for (let lt = 0, mt = tt.curves.length; lt < mt; lt++) {
                    const ft = tt.curves[lt];
                    this.curves.push(new zv[ft.type]().fromJSON(ft))
                }
                return this
            }
        }
        class E_ extends Zx {
            constructor(tt) {
                super(),
                this.type = "Path",
                this.currentPoint = new mn,
                tt && this.setFromPoints(tt)
            }
            setFromPoints(tt) {
                this.moveTo(tt[0].x, tt[0].y);
                for (let lt = 1, mt = tt.length; lt < mt; lt++)
                    this.lineTo(tt[lt].x, tt[lt].y);
                return this
            }
            moveTo(tt, lt) {
                return this.currentPoint.set(tt, lt),
                this
            }
            lineTo(tt, lt) {
                const mt = new sy(this.currentPoint.clone(),new mn(tt,lt));
                return this.curves.push(mt),
                this.currentPoint.set(tt, lt),
                this
            }
            quadraticCurveTo(tt, lt, mt, ft) {
                const xt = new ay(this.currentPoint.clone(),new mn(tt,lt),new mn(mt,ft));
                return this.curves.push(xt),
                this.currentPoint.set(mt, ft),
                this
            }
            bezierCurveTo(tt, lt, mt, ft, xt, Ct) {
                const Mt = new oy(this.currentPoint.clone(),new mn(tt,lt),new mn(mt,ft),new mn(xt,Ct));
                return this.curves.push(Mt),
                this.currentPoint.set(xt, Ct),
                this
            }
            splineThru(tt) {
                const lt = [this.currentPoint.clone()].concat(tt)
                  , mt = new cy(lt);
                return this.curves.push(mt),
                this.currentPoint.copy(tt[tt.length - 1]),
                this
            }
            arc(tt, lt, mt, ft, xt, Ct) {
                const Mt = this.currentPoint.x
                  , Lt = this.currentPoint.y;
                return this.absarc(tt + Mt, lt + Lt, mt, ft, xt, Ct),
                this
            }
            absarc(tt, lt, mt, ft, xt, Ct) {
                return this.absellipse(tt, lt, mt, mt, ft, xt, Ct),
                this
            }
            ellipse(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                const Nt = this.currentPoint.x
                  , jt = this.currentPoint.y;
                return this.absellipse(tt + Nt, lt + jt, mt, ft, xt, Ct, Mt, Lt),
                this
            }
            absellipse(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                const Nt = new Vv(tt,lt,mt,ft,xt,Ct,Mt,Lt);
                if (this.curves.length > 0) {
                    const Wt = Nt.getPoint(0);
                    Wt.equals(this.currentPoint) || this.lineTo(Wt.x, Wt.y)
                }
                this.curves.push(Nt);
                const jt = Nt.getPoint(1);
                return this.currentPoint.copy(jt),
                this
            }
            copy(tt) {
                return super.copy(tt),
                this.currentPoint.copy(tt.currentPoint),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.currentPoint = this.currentPoint.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.currentPoint.fromArray(tt.currentPoint),
                this
            }
        }
        class T_ extends bo {
            constructor(tt=[new mn(0,-.5), new mn(.5,0), new mn(0,.5)], lt=12, mt=0, ft=2 * Math.PI) {
                super(),
                this.type = "LatheGeometry",
                this.parameters = {
                    points: tt,
                    segments: lt,
                    phiStart: mt,
                    phiLength: ft
                },
                lt = Math.floor(lt),
                ft = qo(ft, 0, 2 * Math.PI);
                const xt = []
                  , Ct = []
                  , Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = 1 / lt
                  , Wt = new Er
                  , Qt = new mn
                  , qt = new Er
                  , Xt = new Er
                  , Zt = new Er;
                let Yt = 0
                  , sr = 0;
                for (let er = 0; er <= tt.length - 1; er++)
                    switch (er) {
                    case 0:
                        Yt = tt[er + 1].x - tt[er].x,
                        sr = tt[er + 1].y - tt[er].y,
                        qt.x = 1 * sr,
                        qt.y = -Yt,
                        qt.z = 0 * sr,
                        Zt.copy(qt),
                        qt.normalize(),
                        Lt.push(qt.x, qt.y, qt.z);
                        break;
                    case tt.length - 1:
                        Lt.push(Zt.x, Zt.y, Zt.z);
                        break;
                    default:
                        Yt = tt[er + 1].x - tt[er].x,
                        sr = tt[er + 1].y - tt[er].y,
                        qt.x = 1 * sr,
                        qt.y = -Yt,
                        qt.z = 0 * sr,
                        Xt.copy(qt),
                        qt.x += Zt.x,
                        qt.y += Zt.y,
                        qt.z += Zt.z,
                        qt.normalize(),
                        Lt.push(qt.x, qt.y, qt.z),
                        Zt.copy(Xt)
                    }
                for (let er = 0; er <= lt; er++) {
                    const rr = mt + er * jt * ft
                      , xr = Math.sin(rr)
                      , br = Math.cos(rr);
                    for (let yr = 0; yr <= tt.length - 1; yr++) {
                        Wt.x = tt[yr].x * xr,
                        Wt.y = tt[yr].y,
                        Wt.z = tt[yr].x * br,
                        Ct.push(Wt.x, Wt.y, Wt.z),
                        Qt.x = er / lt,
                        Qt.y = yr / (tt.length - 1),
                        Mt.push(Qt.x, Qt.y);
                        const Pr = Lt[3 * yr + 0] * xr
                          , zr = Lt[3 * yr + 1]
                          , Nr = Lt[3 * yr + 0] * br;
                        Nt.push(Pr, zr, Nr)
                    }
                }
                for (let er = 0; er < lt; er++)
                    for (let rr = 0; rr < tt.length - 1; rr++) {
                        const xr = rr + er * tt.length
                          , br = xr
                          , yr = xr + tt.length
                          , Pr = xr + tt.length + 1
                          , zr = xr + 1;
                        xt.push(br, yr, zr),
                        xt.push(Pr, zr, yr)
                    }
                this.setIndex(xt),
                this.setAttribute("position", new Fn(Ct,3)),
                this.setAttribute("uv", new Fn(Mt,2)),
                this.setAttribute("normal", new Fn(Nt,3))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new T_(tt.points,tt.segments,tt.phiStart,tt.phiLength)
            }
        }
        class Hv extends T_ {
            constructor(tt=1, lt=1, mt=4, ft=8) {
                const xt = new E_;
                xt.absarc(0, -lt / 2, tt, 1.5 * Math.PI, 0),
                xt.absarc(0, lt / 2, tt, 0, .5 * Math.PI),
                super(xt.getPoints(mt), ft),
                this.type = "CapsuleGeometry",
                this.parameters = {
                    radius: tt,
                    length: lt,
                    capSegments: mt,
                    radialSegments: ft
                }
            }
            static fromJSON(tt) {
                return new Hv(tt.radius,tt.length,tt.capSegments,tt.radialSegments)
            }
        }
        class Qv extends bo {
            constructor(tt=1, lt=32, mt=0, ft=2 * Math.PI) {
                super(),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: tt,
                    segments: lt,
                    thetaStart: mt,
                    thetaLength: ft
                },
                lt = Math.max(3, lt);
                const xt = []
                  , Ct = []
                  , Mt = []
                  , Lt = []
                  , Nt = new Er
                  , jt = new mn;
                Ct.push(0, 0, 0),
                Mt.push(0, 0, 1),
                Lt.push(.5, .5);
                for (let Wt = 0, Qt = 3; Wt <= lt; Wt++,
                Qt += 3) {
                    const qt = mt + Wt / lt * ft;
                    Nt.x = tt * Math.cos(qt),
                    Nt.y = tt * Math.sin(qt),
                    Ct.push(Nt.x, Nt.y, Nt.z),
                    Mt.push(0, 0, 1),
                    jt.x = (Ct[Qt] / tt + 1) / 2,
                    jt.y = (Ct[Qt + 1] / tt + 1) / 2,
                    Lt.push(jt.x, jt.y)
                }
                for (let Wt = 1; Wt <= lt; Wt++)
                    xt.push(Wt, Wt + 1, 0);
                this.setIndex(xt),
                this.setAttribute("position", new Fn(Ct,3)),
                this.setAttribute("normal", new Fn(Mt,3)),
                this.setAttribute("uv", new Fn(Lt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new Qv(tt.radius,tt.segments,tt.thetaStart,tt.thetaLength)
            }
        }
        class Im extends bo {
            constructor(tt=1, lt=1, mt=1, ft=32, xt=1, Ct=!1, Mt=0, Lt=2 * Math.PI) {
                super(),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: tt,
                    radiusBottom: lt,
                    height: mt,
                    radialSegments: ft,
                    heightSegments: xt,
                    openEnded: Ct,
                    thetaStart: Mt,
                    thetaLength: Lt
                };
                const Nt = this;
                ft = Math.floor(ft),
                xt = Math.floor(xt);
                const jt = []
                  , Wt = []
                  , Qt = []
                  , qt = [];
                let Xt = 0;
                const Zt = []
                  , Yt = mt / 2;
                let sr = 0;
                function er(rr) {
                    const xr = Xt
                      , br = new mn
                      , yr = new Er;
                    let Pr = 0;
                    const zr = rr === !0 ? tt : lt
                      , Nr = rr === !0 ? 1 : -1;
                    for (let Gr = 1; Gr <= ft; Gr++)
                        Wt.push(0, Yt * Nr, 0),
                        Qt.push(0, Nr, 0),
                        qt.push(.5, .5),
                        Xt++;
                    const Vr = Xt;
                    for (let Gr = 0; Gr <= ft; Gr++) {
                        const Hr = Gr / ft * Lt + Mt
                          , _n = Math.cos(Hr)
                          , dn = Math.sin(Hr);
                        yr.x = zr * dn,
                        yr.y = Yt * Nr,
                        yr.z = zr * _n,
                        Wt.push(yr.x, yr.y, yr.z),
                        Qt.push(0, Nr, 0),
                        br.x = .5 * _n + .5,
                        br.y = .5 * dn * Nr + .5,
                        qt.push(br.x, br.y),
                        Xt++
                    }
                    for (let Gr = 0; Gr < ft; Gr++) {
                        const Hr = xr + Gr
                          , _n = Vr + Gr;
                        rr === !0 ? jt.push(_n, _n + 1, Hr) : jt.push(_n + 1, _n, Hr),
                        Pr += 3
                    }
                    Nt.addGroup(sr, Pr, rr === !0 ? 1 : 2),
                    sr += Pr
                }
                (function() {
                    const rr = new Er
                      , xr = new Er;
                    let br = 0;
                    const yr = (lt - tt) / mt;
                    for (let Pr = 0; Pr <= xt; Pr++) {
                        const zr = []
                          , Nr = Pr / xt
                          , Vr = Nr * (lt - tt) + tt;
                        for (let Gr = 0; Gr <= ft; Gr++) {
                            const Hr = Gr / ft
                              , _n = Hr * Lt + Mt
                              , dn = Math.sin(_n)
                              , kn = Math.cos(_n);
                            xr.x = Vr * dn,
                            xr.y = -Nr * mt + Yt,
                            xr.z = Vr * kn,
                            Wt.push(xr.x, xr.y, xr.z),
                            rr.set(dn, yr, kn).normalize(),
                            Qt.push(rr.x, rr.y, rr.z),
                            qt.push(Hr, 1 - Nr),
                            zr.push(Xt++)
                        }
                        Zt.push(zr)
                    }
                    for (let Pr = 0; Pr < ft; Pr++)
                        for (let zr = 0; zr < xt; zr++) {
                            const Nr = Zt[zr][Pr]
                              , Vr = Zt[zr + 1][Pr]
                              , Gr = Zt[zr + 1][Pr + 1]
                              , Hr = Zt[zr][Pr + 1];
                            jt.push(Nr, Vr, Hr),
                            jt.push(Vr, Gr, Hr),
                            br += 6
                        }
                    Nt.addGroup(sr, br, 0),
                    sr += br
                }
                )(),
                Ct === !1 && (tt > 0 && er(!0),
                lt > 0 && er(!1)),
                this.setIndex(jt),
                this.setAttribute("position", new Fn(Wt,3)),
                this.setAttribute("normal", new Fn(Qt,3)),
                this.setAttribute("uv", new Fn(qt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new Im(tt.radiusTop,tt.radiusBottom,tt.height,tt.radialSegments,tt.heightSegments,tt.openEnded,tt.thetaStart,tt.thetaLength)
            }
        }
        class Wv extends Im {
            constructor(tt=1, lt=1, mt=32, ft=1, xt=!1, Ct=0, Mt=2 * Math.PI) {
                super(0, tt, lt, mt, ft, xt, Ct, Mt),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: tt,
                    height: lt,
                    radialSegments: mt,
                    heightSegments: ft,
                    openEnded: xt,
                    thetaStart: Ct,
                    thetaLength: Mt
                }
            }
            static fromJSON(tt) {
                return new Wv(tt.radius,tt.height,tt.radialSegments,tt.heightSegments,tt.openEnded,tt.thetaStart,tt.thetaLength)
            }
        }
        class tp extends bo {
            constructor(tt=[], lt=[], mt=1, ft=0) {
                super(),
                this.type = "PolyhedronGeometry",
                this.parameters = {
                    vertices: tt,
                    indices: lt,
                    radius: mt,
                    detail: ft
                };
                const xt = []
                  , Ct = [];
                function Mt(Qt, qt, Xt, Zt) {
                    const Yt = Zt + 1
                      , sr = [];
                    for (let er = 0; er <= Yt; er++) {
                        sr[er] = [];
                        const rr = Qt.clone().lerp(Xt, er / Yt)
                          , xr = qt.clone().lerp(Xt, er / Yt)
                          , br = Yt - er;
                        for (let yr = 0; yr <= br; yr++)
                            sr[er][yr] = yr === 0 && er === Yt ? rr : rr.clone().lerp(xr, yr / br)
                    }
                    for (let er = 0; er < Yt; er++)
                        for (let rr = 0; rr < 2 * (Yt - er) - 1; rr++) {
                            const xr = Math.floor(rr / 2);
                            rr % 2 == 0 ? (Lt(sr[er][xr + 1]),
                            Lt(sr[er + 1][xr]),
                            Lt(sr[er][xr])) : (Lt(sr[er][xr + 1]),
                            Lt(sr[er + 1][xr + 1]),
                            Lt(sr[er + 1][xr]))
                        }
                }
                function Lt(Qt) {
                    xt.push(Qt.x, Qt.y, Qt.z)
                }
                function Nt(Qt, qt) {
                    const Xt = 3 * Qt;
                    qt.x = tt[Xt + 0],
                    qt.y = tt[Xt + 1],
                    qt.z = tt[Xt + 2]
                }
                function jt(Qt, qt, Xt, Zt) {
                    Zt < 0 && Qt.x === 1 && (Ct[qt] = Qt.x - 1),
                    Xt.x === 0 && Xt.z === 0 && (Ct[qt] = Zt / 2 / Math.PI + .5)
                }
                function Wt(Qt) {
                    return Math.atan2(Qt.z, -Qt.x)
                }
                (function(Qt) {
                    const qt = new Er
                      , Xt = new Er
                      , Zt = new Er;
                    for (let Yt = 0; Yt < lt.length; Yt += 3)
                        Nt(lt[Yt + 0], qt),
                        Nt(lt[Yt + 1], Xt),
                        Nt(lt[Yt + 2], Zt),
                        Mt(qt, Xt, Zt, Qt)
                }
                )(ft),
                function(Qt) {
                    const qt = new Er;
                    for (let Xt = 0; Xt < xt.length; Xt += 3)
                        qt.x = xt[Xt + 0],
                        qt.y = xt[Xt + 1],
                        qt.z = xt[Xt + 2],
                        qt.normalize().multiplyScalar(Qt),
                        xt[Xt + 0] = qt.x,
                        xt[Xt + 1] = qt.y,
                        xt[Xt + 2] = qt.z
                }(mt),
                function() {
                    const Qt = new Er;
                    for (let Xt = 0; Xt < xt.length; Xt += 3) {
                        Qt.x = xt[Xt + 0],
                        Qt.y = xt[Xt + 1],
                        Qt.z = xt[Xt + 2];
                        const Zt = Wt(Qt) / 2 / Math.PI + .5
                          , Yt = (qt = Qt,
                        Math.atan2(-qt.y, Math.sqrt(qt.x * qt.x + qt.z * qt.z)) / Math.PI + .5);
                        Ct.push(Zt, 1 - Yt)
                    }
                    var qt;
                    (function() {
                        const Xt = new Er
                          , Zt = new Er
                          , Yt = new Er
                          , sr = new Er
                          , er = new mn
                          , rr = new mn
                          , xr = new mn;
                        for (let br = 0, yr = 0; br < xt.length; br += 9,
                        yr += 6) {
                            Xt.set(xt[br + 0], xt[br + 1], xt[br + 2]),
                            Zt.set(xt[br + 3], xt[br + 4], xt[br + 5]),
                            Yt.set(xt[br + 6], xt[br + 7], xt[br + 8]),
                            er.set(Ct[yr + 0], Ct[yr + 1]),
                            rr.set(Ct[yr + 2], Ct[yr + 3]),
                            xr.set(Ct[yr + 4], Ct[yr + 5]),
                            sr.copy(Xt).add(Zt).add(Yt).divideScalar(3);
                            const Pr = Wt(sr);
                            jt(er, yr + 0, Xt, Pr),
                            jt(rr, yr + 2, Zt, Pr),
                            jt(xr, yr + 4, Yt, Pr)
                        }
                    }
                    )(),
                    function() {
                        for (let Xt = 0; Xt < Ct.length; Xt += 6) {
                            const Zt = Ct[Xt + 0]
                              , Yt = Ct[Xt + 2]
                              , sr = Ct[Xt + 4]
                              , er = Math.max(Zt, Yt, sr)
                              , rr = Math.min(Zt, Yt, sr);
                            er > .9 && rr < .1 && (Zt < .2 && (Ct[Xt + 0] += 1),
                            Yt < .2 && (Ct[Xt + 2] += 1),
                            sr < .2 && (Ct[Xt + 4] += 1))
                        }
                    }()
                }(),
                this.setAttribute("position", new Fn(xt,3)),
                this.setAttribute("normal", new Fn(xt.slice(),3)),
                this.setAttribute("uv", new Fn(Ct,2)),
                ft === 0 ? this.computeVertexNormals() : this.normalizeNormals()
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new tp(tt.vertices,tt.indices,tt.radius,tt.details)
            }
        }
        class qv extends tp {
            constructor(tt=1, lt=0) {
                const mt = (1 + Math.sqrt(5)) / 2
                  , ft = 1 / mt;
                super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -ft, -mt, 0, -ft, mt, 0, ft, -mt, 0, ft, mt, -ft, -mt, 0, -ft, mt, 0, ft, -mt, 0, ft, mt, 0, -mt, 0, -ft, mt, 0, -ft, -mt, 0, ft, mt, 0, ft], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], tt, lt),
                this.type = "DodecahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new qv(tt.radius,tt.detail)
            }
        }
        const $v = new Er
          , Xv = new Er
          , uy = new Er
          , Yv = new Es;
        class eA extends bo {
            constructor(tt=null, lt=1) {
                if (super(),
                this.type = "EdgesGeometry",
                this.parameters = {
                    geometry: tt,
                    thresholdAngle: lt
                },
                tt !== null) {
                    const ft = Math.pow(10, 4)
                      , xt = Math.cos(Zl * lt)
                      , Ct = tt.getIndex()
                      , Mt = tt.getAttribute("position")
                      , Lt = Ct ? Ct.count : Mt.count
                      , Nt = [0, 0, 0]
                      , jt = ["a", "b", "c"]
                      , Wt = new Array(3)
                      , Qt = {}
                      , qt = [];
                    for (let Xt = 0; Xt < Lt; Xt += 3) {
                        Ct ? (Nt[0] = Ct.getX(Xt),
                        Nt[1] = Ct.getX(Xt + 1),
                        Nt[2] = Ct.getX(Xt + 2)) : (Nt[0] = Xt,
                        Nt[1] = Xt + 1,
                        Nt[2] = Xt + 2);
                        const {
a: Zt, b: Yt, c: sr} = Yv;
                        if (Zt.fromBufferAttribute(Mt, Nt[0]),
                        Yt.fromBufferAttribute(Mt, Nt[1]),
                        sr.fromBufferAttribute(Mt, Nt[2]),
                        Yv.getNormal(uy),
                        Wt[0] = `${
Math.round(Zt.x * ft)},${
Math.round(Zt.y * ft)},${
Math.round(Zt.z * ft)}`,
                        Wt[1] = `${
Math.round(Yt.x * ft)},${
Math.round(Yt.y * ft)},${
Math.round(Yt.z * ft)}`,
                        Wt[2] = `${
Math.round(sr.x * ft)},${
Math.round(sr.y * ft)},${
Math.round(sr.z * ft)}`,
                        Wt[0] !== Wt[1] && Wt[1] !== Wt[2] && Wt[2] !== Wt[0])
                            for (let er = 0; er < 3; er++) {
                                const rr = (er + 1) % 3
                                  , xr = Wt[er]
                                  , br = Wt[rr]
                                  , yr = Yv[jt[er]]
                                  , Pr = Yv[jt[rr]]
                                  , zr = `${
xr}_${
br}`
                                  , Nr = `${
br}_${
xr}`;
                                Nr in Qt && Qt[Nr] ? (uy.dot(Qt[Nr].normal) <= xt && (qt.push(yr.x, yr.y, yr.z),
                                qt.push(Pr.x, Pr.y, Pr.z)),
                                Qt[Nr] = null) : zr in Qt || (Qt[zr] = {
                                    index0: Nt[er],
                                    index1: Nt[rr],
                                    normal: uy.clone()
                                })
                            }
                    }
                    for (const Xt in Qt)
                        if (Qt[Xt]) {
                            const {
index0: Zt, index1: Yt} = Qt[Xt];
                            $v.fromBufferAttribute(Mt, Zt),
                            Xv.fromBufferAttribute(Mt, Yt),
                            qt.push($v.x, $v.y, $v.z),
                            qt.push(Xv.x, Xv.y, Xv.z)
                        }
                    this.setAttribute("position", new Fn(qt,3))
                }
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
        }
        class Pp extends E_ {
            constructor(tt) {
                super(tt),
                this.uuid = Ms(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(tt) {
                const lt = [];
                for (let mt = 0, ft = this.holes.length; mt < ft; mt++)
                    lt[mt] = this.holes[mt].getPoints(tt);
                return lt
            }
            extractPoints(tt) {
                return {
                    shape: this.getPoints(tt),
                    holes: this.getPointsHoles(tt)
                }
            }
            copy(tt) {
                super.copy(tt),
                this.holes = [];
                for (let lt = 0, mt = tt.holes.length; lt < mt; lt++) {
                    const ft = tt.holes[lt];
                    this.holes.push(ft.clone())
                }
                return this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.uuid = this.uuid,
                tt.holes = [];
                for (let lt = 0, mt = this.holes.length; lt < mt; lt++) {
                    const ft = this.holes[lt];
                    tt.holes.push(ft.toJSON())
                }
                return tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.uuid = tt.uuid,
                this.holes = [];
                for (let lt = 0, mt = tt.holes.length; lt < mt; lt++) {
                    const ft = tt.holes[lt];
                    this.holes.push(new E_().fromJSON(ft))
                }
                return this
            }
        }
        function tA(Tt, tt, lt, mt, ft) {
            let xt, Ct;
            if (ft === function(Mt, Lt, Nt, jt) {
                let Wt = 0;
                for (let Qt = Lt, qt = Nt - jt; Qt < Nt; Qt += jt)
                    Wt += (Mt[qt] - Mt[Qt]) * (Mt[Qt + 1] + Mt[qt + 1]),
                    qt = Qt;
                return Wt
            }(Tt, tt, lt, mt) > 0)
                for (xt = tt; xt < lt; xt += mt)
                    Ct = iA(xt, Tt[xt], Tt[xt + 1], Ct);
            else
                for (xt = lt - mt; xt >= tt; xt -= mt)
                    Ct = iA(xt, Tt[xt], Tt[xt + 1], Ct);
            return Ct && Kv(Ct, Ct.next) && (M_(Ct),
            Ct = Ct.next),
            Ct
        }
        function Mp(Tt, tt) {
            if (!Tt)
                return Tt;
            tt || (tt = Tt);
            let lt, mt = Tt;
            do
                if (lt = !1,
                mt.steiner || !Kv(mt, mt.next) && Ko(mt.prev, mt, mt.next) !== 0)
                    mt = mt.next;
                else {
                    if (M_(mt),
                    mt = tt = mt.prev,
                    mt === mt.next)
                        break;
                    lt = !0
                }
            while (lt || mt !== tt);
            return tt
        }
        function C_(Tt, tt, lt, mt, ft, xt, Ct) {
            if (!Tt)
                return;
            !Ct && xt && function(jt, Wt, Qt, qt) {
                let Xt = jt;
                do
                    Xt.z === 0 && (Xt.z = dy(Xt.x, Xt.y, Wt, Qt, qt)),
                    Xt.prevZ = Xt.prev,
                    Xt.nextZ = Xt.next,
                    Xt = Xt.next;
                while (Xt !== jt);
                Xt.prevZ.nextZ = null,
                Xt.prevZ = null,
                function(Zt) {
                    let Yt, sr, er, rr, xr, br, yr, Pr, zr = 1;
                    do {
                        for (sr = Zt,
                        Zt = null,
                        xr = null,
                        br = 0; sr; ) {
                            for (br++,
                            er = sr,
                            yr = 0,
                            Yt = 0; Yt < zr && (yr++,
                            er = er.nextZ,
                            er); Yt++)
                                ;
                            for (Pr = zr; yr > 0 || Pr > 0 && er; )
                                yr !== 0 && (Pr === 0 || !er || sr.z <= er.z) ? (rr = sr,
                                sr = sr.nextZ,
                                yr--) : (rr = er,
                                er = er.nextZ,
                                Pr--),
                                xr ? xr.nextZ = rr : Zt = rr,
                                rr.prevZ = xr,
                                xr = rr;
                            sr = er
                        }
                        xr.nextZ = null,
                        zr *= 2
                    } while (br > 1)
                }(Xt)
            }(Tt, mt, ft, xt);
            let Mt, Lt, Nt = Tt;
            for (; Tt.prev !== Tt.next; )
                if (Mt = Tt.prev,
                Lt = Tt.next,
                xt ? hS(Tt, mt, ft, xt) : pS(Tt))
                    tt.push(Mt.i / lt | 0),
                    tt.push(Tt.i / lt | 0),
                    tt.push(Lt.i / lt | 0),
                    M_(Tt),
                    Tt = Lt.next,
                    Nt = Lt.next;
                else if ((Tt = Lt) === Nt) {
                    Ct ? Ct === 1 ? C_(Tt = mS(Mp(Tt), tt, lt), tt, lt, mt, ft, xt, 2) : Ct === 2 && fS(Tt, tt, lt, mt, ft, xt) : C_(Mp(Tt), tt, lt, mt, ft, xt, 1);
                    break
                }
        }
        function pS(Tt) {
            const tt = Tt.prev
              , lt = Tt
              , mt = Tt.next;
            if (Ko(tt, lt, mt) >= 0)
                return !1;
            const ft = tt.x
              , xt = lt.x
              , Ct = mt.x
              , Mt = tt.y
              , Lt = lt.y
              , Nt = mt.y
              , jt = ft < xt ? ft < Ct ? ft : Ct : xt < Ct ? xt : Ct
              , Wt = Mt < Lt ? Mt < Nt ? Mt : Nt : Lt < Nt ? Lt : Nt
              , Qt = ft > xt ? ft > Ct ? ft : Ct : xt > Ct ? xt : Ct
              , qt = Mt > Lt ? Mt > Nt ? Mt : Nt : Lt > Nt ? Lt : Nt;
            let Xt = mt.next;
            for (; Xt !== tt; ) {
                if (Xt.x >= jt && Xt.x <= Qt && Xt.y >= Wt && Xt.y <= qt && km(ft, Mt, xt, Lt, Ct, Nt, Xt.x, Xt.y) && Ko(Xt.prev, Xt, Xt.next) >= 0)
                    return !1;
                Xt = Xt.next
            }
            return !0
        }
        function hS(Tt, tt, lt, mt) {
            const ft = Tt.prev
              , xt = Tt
              , Ct = Tt.next;
            if (Ko(ft, xt, Ct) >= 0)
                return !1;
            const Mt = ft.x
              , Lt = xt.x
              , Nt = Ct.x
              , jt = ft.y
              , Wt = xt.y
              , Qt = Ct.y
              , qt = Mt < Lt ? Mt < Nt ? Mt : Nt : Lt < Nt ? Lt : Nt
              , Xt = jt < Wt ? jt < Qt ? jt : Qt : Wt < Qt ? Wt : Qt
              , Zt = Mt > Lt ? Mt > Nt ? Mt : Nt : Lt > Nt ? Lt : Nt
              , Yt = jt > Wt ? jt > Qt ? jt : Qt : Wt > Qt ? Wt : Qt
              , sr = dy(qt, Xt, tt, lt, mt)
              , er = dy(Zt, Yt, tt, lt, mt);
            let rr = Tt.prevZ
              , xr = Tt.nextZ;
            for (; rr && rr.z >= sr && xr && xr.z <= er; ) {
                if (rr.x >= qt && rr.x <= Zt && rr.y >= Xt && rr.y <= Yt && rr !== ft && rr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, rr.x, rr.y) && Ko(rr.prev, rr, rr.next) >= 0 || (rr = rr.prevZ,
                xr.x >= qt && xr.x <= Zt && xr.y >= Xt && xr.y <= Yt && xr !== ft && xr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, xr.x, xr.y) && Ko(xr.prev, xr, xr.next) >= 0))
                    return !1;
                xr = xr.nextZ
            }
            for (; rr && rr.z >= sr; ) {
                if (rr.x >= qt && rr.x <= Zt && rr.y >= Xt && rr.y <= Yt && rr !== ft && rr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, rr.x, rr.y) && Ko(rr.prev, rr, rr.next) >= 0)
                    return !1;
                rr = rr.prevZ
            }
            for (; xr && xr.z <= er; ) {
                if (xr.x >= qt && xr.x <= Zt && xr.y >= Xt && xr.y <= Yt && xr !== ft && xr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, xr.x, xr.y) && Ko(xr.prev, xr, xr.next) >= 0)
                    return !1;
                xr = xr.nextZ
            }
            return !0
        }
        function mS(Tt, tt, lt) {
            let mt = Tt;
            do {
                const ft = mt.prev
                  , xt = mt.next.next;
                !Kv(ft, xt) && rA(ft, mt, mt.next, xt) && P_(ft, xt) && P_(xt, ft) && (tt.push(ft.i / lt | 0),
                tt.push(mt.i / lt | 0),
                tt.push(xt.i / lt | 0),
                M_(mt),
                M_(mt.next),
                mt = Tt = xt),
                mt = mt.next
            } while (mt !== Tt);
            return Mp(mt)
        }
        function fS(Tt, tt, lt, mt, ft, xt) {
            let Ct = Tt;
            do {
                let Mt = Ct.next.next;
                for (; Mt !== Ct.prev; ) {
                    if (Ct.i !== Mt.i && xS(Ct, Mt)) {
                        let Lt = nA(Ct, Mt);
                        return Ct = Mp(Ct, Ct.next),
                        Lt = Mp(Lt, Lt.next),
                        C_(Ct, tt, lt, mt, ft, xt, 0),
                        void C_(Lt, tt, lt, mt, ft, xt, 0)
                    }
                    Mt = Mt.next
                }
                Ct = Ct.next
            } while (Ct !== Tt)
        }
        function gS(Tt, tt) {
            return Tt.x - tt.x
        }
        function _S(Tt, tt) {
            const lt = function(ft, xt) {
                let Ct, Mt = xt, Lt = -1 / 0;
                const Nt = ft.x
                  , jt = ft.y;
                do {
                    if (jt <= Mt.y && jt >= Mt.next.y && Mt.next.y !== Mt.y) {
                        const Yt = Mt.x + (jt - Mt.y) * (Mt.next.x - Mt.x) / (Mt.next.y - Mt.y);
                        if (Yt <= Nt && Yt > Lt && (Lt = Yt,
                        Ct = Mt.x < Mt.next.x ? Mt : Mt.next,
                        Yt === Nt))
                            return Ct
                    }
                    Mt = Mt.next
                } while (Mt !== xt);
                if (!Ct)
                    return null;
                const Wt = Ct
                  , Qt = Ct.x
                  , qt = Ct.y;
                let Xt, Zt = 1 / 0;
                Mt = Ct;
                do
                    Nt >= Mt.x && Mt.x >= Qt && Nt !== Mt.x && km(jt < qt ? Nt : Lt, jt, Qt, qt, jt < qt ? Lt : Nt, jt, Mt.x, Mt.y) && (Xt = Math.abs(jt - Mt.y) / (Nt - Mt.x),
                    P_(Mt, ft) && (Xt < Zt || Xt === Zt && (Mt.x > Ct.x || Mt.x === Ct.x && vS(Ct, Mt))) && (Ct = Mt,
                    Zt = Xt)),
                    Mt = Mt.next;
                while (Mt !== Wt);
                return Ct
            }(Tt, tt);
            if (!lt)
                return tt;
            const mt = nA(lt, Tt);
            return Mp(mt, mt.next),
            Mp(lt, lt.next)
        }
        function vS(Tt, tt) {
            return Ko(Tt.prev, Tt, tt.prev) < 0 && Ko(tt.next, Tt, Tt.next) < 0
        }
        function dy(Tt, tt, lt, mt, ft) {
            return (Tt = 1431655765 & ((Tt = 858993459 & ((Tt = 252645135 & ((Tt = 16711935 & ((Tt = (Tt - lt) * ft | 0) | Tt << 8)) | Tt << 4)) | Tt << 2)) | Tt << 1)) | (tt = 1431655765 & ((tt = 858993459 & ((tt = 252645135 & ((tt = 16711935 & ((tt = (tt - mt) * ft | 0) | tt << 8)) | tt << 4)) | tt << 2)) | tt << 1)) << 1
        }
        function yS(Tt) {
            let tt = Tt
              , lt = Tt;
            do
                (tt.x < lt.x || tt.x === lt.x && tt.y < lt.y) && (lt = tt),
                tt = tt.next;
            while (tt !== Tt);
            return lt
        }
        function km(Tt, tt, lt, mt, ft, xt, Ct, Mt) {
            return (ft - Ct) * (tt - Mt) >= (Tt - Ct) * (xt - Mt) && (Tt - Ct) * (mt - Mt) >= (lt - Ct) * (tt - Mt) && (lt - Ct) * (xt - Mt) >= (ft - Ct) * (mt - Mt)
        }
        function xS(Tt, tt) {
            return Tt.next.i !== tt.i && Tt.prev.i !== tt.i && !function(lt, mt) {
                let ft = lt;
                do {
                    if (ft.i !== lt.i && ft.next.i !== lt.i && ft.i !== mt.i && ft.next.i !== mt.i && rA(ft, ft.next, lt, mt))
                        return !0;
                    ft = ft.next
                } while (ft !== lt);
                return !1
            }(Tt, tt) && (P_(Tt, tt) && P_(tt, Tt) && function(lt, mt) {
                let ft = lt
                  , xt = !1;
                const Ct = (lt.x + mt.x) / 2
                  , Mt = (lt.y + mt.y) / 2;
                do
                    ft.y > Mt != ft.next.y > Mt && ft.next.y !== ft.y && Ct < (ft.next.x - ft.x) * (Mt - ft.y) / (ft.next.y - ft.y) + ft.x && (xt = !xt),
                    ft = ft.next;
                while (ft !== lt);
                return xt
            }(Tt, tt) && (Ko(Tt.prev, Tt, tt.prev) || Ko(Tt, tt.prev, tt)) || Kv(Tt, tt) && Ko(Tt.prev, Tt, Tt.next) > 0 && Ko(tt.prev, tt, tt.next) > 0)
        }
        function Ko(Tt, tt, lt) {
            return (tt.y - Tt.y) * (lt.x - tt.x) - (tt.x - Tt.x) * (lt.y - tt.y)
        }
        function Kv(Tt, tt) {
            return Tt.x === tt.x && Tt.y === tt.y
        }
        function rA(Tt, tt, lt, mt) {
            const ft = Zv(Ko(Tt, tt, lt))
              , xt = Zv(Ko(Tt, tt, mt))
              , Ct = Zv(Ko(lt, mt, Tt))
              , Mt = Zv(Ko(lt, mt, tt));
            return ft !== xt && Ct !== Mt || !(ft !== 0 || !Jv(Tt, lt, tt)) || !(xt !== 0 || !Jv(Tt, mt, tt)) || !(Ct !== 0 || !Jv(lt, Tt, mt)) || !(Mt !== 0 || !Jv(lt, tt, mt))
        }
        function Jv(Tt, tt, lt) {
            return tt.x <= Math.max(Tt.x, lt.x) && tt.x >= Math.min(Tt.x, lt.x) && tt.y <= Math.max(Tt.y, lt.y) && tt.y >= Math.min(Tt.y, lt.y)
        }
        function Zv(Tt) {
            return Tt > 0 ? 1 : Tt < 0 ? -1 : 0
        }
        function P_(Tt, tt) {
            return Ko(Tt.prev, Tt, Tt.next) < 0 ? Ko(Tt, tt, Tt.next) >= 0 && Ko(Tt, Tt.prev, tt) >= 0 : Ko(Tt, tt, Tt.prev) < 0 || Ko(Tt, Tt.next, tt) < 0
        }
        function nA(Tt, tt) {
            const lt = new py(Tt.i,Tt.x,Tt.y)
              , mt = new py(tt.i,tt.x,tt.y)
              , ft = Tt.next
              , xt = tt.prev;
            return Tt.next = tt,
            tt.prev = Tt,
            lt.next = ft,
            ft.prev = lt,
            mt.next = lt,
            lt.prev = mt,
            xt.next = mt,
            mt.prev = xt,
            mt
        }
        function iA(Tt, tt, lt, mt) {
            const ft = new py(Tt,tt,lt);
            return mt ? (ft.next = mt.next,
            ft.prev = mt,
            mt.next.prev = ft,
            mt.next = ft) : (ft.prev = ft,
            ft.next = ft),
            ft
        }
        function M_(Tt) {
            Tt.next.prev = Tt.prev,
            Tt.prev.next = Tt.next,
            Tt.prevZ && (Tt.prevZ.nextZ = Tt.nextZ),
            Tt.nextZ && (Tt.nextZ.prevZ = Tt.prevZ)
        }
        function py(Tt, tt, lt) {
            this.i = Tt,
            this.x = tt,
            this.y = lt,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class ou {
            static area(tt) {
                const lt = tt.length;
                let mt = 0;
                for (let ft = lt - 1, xt = 0; xt < lt; ft = xt++)
                    mt += tt[ft].x * tt[xt].y - tt[xt].x * tt[ft].y;
                return .5 * mt
            }
            static isClockWise(tt) {
                return ou.area(tt) < 0
            }
            static triangulateShape(tt, lt) {
                const mt = []
                  , ft = []
                  , xt = [];
                oA(tt),
                sA(mt, tt);
                let Ct = tt.length;
                lt.forEach(oA);
                for (let Lt = 0; Lt < lt.length; Lt++)
                    ft.push(Ct),
                    Ct += lt[Lt].length,
                    sA(mt, lt[Lt]);
                const Mt = function(Lt, Nt, jt=2) {
                    const Wt = Nt && Nt.length
                      , Qt = Wt ? Nt[0] * jt : Lt.length;
                    let qt = tA(Lt, 0, Qt, jt, !0);
                    const Xt = [];
                    if (!qt || qt.next === qt.prev)
                        return Xt;
                    let Zt, Yt, sr, er, rr, xr, br;
                    if (Wt && (qt = function(yr, Pr, zr, Nr) {
                        const Vr = [];
                        let Gr, Hr, _n, dn, kn;
                        for (Gr = 0,
                        Hr = Pr.length; Gr < Hr; Gr++)
                            _n = Pr[Gr] * Nr,
                            dn = Gr < Hr - 1 ? Pr[Gr + 1] * Nr : yr.length,
                            kn = tA(yr, _n, dn, Nr, !1),
                            kn === kn.next && (kn.steiner = !0),
                            Vr.push(yS(kn));
                        for (Vr.sort(gS),
                        Gr = 0; Gr < Vr.length; Gr++)
                            zr = _S(Vr[Gr], zr);
                        return zr
                    }(Lt, Nt, qt, jt)),
                    Lt.length > 80 * jt) {
                        Zt = sr = Lt[0],
                        Yt = er = Lt[1];
                        for (let yr = jt; yr < Qt; yr += jt)
                            rr = Lt[yr],
                            xr = Lt[yr + 1],
                            rr < Zt && (Zt = rr),
                            xr < Yt && (Yt = xr),
                            rr > sr && (sr = rr),
                            xr > er && (er = xr);
                        br = Math.max(sr - Zt, er - Yt),
                        br = br !== 0 ? 32767 / br : 0
                    }
                    return C_(qt, Xt, jt, Zt, Yt, br, 0),
                    Xt
                }(mt, ft);
                for (let Lt = 0; Lt < Mt.length; Lt += 3)
                    xt.push(Mt.slice(Lt, Lt + 3));
                return xt
            }
        }
        function oA(Tt) {
            const tt = Tt.length;
            tt > 2 && Tt[tt - 1].equals(Tt[0]) && Tt.pop()
        }
        function sA(Tt, tt) {
            for (let lt = 0; lt < tt.length; lt++)
                Tt.push(tt[lt].x),
                Tt.push(tt[lt].y)
        }
        class e0 extends bo {
            constructor(tt=new Pp([new mn(.5,.5), new mn(-.5,.5), new mn(-.5,-.5), new mn(.5,-.5)]), lt={}) {
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: tt,
                    options: lt
                },
                tt = Array.isArray(tt) ? tt : [tt];
                const mt = this
                  , ft = []
                  , xt = [];
                for (let Mt = 0, Lt = tt.length; Mt < Lt; Mt++)
                    Ct(tt[Mt]);
                function Ct(Mt) {
                    const Lt = []
                      , Nt = lt.curveSegments !== void 0 ? lt.curveSegments : 12
                      , jt = lt.steps !== void 0 ? lt.steps : 1
                      , Wt = lt.depth !== void 0 ? lt.depth : 1;
                    let Qt = lt.bevelEnabled === void 0 || lt.bevelEnabled
                      , qt = lt.bevelThickness !== void 0 ? lt.bevelThickness : .2
                      , Xt = lt.bevelSize !== void 0 ? lt.bevelSize : qt - .1
                      , Zt = lt.bevelOffset !== void 0 ? lt.bevelOffset : 0
                      , Yt = lt.bevelSegments !== void 0 ? lt.bevelSegments : 3;
                    const sr = lt.extrudePath
                      , er = lt.UVGenerator !== void 0 ? lt.UVGenerator : bS;
                    let rr, xr, br, yr, Pr, zr = !1;
                    sr && (rr = sr.getSpacedPoints(jt),
                    zr = !0,
                    Qt = !1,
                    xr = sr.computeFrenetFrames(jt, !1),
                    br = new Er,
                    yr = new Er,
                    Pr = new Er),
                    Qt || (Yt = 0,
                    qt = 0,
                    Xt = 0,
                    Zt = 0);
                    const Nr = Mt.extractPoints(Nt);
                    let Vr = Nr.shape;
                    const Gr = Nr.holes;
                    if (!ou.isClockWise(Vr)) {
                        Vr = Vr.reverse();
                        for (let Fr = 0, Wr = Gr.length; Fr < Wr; Fr++) {
                            const kr = Gr[Fr];
                            ou.isClockWise(kr) && (Gr[Fr] = kr.reverse())
                        }
                    }
                    const Hr = ou.triangulateShape(Vr, Gr)
                      , _n = Vr;
                    for (let Fr = 0, Wr = Gr.length; Fr < Wr; Fr++) {
                        const kr = Gr[Fr];
                        Vr = Vr.concat(kr)
                    }
                    function dn(Fr, Wr, kr) {
                        return Wr || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        Fr.clone().addScaledVector(Wr, kr)
                    }
                    const kn = Vr.length
                      , Bn = Hr.length;
                    function cn(Fr, Wr, kr) {
                        let _r, Br, Lr;
                        const Xr = Fr.x - Wr.x
                          , Kr = Fr.y - Wr.y
                          , An = kr.x - Fr.x
                          , pn = kr.y - Fr.y
                          , _o = Xr * Xr + Kr * Kr
                          , to = Xr * pn - Kr * An;
                        if (Math.abs(to) > Number.EPSILON) {
                            const Pn = Math.sqrt(_o)
                              , eo = Math.sqrt(An * An + pn * pn)
                              , Kn = Wr.x - Kr / Pn
                              , po = Wr.y + Xr / Pn
                              , Ao = ((kr.x - pn / eo - Kn) * pn - (kr.y + An / eo - po) * An) / (Xr * pn - Kr * An);
                            _r = Kn + Xr * Ao - Fr.x,
                            Br = po + Kr * Ao - Fr.y;
                            const Fo = _r * _r + Br * Br;
                            if (Fo <= 2)
                                return new mn(_r,Br);
                            Lr = Math.sqrt(Fo / 2)
                        } else {
                            let Pn = !1;
                            Xr > Number.EPSILON ? An > Number.EPSILON && (Pn = !0) : Xr < -Number.EPSILON ? An < -Number.EPSILON && (Pn = !0) : Math.sign(Kr) === Math.sign(pn) && (Pn = !0),
                            Pn ? (_r = -Kr,
                            Br = Xr,
                            Lr = Math.sqrt(_o)) : (_r = Xr,
                            Br = Kr,
                            Lr = Math.sqrt(_o / 2))
                        }
                        return new mn(_r / Lr,Br / Lr)
                    }
                    const Yr = [];
                    for (let Fr = 0, Wr = _n.length, kr = Wr - 1, _r = Fr + 1; Fr < Wr; Fr++,
                    kr++,
                    _r++)
                        kr === Wr && (kr = 0),
                        _r === Wr && (_r = 0),
                        Yr[Fr] = cn(_n[Fr], _n[kr], _n[_r]);
                    const Jr = [];
                    let sn, on = Yr.concat();
                    for (let Fr = 0, Wr = Gr.length; Fr < Wr; Fr++) {
                        const kr = Gr[Fr];
                        sn = [];
                        for (let _r = 0, Br = kr.length, Lr = Br - 1, Xr = _r + 1; _r < Br; _r++,
                        Lr++,
                        Xr++)
                            Lr === Br && (Lr = 0),
                            Xr === Br && (Xr = 0),
                            sn[_r] = cn(kr[_r], kr[Lr], kr[Xr]);
                        Jr.push(sn),
                        on = on.concat(sn)
                    }
                    for (let Fr = 0; Fr < Yt; Fr++) {
                        const Wr = Fr / Yt
                          , kr = qt * Math.cos(Wr * Math.PI / 2)
                          , _r = Xt * Math.sin(Wr * Math.PI / 2) + Zt;
                        for (let Br = 0, Lr = _n.length; Br < Lr; Br++) {
                            const Xr = dn(_n[Br], Yr[Br], _r);
                            Zn(Xr.x, Xr.y, -kr)
                        }
                        for (let Br = 0, Lr = Gr.length; Br < Lr; Br++) {
                            const Xr = Gr[Br];
                            sn = Jr[Br];
                            for (let Kr = 0, An = Xr.length; Kr < An; Kr++) {
                                const pn = dn(Xr[Kr], sn[Kr], _r);
                                Zn(pn.x, pn.y, -kr)
                            }
                        }
                    }
                    const Un = Xt + Zt;
                    for (let Fr = 0; Fr < kn; Fr++) {
                        const Wr = Qt ? dn(Vr[Fr], on[Fr], Un) : Vr[Fr];
                        zr ? (yr.copy(xr.normals[0]).multiplyScalar(Wr.x),
                        br.copy(xr.binormals[0]).multiplyScalar(Wr.y),
                        Pr.copy(rr[0]).add(yr).add(br),
                        Zn(Pr.x, Pr.y, Pr.z)) : Zn(Wr.x, Wr.y, 0)
                    }
                    for (let Fr = 1; Fr <= jt; Fr++)
                        for (let Wr = 0; Wr < kn; Wr++) {
                            const kr = Qt ? dn(Vr[Wr], on[Wr], Un) : Vr[Wr];
                            zr ? (yr.copy(xr.normals[Fr]).multiplyScalar(kr.x),
                            br.copy(xr.binormals[Fr]).multiplyScalar(kr.y),
                            Pr.copy(rr[Fr]).add(yr).add(br),
                            Zn(Pr.x, Pr.y, Pr.z)) : Zn(kr.x, kr.y, Wt / jt * Fr)
                        }
                    for (let Fr = Yt - 1; Fr >= 0; Fr--) {
                        const Wr = Fr / Yt
                          , kr = qt * Math.cos(Wr * Math.PI / 2)
                          , _r = Xt * Math.sin(Wr * Math.PI / 2) + Zt;
                        for (let Br = 0, Lr = _n.length; Br < Lr; Br++) {
                            const Xr = dn(_n[Br], Yr[Br], _r);
                            Zn(Xr.x, Xr.y, Wt + kr)
                        }
                        for (let Br = 0, Lr = Gr.length; Br < Lr; Br++) {
                            const Xr = Gr[Br];
                            sn = Jr[Br];
                            for (let Kr = 0, An = Xr.length; Kr < An; Kr++) {
                                const pn = dn(Xr[Kr], sn[Kr], _r);
                                zr ? Zn(pn.x, pn.y + rr[jt - 1].y, rr[jt - 1].x + kr) : Zn(pn.x, pn.y, Wt + kr)
                            }
                        }
                    }
                    function ro(Fr, Wr) {
                        let kr = Fr.length;
                        for (; --kr >= 0; ) {
                            const _r = kr;
                            let Br = kr - 1;
                            Br < 0 && (Br = Fr.length - 1);
                            for (let Lr = 0, Xr = jt + 2 * Yt; Lr < Xr; Lr++) {
                                const Kr = kn * Lr
                                  , An = kn * (Lr + 1);
                                uo(Wr + _r + Kr, Wr + Br + Kr, Wr + Br + An, Wr + _r + An)
                            }
                        }
                    }
                    function Zn(Fr, Wr, kr) {
                        Lt.push(Fr),
                        Lt.push(Wr),
                        Lt.push(kr)
                    }
                    function jn(Fr, Wr, kr) {
                        Dr(Fr),
                        Dr(Wr),
                        Dr(kr);
                        const _r = ft.length / 3
                          , Br = er.generateTopUV(mt, ft, _r - 3, _r - 2, _r - 1);
                        Sr(Br[0]),
                        Sr(Br[1]),
                        Sr(Br[2])
                    }
                    function uo(Fr, Wr, kr, _r) {
                        Dr(Fr),
                        Dr(Wr),
                        Dr(_r),
                        Dr(Wr),
                        Dr(kr),
                        Dr(_r);
                        const Br = ft.length / 3
                          , Lr = er.generateSideWallUV(mt, ft, Br - 6, Br - 3, Br - 2, Br - 1);
                        Sr(Lr[0]),
                        Sr(Lr[1]),
                        Sr(Lr[3]),
                        Sr(Lr[1]),
                        Sr(Lr[2]),
                        Sr(Lr[3])
                    }
                    function Dr(Fr) {
                        ft.push(Lt[3 * Fr + 0]),
                        ft.push(Lt[3 * Fr + 1]),
                        ft.push(Lt[3 * Fr + 2])
                    }
                    function Sr(Fr) {
                        xt.push(Fr.x),
                        xt.push(Fr.y)
                    }
                    (function() {
                        const Fr = ft.length / 3;
                        if (Qt) {
                            let Wr = 0
                              , kr = kn * Wr;
                            for (let _r = 0; _r < Bn; _r++) {
                                const Br = Hr[_r];
                                jn(Br[2] + kr, Br[1] + kr, Br[0] + kr)
                            }
                            Wr = jt + 2 * Yt,
                            kr = kn * Wr;
                            for (let _r = 0; _r < Bn; _r++) {
                                const Br = Hr[_r];
                                jn(Br[0] + kr, Br[1] + kr, Br[2] + kr)
                            }
                        } else {
                            for (let Wr = 0; Wr < Bn; Wr++) {
                                const kr = Hr[Wr];
                                jn(kr[2], kr[1], kr[0])
                            }
                            for (let Wr = 0; Wr < Bn; Wr++) {
                                const kr = Hr[Wr];
                                jn(kr[0] + kn * jt, kr[1] + kn * jt, kr[2] + kn * jt)
                            }
                        }
                        mt.addGroup(Fr, ft.length / 3 - Fr, 0)
                    }
                    )(),
                    function() {
                        const Fr = ft.length / 3;
                        let Wr = 0;
                        ro(_n, Wr),
                        Wr += _n.length;
                        for (let kr = 0, _r = Gr.length; kr < _r; kr++) {
                            const Br = Gr[kr];
                            ro(Br, Wr),
                            Wr += Br.length
                        }
                        mt.addGroup(Fr, ft.length / 3 - Fr, 1)
                    }()
                }
                this.setAttribute("position", new Fn(ft,3)),
                this.setAttribute("uv", new Fn(xt,2)),
                this.computeVertexNormals()
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return function(lt, mt, ft) {
                    if (ft.shapes = [],
                    Array.isArray(lt))
                        for (let xt = 0, Ct = lt.length; xt < Ct; xt++) {
                            const Mt = lt[xt];
                            ft.shapes.push(Mt.uuid)
                        }
                    else
                        ft.shapes.push(lt.uuid);
                    return ft.options = Object.assign({}, mt),
                    mt.extrudePath !== void 0 && (ft.options.extrudePath = mt.extrudePath.toJSON()),
                    ft
                }(this.parameters.shapes, this.parameters.options, tt)
            }
            static fromJSON(tt, lt) {
                const mt = [];
                for (let xt = 0, Ct = tt.shapes.length; xt < Ct; xt++) {
                    const Mt = lt[tt.shapes[xt]];
                    mt.push(Mt)
                }
                const ft = tt.options.extrudePath;
                return ft !== void 0 && (tt.options.extrudePath = new zv[ft.type]().fromJSON(ft)),
                new e0(mt,tt.options)
            }
        }
        const bS = {
            generateTopUV: function(Tt, tt, lt, mt, ft) {
                const xt = tt[3 * lt]
                  , Ct = tt[3 * lt + 1]
                  , Mt = tt[3 * mt]
                  , Lt = tt[3 * mt + 1]
                  , Nt = tt[3 * ft]
                  , jt = tt[3 * ft + 1];
                return [new mn(xt,Ct), new mn(Mt,Lt), new mn(Nt,jt)]
            },
            generateSideWallUV: function(Tt, tt, lt, mt, ft, xt) {
                const Ct = tt[3 * lt]
                  , Mt = tt[3 * lt + 1]
                  , Lt = tt[3 * lt + 2]
                  , Nt = tt[3 * mt]
                  , jt = tt[3 * mt + 1]
                  , Wt = tt[3 * mt + 2]
                  , Qt = tt[3 * ft]
                  , qt = tt[3 * ft + 1]
                  , Xt = tt[3 * ft + 2]
                  , Zt = tt[3 * xt]
                  , Yt = tt[3 * xt + 1]
                  , sr = tt[3 * xt + 2];
                return Math.abs(Mt - jt) < Math.abs(Ct - Nt) ? [new mn(Ct,1 - Lt), new mn(Nt,1 - Wt), new mn(Qt,1 - Xt), new mn(Zt,1 - sr)] : [new mn(Mt,1 - Lt), new mn(jt,1 - Wt), new mn(qt,1 - Xt), new mn(Yt,1 - sr)]
            }
        };
        class t0 extends tp {
            constructor(tt=1, lt=0) {
                const mt = (1 + Math.sqrt(5)) / 2;
                super([-1, mt, 0, 1, mt, 0, -1, -mt, 0, 1, -mt, 0, 0, -1, mt, 0, 1, mt, 0, -1, -mt, 0, 1, -mt, mt, 0, -1, mt, 0, 1, -mt, 0, -1, -mt, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], tt, lt),
                this.type = "IcosahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new t0(tt.radius,tt.detail)
            }
        }
        class R_ extends tp {
            constructor(tt=1, lt=0) {
                super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], tt, lt),
                this.type = "OctahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new R_(tt.radius,tt.detail)
            }
        }
        class r0 extends bo {
            constructor(tt=.5, lt=1, mt=32, ft=1, xt=0, Ct=2 * Math.PI) {
                super(),
                this.type = "RingGeometry",
                this.parameters = {
                    innerRadius: tt,
                    outerRadius: lt,
                    thetaSegments: mt,
                    phiSegments: ft,
                    thetaStart: xt,
                    thetaLength: Ct
                },
                mt = Math.max(3, mt);
                const Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = [];
                let Wt = tt;
                const Qt = (lt - tt) / (ft = Math.max(1, ft))
                  , qt = new Er
                  , Xt = new mn;
                for (let Zt = 0; Zt <= ft; Zt++) {
                    for (let Yt = 0; Yt <= mt; Yt++) {
                        const sr = xt + Yt / mt * Ct;
                        qt.x = Wt * Math.cos(sr),
                        qt.y = Wt * Math.sin(sr),
                        Lt.push(qt.x, qt.y, qt.z),
                        Nt.push(0, 0, 1),
                        Xt.x = (qt.x / lt + 1) / 2,
                        Xt.y = (qt.y / lt + 1) / 2,
                        jt.push(Xt.x, Xt.y)
                    }
                    Wt += Qt
                }
                for (let Zt = 0; Zt < ft; Zt++) {
                    const Yt = Zt * (mt + 1);
                    for (let sr = 0; sr < mt; sr++) {
                        const er = sr + Yt
                          , rr = er
                          , xr = er + mt + 1
                          , br = er + mt + 2
                          , yr = er + 1;
                        Mt.push(rr, xr, yr),
                        Mt.push(xr, br, yr)
                    }
                }
                this.setIndex(Mt),
                this.setAttribute("position", new Fn(Lt,3)),
                this.setAttribute("normal", new Fn(Nt,3)),
                this.setAttribute("uv", new Fn(jt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new r0(tt.innerRadius,tt.outerRadius,tt.thetaSegments,tt.phiSegments,tt.thetaStart,tt.thetaLength)
            }
        }
        class n0 extends bo {
            constructor(tt=new Pp([new mn(0,.5), new mn(-.5,-.5), new mn(.5,-.5)]), lt=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: tt,
                    curveSegments: lt
                };
                const mt = []
                  , ft = []
                  , xt = []
                  , Ct = [];
                let Mt = 0
                  , Lt = 0;
                if (Array.isArray(tt) === !1)
                    Nt(tt);
                else
                    for (let jt = 0; jt < tt.length; jt++)
                        Nt(tt[jt]),
                        this.addGroup(Mt, Lt, jt),
                        Mt += Lt,
                        Lt = 0;
                function Nt(jt) {
                    const Wt = ft.length / 3
                      , Qt = jt.extractPoints(lt);
                    let qt = Qt.shape;
                    const Xt = Qt.holes;
                    ou.isClockWise(qt) === !1 && (qt = qt.reverse());
                    for (let Yt = 0, sr = Xt.length; Yt < sr; Yt++) {
                        const er = Xt[Yt];
                        ou.isClockWise(er) === !0 && (Xt[Yt] = er.reverse())
                    }
                    const Zt = ou.triangulateShape(qt, Xt);
                    for (let Yt = 0, sr = Xt.length; Yt < sr; Yt++) {
                        const er = Xt[Yt];
                        qt = qt.concat(er)
                    }
                    for (let Yt = 0, sr = qt.length; Yt < sr; Yt++) {
                        const er = qt[Yt];
                        ft.push(er.x, er.y, 0),
                        xt.push(0, 0, 1),
                        Ct.push(er.x, er.y)
                    }
                    for (let Yt = 0, sr = Zt.length; Yt < sr; Yt++) {
                        const er = Zt[Yt]
                          , rr = er[0] + Wt
                          , xr = er[1] + Wt
                          , br = er[2] + Wt;
                        mt.push(rr, xr, br),
                        Lt += 3
                    }
                }
                this.setIndex(mt),
                this.setAttribute("position", new Fn(ft,3)),
                this.setAttribute("normal", new Fn(xt,3)),
                this.setAttribute("uv", new Fn(Ct,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return function(lt, mt) {
                    if (mt.shapes = [],
                    Array.isArray(lt))
                        for (let ft = 0, xt = lt.length; ft < xt; ft++) {
                            const Ct = lt[ft];
                            mt.shapes.push(Ct.uuid)
                        }
                    else
                        mt.shapes.push(lt.uuid);
                    return mt
                }(this.parameters.shapes, tt)
            }
            static fromJSON(tt, lt) {
                const mt = [];
                for (let ft = 0, xt = tt.shapes.length; ft < xt; ft++) {
                    const Ct = lt[tt.shapes[ft]];
                    mt.push(Ct)
                }
                return new n0(mt,tt.curveSegments)
            }
        }
        class I_ extends bo {
            constructor(tt=1, lt=32, mt=16, ft=0, xt=2 * Math.PI, Ct=0, Mt=Math.PI) {
                super(),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: tt,
                    widthSegments: lt,
                    heightSegments: mt,
                    phiStart: ft,
                    phiLength: xt,
                    thetaStart: Ct,
                    thetaLength: Mt
                },
                lt = Math.max(3, Math.floor(lt)),
                mt = Math.max(2, Math.floor(mt));
                const Lt = Math.min(Ct + Mt, Math.PI);
                let Nt = 0;
                const jt = []
                  , Wt = new Er
                  , Qt = new Er
                  , qt = []
                  , Xt = []
                  , Zt = []
                  , Yt = [];
                for (let sr = 0; sr <= mt; sr++) {
                    const er = []
                      , rr = sr / mt;
                    let xr = 0;
                    sr === 0 && Ct === 0 ? xr = .5 / lt : sr === mt && Lt === Math.PI && (xr = -.5 / lt);
                    for (let br = 0; br <= lt; br++) {
                        const yr = br / lt;
                        Wt.x = -tt * Math.cos(ft + yr * xt) * Math.sin(Ct + rr * Mt),
                        Wt.y = tt * Math.cos(Ct + rr * Mt),
                        Wt.z = tt * Math.sin(ft + yr * xt) * Math.sin(Ct + rr * Mt),
                        Xt.push(Wt.x, Wt.y, Wt.z),
                        Qt.copy(Wt).normalize(),
                        Zt.push(Qt.x, Qt.y, Qt.z),
                        Yt.push(yr + xr, 1 - rr),
                        er.push(Nt++)
                    }
                    jt.push(er)
                }
                for (let sr = 0; sr < mt; sr++)
                    for (let er = 0; er < lt; er++) {
                        const rr = jt[sr][er + 1]
                          , xr = jt[sr][er]
                          , br = jt[sr + 1][er]
                          , yr = jt[sr + 1][er + 1];
                        (sr !== 0 || Ct > 0) && qt.push(rr, xr, yr),
                        (sr !== mt - 1 || Lt < Math.PI) && qt.push(xr, br, yr)
                    }
                this.setIndex(qt),
                this.setAttribute("position", new Fn(Xt,3)),
                this.setAttribute("normal", new Fn(Zt,3)),
                this.setAttribute("uv", new Fn(Yt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new I_(tt.radius,tt.widthSegments,tt.heightSegments,tt.phiStart,tt.phiLength,tt.thetaStart,tt.thetaLength)
            }
        }
        class i0 extends tp {
            constructor(tt=1, lt=0) {
                super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], tt, lt),
                this.type = "TetrahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new i0(tt.radius,tt.detail)
            }
        }
        class o0 extends bo {
            constructor(tt=1, lt=.4, mt=12, ft=48, xt=2 * Math.PI) {
                super(),
                this.type = "TorusGeometry",
                this.parameters = {
                    radius: tt,
                    tube: lt,
                    radialSegments: mt,
                    tubularSegments: ft,
                    arc: xt
                },
                mt = Math.floor(mt),
                ft = Math.floor(ft);
                const Ct = []
                  , Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = new Er
                  , Wt = new Er
                  , Qt = new Er;
                for (let qt = 0; qt <= mt; qt++)
                    for (let Xt = 0; Xt <= ft; Xt++) {
                        const Zt = Xt / ft * xt
                          , Yt = qt / mt * Math.PI * 2;
                        Wt.x = (tt + lt * Math.cos(Yt)) * Math.cos(Zt),
                        Wt.y = (tt + lt * Math.cos(Yt)) * Math.sin(Zt),
                        Wt.z = lt * Math.sin(Yt),
                        Mt.push(Wt.x, Wt.y, Wt.z),
                        jt.x = tt * Math.cos(Zt),
                        jt.y = tt * Math.sin(Zt),
                        Qt.subVectors(Wt, jt).normalize(),
                        Lt.push(Qt.x, Qt.y, Qt.z),
                        Nt.push(Xt / ft),
                        Nt.push(qt / mt)
                    }
                for (let qt = 1; qt <= mt; qt++)
                    for (let Xt = 1; Xt <= ft; Xt++) {
                        const Zt = (ft + 1) * qt + Xt - 1
                          , Yt = (ft + 1) * (qt - 1) + Xt - 1
                          , sr = (ft + 1) * (qt - 1) + Xt
                          , er = (ft + 1) * qt + Xt;
                        Ct.push(Zt, Yt, er),
                        Ct.push(Yt, sr, er)
                    }
                this.setIndex(Ct),
                this.setAttribute("position", new Fn(Mt,3)),
                this.setAttribute("normal", new Fn(Lt,3)),
                this.setAttribute("uv", new Fn(Nt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new o0(tt.radius,tt.tube,tt.radialSegments,tt.tubularSegments,tt.arc)
            }
        }
        class s0 extends bo {
            constructor(tt=1, lt=.4, mt=64, ft=8, xt=2, Ct=3) {
                super(),
                this.type = "TorusKnotGeometry",
                this.parameters = {
                    radius: tt,
                    tube: lt,
                    tubularSegments: mt,
                    radialSegments: ft,
                    p: xt,
                    q: Ct
                },
                mt = Math.floor(mt),
                ft = Math.floor(ft);
                const Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = []
                  , Wt = new Er
                  , Qt = new Er
                  , qt = new Er
                  , Xt = new Er
                  , Zt = new Er
                  , Yt = new Er
                  , sr = new Er;
                for (let rr = 0; rr <= mt; ++rr) {
                    const xr = rr / mt * xt * Math.PI * 2;
                    er(xr, xt, Ct, tt, qt),
                    er(xr + .01, xt, Ct, tt, Xt),
                    Yt.subVectors(Xt, qt),
                    sr.addVectors(Xt, qt),
                    Zt.crossVectors(Yt, sr),
                    sr.crossVectors(Zt, Yt),
                    Zt.normalize(),
                    sr.normalize();
                    for (let br = 0; br <= ft; ++br) {
                        const yr = br / ft * Math.PI * 2
                          , Pr = -lt * Math.cos(yr)
                          , zr = lt * Math.sin(yr);
                        Wt.x = qt.x + (Pr * sr.x + zr * Zt.x),
                        Wt.y = qt.y + (Pr * sr.y + zr * Zt.y),
                        Wt.z = qt.z + (Pr * sr.z + zr * Zt.z),
                        Lt.push(Wt.x, Wt.y, Wt.z),
                        Qt.subVectors(Wt, qt).normalize(),
                        Nt.push(Qt.x, Qt.y, Qt.z),
                        jt.push(rr / mt),
                        jt.push(br / ft)
                    }
                }
                for (let rr = 1; rr <= mt; rr++)
                    for (let xr = 1; xr <= ft; xr++) {
                        const br = (ft + 1) * (rr - 1) + (xr - 1)
                          , yr = (ft + 1) * rr + (xr - 1)
                          , Pr = (ft + 1) * rr + xr
                          , zr = (ft + 1) * (rr - 1) + xr;
                        Mt.push(br, yr, zr),
                        Mt.push(yr, Pr, zr)
                    }
                function er(rr, xr, br, yr, Pr) {
                    const zr = Math.cos(rr)
                      , Nr = Math.sin(rr)
                      , Vr = br / xr * rr
                      , Gr = Math.cos(Vr);
                    Pr.x = yr * (2 + Gr) * .5 * zr,
                    Pr.y = yr * (2 + Gr) * Nr * .5,
                    Pr.z = yr * Math.sin(Vr) * .5
                }
                this.setIndex(Mt),
                this.setAttribute("position", new Fn(Lt,3)),
                this.setAttribute("normal", new Fn(Nt,3)),
                this.setAttribute("uv", new Fn(jt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new s0(tt.radius,tt.tube,tt.tubularSegments,tt.radialSegments,tt.p,tt.q)
            }
        }
        class a0 extends bo {
            constructor(tt=new ly(new Er(-1,-1,0),new Er(-1,1,0),new Er(1,1,0)), lt=64, mt=1, ft=8, xt=!1) {
                super(),
                this.type = "TubeGeometry",
                this.parameters = {
                    path: tt,
                    tubularSegments: lt,
                    radius: mt,
                    radialSegments: ft,
                    closed: xt
                };
                const Ct = tt.computeFrenetFrames(lt, xt);
                this.tangents = Ct.tangents,
                this.normals = Ct.normals,
                this.binormals = Ct.binormals;
                const Mt = new Er
                  , Lt = new Er
                  , Nt = new mn;
                let jt = new Er;
                const Wt = []
                  , Qt = []
                  , qt = []
                  , Xt = [];
                function Zt(Yt) {
                    jt = tt.getPointAt(Yt / lt, jt);
                    const sr = Ct.normals[Yt]
                      , er = Ct.binormals[Yt];
                    for (let rr = 0; rr <= ft; rr++) {
                        const xr = rr / ft * Math.PI * 2
                          , br = Math.sin(xr)
                          , yr = -Math.cos(xr);
                        Lt.x = yr * sr.x + br * er.x,
                        Lt.y = yr * sr.y + br * er.y,
                        Lt.z = yr * sr.z + br * er.z,
                        Lt.normalize(),
                        Qt.push(Lt.x, Lt.y, Lt.z),
                        Mt.x = jt.x + mt * Lt.x,
                        Mt.y = jt.y + mt * Lt.y,
                        Mt.z = jt.z + mt * Lt.z,
                        Wt.push(Mt.x, Mt.y, Mt.z)
                    }
                }
                (function() {
                    for (let Yt = 0; Yt < lt; Yt++)
                        Zt(Yt);
                    Zt(xt === !1 ? lt : 0),
                    function() {
                        for (let Yt = 0; Yt <= lt; Yt++)
                            for (let sr = 0; sr <= ft; sr++)
                                Nt.x = Yt / lt,
                                Nt.y = sr / ft,
                                qt.push(Nt.x, Nt.y)
                    }(),
                    function() {
                        for (let Yt = 1; Yt <= lt; Yt++)
                            for (let sr = 1; sr <= ft; sr++) {
                                const er = (ft + 1) * (Yt - 1) + (sr - 1)
                                  , rr = (ft + 1) * Yt + (sr - 1)
                                  , xr = (ft + 1) * Yt + sr
                                  , br = (ft + 1) * (Yt - 1) + sr;
                                Xt.push(er, rr, br),
                                Xt.push(rr, xr, br)
                            }
                    }()
                }
                )(),
                this.setIndex(Xt),
                this.setAttribute("position", new Fn(Wt,3)),
                this.setAttribute("normal", new Fn(Qt,3)),
                this.setAttribute("uv", new Fn(qt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.path = this.parameters.path.toJSON(),
                tt
            }
            static fromJSON(tt) {
                return new a0(new zv[tt.path.type]().fromJSON(tt.path),tt.tubularSegments,tt.radius,tt.radialSegments,tt.closed)
            }
        }
        class aA extends bo {
            constructor(tt=null) {
                if (super(),
                this.type = "WireframeGeometry",
                this.parameters = {
                    geometry: tt
                },
                tt !== null) {
                    const lt = []
                      , mt = new Set
                      , ft = new Er
                      , xt = new Er;
                    if (tt.index !== null) {
                        const Ct = tt.attributes.position
                          , Mt = tt.index;
                        let Lt = tt.groups;
                        Lt.length === 0 && (Lt = [{
                            start: 0,
                            count: Mt.count,
                            materialIndex: 0
                        }]);
                        for (let Nt = 0, jt = Lt.length; Nt < jt; ++Nt) {
                            const Wt = Lt[Nt]
                              , Qt = Wt.start;
                            for (let qt = Qt, Xt = Qt + Wt.count; qt < Xt; qt += 3)
                                for (let Zt = 0; Zt < 3; Zt++) {
                                    const Yt = Mt.getX(qt + Zt)
                                      , sr = Mt.getX(qt + (Zt + 1) % 3);
                                    ft.fromBufferAttribute(Ct, Yt),
                                    xt.fromBufferAttribute(Ct, sr),
                                    lA(ft, xt, mt) === !0 && (lt.push(ft.x, ft.y, ft.z),
                                    lt.push(xt.x, xt.y, xt.z))
                                }
                        }
                    } else {
                        const Ct = tt.attributes.position;
                        for (let Mt = 0, Lt = Ct.count / 3; Mt < Lt; Mt++)
                            for (let Nt = 0; Nt < 3; Nt++) {
                                const jt = 3 * Mt + Nt
                                  , Wt = 3 * Mt + (Nt + 1) % 3;
                                ft.fromBufferAttribute(Ct, jt),
                                xt.fromBufferAttribute(Ct, Wt),
                                lA(ft, xt, mt) === !0 && (lt.push(ft.x, ft.y, ft.z),
                                lt.push(xt.x, xt.y, xt.z))
                            }
                    }
                    this.setAttribute("position", new Fn(lt,3))
                }
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
        }
        function lA(Tt, tt, lt) {
            const mt = `${
Tt.x},${
Tt.y},${
Tt.z}-${
tt.x},${
tt.y},${
tt.z}`
              , ft = `${
tt.x},${
tt.y},${
tt.z}-${
Tt.x},${
Tt.y},${
Tt.z}`;
            return lt.has(mt) !== !0 && lt.has(ft) !== !0 && (lt.add(mt),
            lt.add(ft),
            !0)
        }
        var cA = Object.freeze({
            __proto__: null,
            BoxGeometry: Zu,
            CapsuleGeometry: Hv,
            CircleGeometry: Qv,
            ConeGeometry: Wv,
            CylinderGeometry: Im,
            DodecahedronGeometry: qv,
            EdgesGeometry: eA,
            ExtrudeGeometry: e0,
            IcosahedronGeometry: t0,
            LatheGeometry: T_,
            OctahedronGeometry: R_,
            PlaneGeometry: g_,
            PolyhedronGeometry: tp,
            RingGeometry: r0,
            ShapeGeometry: n0,
            SphereGeometry: I_,
            TetrahedronGeometry: i0,
            TorusGeometry: o0,
            TorusKnotGeometry: s0,
            TubeGeometry: a0,
            WireframeGeometry: aA
        });
        class uA extends hs {
            constructor(tt) {
                super(),
                this.isShadowMaterial = !0,
                this.type = "ShadowMaterial",
                this.color = new Gn(0),
                this.transparent = !0,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.fog = tt.fog,
                this
            }
        }
        class dA extends zl {
            constructor(tt) {
                super(tt),
                this.isRawShaderMaterial = !0,
                this.type = "RawShaderMaterial"
            }
        }
        class hy extends hs {
            constructor(tt) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new Gn(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(tt.color),
                this.roughness = tt.roughness,
                this.metalness = tt.metalness,
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.roughnessMap = tt.roughnessMap,
                this.metalnessMap = tt.metalnessMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.envMapIntensity = tt.envMapIntensity,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class pA extends hy {
            constructor(tt) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new mn(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return qo(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(lt) {
                        this.ior = (1 + .4 * lt) / (1 - .4 * lt)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new Gn(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new Gn(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new Gn(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(tt)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(tt) {
                this._anisotropy > 0 != tt > 0 && this.version++,
                this._anisotropy = tt
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(tt) {
                this._clearcoat > 0 != tt > 0 && this.version++,
                this._clearcoat = tt
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(tt) {
                this._iridescence > 0 != tt > 0 && this.version++,
                this._iridescence = tt
            }
            get sheen() {
                return this._sheen
            }
            set sheen(tt) {
                this._sheen > 0 != tt > 0 && this.version++,
                this._sheen = tt
            }
            get transmission() {
                return this._transmission
            }
            set transmission(tt) {
                this._transmission > 0 != tt > 0 && this.version++,
                this._transmission = tt
            }
            copy(tt) {
                return super.copy(tt),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = tt.anisotropy,
                this.anisotropyRotation = tt.anisotropyRotation,
                this.anisotropyMap = tt.anisotropyMap,
                this.clearcoat = tt.clearcoat,
                this.clearcoatMap = tt.clearcoatMap,
                this.clearcoatRoughness = tt.clearcoatRoughness,
                this.clearcoatRoughnessMap = tt.clearcoatRoughnessMap,
                this.clearcoatNormalMap = tt.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(tt.clearcoatNormalScale),
                this.ior = tt.ior,
                this.iridescence = tt.iridescence,
                this.iridescenceMap = tt.iridescenceMap,
                this.iridescenceIOR = tt.iridescenceIOR,
                this.iridescenceThicknessRange = [...tt.iridescenceThicknessRange],
                this.iridescenceThicknessMap = tt.iridescenceThicknessMap,
                this.sheen = tt.sheen,
                this.sheenColor.copy(tt.sheenColor),
                this.sheenColorMap = tt.sheenColorMap,
                this.sheenRoughness = tt.sheenRoughness,
                this.sheenRoughnessMap = tt.sheenRoughnessMap,
                this.transmission = tt.transmission,
                this.transmissionMap = tt.transmissionMap,
                this.thickness = tt.thickness,
                this.thicknessMap = tt.thicknessMap,
                this.attenuationDistance = tt.attenuationDistance,
                this.attenuationColor.copy(tt.attenuationColor),
                this.specularIntensity = tt.specularIntensity,
                this.specularIntensityMap = tt.specularIntensityMap,
                this.specularColor.copy(tt.specularColor),
                this.specularColorMap = tt.specularColorMap,
                this
            }
        }
        class hA extends hs {
            constructor(tt) {
                super(),
                this.isMeshPhongMaterial = !0,
                this.type = "MeshPhongMaterial",
                this.color = new Gn(16777215),
                this.specular = new Gn(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Wn,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.specular.copy(tt.specular),
                this.shininess = tt.shininess,
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.specularMap = tt.specularMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.combine = tt.combine,
                this.reflectivity = tt.reflectivity,
                this.refractionRatio = tt.refractionRatio,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class mA extends hs {
            constructor(tt) {
                super(),
                this.isMeshToonMaterial = !0,
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.gradientMap = tt.gradientMap,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.alphaMap = tt.alphaMap,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.fog = tt.fog,
                this
            }
        }
        class fA extends hs {
            constructor(tt) {
                super(),
                this.isMeshNormalMaterial = !0,
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.flatShading = !1,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.flatShading = tt.flatShading,
                this
            }
        }
        class gA extends hs {
            constructor(tt) {
                super(),
                this.isMeshLambertMaterial = !0,
                this.type = "MeshLambertMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Wn,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.specularMap = tt.specularMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.combine = tt.combine,
                this.reflectivity = tt.reflectivity,
                this.refractionRatio = tt.refractionRatio,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class _A extends hs {
            constructor(tt) {
                super(),
                this.isMeshMatcapMaterial = !0,
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new Gn(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(tt.color),
                this.matcap = tt.matcap,
                this.map = tt.map,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.alphaMap = tt.alphaMap,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class vA extends Gs {
            constructor(tt) {
                super(),
                this.isLineDashedMaterial = !0,
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.scale = tt.scale,
                this.dashSize = tt.dashSize,
                this.gapSize = tt.gapSize,
                this
            }
        }
        function Rp(Tt, tt, lt) {
            return !Tt || !lt && Tt.constructor === tt ? Tt : typeof tt.BYTES_PER_ELEMENT == "number" ? new tt(Tt) : Array.prototype.slice.call(Tt)
        }
        function yA(Tt) {
            return ArrayBuffer.isView(Tt) && !(Tt instanceof DataView)
        }
        function xA(Tt) {
            const tt = Tt.length
              , lt = new Array(tt);
            for (let mt = 0; mt !== tt; ++mt)
                lt[mt] = mt;
            return lt.sort(function(mt, ft) {
                return Tt[mt] - Tt[ft]
            }),
            lt
        }
        function my(Tt, tt, lt) {
            const mt = Tt.length
              , ft = new Tt.constructor(mt);
            for (let xt = 0, Ct = 0; Ct !== mt; ++xt) {
                const Mt = lt[xt] * tt;
                for (let Lt = 0; Lt !== tt; ++Lt)
                    ft[Ct++] = Tt[Mt + Lt]
            }
            return ft
        }
        function fy(Tt, tt, lt, mt) {
            let ft = 1
              , xt = Tt[0];
            for (; xt !== void 0 && xt[mt] === void 0; )
                xt = Tt[ft++];
            if (xt === void 0)
                return;
            let Ct = xt[mt];
            if (Ct !== void 0)
                if (Array.isArray(Ct))
                    do
                        Ct = xt[mt],
                        Ct !== void 0 && (tt.push(xt.time),
                        lt.push.apply(lt, Ct)),
                        xt = Tt[ft++];
                    while (xt !== void 0);
                else if (Ct.toArray !== void 0)
                    do
                        Ct = xt[mt],
                        Ct !== void 0 && (tt.push(xt.time),
                        Ct.toArray(lt, lt.length)),
                        xt = Tt[ft++];
                    while (xt !== void 0);
                else
                    do
                        Ct = xt[mt],
                        Ct !== void 0 && (tt.push(xt.time),
                        lt.push(Ct)),
                        xt = Tt[ft++];
                    while (xt !== void 0)
        }
        const AS = {
            convertArray: Rp,
            isTypedArray: yA,
            getKeyframeOrder: xA,
            sortedArray: my,
            flattenJSON: fy,
            subclip: function(Tt, tt, lt, mt, ft=30) {
                const xt = Tt.clone();
                xt.name = tt;
                const Ct = [];
                for (let Lt = 0; Lt < xt.tracks.length; ++Lt) {
                    const Nt = xt.tracks[Lt]
                      , jt = Nt.getValueSize()
                      , Wt = []
                      , Qt = [];
                    for (let qt = 0; qt < Nt.times.length; ++qt) {
                        const Xt = Nt.times[qt] * ft;
                        if (!(Xt < lt || Xt >= mt)) {
                            Wt.push(Nt.times[qt]);
                            for (let Zt = 0; Zt < jt; ++Zt)
                                Qt.push(Nt.values[qt * jt + Zt])
                        }
                    }
                    Wt.length !== 0 && (Nt.times = Rp(Wt, Nt.times.constructor),
                    Nt.values = Rp(Qt, Nt.values.constructor),
                    Ct.push(Nt))
                }
                xt.tracks = Ct;
                let Mt = 1 / 0;
                for (let Lt = 0; Lt < xt.tracks.length; ++Lt)
                    Mt > xt.tracks[Lt].times[0] && (Mt = xt.tracks[Lt].times[0]);
                for (let Lt = 0; Lt < xt.tracks.length; ++Lt)
                    xt.tracks[Lt].shift(-1 * Mt);
                return xt.resetDuration(),
                xt
            },
            makeClipAdditive: function(Tt, tt=0, lt=Tt, mt=30) {
                mt <= 0 && (mt = 30);
                const ft = lt.tracks.length
                  , xt = tt / mt;
                for (let Ct = 0; Ct < ft; ++Ct) {
                    const Mt = lt.tracks[Ct]
                      , Lt = Mt.ValueTypeName;
                    if (Lt === "bool" || Lt === "string")
                        continue;
                    const Nt = Tt.tracks.find(function(sr) {
                        return sr.name === Mt.name && sr.ValueTypeName === Lt
                    });
                    if (Nt === void 0)
                        continue;
                    let jt = 0;
                    const Wt = Mt.getValueSize();
                    Mt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (jt = Wt / 3);
                    let Qt = 0;
                    const qt = Nt.getValueSize();
                    Nt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (Qt = qt / 3);
                    const Xt = Mt.times.length - 1;
                    let Zt;
                    if (xt <= Mt.times[0]) {
                        const sr = jt
                          , er = Wt - jt;
                        Zt = Mt.values.slice(sr, er)
                    } else if (xt >= Mt.times[Xt]) {
                        const sr = Xt * Wt + jt
                          , er = sr + Wt - jt;
                        Zt = Mt.values.slice(sr, er)
                    } else {
                        const sr = Mt.createInterpolant()
                          , er = jt
                          , rr = Wt - jt;
                        sr.evaluate(xt),
                        Zt = sr.resultBuffer.slice(er, rr)
                    }
                    Lt === "quaternion" && new Is().fromArray(Zt).normalize().conjugate().toArray(Zt);
                    const Yt = Nt.times.length;
                    for (let sr = 0; sr < Yt; ++sr) {
                        const er = sr * qt + Qt;
                        if (Lt === "quaternion")
                            Is.multiplyQuaternionsFlat(Nt.values, er, Zt, 0, Nt.values, er);
                        else {
                            const rr = qt - 2 * Qt;
                            for (let xr = 0; xr < rr; ++xr)
                                Nt.values[er + xr] -= Zt[xr]
                        }
                    }
                }
                return Tt.blendMode = Xp,
                Tt
            }
        };
        class k_ {
            constructor(tt, lt, mt, ft) {
                this.parameterPositions = tt,
                this._cachedIndex = 0,
                this.resultBuffer = ft !== void 0 ? ft : new lt.constructor(mt),
                this.sampleValues = lt,
                this.valueSize = mt,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(tt) {
                const lt = this.parameterPositions;
                let mt = this._cachedIndex
                  , ft = lt[mt]
                  , xt = lt[mt - 1];
                e: {
                    t: {
                        let Ct;
                        r: {
                            n: if (!(tt < ft)) {
                                for (let Mt = mt + 2; ; ) {
                                    if (ft === void 0) {
                                        if (tt < xt)
                                            break n;
                                        return mt = lt.length,
                                        this._cachedIndex = mt,
                                        this.copySampleValue_(mt - 1)
                                    }
                                    if (mt === Mt)
                                        break;
                                    if (xt = ft,
                                    ft = lt[++mt],
                                    tt < ft)
                                        break t
                                }
                                Ct = lt.length;
                                break r
                            }
                            if (tt >= xt)
                                break e;
                            {
                                const Mt = lt[1];
                                tt < Mt && (mt = 2,
                                xt = Mt);
                                for (let Lt = mt - 2; ; ) {
                                    if (xt === void 0)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (mt === Lt)
                                        break;
                                    if (ft = xt,
                                    xt = lt[--mt - 1],
                                    tt >= xt)
                                        break t
                                }
                                Ct = mt,
                                mt = 0
                            }
                        }
                        for (; mt < Ct; ) {
                            const Mt = mt + Ct >>> 1;
                            tt < lt[Mt] ? Ct = Mt : mt = Mt + 1
                        }
                        if (ft = lt[mt],
                        xt = lt[mt - 1],
                        xt === void 0)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (ft === void 0)
                            return mt = lt.length,
                            this._cachedIndex = mt,
                            this.copySampleValue_(mt - 1)
                    }
                    this._cachedIndex = mt,
                    this.intervalChanged_(mt, xt, ft)
                }
                return this.interpolate_(mt, xt, tt, ft)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(tt) {
                const lt = this.resultBuffer
                  , mt = this.sampleValues
                  , ft = this.valueSize
                  , xt = tt * ft;
                for (let Ct = 0; Ct !== ft; ++Ct)
                    lt[Ct] = mt[xt + Ct];
                return lt
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class bA extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: du,
                    endingEnd: du
                }
            }
            intervalChanged_(tt, lt, mt) {
                const ft = this.parameterPositions;
                let xt = tt - 2
                  , Ct = tt + 1
                  , Mt = ft[xt]
                  , Lt = ft[Ct];
                if (Mt === void 0)
                    switch (this.getSettings_().endingStart) {
                    case pu:
                        xt = tt,
                        Mt = 2 * lt - mt;
                        break;
                    case cp:
                        xt = ft.length - 2,
                        Mt = lt + ft[xt] - ft[xt + 1];
                        break;
                    default:
                        xt = tt,
                        Mt = mt
                    }
                if (Lt === void 0)
                    switch (this.getSettings_().endingEnd) {
                    case pu:
                        Ct = tt,
                        Lt = 2 * mt - lt;
                        break;
                    case cp:
                        Ct = 1,
                        Lt = mt + ft[1] - ft[0];
                        break;
                    default:
                        Ct = tt - 1,
                        Lt = lt
                    }
                const Nt = .5 * (mt - lt)
                  , jt = this.valueSize;
                this._weightPrev = Nt / (lt - Mt),
                this._weightNext = Nt / (Lt - mt),
                this._offsetPrev = xt * jt,
                this._offsetNext = Ct * jt
            }
            interpolate_(tt, lt, mt, ft) {
                const xt = this.resultBuffer
                  , Ct = this.sampleValues
                  , Mt = this.valueSize
                  , Lt = tt * Mt
                  , Nt = Lt - Mt
                  , jt = this._offsetPrev
                  , Wt = this._offsetNext
                  , Qt = this._weightPrev
                  , qt = this._weightNext
                  , Xt = (mt - lt) / (ft - lt)
                  , Zt = Xt * Xt
                  , Yt = Zt * Xt
                  , sr = -Qt * Yt + 2 * Qt * Zt - Qt * Xt
                  , er = (1 + Qt) * Yt + (-1.5 - 2 * Qt) * Zt + (-.5 + Qt) * Xt + 1
                  , rr = (-1 - qt) * Yt + (1.5 + qt) * Zt + .5 * Xt
                  , xr = qt * Yt - qt * Zt;
                for (let br = 0; br !== Mt; ++br)
                    xt[br] = sr * Ct[jt + br] + er * Ct[Nt + br] + rr * Ct[Lt + br] + xr * Ct[Wt + br];
                return xt
            }
        }
        class gy extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft)
            }
            interpolate_(tt, lt, mt, ft) {
                const xt = this.resultBuffer
                  , Ct = this.sampleValues
                  , Mt = this.valueSize
                  , Lt = tt * Mt
                  , Nt = Lt - Mt
                  , jt = (mt - lt) / (ft - lt)
                  , Wt = 1 - jt;
                for (let Qt = 0; Qt !== Mt; ++Qt)
                    xt[Qt] = Ct[Nt + Qt] * Wt + Ct[Lt + Qt] * jt;
                return xt
            }
        }
        class AA extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft)
            }
            interpolate_(tt) {
                return this.copySampleValue_(tt - 1)
            }
        }
        class Ql {
            constructor(tt, lt, mt, ft) {
                if (tt === void 0)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (lt === void 0 || lt.length === 0)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + tt);
                this.name = tt,
                this.times = Rp(lt, this.TimeBufferType),
                this.values = Rp(mt, this.ValueBufferType),
                this.setInterpolation(ft || this.DefaultInterpolation)
            }
            static toJSON(tt) {
                const lt = tt.constructor;
                let mt;
                if (lt.toJSON !== this.toJSON)
                    mt = lt.toJSON(tt);
                else {
                    mt = {
                        name: tt.name,
                        times: Rp(tt.times, Array),
                        values: Rp(tt.values, Array)
                    };
                    const ft = tt.getInterpolation();
                    ft !== tt.DefaultInterpolation && (mt.interpolation = ft)
                }
                return mt.type = tt.ValueTypeName,
                mt
            }
            InterpolantFactoryMethodDiscrete(tt) {
                return new AA(this.times,this.values,this.getValueSize(),tt)
            }
            InterpolantFactoryMethodLinear(tt) {
                return new gy(this.times,this.values,this.getValueSize(),tt)
            }
            InterpolantFactoryMethodSmooth(tt) {
                return new bA(this.times,this.values,this.getValueSize(),tt)
            }
            setInterpolation(tt) {
                let lt;
                switch (tt) {
                case Bu:
                    lt = this.InterpolantFactoryMethodDiscrete;
                    break;
                case lp:
                    lt = this.InterpolantFactoryMethodLinear;
                    break;
                case $p:
                    lt = this.InterpolantFactoryMethodSmooth
                }
                if (lt === void 0) {
                    const mt = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (this.createInterpolant === void 0) {
                        if (tt === this.DefaultInterpolation)
                            throw new Error(mt);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", mt),
                    this
                }
                return this.createInterpolant = lt,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Bu;
                case this.InterpolantFactoryMethodLinear:
                    return lp;
                case this.InterpolantFactoryMethodSmooth:
                    return $p
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(tt) {
                if (tt !== 0) {
                    const lt = this.times;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt)
                        lt[mt] += tt
                }
                return this
            }
            scale(tt) {
                if (tt !== 1) {
                    const lt = this.times;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt)
                        lt[mt] *= tt
                }
                return this
            }
            trim(tt, lt) {
                const mt = this.times
                  , ft = mt.length;
                let xt = 0
                  , Ct = ft - 1;
                for (; xt !== ft && mt[xt] < tt; )
                    ++xt;
                for (; Ct !== -1 && mt[Ct] > lt; )
                    --Ct;
                if (++Ct,
                xt !== 0 || Ct !== ft) {
                    xt >= Ct && (Ct = Math.max(Ct, 1),
                    xt = Ct - 1);
                    const Mt = this.getValueSize();
                    this.times = mt.slice(xt, Ct),
                    this.values = this.values.slice(xt * Mt, Ct * Mt)
                }
                return this
            }
            validate() {
                let tt = !0;
                const lt = this.getValueSize();
                lt - Math.floor(lt) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                tt = !1);
                const mt = this.times
                  , ft = this.values
                  , xt = mt.length;
                xt === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                tt = !1);
                let Ct = null;
                for (let Mt = 0; Mt !== xt; Mt++) {
                    const Lt = mt[Mt];
                    if (typeof Lt == "number" && isNaN(Lt)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, Mt, Lt),
                        tt = !1;
                        break
                    }
                    if (Ct !== null && Ct > Lt) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, Mt, Lt, Ct),
                        tt = !1;
                        break
                    }
                    Ct = Lt
                }
                if (ft !== void 0 && yA(ft))
                    for (let Mt = 0, Lt = ft.length; Mt !== Lt; ++Mt) {
                        const Nt = ft[Mt];
                        if (isNaN(Nt)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, Mt, Nt),
                            tt = !1;
                            break
                        }
                    }
                return tt
            }
            optimize() {
                const tt = this.times.slice()
                  , lt = this.values.slice()
                  , mt = this.getValueSize()
                  , ft = this.getInterpolation() === $p
                  , xt = tt.length - 1;
                let Ct = 1;
                for (let Mt = 1; Mt < xt; ++Mt) {
                    let Lt = !1;
                    const Nt = tt[Mt];
                    if (Nt !== tt[Mt + 1] && (Mt !== 1 || Nt !== tt[0]))
                        if (ft)
                            Lt = !0;
                        else {
                            const jt = Mt * mt
                              , Wt = jt - mt
                              , Qt = jt + mt;
                            for (let qt = 0; qt !== mt; ++qt) {
                                const Xt = lt[jt + qt];
                                if (Xt !== lt[Wt + qt] || Xt !== lt[Qt + qt]) {
                                    Lt = !0;
                                    break
                                }
                            }
                        }
                    if (Lt) {
                        if (Mt !== Ct) {
                            tt[Ct] = tt[Mt];
                            const jt = Mt * mt
                              , Wt = Ct * mt;
                            for (let Qt = 0; Qt !== mt; ++Qt)
                                lt[Wt + Qt] = lt[jt + Qt]
                        }
                        ++Ct
                    }
                }
                if (xt > 0) {
                    tt[Ct] = tt[xt];
                    for (let Mt = xt * mt, Lt = Ct * mt, Nt = 0; Nt !== mt; ++Nt)
                        lt[Lt + Nt] = lt[Mt + Nt];
                    ++Ct
                }
                return Ct !== tt.length ? (this.times = tt.slice(0, Ct),
                this.values = lt.slice(0, Ct * mt)) : (this.times = tt,
                this.values = lt),
                this
            }
            clone() {
                const tt = this.times.slice()
                  , lt = this.values.slice()
                  , mt = new this.constructor(this.name,tt,lt);
                return mt.createInterpolant = this.createInterpolant,
                mt
            }
        }
        Ql.prototype.TimeBufferType = Float32Array,
        Ql.prototype.ValueBufferType = Float32Array,
        Ql.prototype.DefaultInterpolation = lp;
        class Ip extends Ql {
        }
        Ip.prototype.ValueTypeName = "bool",
        Ip.prototype.ValueBufferType = Array,
        Ip.prototype.DefaultInterpolation = Bu,
        Ip.prototype.InterpolantFactoryMethodLinear = void 0,
        Ip.prototype.InterpolantFactoryMethodSmooth = void 0;
        class _y extends Ql {
        }
        _y.prototype.ValueTypeName = "color";
        class D_ extends Ql {
        }
        D_.prototype.ValueTypeName = "number";
        class wA extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft)
            }
            interpolate_(tt, lt, mt, ft) {
                const xt = this.resultBuffer
                  , Ct = this.sampleValues
                  , Mt = this.valueSize
                  , Lt = (mt - lt) / (ft - lt);
                let Nt = tt * Mt;
                for (let jt = Nt + Mt; Nt !== jt; Nt += 4)
                    Is.slerpFlat(xt, 0, Ct, Nt - Mt, Ct, Nt, Lt);
                return xt
            }
        }
        class Dm extends Ql {
            InterpolantFactoryMethodLinear(tt) {
                return new wA(this.times,this.values,this.getValueSize(),tt)
            }
        }
        Dm.prototype.ValueTypeName = "quaternion",
        Dm.prototype.DefaultInterpolation = lp,
        Dm.prototype.InterpolantFactoryMethodSmooth = void 0;
        class kp extends Ql {
        }
        kp.prototype.ValueTypeName = "string",
        kp.prototype.ValueBufferType = Array,
        kp.prototype.DefaultInterpolation = Bu,
        kp.prototype.InterpolantFactoryMethodLinear = void 0,
        kp.prototype.InterpolantFactoryMethodSmooth = void 0;
        class B_ extends Ql {
        }
        B_.prototype.ValueTypeName = "vector";
        class L_ {
            constructor(tt, lt=-1, mt, ft=Hm) {
                this.name = tt,
                this.tracks = mt,
                this.duration = lt,
                this.blendMode = ft,
                this.uuid = Ms(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(tt) {
                const lt = []
                  , mt = tt.tracks
                  , ft = 1 / (tt.fps || 1);
                for (let Ct = 0, Mt = mt.length; Ct !== Mt; ++Ct)
                    lt.push(wS(mt[Ct]).scale(ft));
                const xt = new this(tt.name,tt.duration,lt,tt.blendMode);
                return xt.uuid = tt.uuid,
                xt
            }
            static toJSON(tt) {
                const lt = []
                  , mt = tt.tracks
                  , ft = {
                    name: tt.name,
                    duration: tt.duration,
                    tracks: lt,
                    uuid: tt.uuid,
                    blendMode: tt.blendMode
                };
                for (let xt = 0, Ct = mt.length; xt !== Ct; ++xt)
                    lt.push(Ql.toJSON(mt[xt]));
                return ft
            }
            static CreateFromMorphTargetSequence(tt, lt, mt, ft) {
                const xt = lt.length
                  , Ct = [];
                for (let Mt = 0; Mt < xt; Mt++) {
                    let Lt = []
                      , Nt = [];
                    Lt.push((Mt + xt - 1) % xt, Mt, (Mt + 1) % xt),
                    Nt.push(0, 1, 0);
                    const jt = xA(Lt);
                    Lt = my(Lt, 1, jt),
                    Nt = my(Nt, 1, jt),
                    ft || Lt[0] !== 0 || (Lt.push(xt),
                    Nt.push(Nt[0])),
                    Ct.push(new D_(".morphTargetInfluences[" + lt[Mt].name + "]",Lt,Nt).scale(1 / mt))
                }
                return new this(tt,-1,Ct)
            }
            static findByName(tt, lt) {
                let mt = tt;
                if (!Array.isArray(tt)) {
                    const ft = tt;
                    mt = ft.geometry && ft.geometry.animations || ft.animations
                }
                for (let ft = 0; ft < mt.length; ft++)
                    if (mt[ft].name === lt)
                        return mt[ft];
                return null
            }
            static CreateClipsFromMorphTargetSequences(tt, lt, mt) {
                const ft = {}
                  , xt = /^([\w-]*?)([\d]+)$/;
                for (let Mt = 0, Lt = tt.length; Mt < Lt; Mt++) {
                    const Nt = tt[Mt]
                      , jt = Nt.name.match(xt);
                    if (jt && jt.length > 1) {
                        const Wt = jt[1];
                        let Qt = ft[Wt];
                        Qt || (ft[Wt] = Qt = []),
                        Qt.push(Nt)
                    }
                }
                const Ct = [];
                for (const Mt in ft)
                    Ct.push(this.CreateFromMorphTargetSequence(Mt, ft[Mt], lt, mt));
                return Ct
            }
            static parseAnimation(tt, lt) {
                if (!tt)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const mt = function(jt, Wt, Qt, qt, Xt) {
                    if (Qt.length !== 0) {
                        const Zt = []
                          , Yt = [];
                        fy(Qt, Zt, Yt, qt),
                        Zt.length !== 0 && Xt.push(new jt(Wt,Zt,Yt))
                    }
                }
                  , ft = []
                  , xt = tt.name || "default"
                  , Ct = tt.fps || 30
                  , Mt = tt.blendMode;
                let Lt = tt.length || -1;
                const Nt = tt.hierarchy || [];
                for (let jt = 0; jt < Nt.length; jt++) {
                    const Wt = Nt[jt].keys;
                    if (Wt && Wt.length !== 0)
                        if (Wt[0].morphTargets) {
                            const Qt = {};
                            let qt;
                            for (qt = 0; qt < Wt.length; qt++)
                                if (Wt[qt].morphTargets)
                                    for (let Xt = 0; Xt < Wt[qt].morphTargets.length; Xt++)
                                        Qt[Wt[qt].morphTargets[Xt]] = -1;
                            for (const Xt in Qt) {
                                const Zt = []
                                  , Yt = [];
                                for (let sr = 0; sr !== Wt[qt].morphTargets.length; ++sr) {
                                    const er = Wt[qt];
                                    Zt.push(er.time),
                                    Yt.push(er.morphTarget === Xt ? 1 : 0)
                                }
                                ft.push(new D_(".morphTargetInfluence[" + Xt + "]",Zt,Yt))
                            }
                            Lt = Qt.length * Ct
                        } else {
                            const Qt = ".bones[" + lt[jt].name + "]";
                            mt(B_, Qt + ".position", Wt, "pos", ft),
                            mt(Dm, Qt + ".quaternion", Wt, "rot", ft),
                            mt(B_, Qt + ".scale", Wt, "scl", ft)
                        }
                }
                return ft.length === 0 ? null : new this(xt,Lt,ft,Mt)
            }
            resetDuration() {
                let tt = 0;
                for (let lt = 0, mt = this.tracks.length; lt !== mt; ++lt) {
                    const ft = this.tracks[lt];
                    tt = Math.max(tt, ft.times[ft.times.length - 1])
                }
                return this.duration = tt,
                this
            }
            trim() {
                for (let tt = 0; tt < this.tracks.length; tt++)
                    this.tracks[tt].trim(0, this.duration);
                return this
            }
            validate() {
                let tt = !0;
                for (let lt = 0; lt < this.tracks.length; lt++)
                    tt = tt && this.tracks[lt].validate();
                return tt
            }
            optimize() {
                for (let tt = 0; tt < this.tracks.length; tt++)
                    this.tracks[tt].optimize();
                return this
            }
            clone() {
                const tt = [];
                for (let lt = 0; lt < this.tracks.length; lt++)
                    tt.push(this.tracks[lt].clone());
                return new this.constructor(this.name,this.duration,tt,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function wS(Tt) {
            if (Tt.type === void 0)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const tt = function(lt) {
                switch (lt.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return D_;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return B_;
                case "color":
                    return _y;
                case "quaternion":
                    return Dm;
                case "bool":
                case "boolean":
                    return Ip;
                case "string":
                    return kp
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + lt)
            }(Tt.type);
            if (Tt.times === void 0) {
                const lt = []
                  , mt = [];
                fy(Tt.keys, lt, mt, "value"),
                Tt.times = lt,
                Tt.values = mt
            }
            return tt.parse !== void 0 ? tt.parse(Tt) : new tt(Tt.name,Tt.times,Tt.values,Tt.interpolation)
        }
        const Eu = {
            enabled: !1,
            files: {},
            add: function(Tt, tt) {
                this.enabled !== !1 && (this.files[Tt] = tt)
            },
            get: function(Tt, tt) {
                return this.enabled === !1 ? tt ? Promise.resolve() : void 0 : tt ? Promise.resolve(this.files[Tt]) : this.files[Tt]
            },
            remove: function(Tt) {
                delete this.files[Tt]
            },
            clear: function() {
                this.files = {}
            }
        };
        class vy {
            constructor(tt, lt, mt) {
                const ft = this;
                let xt, Ct = !1, Mt = 0, Lt = 0;
                const Nt = [];
                this.onStart = void 0,
                this.onLoad = tt,
                this.onProgress = lt,
                this.onError = mt,
                this.itemStart = function(jt) {
                    Lt++,
                    Ct === !1 && ft.onStart !== void 0 && ft.onStart(jt, Mt, Lt),
                    Ct = !0
                }
                ,
                this.itemEnd = function(jt) {
                    Mt++,
                    ft.onProgress !== void 0 && ft.onProgress(jt, Mt, Lt),
                    Mt === Lt && (Ct = !1,
                    ft.onLoad !== void 0 && ft.onLoad())
                }
                ,
                this.itemError = function(jt) {
                    ft.onError !== void 0 && ft.onError(jt)
                }
                ,
                this.resolveURL = function(jt) {
                    return xt ? xt(jt) : jt
                }
                ,
                this.setURLModifier = function(jt) {
                    return xt = jt,
                    this
                }
                ,
                this.addHandler = function(jt, Wt) {
                    return Nt.push(jt, Wt),
                    this
                }
                ,
                this.removeHandler = function(jt) {
                    const Wt = Nt.indexOf(jt);
                    return Wt !== -1 && Nt.splice(Wt, 2),
                    this
                }
                ,
                this.getHandler = function(jt) {
                    for (let Wt = 0, Qt = Nt.length; Wt < Qt; Wt += 2) {
                        const qt = Nt[Wt]
                          , Xt = Nt[Wt + 1];
                        if (qt.global && (qt.lastIndex = 0),
                        qt.test(jt))
                            return Xt
                    }
                    return null
                }
            }
        }
        const SA = new vy;
        class $s {
            constructor(tt) {
                this.manager = tt !== void 0 ? tt : SA,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(tt, lt) {
                const mt = this;
                return new Promise(function(ft, xt) {
                    mt.load(tt, ft, lt, xt)
                }
                )
            }
            parse() {}
            setCrossOrigin(tt) {
                return this.crossOrigin = tt,
                this
            }
            setWithCredentials(tt) {
                return this.withCredentials = tt,
                this
            }
            setPath(tt) {
                return this.path = tt,
                this
            }
            setResourcePath(tt) {
                return this.resourcePath = tt,
                this
            }
            setRequestHeader(tt) {
                return this.requestHeader = tt,
                this
            }
        }
        $s.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Tu = {};
        class SS extends Error {
            constructor(tt, lt) {
                super(tt),
                this.response = lt
            }
        }
        class su extends $s {
            constructor(tt) {
                super(tt),
                this.responseType = "text",
                this.useCache = !0
            }
            load(tt, lt, mt, ft) {
                tt === void 0 && (tt = ""),
                this.path !== void 0 && (tt = this.path + tt),
                tt = this.manager.resolveURL(tt),
                (this.useCache ? Eu.get(tt, this.responseType, this.mimeType) : Promise.resolve(void 0)).then(xt => {
                    if (xt !== void 0)
                        return this.manager.itemStart(tt),
                        setTimeout( () => {
                            lt && lt(xt),
                            this.manager.itemEnd(tt)
                        }
                        , 0),
                        xt;
                    if (Tu[tt] !== void 0)
                        return void Tu[tt].push({
                            onLoad: lt,
                            onProgress: mt,
                            onError: ft
                        });
                    Tu[tt] = [],
                    Tu[tt].push({
                        onLoad: lt,
                        onProgress: mt,
                        onError: ft
                    });
                    const Ct = new Request(tt,{
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    })
                      , Mt = this.mimeType
                      , Lt = this.responseType;
                    fetch(Ct).then(Nt => {
                        if (Nt.status === 200 || Nt.status === 0) {
                            if (Nt.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            typeof ReadableStream > "u" || Nt.body === void 0 || Nt.body.getReader === void 0)
                                return Nt;
                            const jt = Tu[tt]
                              , Wt = Nt.body.getReader()
                              , Qt = Nt.headers.get("Content-Length") || Nt.headers.get("X-File-Size")
                              , qt = Qt ? parseInt(Qt) : 0
                              , Xt = qt !== 0;
                            let Zt = 0;
                            const Yt = new ReadableStream({
                                start(sr) {
                                    (function er() {
                                        Wt.read().then( ({
done: rr, value: xr}) => {
                                            if (rr)
                                                sr.close();
                                            else {
                                                Zt += xr.byteLength;
                                                const br = new ProgressEvent("progress",{
                                                    lengthComputable: Xt,
                                                    loaded: Zt,
                                                    total: qt
                                                });
                                                for (let yr = 0, Pr = jt.length; yr < Pr; yr++) {
                                                    const zr = jt[yr];
                                                    zr.onProgress && zr.onProgress(br)
                                                }
                                                sr.enqueue(xr),
                                                er()
                                            }
                                        }
                                        )
                                    }
                                    )()
                                }
                            });
                            return new Response(Yt)
                        }
                        throw new SS(`fetch for "${
Nt.url}" responded with ${
Nt.status}: ${
Nt.statusText}`,Nt)
                    }
                    ).then(Nt => {
                        switch (Lt) {
                        case "arraybuffer":
                            return Nt.arrayBuffer();
                        case "blob":
                            return Nt.blob();
                        case "document":
                            return Nt.text().then(jt => new DOMParser().parseFromString(jt, Mt));
                        case "json":
                            return Nt.json();
                        default:
                            if (Mt === void 0)
                                return Nt.text();
                            {
                                const jt = /charset="?([^;"\s]*)"?/i.exec(Mt)
                                  , Wt = jt && jt[1] ? jt[1].toLowerCase() : void 0
                                  , Qt = new TextDecoder(Wt);
                                return Nt.arrayBuffer().then(qt => Qt.decode(qt))
                            }
                        }
                    }
                    ).then(Nt => {
                        this.useCache && Eu.add(tt, Nt, this.responseType);
                        const jt = Tu[tt];
                        delete Tu[tt];
                        for (let Wt = 0, Qt = jt.length; Wt < Qt; Wt++) {
                            const qt = jt[Wt];
                            qt.onLoad && qt.onLoad(Nt)
                        }
                    }
                    ).catch(Nt => {
                        const jt = Tu[tt];
                        if (jt === void 0)
                            throw this.manager.itemError(tt),
                            Nt;
                        delete Tu[tt];
                        for (let Wt = 0, Qt = jt.length; Wt < Qt; Wt++) {
                            const qt = jt[Wt];
                            qt.onError && qt.onError(Nt)
                        }
                        this.manager.itemError(tt)
                    }
                    ).finally( () => {
                        this.useCache && this.manager.itemEnd(tt)
                    }
                    ),
                    this.useCache && this.manager.itemStart(tt)
                }
                )
            }
            setResponseType(tt) {
                return this.responseType = tt,
                this
            }
            setMimeType(tt) {
                return this.mimeType = tt,
                this
            }
        }
        class ES extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(this.manager);
                Ct.setPath(this.path),
                Ct.setRequestHeader(this.requestHeader),
                Ct.setWithCredentials(this.withCredentials),
                Ct.load(tt, function(Mt) {
                    try {
                        lt(xt.parse(JSON.parse(Mt)))
                    } catch (Lt) {
                        ft ? ft(Lt) : console.error(Lt),
                        xt.manager.itemError(tt)
                    }
                }, mt, ft)
            }
            parse(tt) {
                const lt = [];
                for (let mt = 0; mt < tt.length; mt++) {
                    const ft = L_.parse(tt[mt]);
                    lt.push(ft)
                }
                return lt
            }
        }
        class TS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = []
                  , Mt = new jv
                  , Lt = new su(this.manager);
                Lt.setPath(this.path),
                Lt.setResponseType("arraybuffer"),
                Lt.setRequestHeader(this.requestHeader),
                Lt.setWithCredentials(xt.withCredentials);
                let Nt = 0;
                function jt(Wt) {
                    Lt.load(tt[Wt], function(Qt) {
                        const qt = xt.parse(Qt, !0);
                        Ct[Wt] = {
                            width: qt.width,
                            height: qt.height,
                            format: qt.format,
                            mipmaps: qt.mipmaps
                        },
                        Nt += 1,
                        Nt === 6 && (qt.mipmapCount === 1 && (Mt.minFilter = Rn),
                        Mt.image = Ct,
                        Mt.format = qt.format,
                        Mt.needsUpdate = !0,
                        lt && lt(Mt))
                    }, mt, ft)
                }
                if (Array.isArray(tt))
                    for (let Wt = 0, Qt = tt.length; Wt < Qt; ++Wt)
                        jt(Wt);
                else
                    Lt.load(tt, function(Wt) {
                        const Qt = xt.parse(Wt, !0);
                        if (Qt.isCubemap) {
                            const qt = Qt.mipmaps.length / Qt.mipmapCount;
                            for (let Xt = 0; Xt < qt; Xt++) {
                                Ct[Xt] = {
                                    mipmaps: []
                                };
                                for (let Zt = 0; Zt < Qt.mipmapCount; Zt++)
                                    Ct[Xt].mipmaps.push(Qt.mipmaps[Xt * Qt.mipmapCount + Zt]),
                                    Ct[Xt].format = Qt.format,
                                    Ct[Xt].width = Qt.width,
                                    Ct[Xt].height = Qt.height
                            }
                            Mt.image = Ct
                        } else
                            Mt.image.width = Qt.width,
                            Mt.image.height = Qt.height,
                            Mt.mipmaps = Qt.mipmaps;
                        Qt.mipmapCount === 1 && (Mt.minFilter = Rn),
                        Mt.format = Qt.format,
                        Mt.needsUpdate = !0,
                        lt && lt(Mt)
                    }, mt, ft);
                return Mt
            }
        }
        class O_ extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = tt;
                this.path !== void 0 && (tt = this.path + tt),
                tt = this.manager.resolveURL(tt);
                const Ct = this
                  , Mt = Eu.get(tt);
                if (Mt !== void 0)
                    return Ct.manager.itemStart(tt),
                    setTimeout(function() {
                        lt && lt(Mt),
                        Ct.manager.itemEnd(tt)
                    }, 0),
                    Mt;
                const Lt = yu("img");
                function Nt() {
                    Wt(),
                    Eu.add(tt, this),
                    lt && lt(this),
                    Ct.manager.itemEnd(tt)
                }
                function jt(Qt) {
                    Wt(),
                    ft && ft(Qt),
                    Ct.manager.itemError(tt),
                    Ct.manager.itemEnd(tt)
                }
                function Wt() {
                    Lt.removeEventListener("load", Nt, !1),
                    Lt.removeEventListener("error", jt, !1)
                }
                return Lt.addEventListener("load", Nt, !1),
                Lt.addEventListener("error", jt, !1),
                tt.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (Lt.crossOrigin = this.crossOrigin),
                Ct.manager.itemStart(tt),
                Eu.get(tt, "blob").then(Qt => {
                    if (Qt !== void 0 && !Qt.type.startsWith("text/plain"))
                        return Qt.type || (tt.endsWith(".svg") || tt.startsWith("data:image/svg")) && (Qt = new Blob([Qt],{
                            type: "image/svg+xml"
                        })),
                        void (Lt.src = URL.createObjectURL(Qt));
                    const qt = new su(this.manager);
                    qt.useCache = !1,
                    qt.setPath(this.path),
                    qt.setCrossOrigin(this.crossOrigin),
                    qt.setResponseType("blob"),
                    qt.load(xt, function(Xt) {
                        Xt.type || (tt.endsWith(".svg") || tt.startsWith("data:image/svg")) && (Xt = new Blob([Xt],{
                            type: "image/svg+xml"
                        })),
                        Eu.add(tt, Xt, "blob"),
                        Lt.src = URL.createObjectURL(Xt)
                    }, mt, Xt => {
                        Wt(),
                        ft && ft(Xt)
                    }
                    )
                }
                ),
                Lt
            }
        }
        class CS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = new f_;
                xt.colorSpace = jo;
                const Ct = new O_(this.manager);
                Ct.setCrossOrigin(this.crossOrigin),
                Ct.setPath(this.path);
                let Mt = 0;
                function Lt(Nt) {
                    Ct.load(tt[Nt], function(jt) {
                        xt.images[Nt] = jt,
                        Mt++,
                        Mt === 6 && (xt.needsUpdate = !0,
                        lt && lt(xt))
                    }, void 0, ft)
                }
                for (let Nt = 0; Nt < tt.length; ++Nt)
                    Lt(Nt);
                return xt
            }
        }
        class PS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new Pm
                  , Mt = new su(this.manager);
                return Mt.setResponseType("arraybuffer"),
                Mt.setRequestHeader(this.requestHeader),
                Mt.setPath(this.path),
                Mt.setWithCredentials(xt.withCredentials),
                Mt.load(tt, function(Lt) {
                    let Nt;
                    try {
                        Nt = xt.parse(Lt)
                    } catch (jt) {
                        if (ft === void 0)
                            return void console.error(jt);
                        ft(jt)
                    }
                    Nt.image !== void 0 ? Ct.image = Nt.image : Nt.data !== void 0 && (Ct.image.width = Nt.width,
                    Ct.image.height = Nt.height,
                    Ct.image.data = Nt.data,
                    Ct.image.complete = !0),
                    Ct.wrapS = Nt.wrapS !== void 0 ? Nt.wrapS : wn,
                    Ct.wrapT = Nt.wrapT !== void 0 ? Nt.wrapT : wn,
                    Ct.magFilter = Nt.magFilter !== void 0 ? Nt.magFilter : Rn,
                    Ct.minFilter = Nt.minFilter !== void 0 ? Nt.minFilter : Rn,
                    Ct.anisotropy = Nt.anisotropy !== void 0 ? Nt.anisotropy : 1,
                    Nt.colorSpace !== void 0 ? Ct.colorSpace = Nt.colorSpace : Nt.encoding !== void 0 && (Ct.encoding = Nt.encoding),
                    Nt.flipY !== void 0 && (Ct.flipY = Nt.flipY),
                    Nt.format !== void 0 && (Ct.format = Nt.format),
                    Nt.type !== void 0 && (Ct.type = Nt.type),
                    Nt.mipmaps !== void 0 && (Ct.mipmaps = Nt.mipmaps,
                    Ct.minFilter = vo),
                    Nt.mipmapCount === 1 && (Ct.minFilter = Rn),
                    Nt.generateMipmaps !== void 0 && (Ct.generateMipmaps = Nt.generateMipmaps),
                    Ct.needsUpdate = !0,
                    lt && lt(Ct, Nt)
                }, mt, ft),
                Ct
            }
        }
        class MS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = new Ho
                  , Ct = new O_(this.manager);
                return Ct.setCrossOrigin(this.crossOrigin),
                Ct.setPath(this.path),
                Ct.load(tt, function(Mt) {
                    xt.image = Mt,
                    xt.needsUpdate = !0,
                    lt !== void 0 && lt(xt)
                }, mt, ft),
                xt
            }
        }
        class rp extends Mo {
            constructor(tt, lt=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new Gn(tt),
                this.intensity = lt
            }
            dispose() {}
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.color.copy(tt.color),
                this.intensity = tt.intensity,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.color = this.color.getHex(),
                lt.object.intensity = this.intensity,
                this.groundColor !== void 0 && (lt.object.groundColor = this.groundColor.getHex()),
                this.distance !== void 0 && (lt.object.distance = this.distance),
                this.angle !== void 0 && (lt.object.angle = this.angle),
                this.decay !== void 0 && (lt.object.decay = this.decay),
                this.penumbra !== void 0 && (lt.object.penumbra = this.penumbra),
                this.shadow !== void 0 && (lt.object.shadow = this.shadow.toJSON()),
                lt
            }
        }
        class EA extends rp {
            constructor(tt, lt, mt) {
                super(tt, mt),
                this.isHemisphereLight = !0,
                this.type = "HemisphereLight",
                this.position.copy(Mo.DEFAULT_UP),
                this.updateMatrix(),
                this.groundColor = new Gn(lt)
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.groundColor.copy(tt.groundColor),
                this
            }
        }
        const yy = new no
          , TA = new Er
          , CA = new Er;
        class xy {
            constructor(tt) {
                this.camera = tt,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new mn(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new no,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Av,
                this._frameExtents = new mn(1,1),
                this._viewportCount = 1,
                this._viewports = [new Lo(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(tt) {
                const lt = this.camera
                  , mt = this.matrix;
                TA.setFromMatrixPosition(tt.matrixWorld),
                lt.position.copy(TA),
                CA.setFromMatrixPosition(tt.target.matrixWorld),
                lt.lookAt(CA),
                lt.updateMatrixWorld(),
                yy.multiplyMatrices(lt.projectionMatrix, lt.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(yy),
                mt.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                mt.multiply(yy)
            }
            getViewport(tt) {
                return this._viewports[tt]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(tt) {
                return this.camera = tt.camera.clone(),
                this.bias = tt.bias,
                this.normalBias = tt.normalBias,
                this.radius = tt.radius,
                this.mapSize.copy(tt.mapSize),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            toJSON() {
                const tt = {};
                return this.bias !== 0 && (tt.bias = this.bias),
                this.normalBias !== 0 && (tt.normalBias = this.normalBias),
                this.radius !== 1 && (tt.radius = this.radius),
                this.mapSize.x === 512 && this.mapSize.y === 512 || (tt.mapSize = this.mapSize.toArray()),
                tt.camera = this.camera.toJSON(!1).object,
                delete tt.camera.matrix,
                tt
            }
        }
        class RS extends xy {
            constructor() {
                super(new Cs(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(tt) {
                const lt = this.camera
                  , mt = 2 * _u * tt.angle * this.focus
                  , ft = this.mapSize.width / this.mapSize.height
                  , xt = tt.distance || lt.far;
                mt === lt.fov && ft === lt.aspect && xt === lt.far || (lt.fov = mt,
                lt.aspect = ft,
                lt.far = xt,
                lt.updateProjectionMatrix()),
                super.updateMatrices(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.focus = tt.focus,
                this
            }
        }
        class PA extends rp {
            constructor(tt, lt, mt=0, ft=Math.PI / 3, xt=0, Ct=2) {
                super(tt, lt),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(Mo.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new Mo,
                this.distance = mt,
                this.angle = ft,
                this.penumbra = xt,
                this.decay = Ct,
                this.map = null,
                this.shadow = new RS
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(tt) {
                this.intensity = tt / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.distance = tt.distance,
                this.angle = tt.angle,
                this.penumbra = tt.penumbra,
                this.decay = tt.decay,
                this.target = tt.target.clone(),
                this.shadow = tt.shadow.clone(),
                this
            }
        }
        const MA = new no
          , N_ = new Er
          , by = new Er;
        class IS extends xy {
            constructor() {
                super(new Cs(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new mn(4,2),
                this._viewportCount = 6,
                this._viewports = [new Lo(2,1,1,1), new Lo(0,1,1,1), new Lo(3,1,1,1), new Lo(1,1,1,1), new Lo(3,0,1,1), new Lo(1,0,1,1)],
                this._cubeDirections = [new Er(1,0,0), new Er(-1,0,0), new Er(0,0,1), new Er(0,0,-1), new Er(0,1,0), new Er(0,-1,0)],
                this._cubeUps = [new Er(0,1,0), new Er(0,1,0), new Er(0,1,0), new Er(0,1,0), new Er(0,0,1), new Er(0,0,-1)]
            }
            updateMatrices(tt, lt=0) {
                const mt = this.camera
                  , ft = this.matrix
                  , xt = tt.distance || mt.far;
                xt !== mt.far && (mt.far = xt,
                mt.updateProjectionMatrix()),
                N_.setFromMatrixPosition(tt.matrixWorld),
                mt.position.copy(N_),
                by.copy(mt.position),
                by.add(this._cubeDirections[lt]),
                mt.up.copy(this._cubeUps[lt]),
                mt.lookAt(by),
                mt.updateMatrixWorld(),
                ft.makeTranslation(-N_.x, -N_.y, -N_.z),
                MA.multiplyMatrices(mt.projectionMatrix, mt.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(MA)
            }
        }
        class RA extends rp {
            constructor(tt, lt, mt=0, ft=2) {
                super(tt, lt),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = mt,
                this.decay = ft,
                this.shadow = new IS
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(tt) {
                this.intensity = tt / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.distance = tt.distance,
                this.decay = tt.decay,
                this.shadow = tt.shadow.clone(),
                this
            }
        }
        class kS extends xy {
            constructor() {
                super(new Sv(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class IA extends rp {
            constructor(tt, lt) {
                super(tt, lt),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(Mo.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new Mo,
                this.shadow = new kS
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(tt) {
                return super.copy(tt),
                this.target = tt.target.clone(),
                this.shadow = tt.shadow.clone(),
                this
            }
        }
        class kA extends rp {
            constructor(tt, lt) {
                super(tt, lt),
                this.isAmbientLight = !0,
                this.type = "AmbientLight"
            }
        }
        class DA extends rp {
            constructor(tt, lt, mt=10, ft=10) {
                super(tt, lt),
                this.isRectAreaLight = !0,
                this.type = "RectAreaLight",
                this.width = mt,
                this.height = ft
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(tt) {
                this.intensity = tt / (this.width * this.height * Math.PI)
            }
            copy(tt) {
                return super.copy(tt),
                this.width = tt.width,
                this.height = tt.height,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.width = this.width,
                lt.object.height = this.height,
                lt
            }
        }
        class BA {
            constructor() {
                this.isSphericalHarmonics3 = !0,
                this.coefficients = [];
                for (let tt = 0; tt < 9; tt++)
                    this.coefficients.push(new Er)
            }
            set(tt) {
                for (let lt = 0; lt < 9; lt++)
                    this.coefficients[lt].copy(tt[lt]);
                return this
            }
            zero() {
                for (let tt = 0; tt < 9; tt++)
                    this.coefficients[tt].set(0, 0, 0);
                return this
            }
            getAt(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = this.coefficients;
                return lt.copy(Ct[0]).multiplyScalar(.282095),
                lt.addScaledVector(Ct[1], .488603 * ft),
                lt.addScaledVector(Ct[2], .488603 * xt),
                lt.addScaledVector(Ct[3], .488603 * mt),
                lt.addScaledVector(Ct[4], mt * ft * 1.092548),
                lt.addScaledVector(Ct[5], ft * xt * 1.092548),
                lt.addScaledVector(Ct[6], .315392 * (3 * xt * xt - 1)),
                lt.addScaledVector(Ct[7], mt * xt * 1.092548),
                lt.addScaledVector(Ct[8], .546274 * (mt * mt - ft * ft)),
                lt
            }
            getIrradianceAt(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = this.coefficients;
                return lt.copy(Ct[0]).multiplyScalar(.886227),
                lt.addScaledVector(Ct[1], 1.023328 * ft),
                lt.addScaledVector(Ct[2], 1.023328 * xt),
                lt.addScaledVector(Ct[3], 1.023328 * mt),
                lt.addScaledVector(Ct[4], .858086 * mt * ft),
                lt.addScaledVector(Ct[5], .858086 * ft * xt),
                lt.addScaledVector(Ct[6], .743125 * xt * xt - .247708),
                lt.addScaledVector(Ct[7], .858086 * mt * xt),
                lt.addScaledVector(Ct[8], .429043 * (mt * mt - ft * ft)),
                lt
            }
            add(tt) {
                for (let lt = 0; lt < 9; lt++)
                    this.coefficients[lt].add(tt.coefficients[lt]);
                return this
            }
            addScaledSH(tt, lt) {
                for (let mt = 0; mt < 9; mt++)
                    this.coefficients[mt].addScaledVector(tt.coefficients[mt], lt);
                return this
            }
            scale(tt) {
                for (let lt = 0; lt < 9; lt++)
                    this.coefficients[lt].multiplyScalar(tt);
                return this
            }
            lerp(tt, lt) {
                for (let mt = 0; mt < 9; mt++)
                    this.coefficients[mt].lerp(tt.coefficients[mt], lt);
                return this
            }
            equals(tt) {
                for (let lt = 0; lt < 9; lt++)
                    if (!this.coefficients[lt].equals(tt.coefficients[lt]))
                        return !1;
                return !0
            }
            copy(tt) {
                return this.set(tt.coefficients)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            fromArray(tt, lt=0) {
                const mt = this.coefficients;
                for (let ft = 0; ft < 9; ft++)
                    mt[ft].fromArray(tt, lt + 3 * ft);
                return this
            }
            toArray(tt=[], lt=0) {
                const mt = this.coefficients;
                for (let ft = 0; ft < 9; ft++)
                    mt[ft].toArray(tt, lt + 3 * ft);
                return tt
            }
            static getBasisAt(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z;
                lt[0] = .282095,
                lt[1] = .488603 * ft,
                lt[2] = .488603 * xt,
                lt[3] = .488603 * mt,
                lt[4] = 1.092548 * mt * ft,
                lt[5] = 1.092548 * ft * xt,
                lt[6] = .315392 * (3 * xt * xt - 1),
                lt[7] = 1.092548 * mt * xt,
                lt[8] = .546274 * (mt * mt - ft * ft)
            }
        }
        class LA extends rp {
            constructor(tt=new BA, lt=1) {
                super(void 0, lt),
                this.isLightProbe = !0,
                this.sh = tt
            }
            copy(tt) {
                return super.copy(tt),
                this.sh.copy(tt.sh),
                this
            }
            fromJSON(tt) {
                return this.intensity = tt.intensity,
                this.sh.fromArray(tt.sh),
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.sh = this.sh.toArray(),
                lt
            }
        }
        class l0 extends $s {
            constructor(tt) {
                super(tt),
                this.textures = {}
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(xt.manager);
                Ct.setPath(xt.path),
                Ct.setRequestHeader(xt.requestHeader),
                Ct.setWithCredentials(xt.withCredentials),
                Ct.load(tt, function(Mt) {
                    try {
                        lt(xt.parse(JSON.parse(Mt)))
                    } catch (Lt) {
                        ft ? ft(Lt) : console.error(Lt),
                        xt.manager.itemError(tt)
                    }
                }, mt, ft)
            }
            parse(tt) {
                const lt = this.textures;
                function mt(Ct) {
                    return lt[Ct] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", Ct),
                    lt[Ct]
                }
                const ft = tt.metadata && tt.metadata.version <= 4.5 ? Xo : void 0
                  , xt = l0.createMaterialFromType(tt.type);
                if (tt.uuid !== void 0 && (xt.uuid = tt.uuid),
                tt.name !== void 0 && (xt.name = tt.name),
                tt.color !== void 0 && xt.color !== void 0 && xt.color.setHex(tt.color, ft),
                tt.roughness !== void 0 && (xt.roughness = tt.roughness),
                tt.metalness !== void 0 && (xt.metalness = tt.metalness),
                tt.sheen !== void 0 && (xt.sheen = tt.sheen),
                tt.sheenColor !== void 0 && (xt.sheenColor = new Gn().setHex(tt.sheenColor, ft)),
                tt.sheenRoughness !== void 0 && (xt.sheenRoughness = tt.sheenRoughness),
                tt.emissive !== void 0 && xt.emissive !== void 0 && xt.emissive.setHex(tt.emissive, ft),
                tt.specular !== void 0 && xt.specular !== void 0 && xt.specular.setHex(tt.specular, ft),
                tt.specularIntensity !== void 0 && (xt.specularIntensity = tt.specularIntensity),
                tt.specularColor !== void 0 && xt.specularColor !== void 0 && xt.specularColor.setHex(tt.specularColor, ft),
                tt.shininess !== void 0 && (xt.shininess = tt.shininess),
                tt.clearcoat !== void 0 && (xt.clearcoat = tt.clearcoat),
                tt.clearcoatRoughness !== void 0 && (xt.clearcoatRoughness = tt.clearcoatRoughness),
                tt.iridescence !== void 0 && (xt.iridescence = tt.iridescence),
                tt.iridescenceIOR !== void 0 && (xt.iridescenceIOR = tt.iridescenceIOR),
                tt.iridescenceThicknessRange !== void 0 && (xt.iridescenceThicknessRange = tt.iridescenceThicknessRange),
                tt.transmission !== void 0 && (xt.transmission = tt.transmission),
                tt.thickness !== void 0 && (xt.thickness = tt.thickness),
                tt.attenuationDistance !== void 0 && (xt.attenuationDistance = tt.attenuationDistance),
                tt.attenuationColor !== void 0 && xt.attenuationColor !== void 0 && xt.attenuationColor.setHex(tt.attenuationColor, ft),
                tt.anisotropy !== void 0 && (xt.anisotropy = tt.anisotropy),
                tt.anisotropyRotation !== void 0 && (xt.anisotropyRotation = tt.anisotropyRotation),
                tt.fog !== void 0 && (xt.fog = tt.fog),
                tt.flatShading !== void 0 && (xt.flatShading = tt.flatShading),
                tt.blending !== void 0 && (xt.blending = tt.blending),
                tt.combine !== void 0 && (xt.combine = tt.combine),
                tt.side !== void 0 && (xt.side = tt.side),
                tt.shadowSide !== void 0 && (xt.shadowSide = tt.shadowSide),
                tt.opacity !== void 0 && (xt.opacity = tt.opacity),
                tt.transparent !== void 0 && (xt.transparent = tt.transparent),
                tt.alphaTest !== void 0 && (xt.alphaTest = tt.alphaTest),
                tt.alphaHash !== void 0 && (xt.alphaHash = tt.alphaHash),
                tt.depthTest !== void 0 && (xt.depthTest = tt.depthTest),
                tt.depthWrite !== void 0 && (xt.depthWrite = tt.depthWrite),
                tt.colorWrite !== void 0 && (xt.colorWrite = tt.colorWrite),
                tt.stencilWrite !== void 0 && (xt.stencilWrite = tt.stencilWrite),
                tt.stencilWriteMask !== void 0 && (xt.stencilWriteMask = tt.stencilWriteMask),
                tt.stencilFunc !== void 0 && (xt.stencilFunc = tt.stencilFunc),
                tt.stencilRef !== void 0 && (xt.stencilRef = tt.stencilRef),
                tt.stencilFuncMask !== void 0 && (xt.stencilFuncMask = tt.stencilFuncMask),
                tt.stencilFail !== void 0 && (xt.stencilFail = tt.stencilFail),
                tt.stencilZFail !== void 0 && (xt.stencilZFail = tt.stencilZFail),
                tt.stencilZPass !== void 0 && (xt.stencilZPass = tt.stencilZPass),
                tt.wireframe !== void 0 && (xt.wireframe = tt.wireframe),
                tt.wireframeLinewidth !== void 0 && (xt.wireframeLinewidth = tt.wireframeLinewidth),
                tt.wireframeLinecap !== void 0 && (xt.wireframeLinecap = tt.wireframeLinecap),
                tt.wireframeLinejoin !== void 0 && (xt.wireframeLinejoin = tt.wireframeLinejoin),
                tt.rotation !== void 0 && (xt.rotation = tt.rotation),
                tt.linewidth !== void 0 && (xt.linewidth = tt.linewidth),
                tt.dashSize !== void 0 && (xt.dashSize = tt.dashSize),
                tt.gapSize !== void 0 && (xt.gapSize = tt.gapSize),
                tt.scale !== void 0 && (xt.scale = tt.scale),
                tt.polygonOffset !== void 0 && (xt.polygonOffset = tt.polygonOffset),
                tt.polygonOffsetFactor !== void 0 && (xt.polygonOffsetFactor = tt.polygonOffsetFactor),
                tt.polygonOffsetUnits !== void 0 && (xt.polygonOffsetUnits = tt.polygonOffsetUnits),
                tt.dithering !== void 0 && (xt.dithering = tt.dithering),
                tt.alphaToCoverage !== void 0 && (xt.alphaToCoverage = tt.alphaToCoverage),
                tt.premultipliedAlpha !== void 0 && (xt.premultipliedAlpha = tt.premultipliedAlpha),
                tt.forceSinglePass !== void 0 && (xt.forceSinglePass = tt.forceSinglePass),
                tt.visible !== void 0 && (xt.visible = tt.visible),
                tt.toneMapped !== void 0 && (xt.toneMapped = tt.toneMapped),
                tt.userData !== void 0 && (xt.userData = tt.userData),
                tt.vertexColors !== void 0 && (typeof tt.vertexColors == "number" ? xt.vertexColors = tt.vertexColors > 0 : xt.vertexColors = tt.vertexColors),
                tt.uniforms !== void 0)
                    for (const Ct in tt.uniforms) {
                        const Mt = tt.uniforms[Ct];
                        switch (xt.uniforms[Ct] = {},
                        Mt.type) {
                        case "t":
                            xt.uniforms[Ct].value = mt(Mt.value);
                            break;
                        case "c":
                            xt.uniforms[Ct].value = new Gn().setHex(Mt.value, ft);
                            break;
                        case "v2":
                            xt.uniforms[Ct].value = new mn().fromArray(Mt.value);
                            break;
                        case "v3":
                            xt.uniforms[Ct].value = new Er().fromArray(Mt.value);
                            break;
                        case "v4":
                            xt.uniforms[Ct].value = new Lo().fromArray(Mt.value);
                            break;
                        case "m3":
                            xt.uniforms[Ct].value = new lo().fromArray(Mt.value);
                            break;
                        case "m4":
                            xt.uniforms[Ct].value = new no().fromArray(Mt.value);
                            break;
                        default:
                            xt.uniforms[Ct].value = Mt.value
                        }
                    }
                if (tt.defines !== void 0 && (xt.defines = tt.defines),
                tt.vertexShader !== void 0 && (xt.vertexShader = tt.vertexShader),
                tt.fragmentShader !== void 0 && (xt.fragmentShader = tt.fragmentShader),
                tt.glslVersion !== void 0 && (xt.glslVersion = tt.glslVersion),
                tt.extensions !== void 0)
                    for (const Ct in tt.extensions)
                        xt.extensions[Ct] = tt.extensions[Ct];
                if (tt.lights !== void 0 && (xt.lights = tt.lights),
                tt.clipping !== void 0 && (xt.clipping = tt.clipping),
                tt.size !== void 0 && (xt.size = tt.size),
                tt.sizeAttenuation !== void 0 && (xt.sizeAttenuation = tt.sizeAttenuation),
                tt.map !== void 0 && (xt.map = mt(tt.map)),
                tt.matcap !== void 0 && (xt.matcap = mt(tt.matcap)),
                tt.alphaMap !== void 0 && (xt.alphaMap = mt(tt.alphaMap)),
                tt.bumpMap !== void 0 && (xt.bumpMap = mt(tt.bumpMap)),
                tt.bumpScale !== void 0 && (xt.bumpScale = tt.bumpScale),
                tt.normalMap !== void 0 && (xt.normalMap = mt(tt.normalMap)),
                tt.normalMapType !== void 0 && (xt.normalMapType = tt.normalMapType),
                tt.normalScale !== void 0) {
                    let Ct = tt.normalScale;
                    Array.isArray(Ct) === !1 && (Ct = [Ct, Ct]),
                    xt.normalScale = new mn().fromArray(Ct)
                }
                return tt.displacementMap !== void 0 && (xt.displacementMap = mt(tt.displacementMap)),
                tt.displacementScale !== void 0 && (xt.displacementScale = tt.displacementScale),
                tt.displacementBias !== void 0 && (xt.displacementBias = tt.displacementBias),
                tt.roughnessMap !== void 0 && (xt.roughnessMap = mt(tt.roughnessMap)),
                tt.metalnessMap !== void 0 && (xt.metalnessMap = mt(tt.metalnessMap)),
                tt.emissiveMap !== void 0 && (xt.emissiveMap = mt(tt.emissiveMap)),
                tt.emissiveIntensity !== void 0 && (xt.emissiveIntensity = tt.emissiveIntensity),
                tt.specularMap !== void 0 && (xt.specularMap = mt(tt.specularMap)),
                tt.specularIntensityMap !== void 0 && (xt.specularIntensityMap = mt(tt.specularIntensityMap)),
                tt.specularColorMap !== void 0 && (xt.specularColorMap = mt(tt.specularColorMap)),
                tt.envMap !== void 0 && (xt.envMap = mt(tt.envMap)),
                tt.envMapIntensity !== void 0 && (xt.envMapIntensity = tt.envMapIntensity),
                tt.reflectivity !== void 0 && (xt.reflectivity = tt.reflectivity),
                tt.refractionRatio !== void 0 && (xt.refractionRatio = tt.refractionRatio),
                tt.lightMap !== void 0 && (xt.lightMap = mt(tt.lightMap)),
                tt.lightMapIntensity !== void 0 && (xt.lightMapIntensity = tt.lightMapIntensity),
                tt.aoMap !== void 0 && (xt.aoMap = mt(tt.aoMap)),
                tt.aoMapIntensity !== void 0 && (xt.aoMapIntensity = tt.aoMapIntensity),
                tt.gradientMap !== void 0 && (xt.gradientMap = mt(tt.gradientMap)),
                tt.clearcoatMap !== void 0 && (xt.clearcoatMap = mt(tt.clearcoatMap)),
                tt.clearcoatRoughnessMap !== void 0 && (xt.clearcoatRoughnessMap = mt(tt.clearcoatRoughnessMap)),
                tt.clearcoatNormalMap !== void 0 && (xt.clearcoatNormalMap = mt(tt.clearcoatNormalMap)),
                tt.clearcoatNormalScale !== void 0 && (xt.clearcoatNormalScale = new mn().fromArray(tt.clearcoatNormalScale)),
                tt.iridescenceMap !== void 0 && (xt.iridescenceMap = mt(tt.iridescenceMap)),
                tt.iridescenceThicknessMap !== void 0 && (xt.iridescenceThicknessMap = mt(tt.iridescenceThicknessMap)),
                tt.transmissionMap !== void 0 && (xt.transmissionMap = mt(tt.transmissionMap)),
                tt.thicknessMap !== void 0 && (xt.thicknessMap = mt(tt.thicknessMap)),
                tt.anisotropyMap !== void 0 && (xt.anisotropyMap = mt(tt.anisotropyMap)),
                tt.sheenColorMap !== void 0 && (xt.sheenColorMap = mt(tt.sheenColorMap)),
                tt.sheenRoughnessMap !== void 0 && (xt.sheenRoughnessMap = mt(tt.sheenRoughnessMap)),
                xt
            }
            setTextures(tt) {
                return this.textures = tt,
                this
            }
            static createMaterialFromType(tt) {
                return new {
                    ShadowMaterial: uA,
                    SpriteMaterial: q0,
                    RawShaderMaterial: dA,
                    ShaderMaterial: zl,
                    PointsMaterial: Z0,
                    MeshPhysicalMaterial: pA,
                    MeshStandardMaterial: hy,
                    MeshPhongMaterial: hA,
                    MeshToonMaterial: mA,
                    MeshNormalMaterial: fA,
                    MeshLambertMaterial: gA,
                    MeshDepthMaterial: H0,
                    MeshDistanceMaterial: Q0,
                    MeshBasicMaterial: nu,
                    MeshMatcapMaterial: _A,
                    LineDashedMaterial: vA,
                    LineBasicMaterial: Gs,
                    Material: hs
                }[tt]
            }
        }
        class Ay {
            static decodeText(tt) {
                if (typeof TextDecoder < "u")
                    return new TextDecoder().decode(tt);
                let lt = "";
                for (let mt = 0, ft = tt.length; mt < ft; mt++)
                    lt += String.fromCharCode(tt[mt]);
                try {
                    return decodeURIComponent(escape(lt))
                } catch {
                    return lt
                }
            }
            static extractUrlBase(tt) {
                const lt = tt.lastIndexOf("/");
                return lt === -1 ? "./" : tt.slice(0, lt + 1)
            }
            static resolveURL(tt, lt) {
                return typeof tt != "string" || tt === "" ? "" : (/^https?:\/\//i.test(lt) && /^\//.test(tt) && (lt = lt.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(tt) || /^data:.*,.*$/i.test(tt) || /^blob:.*$/i.test(tt) ? tt : lt + tt)
            }
        }
        class OA extends bo {
            constructor() {
                super(),
                this.isInstancedBufferGeometry = !0,
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
            }
            copy(tt) {
                return super.copy(tt),
                this.instanceCount = tt.instanceCount,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.instanceCount = this.instanceCount,
                tt.isInstancedBufferGeometry = !0,
                tt
            }
        }
        class NA extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(xt.manager);
                Ct.setPath(xt.path),
                Ct.setRequestHeader(xt.requestHeader),
                Ct.setWithCredentials(xt.withCredentials),
                Ct.load(tt, function(Mt) {
                    try {
                        lt(xt.parse(JSON.parse(Mt)))
                    } catch (Lt) {
                        ft ? ft(Lt) : console.error(Lt),
                        xt.manager.itemError(tt)
                    }
                }, mt, ft)
            }
            parse(tt) {
                const lt = {}
                  , mt = {};
                function ft(Wt, Qt) {
                    if (lt[Qt] !== void 0)
                        return lt[Qt];
                    const qt = Wt.interleavedBuffers[Qt]
                      , Xt = function(sr, er) {
                        if (mt[er] !== void 0)
                            return mt[er];
                        const rr = sr.arrayBuffers[er]
                          , xr = new Uint32Array(rr).buffer;
                        return mt[er] = xr,
                        xr
                    }(Wt, qt.buffer)
                      , Zt = vu(qt.type, Xt)
                      , Yt = new Rv(Zt,qt.stride);
                    return Yt.uuid = qt.uuid,
                    lt[Qt] = Yt,
                    Yt
                }
                const xt = tt.isInstancedBufferGeometry ? new OA : new bo
                  , Ct = tt.data.index;
                if (Ct !== void 0) {
                    const Wt = vu(Ct.type, Ct.array);
                    xt.setIndex(new mr(Wt,1))
                }
                const Mt = tt.data.attributes;
                for (const Wt in Mt) {
                    const Qt = Mt[Wt];
                    let qt;
                    if (Qt.isInterleavedBufferAttribute) {
                        const Xt = ft(tt.data, Qt.data);
                        qt = new Cp(Xt,Qt.itemSize,Qt.offset,Qt.normalized)
                    } else {
                        const Xt = vu(Qt.type, Qt.array);
                        qt = new (Qt.isInstancedBufferAttribute ? Mm : mr)(Xt,Qt.itemSize,Qt.normalized)
                    }
                    Qt.name !== void 0 && (qt.name = Qt.name),
                    Qt.usage !== void 0 && qt.setUsage(Qt.usage),
                    Qt.updateRange !== void 0 && (qt.updateRange.offset = Qt.updateRange.offset,
                    qt.updateRange.count = Qt.updateRange.count),
                    xt.setAttribute(Wt, qt)
                }
                const Lt = tt.data.morphAttributes;
                if (Lt)
                    for (const Wt in Lt) {
                        const Qt = Lt[Wt]
                          , qt = [];
                        for (let Xt = 0, Zt = Qt.length; Xt < Zt; Xt++) {
                            const Yt = Qt[Xt];
                            let sr;
                            if (Yt.isInterleavedBufferAttribute) {
                                const er = ft(tt.data, Yt.data);
                                sr = new Cp(er,Yt.itemSize,Yt.offset,Yt.normalized)
                            } else {
                                const er = vu(Yt.type, Yt.array);
                                sr = new mr(er,Yt.itemSize,Yt.normalized)
                            }
                            Yt.name !== void 0 && (sr.name = Yt.name),
                            qt.push(sr)
                        }
                        xt.morphAttributes[Wt] = qt
                    }
                tt.data.morphTargetsRelative && (xt.morphTargetsRelative = !0);
                const Nt = tt.data.groups || tt.data.drawcalls || tt.data.offsets;
                if (Nt !== void 0)
                    for (let Wt = 0, Qt = Nt.length; Wt !== Qt; ++Wt) {
                        const qt = Nt[Wt];
                        xt.addGroup(qt.start, qt.count, qt.materialIndex)
                    }
                const jt = tt.data.boundingSphere;
                if (jt !== void 0) {
                    const Wt = new Er;
                    jt.center !== void 0 && Wt.fromArray(jt.center),
                    xt.boundingSphere = new Ws(Wt,jt.radius)
                }
                return tt.name && (xt.name = tt.name),
                tt.userData && (xt.userData = tt.userData),
                xt
            }
        }
        class DS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = this.path === "" ? Ay.extractUrlBase(tt) : this.path;
                this.resourcePath = this.resourcePath || Ct;
                const Mt = new su(this.manager);
                Mt.setPath(this.path),
                Mt.setRequestHeader(this.requestHeader),
                Mt.setWithCredentials(this.withCredentials),
                Mt.load(tt, function(Lt) {
                    let Nt = null;
                    try {
                        Nt = JSON.parse(Lt)
                    } catch (Wt) {
                        return ft !== void 0 && ft(Wt),
                        void console.error("THREE:ObjectLoader: Can't parse " + tt + ".", Wt.message)
                    }
                    const jt = Nt.metadata;
                    if (jt === void 0 || jt.type === void 0 || jt.type.toLowerCase() === "geometry")
                        return ft !== void 0 && ft(new Error("THREE.ObjectLoader: Can't load " + tt)),
                        void console.error("THREE.ObjectLoader: Can't load " + tt);
                    xt.parse(Nt, lt)
                }, mt, ft)
            }
            async loadAsync(tt, lt) {
                const mt = this.path === "" ? Ay.extractUrlBase(tt) : this.path;
                this.resourcePath = this.resourcePath || mt;
                const ft = new su(this.manager);
                ft.setPath(this.path),
                ft.setRequestHeader(this.requestHeader),
                ft.setWithCredentials(this.withCredentials);
                const xt = await ft.loadAsync(tt, lt)
                  , Ct = JSON.parse(xt)
                  , Mt = Ct.metadata;
                if (Mt === void 0 || Mt.type === void 0 || Mt.type.toLowerCase() === "geometry")
                    throw new Error("THREE.ObjectLoader: Can't load " + tt);
                return await this.parseAsync(Ct)
            }
            parse(tt, lt) {
                const mt = this.parseAnimations(tt.animations)
                  , ft = this.parseShapes(tt.shapes)
                  , xt = this.parseGeometries(tt.geometries, ft)
                  , Ct = this.parseImages(tt.images, function() {
                    lt !== void 0 && lt(Nt)
                })
                  , Mt = this.parseTextures(tt.textures, Ct)
                  , Lt = this.parseMaterials(tt.materials, Mt)
                  , Nt = this.parseObject(tt.object, xt, Lt, Mt, mt)
                  , jt = this.parseSkeletons(tt.skeletons, Nt);
                if (this.bindSkeletons(Nt, jt),
                lt !== void 0) {
                    let Wt = !1;
                    for (const Qt in Ct)
                        if (Ct[Qt].data instanceof HTMLImageElement) {
                            Wt = !0;
                            break
                        }
                    Wt === !1 && lt(Nt)
                }
                return Nt
            }
            async parseAsync(tt) {
                const lt = this.parseAnimations(tt.animations)
                  , mt = this.parseShapes(tt.shapes)
                  , ft = this.parseGeometries(tt.geometries, mt)
                  , xt = await this.parseImagesAsync(tt.images)
                  , Ct = this.parseTextures(tt.textures, xt)
                  , Mt = this.parseMaterials(tt.materials, Ct)
                  , Lt = this.parseObject(tt.object, ft, Mt, Ct, lt)
                  , Nt = this.parseSkeletons(tt.skeletons, Lt);
                return this.bindSkeletons(Lt, Nt),
                Lt
            }
            parseShapes(tt) {
                const lt = {};
                if (tt !== void 0)
                    for (let mt = 0, ft = tt.length; mt < ft; mt++) {
                        const xt = new Pp().fromJSON(tt[mt]);
                        lt[xt.uuid] = xt
                    }
                return lt
            }
            parseSkeletons(tt, lt) {
                const mt = {}
                  , ft = {};
                if (lt.traverse(function(xt) {
                    xt.isBone && (ft[xt.uuid] = xt)
                }),
                tt !== void 0)
                    for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                        const Mt = new Lv().fromJSON(tt[xt], ft);
                        mt[Mt.uuid] = Mt
                    }
                return mt
            }
            parseGeometries(tt, lt) {
                const mt = {};
                if (tt !== void 0) {
                    const ft = new NA;
                    for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                        let Mt;
                        const Lt = tt[xt];
                        switch (Lt.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            Mt = ft.parse(Lt);
                            break;
                        default:
                            Lt.type in cA ? Mt = cA[Lt.type].fromJSON(Lt, lt) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${
Lt.type}"`)
                        }
                        Mt.uuid = Lt.uuid,
                        Lt.name !== void 0 && (Mt.name = Lt.name),
                        Lt.userData !== void 0 && (Mt.userData = Lt.userData),
                        mt[Lt.uuid] = Mt
                    }
                }
                return mt
            }
            parseMaterials(tt, lt) {
                const mt = {}
                  , ft = {};
                if (tt !== void 0) {
                    const xt = new l0;
                    xt.setTextures(lt);
                    for (let Ct = 0, Mt = tt.length; Ct < Mt; Ct++) {
                        const Lt = tt[Ct];
                        mt[Lt.uuid] === void 0 && (mt[Lt.uuid] = xt.parse(Lt)),
                        ft[Lt.uuid] = mt[Lt.uuid]
                    }
                }
                return ft
            }
            parseAnimations(tt) {
                const lt = {};
                if (tt !== void 0)
                    for (let mt = 0; mt < tt.length; mt++) {
                        const ft = tt[mt]
                          , xt = L_.parse(ft);
                        lt[xt.uuid] = xt
                    }
                return lt
            }
            parseImages(tt, lt) {
                const mt = this
                  , ft = {};
                let xt;
                function Ct(Mt) {
                    if (typeof Mt == "string") {
                        const Lt = Mt;
                        return function(Nt) {
                            return mt.manager.itemStart(Nt),
                            xt.load(Nt, function() {
                                mt.manager.itemEnd(Nt)
                            }, void 0, function() {
                                mt.manager.itemError(Nt),
                                mt.manager.itemEnd(Nt)
                            })
                        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(Lt) ? Lt : mt.resourcePath + Lt)
                    }
                    return Mt.data ? {
                        data: vu(Mt.type, Mt.data),
                        width: Mt.width,
                        height: Mt.height,
                        complete: !0
                    } : null
                }
                if (tt !== void 0 && tt.length > 0) {
                    const Mt = new vy(lt);
                    xt = new O_(Mt),
                    xt.setCrossOrigin(this.crossOrigin);
                    for (let Lt = 0, Nt = tt.length; Lt < Nt; Lt++) {
                        const jt = tt[Lt]
                          , Wt = jt.url;
                        if (Array.isArray(Wt)) {
                            const Qt = [];
                            for (let qt = 0, Xt = Wt.length; qt < Xt; qt++) {
                                const Zt = Ct(Wt[qt]);
                                Zt !== null && (Zt instanceof HTMLImageElement ? Qt.push(Zt) : Qt.push(new Pm(Zt.data,Zt.width,Zt.height)))
                            }
                            ft[jt.uuid] = new ga(Qt)
                        } else {
                            const Qt = Ct(jt.url);
                            ft[jt.uuid] = new ga(Qt)
                        }
                    }
                }
                return ft
            }
            async parseImagesAsync(tt) {
                const lt = this
                  , mt = {};
                let ft;
                async function xt(Ct) {
                    if (typeof Ct == "string") {
                        const Mt = Ct
                          , Lt = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(Mt) ? Mt : lt.resourcePath + Mt;
                        return await ft.loadAsync(Lt)
                    }
                    return Ct.data ? {
                        data: vu(Ct.type, Ct.data),
                        width: Ct.width,
                        height: Ct.height,
                        complete: !0
                    } : null
                }
                if (tt !== void 0 && tt.length > 0) {
                    ft = new O_(this.manager),
                    ft.setCrossOrigin(this.crossOrigin);
                    for (let Ct = 0, Mt = tt.length; Ct < Mt; Ct++) {
                        const Lt = tt[Ct]
                          , Nt = Lt.url;
                        if (Array.isArray(Nt)) {
                            const jt = [];
                            for (let Wt = 0, Qt = Nt.length; Wt < Qt; Wt++) {
                                const qt = Nt[Wt]
                                  , Xt = await xt(qt);
                                Xt !== null && (Xt instanceof HTMLImageElement ? jt.push(Xt) : jt.push(new Pm(Xt.data,Xt.width,Xt.height)))
                            }
                            mt[Lt.uuid] = new ga(jt)
                        } else {
                            const jt = await xt(Lt.url);
                            mt[Lt.uuid] = new ga(jt)
                        }
                    }
                }
                return mt
            }
            parseTextures(tt, lt) {
                function mt(xt, Ct) {
                    return typeof xt == "number" ? xt : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", xt),
                    Ct[xt])
                }
                const ft = {};
                if (tt !== void 0)
                    for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                        const Mt = tt[xt];
                        Mt.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', Mt.uuid),
                        lt[Mt.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", Mt.image);
                        const Lt = lt[Mt.image]
                          , Nt = Lt ? Lt.data : void 0;
                        let jt;
                        Array.isArray(Nt) ? (jt = new f_,
                        Nt.length === 6 && (jt.needsUpdate = !0)) : (jt = Nt && Nt.data ? new Pm : new Ho,
                        Nt && Nt.complete && (jt.needsUpdate = !0)),
                        jt.source = Lt,
                        jt.uuid = Mt.uuid,
                        Mt.name !== void 0 && (jt.name = Mt.name),
                        Mt.mapping !== void 0 && (jt.mapping = mt(Mt.mapping, BS)),
                        Mt.channel !== void 0 && (jt.channel = Mt.channel),
                        Mt.offset !== void 0 && jt.offset.fromArray(Mt.offset),
                        Mt.repeat !== void 0 && jt.repeat.fromArray(Mt.repeat),
                        Mt.center !== void 0 && jt.center.fromArray(Mt.center),
                        Mt.rotation !== void 0 && (jt.rotation = Mt.rotation),
                        Mt.wrap !== void 0 && (jt.wrapS = mt(Mt.wrap[0], FA),
                        jt.wrapT = mt(Mt.wrap[1], FA)),
                        Mt.format !== void 0 && (jt.format = Mt.format),
                        Mt.internalFormat !== void 0 && (jt.internalFormat = Mt.internalFormat),
                        Mt.type !== void 0 && (jt.type = Mt.type),
                        Mt.colorSpace !== void 0 ? jt.colorSpace = Mt.colorSpace : Mt.encoding !== void 0 && (jt.encoding = Mt.encoding),
                        Mt.minFilter !== void 0 && (jt.minFilter = mt(Mt.minFilter, UA)),
                        Mt.magFilter !== void 0 && (jt.magFilter = mt(Mt.magFilter, UA)),
                        Mt.anisotropy !== void 0 && (jt.anisotropy = Mt.anisotropy),
                        Mt.flipY !== void 0 && (jt.flipY = Mt.flipY),
                        Mt.generateMipmaps !== void 0 && (jt.generateMipmaps = Mt.generateMipmaps),
                        Mt.premultiplyAlpha !== void 0 && (jt.premultiplyAlpha = Mt.premultiplyAlpha),
                        Mt.unpackAlignment !== void 0 && (jt.unpackAlignment = Mt.unpackAlignment),
                        Mt.compareFunction !== void 0 && (jt.compareFunction = Mt.compareFunction),
                        Mt.userData !== void 0 && (jt.userData = Mt.userData),
                        ft[Mt.uuid] = jt
                    }
                return ft
            }
            parseObject(tt, lt, mt, ft, xt) {
                let Ct;
                const Mt = tt.metadata && tt.metadata.version <= 4.5 ? Xo : void 0;
                function Lt(qt) {
                    return lt[qt] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", qt),
                    lt[qt]
                }
                function Nt(qt) {
                    if (qt !== void 0) {
                        if (Array.isArray(qt)) {
                            const Xt = [];
                            for (let Zt = 0, Yt = qt.length; Zt < Yt; Zt++) {
                                const sr = qt[Zt];
                                mt[sr] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", sr),
                                Xt.push(mt[sr])
                            }
                            return Xt
                        }
                        return mt[qt] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", qt),
                        mt[qt]
                    }
                }
                function jt(qt) {
                    return ft[qt] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", qt),
                    ft[qt]
                }
                let Wt, Qt;
                switch (tt.type) {
                case "Scene":
                    Ct = new Ax,
                    tt.background !== void 0 && (Number.isInteger(tt.background) ? Ct.background = new Gn().setHex(tt.background, Mt) : Ct.background = jt(tt.background)),
                    tt.environment !== void 0 && (Ct.environment = jt(tt.environment)),
                    tt.fog !== void 0 && (tt.fog.type === "Fog" ? Ct.fog = new Mv(tt.fog.color,tt.fog.near,tt.fog.far) : tt.fog.type === "FogExp2" && (Ct.fog = new Pv(tt.fog.color,tt.fog.density)),
                    tt.fog.name !== "" && (Ct.fog.name = tt.fog.name)),
                    tt.backgroundBlurriness !== void 0 && (Ct.backgroundBlurriness = tt.backgroundBlurriness),
                    tt.backgroundIntensity !== void 0 && (Ct.backgroundIntensity = tt.backgroundIntensity);
                    break;
                case "PerspectiveCamera":
                    Ct = new Cs(tt.fov,tt.aspect,tt.near,tt.far),
                    tt.focus !== void 0 && (Ct.focus = tt.focus),
                    tt.zoom !== void 0 && (Ct.zoom = tt.zoom),
                    tt.filmGauge !== void 0 && (Ct.filmGauge = tt.filmGauge),
                    tt.filmOffset !== void 0 && (Ct.filmOffset = tt.filmOffset),
                    tt.view !== void 0 && (Ct.view = Object.assign({}, tt.view));
                    break;
                case "OrthographicCamera":
                    Ct = new Sv(tt.left,tt.right,tt.top,tt.bottom,tt.near,tt.far),
                    tt.zoom !== void 0 && (Ct.zoom = tt.zoom),
                    tt.view !== void 0 && (Ct.view = Object.assign({}, tt.view));
                    break;
                case "AmbientLight":
                    Ct = new kA(tt.color,tt.intensity);
                    break;
                case "DirectionalLight":
                    Ct = new IA(tt.color,tt.intensity);
                    break;
                case "PointLight":
                    Ct = new RA(tt.color,tt.intensity,tt.distance,tt.decay);
                    break;
                case "RectAreaLight":
                    Ct = new DA(tt.color,tt.intensity,tt.width,tt.height);
                    break;
                case "SpotLight":
                    Ct = new PA(tt.color,tt.intensity,tt.distance,tt.angle,tt.penumbra,tt.decay);
                    break;
                case "HemisphereLight":
                    Ct = new EA(tt.color,tt.groundColor,tt.intensity);
                    break;
                case "LightProbe":
                    Ct = new LA().fromJSON(tt);
                    break;
                case "SkinnedMesh":
                    Wt = Lt(tt.geometry),
                    Qt = Nt(tt.material),
                    Ct = new Bx(Wt,Qt),
                    tt.bindMode !== void 0 && (Ct.bindMode = tt.bindMode),
                    tt.bindMatrix !== void 0 && Ct.bindMatrix.fromArray(tt.bindMatrix),
                    tt.skeleton !== void 0 && (Ct.skeleton = tt.skeleton);
                    break;
                case "Mesh":
                    Wt = Lt(tt.geometry),
                    Qt = Nt(tt.material),
                    Ct = new gs(Wt,Qt);
                    break;
                case "InstancedMesh":
                    Wt = Lt(tt.geometry),
                    Qt = Nt(tt.material);
                    const qt = tt.count
                      , Xt = tt.instanceMatrix
                      , Zt = tt.instanceColor;
                    Ct = new Fx(Wt,Qt,qt),
                    Ct.instanceMatrix = new Mm(new Float32Array(Xt.array),16),
                    Zt !== void 0 && (Ct.instanceColor = new Mm(new Float32Array(Zt.array),Zt.itemSize));
                    break;
                case "LOD":
                    Ct = new Px;
                    break;
                case "Line":
                    Ct = new ep(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "LineLoop":
                    Ct = new Hx(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "LineSegments":
                    Ct = new iu(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "PointCloud":
                case "Points":
                    Ct = new Wx(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "Sprite":
                    Ct = new Tx(Nt(tt.material));
                    break;
                case "Group":
                    Ct = new Am;
                    break;
                case "Bone":
                    Ct = new K0;
                    break;
                default:
                    Ct = new Mo
                }
                if (Ct.uuid = tt.uuid,
                tt.name !== void 0 && (Ct.name = tt.name),
                tt.matrix !== void 0 ? (Ct.matrix.fromArray(tt.matrix),
                tt.matrixAutoUpdate !== void 0 && (Ct.matrixAutoUpdate = tt.matrixAutoUpdate),
                Ct.matrixAutoUpdate && Ct.matrix.decompose(Ct.position, Ct.quaternion, Ct.scale)) : (tt.position !== void 0 && Ct.position.fromArray(tt.position),
                tt.rotation !== void 0 && Ct.rotation.fromArray(tt.rotation),
                tt.quaternion !== void 0 && Ct.quaternion.fromArray(tt.quaternion),
                tt.scale !== void 0 && Ct.scale.fromArray(tt.scale)),
                tt.up !== void 0 && Ct.up.fromArray(tt.up),
                tt.castShadow !== void 0 && (Ct.castShadow = tt.castShadow),
                tt.receiveShadow !== void 0 && (Ct.receiveShadow = tt.receiveShadow),
                tt.shadow && (tt.shadow.bias !== void 0 && (Ct.shadow.bias = tt.shadow.bias),
                tt.shadow.normalBias !== void 0 && (Ct.shadow.normalBias = tt.shadow.normalBias),
                tt.shadow.radius !== void 0 && (Ct.shadow.radius = tt.shadow.radius),
                tt.shadow.mapSize !== void 0 && Ct.shadow.mapSize.fromArray(tt.shadow.mapSize),
                tt.shadow.camera !== void 0 && (Ct.shadow.camera = this.parseObject(tt.shadow.camera))),
                tt.visible !== void 0 && (Ct.visible = tt.visible),
                tt.frustumCulled !== void 0 && (Ct.frustumCulled = tt.frustumCulled),
                tt.renderOrder !== void 0 && (Ct.renderOrder = tt.renderOrder),
                tt.userData !== void 0 && (Ct.userData = tt.userData),
                tt.layers !== void 0 && (Ct.layers.mask = tt.layers),
                tt.children !== void 0) {
                    const qt = tt.children;
                    for (let Xt = 0; Xt < qt.length; Xt++)
                        Ct.add(this.parseObject(qt[Xt], lt, mt, ft, xt))
                }
                if (tt.animations !== void 0) {
                    const qt = tt.animations;
                    for (let Xt = 0; Xt < qt.length; Xt++) {
                        const Zt = qt[Xt];
                        Ct.animations.push(xt[Zt])
                    }
                }
                if (tt.type === "LOD") {
                    tt.autoUpdate !== void 0 && (Ct.autoUpdate = tt.autoUpdate);
                    const qt = tt.levels;
                    for (let Xt = 0; Xt < qt.length; Xt++) {
                        const Zt = qt[Xt]
                          , Yt = Ct.getObjectByProperty("uuid", Zt.object);
                        Yt !== void 0 && Ct.addLevel(Yt, Zt.distance, Zt.hysteresis)
                    }
                }
                return Ct
            }
            bindSkeletons(tt, lt) {
                Object.keys(lt).length !== 0 && tt.traverse(function(mt) {
                    if (mt.isSkinnedMesh === !0 && mt.skeleton !== void 0) {
                        const ft = lt[mt.skeleton];
                        ft === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", mt.skeleton) : mt.bind(ft, mt.bindMatrix)
                    }
                })
            }
        }
        const BS = {
            UVMapping: jr,
            CubeReflectionMapping: Qr,
            CubeRefractionMapping: Or,
            EquirectangularReflectionMapping: qr,
            EquirectangularRefractionMapping: gn,
            CubeUVReflectionMapping: Mn
        }
          , FA = {
            RepeatWrapping: Tn,
            ClampToEdgeWrapping: wn,
            MirroredRepeatWrapping: Cn
        }
          , UA = {
            NearestFilter: fn,
            NearestMipmapNearestFilter: bn,
            NearestMipmapLinearFilter: En,
            LinearFilter: Rn,
            LinearMipmapNearestFilter: Yn,
            LinearMipmapLinearFilter: vo
        };
        class LS extends $s {
            constructor(tt) {
                super(tt),
                this.isImageBitmapLoader = !0,
                typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(tt) {
                return this.options = tt,
                this
            }
            load(tt, lt, mt, ft) {
                tt === void 0 && (tt = ""),
                this.path !== void 0 && (tt = this.path + tt),
                tt = this.manager.resolveURL(tt);
                const xt = this;
                Eu.get(tt, "blob").then(Ct => {
                    if (Ct !== void 0)
                        return xt.manager.itemStart(tt),
                        void createImageBitmap(Ct, Object.assign(xt.options, {
                            colorSpaceConversion: "none"
                        })).then(function(Lt) {
                            lt && lt(Lt),
                            xt.manager.itemEnd(tt)
                        }).catch(function(Lt) {
                            ft && ft(Lt),
                            xt.manager.itemError(tt),
                            xt.manager.itemEnd(tt)
                        });
                    const Mt = {};
                    Mt.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                    Mt.headers = this.requestHeader,
                    fetch(tt, Mt).then(function(Lt) {
                        return Lt.blob()
                    }).then(function(Lt) {
                        return Eu.add(tt, Lt, "blob"),
                        createImageBitmap(Lt, Object.assign(xt.options, {
                            colorSpaceConversion: "none"
                        }))
                    }).then(function(Lt) {
                        lt && lt(Lt),
                        xt.manager.itemEnd(tt)
                    }).catch(function(Lt) {
                        ft && ft(Lt),
                        xt.manager.itemError(tt),
                        xt.manager.itemEnd(tt)
                    }),
                    xt.manager.itemStart(tt)
                }
                )
            }
        }
        let c0;
        class wy {
            static getContext() {
                return c0 === void 0 && (c0 = new (window.AudioContext || window.webkitAudioContext)),
                c0
            }
            static setContext(tt) {
                c0 = tt
            }
        }
        class OS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(this.manager);
                function Mt(Lt) {
                    ft ? ft(Lt) : console.error(Lt),
                    xt.manager.itemError(tt)
                }
                Ct.setResponseType("arraybuffer"),
                Ct.setPath(this.path),
                Ct.setRequestHeader(this.requestHeader),
                Ct.setWithCredentials(this.withCredentials),
                Ct.load(tt, function(Lt) {
                    try {
                        const Nt = Lt.slice(0);
                        wy.getContext().decodeAudioData(Nt, function(jt) {
                            lt(jt)
                        }, Mt)
                    } catch (Nt) {
                        Mt(Nt)
                    }
                }, mt, ft)
            }
        }
        const jA = new no
          , VA = new no
          , Dp = new no;
        class NS {
            constructor() {
                this.type = "StereoCamera",
                this.aspect = 1,
                this.eyeSep = .064,
                this.cameraL = new Cs,
                this.cameraL.layers.enable(1),
                this.cameraL.matrixAutoUpdate = !1,
                this.cameraR = new Cs,
                this.cameraR.layers.enable(2),
                this.cameraR.matrixAutoUpdate = !1,
                this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            update(tt) {
                const lt = this._cache;
                if (lt.focus !== tt.focus || lt.fov !== tt.fov || lt.aspect !== tt.aspect * this.aspect || lt.near !== tt.near || lt.far !== tt.far || lt.zoom !== tt.zoom || lt.eyeSep !== this.eyeSep) {
                    lt.focus = tt.focus,
                    lt.fov = tt.fov,
                    lt.aspect = tt.aspect * this.aspect,
                    lt.near = tt.near,
                    lt.far = tt.far,
                    lt.zoom = tt.zoom,
                    lt.eyeSep = this.eyeSep,
                    Dp.copy(tt.projectionMatrix);
                    const mt = lt.eyeSep / 2
                      , ft = mt * lt.near / lt.focus
                      , xt = lt.near * Math.tan(Zl * lt.fov * .5) / lt.zoom;
                    let Ct, Mt;
                    VA.elements[12] = -mt,
                    jA.elements[12] = mt,
                    Ct = -xt * lt.aspect + ft,
                    Mt = xt * lt.aspect + ft,
                    Dp.elements[0] = 2 * lt.near / (Mt - Ct),
                    Dp.elements[8] = (Mt + Ct) / (Mt - Ct),
                    this.cameraL.projectionMatrix.copy(Dp),
                    Ct = -xt * lt.aspect - ft,
                    Mt = xt * lt.aspect - ft,
                    Dp.elements[0] = 2 * lt.near / (Mt - Ct),
                    Dp.elements[8] = (Mt + Ct) / (Mt - Ct),
                    this.cameraR.projectionMatrix.copy(Dp)
                }
                this.cameraL.matrixWorld.copy(tt.matrixWorld).multiply(VA),
                this.cameraR.matrixWorld.copy(tt.matrixWorld).multiply(jA)
            }
        }
        class GA {
            constructor(tt=!0) {
                this.autoStart = tt,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = zA(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let tt = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const lt = zA();
                    tt = (lt - this.oldTime) / 1e3,
                    this.oldTime = lt,
                    this.elapsedTime += tt
                }
                return tt
            }
        }
        function zA() {
            return (typeof performance > "u" ? Date : performance).now()
        }
        const Bp = new Er
          , HA = new Is
          , FS = new Er
          , Lp = new Er;
        class US extends Mo {
            constructor() {
                super(),
                this.type = "AudioListener",
                this.context = wy.getContext(),
                this.gain = this.context.createGain(),
                this.gain.connect(this.context.destination),
                this.filter = null,
                this.timeDelta = 0,
                this._clock = new GA
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return this.filter !== null && (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                this.filter = null),
                this
            }
            getFilter() {
                return this.filter
            }
            setFilter(tt) {
                return this.filter !== null ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                this.filter = tt,
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(tt) {
                return this.gain.gain.setTargetAtTime(tt, this.context.currentTime, .01),
                this
            }
            updateMatrixWorld(tt) {
                super.updateMatrixWorld(tt);
                const lt = this.context.listener
                  , mt = this.up;
                if (this.timeDelta = this._clock.getDelta(),
                this.matrixWorld.decompose(Bp, HA, FS),
                Lp.set(0, 0, -1).applyQuaternion(HA),
                lt.positionX) {
                    const ft = this.context.currentTime + this.timeDelta;
                    lt.positionX.linearRampToValueAtTime(Bp.x, ft),
                    lt.positionY.linearRampToValueAtTime(Bp.y, ft),
                    lt.positionZ.linearRampToValueAtTime(Bp.z, ft),
                    lt.forwardX.linearRampToValueAtTime(Lp.x, ft),
                    lt.forwardY.linearRampToValueAtTime(Lp.y, ft),
                    lt.forwardZ.linearRampToValueAtTime(Lp.z, ft),
                    lt.upX.linearRampToValueAtTime(mt.x, ft),
                    lt.upY.linearRampToValueAtTime(mt.y, ft),
                    lt.upZ.linearRampToValueAtTime(mt.z, ft)
                } else
                    lt.setPosition(Bp.x, Bp.y, Bp.z),
                    lt.setOrientation(Lp.x, Lp.y, Lp.z, mt.x, mt.y, mt.z)
            }
        }
        class QA extends Mo {
            constructor(tt) {
                super(),
                this.type = "Audio",
                this.listener = tt,
                this.context = tt.context,
                this.gain = this.context.createGain(),
                this.gain.connect(tt.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(tt) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = tt,
                this.connect(),
                this
            }
            setMediaElementSource(tt) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(tt),
                this.connect(),
                this
            }
            setMediaStreamSource(tt) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(tt),
                this.connect(),
                this
            }
            setBuffer(tt) {
                return this.buffer = tt,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play(tt=0) {
                if (this.isPlaying === !0)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (this.hasPlaybackControl === !1)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + tt;
                const lt = this.context.createBufferSource();
                return lt.buffer = this.buffer,
                lt.loop = this.loop,
                lt.loopStart = this.loopStart,
                lt.loopEnd = this.loopEnd,
                lt.onended = this.onEnded.bind(this),
                lt.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = lt,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (this.hasPlaybackControl !== !1)
                    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (this.hasPlaybackControl !== !1)
                    return this._progress = 0,
                    this.source !== null && (this.source.stop(),
                    this.source.onended = null),
                    this.isPlaying = !1,
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let tt = 1, lt = this.filters.length; tt < lt; tt++)
                        this.filters[tt - 1].connect(this.filters[tt]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (this._connected !== !1) {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let tt = 1, lt = this.filters.length; tt < lt; tt++)
                            this.filters[tt - 1].disconnect(this.filters[tt]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else
                        this.source.disconnect(this.getOutput());
                    return this._connected = !1,
                    this
                }
            }
            getFilters() {
                return this.filters
            }
            setFilters(tt) {
                return tt || (tt = []),
                this._connected === !0 ? (this.disconnect(),
                this.filters = tt.slice(),
                this.connect()) : this.filters = tt.slice(),
                this
            }
            setDetune(tt) {
                if (this.detune = tt,
                this.source.detune !== void 0)
                    return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(tt) {
                return this.setFilters(tt ? [tt] : [])
            }
            setPlaybackRate(tt) {
                if (this.hasPlaybackControl !== !1)
                    return this.playbackRate = tt,
                    this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(tt) {
                if (this.hasPlaybackControl !== !1)
                    return this.loop = tt,
                    this.isPlaying === !0 && (this.source.loop = this.loop),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(tt) {
                return this.loopStart = tt,
                this
            }
            setLoopEnd(tt) {
                return this.loopEnd = tt,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(tt) {
                return this.gain.gain.setTargetAtTime(tt, this.context.currentTime, .01),
                this
            }
        }
        const Op = new Er
          , WA = new Is
          , jS = new Er
          , Np = new Er;
        class VS extends QA {
            constructor(tt) {
                super(tt),
                this.panner = this.context.createPanner(),
                this.panner.panningModel = "HRTF",
                this.panner.connect(this.gain)
            }
            connect() {
                super.connect(),
                this.panner.connect(this.gain)
            }
            disconnect() {
                super.disconnect(),
                this.panner.disconnect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(tt) {
                return this.panner.refDistance = tt,
                this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(tt) {
                return this.panner.rolloffFactor = tt,
                this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(tt) {
                return this.panner.distanceModel = tt,
                this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(tt) {
                return this.panner.maxDistance = tt,
                this
            }
            setDirectionalCone(tt, lt, mt) {
                return this.panner.coneInnerAngle = tt,
                this.panner.coneOuterAngle = lt,
                this.panner.coneOuterGain = mt,
                this
            }
            updateMatrixWorld(tt) {
                if (super.updateMatrixWorld(tt),
                this.hasPlaybackControl === !0 && this.isPlaying === !1)
                    return;
                this.matrixWorld.decompose(Op, WA, jS),
                Np.set(0, 0, 1).applyQuaternion(WA);
                const lt = this.panner;
                if (lt.positionX) {
                    const mt = this.context.currentTime + this.listener.timeDelta;
                    lt.positionX.linearRampToValueAtTime(Op.x, mt),
                    lt.positionY.linearRampToValueAtTime(Op.y, mt),
                    lt.positionZ.linearRampToValueAtTime(Op.z, mt),
                    lt.orientationX.linearRampToValueAtTime(Np.x, mt),
                    lt.orientationY.linearRampToValueAtTime(Np.y, mt),
                    lt.orientationZ.linearRampToValueAtTime(Np.z, mt)
                } else
                    lt.setPosition(Op.x, Op.y, Op.z),
                    lt.setOrientation(Np.x, Np.y, Np.z)
            }
        }
        class GS {
            constructor(tt, lt=2048) {
                this.analyser = tt.context.createAnalyser(),
                this.analyser.fftSize = lt,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                tt.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            }
            getAverageFrequency() {
                let tt = 0;
                const lt = this.getFrequencyData();
                for (let mt = 0; mt < lt.length; mt++)
                    tt += lt[mt];
                return tt / lt.length
            }
        }
        class qA {
            constructor(tt, lt, mt) {
                let ft, xt, Ct;
                switch (this.binding = tt,
                this.valueSize = mt,
                lt) {
                case "quaternion":
                    ft = this._slerp,
                    xt = this._slerpAdditive,
                    Ct = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * mt),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    ft = this._select,
                    xt = this._select,
                    Ct = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * mt);
                    break;
                default:
                    ft = this._lerp,
                    xt = this._lerpAdditive,
                    Ct = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * mt)
                }
                this._mixBufferRegion = ft,
                this._mixBufferRegionAdditive = xt,
                this._setIdentity = Ct,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(tt, lt) {
                const mt = this.buffer
                  , ft = this.valueSize
                  , xt = tt * ft + ft;
                let Ct = this.cumulativeWeight;
                if (Ct === 0) {
                    for (let Mt = 0; Mt !== ft; ++Mt)
                        mt[xt + Mt] = mt[Mt];
                    Ct = lt
                } else {
                    Ct += lt;
                    const Mt = lt / Ct;
                    this._mixBufferRegion(mt, xt, 0, Mt, ft)
                }
                this.cumulativeWeight = Ct
            }
            accumulateAdditive(tt) {
                const lt = this.buffer
                  , mt = this.valueSize
                  , ft = mt * this._addIndex;
                this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                this._mixBufferRegionAdditive(lt, ft, 0, tt, mt),
                this.cumulativeWeightAdditive += tt
            }
            apply(tt) {
                const lt = this.valueSize
                  , mt = this.buffer
                  , ft = tt * lt + lt
                  , xt = this.cumulativeWeight
                  , Ct = this.cumulativeWeightAdditive
                  , Mt = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                xt < 1) {
                    const Lt = lt * this._origIndex;
                    this._mixBufferRegion(mt, ft, Lt, 1 - xt, lt)
                }
                Ct > 0 && this._mixBufferRegionAdditive(mt, ft, this._addIndex * lt, 1, lt);
                for (let Lt = lt, Nt = lt + lt; Lt !== Nt; ++Lt)
                    if (mt[Lt] !== mt[Lt + lt]) {
                        Mt.setValue(mt, ft);
                        break
                    }
            }
            saveOriginalState() {
                const tt = this.binding
                  , lt = this.buffer
                  , mt = this.valueSize
                  , ft = mt * this._origIndex;
                tt.getValue(lt, ft);
                for (let xt = mt, Ct = ft; xt !== Ct; ++xt)
                    lt[xt] = lt[ft + xt % mt];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const tt = 3 * this.valueSize;
                this.binding.setValue(this.buffer, tt)
            }
            _setAdditiveIdentityNumeric() {
                const tt = this._addIndex * this.valueSize
                  , lt = tt + this.valueSize;
                for (let mt = tt; mt < lt; mt++)
                    this.buffer[mt] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const tt = this._origIndex * this.valueSize
                  , lt = this._addIndex * this.valueSize;
                for (let mt = 0; mt < this.valueSize; mt++)
                    this.buffer[lt + mt] = this.buffer[tt + mt]
            }
            _select(tt, lt, mt, ft, xt) {
                if (ft >= .5)
                    for (let Ct = 0; Ct !== xt; ++Ct)
                        tt[lt + Ct] = tt[mt + Ct]
            }
            _slerp(tt, lt, mt, ft) {
                Is.slerpFlat(tt, lt, tt, lt, tt, mt, ft)
            }
            _slerpAdditive(tt, lt, mt, ft, xt) {
                const Ct = this._workIndex * xt;
                Is.multiplyQuaternionsFlat(tt, Ct, tt, lt, tt, mt),
                Is.slerpFlat(tt, lt, tt, lt, tt, Ct, ft)
            }
            _lerp(tt, lt, mt, ft, xt) {
                const Ct = 1 - ft;
                for (let Mt = 0; Mt !== xt; ++Mt) {
                    const Lt = lt + Mt;
                    tt[Lt] = tt[Lt] * Ct + tt[mt + Mt] * ft
                }
            }
            _lerpAdditive(tt, lt, mt, ft, xt) {
                for (let Ct = 0; Ct !== xt; ++Ct) {
                    const Mt = lt + Ct;
                    tt[Mt] = tt[Mt] + tt[mt + Ct] * ft
                }
            }
        }
        const Sy = "\\[\\]\\.:\\/"
          , zS = new RegExp("[" + Sy + "]","g")
          , Ey = "[^" + Sy + "]"
          , HS = "[^" + Sy.replace("\\.", "") + "]"
          , QS = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Ey) + /(WCOD+)?/.source.replace("WCOD", HS) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ey) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ey) + "$")
          , WS = ["material", "materials", "bones", "map"];
        class Ro {
            constructor(tt, lt, mt) {
                this.path = lt,
                this.parsedPath = mt || Ro.parseTrackName(lt),
                this.node = Ro.findNode(tt, this.parsedPath.nodeName),
                this.rootNode = tt,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(tt, lt, mt) {
                return tt && tt.isAnimationObjectGroup ? new Ro.Composite(tt,lt,mt) : new Ro(tt,lt,mt)
            }
            static sanitizeNodeName(tt) {
                return tt.replace(/\s/g, "_").replace(zS, "")
            }
            static parseTrackName(tt) {
                const lt = QS.exec(tt);
                if (lt === null)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + tt);
                const mt = {
                    nodeName: lt[2],
                    objectName: lt[3],
                    objectIndex: lt[4],
                    propertyName: lt[5],
                    propertyIndex: lt[6]
                }
                  , ft = mt.nodeName && mt.nodeName.lastIndexOf(".");
                if (ft !== void 0 && ft !== -1) {
                    const xt = mt.nodeName.substring(ft + 1);
                    WS.indexOf(xt) !== -1 && (mt.nodeName = mt.nodeName.substring(0, ft),
                    mt.objectName = xt)
                }
                if (mt.propertyName === null || mt.propertyName.length === 0)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + tt);
                return mt
            }
            static findNode(tt, lt) {
                if (lt === void 0 || lt === "" || lt === "." || lt === -1 || lt === tt.name || lt === tt.uuid)
                    return tt;
                if (tt.skeleton) {
                    const mt = tt.skeleton.getBoneByName(lt);
                    if (mt !== void 0)
                        return mt
                }
                if (tt.children) {
                    const mt = function(xt) {
                        for (let Ct = 0; Ct < xt.length; Ct++) {
                            const Mt = xt[Ct];
                            if (Mt.name === lt || Mt.uuid === lt)
                                return Mt;
                            const Lt = mt(Mt.children);
                            if (Lt)
                                return Lt
                        }
                        return null
                    }
                      , ft = mt(tt.children);
                    if (ft)
                        return ft
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(tt, lt) {
                tt[lt] = this.targetObject[this.propertyName]
            }
            _getValue_array(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    tt[lt++] = mt[ft]
            }
            _getValue_arrayElement(tt, lt) {
                tt[lt] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(tt, lt) {
                this.resolvedProperty.toArray(tt, lt)
            }
            _setValue_direct(tt, lt) {
                this.targetObject[this.propertyName] = tt[lt]
            }
            _setValue_direct_setNeedsUpdate(tt, lt) {
                this.targetObject[this.propertyName] = tt[lt],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(tt, lt) {
                this.targetObject[this.propertyName] = tt[lt],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    mt[ft] = tt[lt++]
            }
            _setValue_array_setNeedsUpdate(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    mt[ft] = tt[lt++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    mt[ft] = tt[lt++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(tt, lt) {
                this.resolvedProperty[this.propertyIndex] = tt[lt]
            }
            _setValue_arrayElement_setNeedsUpdate(tt, lt) {
                this.resolvedProperty[this.propertyIndex] = tt[lt],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(tt, lt) {
                this.resolvedProperty[this.propertyIndex] = tt[lt],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(tt, lt) {
                this.resolvedProperty.fromArray(tt, lt)
            }
            _setValue_fromArray_setNeedsUpdate(tt, lt) {
                this.resolvedProperty.fromArray(tt, lt),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(tt, lt) {
                this.resolvedProperty.fromArray(tt, lt),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(tt, lt) {
                this.bind(),
                this.getValue(tt, lt)
            }
            _setValue_unbound(tt, lt) {
                this.bind(),
                this.setValue(tt, lt)
            }
            bind() {
                let tt = this.node;
                const lt = this.parsedPath
                  , mt = lt.objectName
                  , ft = lt.propertyName;
                let xt = lt.propertyIndex;
                if (tt || (tt = Ro.findNode(this.rootNode, lt.nodeName),
                this.node = tt),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !tt)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (mt) {
                    let Nt = lt.objectIndex;
                    switch (mt) {
                    case "materials":
                        if (!tt.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!tt.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        tt = tt.material.materials;
                        break;
                    case "bones":
                        if (!tt.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        tt = tt.skeleton.bones;
                        for (let jt = 0; jt < tt.length; jt++)
                            if (tt[jt].name === Nt) {
                                Nt = jt;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in tt) {
                            tt = tt.map;
                            break
                        }
                        if (!tt.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!tt.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        tt = tt.material.map;
                        break;
                    default:
                        if (tt[mt] === void 0)
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        tt = tt[mt]
                    }
                    if (Nt !== void 0) {
                        if (tt[Nt] === void 0)
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, tt);
                        tt = tt[Nt]
                    }
                }
                const Ct = tt[ft];
                if (Ct === void 0) {
                    const Nt = lt.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + Nt + "." + ft + " but it wasn't found.", tt)
                }
                let Mt = this.Versioning.None;
                this.targetObject = tt,
                tt.needsUpdate !== void 0 ? Mt = this.Versioning.NeedsUpdate : tt.matrixWorldNeedsUpdate !== void 0 && (Mt = this.Versioning.MatrixWorldNeedsUpdate);
                let Lt = this.BindingType.Direct;
                if (xt !== void 0) {
                    if (ft === "morphTargetInfluences") {
                        if (!tt.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!tt.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        tt.morphTargetDictionary[xt] !== void 0 && (xt = tt.morphTargetDictionary[xt])
                    }
                    Lt = this.BindingType.ArrayElement,
                    this.resolvedProperty = Ct,
                    this.propertyIndex = xt
                } else
                    Ct.fromArray !== void 0 && Ct.toArray !== void 0 ? (Lt = this.BindingType.HasFromToArray,
                    this.resolvedProperty = Ct) : Array.isArray(Ct) ? (Lt = this.BindingType.EntireArray,
                    this.resolvedProperty = Ct) : this.propertyName = ft;
                this.getValue = this.GetterByBindingType[Lt],
                this.setValue = this.SetterByBindingTypeAndVersioning[Lt][Mt]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        Ro.Composite = class {
            constructor(Tt, tt, lt) {
                const mt = lt || Ro.parseTrackName(tt);
                this._targetGroup = Tt,
                this._bindings = Tt.subscribe_(tt, mt)
            }
            getValue(Tt, tt) {
                this.bind();
                const lt = this._targetGroup.nCachedObjects_
                  , mt = this._bindings[lt];
                mt !== void 0 && mt.getValue(Tt, tt)
            }
            setValue(Tt, tt) {
                const lt = this._bindings;
                for (let mt = this._targetGroup.nCachedObjects_, ft = lt.length; mt !== ft; ++mt)
                    lt[mt].setValue(Tt, tt)
            }
            bind() {
                const Tt = this._bindings;
                for (let tt = this._targetGroup.nCachedObjects_, lt = Tt.length; tt !== lt; ++tt)
                    Tt[tt].bind()
            }
            unbind() {
                const Tt = this._bindings;
                for (let tt = this._targetGroup.nCachedObjects_, lt = Tt.length; tt !== lt; ++tt)
                    Tt[tt].unbind()
            }
        }
        ,
        Ro.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Ro.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        Ro.prototype.GetterByBindingType = [Ro.prototype._getValue_direct, Ro.prototype._getValue_array, Ro.prototype._getValue_arrayElement, Ro.prototype._getValue_toArray],
        Ro.prototype.SetterByBindingTypeAndVersioning = [[Ro.prototype._setValue_direct, Ro.prototype._setValue_direct_setNeedsUpdate, Ro.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ro.prototype._setValue_array, Ro.prototype._setValue_array_setNeedsUpdate, Ro.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ro.prototype._setValue_arrayElement, Ro.prototype._setValue_arrayElement_setNeedsUpdate, Ro.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ro.prototype._setValue_fromArray, Ro.prototype._setValue_fromArray_setNeedsUpdate, Ro.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class qS {
            constructor() {
                this.isAnimationObjectGroup = !0,
                this.uuid = Ms(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
                const tt = {};
                this._indicesByUUID = tt;
                for (let mt = 0, ft = arguments.length; mt !== ft; ++mt)
                    tt[arguments[mt].uuid] = mt;
                this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
                const lt = this;
                this.stats = {
                    objects: {
                        get total() {
                            return lt._objects.length
                        },
                        get inUse() {
                            return this.total - lt.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return lt._bindings.length
                    }
                }
            }
            add() {
                const tt = this._objects
                  , lt = this._indicesByUUID
                  , mt = this._paths
                  , ft = this._parsedPaths
                  , xt = this._bindings
                  , Ct = xt.length;
                let Mt, Lt = tt.length, Nt = this.nCachedObjects_;
                for (let jt = 0, Wt = arguments.length; jt !== Wt; ++jt) {
                    const Qt = arguments[jt]
                      , qt = Qt.uuid;
                    let Xt = lt[qt];
                    if (Xt === void 0) {
                        Xt = Lt++,
                        lt[qt] = Xt,
                        tt.push(Qt);
                        for (let Zt = 0, Yt = Ct; Zt !== Yt; ++Zt)
                            xt[Zt].push(new Ro(Qt,mt[Zt],ft[Zt]))
                    } else if (Xt < Nt) {
                        Mt = tt[Xt];
                        const Zt = --Nt
                          , Yt = tt[Zt];
                        lt[Yt.uuid] = Xt,
                        tt[Xt] = Yt,
                        lt[qt] = Zt,
                        tt[Zt] = Qt;
                        for (let sr = 0, er = Ct; sr !== er; ++sr) {
                            const rr = xt[sr]
                              , xr = rr[Zt];
                            let br = rr[Xt];
                            rr[Xt] = xr,
                            br === void 0 && (br = new Ro(Qt,mt[sr],ft[sr])),
                            rr[Zt] = br
                        }
                    } else
                        tt[Xt] !== Mt && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = Nt
            }
            remove() {
                const tt = this._objects
                  , lt = this._indicesByUUID
                  , mt = this._bindings
                  , ft = mt.length;
                let xt = this.nCachedObjects_;
                for (let Ct = 0, Mt = arguments.length; Ct !== Mt; ++Ct) {
                    const Lt = arguments[Ct]
                      , Nt = Lt.uuid
                      , jt = lt[Nt];
                    if (jt !== void 0 && jt >= xt) {
                        const Wt = xt++
                          , Qt = tt[Wt];
                        lt[Qt.uuid] = jt,
                        tt[jt] = Qt,
                        lt[Nt] = Wt,
                        tt[Wt] = Lt;
                        for (let qt = 0, Xt = ft; qt !== Xt; ++qt) {
                            const Zt = mt[qt]
                              , Yt = Zt[Wt]
                              , sr = Zt[jt];
                            Zt[jt] = Yt,
                            Zt[Wt] = sr
                        }
                    }
                }
                this.nCachedObjects_ = xt
            }
            uncache() {
                const tt = this._objects
                  , lt = this._indicesByUUID
                  , mt = this._bindings
                  , ft = mt.length;
                let xt = this.nCachedObjects_
                  , Ct = tt.length;
                for (let Mt = 0, Lt = arguments.length; Mt !== Lt; ++Mt) {
                    const Nt = arguments[Mt].uuid
                      , jt = lt[Nt];
                    if (jt !== void 0)
                        if (delete lt[Nt],
                        jt < xt) {
                            const Wt = --xt
                              , Qt = tt[Wt]
                              , qt = --Ct
                              , Xt = tt[qt];
                            lt[Qt.uuid] = jt,
                            tt[jt] = Qt,
                            lt[Xt.uuid] = Wt,
                            tt[Wt] = Xt,
                            tt.pop();
                            for (let Zt = 0, Yt = ft; Zt !== Yt; ++Zt) {
                                const sr = mt[Zt]
                                  , er = sr[Wt]
                                  , rr = sr[qt];
                                sr[jt] = er,
                                sr[Wt] = rr,
                                sr.pop()
                            }
                        } else {
                            const Wt = --Ct
                              , Qt = tt[Wt];
                            Wt > 0 && (lt[Qt.uuid] = jt),
                            tt[jt] = Qt,
                            tt.pop();
                            for (let qt = 0, Xt = ft; qt !== Xt; ++qt) {
                                const Zt = mt[qt];
                                Zt[jt] = Zt[Wt],
                                Zt.pop()
                            }
                        }
                }
                this.nCachedObjects_ = xt
            }
            subscribe_(tt, lt) {
                const mt = this._bindingsIndicesByPath;
                let ft = mt[tt];
                const xt = this._bindings;
                if (ft !== void 0)
                    return xt[ft];
                const Ct = this._paths
                  , Mt = this._parsedPaths
                  , Lt = this._objects
                  , Nt = Lt.length
                  , jt = this.nCachedObjects_
                  , Wt = new Array(Nt);
                ft = xt.length,
                mt[tt] = ft,
                Ct.push(tt),
                Mt.push(lt),
                xt.push(Wt);
                for (let Qt = jt, qt = Lt.length; Qt !== qt; ++Qt) {
                    const Xt = Lt[Qt];
                    Wt[Qt] = new Ro(Xt,tt,lt)
                }
                return Wt
            }
            unsubscribe_(tt) {
                const lt = this._bindingsIndicesByPath
                  , mt = lt[tt];
                if (mt !== void 0) {
                    const ft = this._paths
                      , xt = this._parsedPaths
                      , Ct = this._bindings
                      , Mt = Ct.length - 1
                      , Lt = Ct[Mt];
                    lt[tt[Mt]] = mt,
                    Ct[mt] = Lt,
                    Ct.pop(),
                    xt[mt] = xt[Mt],
                    xt.pop(),
                    ft[mt] = ft[Mt],
                    ft.pop()
                }
            }
        }
        class $A {
            constructor(tt, lt, mt=null, ft=lt.blendMode) {
                this._mixer = tt,
                this._clip = lt,
                this._localRoot = mt,
                this.blendMode = ft;
                const xt = lt.tracks
                  , Ct = xt.length
                  , Mt = new Array(Ct)
                  , Lt = {
                    endingStart: du,
                    endingEnd: du
                };
                for (let Nt = 0; Nt !== Ct; ++Nt) {
                    const jt = xt[Nt].createInterpolant(null);
                    Mt[Nt] = jt,
                    jt.settings = Lt
                }
                this._interpolantSettings = Lt,
                this._interpolants = Mt,
                this._propertyBindings = new Array(Ct),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = Du,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(tt) {
                return this._startTime = tt,
                this
            }
            setLoop(tt, lt) {
                return this.loop = tt,
                this.repetitions = lt,
                this
            }
            setEffectiveWeight(tt) {
                return this.weight = tt,
                this._effectiveWeight = this.enabled ? tt : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(tt) {
                return this._scheduleFading(tt, 0, 1)
            }
            fadeOut(tt) {
                return this._scheduleFading(tt, 1, 0)
            }
            crossFadeFrom(tt, lt, mt) {
                if (tt.fadeOut(lt),
                this.fadeIn(lt),
                mt) {
                    const ft = this._clip.duration
                      , xt = tt._clip.duration
                      , Ct = xt / ft
                      , Mt = ft / xt;
                    tt.warp(1, Ct, lt),
                    this.warp(Mt, 1, lt)
                }
                return this
            }
            crossFadeTo(tt, lt, mt) {
                return tt.crossFadeFrom(this, lt, mt)
            }
            stopFading() {
                const tt = this._weightInterpolant;
                return tt !== null && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(tt)),
                this
            }
            setEffectiveTimeScale(tt) {
                return this.timeScale = tt,
                this._effectiveTimeScale = this.paused ? 0 : tt,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(tt) {
                return this.timeScale = this._clip.duration / tt,
                this.stopWarping()
            }
            syncWith(tt) {
                return this.time = tt.time,
                this.timeScale = tt.timeScale,
                this.stopWarping()
            }
            halt(tt) {
                return this.warp(this._effectiveTimeScale, 0, tt)
            }
            warp(tt, lt, mt) {
                const ft = this._mixer
                  , xt = ft.time
                  , Ct = this.timeScale;
                let Mt = this._timeScaleInterpolant;
                Mt === null && (Mt = ft._lendControlInterpolant(),
                this._timeScaleInterpolant = Mt);
                const Lt = Mt.parameterPositions
                  , Nt = Mt.sampleValues;
                return Lt[0] = xt,
                Lt[1] = xt + mt,
                Nt[0] = tt / Ct,
                Nt[1] = lt / Ct,
                this
            }
            stopWarping() {
                const tt = this._timeScaleInterpolant;
                return tt !== null && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(tt)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(tt, lt, mt, ft) {
                if (!this.enabled)
                    return void this._updateWeight(tt);
                const xt = this._startTime;
                if (xt !== null) {
                    const Lt = (tt - xt) * mt;
                    Lt < 0 || mt === 0 ? lt = 0 : (this._startTime = null,
                    lt = mt * Lt)
                }
                lt *= this._updateTimeScale(tt);
                const Ct = this._updateTime(lt)
                  , Mt = this._updateWeight(tt);
                if (Mt > 0) {
                    const Lt = this._interpolants
                      , Nt = this._propertyBindings;
                    if (this.blendMode === Xp)
                        for (let jt = 0, Wt = Lt.length; jt !== Wt; ++jt)
                            Lt[jt].evaluate(Ct),
                            Nt[jt].accumulateAdditive(Mt);
                    else
                        for (let jt = 0, Wt = Lt.length; jt !== Wt; ++jt)
                            Lt[jt].evaluate(Ct),
                            Nt[jt].accumulate(ft, Mt)
                }
            }
            _updateWeight(tt) {
                let lt = 0;
                if (this.enabled) {
                    lt = this.weight;
                    const mt = this._weightInterpolant;
                    if (mt !== null) {
                        const ft = mt.evaluate(tt)[0];
                        lt *= ft,
                        tt > mt.parameterPositions[1] && (this.stopFading(),
                        ft === 0 && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = lt,
                lt
            }
            _updateTimeScale(tt) {
                let lt = 0;
                if (!this.paused) {
                    lt = this.timeScale;
                    const mt = this._timeScaleInterpolant;
                    mt !== null && (lt *= mt.evaluate(tt)[0],
                    tt > mt.parameterPositions[1] && (this.stopWarping(),
                    lt === 0 ? this.paused = !0 : this.timeScale = lt))
                }
                return this._effectiveTimeScale = lt,
                lt
            }
            _updateTime(tt) {
                const lt = this._clip.duration
                  , mt = this.loop;
                let ft = this.time + tt
                  , xt = this._loopCount;
                const Ct = mt === qp;
                if (tt === 0)
                    return xt === -1 || !Ct || 1 & ~xt ? ft : lt - ft;
                if (mt === ku) {
                    xt === -1 && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    e: {
                        if (ft >= lt)
                            ft = lt;
                        else {
                            if (!(ft < 0)) {
                                this.time = ft;
                                break e
                            }
                            ft = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = ft,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: tt < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (xt === -1 && (tt >= 0 ? (xt = 0,
                    this._setEndings(!0, this.repetitions === 0, Ct)) : this._setEndings(this.repetitions === 0, !0, Ct)),
                    ft >= lt || ft < 0) {
                        const Mt = Math.floor(ft / lt);
                        ft -= lt * Mt,
                        xt += Math.abs(Mt);
                        const Lt = this.repetitions - xt;
                        if (Lt <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            ft = tt > 0 ? lt : 0,
                            this.time = ft,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: tt > 0 ? 1 : -1
                            });
                        else {
                            if (Lt === 1) {
                                const Nt = tt < 0;
                                this._setEndings(Nt, !Nt, Ct)
                            } else
                                this._setEndings(!1, !1, Ct);
                            this._loopCount = xt,
                            this.time = ft,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: Mt
                            })
                        }
                    } else
                        this.time = ft;
                    if (Ct && !(1 & ~xt))
                        return lt - ft
                }
                return ft
            }
            _setEndings(tt, lt, mt) {
                const ft = this._interpolantSettings;
                mt ? (ft.endingStart = pu,
                ft.endingEnd = pu) : (ft.endingStart = tt ? this.zeroSlopeAtStart ? pu : du : cp,
                ft.endingEnd = lt ? this.zeroSlopeAtEnd ? pu : du : cp)
            }
            _scheduleFading(tt, lt, mt) {
                const ft = this._mixer
                  , xt = ft.time;
                let Ct = this._weightInterpolant;
                Ct === null && (Ct = ft._lendControlInterpolant(),
                this._weightInterpolant = Ct);
                const Mt = Ct.parameterPositions
                  , Lt = Ct.sampleValues;
                return Mt[0] = xt,
                Lt[0] = lt,
                Mt[1] = xt + tt,
                Lt[1] = mt,
                this
            }
        }
        const $S = new Float32Array(1);
        class XS extends As {
            constructor(tt) {
                super(),
                this._root = tt,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(tt, lt) {
                const mt = tt._localRoot || this._root
                  , ft = tt._clip.tracks
                  , xt = ft.length
                  , Ct = tt._propertyBindings
                  , Mt = tt._interpolants
                  , Lt = mt.uuid
                  , Nt = this._bindingsByRootAndName;
                let jt = Nt[Lt];
                jt === void 0 && (jt = {},
                Nt[Lt] = jt);
                for (let Wt = 0; Wt !== xt; ++Wt) {
                    const Qt = ft[Wt]
                      , qt = Qt.name;
                    let Xt = jt[qt];
                    if (Xt !== void 0)
                        ++Xt.referenceCount,
                        Ct[Wt] = Xt;
                    else {
                        if (Xt = Ct[Wt],
                        Xt !== void 0) {
                            Xt._cacheIndex === null && (++Xt.referenceCount,
                            this._addInactiveBinding(Xt, Lt, qt));
                            continue
                        }
                        const Zt = lt && lt._propertyBindings[Wt].binding.parsedPath;
                        Xt = new qA(Ro.create(mt, qt, Zt),Qt.ValueTypeName,Qt.getValueSize()),
                        ++Xt.referenceCount,
                        this._addInactiveBinding(Xt, Lt, qt),
                        Ct[Wt] = Xt
                    }
                    Mt[Wt].resultBuffer = Xt.buffer
                }
            }
            _activateAction(tt) {
                if (!this._isActiveAction(tt)) {
                    if (tt._cacheIndex === null) {
                        const mt = (tt._localRoot || this._root).uuid
                          , ft = tt._clip.uuid
                          , xt = this._actionsByClip[ft];
                        this._bindAction(tt, xt && xt.knownActions[0]),
                        this._addInactiveAction(tt, ft, mt)
                    }
                    const lt = tt._propertyBindings;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt) {
                        const xt = lt[mt];
                        xt.useCount++ == 0 && (this._lendBinding(xt),
                        xt.saveOriginalState())
                    }
                    this._lendAction(tt)
                }
            }
            _deactivateAction(tt) {
                if (this._isActiveAction(tt)) {
                    const lt = tt._propertyBindings;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt) {
                        const xt = lt[mt];
                        --xt.useCount == 0 && (xt.restoreOriginalState(),
                        this._takeBackBinding(xt))
                    }
                    this._takeBackAction(tt)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const tt = this;
                this.stats = {
                    actions: {
                        get total() {
                            return tt._actions.length
                        },
                        get inUse() {
                            return tt._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return tt._bindings.length
                        },
                        get inUse() {
                            return tt._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return tt._controlInterpolants.length
                        },
                        get inUse() {
                            return tt._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(tt) {
                const lt = tt._cacheIndex;
                return lt !== null && lt < this._nActiveActions
            }
            _addInactiveAction(tt, lt, mt) {
                const ft = this._actions
                  , xt = this._actionsByClip;
                let Ct = xt[lt];
                if (Ct === void 0)
                    Ct = {
                        knownActions: [tt],
                        actionByRoot: {}
                    },
                    tt._byClipCacheIndex = 0,
                    xt[lt] = Ct;
                else {
                    const Mt = Ct.knownActions;
                    tt._byClipCacheIndex = Mt.length,
                    Mt.push(tt)
                }
                tt._cacheIndex = ft.length,
                ft.push(tt),
                Ct.actionByRoot[mt] = tt
            }
            _removeInactiveAction(tt) {
                const lt = this._actions
                  , mt = lt[lt.length - 1]
                  , ft = tt._cacheIndex;
                mt._cacheIndex = ft,
                lt[ft] = mt,
                lt.pop(),
                tt._cacheIndex = null;
                const xt = tt._clip.uuid
                  , Ct = this._actionsByClip
                  , Mt = Ct[xt]
                  , Lt = Mt.knownActions
                  , Nt = Lt[Lt.length - 1]
                  , jt = tt._byClipCacheIndex;
                Nt._byClipCacheIndex = jt,
                Lt[jt] = Nt,
                Lt.pop(),
                tt._byClipCacheIndex = null,
                delete Mt.actionByRoot[(tt._localRoot || this._root).uuid],
                Lt.length === 0 && delete Ct[xt],
                this._removeInactiveBindingsForAction(tt)
            }
            _removeInactiveBindingsForAction(tt) {
                const lt = tt._propertyBindings;
                for (let mt = 0, ft = lt.length; mt !== ft; ++mt) {
                    const xt = lt[mt];
                    --xt.referenceCount == 0 && this._removeInactiveBinding(xt)
                }
            }
            _lendAction(tt) {
                const lt = this._actions
                  , mt = tt._cacheIndex
                  , ft = this._nActiveActions++
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _takeBackAction(tt) {
                const lt = this._actions
                  , mt = tt._cacheIndex
                  , ft = --this._nActiveActions
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _addInactiveBinding(tt, lt, mt) {
                const ft = this._bindingsByRootAndName
                  , xt = this._bindings;
                let Ct = ft[lt];
                Ct === void 0 && (Ct = {},
                ft[lt] = Ct),
                Ct[mt] = tt,
                tt._cacheIndex = xt.length,
                xt.push(tt)
            }
            _removeInactiveBinding(tt) {
                const lt = this._bindings
                  , mt = tt.binding
                  , ft = mt.rootNode.uuid
                  , xt = mt.path
                  , Ct = this._bindingsByRootAndName
                  , Mt = Ct[ft]
                  , Lt = lt[lt.length - 1]
                  , Nt = tt._cacheIndex;
                Lt._cacheIndex = Nt,
                lt[Nt] = Lt,
                lt.pop(),
                delete Mt[xt],
                Object.keys(Mt).length === 0 && delete Ct[ft]
            }
            _lendBinding(tt) {
                const lt = this._bindings
                  , mt = tt._cacheIndex
                  , ft = this._nActiveBindings++
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _takeBackBinding(tt) {
                const lt = this._bindings
                  , mt = tt._cacheIndex
                  , ft = --this._nActiveBindings
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _lendControlInterpolant() {
                const tt = this._controlInterpolants
                  , lt = this._nActiveControlInterpolants++;
                let mt = tt[lt];
                return mt === void 0 && (mt = new gy(new Float32Array(2),new Float32Array(2),1,$S),
                mt.__cacheIndex = lt,
                tt[lt] = mt),
                mt
            }
            _takeBackControlInterpolant(tt) {
                const lt = this._controlInterpolants
                  , mt = tt.__cacheIndex
                  , ft = --this._nActiveControlInterpolants
                  , xt = lt[ft];
                tt.__cacheIndex = ft,
                lt[ft] = tt,
                xt.__cacheIndex = mt,
                lt[mt] = xt
            }
            clipAction(tt, lt, mt) {
                const ft = lt || this._root
                  , xt = ft.uuid;
                let Ct = typeof tt == "string" ? L_.findByName(ft, tt) : tt;
                const Mt = Ct !== null ? Ct.uuid : tt
                  , Lt = this._actionsByClip[Mt];
                let Nt = null;
                if (mt === void 0 && (mt = Ct !== null ? Ct.blendMode : Hm),
                Lt !== void 0) {
                    const Wt = Lt.actionByRoot[xt];
                    if (Wt !== void 0 && Wt.blendMode === mt)
                        return Wt;
                    Nt = Lt.knownActions[0],
                    Ct === null && (Ct = Nt._clip)
                }
                if (Ct === null)
                    return null;
                const jt = new $A(this,Ct,lt,mt);
                return this._bindAction(jt, Nt),
                this._addInactiveAction(jt, Mt, xt),
                jt
            }
            existingAction(tt, lt) {
                const mt = lt || this._root
                  , ft = mt.uuid
                  , xt = typeof tt == "string" ? L_.findByName(mt, tt) : tt
                  , Ct = xt ? xt.uuid : tt
                  , Mt = this._actionsByClip[Ct];
                return Mt !== void 0 && Mt.actionByRoot[ft] || null
            }
            stopAllAction() {
                const tt = this._actions;
                for (let lt = this._nActiveActions - 1; lt >= 0; --lt)
                    tt[lt].stop();
                return this
            }
            update(tt) {
                tt *= this.timeScale;
                const lt = this._actions
                  , mt = this._nActiveActions
                  , ft = this.time += tt
                  , xt = Math.sign(tt)
                  , Ct = this._accuIndex ^= 1;
                for (let Nt = 0; Nt !== mt; ++Nt)
                    lt[Nt]._update(ft, tt, xt, Ct);
                const Mt = this._bindings
                  , Lt = this._nActiveBindings;
                for (let Nt = 0; Nt !== Lt; ++Nt)
                    Mt[Nt].apply(Ct);
                return this
            }
            setTime(tt) {
                this.time = 0;
                for (let lt = 0; lt < this._actions.length; lt++)
                    this._actions[lt].time = 0;
                return this.update(tt)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(tt) {
                const lt = this._actions
                  , mt = tt.uuid
                  , ft = this._actionsByClip
                  , xt = ft[mt];
                if (xt !== void 0) {
                    const Ct = xt.knownActions;
                    for (let Mt = 0, Lt = Ct.length; Mt !== Lt; ++Mt) {
                        const Nt = Ct[Mt];
                        this._deactivateAction(Nt);
                        const jt = Nt._cacheIndex
                          , Wt = lt[lt.length - 1];
                        Nt._cacheIndex = null,
                        Nt._byClipCacheIndex = null,
                        Wt._cacheIndex = jt,
                        lt[jt] = Wt,
                        lt.pop(),
                        this._removeInactiveBindingsForAction(Nt)
                    }
                    delete ft[mt]
                }
            }
            uncacheRoot(tt) {
                const lt = tt.uuid
                  , mt = this._actionsByClip;
                for (const xt in mt) {
                    const Ct = mt[xt].actionByRoot[lt];
                    Ct !== void 0 && (this._deactivateAction(Ct),
                    this._removeInactiveAction(Ct))
                }
                const ft = this._bindingsByRootAndName[lt];
                if (ft !== void 0)
                    for (const xt in ft) {
                        const Ct = ft[xt];
                        Ct.restoreOriginalState(),
                        this._removeInactiveBinding(Ct)
                    }
            }
            uncacheAction(tt, lt) {
                const mt = this.existingAction(tt, lt);
                mt !== null && (this._deactivateAction(mt),
                this._removeInactiveAction(mt))
            }
        }
        class Ty {
            constructor(tt) {
                this.value = tt
            }
            clone() {
                return new Ty(this.value.clone === void 0 ? this.value : this.value.clone())
            }
        }
        let YS = 0;
        class KS extends As {
            constructor() {
                super(),
                this.isUniformsGroup = !0,
                Object.defineProperty(this, "id", {
                    value: YS++
                }),
                this.name = "",
                this.usage = Nu,
                this.uniforms = []
            }
            add(tt) {
                return this.uniforms.push(tt),
                this
            }
            remove(tt) {
                const lt = this.uniforms.indexOf(tt);
                return lt !== -1 && this.uniforms.splice(lt, 1),
                this
            }
            setName(tt) {
                return this.name = tt,
                this
            }
            setUsage(tt) {
                return this.usage = tt,
                this
            }
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }),
                this
            }
            copy(tt) {
                this.name = tt.name,
                this.usage = tt.usage;
                const lt = tt.uniforms;
                this.uniforms.length = 0;
                for (let mt = 0, ft = lt.length; mt < ft; mt++)
                    this.uniforms.push(lt[mt].clone());
                return this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class JS extends Rv {
            constructor(tt, lt, mt=1) {
                super(tt, lt),
                this.isInstancedInterleavedBuffer = !0,
                this.meshPerAttribute = mt
            }
            copy(tt) {
                return super.copy(tt),
                this.meshPerAttribute = tt.meshPerAttribute,
                this
            }
            clone(tt) {
                const lt = super.clone(tt);
                return lt.meshPerAttribute = this.meshPerAttribute,
                lt
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.isInstancedInterleavedBuffer = !0,
                lt.meshPerAttribute = this.meshPerAttribute,
                lt
            }
        }
        class ZS {
            constructor(tt, lt, mt, ft, xt) {
                this.isGLBufferAttribute = !0,
                this.name = "",
                this.buffer = tt,
                this.type = lt,
                this.itemSize = mt,
                this.elementSize = ft,
                this.count = xt,
                this.version = 0
            }
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            setBuffer(tt) {
                return this.buffer = tt,
                this
            }
            setType(tt, lt) {
                return this.type = tt,
                this.elementSize = lt,
                this
            }
            setItemSize(tt) {
                return this.itemSize = tt,
                this
            }
            setCount(tt) {
                return this.count = tt,
                this
            }
        }
        class eE {
            constructor(tt, lt, mt=0, ft=1 / 0) {
                this.ray = new Qu(tt,lt),
                this.near = mt,
                this.far = ft,
                this.camera = null,
                this.layers = new um,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(tt, lt) {
                this.ray.set(tt, lt)
            }
            setFromCamera(tt, lt) {
                lt.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(lt.matrixWorld),
                this.ray.direction.set(tt.x, tt.y, .5).unproject(lt).sub(this.ray.origin).normalize(),
                this.camera = lt) : lt.isOrthographicCamera ? (this.ray.origin.set(tt.x, tt.y, (lt.near + lt.far) / (lt.near - lt.far)).unproject(lt),
                this.ray.direction.set(0, 0, -1).transformDirection(lt.matrixWorld),
                this.camera = lt) : console.error("THREE.Raycaster: Unsupported camera type: " + lt.type)
            }
            intersectObject(tt, lt=!0, mt=[]) {
                return Cy(tt, this, mt, lt),
                mt.sort(XA),
                mt
            }
            intersectObjects(tt, lt=!0, mt=[]) {
                for (let ft = 0, xt = tt.length; ft < xt; ft++)
                    Cy(tt[ft], this, mt, lt);
                return mt.sort(XA),
                mt
            }
        }
        function XA(Tt, tt) {
            return Tt.distance - tt.distance
        }
        function Cy(Tt, tt, lt, mt) {
            if (Tt.layers.test(tt.layers) && Tt.raycast(tt, lt),
            mt === !0) {
                const ft = Tt.children;
                for (let xt = 0, Ct = ft.length; xt < Ct; xt++)
                    Cy(ft[xt], tt, lt, !0)
            }
        }
        class tE {
            constructor(tt=1, lt=0, mt=0) {
                return this.radius = tt,
                this.phi = lt,
                this.theta = mt,
                this
            }
            set(tt, lt, mt) {
                return this.radius = tt,
                this.phi = lt,
                this.theta = mt,
                this
            }
            copy(tt) {
                return this.radius = tt.radius,
                this.phi = tt.phi,
                this.theta = tt.theta,
                this
            }
            makeSafe() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
                this
            }
            setFromVector3(tt) {
                return this.setFromCartesianCoords(tt.x, tt.y, tt.z)
            }
            setFromCartesianCoords(tt, lt, mt) {
                return this.radius = Math.sqrt(tt * tt + lt * lt + mt * mt),
                this.radius === 0 ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(tt, mt),
                this.phi = Math.acos(qo(lt / this.radius, -1, 1))),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class rE {
            constructor(tt=1, lt=0, mt=0) {
                return this.radius = tt,
                this.theta = lt,
                this.y = mt,
                this
            }
            set(tt, lt, mt) {
                return this.radius = tt,
                this.theta = lt,
                this.y = mt,
                this
            }
            copy(tt) {
                return this.radius = tt.radius,
                this.theta = tt.theta,
                this.y = tt.y,
                this
            }
            setFromVector3(tt) {
                return this.setFromCartesianCoords(tt.x, tt.y, tt.z)
            }
            setFromCartesianCoords(tt, lt, mt) {
                return this.radius = Math.sqrt(tt * tt + mt * mt),
                this.theta = Math.atan2(tt, mt),
                this.y = lt,
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const YA = new mn;
        class nE {
            constructor(tt=new mn(1 / 0,1 / 0), lt=new mn(-1 / 0,-1 / 0)) {
                this.isBox2 = !0,
                this.min = tt,
                this.max = lt
            }
            set(tt, lt) {
                return this.min.copy(tt),
                this.max.copy(lt),
                this
            }
            setFromPoints(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.length; lt < mt; lt++)
                    this.expandByPoint(tt[lt]);
                return this
            }
            setFromCenterAndSize(tt, lt) {
                const mt = YA.copy(lt).multiplyScalar(.5);
                return this.min.copy(tt).sub(mt),
                this.max.copy(tt).add(mt),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.min.copy(tt.min),
                this.max.copy(tt.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(tt) {
                return this.isEmpty() ? tt.set(0, 0) : tt.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(tt) {
                return this.isEmpty() ? tt.set(0, 0) : tt.subVectors(this.max, this.min)
            }
            expandByPoint(tt) {
                return this.min.min(tt),
                this.max.max(tt),
                this
            }
            expandByVector(tt) {
                return this.min.sub(tt),
                this.max.add(tt),
                this
            }
            expandByScalar(tt) {
                return this.min.addScalar(-tt),
                this.max.addScalar(tt),
                this
            }
            containsPoint(tt) {
                return !(tt.x < this.min.x || tt.x > this.max.x || tt.y < this.min.y || tt.y > this.max.y)
            }
            containsBox(tt) {
                return this.min.x <= tt.min.x && tt.max.x <= this.max.x && this.min.y <= tt.min.y && tt.max.y <= this.max.y
            }
            getParameter(tt, lt) {
                return lt.set((tt.x - this.min.x) / (this.max.x - this.min.x), (tt.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(tt) {
                return !(tt.max.x < this.min.x || tt.min.x > this.max.x || tt.max.y < this.min.y || tt.min.y > this.max.y)
            }
            clampPoint(tt, lt) {
                return lt.copy(tt).clamp(this.min, this.max)
            }
            distanceToPoint(tt) {
                return this.clampPoint(tt, YA).distanceTo(tt)
            }
            intersect(tt) {
                return this.min.max(tt.min),
                this.max.min(tt.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(tt) {
                return this.min.min(tt.min),
                this.max.max(tt.max),
                this
            }
            translate(tt) {
                return this.min.add(tt),
                this.max.add(tt),
                this
            }
            equals(tt) {
                return tt.min.equals(this.min) && tt.max.equals(this.max)
            }
        }
        const KA = new Er
          , u0 = new Er;
        class iE {
            constructor(tt=new Er, lt=new Er) {
                this.start = tt,
                this.end = lt
            }
            set(tt, lt) {
                return this.start.copy(tt),
                this.end.copy(lt),
                this
            }
            copy(tt) {
                return this.start.copy(tt.start),
                this.end.copy(tt.end),
                this
            }
            getCenter(tt) {
                return tt.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(tt) {
                return tt.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(tt, lt) {
                return this.delta(lt).multiplyScalar(tt).add(this.start)
            }
            closestPointToPointParameter(tt, lt) {
                KA.subVectors(tt, this.start),
                u0.subVectors(this.end, this.start);
                const mt = u0.dot(u0);
                let ft = u0.dot(KA) / mt;
                return lt && (ft = qo(ft, 0, 1)),
                ft
            }
            closestPointToPoint(tt, lt, mt) {
                const ft = this.closestPointToPointParameter(tt, lt);
                return this.delta(mt).multiplyScalar(ft).add(this.start)
            }
            applyMatrix4(tt) {
                return this.start.applyMatrix4(tt),
                this.end.applyMatrix4(tt),
                this
            }
            equals(tt) {
                return tt.start.equals(this.start) && tt.end.equals(this.end)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const JA = new Er;
        class oE extends Mo {
            constructor(tt, lt) {
                super(),
                this.light = tt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = lt,
                this.type = "SpotLightHelper";
                const mt = new bo
                  , ft = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (let Ct = 0, Mt = 1, Lt = 32; Ct < Lt; Ct++,
                Mt++) {
                    const Nt = Ct / Lt * Math.PI * 2
                      , jt = Mt / Lt * Math.PI * 2;
                    ft.push(Math.cos(Nt), Math.sin(Nt), 1, Math.cos(jt), Math.sin(jt), 1)
                }
                mt.setAttribute("position", new Fn(ft,3));
                const xt = new Gs({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new iu(mt,xt),
                this.add(this.cone),
                this.update()
            }
            dispose() {
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1);
                const tt = this.light.distance ? this.light.distance : 1e3
                  , lt = tt * Math.tan(this.light.angle);
                this.cone.scale.set(lt, lt, tt),
                JA.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(JA),
                this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }
        const np = new Er
          , d0 = new no
          , Py = new no;
        class sE extends iu {
            constructor(tt) {
                const lt = ZA(tt)
                  , mt = new bo
                  , ft = []
                  , xt = []
                  , Ct = new Gn(0,0,1)
                  , Mt = new Gn(0,1,0);
                for (let Lt = 0; Lt < lt.length; Lt++) {
                    const Nt = lt[Lt];
                    Nt.parent && Nt.parent.isBone && (ft.push(0, 0, 0),
                    ft.push(0, 0, 0),
                    xt.push(Ct.r, Ct.g, Ct.b),
                    xt.push(Mt.r, Mt.g, Mt.b))
                }
                mt.setAttribute("position", new Fn(ft,3)),
                mt.setAttribute("color", new Fn(xt,3)),
                super(mt, new Gs({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })),
                this.isSkeletonHelper = !0,
                this.type = "SkeletonHelper",
                this.root = tt,
                this.bones = lt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(tt) {
                const lt = this.bones
                  , mt = this.geometry
                  , ft = mt.getAttribute("position");
                Py.copy(this.root.matrixWorld).invert();
                for (let xt = 0, Ct = 0; xt < lt.length; xt++) {
                    const Mt = lt[xt];
                    Mt.parent && Mt.parent.isBone && (d0.multiplyMatrices(Py, Mt.matrixWorld),
                    np.setFromMatrixPosition(d0),
                    ft.setXYZ(Ct, np.x, np.y, np.z),
                    d0.multiplyMatrices(Py, Mt.parent.matrixWorld),
                    np.setFromMatrixPosition(d0),
                    ft.setXYZ(Ct + 1, np.x, np.y, np.z),
                    Ct += 2)
                }
                mt.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(tt)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function ZA(Tt) {
            const tt = [];
            Tt.isBone === !0 && tt.push(Tt);
            for (let lt = 0; lt < Tt.children.length; lt++)
                tt.push.apply(tt, ZA(Tt.children[lt]));
            return tt
        }
        class aE extends gs {
            constructor(tt, lt, mt) {
                super(new I_(lt,4,2), new nu({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                })),
                this.light = tt,
                this.color = mt,
                this.type = "PointLightHelper",
                this.matrix = this.light.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.update()
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }
        const lE = new Er
          , ew = new Gn
          , tw = new Gn;
        class cE extends Mo {
            constructor(tt, lt, mt) {
                super(),
                this.light = tt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = mt,
                this.type = "HemisphereLightHelper";
                const ft = new R_(lt);
                ft.rotateY(.5 * Math.PI),
                this.material = new nu({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }),
                this.color === void 0 && (this.material.vertexColors = !0);
                const xt = ft.getAttribute("position")
                  , Ct = new Float32Array(3 * xt.count);
                ft.setAttribute("color", new mr(Ct,3)),
                this.add(new gs(ft,this.material)),
                this.update()
            }
            dispose() {
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
            update() {
                const tt = this.children[0];
                if (this.color !== void 0)
                    this.material.color.set(this.color);
                else {
                    const lt = tt.geometry.getAttribute("color");
                    ew.copy(this.light.color),
                    tw.copy(this.light.groundColor);
                    for (let mt = 0, ft = lt.count; mt < ft; mt++) {
                        const xt = mt < ft / 2 ? ew : tw;
                        lt.setXYZ(mt, xt.r, xt.g, xt.b)
                    }
                    lt.needsUpdate = !0
                }
                this.light.updateWorldMatrix(!0, !1),
                tt.lookAt(lE.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }
        class uE extends iu {
            constructor(tt=10, lt=10, mt=4473924, ft=8947848) {
                mt = new Gn(mt),
                ft = new Gn(ft);
                const xt = lt / 2
                  , Ct = tt / lt
                  , Mt = tt / 2
                  , Lt = []
                  , Nt = [];
                for (let Wt = 0, Qt = 0, qt = -Mt; Wt <= lt; Wt++,
                qt += Ct) {
                    Lt.push(-Mt, 0, qt, Mt, 0, qt),
                    Lt.push(qt, 0, -Mt, qt, 0, Mt);
                    const Xt = Wt === xt ? mt : ft;
                    Xt.toArray(Nt, Qt),
                    Qt += 3,
                    Xt.toArray(Nt, Qt),
                    Qt += 3,
                    Xt.toArray(Nt, Qt),
                    Qt += 3,
                    Xt.toArray(Nt, Qt),
                    Qt += 3
                }
                const jt = new bo;
                jt.setAttribute("position", new Fn(Lt,3)),
                jt.setAttribute("color", new Fn(Nt,3)),
                super(jt, new Gs({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "GridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class dE extends iu {
            constructor(tt=10, lt=16, mt=8, ft=64, xt=4473924, Ct=8947848) {
                xt = new Gn(xt),
                Ct = new Gn(Ct);
                const Mt = []
                  , Lt = [];
                if (lt > 1)
                    for (let jt = 0; jt < lt; jt++) {
                        const Wt = jt / lt * (2 * Math.PI)
                          , Qt = Math.sin(Wt) * tt
                          , qt = Math.cos(Wt) * tt;
                        Mt.push(0, 0, 0),
                        Mt.push(Qt, 0, qt);
                        const Xt = 1 & jt ? xt : Ct;
                        Lt.push(Xt.r, Xt.g, Xt.b),
                        Lt.push(Xt.r, Xt.g, Xt.b)
                    }
                for (let jt = 0; jt < mt; jt++) {
                    const Wt = 1 & jt ? xt : Ct
                      , Qt = tt - tt / mt * jt;
                    for (let qt = 0; qt < ft; qt++) {
                        let Xt = qt / ft * (2 * Math.PI)
                          , Zt = Math.sin(Xt) * Qt
                          , Yt = Math.cos(Xt) * Qt;
                        Mt.push(Zt, 0, Yt),
                        Lt.push(Wt.r, Wt.g, Wt.b),
                        Xt = (qt + 1) / ft * (2 * Math.PI),
                        Zt = Math.sin(Xt) * Qt,
                        Yt = Math.cos(Xt) * Qt,
                        Mt.push(Zt, 0, Yt),
                        Lt.push(Wt.r, Wt.g, Wt.b)
                    }
                }
                const Nt = new bo;
                Nt.setAttribute("position", new Fn(Mt,3)),
                Nt.setAttribute("color", new Fn(Lt,3)),
                super(Nt, new Gs({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "PolarGridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        const rw = new Er
          , p0 = new Er
          , nw = new Er;
        class pE extends Mo {
            constructor(tt, lt, mt) {
                super(),
                this.light = tt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = mt,
                this.type = "DirectionalLightHelper",
                lt === void 0 && (lt = 1);
                let ft = new bo;
                ft.setAttribute("position", new Fn([-lt, lt, 0, lt, lt, 0, lt, -lt, 0, -lt, -lt, 0, -lt, lt, 0],3));
                const xt = new Gs({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new ep(ft,xt),
                this.add(this.lightPlane),
                ft = new bo,
                ft.setAttribute("position", new Fn([0, 0, 0, 0, 0, 1],3)),
                this.targetLine = new ep(ft,xt),
                this.add(this.targetLine),
                this.update()
            }
            dispose() {
                this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1),
                rw.setFromMatrixPosition(this.light.matrixWorld),
                p0.setFromMatrixPosition(this.light.target.matrixWorld),
                nw.subVectors(p0, rw),
                this.lightPlane.lookAt(p0),
                this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(p0),
                this.targetLine.scale.z = nw.length()
            }
        }
        const h0 = new Er
          , rs = new xv;
        class hE extends iu {
            constructor(tt) {
                const lt = new bo
                  , mt = new Gs({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1
                })
                  , ft = []
                  , xt = []
                  , Ct = {};
                function Mt(Xt, Zt) {
                    Lt(Xt),
                    Lt(Zt)
                }
                function Lt(Xt) {
                    ft.push(0, 0, 0),
                    xt.push(0, 0, 0),
                    Ct[Xt] === void 0 && (Ct[Xt] = []),
                    Ct[Xt].push(ft.length / 3 - 1)
                }
                Mt("n1", "n2"),
                Mt("n2", "n4"),
                Mt("n4", "n3"),
                Mt("n3", "n1"),
                Mt("f1", "f2"),
                Mt("f2", "f4"),
                Mt("f4", "f3"),
                Mt("f3", "f1"),
                Mt("n1", "f1"),
                Mt("n2", "f2"),
                Mt("n3", "f3"),
                Mt("n4", "f4"),
                Mt("p", "n1"),
                Mt("p", "n2"),
                Mt("p", "n3"),
                Mt("p", "n4"),
                Mt("u1", "u2"),
                Mt("u2", "u3"),
                Mt("u3", "u1"),
                Mt("c", "t"),
                Mt("p", "c"),
                Mt("cn1", "cn2"),
                Mt("cn3", "cn4"),
                Mt("cf1", "cf2"),
                Mt("cf3", "cf4"),
                lt.setAttribute("position", new Fn(ft,3)),
                lt.setAttribute("color", new Fn(xt,3)),
                super(lt, mt),
                this.type = "CameraHelper",
                this.camera = tt,
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.pointMap = Ct,
                this.update();
                const Nt = new Gn(16755200)
                  , jt = new Gn(16711680)
                  , Wt = new Gn(43775)
                  , Qt = new Gn(16777215)
                  , qt = new Gn(3355443);
                this.setColors(Nt, jt, Wt, Qt, qt)
            }
            setColors(tt, lt, mt, ft, xt) {
                const Ct = this.geometry.getAttribute("color");
                Ct.setXYZ(0, tt.r, tt.g, tt.b),
                Ct.setXYZ(1, tt.r, tt.g, tt.b),
                Ct.setXYZ(2, tt.r, tt.g, tt.b),
                Ct.setXYZ(3, tt.r, tt.g, tt.b),
                Ct.setXYZ(4, tt.r, tt.g, tt.b),
                Ct.setXYZ(5, tt.r, tt.g, tt.b),
                Ct.setXYZ(6, tt.r, tt.g, tt.b),
                Ct.setXYZ(7, tt.r, tt.g, tt.b),
                Ct.setXYZ(8, tt.r, tt.g, tt.b),
                Ct.setXYZ(9, tt.r, tt.g, tt.b),
                Ct.setXYZ(10, tt.r, tt.g, tt.b),
                Ct.setXYZ(11, tt.r, tt.g, tt.b),
                Ct.setXYZ(12, tt.r, tt.g, tt.b),
                Ct.setXYZ(13, tt.r, tt.g, tt.b),
                Ct.setXYZ(14, tt.r, tt.g, tt.b),
                Ct.setXYZ(15, tt.r, tt.g, tt.b),
                Ct.setXYZ(16, tt.r, tt.g, tt.b),
                Ct.setXYZ(17, tt.r, tt.g, tt.b),
                Ct.setXYZ(18, tt.r, tt.g, tt.b),
                Ct.setXYZ(19, tt.r, tt.g, tt.b),
                Ct.setXYZ(20, tt.r, tt.g, tt.b),
                Ct.setXYZ(21, tt.r, tt.g, tt.b),
                Ct.setXYZ(22, tt.r, tt.g, tt.b),
                Ct.setXYZ(23, tt.r, tt.g, tt.b),
                Ct.setXYZ(24, lt.r, lt.g, lt.b),
                Ct.setXYZ(25, lt.r, lt.g, lt.b),
                Ct.setXYZ(26, lt.r, lt.g, lt.b),
                Ct.setXYZ(27, lt.r, lt.g, lt.b),
                Ct.setXYZ(28, lt.r, lt.g, lt.b),
                Ct.setXYZ(29, lt.r, lt.g, lt.b),
                Ct.setXYZ(30, lt.r, lt.g, lt.b),
                Ct.setXYZ(31, lt.r, lt.g, lt.b),
                Ct.setXYZ(32, mt.r, mt.g, mt.b),
                Ct.setXYZ(33, mt.r, mt.g, mt.b),
                Ct.setXYZ(34, mt.r, mt.g, mt.b),
                Ct.setXYZ(35, mt.r, mt.g, mt.b),
                Ct.setXYZ(36, mt.r, mt.g, mt.b),
                Ct.setXYZ(37, mt.r, mt.g, mt.b),
                Ct.setXYZ(38, ft.r, ft.g, ft.b),
                Ct.setXYZ(39, ft.r, ft.g, ft.b),
                Ct.setXYZ(40, xt.r, xt.g, xt.b),
                Ct.setXYZ(41, xt.r, xt.g, xt.b),
                Ct.setXYZ(42, xt.r, xt.g, xt.b),
                Ct.setXYZ(43, xt.r, xt.g, xt.b),
                Ct.setXYZ(44, xt.r, xt.g, xt.b),
                Ct.setXYZ(45, xt.r, xt.g, xt.b),
                Ct.setXYZ(46, xt.r, xt.g, xt.b),
                Ct.setXYZ(47, xt.r, xt.g, xt.b),
                Ct.setXYZ(48, xt.r, xt.g, xt.b),
                Ct.setXYZ(49, xt.r, xt.g, xt.b),
                Ct.needsUpdate = !0
            }
            update() {
                const tt = this.geometry
                  , lt = this.pointMap;
                rs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                os("c", lt, tt, rs, 0, 0, -1),
                os("t", lt, tt, rs, 0, 0, 1),
                os("n1", lt, tt, rs, -1, -1, -1),
                os("n2", lt, tt, rs, 1, -1, -1),
                os("n3", lt, tt, rs, -1, 1, -1),
                os("n4", lt, tt, rs, 1, 1, -1),
                os("f1", lt, tt, rs, -1, -1, 1),
                os("f2", lt, tt, rs, 1, -1, 1),
                os("f3", lt, tt, rs, -1, 1, 1),
                os("f4", lt, tt, rs, 1, 1, 1),
                os("u1", lt, tt, rs, .7, 1.1, -1),
                os("u2", lt, tt, rs, -.7, 1.1, -1),
                os("u3", lt, tt, rs, 0, 2, -1),
                os("cf1", lt, tt, rs, -1, 0, 1),
                os("cf2", lt, tt, rs, 1, 0, 1),
                os("cf3", lt, tt, rs, 0, -1, 1),
                os("cf4", lt, tt, rs, 0, 1, 1),
                os("cn1", lt, tt, rs, -1, 0, -1),
                os("cn2", lt, tt, rs, 1, 0, -1),
                os("cn3", lt, tt, rs, 0, -1, -1),
                os("cn4", lt, tt, rs, 0, 1, -1),
                tt.getAttribute("position").needsUpdate = !0
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function os(Tt, tt, lt, mt, ft, xt, Ct) {
            h0.set(ft, xt, Ct).unproject(mt);
            const Mt = tt[Tt];
            if (Mt !== void 0) {
                const Lt = lt.getAttribute("position");
                for (let Nt = 0, jt = Mt.length; Nt < jt; Nt++)
                    Lt.setXYZ(Mt[Nt], h0.x, h0.y, h0.z)
            }
        }
        const m0 = new Tl;
        class mE extends iu {
            constructor(tt, lt=16776960) {
                const mt = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , ft = new Float32Array(24)
                  , xt = new bo;
                xt.setIndex(new mr(mt,1)),
                xt.setAttribute("position", new mr(ft,3)),
                super(xt, new Gs({
                    color: lt,
                    toneMapped: !1
                })),
                this.object = tt,
                this.type = "BoxHelper",
                this.matrixAutoUpdate = !1,
                this.update()
            }
            update(tt) {
                if (tt !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
                this.object !== void 0 && m0.setFromObject(this.object),
                m0.isEmpty())
                    return;
                const lt = m0.min
                  , mt = m0.max
                  , ft = this.geometry.attributes.position
                  , xt = ft.array;
                xt[0] = mt.x,
                xt[1] = mt.y,
                xt[2] = mt.z,
                xt[3] = lt.x,
                xt[4] = mt.y,
                xt[5] = mt.z,
                xt[6] = lt.x,
                xt[7] = lt.y,
                xt[8] = mt.z,
                xt[9] = mt.x,
                xt[10] = lt.y,
                xt[11] = mt.z,
                xt[12] = mt.x,
                xt[13] = mt.y,
                xt[14] = lt.z,
                xt[15] = lt.x,
                xt[16] = mt.y,
                xt[17] = lt.z,
                xt[18] = lt.x,
                xt[19] = lt.y,
                xt[20] = lt.z,
                xt[21] = mt.x,
                xt[22] = lt.y,
                xt[23] = lt.z,
                ft.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
            setFromObject(tt) {
                return this.object = tt,
                this.update(),
                this
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.object = tt.object,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class fE extends iu {
            constructor(tt, lt=16776960) {
                const mt = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , ft = new bo;
                ft.setIndex(new mr(mt,1)),
                ft.setAttribute("position", new Fn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
                super(ft, new Gs({
                    color: lt,
                    toneMapped: !1
                })),
                this.box = tt,
                this.type = "Box3Helper",
                this.geometry.computeBoundingSphere()
            }
            updateMatrixWorld(tt) {
                const lt = this.box;
                lt.isEmpty() || (lt.getCenter(this.position),
                lt.getSize(this.scale),
                this.scale.multiplyScalar(.5),
                super.updateMatrixWorld(tt))
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class gE extends ep {
            constructor(tt, lt=1, mt=16776960) {
                const ft = mt
                  , xt = new bo;
                xt.setAttribute("position", new Fn([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
                xt.computeBoundingSphere(),
                super(xt, new Gs({
                    color: ft,
                    toneMapped: !1
                })),
                this.type = "PlaneHelper",
                this.plane = tt,
                this.size = lt;
                const Ct = new bo;
                Ct.setAttribute("position", new Fn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
                Ct.computeBoundingSphere(),
                this.add(new gs(Ct,new nu({
                    color: ft,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }
            updateMatrixWorld(tt) {
                this.position.set(0, 0, 0),
                this.scale.set(.5 * this.size, .5 * this.size, 1),
                this.lookAt(this.plane.normal),
                this.translateZ(-this.plane.constant),
                super.updateMatrixWorld(tt)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose(),
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
        }
        const iw = new Er;
        let f0, My;
        class _E extends Mo {
            constructor(tt=new Er(0,0,1), lt=new Er(0,0,0), mt=1, ft=16776960, xt=.2 * mt, Ct=.2 * xt) {
                super(),
                this.type = "ArrowHelper",
                f0 === void 0 && (f0 = new bo,
                f0.setAttribute("position", new Fn([0, 0, 0, 0, 1, 0],3)),
                My = new Im(0,.5,1,5,1),
                My.translate(0, -.5, 0)),
                this.position.copy(lt),
                this.line = new ep(f0,new Gs({
                    color: ft,
                    toneMapped: !1
                })),
                this.line.matrixAutoUpdate = !1,
                this.add(this.line),
                this.cone = new gs(My,new nu({
                    color: ft,
                    toneMapped: !1
                })),
                this.cone.matrixAutoUpdate = !1,
                this.add(this.cone),
                this.setDirection(tt),
                this.setLength(mt, xt, Ct)
            }
            setDirection(tt) {
                if (tt.y > .99999)
                    this.quaternion.set(0, 0, 0, 1);
                else if (tt.y < -.99999)
                    this.quaternion.set(1, 0, 0, 0);
                else {
                    iw.set(tt.z, 0, -tt.x).normalize();
                    const lt = Math.acos(tt.y);
                    this.quaternion.setFromAxisAngle(iw, lt)
                }
            }
            setLength(tt, lt=.2 * tt, mt=.2 * lt) {
                this.line.scale.set(1, Math.max(1e-4, tt - lt), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(mt, lt, mt),
                this.cone.position.y = tt,
                this.cone.updateMatrix()
            }
            setColor(tt) {
                this.line.material.color.set(tt),
                this.cone.material.color.set(tt)
            }
            copy(tt) {
                return super.copy(tt, !1),
                this.line.copy(tt.line),
                this.cone.copy(tt.cone),
                this
            }
            dispose() {
                this.line.geometry.dispose(),
                this.line.material.dispose(),
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
        }
        class vE extends iu {
            constructor(tt=1) {
                const lt = [0, 0, 0, tt, 0, 0, 0, 0, 0, 0, tt, 0, 0, 0, 0, 0, 0, tt]
                  , mt = new bo;
                mt.setAttribute("position", new Fn(lt,3)),
                mt.setAttribute("color", new Fn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
                super(mt, new Gs({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "AxesHelper"
            }
            setColors(tt, lt, mt) {
                const ft = new Gn
                  , xt = this.geometry.attributes.color.array;
                return ft.set(tt),
                ft.toArray(xt, 0),
                ft.toArray(xt, 3),
                ft.set(lt),
                ft.toArray(xt, 6),
                ft.toArray(xt, 9),
                ft.set(mt),
                ft.toArray(xt, 12),
                ft.toArray(xt, 15),
                this.geometry.attributes.color.needsUpdate = !0,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class yE {
            constructor() {
                this.type = "ShapePath",
                this.color = new Gn,
                this.subPaths = [],
                this.currentPath = null
            }
            moveTo(tt, lt) {
                return this.currentPath = new E_,
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(tt, lt),
                this
            }
            lineTo(tt, lt) {
                return this.currentPath.lineTo(tt, lt),
                this
            }
            quadraticCurveTo(tt, lt, mt, ft) {
                return this.currentPath.quadraticCurveTo(tt, lt, mt, ft),
                this
            }
            bezierCurveTo(tt, lt, mt, ft, xt, Ct) {
                return this.currentPath.bezierCurveTo(tt, lt, mt, ft, xt, Ct),
                this
            }
            splineThru(tt) {
                return this.currentPath.splineThru(tt),
                this
            }
            toShapes(tt) {
                function lt(Yt, sr) {
                    const er = sr.length;
                    let rr = !1;
                    for (let xr = er - 1, br = 0; br < er; xr = br++) {
                        let yr = sr[xr]
                          , Pr = sr[br]
                          , zr = Pr.x - yr.x
                          , Nr = Pr.y - yr.y;
                        if (Math.abs(Nr) > Number.EPSILON) {
                            if (Nr < 0 && (yr = sr[br],
                            zr = -zr,
                            Pr = sr[xr],
                            Nr = -Nr),
                            Yt.y < yr.y || Yt.y > Pr.y)
                                continue;
                            if (Yt.y === yr.y) {
                                if (Yt.x === yr.x)
                                    return !0
                            } else {
                                const Vr = Nr * (Yt.x - yr.x) - zr * (Yt.y - yr.y);
                                if (Vr === 0)
                                    return !0;
                                if (Vr < 0)
                                    continue;
                                rr = !rr
                            }
                        } else {
                            if (Yt.y !== yr.y)
                                continue;
                            if (Pr.x <= Yt.x && Yt.x <= yr.x || yr.x <= Yt.x && Yt.x <= Pr.x)
                                return !0
                        }
                    }
                    return rr
                }
                const mt = ou.isClockWise
                  , ft = this.subPaths;
                if (ft.length === 0)
                    return [];
                let xt, Ct, Mt;
                const Lt = [];
                if (ft.length === 1)
                    return Ct = ft[0],
                    Mt = new Pp,
                    Mt.curves = Ct.curves,
                    Lt.push(Mt),
                    Lt;
                let Nt = !mt(ft[0].getPoints());
                Nt = tt ? !Nt : Nt;
                const jt = []
                  , Wt = [];
                let Qt, qt, Xt = [], Zt = 0;
                Wt[Zt] = void 0,
                Xt[Zt] = [];
                for (let Yt = 0, sr = ft.length; Yt < sr; Yt++)
                    Ct = ft[Yt],
                    Qt = Ct.getPoints(),
                    xt = mt(Qt),
                    xt = tt ? !xt : xt,
                    xt ? (!Nt && Wt[Zt] && Zt++,
                    Wt[Zt] = {
                        s: new Pp,
                        p: Qt
                    },
                    Wt[Zt].s.curves = Ct.curves,
                    Nt && Zt++,
                    Xt[Zt] = []) : Xt[Zt].push({
                        h: Ct,
                        p: Qt[0]
                    });
                if (!Wt[0])
                    return function(Yt) {
                        const sr = [];
                        for (let er = 0, rr = Yt.length; er < rr; er++) {
                            const xr = Yt[er]
                              , br = new Pp;
                            br.curves = xr.curves,
                            sr.push(br)
                        }
                        return sr
                    }(ft);
                if (Wt.length > 1) {
                    let Yt = !1
                      , sr = 0;
                    for (let er = 0, rr = Wt.length; er < rr; er++)
                        jt[er] = [];
                    for (let er = 0, rr = Wt.length; er < rr; er++) {
                        const xr = Xt[er];
                        for (let br = 0; br < xr.length; br++) {
                            const yr = xr[br];
                            let Pr = !0;
                            for (let zr = 0; zr < Wt.length; zr++)
                                lt(yr.p, Wt[zr].p) && (er !== zr && sr++,
                                Pr ? (Pr = !1,
                                jt[zr].push(yr)) : Yt = !0);
                            Pr && jt[er].push(yr)
                        }
                    }
                    sr > 0 && Yt === !1 && (Xt = jt)
                }
                for (let Yt = 0, sr = Wt.length; Yt < sr; Yt++) {
                    Mt = Wt[Yt].s,
                    Lt.push(Mt),
                    qt = Xt[Yt];
                    for (let er = 0, rr = qt.length; er < rr; er++)
                        Mt.holes.push(qt[er].h)
                }
                return Lt
            }
        }
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: h
            }
        })),
        typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = h)
}

export default module848;
