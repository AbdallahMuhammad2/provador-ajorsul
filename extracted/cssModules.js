/* CSSMODULES */
/* CSS webpack modules */
/* Lines: 34-42211 */
/* Size: 1807963 characters */

var __webpackgi_modules__ = {
    774: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, '.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(0.54, 1.5, 0.38, 1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:rgba(0,0,0,0);border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}', ""]),
        o.A = _
    },
    611: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, ".loader{width:48px;height:48px;border:5px solid #333;border-bottom-color:rgba(0,0,0,0);border-radius:50%;display:inline-block;box-sizing:border-box;animation:rotation 1s linear infinite}@keyframes rotation{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}", ""]),
        o.A = _
    },
    223: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, "#assetManagerLoadingBar{z-index:400;position:absolute;top:0;left:0;right:0;width:100%;background-color:rgba(0,0,0,0);height:auto}#assetManagerLoadingBarContent{color:#fff;position:absolute;left:0;right:0;margin:auto;transition:width .5s;background-color:rgba(34,34,34,.6666666667);text-align:center;font-size:.5rem;line-height:.6rem;height:.6rem;border-radius:0 0 .125rem .125rem;border-bottom:#999 1px solid}.processState{font-weight:bold}", ""]),
        o.A = _
    },
    646: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, '#assetManagerLoadingScreen{z-index:300;position:absolute;bottom:0;right:0;min-width:100%;min-height:100%;color:#333;font-size:1rem;gap:1rem;display:flex;align-content:center;justify-content:center;align-items:center;flex-direction:column;opacity:1;transition:opacity .5s ease-in-out,min-width .5s,min-height .5s,bottom .5s,right .5s;overflow:hidden;background:rgba(0,0,0,0);-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);background-blend-mode:luminosity;--b-opacity: 0.8;--b-background: #ffffff}#assetManagerLoadingScreen::before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;z-index:-1;opacity:var(--b-opacity);background:var(--b-background)}#assetManagerLoadingScreenContent{padding-top:.5rem}.loadingScreenProcessState{font-weight:bold}#assetManagerLoadingScreen.minimizedLoadingScreen{top:unset;left:unset;bottom:2rem;right:2rem;min-width:0;min-height:0;max-width:80vw;max-height:80vh;width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content;padding:1.5rem;border-radius:.5rem}.loadingScreenFilesElement{min-height:4rem;padding:1rem}.loadingScreenLogoElement{margin-bottom:.5rem;max-width:80%}.loadingScreenLogoElement img{min-height:3rem;max-height:5rem;max-width:100%;-o-object-fit:contain;object-fit:contain}.loadingScreenLogoImage{width:-moz-max-content;width:max-content;height:-moz-max-content;height:max-content}.minimizedLoadingScreen .loadingScreenLoadingElement{display:none}.minimizedLoadingScreen .loadingScreenFilesElement{min-height:0}.minimizedLoadingScreen .loadingScreenLogoElement{min-height:0;display:none}.minimizedLoadingScreen #assetManagerLoadingScreenContent{display:none}', ""]),
        o.A = _
    },
    636: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, "#assetManagerPopup{z-index:300;position:absolute;bottom:2rem;right:2rem;color:#fff;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);background-blend-mode:luminosity;background-color:rgba(40,34,60,.6666666667);padding:1.5rem;font-size:1rem;width:-moz-max-content;width:max-content;max-width:80vw;max-height:80vh;overflow-y:scroll;border-radius:.5rem;height:-moz-max-content;height:max-content}#assetManagerPopupClose{position:absolute;top:0;right:0;padding:.5rem;cursor:pointer}#assetManagerPopupContent{padding-top:.5rem}.processState{font-weight:bold}", ""]),
        o.A = _
    },
    757: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, '.button-bar{background:var(--tp-base-background-color);width:fit-content;width:-moz-fit-content;height:auto;display:flex;flex-direction:row;justify-content:center;flex-wrap:wrap;z-index:200;padding:.25rem .5rem .5rem;border-radius:.5rem;pointer-events:auto;box-shadow:0 2px 4px var(--tp-base-shadow-color);gap:8px;font-size:.85rem;line-height:130%;font-family:Inter,"Roboto Mono","Source Code Pro",Menlo,Courier,monospace;opacity:1;transition:all .25s}.button-bar-button{background-color:rgba(0,0,0,0);cursor:pointer;width:auto;height:auto;font-weight:500;padding:.35rem .5rem;position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;color:var(--tp-input-foreground-color, #cccccc);transition:color .25s}.button-bar-button:hover{color:var(--tp-label-foreground-color, #eeeeee)}.button-bar-selected{color:var(--tp-label-foreground-color, #eeeeee)}.button-bar-selected-box{color:var(--tp-label-foreground-color, #eeeeee)}.button-bar>.button-bar-button:not(:last-child)::after{content:"";position:absolute;right:-5px;top:20%;width:2px;height:60%;border-radius:1px;background-color:var(--tp-container-background-color-active, #413762)}.button-bar-button:before{left:50%;width:0;content:"";position:absolute}.button-bar-selected:before{left:25%;width:50%;bottom:0;height:2px;border-radius:1px;background-color:var(--tp-container-foreground-color, #cccccc);transition:width .25s,left .25s}.button-bar-selected-box{background-color:rgba(238,238,238,.3333333333);border-radius:.25rem;transition:all .25s}.round-button{width:1rem;height:1rem;padding:.6rem;background-color:var(--tp-base-background-color);border-radius:1.2rem;color:#ccc;cursor:pointer;box-shadow:0 2px 4px var(--tp-base-shadow-color);transition:all .25s;box-sizing:content-box !important}.round-button:hover{color:#fff}.util-buttons-container{bottom:1.25rem;right:1.25rem;position:absolute;gap:8px;padding:.25rem}.util-button{position:relative;width:auto;height:1.2rem;aspect-ratio:1;box-sizing:content-box !important}.mode-buttons-container{border-top:0;top:0;left:0;right:0;margin-left:auto;margin-right:auto;position:absolute;min-width:6rem;border-radius:0 0 .5rem .5rem;gap:8px;flex-wrap:nowrap !important;overflow-x:scroll;pointer-events:auto;max-width:100%;align-content:center;justify-content:flex-start;align-items:center;box-sizing:border-box}.mode-buttons-container::-webkit-scrollbar{display:none}.mode-buttons-container{-ms-overflow-style:none;scrollbar-width:none}.mode-button{font-weight:500}#webgi-logo{background-image:url("https://static.webgi.xyz/logo.svg");background-size:contain;background-repeat:no-repeat;background-position:center;bottom:1.25rem;left:1rem;z-index:100;width:7.5rem;height:2.5rem;position:absolute;cursor:pointer}#webgi-logo:hover{filter:grayscale(100%)}#fsToggle{position:absolute;right:1.25rem;top:1.25rem;color:var(--tp-container-foreground-color, #dddddd)}#assetManagerPopup{position:absolute;margin:auto;left:0;right:0;top:0;bottom:0;color:#fff;padding:1.5rem;font-size:.85rem;overflow-y:scroll;background-color:var(--tp-base-background-color)}::-webkit-scrollbar{width:8px;height:8px}::-webkit-scrollbar-track{background:rgba(40,34,60,.8) !important;border-radius:6px}::-webkit-scrollbar-thumb{background:hsla(0,0%,100%,.4);border-radius:6px}::-webkit-scrollbar-corner{background:rgba(0,0,0,.5)}.tippy-box[data-theme~=editor]{margin:.25rem !important;background-color:var(--tp-base-background-color) !important;font-size:.9rem !important;color:var(--tp-container-foreground-color, #dddddd) !important}#tweakpaneUiContainer{margin-top:4.5rem}#canvasContainer{display:flex;justify-content:center;align-items:center}@media only screen and (min-width: 920px){#canvasContainer{width:calc(min(100% - 3rem,100% - var(--tweakpane-ui-container-width, 300px)) - 3.5rem) !important;height:calc(100% - 5rem);margin:3.5rem 1.5rem 1.5rem 1.5rem;border-radius:.5rem;box-shadow:rgba(0,0,0,.25) 0px 25px 50px -12px}#mcanvas{border-radius:.5rem}#tweakpaneUiContainer{margin-top:3.5rem}}body{transition:background-color .5s ease;background-color:#d1d4e7}body.tpTheme-blue{background-color:#d1d4e7}body.tpTheme-white{background-color:#dcdcdc}body.tpTheme-black{background-color:#48495d}', ""]),
        o.A = _
    },
    367: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, ':root{--tp-blade-unit-size: 26px;--tp-font-family: "Inter";--tp-element-border-radius: 0.25rem}:root{--tp-base-background-color: #0e0e0e;--tp-container-background-color: rgba(32, 32, 32, 0.2);--tp-container-background-color-hover: rgba(32, 32, 32, 0.3);--tp-container-background-color-active: rgba(50, 50, 50, 0.8);--tp-container-background-color-focus: rgba(50, 50, 50, 1.0);--tp-container-foreground-color: hsla(0, 0%, 90%, 0.90);--tp-label-foreground-color: hsla(0, 0%, 85%, 0.90)}:root .tpTheme-blue{--tp-base-background-color: #28223C;--tp-base-shadow-color: hsla(0, 0%, 0%, 0.2);--tp-button-background-color: hsla(230, 10%, 80%, 1.00);--tp-button-background-color-active: hsla(230, 10%, 95%, 1.00);--tp-button-background-color-focus: hsla(230, 10%, 90%, 1.00);--tp-button-background-color-hover: hsla(230, 10%, 85%, 1.00);--tp-button-foreground-color: hsla(230, 20%, 11%, 1.00);--tp-container-background-color: hsla(230, 25%, 16%, 0.65);--tp-container-background-color-active: hsla(230, 25%, 36%, 0.65);--tp-container-background-color-focus: hsla(230, 25%, 26%, 0.65);--tp-container-background-color-hover: hsla(230, 25%, 21%, 0.65);--tp-container-foreground-color: hsl(240, 10%, 92%);--tp-groove-foreground-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color: hsla(230, 20%, 8%, 1.00);--tp-input-background-color-active: hsla(230, 28%, 23%, 1.00);--tp-input-background-color-focus: hsla(230, 28%, 18%, 1.00);--tp-input-background-color-hover: hsla(230, 20%, 13%, 1.00);--tp-input-foreground-color: hsla(230, 10%, 80%, 1.00);--tp-monitor-background-color: hsla(230, 20%, 8%, 1.00);--tp-monitor-foreground-color: hsla(230, 12%, 48%, 1.00);--tp-label-foreground-color: #E4E2ED}:root .tpTheme-white{--tp-base-background-color: hsla(230, 5%, 90%, 1.00);--tp-base-shadow-color: hsla(0, 0%, 0%, 0.10);--tp-button-background-color: hsla(230, 7%, 85%, 1.00);--tp-button-background-color-active: hsla(230, 7%, 70%, 1.00);--tp-button-background-color-focus: hsla(230, 7%, 75%, 1.00);--tp-button-background-color-hover: hsla(230, 7%, 80%, 1.00);--tp-button-foreground-color: hsla(230, 10%, 30%, 1.00);--tp-container-background-color: hsla(230, 15%, 80%, 0.10);--tp-container-background-color-active: hsla(230, 15%, 70%, 0.32);--tp-container-background-color-focus: hsla(230, 15%, 70%, 0.28);--tp-container-background-color-hover: hsla(230, 15%, 70%, 0.24);--tp-container-foreground-color: hsla(230, 10%, 30%, 1.00);--tp-groove-foreground-color: hsla(230, 15%, 20%, 0.10);--tp-input-background-color: hsla(230, 15%, 30%, 0.10);--tp-input-background-color-active: hsla(230, 15%, 50%, 0.22);--tp-input-background-color-focus: hsla(230, 15%, 50%, 0.18);--tp-input-background-color-hover: hsla(230, 15%, 50%, 0.14);--tp-input-foreground-color: hsla(230, 10%, 20%, 1.00);--tp-label-foreground-color: hsla(230, 10%, 10%, 1.00);--tp-monitor-background-color: hsla(230, 15%, 30%, 0.10);--tp-monitor-foreground-color: hsla(230, 10%, 30%, 0.50)}.tp-fldv{margin-top:.25rem;margin-bottom:.25rem;background-blend-mode:luminosity;position:relative}.tp-fldv .tp-fldv{margin-top:.5rem;margin-bottom:.5rem}.tp-fldv_b{height:calc(var(--bld-us)*1.5 + 4px) !important;font-size:.9rem !important;transition:background-color .5s ease}.tp-fldv_b+.tp-brkv .tp-fldv_b{height:calc(var(--bld-us)*1.1 + 4px) !important;font-size:.7rem !important}.tp-lblv_l{font-size:.75rem !important;font-weight:500 !important;flex-grow:1 !important;flex-basis:20% !important}.tp-lblv_v{flex-grow:1 !important;flex-basis:50% !important}.tp-txtv_i{font-size:.75rem !important;font-weight:500 !important}.tp-fldv_t{font-weight:500 !important;padding-left:1.5rem !important}.tp-fldv_m{right:auto !important;left:.75rem;opacity:1 !important}.pluginOptionsButton{position:absolute;right:0;top:.75rem;padding-left:.5rem;padding-right:.5rem;height:-moz-min-content;height:min-content;background:rgba(0,0,0,0);color:var(--tp-container-foreground-color, #eeeeee);font-size:.9rem;border:none}.tp-sldv_k::after{background-color:var(--tp-input-foreground-color, hsl(230, 7%, 75%))}.tp-btnv_b{height:calc(var(--tp-blade-unit-size)*1.15)}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{font-weight:500 !important}.tp-rotv{font-size:13px !important}', ""]),
        o.A = _
    },
    160: function(d, o, c) {
        var h = c(364)
          , _ = c.n(h)()(function(b) {
            return b[1]
        });
        _.push([d.id, ".wwise-perspective{perspective:1000px;position:fixed;left:0;top:0;width:100vw;height:100vh}.wwise-wrapper{position:fixed;width:0;height:0;font-weight:400}.wwise-wrapper.v-center{top:50%}.wwise-wrapper.h-center{left:50%}.wwise-wrapper.left{left:0}.wwise-wrapper.right{right:0}.wwise-wrapper.top{top:0}.wwise-wrapper.bottom{bottom:0}.wwise *.preset{color:#fafafa}.wwise *.preset.ok{background:rgba(45,193,80,.95)}.wwise *.preset.error{background:rgba(190,17,51,.95)}.wwise *.preset.info{background:rgba(40,34,60,.95)}.wwise *.preset.caution{background:rgba(239,128,0,.95)}.wwise-no-scroll{position:relative;overflow:hidden}.wwise-overlay{position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(50,50,50,.5)}.wwise{position:absolute;left:0;top:0;display:flex;flex-direction:column;border-radius:5px;box-shadow:1px 1px 10px rgba(150,150,150,.5);box-sizing:border-box}.wwise.no-radius{border-radius:0}.wwise *{box-sizing:border-box}.wwise .clear{clear:both}.wwise>.content{padding:0;margin:0;flex-grow:1;border-radius:0 0 4px 4px;background:#fff;color:#333;box-shadow:0 1px 3px rgba(200,200,200,.5) inset}.wwise>.content.no-topbar{border-radius:4px;box-shadow:none}.wwise.no-radius>.content,.wwise.no-radius>.content.no-topbar{border-radius:0}.wwise .modal>.main{width:90vw;max-width:400px;border-radius:4px 4px 0 0;text-align:center;padding-bottom:10px;color:#fff}.wwise .modal>.main .icon{display:block;margin:0 auto;fill:#fff;width:100px}.wwise .modal>.main .title{font-size:30px}.wwise .modal>.main .text{margin:10px 0;font-weight:300;font-size:16px}.wwise .modal>.main.no-op{border-radius:4px}.wwise .modal>.main.ok{background:#2dc150}.wwise .modal>.main.error{background:#be1133}.wwise .modal>.main.info{background:#28223c}.wwise .modal>.main.caution{background:#ef8000}.wwise .modal>.operation .button-wrapper{text-align:center;margin:30px 0 20px 0}.wwise .modal>.operation .button{display:inline-block;line-height:18px;padding:8px 10px;margin:0 15px;line-height:18px;width:100px;border-radius:4px;border:1px solid #eee;box-shadow:1px 1px 3px rgba(220,220,220,.8);color:#555;transition:all ease .2s}.wwise .modal>.operation .button:hover{background:#f5f5f5;cursor:pointer}.wwise .modal>.operation .button.main{color:#fff}.wwise .modal>.operation.ok .main{background:#2dc150}.wwise .modal>.operation.ok .main:hover{background:rgb(35.3571428571,151.6428571429,62.8571428571)}.wwise .modal>.operation.error .main{background:#be1133}.wwise .modal>.operation.error .main:hover{background:rgb(143.1884057971,12.8115942029,38.4347826087)}.wwise .modal>.operation.info .main{background:#28223c}.wwise .modal>.operation.info .main:hover{background:rgb(18.2978723404,15.5531914894,27.4468085106)}.wwise .modal>.operation.caution .main{background:#ef8000}.wwise .modal>.operation.caution .main:hover{background:rgb(188,100.6861924686,0)}.wwise .input-wrapper{margin:15px auto -15px auto}.wwise .input-wrapper .input{display:block;margin:0 auto;width:95%;max-width:300px;outline:none;border:none;background:#f3f3f3;padding:15px;font-size:16px;border-radius:5px}.wwise .input-wrapper .error{width:95%;text-align:center;margin-top:10px;color:red}div:has(>.wwise-wrapper){position:absolute !important}.wwise-wrapper{position:absolute !important}.wwise .modal>.main{padding-top:10px}", ""]),
        o.A = _
    },
    333: function(d) {
        var o;
        o = function() {
            return function(c) {
                var h = {};
                function _(b) {
                    if (h[b])
                        return h[b].exports;
                    var _e = h[b] = {
                        i: b,
                        l: !1,
                        exports: {}
                    };
                    return c[b].call(_e.exports, _e, _e.exports, _),
                    _e.l = !0,
                    _e.exports
                }
                return _.m = c,
                _.c = h,
                _.i = function(b) {
                    return b
                }
                ,
                _.d = function(b, _e, nt) {
                    _.o(b, _e) || Object.defineProperty(b, _e, {
                        configurable: !1,
                        enumerable: !0,
                        get: nt
                    })
                }
                ,
                _.n = function(b) {
                    var _e = b && b.__esModule ? function() {
                        return b.default
                    }
                    : function() {
                        return b
                    }
                    ;
                    return _.d(_e, "a", _e),
                    _e
                }
                ,
                _.o = function(b, _e) {
                    return Object.prototype.hasOwnProperty.call(b, _e)
                }
                ,
                _.p = "",
                _(_.s = 5)
            }([function(c, h, _) {
                Object.defineProperty(h, "__esModule", {
                    value: !0
                });
                var b = {
                    convertToObject: function(_e) {
                        var nt = _e.substring(_e.indexOf("{") + 1).trim().slice(0, -1)
                          , it = {};
                        return nt.split(";").map(function(at) {
                            if (at = at.trim()) {
                                var ut = at.split(":");
                                it[ut[0].trim()] = ut[1].trim()
                            }
                        }),
                        it
                    },
                    getFromSheets: function(_e) {
                        var nt = document.styleSheets;
                        for (var it in nt) {
                            var at = null;
                            try {
                                at = nt[it].rules || nt[it].cssRules
                            } catch {}
                            if (at) {
                                for (var ut in at)
                                    if (at[ut].selectorText && at[ut].selectorText.split(",").indexOf(_e) != -1)
                                        return at[ut].cssText ? b.convertToObject(at[ut].cssText) : b.convertToObject(at[ut].style.cssText)
                            }
                        }
                        return {}
                    },
                    getPropertyDefault: function(_e) {
                        return _e == "timing-function" ? "ease" : _e == "iteration-count" ? 1 : _e == "direction" ? "normal" : _e == "fill-mode" ? "none" : null
                    }
                };
                h.default = b
            }
            , function(c, h, _) {
                Object.defineProperty(h, "__esModule", {
                    value: !0
                });
                var b = {
                    generateId: function() {
                        for (var _e = "", nt = 0; nt < 8; ++nt)
                            _e += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(Math.floor(62 * Math.random()));
                        return _e
                    },
                    frameToString: function(_e) {
                        var nt = "";
                        for (var it in _e)
                            nt += it + ":" + _e[it] + ";";
                        return nt
                    },
                    convertTimeToMs: function(_e) {
                        if (!_e)
                            return 0;
                        if (typeof _e == "number")
                            return _e;
                        var nt = parseFloat(_e);
                        return _e.indexOf("ms") != -1 ? nt : 1e3 * nt
                    },
                    prefixes: ["", "-webkit-", "-moz-", "-o-"]
                };
                h.default = b
            }
            , function(c, h, _) {
                Object.defineProperty(h, "__esModule", {
                    value: !0
                });
                var b, _e = (b = _(0)) && b.__esModule ? b : {
                    default: b
                };
                h.default = function nt(it, at) {
                    if (function(ht, _t) {
                        if (!(ht instanceof _t))
                            throw new TypeError("Cannot call a class as a function")
                    }(this, nt),
                    this.styles = typeof it == "string" ? _e.default.getFromSheets(it) : it,
                    typeof at == "string") {
                        var ut = _e.default.getFromSheets(at);
                        for (var pt in this.options = {},
                        ut)
                            this.options[pt.replace("animation-", "")] = ut[pt]
                    } else
                        this.options = typeof at == "number" ? {
                            duration: at
                        } : at
                }
            }
            , function(c, h, _) {
                Object.defineProperty(h, "__esModule", {
                    value: !0
                });
                var b = function() {
                    function pt(ht, _t) {
                        for (var vt = 0; vt < _t.length; vt++) {
                            var bt = _t[vt];
                            bt.enumerable = bt.enumerable || !1,
                            bt.configurable = !0,
                            "value"in bt && (bt.writable = !0),
                            Object.defineProperty(ht, bt.key, bt)
                        }
                    }
                    return function(ht, _t, vt) {
                        return _t && pt(ht.prototype, _t),
                        vt && pt(ht, vt),
                        ht
                    }
                }()
                  , _e = at(_(4))
                  , nt = at(_(1))
                  , it = at(_(0));
                function at(pt) {
                    return pt && pt.__esModule ? pt : {
                        default: pt
                    }
                }
                var ut = function() {
                    function pt(ht, _t, vt, bt) {
                        if (function(Et, Pt) {
                            if (!(Et instanceof Pt))
                                throw new TypeError("Cannot call a class as a function")
                        }(this, pt),
                        ht.constructor === Array ? this.doms = ht : this.doms = [ht],
                        _t.constructor === Array ? this.frames = _t : this.frames = [_t],
                        this.options = {
                            startFrom: 0,
                            pauseAt: [],
                            prefix: !1,
                            count: 1,
                            clear: !0,
                            applyOnEnd: !1,
                            instant: !1
                        },
                        vt != null && vt != null)
                            if (typeof vt == "boolean")
                                this.options.instant = vt;
                            else if (typeof vt == "number")
                                this.options.count = vt,
                                typeof bt == "boolean" && (this.options.instant = bt);
                            else
                                for (var St in vt)
                                    St == "pauseAt" && vt.pauseAt.constructor !== Array ? this.options[St] = [vt[St]] : this.options[St] = vt[St];
                        for (var At in this.promiseSupported = typeof Promise < "u" && Promise.toString().indexOf("[native code]") !== -1,
                        this.countRemainder = [],
                        this.animations = [],
                        this.styleDoms = [],
                        this.superSets = [],
                        this.eventHandler = [],
                        this.options.prefix ? this.prefixes = nt.default.prefixes : this.prefixes = [""],
                        ht)
                            this.countRemainder[At] = this.options.count - 1;
                        this.options.instant && this.play()
                    }
                    return b(pt, [{
                        key: "play",
                        value: function() {
                            var ht = this;
                            for (var _t in this.clear(),
                            this.promiseSupported && (this.promise = new Promise(function(bt) {
                                ht.promiseResolve = bt
                            }
                            )),
                            this.doms) {
                                var vt = this.makeAnimation(this.doms[_t]);
                                this.animations[_t] = vt.names,
                                this.styleDoms[_t] = vt.styleDom,
                                this.superSets[_t] = this.makeSuperSet(this.doms[_t], this.animations[_t]),
                                this.playAnimation(this.doms[_t], this.superSets[_t]),
                                this.eventHandler[_t] = this.handleAnimationEnd.bind(this, _t),
                                this.doms[_t].addEventListener("animationend", this.eventHandler[_t])
                            }
                            if (this.promiseSupported)
                                return this.promise
                        }
                    }, {
                        key: "clear",
                        value: function(ht) {
                            if (!ht) {
                                for (var _t in this.doms)
                                    this.clear(_t);
                                return this.animationEnded = 0,
                                this.promise = void 0,
                                void (this.promiseResolve = void 0)
                            }
                            var vt = this.styleDoms[ht];
                            for (var bt in vt && vt.parentNode && vt.parentNode.removeChild(vt),
                            this.superSets[ht])
                                for (var St in this.prefixes)
                                    this.doms[ht].style[this.prefixes[St] + "animation-" + bt] = null;
                            for (var At in this.prefixes)
                                this.doms[ht].style[this.prefixes[At] + "animation-play-state"] = null;
                            this.doms[ht].removeEventListener("animationend", this.eventHandler[ht]),
                            this.countRemainder[ht] = this.options.count - 1
                        }
                    }, {
                        key: "replay",
                        value: function(ht) {
                            var _t = this.doms[ht]
                              , vt = _t.cloneNode(!0);
                            _t.parentNode.replaceChild(vt, _t),
                            this.doms[ht].removeEventListener("animationend", this.eventHandler[ht]),
                            this.doms[ht] = vt,
                            this.doms[ht].addEventListener("animationend", this.eventHandler[ht])
                        }
                    }, {
                        key: "pause",
                        value: function() {
                            for (var ht in this.doms)
                                this.pauseDom(this.doms[ht])
                        }
                    }, {
                        key: "resume",
                        value: function() {
                            for (var ht in this.doms)
                                this.resumeDom(this.doms[ht])
                        }
                    }, {
                        key: "getPromise",
                        value: function() {
                            return this.promise
                        }
                    }, {
                        key: "handleAnimationEnd",
                        value: function(ht, _t) {
                            var vt = _t.animationName
                              , bt = vt.substring(vt.lastIndexOf("-") + 1);
                            this.options.pauseAt.includes(parseInt(bt)) && this.pauseDom(this.doms[ht]),
                            bt == this.frames.length && (this.countRemainder[ht] == -1 ? this.replay(ht) : this.countRemainder[ht] > 0 ? (this.countRemainder[ht]--,
                            this.replay(ht)) : (this.options.applyOnEnd && this.applyOnEnd(ht),
                            this.animationEnded++,
                            this.animationEnded == this.doms.length && (this.promiseSupported && this.promiseResolve(),
                            this.options.clear && this.clear())))
                        }
                    }, {
                        key: "pauseDom",
                        value: function(ht) {
                            for (var _t in this.prefixes)
                                ht.style[this.prefixes[_t] + "animation-play-state"] = "paused"
                        }
                    }, {
                        key: "resumeDom",
                        value: function(ht) {
                            for (var _t in this.prefixes)
                                ht.style[this.prefixes[_t] + "animation-play-state"] = "running"
                        }
                    }, {
                        key: "applyOnEnd",
                        value: function(ht) {
                            var _t = this.newFrames[this.frames.length];
                            for (var vt in _t)
                                this.doms[ht].style[vt] = _t[vt]
                        }
                    }, {
                        key: "makeAnimation",
                        value: function(ht) {
                            var _t = {}
                              , vt = []
                              , bt = {};
                            for (var St in this.frames)
                                for (var At in vt.push(this.frames[St].styles),
                                vt[St])
                                    bt[At] = !0;
                            var Et = window.getComputedStyle(ht);
                            for (var Pt in bt)
                                _t[Pt] = Et[Pt];
                            vt.unshift(_t);
                            for (var It = [vt[0]], Dt = 1; Dt < vt.length; ++Dt) {
                                var Gt = JSON.parse(JSON.stringify(It[Dt - 1]));
                                for (var Bt in vt[Dt])
                                    Gt[Bt] = vt[Dt][Bt];
                                It.push(Gt)
                            }
                            return this.newFrames = It,
                            _e.default.make(It, this.prefixes)
                        }
                    }, {
                        key: "makeSuperSet",
                        value: function(ht, _t) {
                            var vt = 0
                              , bt = {};
                            for (var St in this.frames)
                                for (var At in this.frames[St].options)
                                    bt[At] = "";
                            bt.name = "",
                            bt.duration = "",
                            bt.delay = "";
                            for (var Et = 0; Et < this.frames.length; ++Et) {
                                if (Et)
                                    for (var Pt in bt)
                                        bt[Pt] += ",";
                                var It = nt.default.convertTimeToMs(this.frames[Et].options.duration)
                                  , Dt = nt.default.convertTimeToMs(this.frames[Et].options.delay);
                                for (var Gt in Et < this.options.startFrom && (It = 0,
                                Dt = 0),
                                bt.name += _t[Et],
                                bt.duration += It + "ms",
                                bt.delay += vt + Dt + "ms",
                                bt)
                                    Gt != "name" && Gt != "duration" && Gt != "delay" && (bt[Gt] += this.frames[Et].options[Gt] ? this.frames[Et].options[Gt] : it.default.getPropertyDefault(Gt));
                                var Bt = this.frames[Et].options["iteration-count"];
                                vt += It * parseInt(Bt || 1) + Dt
                            }
                            return bt
                        }
                    }, {
                        key: "playAnimation",
                        value: function(ht, _t) {
                            for (var vt in _t)
                                for (var bt in this.prefixes)
                                    ht.style[this.prefixes[bt] + "animation-" + vt] = _t[vt];
                            this.options.pauseAt.includes(0) && this.pauseDom(ht)
                        }
                    }]),
                    pt
                }();
                h.default = ut
            }
            , function(c, h, _) {
                Object.defineProperty(h, "__esModule", {
                    value: !0
                });
                var b, _e = (b = _(1)) && b.__esModule ? b : {
                    default: b
                }, nt = {
                    make: function(it, at) {
                        for (var ut = [], pt = "", ht = "atr-" + _e.default.generateId(), _t = document.createElement("style"), vt = 0; vt < it.length - 1; ++vt)
                            ut.push(ht + "-" + (vt + 1)),
                            pt += nt.makeFromTwoFrames(it[vt], it[vt + 1], ut[vt], at);
                        return _t.innerHTML = pt,
                        _t.class = "foo",
                        document.getElementsByTagName("head")[0].appendChild(_t),
                        {
                            names: ut,
                            styleDom: _t
                        }
                    },
                    makeFromTwoFrames: function(it, at, ut, pt) {
                        var ht = "";
                        for (var _t in pt)
                            ht += "@" + pt[_t] + "keyframes " + ut + " {",
                            ht += "0%",
                            ht += "{" + _e.default.frameToString(it) + "}",
                            ht += "100%",
                            ht += "{" + _e.default.frameToString(at) + "}",
                            ht += "}";
                        return ht
                    }
                };
                h.default = nt
            }
            , function(c, h, _) {
                Object.defineProperty(h, "__esModule", {
                    value: !0
                }),
                h.Queue = h.Frame = void 0;
                var b = nt(_(2))
                  , _e = nt(_(3));
                function nt(it) {
                    return it && it.__esModule ? it : {
                        default: it
                    }
                }
                h.Frame = b.default,
                h.Queue = _e.default
            }
            ])
        }
        ,
        d.exports = o()
    },
    364: function(d) {
        d.exports = function(o) {
            var c = [];
            return c.toString = function() {
                return this.map(function(h) {
                    var _ = o(h);
                    return h[2] ? "@media ".concat(h[2], " {").concat(_, "}") : _
                }).join("")
            }
            ,
            c.i = function(h, _, b) {
                typeof h == "string" && (h = [[null, h, ""]]);
                var _e = {};
                if (b)
                    for (var nt = 0; nt < this.length; nt++) {
                        var it = this[nt][0];
                        it != null && (_e[it] = !0)
                    }
                for (var at = 0; at < h.length; at++) {
                    var ut = [].concat(h[at]);
                    b && _e[ut[0]] || (_ && (ut[2] ? ut[2] = "".concat(_, " and ").concat(ut[2]) : ut[2] = _),
                    c.push(ut))
                }
            }
            ,
            c
        }
    },
    101: function(d, o, c) {
        var h = c(986);
        function _() {
            this.argTypes = [],
            this.shimArgs = [],
            this.arrayArgs = [],
            this.arrayBlockIndices = [],
            this.scalarArgs = [],
            this.offsetArgs = [],
            this.offsetArgIndex = [],
            this.indexArgs = [],
            this.shapeArgs = [],
            this.funcName = "",
            this.pre = null,
            this.body = null,
            this.post = null,
            this.debug = !1
        }
        d.exports = function(b) {
            var _e = new _;
            _e.pre = b.pre,
            _e.body = b.body,
            _e.post = b.post;
            var nt = b.args.slice(0);
            _e.argTypes = nt;
            for (var it = 0; it < nt.length; ++it) {
                var at = nt[it];
                if (at === "array" || typeof at == "object" && at.blockIndices) {
                    if (_e.argTypes[it] = "array",
                    _e.arrayArgs.push(it),
                    _e.arrayBlockIndices.push(at.blockIndices ? at.blockIndices : 0),
                    _e.shimArgs.push("array" + it),
                    it < _e.pre.args.length && _e.pre.args[it].count > 0)
                        throw new Error("cwise: pre() block may not reference array args");
                    if (it < _e.post.args.length && _e.post.args[it].count > 0)
                        throw new Error("cwise: post() block may not reference array args")
                } else if (at === "scalar")
                    _e.scalarArgs.push(it),
                    _e.shimArgs.push("scalar" + it);
                else if (at === "index") {
                    if (_e.indexArgs.push(it),
                    it < _e.pre.args.length && _e.pre.args[it].count > 0)
                        throw new Error("cwise: pre() block may not reference array index");
                    if (it < _e.body.args.length && _e.body.args[it].lvalue)
                        throw new Error("cwise: body() block may not write to array index");
                    if (it < _e.post.args.length && _e.post.args[it].count > 0)
                        throw new Error("cwise: post() block may not reference array index")
                } else if (at === "shape") {
                    if (_e.shapeArgs.push(it),
                    it < _e.pre.args.length && _e.pre.args[it].lvalue)
                        throw new Error("cwise: pre() block may not write to array shape");
                    if (it < _e.body.args.length && _e.body.args[it].lvalue)
                        throw new Error("cwise: body() block may not write to array shape");
                    if (it < _e.post.args.length && _e.post.args[it].lvalue)
                        throw new Error("cwise: post() block may not write to array shape")
                } else {
                    if (typeof at != "object" || !at.offset)
                        throw new Error("cwise: Unknown argument type " + nt[it]);
                    _e.argTypes[it] = "offset",
                    _e.offsetArgs.push({
                        array: at.array,
                        offset: at.offset
                    }),
                    _e.offsetArgIndex.push(it)
                }
            }
            if (_e.arrayArgs.length <= 0)
                throw new Error("cwise: No array arguments specified");
            if (_e.pre.args.length > nt.length)
                throw new Error("cwise: Too many arguments in pre() block");
            if (_e.body.args.length > nt.length)
                throw new Error("cwise: Too many arguments in body() block");
            if (_e.post.args.length > nt.length)
                throw new Error("cwise: Too many arguments in post() block");
            return _e.debug = !!b.printCode || !!b.debug,
            _e.funcName = b.funcName || "cwise",
            _e.blockSize = b.blockSize || 64,
            h(_e)
        }
    },
    151: function(d, o, c) {
        var h = c(161);
        function _(nt, it, at) {
            var ut, pt, ht = nt.length, _t = it.arrayArgs.length, vt = it.indexArgs.length > 0, bt = [], St = [], At = 0, Et = 0;
            for (ut = 0; ut < ht; ++ut)
                St.push(["i", ut, "=0"].join(""));
            for (pt = 0; pt < _t; ++pt)
                for (ut = 0; ut < ht; ++ut)
                    Et = At,
                    At = nt[ut],
                    ut === 0 ? St.push(["d", pt, "s", ut, "=t", pt, "p", At].join("")) : St.push(["d", pt, "s", ut, "=(t", pt, "p", At, "-s", Et, "*t", pt, "p", Et, ")"].join(""));
            for (St.length > 0 && bt.push("var " + St.join(",")),
            ut = ht - 1; ut >= 0; --ut)
                At = nt[ut],
                bt.push(["for(i", ut, "=0;i", ut, "<s", At, ";++i", ut, "){"].join(""));
            for (bt.push(at),
            ut = 0; ut < ht; ++ut) {
                for (Et = At,
                At = nt[ut],
                pt = 0; pt < _t; ++pt)
                    bt.push(["p", pt, "+=d", pt, "s", ut].join(""));
                vt && (ut > 0 && bt.push(["index[", Et, "]-=s", Et].join("")),
                bt.push(["++index[", At, "]"].join(""))),
                bt.push("}")
            }
            return bt.join(`
`)
        }
        function b(nt, it, at) {
            for (var ut = nt.body, pt = [], ht = [], _t = 0; _t < nt.args.length; ++_t) {
                var vt = nt.args[_t];
                if (!(vt.count <= 0)) {
                    var bt = new RegExp(vt.name,"g")
                      , St = ""
                      , At = it.arrayArgs.indexOf(_t);
                    switch (it.argTypes[_t]) {
                    case "offset":
                        var Et = it.offsetArgIndex.indexOf(_t);
                        At = it.offsetArgs[Et].array,
                        St = "+q" + Et;
                    case "array":
                        St = "p" + At + St;
                        var Pt = "l" + _t
                          , It = "a" + At;
                        if (it.arrayBlockIndices[At] === 0)
                            vt.count === 1 ? at[At] === "generic" ? vt.lvalue ? (pt.push(["var ", Pt, "=", It, ".get(", St, ")"].join("")),
                            ut = ut.replace(bt, Pt),
                            ht.push([It, ".set(", St, ",", Pt, ")"].join(""))) : ut = ut.replace(bt, [It, ".get(", St, ")"].join("")) : ut = ut.replace(bt, [It, "[", St, "]"].join("")) : at[At] === "generic" ? (pt.push(["var ", Pt, "=", It, ".get(", St, ")"].join("")),
                            ut = ut.replace(bt, Pt),
                            vt.lvalue && ht.push([It, ".set(", St, ",", Pt, ")"].join(""))) : (pt.push(["var ", Pt, "=", It, "[", St, "]"].join("")),
                            ut = ut.replace(bt, Pt),
                            vt.lvalue && ht.push([It, "[", St, "]=", Pt].join("")));
                        else {
                            for (var Dt = [vt.name], Gt = [St], Bt = 0; Bt < Math.abs(it.arrayBlockIndices[At]); Bt++)
                                Dt.push("\\s*\\[([^\\]]+)\\]"),
                                Gt.push("$" + (Bt + 1) + "*t" + At + "b" + Bt);
                            if (bt = new RegExp(Dt.join(""),"g"),
                            St = Gt.join("+"),
                            at[At] === "generic")
                                throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                            ut = ut.replace(bt, [It, "[", St, "]"].join(""))
                        }
                        break;
                    case "scalar":
                        ut = ut.replace(bt, "Y" + it.scalarArgs.indexOf(_t));
                        break;
                    case "index":
                        ut = ut.replace(bt, "index");
                        break;
                    case "shape":
                        ut = ut.replace(bt, "shape")
                    }
                }
            }
            return [pt.join(`
`), ut, ht.join(`
`)].join(`
`).trim()
        }
        function _e(nt) {
            for (var it = new Array(nt.length), at = !0, ut = 0; ut < nt.length; ++ut) {
                var pt = nt[ut]
                  , ht = pt.match(/\d+/);
                ht = ht ? ht[0] : "",
                pt.charAt(0) === 0 ? it[ut] = "u" + pt.charAt(1) + ht : it[ut] = pt.charAt(0) + ht,
                ut > 0 && (at = at && it[ut] === it[ut - 1])
            }
            return at ? it[0] : it.join("")
        }
        d.exports = function(nt, it) {
            for (var at = it[1].length - Math.abs(nt.arrayBlockIndices[0]) | 0, ut = new Array(nt.arrayArgs.length), pt = new Array(nt.arrayArgs.length), ht = 0; ht < nt.arrayArgs.length; ++ht)
                pt[ht] = it[2 * ht],
                ut[ht] = it[2 * ht + 1];
            var _t = []
              , vt = []
              , bt = []
              , St = []
              , At = [];
            for (ht = 0; ht < nt.arrayArgs.length; ++ht) {
                nt.arrayBlockIndices[ht] < 0 ? (bt.push(0),
                St.push(at),
                _t.push(at),
                vt.push(at + nt.arrayBlockIndices[ht])) : (bt.push(nt.arrayBlockIndices[ht]),
                St.push(nt.arrayBlockIndices[ht] + at),
                _t.push(0),
                vt.push(nt.arrayBlockIndices[ht]));
                for (var Et = [], Pt = 0; Pt < ut[ht].length; Pt++)
                    bt[ht] <= ut[ht][Pt] && ut[ht][Pt] < St[ht] && Et.push(ut[ht][Pt] - bt[ht]);
                At.push(Et)
            }
            var It = ["SS"]
              , Dt = ["'use strict'"]
              , Gt = [];
            for (Pt = 0; Pt < at; ++Pt)
                Gt.push(["s", Pt, "=SS[", Pt, "]"].join(""));
            for (ht = 0; ht < nt.arrayArgs.length; ++ht) {
                for (It.push("a" + ht),
                It.push("t" + ht),
                It.push("p" + ht),
                Pt = 0; Pt < at; ++Pt)
                    Gt.push(["t", ht, "p", Pt, "=t", ht, "[", bt[ht] + Pt, "]"].join(""));
                for (Pt = 0; Pt < Math.abs(nt.arrayBlockIndices[ht]); ++Pt)
                    Gt.push(["t", ht, "b", Pt, "=t", ht, "[", _t[ht] + Pt, "]"].join(""))
            }
            for (ht = 0; ht < nt.scalarArgs.length; ++ht)
                It.push("Y" + ht);
            if (nt.shapeArgs.length > 0 && Gt.push("shape=SS.slice(0)"),
            nt.indexArgs.length > 0) {
                var Bt = new Array(at);
                for (ht = 0; ht < at; ++ht)
                    Bt[ht] = "0";
                Gt.push(["index=[", Bt.join(","), "]"].join(""))
            }
            for (ht = 0; ht < nt.offsetArgs.length; ++ht) {
                var kt = nt.offsetArgs[ht]
                  , Ut = [];
                for (Pt = 0; Pt < kt.offset.length; ++Pt)
                    kt.offset[Pt] !== 0 && (kt.offset[Pt] === 1 ? Ut.push(["t", kt.array, "p", Pt].join("")) : Ut.push([kt.offset[Pt], "*t", kt.array, "p", Pt].join("")));
                Ut.length === 0 ? Gt.push("q" + ht + "=0") : Gt.push(["q", ht, "=", Ut.join("+")].join(""))
            }
            var Ht = h([].concat(nt.pre.thisVars).concat(nt.body.thisVars).concat(nt.post.thisVars));
            for ((Gt = Gt.concat(Ht)).length > 0 && Dt.push("var " + Gt.join(",")),
            ht = 0; ht < nt.arrayArgs.length; ++ht)
                Dt.push("p" + ht + "|=0");
            nt.pre.body.length > 3 && Dt.push(b(nt.pre, nt, pt));
            var Kt = b(nt.body, nt, pt)
              , Jt = function(ir) {
                for (var lr = 0, ar = ir[0].length; lr < ar; ) {
                    for (var hr = 1; hr < ir.length; ++hr)
                        if (ir[hr][lr] !== ir[0][lr])
                            return lr;
                    ++lr
                }
                return lr
            }(At);
            Jt < at ? Dt.push(function(ir, lr, ar, hr) {
                for (var gr = lr.length, dr = ar.arrayArgs.length, cr = ar.blockSize, Ar = ar.indexArgs.length > 0, wr = [], Rr = 0; Rr < dr; ++Rr)
                    wr.push(["var offset", Rr, "=p", Rr].join(""));
                for (Rr = ir; Rr < gr; ++Rr)
                    wr.push(["for(var j" + Rr + "=SS[", lr[Rr], "]|0;j", Rr, ">0;){"].join("")),
                    wr.push(["if(j", Rr, "<", cr, "){"].join("")),
                    wr.push(["s", lr[Rr], "=j", Rr].join("")),
                    wr.push(["j", Rr, "=0"].join("")),
                    wr.push(["}else{s", lr[Rr], "=", cr].join("")),
                    wr.push(["j", Rr, "-=", cr, "}"].join("")),
                    Ar && wr.push(["index[", lr[Rr], "]=j", Rr].join(""));
                for (Rr = 0; Rr < dr; ++Rr) {
                    for (var Cr = ["offset" + Rr], tr = ir; tr < gr; ++tr)
                        Cr.push(["j", tr, "*t", Rr, "p", lr[tr]].join(""));
                    wr.push(["p", Rr, "=(", Cr.join("+"), ")"].join(""))
                }
                for (wr.push(_(lr, ar, hr)),
                Rr = ir; Rr < gr; ++Rr)
                    wr.push("}");
                return wr.join(`
`)
            }(Jt, At[0], nt, Kt)) : Dt.push(_(At[0], nt, Kt)),
            nt.post.body.length > 3 && Dt.push(b(nt.post, nt, pt)),
            nt.debug && console.log("-----Generated cwise routine for ", it, `:
` + Dt.join(`
`) + `
----------`);
            var or = [nt.funcName || "unnamed", "_cwise_loop_", ut[0].join("s"), "m", Jt, _e(pt)].join("");
            return new Function(["function ", or, "(", It.join(","), "){", Dt.join(`
`), "} return ", or].join(""))()
        }
    },
    986: function(d, o, c) {
        var h = c(151);
        d.exports = function(_) {
            var b = ["'use strict'", "var CACHED={}"]
              , _e = []
              , nt = _.funcName + "_cwise_thunk";
            b.push(["return function ", nt, "(", _.shimArgs.join(","), "){"].join(""));
            for (var it = [], at = [], ut = [["array", _.arrayArgs[0], ".shape.slice(", Math.max(0, _.arrayBlockIndices[0]), _.arrayBlockIndices[0] < 0 ? "," + _.arrayBlockIndices[0] + ")" : ")"].join("")], pt = [], ht = [], _t = 0; _t < _.arrayArgs.length; ++_t) {
                var vt = _.arrayArgs[_t];
                _e.push(["t", vt, "=array", vt, ".dtype,", "r", vt, "=array", vt, ".order"].join("")),
                it.push("t" + vt),
                it.push("r" + vt),
                at.push("t" + vt),
                at.push("r" + vt + ".join()"),
                ut.push("array" + vt + ".data"),
                ut.push("array" + vt + ".stride"),
                ut.push("array" + vt + ".offset|0"),
                _t > 0 && (pt.push("array" + _.arrayArgs[0] + ".shape.length===array" + vt + ".shape.length+" + (Math.abs(_.arrayBlockIndices[0]) - Math.abs(_.arrayBlockIndices[_t]))),
                ht.push("array" + _.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, _.arrayBlockIndices[0]) + "]===array" + vt + ".shape[shapeIndex+" + Math.max(0, _.arrayBlockIndices[_t]) + "]"))
            }
            for (_.arrayArgs.length > 1 && (b.push("if (!(" + pt.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"),
            b.push("for(var shapeIndex=array" + _.arrayArgs[0] + ".shape.length-" + Math.abs(_.arrayBlockIndices[0]) + "; shapeIndex-->0;) {"),
            b.push("if (!(" + ht.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')"),
            b.push("}")),
            _t = 0; _t < _.scalarArgs.length; ++_t)
                ut.push("scalar" + _.scalarArgs[_t]);
            return _e.push(["type=[", at.join(","), "].join()"].join("")),
            _e.push("proc=CACHED[type]"),
            b.push("var " + _e.join(",")),
            b.push(["if(!proc){", "CACHED[type]=proc=compile([", it.join(","), "])}", "return proc(", ut.join(","), ")}"].join("")),
            _.debug && console.log(`-----Generated thunk:
` + b.join(`
`) + `
----------`),
            new Function("compile",b.join(`
`))(h.bind(void 0, _))
        }
    },
    981: function(d) {
        d.exports = function(o) {
            for (var c = new Array(o), h = 0; h < o; ++h)
                c[h] = h;
            return c
        }
    },
    872: function(d) {
        function o(c) {
            return !!c.constructor && typeof c.constructor.isBuffer == "function" && c.constructor.isBuffer(c)
        }
        d.exports = function(c) {
            return c != null && (o(c) || function(h) {
                return typeof h.readFloatLE == "function" && typeof h.slice == "function" && o(h.slice(0, 0))
            }(c) || !!c._isBuffer)
        }
    },
    49: function(d, o, c) {
        var h = c(101)
          , _ = {
            body: "",
            args: [],
            thisVars: [],
            localVars: []
        };
        function b(_t) {
            if (!_t)
                return _;
            for (var vt = 0; vt < _t.args.length; ++vt) {
                var bt = _t.args[vt];
                _t.args[vt] = vt === 0 ? {
                    name: bt,
                    lvalue: !0,
                    rvalue: !!_t.rvalue,
                    count: _t.count || 1
                } : {
                    name: bt,
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }
            }
            return _t.thisVars || (_t.thisVars = []),
            _t.localVars || (_t.localVars = []),
            _t
        }
        function _e(_t) {
            for (var vt = [], bt = 0; bt < _t.args.length; ++bt)
                vt.push("a" + bt);
            return new Function("P",["return function ", _t.funcName, "_ndarrayops(", vt.join(","), ") {P(", vt.join(","), ");return a0}"].join(""))(function(St) {
                return h({
                    args: St.args,
                    pre: b(St.pre),
                    body: b(St.body),
                    post: b(St.proc),
                    funcName: St.funcName
                })
            }(_t))
        }
        var nt = {
            add: "+",
            sub: "-",
            mul: "*",
            div: "/",
            mod: "%",
            band: "&",
            bor: "|",
            bxor: "^",
            lshift: "<<",
            rshift: ">>",
            rrshift: ">>>"
        };
        (function() {
            for (var _t in nt) {
                var vt = nt[_t];
                o[_t] = _e({
                    args: ["array", "array", "array"],
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=b" + vt + "c"
                    },
                    funcName: _t
                }),
                o[_t + "eq"] = _e({
                    args: ["array", "array"],
                    body: {
                        args: ["a", "b"],
                        body: "a" + vt + "=b"
                    },
                    rvalue: !0,
                    funcName: _t + "eq"
                }),
                o[_t + "s"] = _e({
                    args: ["array", "array", "scalar"],
                    body: {
                        args: ["a", "b", "s"],
                        body: "a=b" + vt + "s"
                    },
                    funcName: _t + "s"
                }),
                o[_t + "seq"] = _e({
                    args: ["array", "scalar"],
                    body: {
                        args: ["a", "s"],
                        body: "a" + vt + "=s"
                    },
                    rvalue: !0,
                    funcName: _t + "seq"
                })
            }
        }
        )();
        var it = {
            not: "!",
            bnot: "~",
            neg: "-",
            recip: "1.0/"
        };
        (function() {
            for (var _t in it) {
                var vt = it[_t];
                o[_t] = _e({
                    args: ["array", "array"],
                    body: {
                        args: ["a", "b"],
                        body: "a=" + vt + "b"
                    },
                    funcName: _t
                }),
                o[_t + "eq"] = _e({
                    args: ["array"],
                    body: {
                        args: ["a"],
                        body: "a=" + vt + "a"
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: _t + "eq"
                })
            }
        }
        )();
        var at = {
            and: "&&",
            or: "||",
            eq: "===",
            neq: "!==",
            lt: "<",
            gt: ">",
            leq: "<=",
            geq: ">="
        };
        (function() {
            for (var _t in at) {
                var vt = at[_t];
                o[_t] = _e({
                    args: ["array", "array", "array"],
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=b" + vt + "c"
                    },
                    funcName: _t
                }),
                o[_t + "s"] = _e({
                    args: ["array", "array", "scalar"],
                    body: {
                        args: ["a", "b", "s"],
                        body: "a=b" + vt + "s"
                    },
                    funcName: _t + "s"
                }),
                o[_t + "eq"] = _e({
                    args: ["array", "array"],
                    body: {
                        args: ["a", "b"],
                        body: "a=a" + vt + "b"
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: _t + "eq"
                }),
                o[_t + "seq"] = _e({
                    args: ["array", "scalar"],
                    body: {
                        args: ["a", "s"],
                        body: "a=a" + vt + "s"
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: _t + "seq"
                })
            }
        }
        )();
        var ut = ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan"];
        (function() {
            for (var _t = 0; _t < ut.length; ++_t) {
                var vt = ut[_t];
                o[vt] = _e({
                    args: ["array", "array"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b"],
                        body: "a=this_f(b)",
                        thisVars: ["this_f"]
                    },
                    funcName: vt
                }),
                o[vt + "eq"] = _e({
                    args: ["array"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a"],
                        body: "a=this_f(a)",
                        thisVars: ["this_f"]
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: vt + "eq"
                })
            }
        }
        )();
        var pt = ["max", "min", "atan2", "pow"];
        (function() {
            for (var _t = 0; _t < pt.length; ++_t) {
                var vt = pt[_t];
                o[vt] = _e({
                    args: ["array", "array", "array"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=this_f(b,c)",
                        thisVars: ["this_f"]
                    },
                    funcName: vt
                }),
                o[vt + "s"] = _e({
                    args: ["array", "array", "scalar"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=this_f(b,c)",
                        thisVars: ["this_f"]
                    },
                    funcName: vt + "s"
                }),
                o[vt + "eq"] = _e({
                    args: ["array", "array"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b"],
                        body: "a=this_f(a,b)",
                        thisVars: ["this_f"]
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: vt + "eq"
                }),
                o[vt + "seq"] = _e({
                    args: ["array", "scalar"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b"],
                        body: "a=this_f(a,b)",
                        thisVars: ["this_f"]
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: vt + "seq"
                })
            }
        }
        )();
        var ht = ["atan2", "pow"];
        (function() {
            for (var _t = 0; _t < ht.length; ++_t) {
                var vt = ht[_t];
                o[vt + "op"] = _e({
                    args: ["array", "array", "array"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=this_f(c,b)",
                        thisVars: ["this_f"]
                    },
                    funcName: vt + "op"
                }),
                o[vt + "ops"] = _e({
                    args: ["array", "array", "scalar"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b", "c"],
                        body: "a=this_f(c,b)",
                        thisVars: ["this_f"]
                    },
                    funcName: vt + "ops"
                }),
                o[vt + "opeq"] = _e({
                    args: ["array", "array"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b"],
                        body: "a=this_f(b,a)",
                        thisVars: ["this_f"]
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: vt + "opeq"
                }),
                o[vt + "opseq"] = _e({
                    args: ["array", "scalar"],
                    pre: {
                        args: [],
                        body: "this_f=Math." + vt,
                        thisVars: ["this_f"]
                    },
                    body: {
                        args: ["a", "b"],
                        body: "a=this_f(b,a)",
                        thisVars: ["this_f"]
                    },
                    rvalue: !0,
                    count: 2,
                    funcName: vt + "opseq"
                })
            }
        }
        )(),
        o.any = h({
            args: ["array"],
            pre: _,
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                body: "if(a){return true}",
                localVars: [],
                thisVars: []
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return false"
            },
            funcName: "any"
        }),
        o.all = h({
            args: ["array"],
            pre: _,
            body: {
                args: [{
                    name: "x",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                body: "if(!x){return false}",
                localVars: [],
                thisVars: []
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return true"
            },
            funcName: "all"
        }),
        o.sum = h({
            args: ["array"],
            pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0"
            },
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                body: "this_s+=a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s"
            },
            funcName: "sum"
        }),
        o.prod = h({
            args: ["array"],
            pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=1"
            },
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                body: "this_s*=a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s"
            },
            funcName: "prod"
        }),
        o.norm2squared = h({
            args: ["array"],
            pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0"
            },
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s"
            },
            funcName: "norm2squared"
        }),
        o.norm2 = h({
            args: ["array"],
            pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0"
            },
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }],
                body: "this_s+=a*a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return Math.sqrt(this_s)"
            },
            funcName: "norm2"
        }),
        o.norminf = h({
            args: ["array"],
            pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0"
            },
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 4
                }],
                body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s"
            },
            funcName: "norminf"
        }),
        o.norm1 = h({
            args: ["array"],
            pre: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "this_s=0"
            },
            body: {
                args: [{
                    name: "a",
                    lvalue: !1,
                    rvalue: !0,
                    count: 3
                }],
                body: "this_s+=a<0?-a:a",
                localVars: [],
                thisVars: ["this_s"]
            },
            post: {
                args: [],
                localVars: [],
                thisVars: ["this_s"],
                body: "return this_s"
            },
            funcName: "norm1"
        }),
        o.sup = h({
            args: ["array"],
            pre: {
                body: "this_h=-Infinity",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            },
            body: {
                body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
                args: [{
                    name: "_inline_1_arg0_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }],
                thisVars: ["this_h"],
                localVars: []
            },
            post: {
                body: "return this_h",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            }
        }),
        o.inf = h({
            args: ["array"],
            pre: {
                body: "this_h=Infinity",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            },
            body: {
                body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
                args: [{
                    name: "_inline_1_arg0_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }],
                thisVars: ["this_h"],
                localVars: []
            },
            post: {
                body: "return this_h",
                args: [],
                thisVars: ["this_h"],
                localVars: []
            }
        }),
        o.argmin = h({
            args: ["index", "array", "shape"],
            pre: {
                body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [{
                    name: "_inline_0_arg0_",
                    lvalue: !1,
                    rvalue: !1,
                    count: 0
                }, {
                    name: "_inline_0_arg1_",
                    lvalue: !1,
                    rvalue: !1,
                    count: 0
                }, {
                    name: "_inline_0_arg2_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                thisVars: ["this_i", "this_v"],
                localVars: []
            },
            body: {
                body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [{
                    name: "_inline_1_arg0_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }, {
                    name: "_inline_1_arg1_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }],
                thisVars: ["this_i", "this_v"],
                localVars: ["_inline_1_k"]
            },
            post: {
                body: "{return this_i}",
                args: [],
                thisVars: ["this_i"],
                localVars: []
            }
        }),
        o.argmax = h({
            args: ["index", "array", "shape"],
            pre: {
                body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
                args: [{
                    name: "_inline_0_arg0_",
                    lvalue: !1,
                    rvalue: !1,
                    count: 0
                }, {
                    name: "_inline_0_arg1_",
                    lvalue: !1,
                    rvalue: !1,
                    count: 0
                }, {
                    name: "_inline_0_arg2_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                thisVars: ["this_i", "this_v"],
                localVars: []
            },
            body: {
                body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
                args: [{
                    name: "_inline_1_arg0_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }, {
                    name: "_inline_1_arg1_",
                    lvalue: !1,
                    rvalue: !0,
                    count: 2
                }],
                thisVars: ["this_i", "this_v"],
                localVars: ["_inline_1_k"]
            },
            post: {
                body: "{return this_i}",
                args: [],
                thisVars: ["this_i"],
                localVars: []
            }
        }),
        o.random = _e({
            args: ["array"],
            pre: {
                args: [],
                body: "this_f=Math.random",
                thisVars: ["this_f"]
            },
            body: {
                args: ["a"],
                body: "a=this_f()",
                thisVars: ["this_f"]
            },
            funcName: "random"
        }),
        o.assign = _e({
            args: ["array", "array"],
            body: {
                args: ["a", "b"],
                body: "a=b"
            },
            funcName: "assign"
        }),
        o.assigns = _e({
            args: ["array", "scalar"],
            body: {
                args: ["a", "b"],
                body: "a=b"
            },
            funcName: "assigns"
        }),
        o.equals = h({
            args: ["array", "array"],
            pre: _,
            body: {
                args: [{
                    name: "x",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }, {
                    name: "y",
                    lvalue: !1,
                    rvalue: !0,
                    count: 1
                }],
                body: "if(x!==y){return false}",
                localVars: [],
                thisVars: []
            },
            post: {
                args: [],
                localVars: [],
                thisVars: [],
                body: "return true"
            },
            funcName: "equals"
        })
    },
    881: function(d, o, c) {
        var h = c(981)
          , _ = c(872)
          , b = typeof Float64Array < "u";
        function _e(ut, pt) {
            return ut[0] - pt[0]
        }
        function nt() {
            var ut, pt = this.stride, ht = new Array(pt.length);
            for (ut = 0; ut < ht.length; ++ut)
                ht[ut] = [Math.abs(pt[ut]), ut];
            ht.sort(_e);
            var _t = new Array(ht.length);
            for (ut = 0; ut < _t.length; ++ut)
                _t[ut] = ht[ut][1];
            return _t
        }
        function it(ut, pt) {
            var ht = ["View", pt, "d", ut].join("");
            pt < 0 && (ht = "View_Nil" + ut);
            var _t = ut === "generic";
            if (pt === -1) {
                var vt = "function " + ht + "(a){this.data=a;};var proto=" + ht + ".prototype;proto.dtype='" + ut + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + ht + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + ht + "(a){return new " + ht + "(a);}";
                return new Function(vt)()
            }
            if (pt === 0)
                return vt = "function " + ht + "(a,d) {this.data = a;this.offset = d};var proto=" + ht + ".prototype;proto.dtype='" + ut + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + ht + "_copy() {return new " + ht + "(this.data,this.offset)};proto.pick=function " + ht + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + ht + "_get(){return " + (_t ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + ht + "_set(v){return " + (_t ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + ht + "(a,b,c,d){return new " + ht + "(a,d)}",
                new Function("TrivialArray",vt)(at[ut][0]);
            vt = ["'use strict'"];
            var bt = h(pt)
              , St = bt.map(function(Ut) {
                return "i" + Ut
            })
              , At = "this.offset+" + bt.map(function(Ut) {
                return "this.stride[" + Ut + "]*i" + Ut
            }).join("+")
              , Et = bt.map(function(Ut) {
                return "b" + Ut
            }).join(",")
              , Pt = bt.map(function(Ut) {
                return "c" + Ut
            }).join(",");
            vt.push("function " + ht + "(a," + Et + "," + Pt + ",d){this.data=a", "this.shape=[" + Et + "]", "this.stride=[" + Pt + "]", "this.offset=d|0}", "var proto=" + ht + ".prototype", "proto.dtype='" + ut + "'", "proto.dimension=" + pt),
            vt.push("Object.defineProperty(proto,'size',{get:function " + ht + "_size(){return " + bt.map(function(Ut) {
                return "this.shape[" + Ut + "]"
            }).join("*"), "}})"),
            pt === 1 ? vt.push("proto.order=[0]") : (vt.push("Object.defineProperty(proto,'order',{get:"),
            pt < 4 ? (vt.push("function " + ht + "_order(){"),
            pt === 2 ? vt.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})") : pt === 3 && vt.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")) : vt.push("ORDER})")),
            vt.push("proto.set=function " + ht + "_set(" + St.join(",") + ",v){"),
            _t ? vt.push("return this.data.set(" + At + ",v)}") : vt.push("return this.data[" + At + "]=v}"),
            vt.push("proto.get=function " + ht + "_get(" + St.join(",") + "){"),
            _t ? vt.push("return this.data.get(" + At + ")}") : vt.push("return this.data[" + At + "]}"),
            vt.push("proto.index=function " + ht + "_index(", St.join(), "){return " + At + "}"),
            vt.push("proto.hi=function " + ht + "_hi(" + St.join(",") + "){return new " + ht + "(this.data," + bt.map(function(Ut) {
                return ["(typeof i", Ut, "!=='number'||i", Ut, "<0)?this.shape[", Ut, "]:i", Ut, "|0"].join("")
            }).join(",") + "," + bt.map(function(Ut) {
                return "this.stride[" + Ut + "]"
            }).join(",") + ",this.offset)}");
            var It = bt.map(function(Ut) {
                return "a" + Ut + "=this.shape[" + Ut + "]"
            })
              , Dt = bt.map(function(Ut) {
                return "c" + Ut + "=this.stride[" + Ut + "]"
            });
            vt.push("proto.lo=function " + ht + "_lo(" + St.join(",") + "){var b=this.offset,d=0," + It.join(",") + "," + Dt.join(","));
            for (var Gt = 0; Gt < pt; ++Gt)
                vt.push("if(typeof i" + Gt + "==='number'&&i" + Gt + ">=0){d=i" + Gt + "|0;b+=c" + Gt + "*d;a" + Gt + "-=d}");
            for (vt.push("return new " + ht + "(this.data," + bt.map(function(Ut) {
                return "a" + Ut
            }).join(",") + "," + bt.map(function(Ut) {
                return "c" + Ut
            }).join(",") + ",b)}"),
            vt.push("proto.step=function " + ht + "_step(" + St.join(",") + "){var " + bt.map(function(Ut) {
                return "a" + Ut + "=this.shape[" + Ut + "]"
            }).join(",") + "," + bt.map(function(Ut) {
                return "b" + Ut + "=this.stride[" + Ut + "]"
            }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil"),
            Gt = 0; Gt < pt; ++Gt)
                vt.push("if(typeof i" + Gt + "==='number'){d=i" + Gt + "|0;if(d<0){c+=b" + Gt + "*(a" + Gt + "-1);a" + Gt + "=ceil(-a" + Gt + "/d)}else{a" + Gt + "=ceil(a" + Gt + "/d)}b" + Gt + "*=d}");
            vt.push("return new " + ht + "(this.data," + bt.map(function(Ut) {
                return "a" + Ut
            }).join(",") + "," + bt.map(function(Ut) {
                return "b" + Ut
            }).join(",") + ",c)}");
            var Bt = new Array(pt)
              , kt = new Array(pt);
            for (Gt = 0; Gt < pt; ++Gt)
                Bt[Gt] = "a[i" + Gt + "]",
                kt[Gt] = "b[i" + Gt + "]";
            for (vt.push("proto.transpose=function " + ht + "_transpose(" + St + "){" + St.map(function(Ut, Ht) {
                return Ut + "=(" + Ut + "===undefined?" + Ht + ":" + Ut + "|0)"
            }).join(";"), "var a=this.shape,b=this.stride;return new " + ht + "(this.data," + Bt.join(",") + "," + kt.join(",") + ",this.offset)}"),
            vt.push("proto.pick=function " + ht + "_pick(" + St + "){var a=[],b=[],c=this.offset"),
            Gt = 0; Gt < pt; ++Gt)
                vt.push("if(typeof i" + Gt + "==='number'&&i" + Gt + ">=0){c=(c+this.stride[" + Gt + "]*i" + Gt + ")|0}else{a.push(this.shape[" + Gt + "]);b.push(this.stride[" + Gt + "])}");
            return vt.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),
            vt.push("return function construct_" + ht + "(data,shape,stride,offset){return new " + ht + "(data," + bt.map(function(Ut) {
                return "shape[" + Ut + "]"
            }).join(",") + "," + bt.map(function(Ut) {
                return "stride[" + Ut + "]"
            }).join(",") + ",offset)}"),
            new Function("CTOR_LIST","ORDER",vt.join(`
`))(at[ut], nt)
        }
        var at = {
            float32: [],
            float64: [],
            int8: [],
            int16: [],
            int32: [],
            uint8: [],
            uint16: [],
            uint32: [],
            array: [],
            uint8_clamped: [],
            bigint64: [],
            biguint64: [],
            buffer: [],
            generic: []
        };
        d.exports = function(ut, pt, ht, _t) {
            if (ut === void 0)
                return (0,
                at.array[0])([]);
            typeof ut == "number" && (ut = [ut]),
            pt === void 0 && (pt = [ut.length]);
            var vt = pt.length;
            if (ht === void 0) {
                ht = new Array(vt);
                for (var bt = vt - 1, St = 1; bt >= 0; --bt)
                    ht[bt] = St,
                    St *= pt[bt]
            }
            if (_t === void 0)
                for (_t = 0,
                bt = 0; bt < vt; ++bt)
                    ht[bt] < 0 && (_t -= (pt[bt] - 1) * ht[bt]);
            for (var At = function(Pt) {
                if (_(Pt))
                    return "buffer";
                if (b)
                    switch (Object.prototype.toString.call(Pt)) {
                    case "[object Float64Array]":
                        return "float64";
                    case "[object Float32Array]":
                        return "float32";
                    case "[object Int8Array]":
                        return "int8";
                    case "[object Int16Array]":
                        return "int16";
                    case "[object Int32Array]":
                        return "int32";
                    case "[object Uint8Array]":
                        return "uint8";
                    case "[object Uint16Array]":
                        return "uint16";
                    case "[object Uint32Array]":
                        return "uint32";
                    case "[object Uint8ClampedArray]":
                        return "uint8_clamped";
                    case "[object BigInt64Array]":
                        return "bigint64";
                    case "[object BigUint64Array]":
                        return "biguint64"
                    }
                return Array.isArray(Pt) ? "array" : "generic"
            }(ut), Et = at[At]; Et.length <= vt + 1; )
                Et.push(it(At, Et.length - 1));
            return (0,
            Et[vt + 1])(ut, pt, ht, _t)
        }
    },
    516: function(d) {
        d.exports = function o(c, h, _) {
            function b(it, at) {
                if (!h[it]) {
                    if (!c[it]) {
                        if (_e)
                            return _e(it, !0);
                        throw new Error("Cannot find module '" + it + "'")
                    }
                    var ut = h[it] = {
                        exports: {}
                    };
                    c[it][0].call(ut.exports, function(pt) {
                        return b(c[it][1][pt] || pt)
                    }, ut, ut.exports, o, c, h, _)
                }
                return h[it].exports
            }
            for (var _e = void 0, nt = 0; nt < _.length; nt++)
                b(_[nt]);
            return b
        }({
            1: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    var _t = o("crypto");
                    function vt(Dt, Gt) {
                        return function(Bt, kt) {
                            var Ut;
                            if ((Ut = kt.algorithm !== "passthrough" ? _t.createHash(kt.algorithm) : new It).write === void 0 && (Ut.write = Ut.update,
                            Ut.end = Ut.update),
                            Pt(kt, Ut).dispatch(Bt),
                            Ut.update || Ut.end(""),
                            Ut.digest)
                                return Ut.digest(kt.encoding === "buffer" ? void 0 : kt.encoding);
                            var Ht = Ut.read();
                            return kt.encoding !== "buffer" ? Ht.toString(kt.encoding) : Ht
                        }(Dt, Gt = At(Dt, Gt))
                    }
                    (h = c.exports = vt).sha1 = function(Dt) {
                        return vt(Dt)
                    }
                    ,
                    h.keys = function(Dt) {
                        return vt(Dt, {
                            excludeValues: !0,
                            algorithm: "sha1",
                            encoding: "hex"
                        })
                    }
                    ,
                    h.MD5 = function(Dt) {
                        return vt(Dt, {
                            algorithm: "md5",
                            encoding: "hex"
                        })
                    }
                    ,
                    h.keysMD5 = function(Dt) {
                        return vt(Dt, {
                            algorithm: "md5",
                            encoding: "hex",
                            excludeValues: !0
                        })
                    }
                    ;
                    var bt = _t.getHashes ? _t.getHashes().slice() : ["sha1", "md5"];
                    bt.push("passthrough");
                    var St = ["buffer", "hex", "binary", "base64"];
                    function At(Dt, Gt) {
                        Gt = Gt || {};
                        var Bt = {};
                        if (Bt.algorithm = Gt.algorithm || "sha1",
                        Bt.encoding = Gt.encoding || "hex",
                        Bt.excludeValues = !!Gt.excludeValues,
                        Bt.algorithm = Bt.algorithm.toLowerCase(),
                        Bt.encoding = Bt.encoding.toLowerCase(),
                        Bt.ignoreUnknown = Gt.ignoreUnknown === !0,
                        Bt.respectType = Gt.respectType !== !1,
                        Bt.respectFunctionNames = Gt.respectFunctionNames !== !1,
                        Bt.respectFunctionProperties = Gt.respectFunctionProperties !== !1,
                        Bt.unorderedArrays = Gt.unorderedArrays === !0,
                        Bt.unorderedSets = Gt.unorderedSets !== !1,
                        Bt.unorderedObjects = Gt.unorderedObjects !== !1,
                        Bt.replacer = Gt.replacer || void 0,
                        Bt.excludeKeys = Gt.excludeKeys || void 0,
                        Dt === void 0)
                            throw new Error("Object argument required.");
                        for (var kt = 0; kt < bt.length; ++kt)
                            bt[kt].toLowerCase() === Bt.algorithm.toLowerCase() && (Bt.algorithm = bt[kt]);
                        if (bt.indexOf(Bt.algorithm) === -1)
                            throw new Error('Algorithm "' + Bt.algorithm + '"  not supported. supported values: ' + bt.join(", "));
                        if (St.indexOf(Bt.encoding) === -1 && Bt.algorithm !== "passthrough")
                            throw new Error('Encoding "' + Bt.encoding + '"  not supported. supported values: ' + St.join(", "));
                        return Bt
                    }
                    function Et(Dt) {
                        if (typeof Dt == "function")
                            return /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(Dt)) != null
                    }
                    function Pt(Dt, Gt, Bt) {
                        function kt(Ut) {
                            return Gt.update ? Gt.update(Ut, "utf8") : Gt.write(Ut, "utf8")
                        }
                        return Bt = Bt || [],
                        {
                            dispatch: function(Ut) {
                                return Dt.replacer && (Ut = Dt.replacer(Ut)),
                                this["_" + (Ut === null ? "null" : typeof Ut)](Ut)
                            },
                            _object: function(Ut) {
                                var Ht, Kt = Object.prototype.toString.call(Ut), Jt = /\[object (.*)\]/i.exec(Kt);
                                if (Jt = (Jt = Jt ? Jt[1] : "unknown:[" + Kt + "]").toLowerCase(),
                                0 <= (Ht = Bt.indexOf(Ut)))
                                    return this.dispatch("[CIRCULAR:" + Ht + "]");
                                if (Bt.push(Ut),
                                _e !== void 0 && _e.isBuffer && _e.isBuffer(Ut))
                                    return kt("buffer:"),
                                    kt(Ut);
                                if (Jt === "object" || Jt === "function" || Jt === "asyncfunction") {
                                    var or = Object.keys(Ut);
                                    Dt.unorderedObjects && (or = or.sort()),
                                    Dt.respectType === !1 || Et(Ut) || or.splice(0, 0, "prototype", "__proto__", "constructor"),
                                    Dt.excludeKeys && (or = or.filter(function(lr) {
                                        return !Dt.excludeKeys(lr)
                                    })),
                                    kt("object:" + or.length + ":");
                                    var ir = this;
                                    return or.forEach(function(lr) {
                                        ir.dispatch(lr),
                                        kt(":"),
                                        Dt.excludeValues || ir.dispatch(Ut[lr]),
                                        kt(",")
                                    })
                                }
                                if (!this["_" + Jt]) {
                                    if (Dt.ignoreUnknown)
                                        return kt("[" + Jt + "]");
                                    throw new Error('Unknown object type "' + Jt + '"')
                                }
                                this["_" + Jt](Ut)
                            },
                            _array: function(Ut, Ht) {
                                Ht = Ht !== void 0 ? Ht : Dt.unorderedArrays !== !1;
                                var Kt = this;
                                if (kt("array:" + Ut.length + ":"),
                                !Ht || Ut.length <= 1)
                                    return Ut.forEach(function(ir) {
                                        return Kt.dispatch(ir)
                                    });
                                var Jt = []
                                  , or = Ut.map(function(ir) {
                                    var lr = new It
                                      , ar = Bt.slice();
                                    return Pt(Dt, lr, ar).dispatch(ir),
                                    Jt = Jt.concat(ar.slice(Bt.length)),
                                    lr.read().toString()
                                });
                                return Bt = Bt.concat(Jt),
                                or.sort(),
                                this._array(or, !1)
                            },
                            _date: function(Ut) {
                                return kt("date:" + Ut.toJSON())
                            },
                            _symbol: function(Ut) {
                                return kt("symbol:" + Ut.toString())
                            },
                            _error: function(Ut) {
                                return kt("error:" + Ut.toString())
                            },
                            _boolean: function(Ut) {
                                return kt("bool:" + Ut.toString())
                            },
                            _string: function(Ut) {
                                kt("string:" + Ut.length + ":"),
                                kt(Ut.toString())
                            },
                            _function: function(Ut) {
                                kt("fn:"),
                                Et(Ut) ? this.dispatch("[native]") : this.dispatch(Ut.toString()),
                                Dt.respectFunctionNames !== !1 && this.dispatch("function-name:" + String(Ut.name)),
                                Dt.respectFunctionProperties && this._object(Ut)
                            },
                            _number: function(Ut) {
                                return kt("number:" + Ut.toString())
                            },
                            _xml: function(Ut) {
                                return kt("xml:" + Ut.toString())
                            },
                            _null: function() {
                                return kt("Null")
                            },
                            _undefined: function() {
                                return kt("Undefined")
                            },
                            _regexp: function(Ut) {
                                return kt("regex:" + Ut.toString())
                            },
                            _uint8array: function(Ut) {
                                return kt("uint8array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _uint8clampedarray: function(Ut) {
                                return kt("uint8clampedarray:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _int8array: function(Ut) {
                                return kt("uint8array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _uint16array: function(Ut) {
                                return kt("uint16array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _int16array: function(Ut) {
                                return kt("uint16array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _uint32array: function(Ut) {
                                return kt("uint32array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _int32array: function(Ut) {
                                return kt("uint32array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _float32array: function(Ut) {
                                return kt("float32array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _float64array: function(Ut) {
                                return kt("float64array:"),
                                this.dispatch(Array.prototype.slice.call(Ut))
                            },
                            _arraybuffer: function(Ut) {
                                return kt("arraybuffer:"),
                                this.dispatch(new Uint8Array(Ut))
                            },
                            _url: function(Ut) {
                                return kt("url:" + Ut.toString())
                            },
                            _map: function(Ut) {
                                kt("map:");
                                var Ht = Array.from(Ut);
                                return this._array(Ht, Dt.unorderedSets !== !1)
                            },
                            _set: function(Ut) {
                                kt("set:");
                                var Ht = Array.from(Ut);
                                return this._array(Ht, Dt.unorderedSets !== !1)
                            },
                            _file: function(Ut) {
                                return kt("file:"),
                                this.dispatch([Ut.name, Ut.size, Ut.type, Ut.lastModfied])
                            },
                            _blob: function() {
                                if (Dt.ignoreUnknown)
                                    return kt("[blob]");
                                throw Error(`Hashing Blob objects is currently not supported
(see https://github.com/puleos/object-hash/issues/26)
Use "options.replacer" or "options.ignoreUnknown"
`)
                            },
                            _domwindow: function() {
                                return kt("domwindow")
                            },
                            _bigint: function(Ut) {
                                return kt("bigint:" + Ut.toString())
                            },
                            _process: function() {
                                return kt("process")
                            },
                            _timer: function() {
                                return kt("timer")
                            },
                            _pipe: function() {
                                return kt("pipe")
                            },
                            _tcp: function() {
                                return kt("tcp")
                            },
                            _udp: function() {
                                return kt("udp")
                            },
                            _tty: function() {
                                return kt("tty")
                            },
                            _statwatcher: function() {
                                return kt("statwatcher")
                            },
                            _securecontext: function() {
                                return kt("securecontext")
                            },
                            _connection: function() {
                                return kt("connection")
                            },
                            _zlib: function() {
                                return kt("zlib")
                            },
                            _context: function() {
                                return kt("context")
                            },
                            _nodescript: function() {
                                return kt("nodescript")
                            },
                            _httpparser: function() {
                                return kt("httpparser")
                            },
                            _dataview: function() {
                                return kt("dataview")
                            },
                            _signal: function() {
                                return kt("signal")
                            },
                            _fsevent: function() {
                                return kt("fsevent")
                            },
                            _tlswrap: function() {
                                return kt("tlswrap")
                            }
                        }
                    }
                    function It() {
                        return {
                            buf: "",
                            write: function(Dt) {
                                this.buf += Dt
                            },
                            end: function(Dt) {
                                this.buf += Dt
                            },
                            read: function() {
                                return this.buf
                            }
                        }
                    }
                    h.writeToStream = function(Dt, Gt, Bt) {
                        return Bt === void 0 && (Bt = Gt,
                        Gt = {}),
                        Pt(Gt = At(Dt, Gt), Bt).dispatch(Dt)
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_7eac155c.js", "/")
            }
            , {
                buffer: 3,
                crypto: 5,
                lYpoI2: 10
            }],
            2: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    (function(_t) {
                        var vt = typeof Uint8Array < "u" ? Uint8Array : Array
                          , bt = 43
                          , St = 47
                          , At = 48
                          , Et = 97
                          , Pt = 65
                          , It = 45
                          , Dt = 95;
                        function Gt(Bt) {
                            var kt = Bt.charCodeAt(0);
                            return kt === bt || kt === It ? 62 : kt === St || kt === Dt ? 63 : kt < At ? -1 : kt < At + 10 ? kt - At + 26 + 26 : kt < Pt + 26 ? kt - Pt : kt < Et + 26 ? kt - Et + 26 : void 0
                        }
                        _t.toByteArray = function(Bt) {
                            var kt, Ut;
                            if (0 < Bt.length % 4)
                                throw new Error("Invalid string. Length must be a multiple of 4");
                            var Ht = Bt.length
                              , Kt = Bt.charAt(Ht - 2) === "=" ? 2 : Bt.charAt(Ht - 1) === "=" ? 1 : 0
                              , Jt = new vt(3 * Bt.length / 4 - Kt)
                              , or = 0 < Kt ? Bt.length - 4 : Bt.length
                              , ir = 0;
                            function lr(ar) {
                                Jt[ir++] = ar
                            }
                            for (kt = 0; kt < or; kt += 4,
                            0)
                                lr((16711680 & (Ut = Gt(Bt.charAt(kt)) << 18 | Gt(Bt.charAt(kt + 1)) << 12 | Gt(Bt.charAt(kt + 2)) << 6 | Gt(Bt.charAt(kt + 3)))) >> 16),
                                lr((65280 & Ut) >> 8),
                                lr(255 & Ut);
                            return Kt == 2 ? lr(255 & (Ut = Gt(Bt.charAt(kt)) << 2 | Gt(Bt.charAt(kt + 1)) >> 4)) : Kt == 1 && (lr((Ut = Gt(Bt.charAt(kt)) << 10 | Gt(Bt.charAt(kt + 1)) << 4 | Gt(Bt.charAt(kt + 2)) >> 2) >> 8 & 255),
                            lr(255 & Ut)),
                            Jt
                        }
                        ,
                        _t.fromByteArray = function(Bt) {
                            var kt, Ut, Ht, Kt, Jt = Bt.length % 3, or = "";
                            function ir(lr) {
                                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(lr)
                            }
                            for (kt = 0,
                            Ht = Bt.length - Jt; kt < Ht; kt += 3)
                                or += ir((Kt = Ut = (Bt[kt] << 16) + (Bt[kt + 1] << 8) + Bt[kt + 2]) >> 18 & 63) + ir(Kt >> 12 & 63) + ir(Kt >> 6 & 63) + ir(63 & Kt);
                            switch (Jt) {
                            case 1:
                                or += ir((Ut = Bt[Bt.length - 1]) >> 2),
                                or += ir(Ut << 4 & 63),
                                or += "==";
                                break;
                            case 2:
                                or += ir((Ut = (Bt[Bt.length - 2] << 8) + Bt[Bt.length - 1]) >> 10),
                                or += ir(Ut >> 4 & 63),
                                or += ir(Ut << 2 & 63),
                                or += "="
                            }
                            return or
                        }
                    }
                    )(h === void 0 ? this.base64js = {} : h)
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib")
            }
            , {
                buffer: 3,
                lYpoI2: 10
            }],
            3: [function(o, c, h) {
                (function(_, b, bt, nt, it, at, ut, pt, ht) {
                    var _t = o("base64-js")
                      , vt = o("ieee754");
                    function bt(tr, fr, vr) {
                        if (!(this instanceof bt))
                            return new bt(tr,fr,vr);
                        var Zr, rn, hn, Nn, Wn, qn = typeof tr;
                        if (fr === "base64" && qn == "string")
                            for (tr = (Zr = tr).trim ? Zr.trim() : Zr.replace(/^\s+|\s+$/g, ""); tr.length % 4 != 0; )
                                tr += "=";
                        if (qn == "number")
                            rn = ir(tr);
                        else if (qn == "string")
                            rn = bt.byteLength(tr, fr);
                        else {
                            if (qn != "object")
                                throw new Error("First argument needs to be a number, array or string.");
                            rn = ir(tr.length)
                        }
                        if (bt._useTypedArrays ? hn = bt._augment(new Uint8Array(rn)) : ((hn = this).length = rn,
                        hn._isBuffer = !0),
                        bt._useTypedArrays && typeof tr.byteLength == "number")
                            hn._set(tr);
                        else if (lr(Wn = tr) || bt.isBuffer(Wn) || Wn && typeof Wn == "object" && typeof Wn.length == "number")
                            for (Nn = 0; Nn < rn; Nn++)
                                bt.isBuffer(tr) ? hn[Nn] = tr.readUInt8(Nn) : hn[Nn] = tr[Nn];
                        else if (qn == "string")
                            hn.write(tr, 0, fr);
                        else if (qn == "number" && !bt._useTypedArrays && !vr)
                            for (Nn = 0; Nn < rn; Nn++)
                                hn[Nn] = 0;
                        return hn
                    }
                    function St(tr, fr, vr, Zr) {
                        Zr || (Cr(typeof vr == "boolean", "missing or invalid endian"),
                        Cr(fr != null, "missing offset"),
                        Cr(fr + 1 < tr.length, "Trying to read beyond buffer length"));
                        var rn, hn = tr.length;
                        if (!(hn <= fr))
                            return vr ? (rn = tr[fr],
                            fr + 1 < hn && (rn |= tr[fr + 1] << 8)) : (rn = tr[fr] << 8,
                            fr + 1 < hn && (rn |= tr[fr + 1])),
                            rn
                    }
                    function At(tr, fr, vr, Zr) {
                        Zr || (Cr(typeof vr == "boolean", "missing or invalid endian"),
                        Cr(fr != null, "missing offset"),
                        Cr(fr + 3 < tr.length, "Trying to read beyond buffer length"));
                        var rn, hn = tr.length;
                        if (!(hn <= fr))
                            return vr ? (fr + 2 < hn && (rn = tr[fr + 2] << 16),
                            fr + 1 < hn && (rn |= tr[fr + 1] << 8),
                            rn |= tr[fr],
                            fr + 3 < hn && (rn += tr[fr + 3] << 24 >>> 0)) : (fr + 1 < hn && (rn = tr[fr + 1] << 16),
                            fr + 2 < hn && (rn |= tr[fr + 2] << 8),
                            fr + 3 < hn && (rn |= tr[fr + 3]),
                            rn += tr[fr] << 24 >>> 0),
                            rn
                    }
                    function Et(tr, fr, vr, Zr) {
                        if (Zr || (Cr(typeof vr == "boolean", "missing or invalid endian"),
                        Cr(fr != null, "missing offset"),
                        Cr(fr + 1 < tr.length, "Trying to read beyond buffer length")),
                        !(tr.length <= fr)) {
                            var rn = St(tr, fr, vr, !0);
                            return 32768 & rn ? -1 * (65535 - rn + 1) : rn
                        }
                    }
                    function Pt(tr, fr, vr, Zr) {
                        if (Zr || (Cr(typeof vr == "boolean", "missing or invalid endian"),
                        Cr(fr != null, "missing offset"),
                        Cr(fr + 3 < tr.length, "Trying to read beyond buffer length")),
                        !(tr.length <= fr)) {
                            var rn = At(tr, fr, vr, !0);
                            return 2147483648 & rn ? -1 * (4294967295 - rn + 1) : rn
                        }
                    }
                    function It(tr, fr, vr, Zr) {
                        return Zr || (Cr(typeof vr == "boolean", "missing or invalid endian"),
                        Cr(fr + 3 < tr.length, "Trying to read beyond buffer length")),
                        vt.read(tr, fr, vr, 23, 4)
                    }
                    function Dt(tr, fr, vr, Zr) {
                        return Zr || (Cr(typeof vr == "boolean", "missing or invalid endian"),
                        Cr(fr + 7 < tr.length, "Trying to read beyond buffer length")),
                        vt.read(tr, fr, vr, 52, 8)
                    }
                    function Gt(tr, fr, vr, Zr, rn) {
                        rn || (Cr(fr != null, "missing value"),
                        Cr(typeof Zr == "boolean", "missing or invalid endian"),
                        Cr(vr != null, "missing offset"),
                        Cr(vr + 1 < tr.length, "trying to write beyond buffer length"),
                        Ar(fr, 65535));
                        var hn = tr.length;
                        if (!(hn <= vr))
                            for (var Nn = 0, Wn = Math.min(hn - vr, 2); Nn < Wn; Nn++)
                                tr[vr + Nn] = (fr & 255 << 8 * (Zr ? Nn : 1 - Nn)) >>> 8 * (Zr ? Nn : 1 - Nn)
                    }
                    function Bt(tr, fr, vr, Zr, rn) {
                        rn || (Cr(fr != null, "missing value"),
                        Cr(typeof Zr == "boolean", "missing or invalid endian"),
                        Cr(vr != null, "missing offset"),
                        Cr(vr + 3 < tr.length, "trying to write beyond buffer length"),
                        Ar(fr, 4294967295));
                        var hn = tr.length;
                        if (!(hn <= vr))
                            for (var Nn = 0, Wn = Math.min(hn - vr, 4); Nn < Wn; Nn++)
                                tr[vr + Nn] = fr >>> 8 * (Zr ? Nn : 3 - Nn) & 255
                    }
                    function kt(tr, fr, vr, Zr, rn) {
                        rn || (Cr(fr != null, "missing value"),
                        Cr(typeof Zr == "boolean", "missing or invalid endian"),
                        Cr(vr != null, "missing offset"),
                        Cr(vr + 1 < tr.length, "Trying to write beyond buffer length"),
                        wr(fr, 32767, -32768)),
                        tr.length <= vr || Gt(tr, 0 <= fr ? fr : 65535 + fr + 1, vr, Zr, rn)
                    }
                    function Ut(tr, fr, vr, Zr, rn) {
                        rn || (Cr(fr != null, "missing value"),
                        Cr(typeof Zr == "boolean", "missing or invalid endian"),
                        Cr(vr != null, "missing offset"),
                        Cr(vr + 3 < tr.length, "Trying to write beyond buffer length"),
                        wr(fr, 2147483647, -2147483648)),
                        tr.length <= vr || Bt(tr, 0 <= fr ? fr : 4294967295 + fr + 1, vr, Zr, rn)
                    }
                    function Ht(tr, fr, vr, Zr, rn) {
                        rn || (Cr(fr != null, "missing value"),
                        Cr(typeof Zr == "boolean", "missing or invalid endian"),
                        Cr(vr != null, "missing offset"),
                        Cr(vr + 3 < tr.length, "Trying to write beyond buffer length"),
                        Rr(fr, 34028234663852886e22, -34028234663852886e22)),
                        tr.length <= vr || vt.write(tr, fr, vr, Zr, 23, 4)
                    }
                    function Kt(tr, fr, vr, Zr, rn) {
                        rn || (Cr(fr != null, "missing value"),
                        Cr(typeof Zr == "boolean", "missing or invalid endian"),
                        Cr(vr != null, "missing offset"),
                        Cr(vr + 7 < tr.length, "Trying to write beyond buffer length"),
                        Rr(fr, 17976931348623157e292, -17976931348623157e292)),
                        tr.length <= vr || vt.write(tr, fr, vr, Zr, 52, 8)
                    }
                    h.Buffer = bt,
                    h.SlowBuffer = bt,
                    h.INSPECT_MAX_BYTES = 50,
                    bt.poolSize = 8192,
                    bt._useTypedArrays = function() {
                        try {
                            var tr = new ArrayBuffer(0)
                              , fr = new Uint8Array(tr);
                            return fr.foo = function() {
                                return 42
                            }
                            ,
                            fr.foo() === 42 && typeof fr.subarray == "function"
                        } catch {
                            return !1
                        }
                    }(),
                    bt.isEncoding = function(tr) {
                        switch (String(tr).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "binary":
                        case "base64":
                        case "raw":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    ,
                    bt.isBuffer = function(tr) {
                        return !(tr == null || !tr._isBuffer)
                    }
                    ,
                    bt.byteLength = function(tr, fr) {
                        var vr;
                        switch (tr += "",
                        fr || "utf8") {
                        case "hex":
                            vr = tr.length / 2;
                            break;
                        case "utf8":
                        case "utf-8":
                            vr = hr(tr).length;
                            break;
                        case "ascii":
                        case "binary":
                        case "raw":
                            vr = tr.length;
                            break;
                        case "base64":
                            vr = gr(tr).length;
                            break;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            vr = 2 * tr.length;
                            break;
                        default:
                            throw new Error("Unknown encoding")
                        }
                        return vr
                    }
                    ,
                    bt.concat = function(tr, fr) {
                        if (Cr(lr(tr), `Usage: Buffer.concat(list, [totalLength])
list should be an Array.`),
                        tr.length === 0)
                            return new bt(0);
                        if (tr.length === 1)
                            return tr[0];
                        if (typeof fr != "number")
                            for (rn = fr = 0; rn < tr.length; rn++)
                                fr += tr[rn].length;
                        for (var vr = new bt(fr), Zr = 0, rn = 0; rn < tr.length; rn++) {
                            var hn = tr[rn];
                            hn.copy(vr, Zr),
                            Zr += hn.length
                        }
                        return vr
                    }
                    ,
                    bt.prototype.write = function(tr, fr, vr, Zr) {
                        var rn;
                        isFinite(fr) ? isFinite(vr) || (Zr = vr,
                        vr = void 0) : (rn = Zr,
                        Zr = fr,
                        fr = vr,
                        vr = rn),
                        fr = Number(fr) || 0;
                        var hn, Nn, Wn, qn, mo, Ur, nn, xn = this.length - fr;
                        switch ((!vr || xn < (vr = Number(vr))) && (vr = xn),
                        Zr = String(Zr || "utf8").toLowerCase()) {
                        case "hex":
                            hn = function(ur, pr, Ir, jr) {
                                Ir = Number(Ir) || 0;
                                var Qr = ur.length - Ir;
                                (!jr || Qr < (jr = Number(jr))) && (jr = Qr);
                                var Or = pr.length;
                                Cr(Or % 2 == 0, "Invalid hex string"),
                                Or / 2 < jr && (jr = Or / 2);
                                for (var qr = 0; qr < jr; qr++) {
                                    var gn = parseInt(pr.substr(2 * qr, 2), 16);
                                    Cr(!isNaN(gn), "Invalid hex string"),
                                    ur[Ir + qr] = gn
                                }
                                return bt._charsWritten = 2 * qr,
                                qr
                            }(this, tr, fr, vr);
                            break;
                        case "utf8":
                        case "utf-8":
                            mo = tr,
                            Ur = fr,
                            nn = vr,
                            hn = bt._charsWritten = dr(hr(mo), this, Ur, nn);
                            break;
                        case "ascii":
                        case "binary":
                            hn = function(ur, pr, Ir, jr) {
                                return bt._charsWritten = dr(function(Qr) {
                                    for (var Or = [], qr = 0; qr < Qr.length; qr++)
                                        Or.push(255 & Qr.charCodeAt(qr));
                                    return Or
                                }(pr), ur, Ir, jr)
                            }(this, tr, fr, vr);
                            break;
                        case "base64":
                            Nn = tr,
                            Wn = fr,
                            qn = vr,
                            hn = bt._charsWritten = dr(gr(Nn), this, Wn, qn);
                            break;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            hn = function(ur, pr, Ir, jr) {
                                return bt._charsWritten = dr(function(Qr) {
                                    for (var Or, qr, gn, Mn = [], Tn = 0; Tn < Qr.length; Tn++)
                                        qr = (Or = Qr.charCodeAt(Tn)) >> 8,
                                        gn = Or % 256,
                                        Mn.push(gn),
                                        Mn.push(qr);
                                    return Mn
                                }(pr), ur, Ir, jr)
                            }(this, tr, fr, vr);
                            break;
                        default:
                            throw new Error("Unknown encoding")
                        }
                        return hn
                    }
                    ,
                    bt.prototype.toString = function(tr, fr, vr) {
                        var Zr, rn, hn, Nn, Wn = this;
                        if (tr = String(tr || "utf8").toLowerCase(),
                        fr = Number(fr) || 0,
                        (vr = vr !== void 0 ? Number(vr) : vr = Wn.length) === fr)
                            return "";
                        switch (tr) {
                        case "hex":
                            Zr = function(qn, mo, Ur) {
                                var nn = qn.length;
                                (!mo || mo < 0) && (mo = 0),
                                (!Ur || Ur < 0 || nn < Ur) && (Ur = nn);
                                for (var xn = "", ur = mo; ur < Ur; ur++)
                                    xn += ar(qn[ur]);
                                return xn
                            }(Wn, fr, vr);
                            break;
                        case "utf8":
                        case "utf-8":
                            Zr = function(qn, mo, Ur) {
                                var nn = ""
                                  , xn = "";
                                Ur = Math.min(qn.length, Ur);
                                for (var ur = mo; ur < Ur; ur++)
                                    qn[ur] <= 127 ? (nn += cr(xn) + String.fromCharCode(qn[ur]),
                                    xn = "") : xn += "%" + qn[ur].toString(16);
                                return nn + cr(xn)
                            }(Wn, fr, vr);
                            break;
                        case "ascii":
                        case "binary":
                            Zr = function(qn, mo, Ur) {
                                var nn = "";
                                Ur = Math.min(qn.length, Ur);
                                for (var xn = mo; xn < Ur; xn++)
                                    nn += String.fromCharCode(qn[xn]);
                                return nn
                            }(Wn, fr, vr);
                            break;
                        case "base64":
                            rn = Wn,
                            Nn = vr,
                            Zr = (hn = fr) === 0 && Nn === rn.length ? _t.fromByteArray(rn) : _t.fromByteArray(rn.slice(hn, Nn));
                            break;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            Zr = function(qn, mo, Ur) {
                                for (var nn = qn.slice(mo, Ur), xn = "", ur = 0; ur < nn.length; ur += 2)
                                    xn += String.fromCharCode(nn[ur] + 256 * nn[ur + 1]);
                                return xn
                            }(Wn, fr, vr);
                            break;
                        default:
                            throw new Error("Unknown encoding")
                        }
                        return Zr
                    }
                    ,
                    bt.prototype.toJSON = function() {
                        return {
                            type: "Buffer",
                            data: Array.prototype.slice.call(this._arr || this, 0)
                        }
                    }
                    ,
                    bt.prototype.copy = function(tr, fr, vr, Zr) {
                        if (vr = vr || 0,
                        Zr || Zr === 0 || (Zr = this.length),
                        fr = fr || 0,
                        Zr !== vr && tr.length !== 0 && this.length !== 0) {
                            Cr(vr <= Zr, "sourceEnd < sourceStart"),
                            Cr(0 <= fr && fr < tr.length, "targetStart out of bounds"),
                            Cr(0 <= vr && vr < this.length, "sourceStart out of bounds"),
                            Cr(0 <= Zr && Zr <= this.length, "sourceEnd out of bounds"),
                            Zr > this.length && (Zr = this.length),
                            tr.length - fr < Zr - vr && (Zr = tr.length - fr + vr);
                            var rn = Zr - vr;
                            if (rn < 100 || !bt._useTypedArrays)
                                for (var hn = 0; hn < rn; hn++)
                                    tr[hn + fr] = this[hn + vr];
                            else
                                tr._set(this.subarray(vr, vr + rn), fr)
                        }
                    }
                    ,
                    bt.prototype.slice = function(tr, fr) {
                        var vr = this.length;
                        if (tr = or(tr, vr, 0),
                        fr = or(fr, vr, vr),
                        bt._useTypedArrays)
                            return bt._augment(this.subarray(tr, fr));
                        for (var Zr = fr - tr, rn = new bt(Zr,void 0,!0), hn = 0; hn < Zr; hn++)
                            rn[hn] = this[hn + tr];
                        return rn
                    }
                    ,
                    bt.prototype.get = function(tr) {
                        return console.log(".get() is deprecated. Access using array indexes instead."),
                        this.readUInt8(tr)
                    }
                    ,
                    bt.prototype.set = function(tr, fr) {
                        return console.log(".set() is deprecated. Access using array indexes instead."),
                        this.writeUInt8(tr, fr)
                    }
                    ,
                    bt.prototype.readUInt8 = function(tr, fr) {
                        if (fr || (Cr(tr != null, "missing offset"),
                        Cr(tr < this.length, "Trying to read beyond buffer length")),
                        !(tr >= this.length))
                            return this[tr]
                    }
                    ,
                    bt.prototype.readUInt16LE = function(tr, fr) {
                        return St(this, tr, !0, fr)
                    }
                    ,
                    bt.prototype.readUInt16BE = function(tr, fr) {
                        return St(this, tr, !1, fr)
                    }
                    ,
                    bt.prototype.readUInt32LE = function(tr, fr) {
                        return At(this, tr, !0, fr)
                    }
                    ,
                    bt.prototype.readUInt32BE = function(tr, fr) {
                        return At(this, tr, !1, fr)
                    }
                    ,
                    bt.prototype.readInt8 = function(tr, fr) {
                        if (fr || (Cr(tr != null, "missing offset"),
                        Cr(tr < this.length, "Trying to read beyond buffer length")),
                        !(tr >= this.length))
                            return 128 & this[tr] ? -1 * (255 - this[tr] + 1) : this[tr]
                    }
                    ,
                    bt.prototype.readInt16LE = function(tr, fr) {
                        return Et(this, tr, !0, fr)
                    }
                    ,
                    bt.prototype.readInt16BE = function(tr, fr) {
                        return Et(this, tr, !1, fr)
                    }
                    ,
                    bt.prototype.readInt32LE = function(tr, fr) {
                        return Pt(this, tr, !0, fr)
                    }
                    ,
                    bt.prototype.readInt32BE = function(tr, fr) {
                        return Pt(this, tr, !1, fr)
                    }
                    ,
                    bt.prototype.readFloatLE = function(tr, fr) {
                        return It(this, tr, !0, fr)
                    }
                    ,
                    bt.prototype.readFloatBE = function(tr, fr) {
                        return It(this, tr, !1, fr)
                    }
                    ,
                    bt.prototype.readDoubleLE = function(tr, fr) {
                        return Dt(this, tr, !0, fr)
                    }
                    ,
                    bt.prototype.readDoubleBE = function(tr, fr) {
                        return Dt(this, tr, !1, fr)
                    }
                    ,
                    bt.prototype.writeUInt8 = function(tr, fr, vr) {
                        vr || (Cr(tr != null, "missing value"),
                        Cr(fr != null, "missing offset"),
                        Cr(fr < this.length, "trying to write beyond buffer length"),
                        Ar(tr, 255)),
                        fr >= this.length || (this[fr] = tr)
                    }
                    ,
                    bt.prototype.writeUInt16LE = function(tr, fr, vr) {
                        Gt(this, tr, fr, !0, vr)
                    }
                    ,
                    bt.prototype.writeUInt16BE = function(tr, fr, vr) {
                        Gt(this, tr, fr, !1, vr)
                    }
                    ,
                    bt.prototype.writeUInt32LE = function(tr, fr, vr) {
                        Bt(this, tr, fr, !0, vr)
                    }
                    ,
                    bt.prototype.writeUInt32BE = function(tr, fr, vr) {
                        Bt(this, tr, fr, !1, vr)
                    }
                    ,
                    bt.prototype.writeInt8 = function(tr, fr, vr) {
                        vr || (Cr(tr != null, "missing value"),
                        Cr(fr != null, "missing offset"),
                        Cr(fr < this.length, "Trying to write beyond buffer length"),
                        wr(tr, 127, -128)),
                        fr >= this.length || (0 <= tr ? this.writeUInt8(tr, fr, vr) : this.writeUInt8(255 + tr + 1, fr, vr))
                    }
                    ,
                    bt.prototype.writeInt16LE = function(tr, fr, vr) {
                        kt(this, tr, fr, !0, vr)
                    }
                    ,
                    bt.prototype.writeInt16BE = function(tr, fr, vr) {
                        kt(this, tr, fr, !1, vr)
                    }
                    ,
                    bt.prototype.writeInt32LE = function(tr, fr, vr) {
                        Ut(this, tr, fr, !0, vr)
                    }
                    ,
                    bt.prototype.writeInt32BE = function(tr, fr, vr) {
                        Ut(this, tr, fr, !1, vr)
                    }
                    ,
                    bt.prototype.writeFloatLE = function(tr, fr, vr) {
                        Ht(this, tr, fr, !0, vr)
                    }
                    ,
                    bt.prototype.writeFloatBE = function(tr, fr, vr) {
                        Ht(this, tr, fr, !1, vr)
                    }
                    ,
                    bt.prototype.writeDoubleLE = function(tr, fr, vr) {
                        Kt(this, tr, fr, !0, vr)
                    }
                    ,
                    bt.prototype.writeDoubleBE = function(tr, fr, vr) {
                        Kt(this, tr, fr, !1, vr)
                    }
                    ,
                    bt.prototype.fill = function(tr, fr, vr) {
                        if (tr = tr || 0,
                        fr = fr || 0,
                        vr = vr || this.length,
                        typeof tr == "string" && (tr = tr.charCodeAt(0)),
                        Cr(typeof tr == "number" && !isNaN(tr), "value is not a number"),
                        Cr(fr <= vr, "end < start"),
                        vr !== fr && this.length !== 0) {
                            Cr(0 <= fr && fr < this.length, "start out of bounds"),
                            Cr(0 <= vr && vr <= this.length, "end out of bounds");
                            for (var Zr = fr; Zr < vr; Zr++)
                                this[Zr] = tr
                        }
                    }
                    ,
                    bt.prototype.inspect = function() {
                        for (var tr = [], fr = this.length, vr = 0; vr < fr; vr++)
                            if (tr[vr] = ar(this[vr]),
                            vr === h.INSPECT_MAX_BYTES) {
                                tr[vr + 1] = "...";
                                break
                            }
                        return "<Buffer " + tr.join(" ") + ">"
                    }
                    ,
                    bt.prototype.toArrayBuffer = function() {
                        if (typeof Uint8Array > "u")
                            throw new Error("Buffer.toArrayBuffer not supported in this browser");
                        if (bt._useTypedArrays)
                            return new bt(this).buffer;
                        for (var tr = new Uint8Array(this.length), fr = 0, vr = tr.length; fr < vr; fr += 1)
                            tr[fr] = this[fr];
                        return tr.buffer
                    }
                    ;
                    var Jt = bt.prototype;
                    function or(tr, fr, vr) {
                        return typeof tr != "number" ? vr : fr <= (tr = ~~tr) ? fr : 0 <= tr || 0 <= (tr += fr) ? tr : 0
                    }
                    function ir(tr) {
                        return (tr = ~~Math.ceil(+tr)) < 0 ? 0 : tr
                    }
                    function lr(tr) {
                        return (Array.isArray || function(fr) {
                            return Object.prototype.toString.call(fr) === "[object Array]"
                        }
                        )(tr)
                    }
                    function ar(tr) {
                        return tr < 16 ? "0" + tr.toString(16) : tr.toString(16)
                    }
                    function hr(tr) {
                        for (var fr = [], vr = 0; vr < tr.length; vr++) {
                            var Zr = tr.charCodeAt(vr);
                            if (Zr <= 127)
                                fr.push(tr.charCodeAt(vr));
                            else {
                                var rn = vr;
                                55296 <= Zr && Zr <= 57343 && vr++;
                                for (var hn = encodeURIComponent(tr.slice(rn, vr + 1)).substr(1).split("%"), Nn = 0; Nn < hn.length; Nn++)
                                    fr.push(parseInt(hn[Nn], 16))
                            }
                        }
                        return fr
                    }
                    function gr(tr) {
                        return _t.toByteArray(tr)
                    }
                    function dr(tr, fr, vr, Zr) {
                        for (var rn = 0; rn < Zr && !(rn + vr >= fr.length || rn >= tr.length); rn++)
                            fr[rn + vr] = tr[rn];
                        return rn
                    }
                    function cr(tr) {
                        try {
                            return decodeURIComponent(tr)
                        } catch {
                            return "�"
                        }
                    }
                    function Ar(tr, fr) {
                        Cr(typeof tr == "number", "cannot write a non-number as a number"),
                        Cr(0 <= tr, "specified a negative value for writing an unsigned value"),
                        Cr(tr <= fr, "value is larger than maximum value for type"),
                        Cr(Math.floor(tr) === tr, "value has a fractional component")
                    }
                    function wr(tr, fr, vr) {
                        Cr(typeof tr == "number", "cannot write a non-number as a number"),
                        Cr(tr <= fr, "value larger than maximum allowed value"),
                        Cr(vr <= tr, "value smaller than minimum allowed value"),
                        Cr(Math.floor(tr) === tr, "value has a fractional component")
                    }
                    function Rr(tr, fr, vr) {
                        Cr(typeof tr == "number", "cannot write a non-number as a number"),
                        Cr(tr <= fr, "value larger than maximum allowed value"),
                        Cr(vr <= tr, "value smaller than minimum allowed value")
                    }
                    function Cr(tr, fr) {
                        if (!tr)
                            throw new Error(fr || "Failed assertion")
                    }
                    bt._augment = function(tr) {
                        return tr._isBuffer = !0,
                        tr._get = tr.get,
                        tr._set = tr.set,
                        tr.get = Jt.get,
                        tr.set = Jt.set,
                        tr.write = Jt.write,
                        tr.toString = Jt.toString,
                        tr.toLocaleString = Jt.toString,
                        tr.toJSON = Jt.toJSON,
                        tr.copy = Jt.copy,
                        tr.slice = Jt.slice,
                        tr.readUInt8 = Jt.readUInt8,
                        tr.readUInt16LE = Jt.readUInt16LE,
                        tr.readUInt16BE = Jt.readUInt16BE,
                        tr.readUInt32LE = Jt.readUInt32LE,
                        tr.readUInt32BE = Jt.readUInt32BE,
                        tr.readInt8 = Jt.readInt8,
                        tr.readInt16LE = Jt.readInt16LE,
                        tr.readInt16BE = Jt.readInt16BE,
                        tr.readInt32LE = Jt.readInt32LE,
                        tr.readInt32BE = Jt.readInt32BE,
                        tr.readFloatLE = Jt.readFloatLE,
                        tr.readFloatBE = Jt.readFloatBE,
                        tr.readDoubleLE = Jt.readDoubleLE,
                        tr.readDoubleBE = Jt.readDoubleBE,
                        tr.writeUInt8 = Jt.writeUInt8,
                        tr.writeUInt16LE = Jt.writeUInt16LE,
                        tr.writeUInt16BE = Jt.writeUInt16BE,
                        tr.writeUInt32LE = Jt.writeUInt32LE,
                        tr.writeUInt32BE = Jt.writeUInt32BE,
                        tr.writeInt8 = Jt.writeInt8,
                        tr.writeInt16LE = Jt.writeInt16LE,
                        tr.writeInt16BE = Jt.writeInt16BE,
                        tr.writeInt32LE = Jt.writeInt32LE,
                        tr.writeInt32BE = Jt.writeInt32BE,
                        tr.writeFloatLE = Jt.writeFloatLE,
                        tr.writeFloatBE = Jt.writeFloatBE,
                        tr.writeDoubleLE = Jt.writeDoubleLE,
                        tr.writeDoubleBE = Jt.writeDoubleBE,
                        tr.fill = Jt.fill,
                        tr.inspect = Jt.inspect,
                        tr.toArrayBuffer = Jt.toArrayBuffer,
                        tr
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer")
            }
            , {
                "base64-js": 2,
                buffer: 3,
                ieee754: 11,
                lYpoI2: 10
            }],
            4: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    _e = o("buffer").Buffer;
                    var _t = new _e(4);
                    _t.fill(0),
                    c.exports = {
                        hash: function(vt, bt, St, At) {
                            return _e.isBuffer(vt) || (vt = new _e(vt)),
                            function(Et, Pt, It) {
                                for (var Dt = new _e(Pt), Gt = It ? Dt.writeInt32BE : Dt.writeInt32LE, Bt = 0; Bt < Et.length; Bt++)
                                    Gt.call(Dt, Et[Bt], 4 * Bt, !0);
                                return Dt
                            }(bt(function(Et, Pt) {
                                var It;
                                Et.length % 4 != 0 && (It = Et.length + (4 - Et.length % 4),
                                Et = _e.concat([Et, _t], It));
                                for (var Dt = [], Gt = Pt ? Et.readInt32BE : Et.readInt32LE, Bt = 0; Bt < Et.length; Bt += 4)
                                    Dt.push(Gt.call(Et, Bt));
                                return Dt
                            }(vt, At), 8 * vt.length), St, At)
                        }
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
            }
            , {
                buffer: 3,
                lYpoI2: 10
            }],
            5: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    _e = o("buffer").Buffer;
                    var _t = o("./sha")
                      , vt = o("./sha256")
                      , bt = o("./rng")
                      , St = {
                        sha1: _t,
                        sha256: vt,
                        md5: o("./md5")
                    }
                      , At = 64
                      , Et = new _e(At);
                    function Pt(Dt, Gt) {
                        var Bt = St[Dt = Dt || "sha1"]
                          , kt = [];
                        return Bt || It("algorithm:", Dt, "is not yet supported"),
                        {
                            update: function(Ut) {
                                return _e.isBuffer(Ut) || (Ut = new _e(Ut)),
                                kt.push(Ut),
                                Ut.length,
                                this
                            },
                            digest: function(Ut) {
                                var Ht = _e.concat(kt)
                                  , Kt = Gt ? function(Jt, or, ir) {
                                    _e.isBuffer(or) || (or = new _e(or)),
                                    _e.isBuffer(ir) || (ir = new _e(ir)),
                                    or.length > At ? or = Jt(or) : or.length < At && (or = _e.concat([or, Et], At));
                                    for (var lr = new _e(At), ar = new _e(At), hr = 0; hr < At; hr++)
                                        lr[hr] = 54 ^ or[hr],
                                        ar[hr] = 92 ^ or[hr];
                                    var gr = Jt(_e.concat([lr, ir]));
                                    return Jt(_e.concat([ar, gr]))
                                }(Bt, Gt, Ht) : Bt(Ht);
                                return kt = null,
                                Ut ? Kt.toString(Ut) : Kt
                            }
                        }
                    }
                    function It() {
                        var Dt = [].slice.call(arguments).join(" ");
                        throw new Error([Dt, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join(`
`))
                    }
                    Et.fill(0),
                    h.createHash = function(Dt) {
                        return Pt(Dt)
                    }
                    ,
                    h.createHmac = Pt,
                    h.randomBytes = function(Dt, Gt) {
                        if (!Gt || !Gt.call)
                            return new _e(bt(Dt));
                        try {
                            Gt.call(this, void 0, new _e(bt(Dt)))
                        } catch (Bt) {
                            Gt(Bt)
                        }
                    }
                    ,
                    function(Dt, Gt) {
                        for (var Bt in Dt)
                            Gt(Dt[Bt])
                    }(["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], function(Dt) {
                        h[Dt] = function() {
                            It("sorry,", Dt, "is not implemented yet")
                        }
                    })
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
            }
            , {
                "./md5": 6,
                "./rng": 7,
                "./sha": 8,
                "./sha256": 9,
                buffer: 3,
                lYpoI2: 10
            }],
            6: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    var _t = o("./helpers");
                    function vt(Dt, Gt) {
                        Dt[Gt >> 5] |= 128 << Gt % 32,
                        Dt[14 + (Gt + 64 >>> 9 << 4)] = Gt;
                        for (var Bt = 1732584193, kt = -271733879, Ut = -1732584194, Ht = 271733878, Kt = 0; Kt < Dt.length; Kt += 16) {
                            var Jt = Bt
                              , or = kt
                              , ir = Ut
                              , lr = Ht;
                            Bt = St(Bt, kt, Ut, Ht, Dt[Kt + 0], 7, -680876936),
                            Ht = St(Ht, Bt, kt, Ut, Dt[Kt + 1], 12, -389564586),
                            Ut = St(Ut, Ht, Bt, kt, Dt[Kt + 2], 17, 606105819),
                            kt = St(kt, Ut, Ht, Bt, Dt[Kt + 3], 22, -1044525330),
                            Bt = St(Bt, kt, Ut, Ht, Dt[Kt + 4], 7, -176418897),
                            Ht = St(Ht, Bt, kt, Ut, Dt[Kt + 5], 12, 1200080426),
                            Ut = St(Ut, Ht, Bt, kt, Dt[Kt + 6], 17, -1473231341),
                            kt = St(kt, Ut, Ht, Bt, Dt[Kt + 7], 22, -45705983),
                            Bt = St(Bt, kt, Ut, Ht, Dt[Kt + 8], 7, 1770035416),
                            Ht = St(Ht, Bt, kt, Ut, Dt[Kt + 9], 12, -1958414417),
                            Ut = St(Ut, Ht, Bt, kt, Dt[Kt + 10], 17, -42063),
                            kt = St(kt, Ut, Ht, Bt, Dt[Kt + 11], 22, -1990404162),
                            Bt = St(Bt, kt, Ut, Ht, Dt[Kt + 12], 7, 1804603682),
                            Ht = St(Ht, Bt, kt, Ut, Dt[Kt + 13], 12, -40341101),
                            Ut = St(Ut, Ht, Bt, kt, Dt[Kt + 14], 17, -1502002290),
                            Bt = At(Bt, kt = St(kt, Ut, Ht, Bt, Dt[Kt + 15], 22, 1236535329), Ut, Ht, Dt[Kt + 1], 5, -165796510),
                            Ht = At(Ht, Bt, kt, Ut, Dt[Kt + 6], 9, -1069501632),
                            Ut = At(Ut, Ht, Bt, kt, Dt[Kt + 11], 14, 643717713),
                            kt = At(kt, Ut, Ht, Bt, Dt[Kt + 0], 20, -373897302),
                            Bt = At(Bt, kt, Ut, Ht, Dt[Kt + 5], 5, -701558691),
                            Ht = At(Ht, Bt, kt, Ut, Dt[Kt + 10], 9, 38016083),
                            Ut = At(Ut, Ht, Bt, kt, Dt[Kt + 15], 14, -660478335),
                            kt = At(kt, Ut, Ht, Bt, Dt[Kt + 4], 20, -405537848),
                            Bt = At(Bt, kt, Ut, Ht, Dt[Kt + 9], 5, 568446438),
                            Ht = At(Ht, Bt, kt, Ut, Dt[Kt + 14], 9, -1019803690),
                            Ut = At(Ut, Ht, Bt, kt, Dt[Kt + 3], 14, -187363961),
                            kt = At(kt, Ut, Ht, Bt, Dt[Kt + 8], 20, 1163531501),
                            Bt = At(Bt, kt, Ut, Ht, Dt[Kt + 13], 5, -1444681467),
                            Ht = At(Ht, Bt, kt, Ut, Dt[Kt + 2], 9, -51403784),
                            Ut = At(Ut, Ht, Bt, kt, Dt[Kt + 7], 14, 1735328473),
                            Bt = Et(Bt, kt = At(kt, Ut, Ht, Bt, Dt[Kt + 12], 20, -1926607734), Ut, Ht, Dt[Kt + 5], 4, -378558),
                            Ht = Et(Ht, Bt, kt, Ut, Dt[Kt + 8], 11, -2022574463),
                            Ut = Et(Ut, Ht, Bt, kt, Dt[Kt + 11], 16, 1839030562),
                            kt = Et(kt, Ut, Ht, Bt, Dt[Kt + 14], 23, -35309556),
                            Bt = Et(Bt, kt, Ut, Ht, Dt[Kt + 1], 4, -1530992060),
                            Ht = Et(Ht, Bt, kt, Ut, Dt[Kt + 4], 11, 1272893353),
                            Ut = Et(Ut, Ht, Bt, kt, Dt[Kt + 7], 16, -155497632),
                            kt = Et(kt, Ut, Ht, Bt, Dt[Kt + 10], 23, -1094730640),
                            Bt = Et(Bt, kt, Ut, Ht, Dt[Kt + 13], 4, 681279174),
                            Ht = Et(Ht, Bt, kt, Ut, Dt[Kt + 0], 11, -358537222),
                            Ut = Et(Ut, Ht, Bt, kt, Dt[Kt + 3], 16, -722521979),
                            kt = Et(kt, Ut, Ht, Bt, Dt[Kt + 6], 23, 76029189),
                            Bt = Et(Bt, kt, Ut, Ht, Dt[Kt + 9], 4, -640364487),
                            Ht = Et(Ht, Bt, kt, Ut, Dt[Kt + 12], 11, -421815835),
                            Ut = Et(Ut, Ht, Bt, kt, Dt[Kt + 15], 16, 530742520),
                            Bt = Pt(Bt, kt = Et(kt, Ut, Ht, Bt, Dt[Kt + 2], 23, -995338651), Ut, Ht, Dt[Kt + 0], 6, -198630844),
                            Ht = Pt(Ht, Bt, kt, Ut, Dt[Kt + 7], 10, 1126891415),
                            Ut = Pt(Ut, Ht, Bt, kt, Dt[Kt + 14], 15, -1416354905),
                            kt = Pt(kt, Ut, Ht, Bt, Dt[Kt + 5], 21, -57434055),
                            Bt = Pt(Bt, kt, Ut, Ht, Dt[Kt + 12], 6, 1700485571),
                            Ht = Pt(Ht, Bt, kt, Ut, Dt[Kt + 3], 10, -1894986606),
                            Ut = Pt(Ut, Ht, Bt, kt, Dt[Kt + 10], 15, -1051523),
                            kt = Pt(kt, Ut, Ht, Bt, Dt[Kt + 1], 21, -2054922799),
                            Bt = Pt(Bt, kt, Ut, Ht, Dt[Kt + 8], 6, 1873313359),
                            Ht = Pt(Ht, Bt, kt, Ut, Dt[Kt + 15], 10, -30611744),
                            Ut = Pt(Ut, Ht, Bt, kt, Dt[Kt + 6], 15, -1560198380),
                            kt = Pt(kt, Ut, Ht, Bt, Dt[Kt + 13], 21, 1309151649),
                            Bt = Pt(Bt, kt, Ut, Ht, Dt[Kt + 4], 6, -145523070),
                            Ht = Pt(Ht, Bt, kt, Ut, Dt[Kt + 11], 10, -1120210379),
                            Ut = Pt(Ut, Ht, Bt, kt, Dt[Kt + 2], 15, 718787259),
                            kt = Pt(kt, Ut, Ht, Bt, Dt[Kt + 9], 21, -343485551),
                            Bt = It(Bt, Jt),
                            kt = It(kt, or),
                            Ut = It(Ut, ir),
                            Ht = It(Ht, lr)
                        }
                        return Array(Bt, kt, Ut, Ht)
                    }
                    function bt(Dt, Gt, Bt, kt, Ut, Ht) {
                        return It((Kt = It(It(Gt, Dt), It(kt, Ht))) << (Jt = Ut) | Kt >>> 32 - Jt, Bt);
                        var Kt, Jt
                    }
                    function St(Dt, Gt, Bt, kt, Ut, Ht, Kt) {
                        return bt(Gt & Bt | ~Gt & kt, Dt, Gt, Ut, Ht, Kt)
                    }
                    function At(Dt, Gt, Bt, kt, Ut, Ht, Kt) {
                        return bt(Gt & kt | Bt & ~kt, Dt, Gt, Ut, Ht, Kt)
                    }
                    function Et(Dt, Gt, Bt, kt, Ut, Ht, Kt) {
                        return bt(Gt ^ Bt ^ kt, Dt, Gt, Ut, Ht, Kt)
                    }
                    function Pt(Dt, Gt, Bt, kt, Ut, Ht, Kt) {
                        return bt(Bt ^ (Gt | ~kt), Dt, Gt, Ut, Ht, Kt)
                    }
                    function It(Dt, Gt) {
                        var Bt = (65535 & Dt) + (65535 & Gt);
                        return (Dt >> 16) + (Gt >> 16) + (Bt >> 16) << 16 | 65535 & Bt
                    }
                    c.exports = function(Dt) {
                        return _t.hash(Dt, vt, 16)
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
            }
            , {
                "./helpers": 4,
                buffer: 3,
                lYpoI2: 10
            }],
            7: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    var _t;
                    _t = function(vt) {
                        for (var bt, St = new Array(vt), At = 0; At < vt; At++)
                            !(3 & At) && (bt = 4294967296 * Math.random()),
                            St[At] = bt >>> ((3 & At) << 3) & 255;
                        return St
                    }
                    ,
                    c.exports = _t
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
            }
            , {
                buffer: 3,
                lYpoI2: 10
            }],
            8: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    var _t = o("./helpers");
                    function vt(At, Et) {
                        At[Et >> 5] |= 128 << 24 - Et % 32,
                        At[15 + (Et + 64 >> 9 << 4)] = Et;
                        for (var Pt, It, Dt, Gt, Bt, kt = Array(80), Ut = 1732584193, Ht = -271733879, Kt = -1732584194, Jt = 271733878, or = -1009589776, ir = 0; ir < At.length; ir += 16) {
                            for (var lr = Ut, ar = Ht, hr = Kt, gr = Jt, dr = or, cr = 0; cr < 80; cr++) {
                                kt[cr] = cr < 16 ? At[ir + cr] : St(kt[cr - 3] ^ kt[cr - 8] ^ kt[cr - 14] ^ kt[cr - 16], 1);
                                var Ar = bt(bt(St(Ut, 5), (Dt = Ht,
                                Gt = Kt,
                                Bt = Jt,
                                (It = cr) < 20 ? Dt & Gt | ~Dt & Bt : !(It < 40) && It < 60 ? Dt & Gt | Dt & Bt | Gt & Bt : Dt ^ Gt ^ Bt)), bt(bt(or, kt[cr]), (Pt = cr) < 20 ? 1518500249 : Pt < 40 ? 1859775393 : Pt < 60 ? -1894007588 : -899497514));
                                or = Jt,
                                Jt = Kt,
                                Kt = St(Ht, 30),
                                Ht = Ut,
                                Ut = Ar
                            }
                            Ut = bt(Ut, lr),
                            Ht = bt(Ht, ar),
                            Kt = bt(Kt, hr),
                            Jt = bt(Jt, gr),
                            or = bt(or, dr)
                        }
                        return Array(Ut, Ht, Kt, Jt, or)
                    }
                    function bt(At, Et) {
                        var Pt = (65535 & At) + (65535 & Et);
                        return (At >> 16) + (Et >> 16) + (Pt >> 16) << 16 | 65535 & Pt
                    }
                    function St(At, Et) {
                        return At << Et | At >>> 32 - Et
                    }
                    c.exports = function(At) {
                        return _t.hash(At, vt, 20, !0)
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
            }
            , {
                "./helpers": 4,
                buffer: 3,
                lYpoI2: 10
            }],
            9: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    function _t(At, Et) {
                        var Pt = (65535 & At) + (65535 & Et);
                        return (At >> 16) + (Et >> 16) + (Pt >> 16) << 16 | 65535 & Pt
                    }
                    function vt(At, Et) {
                        return At >>> Et | At << 32 - Et
                    }
                    function bt(At, Et) {
                        var Pt, It, Dt, Gt, Bt, kt, Ut, Ht, Kt, Jt, or = new Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298), ir = new Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225), lr = new Array(64);
                        At[Et >> 5] |= 128 << 24 - Et % 32,
                        At[15 + (Et + 64 >> 9 << 4)] = Et;
                        for (var ar, hr, gr, dr, cr, Ar, wr, Rr, Cr = 0; Cr < At.length; Cr += 16) {
                            Pt = ir[0],
                            It = ir[1],
                            Dt = ir[2],
                            Gt = ir[3],
                            Bt = ir[4],
                            kt = ir[5],
                            Ut = ir[6],
                            Ht = ir[7];
                            for (var tr = 0; tr < 64; tr++)
                                lr[tr] = tr < 16 ? At[tr + Cr] : _t(_t(_t(vt(Rr = lr[tr - 2], 17) ^ vt(Rr, 19) ^ Rr >>> 10, lr[tr - 7]), vt(wr = lr[tr - 15], 7) ^ vt(wr, 18) ^ wr >>> 3), lr[tr - 16]),
                                Kt = _t(_t(_t(_t(Ht, vt(Ar = Bt, 6) ^ vt(Ar, 11) ^ vt(Ar, 25)), (cr = Bt) & kt ^ ~cr & Ut), or[tr]), lr[tr]),
                                Jt = _t(vt(dr = Pt, 2) ^ vt(dr, 13) ^ vt(dr, 22), (ar = Pt) & (hr = It) ^ ar & (gr = Dt) ^ hr & gr),
                                Ht = Ut,
                                Ut = kt,
                                kt = Bt,
                                Bt = _t(Gt, Kt),
                                Gt = Dt,
                                Dt = It,
                                It = Pt,
                                Pt = _t(Kt, Jt);
                            ir[0] = _t(Pt, ir[0]),
                            ir[1] = _t(It, ir[1]),
                            ir[2] = _t(Dt, ir[2]),
                            ir[3] = _t(Gt, ir[3]),
                            ir[4] = _t(Bt, ir[4]),
                            ir[5] = _t(kt, ir[5]),
                            ir[6] = _t(Ut, ir[6]),
                            ir[7] = _t(Ht, ir[7])
                        }
                        return ir
                    }
                    var St = o("./helpers");
                    c.exports = function(At) {
                        return St.hash(At, bt, 32, !0)
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify")
            }
            , {
                "./helpers": 4,
                buffer: 3,
                lYpoI2: 10
            }],
            10: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    function _t() {}
                    (_ = c.exports = {}).nextTick = function() {
                        var vt = typeof window < "u" && window.setImmediate
                          , bt = typeof window < "u" && window.postMessage && window.addEventListener;
                        if (vt)
                            return function(At) {
                                return window.setImmediate(At)
                            }
                            ;
                        if (bt) {
                            var St = [];
                            return window.addEventListener("message", function(At) {
                                var Et = At.source;
                                Et !== window && Et !== null || At.data !== "process-tick" || (At.stopPropagation(),
                                0 < St.length && St.shift()())
                            }, !0),
                            function(At) {
                                St.push(At),
                                window.postMessage("process-tick", "*")
                            }
                        }
                        return function(At) {
                            setTimeout(At, 0)
                        }
                    }(),
                    _.title = "browser",
                    _.browser = !0,
                    _.env = {},
                    _.argv = [],
                    _.on = _t,
                    _.addListener = _t,
                    _.once = _t,
                    _.off = _t,
                    _.removeListener = _t,
                    _.removeAllListeners = _t,
                    _.emit = _t,
                    _.binding = function(vt) {
                        throw new Error("process.binding is not supported")
                    }
                    ,
                    _.cwd = function() {
                        return "/"
                    }
                    ,
                    _.chdir = function(vt) {
                        throw new Error("process.chdir is not supported")
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process")
            }
            , {
                buffer: 3,
                lYpoI2: 10
            }],
            11: [function(o, c, h) {
                (function(_, b, _e, nt, it, at, ut, pt, ht) {
                    h.read = function(_t, vt, bt, St, At) {
                        var Et, Pt, It = 8 * At - St - 1, Dt = (1 << It) - 1, Gt = Dt >> 1, Bt = -7, kt = bt ? At - 1 : 0, Ut = bt ? -1 : 1, Ht = _t[vt + kt];
                        for (kt += Ut,
                        Et = Ht & (1 << -Bt) - 1,
                        Ht >>= -Bt,
                        Bt += It; 0 < Bt; Et = 256 * Et + _t[vt + kt],
                        kt += Ut,
                        Bt -= 8)
                            ;
                        for (Pt = Et & (1 << -Bt) - 1,
                        Et >>= -Bt,
                        Bt += St; 0 < Bt; Pt = 256 * Pt + _t[vt + kt],
                        kt += Ut,
                        Bt -= 8)
                            ;
                        if (Et === 0)
                            Et = 1 - Gt;
                        else {
                            if (Et === Dt)
                                return Pt ? NaN : 1 / 0 * (Ht ? -1 : 1);
                            Pt += Math.pow(2, St),
                            Et -= Gt
                        }
                        return (Ht ? -1 : 1) * Pt * Math.pow(2, Et - St)
                    }
                    ,
                    h.write = function(_t, vt, bt, St, At, Et) {
                        var Pt, It, Dt, Gt = 8 * Et - At - 1, Bt = (1 << Gt) - 1, kt = Bt >> 1, Ut = At === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ht = St ? 0 : Et - 1, Kt = St ? 1 : -1, Jt = vt < 0 || vt === 0 && 1 / vt < 0 ? 1 : 0;
                        for (vt = Math.abs(vt),
                        isNaN(vt) || vt === 1 / 0 ? (It = isNaN(vt) ? 1 : 0,
                        Pt = Bt) : (Pt = Math.floor(Math.log(vt) / Math.LN2),
                        vt * (Dt = Math.pow(2, -Pt)) < 1 && (Pt--,
                        Dt *= 2),
                        2 <= (vt += 1 <= Pt + kt ? Ut / Dt : Ut * Math.pow(2, 1 - kt)) * Dt && (Pt++,
                        Dt /= 2),
                        Bt <= Pt + kt ? (It = 0,
                        Pt = Bt) : 1 <= Pt + kt ? (It = (vt * Dt - 1) * Math.pow(2, At),
                        Pt += kt) : (It = vt * Math.pow(2, kt - 1) * Math.pow(2, At),
                        Pt = 0)); 8 <= At; _t[bt + Ht] = 255 & It,
                        Ht += Kt,
                        It /= 256,
                        At -= 8)
                            ;
                        for (Pt = Pt << At | It,
                        Gt += At; 0 < Gt; _t[bt + Ht] = 255 & Pt,
                        Ht += Kt,
                        Pt /= 256,
                        Gt -= 8)
                            ;
                        _t[bt + Ht - Kt] |= 128 * Jt
                    }
                }
                ).call(this, o("lYpoI2"), typeof self < "u" ? self : typeof window < "u" ? window : {}, o("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/ieee754/index.js", "/node_modules/ieee754")
            }
            , {
                buffer: 3,
                lYpoI2: 10
            }]
        }, {}, [1])(1)
    },
    391: function(d) {
        var o = function() {
            function c(bt) {
                return ut(bt, pt(at(ht(bt.length), bt), 1 / bt.length))
            }
            function h(bt) {
                return at(_t(bt), bt)
            }
            function _(bt, St) {
                return pt(bt, St ? 1 / (bt.length - 1) : 1 / bt.length)
            }
            function b(bt) {
                var St = function(Pt) {
                    var It, Dt = Math.pow(2, -52), Gt = 1e-64 / Dt, Bt = 0, kt = 0, Ut = 0, Ht = 0, Kt = 0, Jt = vt(Pt), or = Jt.length, ir = Jt[0].length;
                    if (or < ir)
                        throw "Need more rows than columns";
                    var lr = new Array(ir)
                      , ar = new Array(ir);
                    for (kt = 0; kt < ir; kt++)
                        lr[kt] = ar[kt] = 0;
                    var hr = function rn(hn, Nn, Wn) {
                        Wn === void 0 && (Wn = 0);
                        var qn, mo = hn[Wn], Ur = Array(mo);
                        if (Wn === hn.length - 1) {
                            for (qn = mo - 2; qn >= 0; qn -= 2)
                                Ur[qn + 1] = Nn,
                                Ur[qn] = Nn;
                            return qn === -1 && (Ur[0] = Nn),
                            Ur
                        }
                        for (qn = mo - 1; qn >= 0; qn--)
                            Ur[qn] = rn(hn, Nn, Wn + 1);
                        return Ur
                    }([ir, ir], 0);
                    function gr(rn, hn) {
                        return (rn = Math.abs(rn)) > (hn = Math.abs(hn)) ? rn * Math.sqrt(1 + hn * hn / rn / rn) : hn == 0 ? rn : hn * Math.sqrt(1 + rn * rn / hn / hn)
                    }
                    var dr = 0
                      , cr = 0
                      , Ar = 0
                      , wr = 0
                      , Rr = 0
                      , Cr = 0
                      , tr = 0;
                    for (kt = 0; kt < ir; kt++) {
                        for (lr[kt] = cr,
                        tr = 0,
                        Kt = kt + 1,
                        Ut = kt; Ut < or; Ut++)
                            tr += Jt[Ut][kt] * Jt[Ut][kt];
                        if (tr <= Gt)
                            cr = 0;
                        else
                            for (dr = Jt[kt][kt],
                            cr = Math.sqrt(tr),
                            dr >= 0 && (cr = -cr),
                            Ar = dr * cr - tr,
                            Jt[kt][kt] = dr - cr,
                            Ut = Kt; Ut < ir; Ut++) {
                                for (tr = 0,
                                Ht = kt; Ht < or; Ht++)
                                    tr += Jt[Ht][kt] * Jt[Ht][Ut];
                                for (dr = tr / Ar,
                                Ht = kt; Ht < or; Ht++)
                                    Jt[Ht][Ut] += dr * Jt[Ht][kt]
                            }
                        for (ar[kt] = cr,
                        tr = 0,
                        Ut = Kt; Ut < ir; Ut++)
                            tr += Jt[kt][Ut] * Jt[kt][Ut];
                        if (tr <= Gt)
                            cr = 0;
                        else {
                            for (dr = Jt[kt][kt + 1],
                            cr = Math.sqrt(tr),
                            dr >= 0 && (cr = -cr),
                            Ar = dr * cr - tr,
                            Jt[kt][kt + 1] = dr - cr,
                            Ut = Kt; Ut < ir; Ut++)
                                lr[Ut] = Jt[kt][Ut] / Ar;
                            for (Ut = Kt; Ut < or; Ut++) {
                                for (tr = 0,
                                Ht = Kt; Ht < ir; Ht++)
                                    tr += Jt[Ut][Ht] * Jt[kt][Ht];
                                for (Ht = Kt; Ht < ir; Ht++)
                                    Jt[Ut][Ht] += tr * lr[Ht]
                            }
                        }
                        (Rr = Math.abs(ar[kt]) + Math.abs(lr[kt])) > wr && (wr = Rr)
                    }
                    for (kt = ir - 1; kt != -1; kt += -1) {
                        if (cr != 0) {
                            for (Ar = cr * Jt[kt][kt + 1],
                            Ut = Kt; Ut < ir; Ut++)
                                hr[Ut][kt] = Jt[kt][Ut] / Ar;
                            for (Ut = Kt; Ut < ir; Ut++) {
                                for (tr = 0,
                                Ht = Kt; Ht < ir; Ht++)
                                    tr += Jt[kt][Ht] * hr[Ht][Ut];
                                for (Ht = Kt; Ht < ir; Ht++)
                                    hr[Ht][Ut] += tr * hr[Ht][kt]
                            }
                        }
                        for (Ut = Kt; Ut < ir; Ut++)
                            hr[kt][Ut] = 0,
                            hr[Ut][kt] = 0;
                        hr[kt][kt] = 1,
                        cr = lr[kt],
                        Kt = kt
                    }
                    for (kt = ir - 1; kt != -1; kt += -1) {
                        for (Kt = kt + 1,
                        cr = ar[kt],
                        Ut = Kt; Ut < ir; Ut++)
                            Jt[kt][Ut] = 0;
                        if (cr != 0) {
                            for (Ar = Jt[kt][kt] * cr,
                            Ut = Kt; Ut < ir; Ut++) {
                                for (tr = 0,
                                Ht = Kt; Ht < or; Ht++)
                                    tr += Jt[Ht][kt] * Jt[Ht][Ut];
                                for (dr = tr / Ar,
                                Ht = kt; Ht < or; Ht++)
                                    Jt[Ht][Ut] += dr * Jt[Ht][kt]
                            }
                            for (Ut = kt; Ut < or; Ut++)
                                Jt[Ut][kt] = Jt[Ut][kt] / cr
                        } else
                            for (Ut = kt; Ut < or; Ut++)
                                Jt[Ut][kt] = 0;
                        Jt[kt][kt] += 1
                    }
                    for (Dt *= wr,
                    Ht = ir - 1; Ht != -1; Ht += -1)
                        for (var fr = 0; fr < 50; fr++) {
                            var vr = !1;
                            for (Kt = Ht; Kt != -1; Kt += -1) {
                                if (Math.abs(lr[Kt]) <= Dt) {
                                    vr = !0;
                                    break
                                }
                                if (Math.abs(ar[Kt - 1]) <= Dt)
                                    break
                            }
                            if (!vr) {
                                Bt = 0,
                                tr = 1;
                                var Zr = Kt - 1;
                                for (kt = Kt; kt < Ht + 1 && (dr = tr * lr[kt],
                                lr[kt] = Bt * lr[kt],
                                !(Math.abs(dr) <= Dt)); kt++)
                                    for (Ar = gr(dr, cr = ar[kt]),
                                    ar[kt] = Ar,
                                    Bt = cr / Ar,
                                    tr = -dr / Ar,
                                    Ut = 0; Ut < or; Ut++)
                                        Rr = Jt[Ut][Zr],
                                        Cr = Jt[Ut][kt],
                                        Jt[Ut][Zr] = Rr * Bt + Cr * tr,
                                        Jt[Ut][kt] = -Rr * tr + Cr * Bt
                            }
                            if (Cr = ar[Ht],
                            Kt == Ht) {
                                if (Cr < 0)
                                    for (ar[Ht] = -Cr,
                                    Ut = 0; Ut < ir; Ut++)
                                        hr[Ut][Ht] = -hr[Ut][Ht];
                                break
                            }
                            if (fr >= 49)
                                throw "Error: no convergence.";
                            for (wr = ar[Kt],
                            cr = gr(dr = (((Rr = ar[Ht - 1]) - Cr) * (Rr + Cr) + ((cr = lr[Ht - 1]) - (Ar = lr[Ht])) * (cr + Ar)) / (2 * Ar * Rr), 1),
                            dr = dr < 0 ? ((wr - Cr) * (wr + Cr) + Ar * (Rr / (dr - cr) - Ar)) / wr : ((wr - Cr) * (wr + Cr) + Ar * (Rr / (dr + cr) - Ar)) / wr,
                            Bt = 1,
                            tr = 1,
                            kt = Kt + 1; kt < Ht + 1; kt++) {
                                for (cr = lr[kt],
                                Rr = ar[kt],
                                Ar = tr * cr,
                                cr *= Bt,
                                Cr = gr(dr, Ar),
                                lr[kt - 1] = Cr,
                                dr = wr * (Bt = dr / Cr) + cr * (tr = Ar / Cr),
                                cr = -wr * tr + cr * Bt,
                                Ar = Rr * tr,
                                Rr *= Bt,
                                Ut = 0; Ut < ir; Ut++)
                                    wr = hr[Ut][kt - 1],
                                    Cr = hr[Ut][kt],
                                    hr[Ut][kt - 1] = wr * Bt + Cr * tr,
                                    hr[Ut][kt] = -wr * tr + Cr * Bt;
                                for (Cr = gr(dr, Ar),
                                ar[kt - 1] = Cr,
                                dr = (Bt = dr / Cr) * cr + (tr = Ar / Cr) * Rr,
                                wr = -tr * cr + Bt * Rr,
                                Ut = 0; Ut < or; Ut++)
                                    Rr = Jt[Ut][kt - 1],
                                    Cr = Jt[Ut][kt],
                                    Jt[Ut][kt - 1] = Rr * Bt + Cr * tr,
                                    Jt[Ut][kt] = -Rr * tr + Cr * Bt
                            }
                            lr[Kt] = 0,
                            lr[Ht] = dr,
                            ar[Ht] = wr
                        }
                    for (kt = 0; kt < ar.length; kt++)
                        ar[kt] < Dt && (ar[kt] = 0);
                    for (kt = 0; kt < ir; kt++)
                        for (Ut = kt - 1; Ut >= 0; Ut--)
                            if (ar[Ut] < ar[kt]) {
                                for (Bt = ar[Ut],
                                ar[Ut] = ar[kt],
                                ar[kt] = Bt,
                                Ht = 0; Ht < Jt.length; Ht++)
                                    It = Jt[Ht][kt],
                                    Jt[Ht][kt] = Jt[Ht][Ut],
                                    Jt[Ht][Ut] = It;
                                for (Ht = 0; Ht < hr.length; Ht++)
                                    It = hr[Ht][kt],
                                    hr[Ht][kt] = hr[Ht][Ut],
                                    hr[Ht][Ut] = It;
                                kt = Ut
                            }
                    return {
                        U: Jt,
                        S: ar,
                        V: hr
                    }
                }(bt);
                console.log(St);
                var At = St.U
                  , Et = St.S.map(function(Pt, It) {
                    var Dt = {};
                    return Dt.eigenvalue = Pt,
                    Dt.vector = At.map(function(Gt, Bt) {
                        return -1 * Gt[It]
                    }),
                    Dt
                });
                return Et
            }
            function _e(bt, ...St) {
                var At = St.map(function(It) {
                    return It.vector
                })
                  , Et = at(At, _t(c(bt)))
                  , Pt = pt(at(ht(bt.length), bt), -1 / bt.length);
                return {
                    adjustedData: Et,
                    formattedAdjustedData: it(Et, 2),
                    avgData: Pt,
                    selectedVectors: At
                }
            }
            function nt(bt) {
                return b(_(h(c(bt)), !1))
            }
            function it(bt, St) {
                var At = Math.pow(10, St);
                return bt.map(function(Et, Pt) {
                    return Et.map(function(It) {
                        return Math.round(It * At) / At
                    })
                })
            }
            function at(bt, St) {
                if (!(bt[0] && St[0] && bt.length && St.length))
                    throw new Error("Both A and B should be matrices");
                if (St.length !== bt[0].length)
                    throw new Error("Columns in A should be the same as the number of rows in B");
                for (var At = [], Et = 0; Et < bt.length; Et++) {
                    At[Et] = [];
                    for (var Pt = 0; Pt < St[0].length; Pt++)
                        for (var It = 0; It < bt[0].length; It++)
                            At[Et][Pt] = At[Et][Pt] ? At[Et][Pt] + bt[Et][It] * St[It][Pt] : bt[Et][It] * St[It][Pt]
                }
                return At
            }
            function ut(bt, St) {
                if (bt.length !== St.length || bt[0].length !== St[0].length)
                    throw new Error("Both A and B should have the same dimensions");
                for (var At = [], Et = 0; Et < bt.length; Et++) {
                    At[Et] = [];
                    for (var Pt = 0; Pt < St[0].length; Pt++)
                        At[Et][Pt] = bt[Et][Pt] - St[Et][Pt]
                }
                return At
            }
            function pt(bt, St) {
                for (var At = [], Et = 0; Et < bt.length; Et++) {
                    At[Et] = [];
                    for (var Pt = 0; Pt < bt[0].length; Pt++)
                        At[Et][Pt] = bt[Et][Pt] * St
                }
                return At
            }
            function ht(bt) {
                for (var St = [], At = 0; At < bt; At++) {
                    St[At] = [];
                    for (var Et = 0; Et < bt; Et++)
                        St[At][Et] = 1
                }
                return St
            }
            function _t(bt) {
                return vt(bt)[0].map(function(St, At) {
                    return bt.map(function(Et) {
                        return Et[At]
                    })
                })
            }
            function vt(bt) {
                var St = JSON.stringify(bt);
                return JSON.parse(St)
            }
            return {
                computeDeviationScores: h,
                computeDeviationMatrix: c,
                computeSVD: b,
                computePercentageExplained: function(bt, ...St) {
                    var At = bt.map(function(Pt) {
                        return Pt.eigenvalue
                    }).reduce(function(Pt, It) {
                        return Pt + It
                    })
                      , Et = St.map(function(Pt) {
                        return Pt.eigenvalue
                    }).reduce(function(Pt, It) {
                        return Pt + It
                    });
                    return Et / At
                },
                computeOriginalData: function(bt, St, At) {
                    var Et = ut(_t(at(_t(St), bt)), At);
                    return {
                        originalData: Et,
                        formattedOriginalData: it(Et, 2)
                    }
                },
                computeVarianceCovariance: _,
                computeAdjustedData: _e,
                getEigenVectors: nt,
                analyseTopResult: function(bt) {
                    var St = nt(bt).sort(function(At, Et) {
                        return Et.eigenvalue - At.eigenvalue
                    });
                    return console.log("Sorted Vectors", St),
                    _e(bt, St[0].vector)
                },
                transpose: _t,
                multiply: at,
                clone: vt,
                scale: pt
            }
        }();
        d.exports = o
    },
    186: function(d) {
        var o = [];
        function c(b) {
            for (var _e = -1, nt = 0; nt < o.length; nt++)
                if (o[nt].identifier === b) {
                    _e = nt;
                    break
                }
            return _e
        }
        function h(b, _e) {
            for (var nt = {}, it = [], at = 0; at < b.length; at++) {
                var ut = b[at]
                  , pt = _e.base ? ut[0] + _e.base : ut[0]
                  , ht = nt[pt] || 0
                  , _t = "".concat(pt, " ").concat(ht);
                nt[pt] = ht + 1;
                var vt = c(_t)
                  , bt = {
                    css: ut[1],
                    media: ut[2],
                    sourceMap: ut[3],
                    supports: ut[4],
                    layer: ut[5]
                };
                if (vt !== -1)
                    o[vt].references++,
                    o[vt].updater(bt);
                else {
                    var St = _(bt, _e);
                    _e.byIndex = at,
                    o.splice(at, 0, {
                        identifier: _t,
                        updater: St,
                        references: 1
                    })
                }
                it.push(_t)
            }
            return it
        }
        function _(b, _e) {
            var nt = _e.domAPI(_e);
            return nt.update(b),
            function(it) {
                if (it) {
                    if (it.css === b.css && it.media === b.media && it.sourceMap === b.sourceMap && it.supports === b.supports && it.layer === b.layer)
                        return;
                    nt.update(b = it)
                } else
                    nt.remove()
            }
        }
        d.exports = function(b, _e) {
            var nt = h(b = b || [], _e = _e || {});
            return function(it) {
                it = it || [];
                for (var at = 0; at < nt.length; at++) {
                    var ut = c(nt[at]);
                    o[ut].references--
                }
                for (var pt = h(it, _e), ht = 0; ht < nt.length; ht++) {
                    var _t = c(nt[ht]);
                    o[_t].references === 0 && (o[_t].updater(),
                    o.splice(_t, 1))
                }
                nt = pt
            }
        }
    },
    990: function(d) {
        d.exports = function(o) {
            var c = document.createElement("style");
            return o.setAttributes(c, o.attributes),
            o.insert(c, o.options),
            c
        }
    },
    626: function(d, o, c) {
        d.exports = function(h) {
            var _ = c.nc;
            _ && h.setAttribute("nonce", _)
        }
    },
    155: function(d) {
        d.exports = function(o) {
            var c = o.insertStyleElement(o);
            return {
                update: function(h) {
                    (function(_, b, _e) {
                        var nt = "";
                        _e.supports && (nt += "@supports (".concat(_e.supports, ") {")),
                        _e.media && (nt += "@media ".concat(_e.media, " {"));
                        var it = _e.layer !== void 0;
                        it && (nt += "@layer".concat(_e.layer.length > 0 ? " ".concat(_e.layer) : "", " {")),
                        nt += _e.css,
                        it && (nt += "}"),
                        _e.media && (nt += "}"),
                        _e.supports && (nt += "}");
                        var at = _e.sourceMap;
                        at && typeof btoa < "u" && (nt += `
/`,
                        nt += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(at)))), " *"),
                        nt += "/"),
                        b.styleTagTransform(nt, _, b.options)
                    }
                    )(c, o, h)
                },
                remove: function() {
                    (function(h) {
                        if (h.parentNode === null)
                            return !1;
                        h.parentNode.removeChild(h)
                    }
                    )(c)
                }
            }
        }
    },
    827: function(d) {
        d.exports = function(o, c) {
            if (c.styleSheet)
                c.styleSheet.cssText = o;
            else {
                for (; c.firstChild; )
                    c.removeChild(c.firstChild);
                c.appendChild(document.createTextNode(o))
            }
        }
    },
    530: function(d) {
        d.exports = function() {
            var o = {
                820: function(b, _e, nt) {
                    var it = nt(537)
                      , at = nt.n(it)
                      , ut = nt(645)
                      , pt = nt.n(ut)()(at());
                    pt.push([b.id, `.treejs {
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  font-size: 14px;
  margin-left: -18px;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.treejs *:after,
.treejs *:before {
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
}
.treejs > .treejs-node {
  padding-left: 0;
}
.treejs .treejs-nodes {
  list-style: none;
  padding-left: 18px;
  margin: 0;
  overflow: hidden;
  -webkit-transition: height 150ms ease-out, opacity 150ms ease-out;
  -o-transition: height 150ms ease-out, opacity 150ms ease-out;
  transition: height 150ms ease-out, opacity 150ms ease-out;
}
.treejs .treejs-node {
  cursor: pointer;
  overflow: hidden;
}
.treejs .treejs-node.treejs-placeholder {
  padding-left: 18px;
}
.treejs .treejs-switcher {
  display: inline-block;
  vertical-align: middle;
  width: 20px;
  height: 20px;
  cursor: pointer;
  position: relative;
  -webkit-transition: -webkit-transform 150ms ease-out;
  transition: -webkit-transform 150ms ease-out;
  -o-transition: transform 150ms ease-out;
  transition: transform 150ms ease-out;
  transition: transform 150ms ease-out, -webkit-transform 150ms ease-out;
}
.treejs .treejs-switcher:before {
  position: absolute;
  top: 8px;
  left: 6px;
  display: block;
  content: ' ';
  border: 4px solid transparent;
  border-top: 4px solid rgba(245, 245, 245, 0.7);
  -webkit-transition: border-color 150ms;
  -o-transition: border-color 150ms;
  transition: border-color 150ms;
}
.treejs .treejs-switcher:hover:before {
  border-top: 4px solid rgba(245, 245, 245, 0.96);
}
.treejs .treejs-node__close > .treejs-switcher {
  -webkit-transform: rotate(-90deg);
      -ms-transform: rotate(-90deg);
          transform: rotate(-90deg);
}
.treejs .treejs-node__close > .treejs-nodes {
  height: 0;
}
.treejs .treejs-checkbox {
  display: inline-block;
  vertical-align: middle;
  width: 20px;
  height: 20px;
  cursor: pointer;
  position: relative;
}
.treejs .treejs-checkbox:before {
  -webkit-transition: all 0.3s;
  -o-transition: all 0.3s;
  transition: all 0.3s;
  cursor: pointer;
  position: absolute;
  top: 2px;
  content: ' ';
  display: block;
  width: 16px;
  height: 16px;
  border: 1px solid #d9d9d9;
  border-radius: 2px;
}
.treejs .treejs-checkbox:hover:before {
  -webkit-box-shadow: 0 0 2px 1px #1890ff;
          box-shadow: 0 0 2px 1px #1890ff;
}
.treejs .treejs-node__checked > .treejs-checkbox:before {
  background-color: #1890ff;
  border-color: #1890ff;
}
.treejs .treejs-node__checked > .treejs-checkbox:after {
  position: absolute;
  content: ' ';
  display: block;
  top: 4px;
  left: 5px;
  width: 5px;
  height: 9px;
  border: 2px solid #fff;
  border-top: none;
  border-left: none;
  -webkit-transform: rotate(45deg);
      -ms-transform: rotate(45deg);
          transform: rotate(45deg);
}
.treejs .treejs-node__halfchecked > .treejs-checkbox:before {
  background-color: #1890ff;
  border-color: #1890ff;
}
.treejs .treejs-node__halfchecked > .treejs-checkbox:after {
  position: absolute;
  content: ' ';
  display: block;
  top: 9px;
  left: 3px;
  width: 10px;
  height: 2px;
  background-color: #fff;
}
.treejs .treejs-node__disabled {
  cursor: not-allowed;
  color: rgba(255, 255, 255, 0.25);
}
.treejs .treejs-node__disabled .treejs-checkbox {
  cursor: not-allowed;
}
.treejs .treejs-node__disabled .treejs-checkbox:before {
  cursor: not-allowed;
  border-color: #d9d9d9 !important;
  background-color: #f5f5f5 !important;
}
.treejs .treejs-node__disabled .treejs-checkbox:hover:before {
  -webkit-box-shadow: none !important;
          box-shadow: none !important;
}
.treejs .treejs-node__disabled .treejs-node__checked > .treejs-checkbox:after {
  border-color: #d9d9d9;
}
.treejs .treejs-node__disabled .treejs-node__halfchecked > .treejs-checkbox:after {
  background-color: #d9d9d9;
}
.treejs .treejs-node__disabled.treejs-node__checked > .treejs-checkbox:after {
  border-color: #d9d9d9;
}
.treejs .treejs-node__disabled.treejs-node__halfchecked > .treejs-checkbox:after {
  background-color: #d9d9d9;
}
.treejs .treejs-label {
  vertical-align: middle;
}
`, "", {
                        version: 3,
                        sources: ["webpack://./src/index.less"],
                        names: [],
                        mappings: "AAKA;EACE,8BAAA;UAAA,sBAAA;EACA,eAAA;EACA,kBAAA;EACA,yBAAA;KAAA,sBAAA;MAAA,qBAAA;UAAA,iBAAA;AAJF;AAAA;;EAQI,8BAAA;UAAA,sBAAA;AAJJ;AAOE;EACE,eAAA;AALJ;AAPA;EAgBI,gBAAA;EACA,kBAAA;EACA,SAAA;EACA,gBAAA;EACA,iEAAA;EAAA,4DAAA;EAAA,yDAAA;AANJ;AAdA;EAwBI,eAAA;EACA,gBAAA;AAPJ;AASI;EACE,kBAAA;AAPN;AArBA;EAiCI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;EACA,oDAAA;EAAA,4CAAA;EAAA,uCAAA;EAAA,oCAAA;EAAA,sEAAA;AATJ;AAWI;EACE,kBAAA;EACA,QAAA;EACA,SAAA;EACA,cAAA;EACA,YAAA;EACA,6BAAA;EACA,8CAAA;EACA,sCAAA;EAAA,iCAAA;EAAA,8BAAA;AATN;AAWI;EACE,+CAAA;AATN;AA3CA;EAwDI,iCAAA;MAAA,6BAAA;UAAA,yBAAA;AAVJ;AA9CA;EA2DI,SAAA;AAVJ;AAjDA;EA+DI,qBAAA;EACA,sBAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,kBAAA;AAXJ;AAaI;EACE,4BAAA;EAAA,uBAAA;EAAA,oBAAA;EACA,eAAA;EACA,kBAAA;EACA,QAAA;EACA,YAAA;EACA,cAAA;EACA,WAAA;EACA,YAAA;EACA,yBAAA;EACA,kBAAA;AAXN;AAaI;EACE,uCAAA;UAAA,+BAAA;AAXN;AAgBM;EACE,yBAAA;EACA,qBAAA;AAdR;AAgBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,UAAA;EACA,WAAA;EACA,sBAAA;EACA,gBAAA;EACA,iBAAA;EACA,gCAAA;MAAA,4BAAA;UAAA,wBAAA;AAdR;AAoBM;EACE,yBAAA;EACA,qBAAA;AAlBR;AAoBM;EACE,kBAAA;EACA,YAAA;EACA,cAAA;EACA,QAAA;EACA,SAAA;EACA,WAAA;EACA,WAAA;EACA,sBAAA;AAlBR;AAvGA;EA+HI,mBAAA;EACA,gCAAA;AArBJ;AA3GA;EAkIM,mBAAA;AApBN;AAqBM;EACE,mBAAA;EACA,gCAAA;EACA,oCAAA;AAnBR;AAqBM;EACE,mCAAA;UAAA,2BAAA;AAnBR;AAwBQ;EACE,qBAAA;AAtBV;AA4BQ;EACE,yBAAA;AA1BV;AAiCM;EACE,qBAAA;AA/BR;AAqCM;EACE,yBAAA;AAnCR;AAlIA;EA2KI,sBAAA;AAtCJ",
                        sourcesContent: [`@color-disable: #d4d4d4;
@bgcolor-disable: #f5f5f5;
@greyborder: #d9d9d9;
@bluebg: #1890ff;

.treejs {
  box-sizing: border-box;
  font-size: 14px;
  margin-left: -18px;
  user-select: none;

  *:after,
  *:before {
    box-sizing: border-box;
  }

  & > .treejs-node {
    padding-left: 0;
  }

  .treejs-nodes {
    list-style: none;
    padding-left: 18px;
    margin: 0; //  for default ul...
    overflow: hidden;
    transition: height 150ms ease-out, opacity 150ms ease-out;
  }

  .treejs-node {
    cursor: pointer;
    overflow: hidden;

    &.treejs-placeholder {
      padding-left: 18px;
    }
  }

  .treejs-switcher {
    display: inline-block;
    vertical-align: middle;
    width: 20px;
    height: 20px;
    cursor: pointer;
    position: relative;
    transition: transform 150ms ease-out;

    &:before {
      position: absolute;
      top: 8px;
      left: 6px;
      display: block;
      content: ' ';
      border: 4px solid transparent;
      border-top: 4px solid rgba(245, 245, 245, 0.7);
      transition: border-color 150ms;
    }
    &:hover:before {
      border-top: 4px solid rgba(245, 245, 245, 0.96);
    }
  }
  .treejs-node__close > .treejs-switcher {
    transform: rotate(-90deg);
  }
  .treejs-node__close > .treejs-nodes {
    height: 0;
  }

  .treejs-checkbox {
    display: inline-block;
    vertical-align: middle;
    width: 20px;
    height: 20px;
    cursor: pointer;
    position: relative;

    &:before {
      transition: all 0.3s;
      cursor: pointer;
      position: absolute;
      top: 2px;
      content: ' ';
      display: block;
      width: 16px;
      height: 16px;
      border: 1px solid @greyborder;
      border-radius: 2px;
    }
    &:hover:before {
      box-shadow: 0 0 2px 1px @bluebg;
    }
  }
  .treejs-node__checked {
    & > .treejs-checkbox {
      &:before {
        background-color: @bluebg;
        border-color: @bluebg;
      }
      &:after {
        position: absolute;
        content: ' ';
        display: block;
        top: 4px;
        left: 5px;
        width: 5px;
        height: 9px;
        border: 2px solid #fff;
        border-top: none;
        border-left: none;
        transform: rotate(45deg);
      }
    }
  }
  .treejs-node__halfchecked {
    & > .treejs-checkbox {
      &:before {
        background-color: @bluebg;
        border-color: @bluebg;
      }
      &:after {
        position: absolute;
        content: ' ';
        display: block;
        top: 9px;
        left: 3px;
        width: 10px;
        height: 2px;
        background-color: #fff;
      }
    }
  }

  .treejs-node__disabled {
    cursor: not-allowed;
    color: rgba(255, 255, 255, 0.25);
    .treejs-checkbox {
      cursor: not-allowed;
      &:before {
        cursor: not-allowed;
        border-color: @greyborder !important;
        background-color: @bgcolor-disable !important;
      }
      &:hover:before {
        box-shadow: none !important;
      }
    }
    .treejs-node__checked {
      & > .treejs-checkbox {
        &:after {
          border-color: @greyborder;
        }
      }
    }
    .treejs-node__halfchecked {
      & > .treejs-checkbox {
        &:after {
          background-color: @greyborder;
        }
      }
    }
  }
  .treejs-node__disabled.treejs-node__checked {
    & > .treejs-checkbox {
      &:after {
        border-color: @greyborder;
      }
    }
  }
  .treejs-node__disabled.treejs-node__halfchecked {
    & > .treejs-checkbox {
      &:after {
        background-color: @greyborder;
      }
    }
  }

  .treejs-label {
    vertical-align: middle;
  }
}
`],
                        sourceRoot: ""
                    }]),
                    _e.Z = pt
                },
                645: function(b) {
                    b.exports = function(_e) {
                        var nt = [];
                        return nt.toString = function() {
                            return this.map(function(it) {
                                var at = ""
                                  , ut = it[5] !== void 0;
                                return it[4] && (at += "@supports (".concat(it[4], ") {")),
                                it[2] && (at += "@media ".concat(it[2], " {")),
                                ut && (at += "@layer".concat(it[5].length > 0 ? " ".concat(it[5]) : "", " {")),
                                at += _e(it),
                                ut && (at += "}"),
                                it[2] && (at += "}"),
                                it[4] && (at += "}"),
                                at
                            }).join("")
                        }
                        ,
                        nt.i = function(it, at, ut, pt, ht) {
                            typeof it == "string" && (it = [[null, it, void 0]]);
                            var _t = {};
                            if (ut)
                                for (var vt = 0; vt < this.length; vt++) {
                                    var bt = this[vt][0];
                                    bt != null && (_t[bt] = !0)
                                }
                            for (var St = 0; St < it.length; St++) {
                                var At = [].concat(it[St]);
                                ut && _t[At[0]] || (ht !== void 0 && (At[5] === void 0 || (At[1] = "@layer".concat(At[5].length > 0 ? " ".concat(At[5]) : "", " {").concat(At[1], "}")),
                                At[5] = ht),
                                at && (At[2] && (At[1] = "@media ".concat(At[2], " {").concat(At[1], "}")),
                                At[2] = at),
                                pt && (At[4] ? (At[1] = "@supports (".concat(At[4], ") {").concat(At[1], "}"),
                                At[4] = pt) : At[4] = "".concat(pt)),
                                nt.push(At))
                            }
                        }
                        ,
                        nt
                    }
                },
                537: function(b) {
                    b.exports = function(_e) {
                        var nt = _e[1]
                          , it = _e[3];
                        if (!it)
                            return nt;
                        if (typeof btoa == "function") {
                            var at = btoa(unescape(encodeURIComponent(JSON.stringify(it))))
                              , ut = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(at)
                              , pt = "/*# ".concat(ut, " */")
                              , ht = it.sources.map(function(_t) {
                                return "/*# sourceURL=".concat(it.sourceRoot || "").concat(_t, " */")
                            });
                            return [nt].concat(ht).concat([pt]).join(`
`)
                        }
                        return [nt].join(`
`)
                    }
                },
                379: function(b) {
                    var _e = [];
                    function nt(ut) {
                        for (var pt = -1, ht = 0; ht < _e.length; ht++)
                            if (_e[ht].identifier === ut) {
                                pt = ht;
                                break
                            }
                        return pt
                    }
                    function it(ut, pt) {
                        for (var ht = {}, _t = [], vt = 0; vt < ut.length; vt++) {
                            var bt = ut[vt]
                              , St = pt.base ? bt[0] + pt.base : bt[0]
                              , At = ht[St] || 0
                              , Et = "".concat(St, " ").concat(At);
                            ht[St] = At + 1;
                            var Pt = nt(Et)
                              , It = {
                                css: bt[1],
                                media: bt[2],
                                sourceMap: bt[3],
                                supports: bt[4],
                                layer: bt[5]
                            };
                            if (Pt !== -1)
                                _e[Pt].references++,
                                _e[Pt].updater(It);
                            else {
                                var Dt = at(It, pt);
                                pt.byIndex = vt,
                                _e.splice(vt, 0, {
                                    identifier: Et,
                                    updater: Dt,
                                    references: 1
                                })
                            }
                            _t.push(Et)
                        }
                        return _t
                    }
                    function at(ut, pt) {
                        var ht = pt.domAPI(pt);
                        return ht.update(ut),
                        function(_t) {
                            if (_t) {
                                if (_t.css === ut.css && _t.media === ut.media && _t.sourceMap === ut.sourceMap && _t.supports === ut.supports && _t.layer === ut.layer)
                                    return;
                                ht.update(ut = _t)
                            } else
                                ht.remove()
                        }
                    }
                    b.exports = function(ut, pt) {
                        var ht = it(ut = ut || [], pt = pt || {});
                        return function(_t) {
                            _t = _t || [];
                            for (var vt = 0; vt < ht.length; vt++) {
                                var bt = nt(ht[vt]);
                                _e[bt].references--
                            }
                            for (var St = it(_t, pt), At = 0; At < ht.length; At++) {
                                var Et = nt(ht[At]);
                                _e[Et].references === 0 && (_e[Et].updater(),
                                _e.splice(Et, 1))
                            }
                            ht = St
                        }
                    }
                },
                216: function(b) {
                    b.exports = function(_e) {
                        var nt = document.createElement("style");
                        return _e.setAttributes(nt, _e.attributes),
                        _e.insert(nt, _e.options),
                        nt
                    }
                },
                636: function(b, _e, nt) {
                    b.exports = function(it) {
                        var at = nt.nc;
                        at && it.setAttribute("nonce", at)
                    }
                },
                795: function(b) {
                    b.exports = function(_e) {
                        var nt = _e.insertStyleElement(_e);
                        return {
                            update: function(it) {
                                (function(at, ut, pt) {
                                    var ht = "";
                                    pt.supports && (ht += "@supports (".concat(pt.supports, ") {")),
                                    pt.media && (ht += "@media ".concat(pt.media, " {"));
                                    var _t = pt.layer !== void 0;
                                    _t && (ht += "@layer".concat(pt.layer.length > 0 ? " ".concat(pt.layer) : "", " {")),
                                    ht += pt.css,
                                    _t && (ht += "}"),
                                    pt.media && (ht += "}"),
                                    pt.supports && (ht += "}");
                                    var vt = pt.sourceMap;
                                    vt && typeof btoa < "u" && (ht += `
/`,
                                    ht += "*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(vt)))), " *"),
                                    ht += "/"),
                                    ut.styleTagTransform(ht, at, ut.options)
                                }
                                )(nt, _e, it)
                            },
                            remove: function() {
                                (function(it) {
                                    if (it.parentNode === null)
                                        return !1;
                                    it.parentNode.removeChild(it)
                                }
                                )(nt)
                            }
                        }
                    }
                },
                589: function(b) {
                    b.exports = function(_e, nt) {
                        if (nt.styleSheet)
                            nt.styleSheet.cssText = _e;
                        else {
                            for (; nt.firstChild; )
                                nt.removeChild(nt.firstChild);
                            nt.appendChild(document.createTextNode(_e))
                        }
                    }
                }
            }
              , c = {};
            function h(b) {
                var _e = c[b];
                if (_e !== void 0)
                    return _e.exports;
                var nt = c[b] = {
                    id: b,
                    exports: {}
                };
                return o[b](nt, nt.exports, h),
                nt.exports
            }
            h.n = function(b) {
                var _e = b && b.__esModule ? function() {
                    return b.default
                }
                : function() {
                    return b
                }
                ;
                return h.d(_e, {
                    a: _e
                }),
                _e
            }
            ,
            h.d = function(b, _e) {
                for (var nt in _e)
                    h.o(_e, nt) && !h.o(b, nt) && Object.defineProperty(b, nt, {
                        enumerable: !0,
                        get: _e[nt]
                    })
            }
            ,
            h.o = function(b, _e) {
                return Object.prototype.hasOwnProperty.call(b, _e)
            }
            ,
            h.nc = void 0;
            var _ = {};
            return function() {
                h.d(_, {
                    default: function() {
                        return lr
                    }
                });
                var b = h(379)
                  , _e = h.n(b)
                  , nt = h(795)
                  , it = h.n(nt)
                  , at = h(636)
                  , ut = h.n(at)
                  , pt = h(216)
                  , ht = h.n(pt)
                  , _t = h(589)
                  , vt = h.n(_t)
                  , bt = h(820)
                  , St = {};
                bt.Z && bt.Z.locals && (St.locals = bt.Z.locals);
                var At, Et = 0, Pt = {};
                Pt.styleTagTransform = vt(),
                Pt.setAttributes = ut(),
                Pt.insert = function(ar, hr) {
                    (hr.target || document.head).appendChild(ar)
                }
                ,
                Pt.domAPI = it(),
                Pt.insertStyleElement = ht(),
                St.use = function(ar) {
                    return Pt.options = ar || {},
                    Et++ || (At = _e()(bt.Z, Pt)),
                    St
                }
                ,
                St.unuse = function() {
                    Et > 0 && !--Et && (At(),
                    At = null)
                }
                ;
                var It = St;
                function Dt(ar, hr) {
                    return function(gr) {
                        if (Array.isArray(gr))
                            return gr
                    }(ar) || function(gr, dr) {
                        var cr = gr == null ? null : typeof Symbol < "u" && gr[Symbol.iterator] || gr["@@iterator"];
                        if (cr != null) {
                            var Ar, wr, Rr = [], Cr = !0, tr = !1;
                            try {
                                for (cr = cr.call(gr); !(Cr = (Ar = cr.next()).done) && (Rr.push(Ar.value),
                                !dr || Rr.length !== dr); Cr = !0)
                                    ;
                            } catch (fr) {
                                tr = !0,
                                wr = fr
                            } finally {
                                try {
                                    Cr || cr.return == null || cr.return()
                                } finally {
                                    if (tr)
                                        throw wr
                                }
                            }
                            return Rr
                        }
                    }(ar, hr) || function(gr, dr) {
                        if (gr) {
                            if (typeof gr == "string")
                                return Gt(gr, dr);
                            var cr = Object.prototype.toString.call(gr).slice(8, -1);
                            return cr === "Object" && gr.constructor && (cr = gr.constructor.name),
                            cr === "Map" || cr === "Set" ? Array.from(gr) : cr === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(cr) ? Gt(gr, dr) : void 0
                        }
                    }(ar, hr) || function() {
                        throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }()
                }
                function Gt(ar, hr) {
                    (hr == null || hr > ar.length) && (hr = ar.length);
                    for (var gr = 0, dr = new Array(hr); gr < hr; gr++)
                        dr[gr] = ar[gr];
                    return dr
                }
                function Bt(ar, hr) {
                    var gr = Object.keys(ar);
                    if (Object.getOwnPropertySymbols) {
                        var dr = Object.getOwnPropertySymbols(ar);
                        hr && (dr = dr.filter(function(cr) {
                            return Object.getOwnPropertyDescriptor(ar, cr).enumerable
                        })),
                        gr.push.apply(gr, dr)
                    }
                    return gr
                }
                function kt(ar) {
                    for (var hr = 1; hr < arguments.length; hr++) {
                        var gr = arguments[hr] != null ? arguments[hr] : {};
                        hr % 2 ? Bt(Object(gr), !0).forEach(function(dr) {
                            Ut(ar, dr, gr[dr])
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ar, Object.getOwnPropertyDescriptors(gr)) : Bt(Object(gr)).forEach(function(dr) {
                            Object.defineProperty(ar, dr, Object.getOwnPropertyDescriptor(gr, dr))
                        })
                    }
                    return ar
                }
                function Ut(ar, hr, gr) {
                    return hr in ar ? Object.defineProperty(ar, hr, {
                        value: gr,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : ar[hr] = gr,
                    ar
                }
                function Ht(ar, hr) {
                    for (var gr = 0; gr < hr.length; gr++) {
                        var dr = hr[gr];
                        dr.enumerable = dr.enumerable || !1,
                        dr.configurable = !0,
                        "value"in dr && (dr.writable = !0),
                        Object.defineProperty(ar, dr.key, dr)
                    }
                }
                function Kt(ar) {
                    var hr = {};
                    return ar.reduce(function(gr, dr) {
                        return hr[dr] || (hr[dr] = !0,
                        gr.push(dr)),
                        gr
                    }, [])
                }
                function Jt(ar, hr) {
                    requestAnimationFrame(function() {
                        hr.enter(),
                        requestAnimationFrame(function() {
                            hr.active(),
                            setTimeout(function() {
                                hr.leave()
                            }, ar)
                        })
                    })
                }
                function or(ar, hr) {
                    try {
                        var gr = ar.liElementsById[hr.parent.id];
                        gr.classList.contains("treejs-node__close") || gr.getElementsByClassName("treejs-switcher")[0].click()
                    } catch {
                        return
                    }
                    Object.prototype.hasOwnProperty.call(hr, "parent") && or(ar, hr.parent)
                }
                function ir(ar, hr) {
                    var gr = ar.liElementsById[hr.id];
                    gr.classList.contains("treejs-node__close") && gr.getElementsByClassName("treejs-switcher")[0].click(),
                    Object.prototype.hasOwnProperty.call(hr, "children") && hr.children.forEach(function(dr) {
                        return ir(ar, dr)
                    })
                }
                var lr = function() {
                    function ar(cr, Ar) {
                        (function(wr, Rr) {
                            if (!(wr instanceof Rr))
                                throw new TypeError("Cannot call a class as a function")
                        }
                        )(this, ar),
                        It.use({
                            target: typeof this.container == "string" ? document.querySelector(this.container) : this.container
                        }),
                        this.treeNodes = [],
                        this.nodesById = {},
                        this.leafNodesById = {},
                        this.liElementsById = {},
                        this.willUpdateNodesById = {},
                        this.container = cr,
                        this.options = Object.assign({
                            values: [],
                            disables: [],
                            loaded: null,
                            closeDepth: null
                        }, Ar),
                        Object.defineProperties(this, {
                            values: {
                                get: function() {
                                    return this.getValues()
                                },
                                set: function(wr) {
                                    this.setValues(Kt(wr))
                                }
                            },
                            disables: {
                                get: function() {
                                    return this.getDisables()
                                },
                                set: function(wr) {
                                    this.setDisables(Kt(wr))
                                }
                            },
                            selectedNodes: {
                                get: function() {
                                    var wr = []
                                      , Rr = this.nodesById;
                                    return Object.keys(Rr).forEach(function(Cr) {
                                        if (Object.prototype.hasOwnProperty.call(Rr, Cr) && (Rr[Cr].status === 1 || Rr[Cr].status === 2)) {
                                            var tr = kt({}, Rr[Cr]);
                                            delete tr.parent,
                                            delete tr.children,
                                            wr.push(tr)
                                        }
                                    }),
                                    wr
                                }
                            },
                            disabledNodes: {
                                get: function() {
                                    var wr = []
                                      , Rr = this.nodesById;
                                    return Object.keys(Rr).forEach(function(Cr) {
                                        if (Object.prototype.hasOwnProperty.call(Rr, Cr) && Rr[Cr].disabled) {
                                            var tr = kt({}, Rr[Cr]);
                                            delete tr.parent,
                                            wr.push(tr)
                                        }
                                    }),
                                    wr
                                }
                            }
                        }),
                        this.init(this.options.data)
                    }
                    var hr, gr, dr;
                    return hr = ar,
                    dr = [{
                        key: "onSwitcherClick",
                        value: function(cr) {
                            var Ar = cr.parentNode
                              , wr = Ar.lastChild
                              , Rr = wr.scrollHeight;
                            Ar.classList.contains("treejs-node__close") ? Jt(150, {
                                enter: function() {
                                    wr.style.height = 0,
                                    wr.style.opacity = 0
                                },
                                active: function() {
                                    wr.style.height = "".concat(Rr, "px"),
                                    wr.style.opacity = 1
                                },
                                leave: function() {
                                    wr.style.height = "",
                                    wr.style.opacity = "",
                                    Ar.classList.remove("treejs-node__close")
                                }
                            }) : Jt(150, {
                                enter: function() {
                                    wr.style.height = "".concat(Rr, "px"),
                                    wr.style.opacity = 1
                                },
                                active: function() {
                                    wr.style.height = 0,
                                    wr.style.opacity = 0
                                },
                                leave: function() {
                                    wr.style.height = "",
                                    wr.style.opacity = "",
                                    Ar.classList.add("treejs-node__close")
                                }
                            })
                        }
                    }, {
                        key: "parseTreeData",
                        value: function(cr) {
                            var Ar, wr = (Ar = cr,
                            JSON.parse(JSON.stringify(Ar))), Rr = {}, Cr = {}, tr = [], fr = [];
                            return function vr(Zr, rn) {
                                Zr.forEach(function(hn) {
                                    Rr[hn.id] = hn,
                                    hn.checked && tr.push(hn.id),
                                    hn.disabled && fr.push(hn.id),
                                    rn && (hn.parent = rn),
                                    hn.children && hn.children.length ? vr(hn.children, hn) : Cr[hn.id] = hn
                                })
                            }(wr),
                            {
                                treeNodes: wr,
                                nodesById: Rr,
                                leafNodesById: Cr,
                                defaultValues: tr,
                                defaultDisables: fr
                            }
                        }
                    }, {
                        key: "createRootEle",
                        value: function() {
                            var cr = document.createElement("div");
                            return cr.classList.add("treejs"),
                            cr
                        }
                    }, {
                        key: "createUlEle",
                        value: function() {
                            var cr = document.createElement("ul");
                            return cr.classList.add("treejs-nodes"),
                            cr
                        }
                    }, {
                        key: "createLiEle",
                        value: function(cr, Ar) {
                            var wr = document.createElement("li");
                            if (wr.classList.add("treejs-node"),
                            Ar && wr.classList.add("treejs-node__close"),
                            cr.children && cr.children.length) {
                                var Rr = document.createElement("span");
                                Rr.classList.add("treejs-switcher"),
                                wr.appendChild(Rr)
                            } else
                                wr.classList.add("treejs-placeholder");
                            var Cr = document.createElement("span");
                            Cr.classList.add("treejs-checkbox"),
                            wr.appendChild(Cr);
                            var tr = document.createElement("span");
                            tr.classList.add("treejs-label");
                            var fr = document.createTextNode(cr.text);
                            return tr.appendChild(fr),
                            wr.appendChild(tr),
                            wr.nodeId = cr.id,
                            wr
                        }
                    }],
                    (gr = [{
                        key: "init",
                        value: function(cr) {
                            var Ar = ar.parseTreeData(cr)
                              , wr = Ar.treeNodes
                              , Rr = Ar.nodesById
                              , Cr = Ar.leafNodesById
                              , tr = Ar.defaultValues
                              , fr = Ar.defaultDisables;
                            this.treeNodes = wr,
                            this.nodesById = Rr,
                            this.leafNodesById = Cr,
                            this.render(this.treeNodes);
                            var vr = this.options
                              , Zr = vr.values
                              , rn = vr.disables
                              , hn = vr.loaded;
                            Zr && Zr.length ? this.setValues(Zr) : tr && tr.length && this.setValues(tr),
                            rn && rn.length ? this.setDisables(rn) : fr && fr.length && this.setDisables(fr),
                            typeof hn == "function" && hn.call(this)
                        }
                    }, {
                        key: "render",
                        value: function(cr) {
                            var Ar = ar.createRootEle();
                            Ar.appendChild(this.buildTree(cr, 0)),
                            this.bindEvent(Ar);
                            var wr = typeof this.container == "string" ? document.querySelector(this.container) : this.container;
                            (function(Rr) {
                                for (; Rr.firstChild; )
                                    Rr.removeChild(Rr.firstChild)
                            }
                            )(wr),
                            wr.appendChild(Ar)
                        }
                    }, {
                        key: "buildTree",
                        value: function(cr, Ar) {
                            var wr = this
                              , Rr = ar.createUlEle();
                            return cr && cr.length && cr.forEach(function(Cr) {
                                var tr = ar.createLiEle(Cr, Ar === wr.options.closeDepth - 1);
                                wr.liElementsById[Cr.id] = tr;
                                var fr = null;
                                Cr.children && Cr.children.length && (fr = wr.buildTree(Cr.children, Ar + 1)),
                                fr && tr.appendChild(fr),
                                Rr.appendChild(tr)
                            }),
                            Rr
                        }
                    }, {
                        key: "bindEvent",
                        value: function(cr) {
                            var Ar = this;
                            cr.addEventListener("click", function(wr) {
                                var Rr = wr.target;
                                Rr.nodeName === "SPAN" && Rr.classList.contains("treejs-checkbox") ? Ar.onItemClick(Rr.parentNode.nodeId) : Rr.nodeName === "SPAN" && Rr.classList.contains("treejs-label") ? Ar.onItemLabelClick(Rr.parentNode.nodeId) : Rr.nodeName === "LI" && Rr.classList.contains("treejs-node") ? Ar.onItemClick(Rr.nodeId) : Rr.nodeName === "SPAN" && Rr.classList.contains("treejs-switcher") && ar.onSwitcherClick(Rr)
                            }, !1)
                        }
                    }, {
                        key: "onItemClick",
                        value: function(cr) {
                            var Ar = this.nodesById[cr]
                              , wr = this.options.onChange;
                            Ar.disabled || (this.setValue(cr),
                            this.updateLiElements()),
                            wr && wr.call(this)
                        }
                    }, {
                        key: "onItemLabelClick",
                        value: function(cr) {
                            var Ar = this.options.onItemLabelClick;
                            Ar && Ar.call(this, cr)
                        }
                    }, {
                        key: "setValue",
                        value: function(cr) {
                            var Ar = this.nodesById[cr];
                            if (Ar) {
                                var wr = Ar.status
                                  , Rr = wr === 1 || wr === 2 ? 0 : 2;
                                Ar.status = Rr,
                                this.markWillUpdateNode(Ar),
                                this.walkUp(Ar, "status"),
                                this.walkDown(Ar, "status")
                            }
                        }
                    }, {
                        key: "getValues",
                        value: function() {
                            var cr = this
                              , Ar = [];
                            return Object.keys(this.leafNodesById).forEach(function(wr) {
                                Object.prototype.hasOwnProperty.call(cr.leafNodesById, wr) && (cr.leafNodesById[wr].status !== 1 && cr.leafNodesById[wr].status !== 2 || Ar.push(wr))
                            }),
                            Ar
                        }
                    }, {
                        key: "setValues",
                        value: function(cr) {
                            var Ar = this;
                            this.emptyNodesCheckStatus(),
                            cr.forEach(function(Rr) {
                                Ar.setValue(Rr)
                            }),
                            this.updateLiElements();
                            var wr = this.options.onChange;
                            wr && wr.call(this)
                        }
                    }, {
                        key: "setDisable",
                        value: function(cr) {
                            var Ar = this.nodesById[cr];
                            Ar && (Ar.disabled || (Ar.disabled = !0,
                            this.markWillUpdateNode(Ar),
                            this.walkUp(Ar, "disabled"),
                            this.walkDown(Ar, "disabled")))
                        }
                    }, {
                        key: "getDisables",
                        value: function() {
                            var cr = this
                              , Ar = [];
                            return Object.keys(this.leafNodesById).forEach(function(wr) {
                                Object.prototype.hasOwnProperty.call(cr.leafNodesById, wr) && cr.leafNodesById[wr].disabled && Ar.push(wr)
                            }),
                            Ar
                        }
                    }, {
                        key: "setDisables",
                        value: function(cr) {
                            var Ar = this;
                            this.emptyNodesDisable(),
                            cr.forEach(function(wr) {
                                Ar.setDisable(wr)
                            }),
                            this.updateLiElements()
                        }
                    }, {
                        key: "emptyNodesCheckStatus",
                        value: function() {
                            this.willUpdateNodesById = this.getSelectedNodesById(),
                            Object.values(this.willUpdateNodesById).forEach(function(cr) {
                                cr.disabled || (cr.status = 0)
                            })
                        }
                    }, {
                        key: "emptyNodesDisable",
                        value: function() {
                            this.willUpdateNodesById = this.getDisabledNodesById(),
                            Object.values(this.willUpdateNodesById).forEach(function(cr) {
                                cr.disabled = !1
                            })
                        }
                    }, {
                        key: "getSelectedNodesById",
                        value: function() {
                            return Object.entries(this.nodesById).reduce(function(cr, Ar) {
                                var wr = Dt(Ar, 2)
                                  , Rr = wr[0]
                                  , Cr = wr[1];
                                return Cr.status !== 1 && Cr.status !== 2 || (cr[Rr] = Cr),
                                cr
                            }, {})
                        }
                    }, {
                        key: "getDisabledNodesById",
                        value: function() {
                            return Object.entries(this.nodesById).reduce(function(cr, Ar) {
                                var wr = Dt(Ar, 2)
                                  , Rr = wr[0]
                                  , Cr = wr[1];
                                return Cr.disabled && (cr[Rr] = Cr),
                                cr
                            }, {})
                        }
                    }, {
                        key: "updateLiElements",
                        value: function() {
                            var cr = this;
                            Object.values(this.willUpdateNodesById).forEach(function(Ar) {
                                cr.updateLiElement(Ar)
                            }),
                            this.willUpdateNodesById = {}
                        }
                    }, {
                        key: "markWillUpdateNode",
                        value: function(cr) {
                            this.willUpdateNodesById[cr.id] = cr
                        }
                    }, {
                        key: "walkUp",
                        value: function(cr, Ar) {
                            var wr = cr.parent;
                            if (wr) {
                                if (Ar === "status") {
                                    var Rr, Cr = wr.children.reduce(function(fr, vr) {
                                        return Number.isNaN(vr.status) ? fr : fr + vr.status
                                    }, 0);
                                    if (Rr = Cr ? Cr === 2 * wr.children.length ? 2 : 1 : 0,
                                    wr.status === Rr)
                                        return;
                                    wr.status = Rr
                                } else {
                                    var tr = wr.children.reduce(function(fr, vr) {
                                        return fr && vr.disabled
                                    }, !0);
                                    if (wr.disabled === tr)
                                        return;
                                    wr.disabled = tr
                                }
                                this.markWillUpdateNode(wr),
                                this.walkUp(wr, Ar)
                            }
                        }
                    }, {
                        key: "walkDown",
                        value: function(cr, Ar) {
                            var wr = this;
                            cr.children && cr.children.length && cr.children.forEach(function(Rr) {
                                Ar === "status" && Rr.disabled || (Rr[Ar] = cr[Ar],
                                wr.markWillUpdateNode(Rr),
                                wr.walkDown(Rr, Ar))
                            })
                        }
                    }, {
                        key: "updateLiElement",
                        value: function(cr) {
                            var Ar = this.liElementsById[cr.id].classList;
                            switch (cr.status) {
                            case 0:
                                Ar.remove("treejs-node__halfchecked", "treejs-node__checked");
                                break;
                            case 1:
                                Ar.remove("treejs-node__checked"),
                                Ar.add("treejs-node__halfchecked");
                                break;
                            case 2:
                                Ar.remove("treejs-node__halfchecked"),
                                Ar.add("treejs-node__checked")
                            }
                            switch (cr.disabled) {
                            case !0:
                                Ar.contains("treejs-node__disabled") || Ar.add("treejs-node__disabled");
                                break;
                            case !1:
                                Ar.contains("treejs-node__disabled") && Ar.remove("treejs-node__disabled")
                            }
                        }
                    }, {
                        key: "collapseAll",
                        value: function() {
                            var cr = this;
                            Object.keys(this.leafNodesById).forEach(function(Ar) {
                                var wr = cr.leafNodesById[Ar];
                                or(cr, wr)
                            })
                        }
                    }, {
                        key: "expandAll",
                        value: function() {
                            ir(this, this.treeNodes[0])
                        }
                    }]) && Ht(hr.prototype, gr),
                    dr && Ht(hr, dr),
                    Object.defineProperty(hr, "prototype", {
                        writable: !1
                    }),
                    ar
                }()
            }(),
            _.default
        }()
    },
    282: function(d, o) {
        (function(c) {
            const h = "tp";
            function _(Bt) {
                return kt => Ut => {
                    if (!kt && Ut === void 0)
                        return {
                            succeeded: !1,
                            value: void 0
                        };
                    if (kt && Ut === void 0)
                        return {
                            succeeded: !0,
                            value: void 0
                        };
                    const Ht = Bt(Ut);
                    return Ht !== void 0 ? {
                        succeeded: !0,
                        value: Ht
                    } : {
                        succeeded: !1,
                        value: void 0
                    }
                }
            }
            function b(Bt) {
                return {
                    custom: kt => _(kt)(Bt),
                    boolean: _(kt => typeof kt == "boolean" ? kt : void 0)(Bt),
                    number: _(kt => typeof kt == "number" ? kt : void 0)(Bt),
                    string: _(kt => typeof kt == "string" ? kt : void 0)(Bt),
                    function: _(kt => typeof kt == "function" ? kt : void 0)(Bt),
                    constant: kt => _(Ut => Ut === kt ? kt : void 0)(Bt),
                    raw: _(kt => kt)(Bt),
                    object: kt => _(Ut => {
                        if ((Ht = Ut) !== null && typeof Ht == "object")
                            return function(Kt, Jt) {
                                return Object.keys(Jt).reduce( (ir, lr) => {
                                    if (ir === void 0)
                                        return;
                                    const ar = (0,
                                    Jt[lr])(Kt[lr]);
                                    return ar.succeeded ? Object.assign(Object.assign({}, ir), {
                                        [lr]: ar.value
                                    }) : void 0
                                }
                                , {})
                            }(Ut, kt);
                        var Ht
                    }
                    )(Bt),
                    array: kt => _(Ut => {
                        if (Array.isArray(Ut))
                            return Ht = kt,
                            Ut.reduce( (Kt, Jt) => {
                                if (Kt === void 0)
                                    return;
                                const or = Ht(Jt);
                                return or.succeeded && or.value !== void 0 ? [...Kt, or.value] : void 0
                            }
                            , []);
                        var Ht
                    }
                    )(Bt)
                }
            }
            const _e = {
                optional: b(!0),
                required: b(!1)
            };
            function nt(Bt) {
                return kt => kt.toFixed(Math.max(Math.min(Bt, 20), 0))
            }
            function it(Bt) {
                return [Bt[0], Bt[1], Bt[2]]
            }
            function at(Bt) {
                return kt => function(Ut, Ht) {
                    const Kt = nt(Ht === "float" ? 2 : 0);
                    return `rgb(${it(Ut.getComponents("rgb", Ht)).map(Jt => Kt(Jt)).join(", ")})`
                }(kt, Bt)
            }
            function ut(Bt) {
                return kt => function(Ut, Ht) {
                    const Kt = nt(2)
                      , Jt = nt(Ht === "float" ? 2 : 0);
                    return `rgba(${Ut.getComponents("rgb", Ht).map( (or, ir) => (ir === 3 ? Kt : Jt)(or)).join(", ")})`
                }(kt, Bt)
            }
            function pt(Bt) {
                return kt => function(Ut, Ht) {
                    const Kt = nt(Ht === "float" ? 2 : 0)
                      , Jt = ["r", "g", "b"];
                    return `{${it(Ut.getComponents("rgb", Ht)).map( (or, ir) => `${Jt[ir]}: ${Kt(or)}`).join(", ")}}`
                }(kt, Bt)
            }
            function ht(Bt) {
                return kt => function(Ut, Ht) {
                    const Kt = nt(2)
                      , Jt = nt(Ht === "float" ? 2 : 0)
                      , or = ["r", "g", "b", "a"];
                    return `{${Ut.getComponents("rgb", Ht).map( (ir, lr) => `${or[lr]}: ${(lr === 3 ? Kt : Jt)(ir)}`).join(", ")}}`
                }(kt, Bt)
            }
            function _t(Bt, kt, Ut, Ht) {
                return new (Ut || (Ut = Promise))(function(Kt, Jt) {
                    function or(ar) {
                        try {
                            lr(Ht.next(ar))
                        } catch (hr) {
                            Jt(hr)
                        }
                    }
                    function ir(ar) {
                        try {
                            lr(Ht.throw(ar))
                        } catch (hr) {
                            Jt(hr)
                        }
                    }
                    function lr(ar) {
                        var hr;
                        ar.done ? Kt(ar.value) : (hr = ar.value,
                        hr instanceof Ut ? hr : new Ut(function(gr) {
                            gr(hr)
                        }
                        )).then(or, ir)
                    }
                    lr((Ht = Ht.apply(Bt, [])).next())
                }
                )
            }
            function vt(Bt) {
                return _t(this, void 0, void 0, function*() {
                    const kt = new Image;
                    return kt.crossOrigin = "anonymous",
                    new Promise( (Ut, Ht) => {
                        kt.src = Bt,
                        kt.onload = () => {
                            Ut(kt)
                        }
                        ,
                        kt.onerror = Ht
                    }
                    )
                })
            }
            ["int", "float"].reduce( (Bt, kt) => [...Bt, {
                format: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "func",
                    type: kt
                },
                stringifier: at(kt)
            }, {
                format: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "func",
                    type: kt
                },
                stringifier: ut(kt)
            }, {
                format: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "object",
                    type: kt
                },
                stringifier: pt(kt)
            }, {
                format: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "object",
                    type: kt
                },
                stringifier: ht(kt)
            }], []);
            const bt = (St = "img",
            (Bt, kt) => [h, "-", St, "v", Bt ? `_${Bt}` : "", kt ? `-${kt}` : ""].join(""));
            var St;
            class At {
                constructor(kt, Ut) {
                    this.element = kt.createElement("div"),
                    this.element.classList.add(bt()),
                    Ut.viewProps.bindClassModifiers(this.element),
                    this.input = kt.createElement("input"),
                    this.input.classList.add(bt("input")),
                    this.input.setAttribute("type", "file"),
                    this.input.setAttribute("accept", Ut.extensions.join(",")),
                    this.image_ = kt.createElement("img"),
                    this.image_.classList.add(bt("image")),
                    this.image_.classList.add(bt(`image_${Ut.imageFit}`)),
                    this.image_.crossOrigin = "anonymous",
                    this.image_.onclick = Ht => {
                        Ut.clickCallback ? Ut.clickCallback(Ht, this.input) : this.input.click()
                    }
                    ,
                    this.element.classList.add(bt("area_root")),
                    this.element.appendChild(this.image_),
                    this.element.appendChild(this.input)
                }
                changeImage(kt) {
                    this.image_.src = kt
                }
                changeDraggingState(kt) {
                    const Ut = this.element;
                    kt ? Ut == null || Ut.classList.add(bt("area_dragging")) : Ut == null || Ut.classList.remove(bt("area_dragging"))
                }
            }
            let Et = null;
            class Pt {
                constructor(kt, Ut) {
                    this.value = Ut.value,
                    this.viewProps = Ut.viewProps,
                    this.view = new At(kt,{
                        viewProps: this.viewProps,
                        extensions: Ut.extensions,
                        imageFit: Ut.imageFit,
                        clickCallback: Ut.clickCallback
                    }),
                    this.onFile = this.onFile.bind(this),
                    this.onDrop = this.onDrop.bind(this),
                    this.onDragOver = this.onDragOver.bind(this),
                    this.onDragLeave = this.onDragLeave.bind(this),
                    this.view.input.addEventListener("change", this.onFile),
                    this.view.element.addEventListener("drop", this.onDrop),
                    this.view.element.addEventListener("dragover", this.onDragOver),
                    this.view.element.addEventListener("dragleave", this.onDragLeave),
                    this.viewProps.handleDispose( () => {
                        this.view.input.removeEventListener("change", this.onFile),
                        this.view.input.removeEventListener("drop", this.onDrop),
                        this.view.input.removeEventListener("dragover", this.onDragOver),
                        this.view.input.removeEventListener("dragleave", this.onDragLeave)
                    }
                    ),
                    this.value.emitter.on("change", this.handleValueChange.bind(this)),
                    this.handleValueChange()
                }
                onFile(kt) {
                    const Ut = (kt == null ? void 0 : kt.target).files;
                    if (!Ut || !Ut.length)
                        return;
                    const Ht = Ut[0];
                    this.setValue(Ht)
                }
                onDrop(kt) {
                    return _t(this, void 0, void 0, function*() {
                        kt.preventDefault();
                        try {
                            const {dataTransfer: Ut} = kt
                              , Ht = Ut == null ? void 0 : Ut.files[0];
                            if (Ht)
                                this.setValue(Ht);
                            else {
                                const Kt = Ut == null ? void 0 : Ut.getData("url");
                                if (!Kt)
                                    throw new Error("No url");
                                this.setValue(Kt)
                            }
                        } catch (Ut) {
                            console.error("Could not parse the dropped image", Ut)
                        } finally {
                            this.view.changeDraggingState(!1)
                        }
                    })
                }
                onDragOver(kt) {
                    kt.preventDefault(),
                    this.view.changeDraggingState(!0)
                }
                onDragLeave() {
                    this.view.changeDraggingState(!1)
                }
                handleImage(kt) {
                    return _t(this, void 0, void 0, function*() {
                        kt instanceof HTMLImageElement ? this.updateImage(kt.src) : typeof kt != "string" && kt ? yield this.setValue(kt) : (kt !== "placeholder" && kt || (kt = (yield this.handlePlaceholderImage()).src),
                        this.updateImage(kt))
                    })
                }
                updateImage(kt) {
                    this.view.changeImage(kt)
                }
                setValue(kt) {
                    return _t(this, void 0, void 0, function*() {
                        if (kt instanceof HTMLImageElement)
                            this.value.setRawValue(kt);
                        else if (kt instanceof File) {
                            const Ut = URL.createObjectURL(kt) + "#" + kt.name;
                            kt.src = Ut;
                            const Ht = yield vt(Ut).catch( () => {}
                            );
                            this.value.setRawValue(Ht || kt)
                        } else
                            kt ? this.value.setRawValue(yield vt(kt)) : this.value.setRawValue(yield this.handlePlaceholderImage())
                    })
                }
                handleValueChange() {
                    this.handleImage(this.value.rawValue)
                }
                handlePlaceholderImage() {
                    return _t(this, void 0, void 0, function*() {
                        return Et || (Et = yield function() {
                            const kt = document.createElement("canvas");
                            kt.width = 320,
                            kt.height = 50;
                            const Ut = kt.getContext("2d");
                            return Ut.fillStyle = "#00000004",
                            Ut.fillRect(0, 0, kt.width, kt.height),
                            Ut.fillStyle = "#eee",
                            Ut.font = '1.25rem "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace',
                            Ut.textAlign = "center",
                            Ut.textBaseline = "middle",
                            Ut.fillText("No image", .5 * kt.width, .5 * kt.height),
                            new Promise(Ht => {
                                kt.toBlob(Kt => {
                                    const Jt = new Image;
                                    Jt.src = URL.createObjectURL(Kt),
                                    Jt.isPlaceholder = !0,
                                    Jt.onload = () => {
                                        Ht(Jt)
                                    }
                                }
                                )
                            }
                            )
                        }()),
                        Et
                    })
                }
            }
            const It = [".jpg", ".png", ".gif"]
              , Dt = {
                id: "input-image",
                type: "input",
                css: ".tp-imgv{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-imgv{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-imgv:hover{background-color:var(--in-bg-h)}.tp-imgv:focus{background-color:var(--in-bg-f)}.tp-imgv:active{background-color:var(--in-bg-a)}.tp-imgv:disabled{opacity:.5}:root{--tp-plugin-image-dragging-color: hsla(230, 100%, 66%, 1.00)}.tp-imgv{cursor:pointer;display:inline-flex;height:auto !important;max-height:calc(var(--bld-us)*3);border-radius:4px;position:relative}.tp-imgv.tp-v-disabled{opacity:.5}.tp-imgv_input{width:0;height:0;pointer-events:none;visibility:hidden}.tp-imgv_image{width:100%;height:-moz-max-content;height:max-content;max-height:calc(var(--bld-us)*3);border:0}.tp-imgv_image_contain{-o-object-fit:contain;object-fit:contain}.tp-imgv_image_cover{-o-object-fit:cover;object-fit:cover}.tp-imgv_area_root{transition:opacity .16s ease-in-out}.tp-imgv_area_dragging{border:2px dashed var(--tp-plugin-image-dragging-color);border-radius:4px;opacity:.6}",
                accept(Bt, kt) {
                    if (!(Bt instanceof HTMLImageElement || typeof Bt == "string"))
                        return null;
                    const Ut = _e
                      , Ht = function(Kt, Jt) {
                        const or = _e.required.object(Jt)(Kt);
                        return or.succeeded ? or.value : void 0
                    }(kt, {
                        view: Ut.required.constant("input-image"),
                        acceptUrl: Ut.optional.boolean,
                        clickCallback: Ut.optional.function,
                        imageFit: Ut.optional.custom(Kt => Kt === "contain" || Kt === "cover" ? Kt : void 0),
                        extensions: Ut.optional.array(Ut.required.string)
                    });
                    return Ht ? {
                        initialValue: Bt,
                        params: Ht
                    } : null
                },
                binding: {
                    reader(Bt) {
                        return kt => kt.src !== void 0 ? kt.src === "" ? "placeholder" : kt.src : kt
                    },
                    writer(Bt) {
                        return (kt, Ut) => {
                            kt.write(Ut)
                        }
                    }
                },
                controller(Bt) {
                    var kt, Ut;
                    return new Pt(Bt.document,{
                        value: Bt.value,
                        imageFit: (kt = Bt.params.imageFit) !== null && kt !== void 0 ? kt : "cover",
                        clickCallback: Bt.params.clickCallback,
                        viewProps: Bt.viewProps,
                        extensions: (Ut = Bt.params.extensions) !== null && Ut !== void 0 ? Ut : It
                    })
                }
            }
              , Gt = Dt;
            c.plugin = Gt,
            Object.defineProperty(c, "__esModule", {
                value: !0
            })
        }
        )(o)
    },
    578: function(d, o) {
        (function(c) {
            class h {
                constructor(wt) {
                    this.controller_ = wt
                }
                get element() {
                    return this.controller_.view.element
                }
                get disabled() {
                    return this.controller_.viewProps.get("disabled")
                }
                set disabled(wt) {
                    this.controller_.viewProps.set("disabled", wt)
                }
                get hidden() {
                    return this.controller_.viewProps.get("hidden")
                }
                set hidden(wt) {
                    this.controller_.viewProps.set("hidden", wt)
                }
                dispose() {
                    this.controller_.viewProps.set("disposed", !0)
                }
            }
            class _ {
                constructor(wt) {
                    this.target = wt
                }
            }
            class b extends _ {
                constructor(wt, Rt, zt, nr) {
                    super(wt),
                    this.value = Rt,
                    this.presetKey = zt,
                    this.last = nr == null || nr
                }
            }
            class _e extends _ {
                constructor(wt, Rt, zt) {
                    super(wt),
                    this.value = Rt,
                    this.presetKey = zt
                }
            }
            class nt extends _ {
                constructor(wt, Rt) {
                    super(wt),
                    this.expanded = Rt
                }
            }
            class it extends _ {
                constructor(wt, Rt) {
                    super(wt),
                    this.index = Rt
                }
            }
            function at(Vt) {
                return Vt == null
            }
            function ut(Vt, wt) {
                if (Vt.length !== wt.length)
                    return !1;
                for (let Rt = 0; Rt < Vt.length; Rt++)
                    if (Vt[Rt] !== wt[Rt])
                        return !1;
                return !0
            }
            function pt(Vt, wt) {
                let Rt = Vt;
                do {
                    const zt = Object.getOwnPropertyDescriptor(Rt, wt);
                    if (zt && (zt.set !== void 0 || zt.writable === !0))
                        return !0;
                    Rt = Object.getPrototypeOf(Rt)
                } while (Rt !== null);
                return !1
            }
            const ht = {
                alreadydisposed: () => "View has been already disposed",
                invalidparams: Vt => `Invalid parameters for '${Vt.name}'`,
                nomatchingcontroller: Vt => `No matching controller for '${Vt.key}'`,
                nomatchingview: Vt => `No matching view for '${JSON.stringify(Vt.params)}'`,
                notbindable: () => "Value is not bindable",
                propertynotfound: Vt => `Property '${Vt.name}' not found`,
                shouldneverhappen: () => "This error should never happen"
            };
            class _t {
                static alreadyDisposed() {
                    return new _t({
                        type: "alreadydisposed"
                    })
                }
                static notBindable() {
                    return new _t({
                        type: "notbindable"
                    })
                }
                static propertyNotFound(wt) {
                    return new _t({
                        type: "propertynotfound",
                        context: {
                            name: wt
                        }
                    })
                }
                static shouldNeverHappen() {
                    return new _t({
                        type: "shouldneverhappen"
                    })
                }
                constructor(wt) {
                    var Rt;
                    this.message = (Rt = ht[wt.type](wt.context)) !== null && Rt !== void 0 ? Rt : "Unexpected error",
                    this.name = this.constructor.name,
                    this.stack = new Error(this.message).stack,
                    this.type = wt.type
                }
            }
            class vt {
                constructor(wt, Rt, zt) {
                    this.obj_ = wt,
                    this.key_ = Rt,
                    this.presetKey_ = zt ?? Rt
                }
                static isBindable(wt) {
                    return wt !== null && (typeof wt == "object" || typeof wt == "function")
                }
                get key() {
                    return this.key_
                }
                get presetKey() {
                    return this.presetKey_
                }
                read() {
                    return this.obj_[this.key_]
                }
                write(wt) {
                    this.obj_[this.key_] = wt
                }
                writeProperty(wt, Rt) {
                    const zt = this.read();
                    if (!vt.isBindable(zt))
                        throw _t.notBindable();
                    if (!(wt in zt))
                        throw _t.propertyNotFound(wt);
                    zt[wt] = Rt
                }
            }
            class bt extends h {
                get label() {
                    return this.controller_.props.get("label")
                }
                set label(wt) {
                    this.controller_.props.set("label", wt)
                }
                get title() {
                    var wt;
                    return (wt = this.controller_.valueController.props.get("title")) !== null && wt !== void 0 ? wt : ""
                }
                set title(wt) {
                    this.controller_.valueController.props.set("title", wt)
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.controller_.valueController.emitter.on(wt, () => {
                        zt(new _(this))
                    }
                    ),
                    this
                }
            }
            class St {
                constructor() {
                    this.observers_ = {}
                }
                on(wt, Rt) {
                    let zt = this.observers_[wt];
                    return zt || (zt = this.observers_[wt] = []),
                    zt.push({
                        handler: Rt
                    }),
                    this
                }
                off(wt, Rt) {
                    const zt = this.observers_[wt];
                    return zt && (this.observers_[wt] = zt.filter(nr => nr.handler !== Rt)),
                    this
                }
                emit(wt, Rt) {
                    const zt = this.observers_[wt];
                    zt && zt.forEach(nr => {
                        nr.handler(Rt)
                    }
                    )
                }
            }
            const At = "tp";
            function Et(Vt) {
                return (wt, Rt) => [At, "-", Vt, "v", wt ? `_${wt}` : "", Rt ? `-${Rt}` : ""].join("")
            }
            function Pt(Vt) {
                return Vt.rawValue
            }
            function It(Vt, wt) {
                var Rt, zt;
                Vt.emitter.on("change", (Rt = Pt,
                zt = wt,
                nr => zt(Rt(nr)))),
                wt(Vt.rawValue)
            }
            function Dt(Vt, wt, Rt) {
                It(Vt.value(wt), Rt)
            }
            function Gt(Vt, wt) {
                return Rt => {
                    (function(zt, nr, mr) {
                        mr ? zt.classList.add(nr) : zt.classList.remove(nr)
                    }
                    )(Vt, wt, Rt)
                }
            }
            function Bt(Vt, wt) {
                It(Vt, Rt => {
                    wt.textContent = Rt ?? ""
                }
                )
            }
            const kt = Et("btn");
            class Ut {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(kt()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("button");
                    zt.classList.add(kt("b")),
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.buttonElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(kt("t")),
                    Bt(Rt.props.value("title"), nr),
                    this.buttonElement.appendChild(nr)
                }
            }
            class Ht {
                constructor(wt, Rt) {
                    this.emitter = new St,
                    this.onClick_ = this.onClick_.bind(this),
                    this.props = Rt.props,
                    this.viewProps = Rt.viewProps,
                    this.view = new Ut(wt,{
                        props: this.props,
                        viewProps: this.viewProps
                    }),
                    this.view.buttonElement.addEventListener("click", this.onClick_)
                }
                onClick_() {
                    this.emitter.emit("click", {
                        sender: this
                    })
                }
            }
            class Kt {
                constructor(wt, Rt) {
                    var zt;
                    this.constraint_ = Rt == null ? void 0 : Rt.constraint,
                    this.equals_ = (zt = Rt == null ? void 0 : Rt.equals) !== null && zt !== void 0 ? zt : (nr, mr) => nr === mr,
                    this.emitter = new St,
                    this.rawValue_ = wt
                }
                get constraint() {
                    return this.constraint_
                }
                get rawValue() {
                    return this.rawValue_
                }
                set rawValue(wt) {
                    this.setRawValue(wt, {
                        forceEmit: !1,
                        last: !0
                    })
                }
                setRawValue(wt, Rt) {
                    const zt = Rt ?? {
                        forceEmit: !1,
                        last: !0
                    }
                      , nr = this.constraint_ ? this.constraint_.constrain(wt) : wt
                      , mr = this.rawValue_;
                    (!this.equals_(mr, nr) || zt.forceEmit) && (this.emitter.emit("beforechange", {
                        sender: this
                    }),
                    this.rawValue_ = nr,
                    this.emitter.emit("change", {
                        options: zt,
                        previousRawValue: mr,
                        rawValue: nr,
                        sender: this
                    }))
                }
            }
            class Jt {
                constructor(wt) {
                    this.emitter = new St,
                    this.value_ = wt
                }
                get rawValue() {
                    return this.value_
                }
                set rawValue(wt) {
                    this.setRawValue(wt, {
                        forceEmit: !1,
                        last: !0
                    })
                }
                setRawValue(wt, Rt) {
                    const zt = Rt ?? {
                        forceEmit: !1,
                        last: !0
                    }
                      , nr = this.value_;
                    (nr !== wt || zt.forceEmit) && (this.emitter.emit("beforechange", {
                        sender: this
                    }),
                    this.value_ = wt,
                    this.emitter.emit("change", {
                        options: zt,
                        previousRawValue: nr,
                        rawValue: this.value_,
                        sender: this
                    }))
                }
            }
            function or(Vt, wt) {
                const Rt = wt == null ? void 0 : wt.constraint
                  , zt = wt == null ? void 0 : wt.equals;
                return Rt || zt ? new Kt(Vt,wt) : new Jt(Vt)
            }
            class ir {
                constructor(wt) {
                    this.emitter = new St,
                    this.valMap_ = wt;
                    for (const Rt in this.valMap_)
                        this.valMap_[Rt].emitter.on("change", () => {
                            this.emitter.emit("change", {
                                key: Rt,
                                sender: this
                            })
                        }
                        )
                }
                static createCore(wt) {
                    return Object.keys(wt).reduce( (Rt, zt) => Object.assign(Rt, {
                        [zt]: or(wt[zt])
                    }), {})
                }
                static fromObject(wt) {
                    const Rt = this.createCore(wt);
                    return new ir(Rt)
                }
                get(wt) {
                    return this.valMap_[wt].rawValue
                }
                set(wt, Rt) {
                    this.valMap_[wt].rawValue = Rt
                }
                value(wt) {
                    return this.valMap_[wt]
                }
            }
            function lr(Vt) {
                return wt => Rt => {
                    if (!wt && Rt === void 0)
                        return {
                            succeeded: !1,
                            value: void 0
                        };
                    if (wt && Rt === void 0)
                        return {
                            succeeded: !0,
                            value: void 0
                        };
                    const zt = Vt(Rt);
                    return zt !== void 0 ? {
                        succeeded: !0,
                        value: zt
                    } : {
                        succeeded: !1,
                        value: void 0
                    }
                }
            }
            function ar(Vt) {
                return {
                    custom: wt => lr(wt)(Vt),
                    boolean: lr(wt => typeof wt == "boolean" ? wt : void 0)(Vt),
                    number: lr(wt => typeof wt == "number" ? wt : void 0)(Vt),
                    string: lr(wt => typeof wt == "string" ? wt : void 0)(Vt),
                    function: lr(wt => typeof wt == "function" ? wt : void 0)(Vt),
                    constant: wt => lr(Rt => Rt === wt ? wt : void 0)(Vt),
                    raw: lr(wt => wt)(Vt),
                    object: wt => lr(Rt => {
                        if ((zt = Rt) !== null && typeof zt == "object")
                            return function(nr, mr) {
                                return Object.keys(mr).reduce( ($r, vn) => {
                                    if ($r === void 0)
                                        return;
                                    const zn = (0,
                                    mr[vn])(nr[vn]);
                                    return zn.succeeded ? Object.assign(Object.assign({}, $r), {
                                        [vn]: zn.value
                                    }) : void 0
                                }
                                , {})
                            }(Rt, wt);
                        var zt
                    }
                    )(Vt),
                    array: wt => lr(Rt => {
                        if (Array.isArray(Rt))
                            return zt = wt,
                            Rt.reduce( (nr, mr) => {
                                if (nr === void 0)
                                    return;
                                const Tr = zt(mr);
                                return Tr.succeeded && Tr.value !== void 0 ? [...nr, Tr.value] : void 0
                            }
                            , []);
                        var zt
                    }
                    )(Vt)
                }
            }
            const hr = {
                optional: ar(!0),
                required: ar(!1)
            };
            function gr(Vt, wt) {
                const Rt = hr.required.object(wt)(Vt);
                return Rt.succeeded ? Rt.value : void 0
            }
            function dr(Vt) {
                console.warn([`Missing '${Vt.key}' of ${Vt.target} in ${Vt.place}.`, "Please rebuild plugins with the latest core package."].join(" "))
            }
            class cr {
                constructor(wt) {
                    this.value_ = wt
                }
                static create(wt) {
                    return [new cr(wt), (Rt, zt) => {
                        wt.setRawValue(Rt, zt)
                    }
                    ]
                }
                get emitter() {
                    return this.value_.emitter
                }
                get rawValue() {
                    return this.value_.rawValue
                }
            }
            const Ar = Et("");
            function wr(Vt, wt) {
                return Gt(Vt, Ar(void 0, wt))
            }
            class Rr extends ir {
                constructor(wt) {
                    var Rt;
                    super(wt),
                    this.onDisabledChange_ = this.onDisabledChange_.bind(this),
                    this.onParentChange_ = this.onParentChange_.bind(this),
                    this.onParentGlobalDisabledChange_ = this.onParentGlobalDisabledChange_.bind(this),
                    [this.globalDisabled_,this.setGlobalDisabled_] = cr.create(or(this.getGlobalDisabled_())),
                    this.value("disabled").emitter.on("change", this.onDisabledChange_),
                    this.value("parent").emitter.on("change", this.onParentChange_),
                    (Rt = this.get("parent")) === null || Rt === void 0 || Rt.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_)
                }
                static create(wt) {
                    var Rt, zt, nr;
                    const mr = wt ?? {};
                    return new Rr(ir.createCore({
                        disabled: (Rt = mr.disabled) !== null && Rt !== void 0 && Rt,
                        disposed: !1,
                        hidden: (zt = mr.hidden) !== null && zt !== void 0 && zt,
                        parent: (nr = mr.parent) !== null && nr !== void 0 ? nr : null
                    }))
                }
                get globalDisabled() {
                    return this.globalDisabled_
                }
                bindClassModifiers(wt) {
                    It(this.globalDisabled_, wr(wt, "disabled")),
                    Dt(this, "hidden", wr(wt, "hidden"))
                }
                bindDisabled(wt) {
                    It(this.globalDisabled_, Rt => {
                        wt.disabled = Rt
                    }
                    )
                }
                bindTabIndex(wt) {
                    It(this.globalDisabled_, Rt => {
                        wt.tabIndex = Rt ? -1 : 0
                    }
                    )
                }
                handleDispose(wt) {
                    this.value("disposed").emitter.on("change", Rt => {
                        Rt && wt()
                    }
                    )
                }
                getGlobalDisabled_() {
                    const wt = this.get("parent");
                    return !!wt && wt.globalDisabled.rawValue || this.get("disabled")
                }
                updateGlobalDisabled_() {
                    this.setGlobalDisabled_(this.getGlobalDisabled_())
                }
                onDisabledChange_() {
                    this.updateGlobalDisabled_()
                }
                onParentGlobalDisabledChange_() {
                    this.updateGlobalDisabled_()
                }
                onParentChange_(wt) {
                    var Rt;
                    const zt = wt.previousRawValue;
                    zt == null || zt.globalDisabled.emitter.off("change", this.onParentGlobalDisabledChange_),
                    (Rt = this.get("parent")) === null || Rt === void 0 || Rt.globalDisabled.emitter.on("change", this.onParentGlobalDisabledChange_),
                    this.updateGlobalDisabled_()
                }
            }
            const Cr = Et("")
              , tr = {
                veryfirst: "vfst",
                first: "fst",
                last: "lst",
                verylast: "vlst"
            };
            class fr {
                constructor(wt) {
                    this.parent_ = null,
                    this.blade = wt.blade,
                    this.view = wt.view,
                    this.viewProps = wt.viewProps;
                    const Rt = this.view.element;
                    this.blade.value("positions").emitter.on("change", () => {
                        ["veryfirst", "first", "last", "verylast"].forEach(zt => {
                            Rt.classList.remove(Cr(void 0, tr[zt]))
                        }
                        ),
                        this.blade.get("positions").forEach(zt => {
                            Rt.classList.add(Cr(void 0, tr[zt]))
                        }
                        )
                    }
                    ),
                    this.viewProps.handleDispose( () => {
                        (function(zt) {
                            zt && zt.parentElement && zt.parentElement.removeChild(zt)
                        }
                        )(Rt)
                    }
                    )
                }
                get parent() {
                    return this.parent_
                }
                set parent(wt) {
                    this.parent_ = wt,
                    "parent"in this.viewProps.valMap_ ? this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null) : dr({
                        key: "parent",
                        target: Rr.name,
                        place: "BladeController.parent"
                    })
                }
            }
            const vr = "http://www.w3.org/2000/svg";
            function Zr(Vt) {
                Vt.offsetHeight
            }
            function rn(Vt) {
                return Vt.ontouchstart !== void 0
            }
            function hn() {
                return globalThis.document
            }
            const Nn = {
                check: '<path d="M2 8l4 4l8 -8"/>',
                dropdown: '<path d="M5 7h6l-3 3 z"/>',
                p2dpad: '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>'
            };
            function Wn(Vt, wt) {
                const Rt = Vt.createElementNS(vr, "svg");
                return Rt.innerHTML = Nn[wt],
                Rt
            }
            function qn(Vt, wt, Rt) {
                Vt.insertBefore(wt, Vt.children[Rt])
            }
            function mo(Vt) {
                Vt.parentElement && Vt.parentElement.removeChild(Vt)
            }
            function Ur(Vt) {
                for (; Vt.children.length > 0; )
                    Vt.removeChild(Vt.children[0])
            }
            function nn(Vt) {
                return Vt.relatedTarget ? Vt.relatedTarget : "explicitOriginalTarget"in Vt ? Vt.explicitOriginalTarget : null
            }
            const xn = Et("lbl");
            class ur {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(xn()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(xn("l")),
                    Dt(Rt.props, "label", mr => {
                        at(mr) ? this.element.classList.add(xn(void 0, "nol")) : (this.element.classList.remove(xn(void 0, "nol")),
                        function(Tr) {
                            for (; Tr.childNodes.length > 0; )
                                Tr.removeChild(Tr.childNodes[0])
                        }(zt),
                        zt.appendChild(function(Tr, $r) {
                            const vn = Tr.createDocumentFragment();
                            return $r.split(`
`).map(zn => Tr.createTextNode(zn)).forEach( (zn, co) => {
                                co > 0 && vn.appendChild(Tr.createElement("br")),
                                vn.appendChild(zn)
                            }
                            ),
                            vn
                        }(wt, mr)))
                    }
                    ),
                    this.element.appendChild(zt),
                    this.labelElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(xn("v")),
                    this.element.appendChild(nr),
                    this.valueElement = nr
                }
            }
            class pr extends fr {
                constructor(wt, Rt) {
                    const zt = Rt.valueController.viewProps;
                    super(Object.assign(Object.assign({}, Rt), {
                        view: new ur(wt,{
                            props: Rt.props,
                            viewProps: zt
                        }),
                        viewProps: zt
                    })),
                    this.props = Rt.props,
                    this.valueController = Rt.valueController,
                    this.view.valueElement.appendChild(this.valueController.view.element)
                }
            }
            const Ir = {
                id: "button",
                type: "blade",
                accept(Vt) {
                    const wt = hr
                      , Rt = gr(Vt, {
                        title: wt.required.string,
                        view: wt.required.constant("button"),
                        label: wt.optional.string
                    });
                    return Rt ? {
                        params: Rt
                    } : null
                },
                controller(Vt) {
                    return new pr(Vt.document,{
                        blade: Vt.blade,
                        props: ir.fromObject({
                            label: Vt.params.label
                        }),
                        valueController: new Ht(Vt.document,{
                            props: ir.fromObject({
                                title: Vt.params.title
                            }),
                            viewProps: Vt.viewProps
                        })
                    })
                },
                api(Vt) {
                    return Vt.controller instanceof pr && Vt.controller.valueController instanceof Ht ? new bt(Vt.controller) : null
                }
            };
            class jr extends fr {
                constructor(wt) {
                    super(wt),
                    this.value = wt.value
                }
            }
            function Qr() {
                return new ir({
                    positions: or([], {
                        equals: ut
                    })
                })
            }
            class Or extends ir {
                constructor(wt) {
                    super(wt)
                }
                static create(wt) {
                    const Rt = {
                        completed: !0,
                        expanded: wt,
                        expandedHeight: null,
                        shouldFixHeight: !1,
                        temporaryExpanded: null
                    }
                      , zt = ir.createCore(Rt);
                    return new Or(zt)
                }
                get styleExpanded() {
                    var wt;
                    return (wt = this.get("temporaryExpanded")) !== null && wt !== void 0 ? wt : this.get("expanded")
                }
                get styleHeight() {
                    if (!this.styleExpanded)
                        return "0";
                    const wt = this.get("expandedHeight");
                    return this.get("shouldFixHeight") && !at(wt) ? `${wt}px` : "auto"
                }
                bindExpandedClass(wt, Rt) {
                    const zt = () => {
                        this.styleExpanded ? wt.classList.add(Rt) : wt.classList.remove(Rt)
                    }
                    ;
                    Dt(this, "expanded", zt),
                    Dt(this, "temporaryExpanded", zt)
                }
                cleanUpTransition() {
                    this.set("shouldFixHeight", !1),
                    this.set("expandedHeight", null),
                    this.set("completed", !0)
                }
            }
            function qr(Vt, wt) {
                wt.style.height = Vt.styleHeight
            }
            function gn(Vt, wt) {
                Vt.value("expanded").emitter.on("beforechange", () => {
                    if (Vt.set("completed", !1),
                    at(Vt.get("expandedHeight"))) {
                        const Rt = function(zt, nr) {
                            let mr = 0;
                            return function(Tr, $r) {
                                const vn = Tr.style.transition;
                                Tr.style.transition = "none",
                                $r(),
                                Tr.style.transition = vn
                            }(nr, () => {
                                zt.set("expandedHeight", null),
                                zt.set("temporaryExpanded", !0),
                                Zr(nr),
                                mr = nr.clientHeight,
                                zt.set("temporaryExpanded", null),
                                Zr(nr)
                            }
                            ),
                            mr
                        }(Vt, wt);
                        Rt > 0 && Vt.set("expandedHeight", Rt)
                    }
                    Vt.set("shouldFixHeight", !0),
                    Zr(wt)
                }
                ),
                Vt.emitter.on("change", () => {
                    qr(Vt, wt)
                }
                ),
                qr(Vt, wt),
                wt.addEventListener("transitionend", Rt => {
                    Rt.propertyName === "height" && Vt.cleanUpTransition()
                }
                )
            }
            class Mn extends h {
                constructor(wt, Rt) {
                    super(wt),
                    this.rackApi_ = Rt
                }
            }
            class Tn {
                constructor(wt) {
                    this.emitter = new St,
                    this.items_ = [],
                    this.cache_ = new Set,
                    this.onSubListAdd_ = this.onSubListAdd_.bind(this),
                    this.onSubListRemove_ = this.onSubListRemove_.bind(this),
                    this.extract_ = wt
                }
                get items() {
                    return this.items_
                }
                allItems() {
                    return Array.from(this.cache_)
                }
                find(wt) {
                    for (const Rt of this.allItems())
                        if (wt(Rt))
                            return Rt;
                    return null
                }
                includes(wt) {
                    return this.cache_.has(wt)
                }
                add(wt, Rt) {
                    if (this.includes(wt))
                        throw _t.shouldNeverHappen();
                    const zt = Rt !== void 0 ? Rt : this.items_.length;
                    this.items_.splice(zt, 0, wt),
                    this.cache_.add(wt);
                    const nr = this.extract_(wt);
                    nr && (nr.emitter.on("add", this.onSubListAdd_),
                    nr.emitter.on("remove", this.onSubListRemove_),
                    nr.allItems().forEach(mr => {
                        this.cache_.add(mr)
                    }
                    )),
                    this.emitter.emit("add", {
                        index: zt,
                        item: wt,
                        root: this,
                        target: this
                    })
                }
                remove(wt) {
                    const Rt = this.items_.indexOf(wt);
                    if (Rt < 0)
                        return;
                    this.items_.splice(Rt, 1),
                    this.cache_.delete(wt);
                    const zt = this.extract_(wt);
                    zt && (zt.emitter.off("add", this.onSubListAdd_),
                    zt.emitter.off("remove", this.onSubListRemove_)),
                    this.emitter.emit("remove", {
                        index: Rt,
                        item: wt,
                        root: this,
                        target: this
                    })
                }
                onSubListAdd_(wt) {
                    this.cache_.add(wt.item),
                    this.emitter.emit("add", {
                        index: wt.index,
                        item: wt.item,
                        root: this,
                        target: wt.target
                    })
                }
                onSubListRemove_(wt) {
                    this.cache_.delete(wt.item),
                    this.emitter.emit("remove", {
                        index: wt.index,
                        item: wt.item,
                        root: this,
                        target: wt.target
                    })
                }
            }
            class wn extends h {
                constructor(wt) {
                    super(wt),
                    this.onBindingChange_ = this.onBindingChange_.bind(this),
                    this.emitter_ = new St,
                    this.controller_.binding.emitter.on("change", this.onBindingChange_)
                }
                get label() {
                    return this.controller_.props.get("label")
                }
                set label(wt) {
                    this.controller_.props.set("label", wt)
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
                refresh() {
                    this.controller_.binding.read()
                }
                onBindingChange_(wt) {
                    const Rt = wt.sender.target.read();
                    this.emitter_.emit("change", {
                        event: new b(this,Rt,this.controller_.binding.target.presetKey,wt.options.last)
                    })
                }
            }
            class Cn extends pr {
                constructor(wt, Rt) {
                    super(wt, Rt),
                    this.binding = Rt.binding
                }
            }
            class fn extends h {
                constructor(wt) {
                    super(wt),
                    this.onBindingUpdate_ = this.onBindingUpdate_.bind(this),
                    this.emitter_ = new St,
                    this.controller_.binding.emitter.on("update", this.onBindingUpdate_)
                }
                get label() {
                    return this.controller_.props.get("label")
                }
                set label(wt) {
                    this.controller_.props.set("label", wt)
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
                refresh() {
                    this.controller_.binding.read()
                }
                onBindingUpdate_(wt) {
                    const Rt = wt.sender.target.read();
                    this.emitter_.emit("update", {
                        event: new _e(this,Rt,this.controller_.binding.target.presetKey)
                    })
                }
            }
            class bn extends pr {
                constructor(wt, Rt) {
                    super(wt, Rt),
                    this.binding = Rt.binding,
                    this.viewProps.bindDisabled(this.binding.ticker),
                    this.viewProps.handleDispose( () => {
                        this.binding.dispose()
                    }
                    )
                }
            }
            function Xn(Vt) {
                return Vt instanceof Rn ? Vt.apiSet_ : Vt instanceof Mn ? Vt.rackApi_.apiSet_ : null
            }
            function En(Vt, wt) {
                const Rt = Vt.find(zt => zt.controller_ === wt);
                if (!Rt)
                    throw _t.shouldNeverHappen();
                return Rt
            }
            function Qn(Vt, wt, Rt) {
                if (!vt.isBindable(Vt))
                    throw _t.notBindable();
                return new vt(Vt,wt,Rt)
            }
            class Rn extends h {
                constructor(wt, Rt) {
                    super(wt),
                    this.onRackAdd_ = this.onRackAdd_.bind(this),
                    this.onRackRemove_ = this.onRackRemove_.bind(this),
                    this.onRackInputChange_ = this.onRackInputChange_.bind(this),
                    this.onRackMonitorUpdate_ = this.onRackMonitorUpdate_.bind(this),
                    this.emitter_ = new St,
                    this.apiSet_ = new Tn(Xn),
                    this.pool_ = Rt;
                    const zt = this.controller_.rack;
                    zt.emitter.on("add", this.onRackAdd_),
                    zt.emitter.on("remove", this.onRackRemove_),
                    zt.emitter.on("inputchange", this.onRackInputChange_),
                    zt.emitter.on("monitorupdate", this.onRackMonitorUpdate_),
                    zt.children.forEach(nr => {
                        this.setUpApi_(nr)
                    }
                    )
                }
                get children() {
                    return this.controller_.rack.children.map(wt => En(this.apiSet_, wt))
                }
                addInput(wt, Rt, zt) {
                    const nr = zt ?? {}
                      , mr = this.controller_.view.element.ownerDocument
                      , Tr = this.pool_.createInput(mr, Qn(wt, Rt, nr.presetKey), nr)
                      , $r = new wn(Tr);
                    return this.add($r, nr.index)
                }
                addMonitor(wt, Rt, zt) {
                    const nr = zt ?? {}
                      , mr = this.controller_.view.element.ownerDocument
                      , Tr = this.pool_.createMonitor(mr, Qn(wt, Rt), nr)
                      , $r = new fn(Tr);
                    return this.add($r, nr.index)
                }
                addFolder(wt) {
                    return function(Rt, zt) {
                        return Rt.addBlade(Object.assign(Object.assign({}, zt), {
                            view: "folder"
                        }))
                    }(this, wt)
                }
                addButton(wt) {
                    return function(Rt, zt) {
                        return Rt.addBlade(Object.assign(Object.assign({}, zt), {
                            view: "button"
                        }))
                    }(this, wt)
                }
                addSeparator(wt) {
                    return function(Rt, zt) {
                        const nr = zt ?? {};
                        return Rt.addBlade(Object.assign(Object.assign({}, nr), {
                            view: "separator"
                        }))
                    }(this, wt)
                }
                addTab(wt) {
                    return function(Rt, zt) {
                        return Rt.addBlade(Object.assign(Object.assign({}, zt), {
                            view: "tab"
                        }))
                    }(this, wt)
                }
                add(wt, Rt) {
                    this.controller_.rack.add(wt.controller_, Rt);
                    const zt = this.apiSet_.find(nr => nr.controller_ === wt.controller_);
                    return zt && this.apiSet_.remove(zt),
                    this.apiSet_.add(wt),
                    wt
                }
                remove(wt) {
                    this.controller_.rack.remove(wt.controller_)
                }
                addBlade(wt) {
                    const Rt = this.controller_.view.element.ownerDocument
                      , zt = this.pool_.createBlade(Rt, wt)
                      , nr = this.pool_.createBladeApi(zt);
                    return this.add(nr, wt.index)
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
                setUpApi_(wt) {
                    this.apiSet_.find(Rt => Rt.controller_ === wt) || this.apiSet_.add(this.pool_.createBladeApi(wt))
                }
                onRackAdd_(wt) {
                    this.setUpApi_(wt.bladeController)
                }
                onRackRemove_(wt) {
                    if (wt.isRoot) {
                        const Rt = En(this.apiSet_, wt.bladeController);
                        this.apiSet_.remove(Rt)
                    }
                }
                onRackInputChange_(wt) {
                    const Rt = wt.bladeController;
                    if (Rt instanceof Cn) {
                        const zt = En(this.apiSet_, Rt)
                          , nr = Rt.binding;
                        this.emitter_.emit("change", {
                            event: new b(zt,nr.target.read(),nr.target.presetKey,wt.options.last)
                        })
                    } else if (Rt instanceof jr) {
                        const zt = En(this.apiSet_, Rt);
                        this.emitter_.emit("change", {
                            event: new b(zt,Rt.value.rawValue,void 0,wt.options.last)
                        })
                    }
                }
                onRackMonitorUpdate_(wt) {
                    if (!(wt.bladeController instanceof bn))
                        throw _t.shouldNeverHappen();
                    const Rt = En(this.apiSet_, wt.bladeController)
                      , zt = wt.bladeController.binding;
                    this.emitter_.emit("update", {
                        event: new _e(Rt,zt.target.read(),zt.target.presetKey)
                    })
                }
            }
            class Yn extends Mn {
                constructor(wt, Rt) {
                    super(wt, new Rn(wt.rackController,Rt)),
                    this.emitter_ = new St,
                    this.controller_.foldable.value("expanded").emitter.on("change", zt => {
                        this.emitter_.emit("fold", {
                            event: new nt(this,zt.sender.rawValue)
                        })
                    }
                    ),
                    this.rackApi_.on("change", zt => {
                        this.emitter_.emit("change", {
                            event: zt
                        })
                    }
                    ),
                    this.rackApi_.on("update", zt => {
                        this.emitter_.emit("update", {
                            event: zt
                        })
                    }
                    )
                }
                get expanded() {
                    return this.controller_.foldable.get("expanded")
                }
                set expanded(wt) {
                    this.controller_.foldable.set("expanded", wt)
                }
                get title() {
                    return this.controller_.props.get("title")
                }
                set title(wt) {
                    this.controller_.props.set("title", wt)
                }
                get children() {
                    return this.rackApi_.children
                }
                addInput(wt, Rt, zt) {
                    return this.rackApi_.addInput(wt, Rt, zt)
                }
                addMonitor(wt, Rt, zt) {
                    return this.rackApi_.addMonitor(wt, Rt, zt)
                }
                addFolder(wt) {
                    return this.rackApi_.addFolder(wt)
                }
                addButton(wt) {
                    return this.rackApi_.addButton(wt)
                }
                addSeparator(wt) {
                    return this.rackApi_.addSeparator(wt)
                }
                addTab(wt) {
                    return this.rackApi_.addTab(wt)
                }
                add(wt, Rt) {
                    return this.rackApi_.add(wt, Rt)
                }
                remove(wt) {
                    this.rackApi_.remove(wt)
                }
                addBlade(wt) {
                    return this.rackApi_.addBlade(wt)
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
            }
            class Bo extends fr {
                constructor(wt) {
                    super({
                        blade: wt.blade,
                        view: wt.view,
                        viewProps: wt.rackController.viewProps
                    }),
                    this.rackController = wt.rackController
                }
            }
            class vo {
                constructor(wt, Rt) {
                    const zt = Et(Rt.viewName);
                    this.element = wt.createElement("div"),
                    this.element.classList.add(zt()),
                    Rt.viewProps.bindClassModifiers(this.element)
                }
            }
            function Hn(Vt) {
                return Vt instanceof zo ? Vt.rack : Vt instanceof Bo ? Vt.rackController.rack : null
            }
            function $n(Vt) {
                const wt = Hn(Vt);
                return wt ? wt.bcSet_ : null
            }
            class ao {
                constructor(wt) {
                    var Rt, zt;
                    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this),
                    this.onSetAdd_ = this.onSetAdd_.bind(this),
                    this.onSetRemove_ = this.onSetRemove_.bind(this),
                    this.onChildDispose_ = this.onChildDispose_.bind(this),
                    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this),
                    this.onChildInputChange_ = this.onChildInputChange_.bind(this),
                    this.onChildMonitorUpdate_ = this.onChildMonitorUpdate_.bind(this),
                    this.onChildValueChange_ = this.onChildValueChange_.bind(this),
                    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this),
                    this.onDescendantLayout_ = this.onDescendantLayout_.bind(this),
                    this.onDescendantInputChange_ = this.onDescendantInputChange_.bind(this),
                    this.onDescendantMonitorUpdate_ = this.onDescendantMonitorUpdate_.bind(this),
                    this.emitter = new St,
                    this.blade_ = (Rt = wt.blade) !== null && Rt !== void 0 ? Rt : null,
                    (zt = this.blade_) === null || zt === void 0 || zt.value("positions").emitter.on("change", this.onBladePositionsChange_),
                    this.viewProps = wt.viewProps,
                    this.bcSet_ = new Tn($n),
                    this.bcSet_.emitter.on("add", this.onSetAdd_),
                    this.bcSet_.emitter.on("remove", this.onSetRemove_)
                }
                get children() {
                    return this.bcSet_.items
                }
                add(wt, Rt) {
                    var zt;
                    (zt = wt.parent) === null || zt === void 0 || zt.remove(wt),
                    pt(wt, "parent") ? wt.parent = this : (wt.parent_ = this,
                    dr({
                        key: "parent",
                        target: "BladeController",
                        place: "BladeRack.add"
                    })),
                    this.bcSet_.add(wt, Rt)
                }
                remove(wt) {
                    pt(wt, "parent") ? wt.parent = null : (wt.parent_ = null,
                    dr({
                        key: "parent",
                        target: "BladeController",
                        place: "BladeRack.remove"
                    })),
                    this.bcSet_.remove(wt)
                }
                find(wt) {
                    return this.bcSet_.allItems().filter(Rt => Rt instanceof wt)
                }
                onSetAdd_(wt) {
                    this.updatePositions_();
                    const Rt = wt.target === wt.root;
                    if (this.emitter.emit("add", {
                        bladeController: wt.item,
                        index: wt.index,
                        isRoot: Rt,
                        sender: this
                    }),
                    !Rt)
                        return;
                    const zt = wt.item;
                    if (zt.viewProps.emitter.on("change", this.onChildViewPropsChange_),
                    zt.blade.value("positions").emitter.on("change", this.onChildPositionsChange_),
                    zt.viewProps.handleDispose(this.onChildDispose_),
                    zt instanceof Cn)
                        zt.binding.emitter.on("change", this.onChildInputChange_);
                    else if (zt instanceof bn)
                        zt.binding.emitter.on("update", this.onChildMonitorUpdate_);
                    else if (zt instanceof jr)
                        zt.value.emitter.on("change", this.onChildValueChange_);
                    else {
                        const nr = Hn(zt);
                        if (nr) {
                            const mr = nr.emitter;
                            mr.on("layout", this.onDescendantLayout_),
                            mr.on("inputchange", this.onDescendantInputChange_),
                            mr.on("monitorupdate", this.onDescendantMonitorUpdate_)
                        }
                    }
                }
                onSetRemove_(wt) {
                    this.updatePositions_();
                    const Rt = wt.target === wt.root;
                    if (this.emitter.emit("remove", {
                        bladeController: wt.item,
                        isRoot: Rt,
                        sender: this
                    }),
                    !Rt)
                        return;
                    const zt = wt.item;
                    if (zt instanceof Cn)
                        zt.binding.emitter.off("change", this.onChildInputChange_);
                    else if (zt instanceof bn)
                        zt.binding.emitter.off("update", this.onChildMonitorUpdate_);
                    else if (zt instanceof jr)
                        zt.value.emitter.off("change", this.onChildValueChange_);
                    else {
                        const nr = Hn(zt);
                        if (nr) {
                            const mr = nr.emitter;
                            mr.off("layout", this.onDescendantLayout_),
                            mr.off("inputchange", this.onDescendantInputChange_),
                            mr.off("monitorupdate", this.onDescendantMonitorUpdate_)
                        }
                    }
                }
                updatePositions_() {
                    const wt = this.bcSet_.items.filter(nr => !nr.viewProps.get("hidden"))
                      , Rt = wt[0]
                      , zt = wt[wt.length - 1];
                    this.bcSet_.items.forEach(nr => {
                        const mr = [];
                        nr === Rt && (mr.push("first"),
                        this.blade_ && !this.blade_.get("positions").includes("veryfirst") || mr.push("veryfirst")),
                        nr === zt && (mr.push("last"),
                        this.blade_ && !this.blade_.get("positions").includes("verylast") || mr.push("verylast")),
                        nr.blade.set("positions", mr)
                    }
                    )
                }
                onChildPositionsChange_() {
                    this.updatePositions_(),
                    this.emitter.emit("layout", {
                        sender: this
                    })
                }
                onChildViewPropsChange_(wt) {
                    this.updatePositions_(),
                    this.emitter.emit("layout", {
                        sender: this
                    })
                }
                onChildDispose_() {
                    this.bcSet_.items.filter(wt => wt.viewProps.get("disposed")).forEach(wt => {
                        this.bcSet_.remove(wt)
                    }
                    )
                }
                onChildInputChange_(wt) {
                    const Rt = function(zt, nr) {
                        for (let mr = 0; mr < zt.length; mr++) {
                            const Tr = zt[mr];
                            if (Tr instanceof Cn && Tr.binding === nr)
                                return Tr
                        }
                        return null
                    }(this.find(Cn), wt.sender);
                    if (!Rt)
                        throw _t.alreadyDisposed();
                    this.emitter.emit("inputchange", {
                        bladeController: Rt,
                        options: wt.options,
                        sender: this
                    })
                }
                onChildMonitorUpdate_(wt) {
                    const Rt = function(zt, nr) {
                        for (let mr = 0; mr < zt.length; mr++) {
                            const Tr = zt[mr];
                            if (Tr instanceof bn && Tr.binding === nr)
                                return Tr
                        }
                        return null
                    }(this.find(bn), wt.sender);
                    if (!Rt)
                        throw _t.alreadyDisposed();
                    this.emitter.emit("monitorupdate", {
                        bladeController: Rt,
                        sender: this
                    })
                }
                onChildValueChange_(wt) {
                    const Rt = function(zt, nr) {
                        for (let mr = 0; mr < zt.length; mr++) {
                            const Tr = zt[mr];
                            if (Tr instanceof jr && Tr.value === nr)
                                return Tr
                        }
                        return null
                    }(this.find(jr), wt.sender);
                    if (!Rt)
                        throw _t.alreadyDisposed();
                    this.emitter.emit("inputchange", {
                        bladeController: Rt,
                        options: wt.options,
                        sender: this
                    })
                }
                onDescendantLayout_(wt) {
                    this.updatePositions_(),
                    this.emitter.emit("layout", {
                        sender: this
                    })
                }
                onDescendantInputChange_(wt) {
                    this.emitter.emit("inputchange", {
                        bladeController: wt.bladeController,
                        options: wt.options,
                        sender: this
                    })
                }
                onDescendantMonitorUpdate_(wt) {
                    this.emitter.emit("monitorupdate", {
                        bladeController: wt.bladeController,
                        sender: this
                    })
                }
                onBladePositionsChange_() {
                    this.updatePositions_()
                }
            }
            class zo extends fr {
                constructor(wt, Rt) {
                    super(Object.assign(Object.assign({}, Rt), {
                        view: new vo(wt,{
                            viewName: "brk",
                            viewProps: Rt.viewProps
                        })
                    })),
                    this.onRackAdd_ = this.onRackAdd_.bind(this),
                    this.onRackRemove_ = this.onRackRemove_.bind(this);
                    const zt = new ao({
                        blade: Rt.root ? void 0 : Rt.blade,
                        viewProps: Rt.viewProps
                    });
                    zt.emitter.on("add", this.onRackAdd_),
                    zt.emitter.on("remove", this.onRackRemove_),
                    this.rack = zt,
                    this.viewProps.handleDispose( () => {
                        for (let nr = this.rack.children.length - 1; nr >= 0; nr--)
                            this.rack.children[nr].viewProps.set("disposed", !0)
                    }
                    )
                }
                onRackAdd_(wt) {
                    wt.isRoot && qn(this.view.element, wt.bladeController.view.element, wt.index)
                }
                onRackRemove_(wt) {
                    wt.isRoot && mo(wt.bladeController.view.element)
                }
            }
            const Zo = Et("cnt");
            class $o {
                constructor(wt, Rt) {
                    var zt;
                    this.className_ = Et((zt = Rt.viewName) !== null && zt !== void 0 ? zt : "fld"),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(this.className_(), Zo()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    this.foldable_ = Rt.foldable,
                    this.foldable_.bindExpandedClass(this.element, this.className_(void 0, "expanded")),
                    Dt(this.foldable_, "completed", Gt(this.element, this.className_(void 0, "cpl")));
                    const nr = wt.createElement("button");
                    nr.classList.add(this.className_("b")),
                    Dt(Rt.props, "title", zn => {
                        at(zn) ? this.element.classList.add(this.className_(void 0, "not")) : this.element.classList.remove(this.className_(void 0, "not"))
                    }
                    ),
                    Rt.viewProps.bindDisabled(nr),
                    this.element.appendChild(nr),
                    this.buttonElement = nr;
                    const mr = wt.createElement("div");
                    mr.classList.add(this.className_("i")),
                    this.element.appendChild(mr);
                    const Tr = wt.createElement("div");
                    Tr.classList.add(this.className_("t")),
                    Bt(Rt.props.value("title"), Tr),
                    this.buttonElement.appendChild(Tr),
                    this.titleElement = Tr;
                    const $r = wt.createElement("div");
                    $r.classList.add(this.className_("m")),
                    this.buttonElement.appendChild($r);
                    const vn = Rt.containerElement;
                    vn.classList.add(this.className_("c")),
                    this.element.appendChild(vn),
                    this.containerElement = vn
                }
            }
            class Yo extends Bo {
                constructor(wt, Rt) {
                    var zt;
                    const nr = Or.create((zt = Rt.expanded) === null || zt === void 0 || zt)
                      , mr = new zo(wt,{
                        blade: Rt.blade,
                        root: Rt.root,
                        viewProps: Rt.viewProps
                    });
                    super(Object.assign(Object.assign({}, Rt), {
                        rackController: mr,
                        view: new $o(wt,{
                            containerElement: mr.view.element,
                            foldable: nr,
                            props: Rt.props,
                            viewName: Rt.root ? "rot" : void 0,
                            viewProps: Rt.viewProps
                        })
                    })),
                    this.onTitleClick_ = this.onTitleClick_.bind(this),
                    this.props = Rt.props,
                    this.foldable = nr,
                    gn(this.foldable, this.view.containerElement),
                    this.rackController.rack.emitter.on("add", () => {
                        this.foldable.cleanUpTransition()
                    }
                    ),
                    this.rackController.rack.emitter.on("remove", () => {
                        this.foldable.cleanUpTransition()
                    }
                    ),
                    this.view.buttonElement.addEventListener("click", this.onTitleClick_)
                }
                get document() {
                    return this.view.element.ownerDocument
                }
                onTitleClick_() {
                    this.foldable.set("expanded", !this.foldable.get("expanded"))
                }
            }
            const ss = {
                id: "folder",
                type: "blade",
                accept(Vt) {
                    const wt = hr
                      , Rt = gr(Vt, {
                        title: wt.required.string,
                        view: wt.required.constant("folder"),
                        expanded: wt.optional.boolean
                    });
                    return Rt ? {
                        params: Rt
                    } : null
                },
                controller(Vt) {
                    return new Yo(Vt.document,{
                        blade: Vt.blade,
                        expanded: Vt.params.expanded,
                        props: ir.fromObject({
                            title: Vt.params.title
                        }),
                        viewProps: Vt.viewProps
                    })
                },
                api(Vt) {
                    return Vt.controller instanceof Yo ? new Yn(Vt.controller,Vt.pool) : null
                }
            };
            class Os extends jr {
                constructor(wt, Rt) {
                    const zt = Rt.valueController.viewProps;
                    super(Object.assign(Object.assign({}, Rt), {
                        value: Rt.valueController.value,
                        view: new ur(wt,{
                            props: Rt.props,
                            viewProps: zt
                        }),
                        viewProps: zt
                    })),
                    this.props = Rt.props,
                    this.valueController = Rt.valueController,
                    this.view.valueElement.appendChild(this.valueController.view.element)
                }
            }
            class $l extends h {
            }
            const wl = Et("spr");
            class Ps {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(wl()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("hr");
                    zt.classList.add(wl("r")),
                    this.element.appendChild(zt)
                }
            }
            class ys extends fr {
                constructor(wt, Rt) {
                    super(Object.assign(Object.assign({}, Rt), {
                        view: new Ps(wt,{
                            viewProps: Rt.viewProps
                        })
                    }))
                }
            }
            const as = {
                id: "separator",
                type: "blade",
                accept(Vt) {
                    const wt = gr(Vt, {
                        view: hr.required.constant("separator")
                    });
                    return wt ? {
                        params: wt
                    } : null
                },
                controller(Vt) {
                    return new ys(Vt.document,{
                        blade: Vt.blade,
                        viewProps: Vt.viewProps
                    })
                },
                api(Vt) {
                    return Vt.controller instanceof ys ? new $l(Vt.controller) : null
                }
            }
              , Ln = Et("tbi");
            class Vn {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Ln()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    Dt(Rt.props, "selected", mr => {
                        mr ? this.element.classList.add(Ln(void 0, "sel")) : this.element.classList.remove(Ln(void 0, "sel"))
                    }
                    );
                    const zt = wt.createElement("button");
                    zt.classList.add(Ln("b")),
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.buttonElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(Ln("t")),
                    Bt(Rt.props.value("title"), nr),
                    this.buttonElement.appendChild(nr),
                    this.titleElement = nr
                }
            }
            class Ys {
                constructor(wt, Rt) {
                    this.emitter = new St,
                    this.onClick_ = this.onClick_.bind(this),
                    this.props = Rt.props,
                    this.viewProps = Rt.viewProps,
                    this.view = new Vn(wt,{
                        props: Rt.props,
                        viewProps: Rt.viewProps
                    }),
                    this.view.buttonElement.addEventListener("click", this.onClick_)
                }
                onClick_() {
                    this.emitter.emit("click", {
                        sender: this
                    })
                }
            }
            class Eo {
                constructor(wt, Rt) {
                    this.onItemClick_ = this.onItemClick_.bind(this),
                    this.ic_ = new Ys(wt,{
                        props: Rt.itemProps,
                        viewProps: Rr.create()
                    }),
                    this.ic_.emitter.on("click", this.onItemClick_),
                    this.cc_ = new zo(wt,{
                        blade: Qr(),
                        viewProps: Rr.create()
                    }),
                    this.props = Rt.props,
                    Dt(this.props, "selected", zt => {
                        this.itemController.props.set("selected", zt),
                        this.contentController.viewProps.set("hidden", !zt)
                    }
                    )
                }
                get itemController() {
                    return this.ic_
                }
                get contentController() {
                    return this.cc_
                }
                onItemClick_() {
                    this.props.set("selected", !0)
                }
            }
            class Sl {
                constructor(wt, Rt) {
                    this.controller_ = wt,
                    this.rackApi_ = Rt
                }
                get title() {
                    var wt;
                    return (wt = this.controller_.itemController.props.get("title")) !== null && wt !== void 0 ? wt : ""
                }
                set title(wt) {
                    this.controller_.itemController.props.set("title", wt)
                }
                get selected() {
                    return this.controller_.props.get("selected")
                }
                set selected(wt) {
                    this.controller_.props.set("selected", wt)
                }
                get children() {
                    return this.rackApi_.children
                }
                addButton(wt) {
                    return this.rackApi_.addButton(wt)
                }
                addFolder(wt) {
                    return this.rackApi_.addFolder(wt)
                }
                addSeparator(wt) {
                    return this.rackApi_.addSeparator(wt)
                }
                addTab(wt) {
                    return this.rackApi_.addTab(wt)
                }
                add(wt, Rt) {
                    this.rackApi_.add(wt, Rt)
                }
                remove(wt) {
                    this.rackApi_.remove(wt)
                }
                addInput(wt, Rt, zt) {
                    return this.rackApi_.addInput(wt, Rt, zt)
                }
                addMonitor(wt, Rt, zt) {
                    return this.rackApi_.addMonitor(wt, Rt, zt)
                }
                addBlade(wt) {
                    return this.rackApi_.addBlade(wt)
                }
            }
            class Ks extends Mn {
                constructor(wt, Rt) {
                    super(wt, new Rn(wt.rackController,Rt)),
                    this.onPageAdd_ = this.onPageAdd_.bind(this),
                    this.onPageRemove_ = this.onPageRemove_.bind(this),
                    this.onSelect_ = this.onSelect_.bind(this),
                    this.emitter_ = new St,
                    this.pageApiMap_ = new Map,
                    this.rackApi_.on("change", zt => {
                        this.emitter_.emit("change", {
                            event: zt
                        })
                    }
                    ),
                    this.rackApi_.on("update", zt => {
                        this.emitter_.emit("update", {
                            event: zt
                        })
                    }
                    ),
                    this.controller_.tab.selectedIndex.emitter.on("change", this.onSelect_),
                    this.controller_.pageSet.emitter.on("add", this.onPageAdd_),
                    this.controller_.pageSet.emitter.on("remove", this.onPageRemove_),
                    this.controller_.pageSet.items.forEach(zt => {
                        this.setUpPageApi_(zt)
                    }
                    )
                }
                get pages() {
                    return this.controller_.pageSet.items.map(wt => {
                        const Rt = this.pageApiMap_.get(wt);
                        if (!Rt)
                            throw _t.shouldNeverHappen();
                        return Rt
                    }
                    )
                }
                addPage(wt) {
                    const Rt = this.controller_.view.element.ownerDocument
                      , zt = new Eo(Rt,{
                        itemProps: ir.fromObject({
                            selected: !1,
                            title: wt.title
                        }),
                        props: ir.fromObject({
                            selected: !1
                        })
                    });
                    this.controller_.add(zt, wt.index);
                    const nr = this.pageApiMap_.get(zt);
                    if (!nr)
                        throw _t.shouldNeverHappen();
                    return nr
                }
                removePage(wt) {
                    this.controller_.remove(wt)
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
                setUpPageApi_(wt) {
                    const Rt = this.rackApi_.apiSet_.find(nr => nr.controller_ === wt.contentController);
                    if (!Rt)
                        throw _t.shouldNeverHappen();
                    const zt = new Sl(wt,Rt);
                    this.pageApiMap_.set(wt, zt)
                }
                onPageAdd_(wt) {
                    this.setUpPageApi_(wt.item)
                }
                onPageRemove_(wt) {
                    if (!this.pageApiMap_.get(wt.item))
                        throw _t.shouldNeverHappen();
                    this.pageApiMap_.delete(wt.item)
                }
                onSelect_(wt) {
                    this.emitter_.emit("select", {
                        event: new it(this,wt.rawValue)
                    })
                }
            }
            class ds {
                constructor() {
                    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this),
                    this.empty = or(!0),
                    this.selectedIndex = or(-1),
                    this.items_ = []
                }
                add(wt, Rt) {
                    const zt = Rt ?? this.items_.length;
                    this.items_.splice(zt, 0, wt),
                    wt.emitter.on("change", this.onItemSelectedChange_),
                    this.keepSelection_()
                }
                remove(wt) {
                    const Rt = this.items_.indexOf(wt);
                    Rt < 0 || (this.items_.splice(Rt, 1),
                    wt.emitter.off("change", this.onItemSelectedChange_),
                    this.keepSelection_())
                }
                keepSelection_() {
                    if (this.items_.length === 0)
                        return this.selectedIndex.rawValue = -1,
                        void (this.empty.rawValue = !0);
                    const wt = this.items_.findIndex(Rt => Rt.rawValue);
                    wt < 0 ? (this.items_.forEach( (Rt, zt) => {
                        Rt.rawValue = zt === 0
                    }
                    ),
                    this.selectedIndex.rawValue = 0) : (this.items_.forEach( (Rt, zt) => {
                        Rt.rawValue = zt === wt
                    }
                    ),
                    this.selectedIndex.rawValue = wt),
                    this.empty.rawValue = !1
                }
                onItemSelectedChange_(wt) {
                    if (wt.rawValue) {
                        const Rt = this.items_.findIndex(zt => zt === wt.sender);
                        this.items_.forEach( (zt, nr) => {
                            zt.rawValue = nr === Rt
                        }
                        ),
                        this.selectedIndex.rawValue = Rt
                    } else
                        this.keepSelection_()
                }
            }
            const yo = Et("tab");
            class ko {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(yo(), Zo()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    It(Rt.empty, Gt(this.element, yo(void 0, "nop")));
                    const zt = wt.createElement("div");
                    zt.classList.add(yo("t")),
                    this.element.appendChild(zt),
                    this.itemsElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(yo("i")),
                    this.element.appendChild(nr);
                    const mr = Rt.contentsElement;
                    mr.classList.add(yo("c")),
                    this.element.appendChild(mr),
                    this.contentsElement = mr
                }
            }
            class xs extends Bo {
                constructor(wt, Rt) {
                    const zt = new zo(wt,{
                        blade: Rt.blade,
                        viewProps: Rt.viewProps
                    })
                      , nr = new ds;
                    super({
                        blade: Rt.blade,
                        rackController: zt,
                        view: new ko(wt,{
                            contentsElement: zt.view.element,
                            empty: nr.empty,
                            viewProps: Rt.viewProps
                        })
                    }),
                    this.onPageAdd_ = this.onPageAdd_.bind(this),
                    this.onPageRemove_ = this.onPageRemove_.bind(this),
                    this.pageSet_ = new Tn( () => null),
                    this.pageSet_.emitter.on("add", this.onPageAdd_),
                    this.pageSet_.emitter.on("remove", this.onPageRemove_),
                    this.tab = nr
                }
                get pageSet() {
                    return this.pageSet_
                }
                add(wt, Rt) {
                    this.pageSet_.add(wt, Rt)
                }
                remove(wt) {
                    this.pageSet_.remove(this.pageSet_.items[wt])
                }
                onPageAdd_(wt) {
                    const Rt = wt.item;
                    qn(this.view.itemsElement, Rt.itemController.view.element, wt.index),
                    Rt.itemController.viewProps.set("parent", this.viewProps),
                    this.rackController.rack.add(Rt.contentController, wt.index),
                    this.tab.add(Rt.props.value("selected"))
                }
                onPageRemove_(wt) {
                    const Rt = wt.item;
                    mo(Rt.itemController.view.element),
                    Rt.itemController.viewProps.set("parent", null),
                    this.rackController.rack.remove(Rt.contentController),
                    this.tab.remove(Rt.props.value("selected"))
                }
            }
            const Js = {
                id: "tab",
                type: "blade",
                accept(Vt) {
                    const wt = hr
                      , Rt = gr(Vt, {
                        pages: wt.required.array(wt.required.object({
                            title: wt.required.string
                        })),
                        view: wt.required.constant("tab")
                    });
                    return Rt && Rt.pages.length !== 0 ? {
                        params: Rt
                    } : null
                },
                controller(Vt) {
                    const wt = new xs(Vt.document,{
                        blade: Vt.blade,
                        viewProps: Vt.viewProps
                    });
                    return Vt.params.pages.forEach(Rt => {
                        const zt = new Eo(Vt.document,{
                            itemProps: ir.fromObject({
                                selected: !1,
                                title: Rt.title
                            }),
                            props: ir.fromObject({
                                selected: !1
                            })
                        });
                        wt.add(zt)
                    }
                    ),
                    wt
                },
                api(Vt) {
                    return Vt.controller instanceof xs ? new Ks(Vt.controller,Vt.pool) : null
                }
            };
            class bs {
                constructor() {
                    this.disabled = !1,
                    this.emitter = new St
                }
                dispose() {}
                tick() {
                    this.disabled || this.emitter.emit("tick", {
                        sender: this
                    })
                }
            }
            class Bl {
                constructor(wt, Rt) {
                    this.disabled_ = !1,
                    this.timerId_ = null,
                    this.onTick_ = this.onTick_.bind(this),
                    this.doc_ = wt,
                    this.emitter = new St,
                    this.interval_ = Rt,
                    this.setTimer_()
                }
                get disabled() {
                    return this.disabled_
                }
                set disabled(wt) {
                    this.disabled_ = wt,
                    this.disabled_ ? this.clearTimer_() : this.setTimer_()
                }
                dispose() {
                    this.clearTimer_()
                }
                clearTimer_() {
                    if (this.timerId_ === null)
                        return;
                    const wt = this.doc_.defaultView;
                    wt && wt.clearInterval(this.timerId_),
                    this.timerId_ = null
                }
                setTimer_() {
                    if (this.clearTimer_(),
                    this.interval_ <= 0)
                        return;
                    const wt = this.doc_.defaultView;
                    wt && (this.timerId_ = wt.setInterval(this.onTick_, this.interval_))
                }
                onTick_() {
                    this.disabled_ || this.emitter.emit("tick", {
                        sender: this
                    })
                }
            }
            class Bm {
                constructor(wt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.reader = wt.reader,
                    this.writer = wt.writer,
                    this.emitter = new St,
                    this.value = wt.value,
                    this.value.emitter.on("change", this.onValueChange_),
                    this.target = wt.target,
                    this.read()
                }
                read() {
                    const wt = this.target.read();
                    wt !== void 0 && (this.value.rawValue = this.reader(wt))
                }
                write_(wt) {
                    this.writer(this.target, wt)
                }
                onValueChange_(wt) {
                    this.write_(wt.rawValue),
                    this.emitter.emit("change", {
                        options: wt.options,
                        rawValue: wt.rawValue,
                        sender: this
                    })
                }
            }
            function Vp(Vt, wt) {
                for (; Vt.length < wt; )
                    Vt.push(void 0)
            }
            function Lm(Vt) {
                const wt = [];
                return Vp(wt, Vt),
                or(wt)
            }
            function Om(Vt) {
                const wt = Vt.indexOf(void 0);
                return wt < 0 ? Vt : Vt.slice(0, wt)
            }
            class G_ {
                constructor(wt) {
                    this.onTick_ = this.onTick_.bind(this),
                    this.reader_ = wt.reader,
                    this.target = wt.target,
                    this.emitter = new St,
                    this.value = wt.value,
                    this.ticker = wt.ticker,
                    this.ticker.emitter.on("tick", this.onTick_),
                    this.read()
                }
                dispose() {
                    this.ticker.dispose()
                }
                read() {
                    const wt = this.target.read();
                    if (wt === void 0)
                        return;
                    const Rt = this.value.rawValue
                      , zt = this.reader_(wt);
                    this.value.rawValue = function(nr, mr) {
                        const Tr = [...Om(nr), mr];
                        return Tr.length > nr.length ? Tr.splice(0, Tr.length - nr.length) : Vp(Tr, nr.length),
                        Tr
                    }(Rt, zt),
                    this.emitter.emit("update", {
                        rawValue: zt,
                        sender: this
                    })
                }
                onTick_(wt) {
                    this.read()
                }
            }
            class lu {
                constructor(wt) {
                    this.constraints = wt
                }
                constrain(wt) {
                    return this.constraints.reduce( (Rt, zt) => zt.constrain(Rt), wt)
                }
            }
            function Zs(Vt, wt) {
                if (Vt instanceof wt)
                    return Vt;
                if (Vt instanceof lu) {
                    const Rt = Vt.constraints.reduce( (zt, nr) => zt || (nr instanceof wt ? nr : null), null);
                    if (Rt)
                        return Rt
                }
                return null
            }
            class Xl {
                constructor(wt) {
                    this.values = ir.fromObject({
                        max: wt.max,
                        min: wt.min
                    })
                }
                constrain(wt) {
                    const Rt = this.values.get("max")
                      , zt = this.values.get("min");
                    return Math.min(Math.max(wt, zt), Rt)
                }
            }
            class cu {
                constructor(wt) {
                    this.values = ir.fromObject({
                        options: wt
                    })
                }
                get options() {
                    return this.values.get("options")
                }
                constrain(wt) {
                    const Rt = this.values.get("options");
                    return Rt.length === 0 || Rt.filter(zt => zt.value === wt).length > 0 ? wt : Rt[0].value
                }
            }
            class Gp {
                constructor(wt) {
                    this.values = ir.fromObject({
                        max: wt.max,
                        min: wt.min
                    })
                }
                get maxValue() {
                    return this.values.get("max")
                }
                get minValue() {
                    return this.values.get("min")
                }
                constrain(wt) {
                    const Rt = this.values.get("max")
                      , zt = this.values.get("min");
                    let nr = wt;
                    return at(zt) || (nr = Math.max(nr, zt)),
                    at(Rt) || (nr = Math.min(nr, Rt)),
                    nr
                }
            }
            class Ru {
                constructor(wt, Rt=0) {
                    this.step = wt,
                    this.origin = Rt
                }
                constrain(wt) {
                    const Rt = this.origin % this.step;
                    return Rt + Math.round((wt - Rt) / this.step) * this.step
                }
            }
            const op = Et("lst");
            class Nm {
                constructor(wt, Rt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.props_ = Rt.props,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(op()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("select");
                    zt.classList.add(op("s")),
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.selectElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(op("m")),
                    nr.appendChild(Wn(wt, "dropdown")),
                    this.element.appendChild(nr),
                    Rt.value.emitter.on("change", this.onValueChange_),
                    this.value_ = Rt.value,
                    Dt(this.props_, "options", mr => {
                        Ur(this.selectElement),
                        mr.forEach(Tr => {
                            const $r = wt.createElement("option");
                            $r.textContent = Tr.text,
                            this.selectElement.appendChild($r)
                        }
                        ),
                        this.update_()
                    }
                    )
                }
                update_() {
                    const wt = this.props_.get("options").map(Rt => Rt.value);
                    this.selectElement.selectedIndex = wt.indexOf(this.value_.rawValue)
                }
                onValueChange_() {
                    this.update_()
                }
            }
            class uu {
                constructor(wt, Rt) {
                    this.onSelectChange_ = this.onSelectChange_.bind(this),
                    this.props = Rt.props,
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new Nm(wt,{
                        props: this.props,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view.selectElement.addEventListener("change", this.onSelectChange_)
                }
                onSelectChange_(wt) {
                    const Rt = wt.currentTarget;
                    this.value.rawValue = this.props.get("options")[Rt.selectedIndex].value
                }
            }
            const zp = Et("pop");
            class Fm {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(zp()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    It(Rt.shows, Gt(this.element, zp(void 0, "v")))
                }
            }
            class Hp {
                constructor(wt, Rt) {
                    this.shows = or(!1),
                    this.viewProps = Rt.viewProps,
                    this.view = new Fm(wt,{
                        shows: this.shows,
                        viewProps: this.viewProps
                    })
                }
            }
            const Qp = Et("txt");
            class Um {
                constructor(wt, Rt) {
                    this.onChange_ = this.onChange_.bind(this),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Qp()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    this.props_ = Rt.props,
                    this.props_.emitter.on("change", this.onChange_);
                    const zt = wt.createElement("input");
                    zt.classList.add(Qp("i")),
                    zt.type = "text",
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.inputElement = zt,
                    Rt.value.emitter.on("change", this.onChange_),
                    this.value_ = Rt.value,
                    this.refresh()
                }
                refresh() {
                    const wt = this.props_.get("formatter");
                    this.inputElement.value = wt(this.value_.rawValue)
                }
                onChange_() {
                    this.refresh()
                }
            }
            class Iu {
                constructor(wt, Rt) {
                    this.onInputChange_ = this.onInputChange_.bind(this),
                    this.parser_ = Rt.parser,
                    this.props = Rt.props,
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new Um(wt,{
                        props: Rt.props,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view.inputElement.addEventListener("change", this.onInputChange_)
                }
                onInputChange_(wt) {
                    const Rt = wt.currentTarget.value
                      , zt = this.parser_(Rt);
                    at(zt) || (this.value.rawValue = zt),
                    this.view.refresh()
                }
            }
            function Wp(Vt) {
                return Vt !== "false" && !!Vt
            }
            function sp(Vt) {
                return function(wt) {
                    return String(wt)
                }(Vt)
            }
            class jm {
                constructor(wt) {
                    this.text = wt
                }
                evaluate() {
                    return Number(this.text)
                }
                toString() {
                    return this.text
                }
            }
            const Vm = {
                "**": (Vt, wt) => Math.pow(Vt, wt),
                "*": (Vt, wt) => Vt * wt,
                "/": (Vt, wt) => Vt / wt,
                "%": (Vt, wt) => Vt % wt,
                "+": (Vt, wt) => Vt + wt,
                "-": (Vt, wt) => Vt - wt,
                "<<": (Vt, wt) => Vt << wt,
                ">>": (Vt, wt) => Vt >> wt,
                ">>>": (Vt, wt) => Vt >>> wt,
                "&": (Vt, wt) => Vt & wt,
                "^": (Vt, wt) => Vt ^ wt,
                "|": (Vt, wt) => Vt | wt
            };
            class z_ {
                constructor(wt, Rt, zt) {
                    this.left = Rt,
                    this.operator = wt,
                    this.right = zt
                }
                evaluate() {
                    const wt = Vm[this.operator];
                    if (!wt)
                        throw new Error(`unexpected binary operator: '${this.operator}`);
                    return wt(this.left.evaluate(), this.right.evaluate())
                }
                toString() {
                    return ["b(", this.left.toString(), this.operator, this.right.toString(), ")"].join(" ")
                }
            }
            const Gm = {
                "+": Vt => Vt,
                "-": Vt => -Vt,
                "~": Vt => ~Vt
            };
            class zm {
                constructor(wt, Rt) {
                    this.operator = wt,
                    this.expression = Rt
                }
                evaluate() {
                    const wt = Gm[this.operator];
                    if (!wt)
                        throw new Error(`unexpected unary operator: '${this.operator}`);
                    return wt(this.expression.evaluate())
                }
                toString() {
                    return ["u(", this.operator, this.expression.toString(), ")"].join(" ")
                }
            }
            function ap(Vt) {
                return (wt, Rt) => {
                    for (let zt = 0; zt < Vt.length; zt++) {
                        const nr = Vt[zt](wt, Rt);
                        if (nr !== "")
                            return nr
                    }
                    return ""
                }
            }
            function ku(Vt, wt) {
                var Rt;
                const zt = Vt.substr(wt).match(/^\s+/);
                return (Rt = zt && zt[0]) !== null && Rt !== void 0 ? Rt : ""
            }
            function Du(Vt, wt) {
                var Rt;
                const zt = Vt.substr(wt).match(/^[0-9]+/);
                return (Rt = zt && zt[0]) !== null && Rt !== void 0 ? Rt : ""
            }
            function qp(Vt, wt) {
                const Rt = Vt.substr(wt, 1);
                if (wt += 1,
                Rt.toLowerCase() !== "e")
                    return "";
                const zt = function(nr, mr) {
                    const Tr = Du(nr, mr);
                    if (Tr !== "")
                        return Tr;
                    const $r = nr.substr(mr, 1);
                    if ($r !== "-" && $r !== "+")
                        return "";
                    const vn = Du(nr, mr += 1);
                    return vn === "" ? "" : $r + vn
                }(Vt, wt);
                return zt === "" ? "" : Rt + zt
            }
            function Bu(Vt, wt) {
                const Rt = Vt.substr(wt, 1);
                if (Rt === "0")
                    return Rt;
                const zt = function(nr, mr) {
                    const Tr = nr.substr(mr, 1);
                    return Tr.match(/^[1-9]$/) ? Tr : ""
                }(Vt, wt);
                return wt += zt.length,
                zt === "" ? "" : zt + Du(Vt, wt)
            }
            const lp = ap([function(Vt, wt) {
                const Rt = Bu(Vt, wt);
                if (wt += Rt.length,
                Rt === "")
                    return "";
                const zt = Vt.substr(wt, 1);
                if (wt += zt.length,
                zt !== ".")
                    return "";
                const nr = Du(Vt, wt);
                return Rt + zt + nr + qp(Vt, wt += nr.length)
            }
            , function(Vt, wt) {
                const Rt = Vt.substr(wt, 1);
                if (wt += Rt.length,
                Rt !== ".")
                    return "";
                const zt = Du(Vt, wt);
                return wt += zt.length,
                zt === "" ? "" : Rt + zt + qp(Vt, wt)
            }
            , function(Vt, wt) {
                const Rt = Bu(Vt, wt);
                return wt += Rt.length,
                Rt === "" ? "" : Rt + qp(Vt, wt)
            }
            ])
              , $p = ap([function(Vt, wt) {
                const Rt = Vt.substr(wt, 2);
                if (wt += Rt.length,
                Rt.toLowerCase() !== "0b")
                    return "";
                const zt = function(nr, mr) {
                    var Tr;
                    const $r = nr.substr(mr).match(/^[01]+/);
                    return (Tr = $r && $r[0]) !== null && Tr !== void 0 ? Tr : ""
                }(Vt, wt);
                return zt === "" ? "" : Rt + zt
            }
            , function(Vt, wt) {
                const Rt = Vt.substr(wt, 2);
                if (wt += Rt.length,
                Rt.toLowerCase() !== "0o")
                    return "";
                const zt = function(nr, mr) {
                    var Tr;
                    const $r = nr.substr(mr).match(/^[0-7]+/);
                    return (Tr = $r && $r[0]) !== null && Tr !== void 0 ? Tr : ""
                }(Vt, wt);
                return zt === "" ? "" : Rt + zt
            }
            , function(Vt, wt) {
                const Rt = Vt.substr(wt, 2);
                if (wt += Rt.length,
                Rt.toLowerCase() !== "0x")
                    return "";
                const zt = function(nr, mr) {
                    var Tr;
                    const $r = nr.substr(mr).match(/^[0-9a-f]+/i);
                    return (Tr = $r && $r[0]) !== null && Tr !== void 0 ? Tr : ""
                }(Vt, wt);
                return zt === "" ? "" : Rt + zt
            }
            ])
              , du = ap([$p, lp]);
            function pu(Vt, wt) {
                var Rt;
                return (Rt = function(zt, nr) {
                    const mr = du(zt, nr);
                    return nr += mr.length,
                    mr === "" ? null : {
                        evaluable: new jm(mr),
                        cursor: nr
                    }
                }(Vt, wt)) !== null && Rt !== void 0 ? Rt : function(zt, nr) {
                    const mr = zt.substr(nr, 1);
                    if (nr += mr.length,
                    mr !== "(")
                        return null;
                    const Tr = Xp(zt, nr);
                    if (!Tr)
                        return null;
                    nr = Tr.cursor,
                    nr += ku(zt, nr).length;
                    const $r = zt.substr(nr, 1);
                    return nr += $r.length,
                    $r !== ")" ? null : {
                        evaluable: Tr.evaluable,
                        cursor: nr
                    }
                }(Vt, wt)
            }
            function cp(Vt, wt, Rt) {
                Rt += ku(wt, Rt).length;
                const zt = Vt.filter(nr => wt.startsWith(nr, Rt))[0];
                return zt ? (Rt += zt.length,
                {
                    cursor: Rt += ku(wt, Rt).length,
                    operator: zt
                }) : null
            }
            const Hm = [["**"], ["*", "/", "%"], ["+", "-"], ["<<", ">>>", ">>"], ["&"], ["^"], ["|"]].reduce( (Vt, wt) => function(Rt, zt) {
                return (nr, mr) => {
                    const Tr = Rt(nr, mr);
                    if (!Tr)
                        return null;
                    mr = Tr.cursor;
                    let $r = Tr.evaluable;
                    for (; ; ) {
                        const vn = cp(zt, nr, mr);
                        if (!vn)
                            break;
                        mr = vn.cursor;
                        const zn = Rt(nr, mr);
                        if (!zn)
                            return null;
                        mr = zn.cursor,
                        $r = new z_(vn.operator,$r,zn.evaluable)
                    }
                    return $r ? {
                        cursor: mr,
                        evaluable: $r
                    } : null
                }
            }(Vt, wt), function Vt(wt, Rt) {
                const zt = pu(wt, Rt);
                if (zt)
                    return zt;
                const nr = wt.substr(Rt, 1);
                if (Rt += nr.length,
                nr !== "+" && nr !== "-" && nr !== "~")
                    return null;
                const mr = Vt(wt, Rt);
                return mr ? {
                    cursor: Rt = mr.cursor,
                    evaluable: new zm(nr,mr.evaluable)
                } : null
            });
            function Xp(Vt, wt) {
                return wt += ku(Vt, wt).length,
                Hm(Vt, wt)
            }
            function Ll(Vt) {
                var wt;
                const Rt = function(zt) {
                    const nr = Xp(zt, 0);
                    return nr ? nr.cursor + ku(zt, nr.cursor).length !== zt.length ? null : nr.evaluable : null
                }(Vt);
                return (wt = Rt == null ? void 0 : Rt.evaluate()) !== null && wt !== void 0 ? wt : null
            }
            function H_(Vt) {
                if (typeof Vt == "number")
                    return Vt;
                if (typeof Vt == "string") {
                    const wt = Ll(Vt);
                    if (!at(wt))
                        return wt
                }
                return 0
            }
            function S0(Vt) {
                return String(Vt)
            }
            function ts(Vt) {
                return wt => wt.toFixed(Math.max(Math.min(Vt, 20), 0))
            }
            const Ol = ts(0);
            function up(Vt) {
                return Ol(Vt) + "%"
            }
            function Qm(Vt) {
                return String(Vt)
            }
            function El(Vt) {
                return Vt
            }
            function Lu({primary: Vt, secondary: wt, forward: Rt, backward: zt}) {
                let nr = !1;
                function mr(Tr) {
                    nr || (nr = !0,
                    Tr(),
                    nr = !1)
                }
                Vt.emitter.on("change", Tr => {
                    mr( () => {
                        wt.setRawValue(Rt(Vt, wt), Tr.options)
                    }
                    )
                }
                ),
                wt.emitter.on("change", Tr => {
                    mr( () => {
                        Vt.setRawValue(zt(Vt, wt), Tr.options)
                    }
                    ),
                    mr( () => {
                        wt.setRawValue(Rt(Vt, wt), Tr.options)
                    }
                    )
                }
                ),
                mr( () => {
                    wt.setRawValue(Rt(Vt, wt), {
                        forceEmit: !1,
                        last: !0
                    })
                }
                )
            }
            function Oo(Vt, wt) {
                const Rt = Vt * (wt.altKey ? .1 : 1) * (wt.shiftKey ? 10 : 1);
                return wt.upKey ? +Rt : wt.downKey ? -Rt : 0
            }
            function jo(Vt) {
                return {
                    altKey: Vt.altKey,
                    downKey: Vt.key === "ArrowDown",
                    shiftKey: Vt.shiftKey,
                    upKey: Vt.key === "ArrowUp"
                }
            }
            function Xo(Vt) {
                return {
                    altKey: Vt.altKey,
                    downKey: Vt.key === "ArrowLeft",
                    shiftKey: Vt.shiftKey,
                    upKey: Vt.key === "ArrowRight"
                }
            }
            function dp(Vt) {
                return function(wt) {
                    return wt === "ArrowUp" || wt === "ArrowDown"
                }(Vt) || Vt === "ArrowLeft" || Vt === "ArrowRight"
            }
            function hu(Vt, wt) {
                var Rt, zt;
                const nr = wt.ownerDocument.defaultView
                  , mr = wt.getBoundingClientRect();
                return {
                    x: Vt.pageX - (((Rt = nr && nr.scrollX) !== null && Rt !== void 0 ? Rt : 0) + mr.left),
                    y: Vt.pageY - (((zt = nr && nr.scrollY) !== null && zt !== void 0 ? zt : 0) + mr.top)
                }
            }
            class ps {
                constructor(wt) {
                    this.lastTouch_ = null,
                    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this),
                    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this),
                    this.onMouseDown_ = this.onMouseDown_.bind(this),
                    this.onTouchEnd_ = this.onTouchEnd_.bind(this),
                    this.onTouchMove_ = this.onTouchMove_.bind(this),
                    this.onTouchStart_ = this.onTouchStart_.bind(this),
                    this.elem_ = wt,
                    this.emitter = new St,
                    wt.addEventListener("touchstart", this.onTouchStart_, {
                        passive: !1
                    }),
                    wt.addEventListener("touchmove", this.onTouchMove_, {
                        passive: !0
                    }),
                    wt.addEventListener("touchend", this.onTouchEnd_),
                    wt.addEventListener("mousedown", this.onMouseDown_)
                }
                computePosition_(wt) {
                    const Rt = this.elem_.getBoundingClientRect();
                    return {
                        bounds: {
                            width: Rt.width,
                            height: Rt.height
                        },
                        point: wt ? {
                            x: wt.x,
                            y: wt.y
                        } : null
                    }
                }
                onMouseDown_(wt) {
                    var Rt;
                    wt.preventDefault(),
                    (Rt = wt.currentTarget) === null || Rt === void 0 || Rt.focus();
                    const zt = this.elem_.ownerDocument;
                    zt.addEventListener("mousemove", this.onDocumentMouseMove_),
                    zt.addEventListener("mouseup", this.onDocumentMouseUp_),
                    this.emitter.emit("down", {
                        altKey: wt.altKey,
                        data: this.computePosition_(hu(wt, this.elem_)),
                        sender: this,
                        shiftKey: wt.shiftKey
                    })
                }
                onDocumentMouseMove_(wt) {
                    this.emitter.emit("move", {
                        altKey: wt.altKey,
                        data: this.computePosition_(hu(wt, this.elem_)),
                        sender: this,
                        shiftKey: wt.shiftKey
                    })
                }
                onDocumentMouseUp_(wt) {
                    const Rt = this.elem_.ownerDocument;
                    Rt.removeEventListener("mousemove", this.onDocumentMouseMove_),
                    Rt.removeEventListener("mouseup", this.onDocumentMouseUp_),
                    this.emitter.emit("up", {
                        altKey: wt.altKey,
                        data: this.computePosition_(hu(wt, this.elem_)),
                        sender: this,
                        shiftKey: wt.shiftKey
                    })
                }
                onTouchStart_(wt) {
                    wt.preventDefault();
                    const Rt = wt.targetTouches.item(0)
                      , zt = this.elem_.getBoundingClientRect();
                    this.emitter.emit("down", {
                        altKey: wt.altKey,
                        data: this.computePosition_(Rt ? {
                            x: Rt.clientX - zt.left,
                            y: Rt.clientY - zt.top
                        } : void 0),
                        sender: this,
                        shiftKey: wt.shiftKey
                    }),
                    this.lastTouch_ = Rt
                }
                onTouchMove_(wt) {
                    const Rt = wt.targetTouches.item(0)
                      , zt = this.elem_.getBoundingClientRect();
                    this.emitter.emit("move", {
                        altKey: wt.altKey,
                        data: this.computePosition_(Rt ? {
                            x: Rt.clientX - zt.left,
                            y: Rt.clientY - zt.top
                        } : void 0),
                        sender: this,
                        shiftKey: wt.shiftKey
                    }),
                    this.lastTouch_ = Rt
                }
                onTouchEnd_(wt) {
                    var Rt;
                    const zt = (Rt = wt.targetTouches.item(0)) !== null && Rt !== void 0 ? Rt : this.lastTouch_
                      , nr = this.elem_.getBoundingClientRect();
                    this.emitter.emit("up", {
                        altKey: wt.altKey,
                        data: this.computePosition_(zt ? {
                            x: zt.clientX - nr.left,
                            y: zt.clientY - nr.top
                        } : void 0),
                        sender: this,
                        shiftKey: wt.shiftKey
                    })
                }
            }
            function No(Vt, wt, Rt, zt, nr) {
                return zt + (Vt - wt) / (Rt - wt) * (nr - zt)
            }
            function Vo(Vt) {
                return String(Vt.toFixed(10)).split(".")[1].replace(/0+$/, "").length
            }
            function Wo(Vt, wt, Rt) {
                return Math.min(Math.max(Vt, wt), Rt)
            }
            function Ou(Vt, wt) {
                return (Vt % wt + wt) % wt
            }
            const Hs = Et("txt");
            class Yp {
                constructor(wt, Rt) {
                    this.onChange_ = this.onChange_.bind(this),
                    this.props_ = Rt.props,
                    this.props_.emitter.on("change", this.onChange_),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Hs(), Hs(void 0, "num")),
                    Rt.arrayPosition && this.element.classList.add(Hs(void 0, Rt.arrayPosition)),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("input");
                    zt.classList.add(Hs("i")),
                    zt.type = "text",
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.inputElement = zt,
                    this.onDraggingChange_ = this.onDraggingChange_.bind(this),
                    this.dragging_ = Rt.dragging,
                    this.dragging_.emitter.on("change", this.onDraggingChange_),
                    this.element.classList.add(Hs()),
                    this.inputElement.classList.add(Hs("i"));
                    const nr = wt.createElement("div");
                    nr.classList.add(Hs("k")),
                    this.element.appendChild(nr),
                    this.knobElement = nr;
                    const mr = wt.createElementNS(vr, "svg");
                    mr.classList.add(Hs("g")),
                    this.knobElement.appendChild(mr);
                    const Tr = wt.createElementNS(vr, "path");
                    Tr.classList.add(Hs("gb")),
                    mr.appendChild(Tr),
                    this.guideBodyElem_ = Tr;
                    const $r = wt.createElementNS(vr, "path");
                    $r.classList.add(Hs("gh")),
                    mr.appendChild($r),
                    this.guideHeadElem_ = $r;
                    const vn = wt.createElement("div");
                    vn.classList.add(Et("tt")()),
                    this.knobElement.appendChild(vn),
                    this.tooltipElem_ = vn,
                    Rt.value.emitter.on("change", this.onChange_),
                    this.value = Rt.value,
                    this.refresh()
                }
                onDraggingChange_(wt) {
                    if (wt.rawValue === null)
                        return void this.element.classList.remove(Hs(void 0, "drg"));
                    this.element.classList.add(Hs(void 0, "drg"));
                    const Rt = wt.rawValue / this.props_.get("draggingScale")
                      , zt = Rt + (Rt > 0 ? -1 : Rt < 0 ? 1 : 0)
                      , nr = Wo(-zt, -4, 4);
                    this.guideHeadElem_.setAttributeNS(null, "d", [`M ${zt + nr},0 L${zt},4 L${zt + nr},8`, `M ${Rt},-1 L${Rt},9`].join(" ")),
                    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${Rt},4`);
                    const mr = this.props_.get("formatter");
                    this.tooltipElem_.textContent = mr(this.value.rawValue),
                    this.tooltipElem_.style.left = `${Rt}px`
                }
                refresh() {
                    const wt = this.props_.get("formatter");
                    this.inputElement.value = wt(this.value.rawValue)
                }
                onChange_() {
                    this.refresh()
                }
            }
            class pp {
                constructor(wt, Rt) {
                    var zt;
                    this.originRawValue_ = 0,
                    this.onInputChange_ = this.onInputChange_.bind(this),
                    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this),
                    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this),
                    this.onPointerDown_ = this.onPointerDown_.bind(this),
                    this.onPointerMove_ = this.onPointerMove_.bind(this),
                    this.onPointerUp_ = this.onPointerUp_.bind(this),
                    this.baseStep_ = Rt.baseStep,
                    this.parser_ = Rt.parser,
                    this.props = Rt.props,
                    this.sliderProps_ = (zt = Rt.sliderProps) !== null && zt !== void 0 ? zt : null,
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.dragging_ = or(null),
                    this.view = new Yp(wt,{
                        arrayPosition: Rt.arrayPosition,
                        dragging: this.dragging_,
                        props: this.props,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view.inputElement.addEventListener("change", this.onInputChange_),
                    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_),
                    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
                    const nr = new ps(this.view.knobElement);
                    nr.emitter.on("down", this.onPointerDown_),
                    nr.emitter.on("move", this.onPointerMove_),
                    nr.emitter.on("up", this.onPointerUp_)
                }
                constrainValue_(wt) {
                    var Rt, zt;
                    const nr = (Rt = this.sliderProps_) === null || Rt === void 0 ? void 0 : Rt.get("minValue")
                      , mr = (zt = this.sliderProps_) === null || zt === void 0 ? void 0 : zt.get("maxValue");
                    let Tr = wt;
                    return nr !== void 0 && (Tr = Math.max(Tr, nr)),
                    mr !== void 0 && (Tr = Math.min(Tr, mr)),
                    Tr
                }
                onInputChange_(wt) {
                    const Rt = wt.currentTarget.value
                      , zt = this.parser_(Rt);
                    at(zt) || (this.value.rawValue = this.constrainValue_(zt)),
                    this.view.refresh()
                }
                onInputKeyDown_(wt) {
                    const Rt = Oo(this.baseStep_, jo(wt));
                    Rt !== 0 && this.value.setRawValue(this.constrainValue_(this.value.rawValue + Rt), {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onInputKeyUp_(wt) {
                    Oo(this.baseStep_, jo(wt)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                        forceEmit: !0,
                        last: !0
                    })
                }
                onPointerDown_() {
                    this.originRawValue_ = this.value.rawValue,
                    this.dragging_.rawValue = 0
                }
                computeDraggingValue_(wt) {
                    if (!wt.point)
                        return null;
                    const Rt = wt.point.x - wt.bounds.width / 2;
                    return this.constrainValue_(this.originRawValue_ + Rt * this.props.get("draggingScale"))
                }
                onPointerMove_(wt) {
                    const Rt = this.computeDraggingValue_(wt.data);
                    Rt !== null && (this.value.setRawValue(Rt, {
                        forceEmit: !1,
                        last: !1
                    }),
                    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_)
                }
                onPointerUp_(wt) {
                    const Rt = this.computeDraggingValue_(wt.data);
                    Rt !== null && (this.value.setRawValue(Rt, {
                        forceEmit: !0,
                        last: !0
                    }),
                    this.dragging_.rawValue = null)
                }
            }
            const Wm = Et("sld");
            class E0 {
                constructor(wt, Rt) {
                    this.onChange_ = this.onChange_.bind(this),
                    this.props_ = Rt.props,
                    this.props_.emitter.on("change", this.onChange_),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Wm()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(Wm("t")),
                    Rt.viewProps.bindTabIndex(zt),
                    this.element.appendChild(zt),
                    this.trackElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(Wm("k")),
                    this.trackElement.appendChild(nr),
                    this.knobElement = nr,
                    Rt.value.emitter.on("change", this.onChange_),
                    this.value = Rt.value,
                    this.update_()
                }
                update_() {
                    const wt = Wo(No(this.value.rawValue, this.props_.get("minValue"), this.props_.get("maxValue"), 0, 100), 0, 100);
                    this.knobElement.style.width = `${wt}%`
                }
                onChange_() {
                    this.update_()
                }
            }
            class T0 {
                constructor(wt, Rt) {
                    this.onKeyDown_ = this.onKeyDown_.bind(this),
                    this.onKeyUp_ = this.onKeyUp_.bind(this),
                    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this),
                    this.onPointerUp_ = this.onPointerUp_.bind(this),
                    this.baseStep_ = Rt.baseStep,
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.props = Rt.props,
                    this.view = new E0(wt,{
                        props: this.props,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.ptHandler_ = new ps(this.view.trackElement),
                    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_),
                    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_),
                    this.ptHandler_.emitter.on("up", this.onPointerUp_),
                    this.view.trackElement.addEventListener("keydown", this.onKeyDown_),
                    this.view.trackElement.addEventListener("keyup", this.onKeyUp_)
                }
                handlePointerEvent_(wt, Rt) {
                    wt.point && this.value.setRawValue(No(Wo(wt.point.x, 0, wt.bounds.width), 0, wt.bounds.width, this.props.get("minValue"), this.props.get("maxValue")), Rt)
                }
                onPointerDownOrMove_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerUp_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !0,
                        last: !0
                    })
                }
                onKeyDown_(wt) {
                    const Rt = Oo(this.baseStep_, Xo(wt));
                    Rt !== 0 && this.value.setRawValue(this.value.rawValue + Rt, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onKeyUp_(wt) {
                    Oo(this.baseStep_, Xo(wt)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                        forceEmit: !0,
                        last: !0
                    })
                }
            }
            const qm = Et("sldtxt");
            class C0 {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(qm());
                    const zt = wt.createElement("div");
                    zt.classList.add(qm("s")),
                    this.sliderView_ = Rt.sliderView,
                    zt.appendChild(this.sliderView_.element),
                    this.element.appendChild(zt);
                    const nr = wt.createElement("div");
                    nr.classList.add(qm("t")),
                    this.textView_ = Rt.textView,
                    nr.appendChild(this.textView_.element),
                    this.element.appendChild(nr)
                }
            }
            class $m {
                constructor(wt, Rt) {
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.sliderC_ = new T0(wt,{
                        baseStep: Rt.baseStep,
                        props: Rt.sliderProps,
                        value: Rt.value,
                        viewProps: this.viewProps
                    }),
                    this.textC_ = new pp(wt,{
                        baseStep: Rt.baseStep,
                        parser: Rt.parser,
                        props: Rt.textProps,
                        sliderProps: Rt.sliderProps,
                        value: Rt.value,
                        viewProps: Rt.viewProps
                    }),
                    this.view = new C0(wt,{
                        sliderView: this.sliderC_.view,
                        textView: this.textC_.view
                    })
                }
                get sliderController() {
                    return this.sliderC_
                }
                get textController() {
                    return this.textC_
                }
            }
            function hp(Vt, wt) {
                Vt.write(wt)
            }
            function Kp(Vt) {
                const wt = hr;
                return Array.isArray(Vt) ? wt.required.array(wt.required.object({
                    text: wt.required.string,
                    value: wt.required.raw
                }))(Vt).value : typeof Vt == "object" ? wt.required.raw(Vt).value : void 0
            }
            function Q_(Vt) {
                if (Vt === "inline" || Vt === "popup")
                    return Vt
            }
            function Yl(Vt) {
                const wt = hr;
                return wt.required.object({
                    max: wt.optional.number,
                    min: wt.optional.number,
                    step: wt.optional.number
                })(Vt).value
            }
            function W_(Vt) {
                if (Array.isArray(Vt))
                    return Vt;
                const wt = [];
                return Object.keys(Vt).forEach(Rt => {
                    wt.push({
                        text: Rt,
                        value: Vt[Rt]
                    })
                }
                ),
                wt
            }
            function Xm(Vt) {
                return at(Vt) ? null : new cu(W_(Vt))
            }
            function mp(Vt, wt) {
                const Rt = Vt && Zs(Vt, Ru);
                return Rt ? Vo(Rt.step) : Math.max(Vo(wt), 2)
            }
            function mu(Vt) {
                const wt = function(Rt) {
                    const zt = Rt ? Zs(Rt, Ru) : null;
                    return zt ? zt.step : null
                }(Vt);
                return wt ?? 1
            }
            function fu(Vt, wt) {
                var Rt;
                const zt = Vt && Zs(Vt, Ru)
                  , nr = Math.abs((Rt = zt == null ? void 0 : zt.step) !== null && Rt !== void 0 ? Rt : wt);
                return nr === 0 ? .1 : Math.pow(10, Math.floor(Math.log10(nr)) - 1)
            }
            const fp = Et("ckb");
            class q_ {
                constructor(wt, Rt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(fp()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("label");
                    zt.classList.add(fp("l")),
                    this.element.appendChild(zt);
                    const nr = wt.createElement("input");
                    nr.classList.add(fp("i")),
                    nr.type = "checkbox",
                    zt.appendChild(nr),
                    this.inputElement = nr,
                    Rt.viewProps.bindDisabled(this.inputElement);
                    const mr = wt.createElement("div");
                    mr.classList.add(fp("w")),
                    zt.appendChild(mr);
                    const Tr = Wn(wt, "check");
                    mr.appendChild(Tr),
                    Rt.value.emitter.on("change", this.onValueChange_),
                    this.value = Rt.value,
                    this.update_()
                }
                update_() {
                    this.inputElement.checked = this.value.rawValue
                }
                onValueChange_() {
                    this.update_()
                }
            }
            class $_ {
                constructor(wt, Rt) {
                    this.onInputChange_ = this.onInputChange_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new q_(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view.inputElement.addEventListener("change", this.onInputChange_)
                }
                onInputChange_(wt) {
                    const Rt = wt.currentTarget;
                    this.value.rawValue = Rt.checked
                }
            }
            const X_ = {
                id: "input-bool",
                type: "input",
                accept: (Vt, wt) => {
                    if (typeof Vt != "boolean")
                        return null;
                    const Rt = gr(wt, {
                        options: hr.optional.custom(Kp)
                    });
                    return Rt ? {
                        initialValue: Vt,
                        params: Rt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => Wp,
                    constraint: Vt => function(wt) {
                        const Rt = []
                          , zt = Xm(wt.options);
                        return zt && Rt.push(zt),
                        new lu(Rt)
                    }(Vt.params),
                    writer: Vt => hp
                },
                controller: Vt => {
                    const wt = Vt.document
                      , Rt = Vt.value
                      , zt = Vt.constraint
                      , nr = zt && Zs(zt, cu);
                    return nr ? new uu(wt,{
                        props: new ir({
                            options: nr.values.value("options")
                        }),
                        value: Rt,
                        viewProps: Vt.viewProps
                    }) : new $_(wt,{
                        value: Rt,
                        viewProps: Vt.viewProps
                    })
                }
            }
              , Kl = Et("col");
            class Y_ {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Kl()),
                    Rt.foldable.bindExpandedClass(this.element, Kl(void 0, "expanded")),
                    Dt(Rt.foldable, "completed", Gt(this.element, Kl(void 0, "cpl")));
                    const zt = wt.createElement("div");
                    zt.classList.add(Kl("h")),
                    this.element.appendChild(zt);
                    const nr = wt.createElement("div");
                    nr.classList.add(Kl("s")),
                    zt.appendChild(nr),
                    this.swatchElement = nr;
                    const mr = wt.createElement("div");
                    if (mr.classList.add(Kl("t")),
                    zt.appendChild(mr),
                    this.textElement = mr,
                    Rt.pickerLayout === "inline") {
                        const Tr = wt.createElement("div");
                        Tr.classList.add(Kl("p")),
                        this.element.appendChild(Tr),
                        this.pickerElement = Tr
                    } else
                        this.pickerElement = null
                }
            }
            function Nu(Vt, wt, Rt) {
                const zt = Ou(Vt, 360)
                  , nr = Wo(wt / 100, 0, 1)
                  , mr = Wo(Rt / 100, 0, 1)
                  , Tr = mr * nr
                  , $r = Tr * (1 - Math.abs(zt / 60 % 2 - 1))
                  , vn = mr - Tr;
                let zn, co, is;
                return [zn,co,is] = zt >= 0 && zt < 60 ? [Tr, $r, 0] : zt >= 60 && zt < 120 ? [$r, Tr, 0] : zt >= 120 && zt < 180 ? [0, Tr, $r] : zt >= 180 && zt < 240 ? [0, $r, Tr] : zt >= 240 && zt < 300 ? [$r, 0, Tr] : [Tr, 0, $r],
                [255 * (zn + vn), 255 * (co + vn), 255 * (is + vn)]
            }
            function gu(Vt) {
                return [Vt[0], Vt[1], Vt[2]]
            }
            function K_(Vt, wt) {
                return [Vt[0], Vt[1], Vt[2], wt]
            }
            const P0 = {
                hsl: {
                    hsl: (Vt, wt, Rt) => [Vt, wt, Rt],
                    hsv: function(Vt, wt, Rt) {
                        const zt = Rt + wt * (100 - Math.abs(2 * Rt - 100)) / 200;
                        return [Vt, zt !== 0 ? wt * (100 - Math.abs(2 * Rt - 100)) / zt : 0, Rt + wt * (100 - Math.abs(2 * Rt - 100)) / 200]
                    },
                    rgb: function(Vt, wt, Rt) {
                        const zt = (Vt % 360 + 360) % 360
                          , nr = Wo(wt / 100, 0, 1)
                          , mr = Wo(Rt / 100, 0, 1)
                          , Tr = (1 - Math.abs(2 * mr - 1)) * nr
                          , $r = Tr * (1 - Math.abs(zt / 60 % 2 - 1))
                          , vn = mr - Tr / 2;
                        let zn, co, is;
                        return [zn,co,is] = zt >= 0 && zt < 60 ? [Tr, $r, 0] : zt >= 60 && zt < 120 ? [$r, Tr, 0] : zt >= 120 && zt < 180 ? [0, Tr, $r] : zt >= 180 && zt < 240 ? [0, $r, Tr] : zt >= 240 && zt < 300 ? [$r, 0, Tr] : [Tr, 0, $r],
                        [255 * (zn + vn), 255 * (co + vn), 255 * (is + vn)]
                    }
                },
                hsv: {
                    hsl: function(Vt, wt, Rt) {
                        const zt = 100 - Math.abs(Rt * (200 - wt) / 100 - 100);
                        return [Vt, zt !== 0 ? wt * Rt / zt : 0, Rt * (200 - wt) / 200]
                    },
                    hsv: (Vt, wt, Rt) => [Vt, wt, Rt],
                    rgb: Nu
                },
                rgb: {
                    hsl: function(Vt, wt, Rt) {
                        const zt = Wo(Vt / 255, 0, 1)
                          , nr = Wo(wt / 255, 0, 1)
                          , mr = Wo(Rt / 255, 0, 1)
                          , Tr = Math.max(zt, nr, mr)
                          , $r = Math.min(zt, nr, mr)
                          , vn = Tr - $r;
                        let zn = 0
                          , co = 0;
                        const is = ($r + Tr) / 2;
                        return vn !== 0 && (co = vn / (1 - Math.abs(Tr + $r - 1)),
                        zn = zt === Tr ? (nr - mr) / vn : nr === Tr ? 2 + (mr - zt) / vn : 4 + (zt - nr) / vn,
                        zn = zn / 6 + (zn < 0 ? 1 : 0)),
                        [360 * zn, 100 * co, 100 * is]
                    },
                    hsv: function(Vt, wt, Rt) {
                        const zt = Wo(Vt / 255, 0, 1)
                          , nr = Wo(wt / 255, 0, 1)
                          , mr = Wo(Rt / 255, 0, 1)
                          , Tr = Math.max(zt, nr, mr)
                          , $r = Tr - Math.min(zt, nr, mr);
                        let vn;
                        return vn = $r === 0 ? 0 : Tr === zt ? ((nr - mr) / $r % 6 + 6) % 6 * 60 : Tr === nr ? 60 * ((mr - zt) / $r + 2) : 60 * ((zt - nr) / $r + 4),
                        [vn, 100 * (Tr === 0 ? 0 : $r / Tr), 100 * Tr]
                    },
                    rgb: (Vt, wt, Rt) => [Vt, wt, Rt]
                }
            };
            function Jp(Vt, wt) {
                return [wt === "float" ? 1 : Vt === "rgb" ? 255 : 360, wt === "float" ? 1 : Vt === "rgb" ? 255 : 100, wt === "float" ? 1 : Vt === "rgb" ? 255 : 100]
            }
            function M0(Vt, wt) {
                return Vt === wt ? wt : Ou(Vt, wt)
            }
            function J_(Vt, wt, Rt, zt) {
                const nr = Jp(wt, Rt)
                  , mr = Jp(wt, zt);
                return Vt.map( (Tr, $r) => Tr / nr[$r] * mr[$r])
            }
            function Zp(Vt, wt) {
                return typeof Vt == "object" && !at(Vt) && wt in Vt && typeof Vt[wt] == "number"
            }
            class xo {
                static black(wt="int") {
                    return new xo([0, 0, 0],"rgb",wt)
                }
                static fromObject(wt, Rt="int") {
                    const zt = "a"in wt ? [wt.r, wt.g, wt.b, wt.a] : [wt.r, wt.g, wt.b];
                    return new xo(zt,"rgb",Rt)
                }
                static toRgbaObject(wt, Rt="int") {
                    return wt.toRgbaObject(Rt)
                }
                static isRgbColorObject(wt) {
                    return Zp(wt, "r") && Zp(wt, "g") && Zp(wt, "b")
                }
                static isRgbaColorObject(wt) {
                    return this.isRgbColorObject(wt) && Zp(wt, "a")
                }
                static isColorObject(wt) {
                    return this.isRgbColorObject(wt)
                }
                static equals(wt, Rt) {
                    if (wt.mode !== Rt.mode)
                        return !1;
                    const zt = wt.comps_
                      , nr = Rt.comps_;
                    for (let mr = 0; mr < zt.length; mr++)
                        if (zt[mr] !== nr[mr])
                            return !1;
                    return !0
                }
                constructor(wt, Rt, zt="int") {
                    this.mode = Rt,
                    this.type = zt,
                    this.comps_ = function(nr, mr, Tr) {
                        var $r;
                        const vn = Jp(mr, Tr);
                        return [mr === "rgb" ? Wo(nr[0], 0, vn[0]) : M0(nr[0], vn[0]), Wo(nr[1], 0, vn[1]), Wo(nr[2], 0, vn[2]), Wo(($r = nr[3]) !== null && $r !== void 0 ? $r : 1, 0, 1)]
                    }(wt, Rt, zt)
                }
                getComponents(wt, Rt="int") {
                    return K_(function(zt, nr, mr) {
                        const Tr = J_(zt, nr.mode, nr.type, "int");
                        return J_(P0[nr.mode][mr.mode](...Tr), mr.mode, "int", mr.type)
                    }(gu(this.comps_), {
                        mode: this.mode,
                        type: this.type
                    }, {
                        mode: wt ?? this.mode,
                        type: Rt
                    }), this.comps_[3])
                }
                toRgbaObject(wt="int") {
                    const Rt = this.getComponents("rgb", wt);
                    return {
                        r: Rt[0],
                        g: Rt[1],
                        b: Rt[2],
                        a: Rt[3]
                    }
                }
            }
            const Jl = Et("colp");
            class Ym {
                constructor(wt, Rt) {
                    this.alphaViews_ = null,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Jl()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(Jl("hsv"));
                    const nr = wt.createElement("div");
                    nr.classList.add(Jl("sv")),
                    this.svPaletteView_ = Rt.svPaletteView,
                    nr.appendChild(this.svPaletteView_.element),
                    zt.appendChild(nr);
                    const mr = wt.createElement("div");
                    mr.classList.add(Jl("h")),
                    this.hPaletteView_ = Rt.hPaletteView,
                    mr.appendChild(this.hPaletteView_.element),
                    zt.appendChild(mr),
                    this.element.appendChild(zt);
                    const Tr = wt.createElement("div");
                    if (Tr.classList.add(Jl("rgb")),
                    this.textView_ = Rt.textView,
                    Tr.appendChild(this.textView_.element),
                    this.element.appendChild(Tr),
                    Rt.alphaViews) {
                        this.alphaViews_ = {
                            palette: Rt.alphaViews.palette,
                            text: Rt.alphaViews.text
                        };
                        const $r = wt.createElement("div");
                        $r.classList.add(Jl("a"));
                        const vn = wt.createElement("div");
                        vn.classList.add(Jl("ap")),
                        vn.appendChild(this.alphaViews_.palette.element),
                        $r.appendChild(vn);
                        const zn = wt.createElement("div");
                        zn.classList.add(Jl("at")),
                        zn.appendChild(this.alphaViews_.text.element),
                        $r.appendChild(zn),
                        this.element.appendChild($r)
                    }
                }
                get allFocusableElements() {
                    const wt = [this.svPaletteView_.element, this.hPaletteView_.element, this.textView_.modeSelectElement, ...this.textView_.textViews.map(Rt => Rt.inputElement)];
                    return this.alphaViews_ && wt.push(this.alphaViews_.palette.element, this.alphaViews_.text.inputElement),
                    wt
                }
            }
            function _h(Vt) {
                return Vt === "int" ? "int" : Vt === "float" ? "float" : void 0
            }
            function Qs(Vt) {
                const wt = hr;
                return gr(Vt, {
                    alpha: wt.optional.boolean,
                    color: wt.optional.object({
                        alpha: wt.optional.boolean,
                        type: wt.optional.custom(_h)
                    }),
                    expanded: wt.optional.boolean,
                    picker: wt.optional.custom(Q_)
                })
            }
            function na(Vt) {
                return Vt ? .1 : 1
            }
            function As(Vt) {
                var wt;
                return (wt = Vt.color) === null || wt === void 0 ? void 0 : wt.type
            }
            function Go(Vt, wt) {
                const Rt = Vt.match(/^(.+)%$/);
                return Math.min(Rt ? .01 * parseFloat(Rt[1]) * wt : parseFloat(Vt), wt)
            }
            const Z_ = {
                deg: Vt => Vt,
                grad: Vt => 360 * Vt / 400,
                rad: Vt => 360 * Vt / (2 * Math.PI),
                turn: Vt => 360 * Vt
            };
            function Zl(Vt) {
                const wt = Vt.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
                if (!wt)
                    return parseFloat(Vt);
                const Rt = parseFloat(wt[1])
                  , zt = wt[2];
                return Z_[zt](Rt)
            }
            function _u(Vt) {
                const wt = Vt.match(/^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                if (!wt)
                    return null;
                const Rt = [Go(wt[1], 255), Go(wt[2], 255), Go(wt[3], 255)];
                return isNaN(Rt[0]) || isNaN(Rt[1]) || isNaN(Rt[2]) ? null : Rt
            }
            function Ms(Vt) {
                return wt => {
                    const Rt = _u(wt);
                    return Rt ? new xo(Rt,"rgb",Vt) : null
                }
            }
            function qo(Vt) {
                const wt = Vt.match(/^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                if (!wt)
                    return null;
                const Rt = [Go(wt[1], 255), Go(wt[2], 255), Go(wt[3], 255), Go(wt[4], 1)];
                return isNaN(Rt[0]) || isNaN(Rt[1]) || isNaN(Rt[2]) || isNaN(Rt[3]) ? null : Rt
            }
            function em(Vt) {
                return wt => {
                    const Rt = qo(wt);
                    return Rt ? new xo(Rt,"rgb",Vt) : null
                }
            }
            function Fu(Vt) {
                const wt = Vt.match(/^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                if (!wt)
                    return null;
                const Rt = [Zl(wt[1]), Go(wt[2], 100), Go(wt[3], 100)];
                return isNaN(Rt[0]) || isNaN(Rt[1]) || isNaN(Rt[2]) ? null : Rt
            }
            function tm(Vt) {
                return wt => {
                    const Rt = Fu(wt);
                    return Rt ? new xo(Rt,"hsl",Vt) : null
                }
            }
            function Km(Vt) {
                const wt = Vt.match(/^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/);
                if (!wt)
                    return null;
                const Rt = [Zl(wt[1]), Go(wt[2], 100), Go(wt[3], 100), Go(wt[4], 1)];
                return isNaN(Rt[0]) || isNaN(Rt[1]) || isNaN(Rt[2]) || isNaN(Rt[3]) ? null : Rt
            }
            function gp(Vt) {
                return wt => {
                    const Rt = Km(wt);
                    return Rt ? new xo(Rt,"hsl",Vt) : null
                }
            }
            function ws(Vt) {
                const wt = Vt.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
                if (wt)
                    return [parseInt(wt[1] + wt[1], 16), parseInt(wt[2] + wt[2], 16), parseInt(wt[3] + wt[3], 16)];
                const Rt = Vt.match(/^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
                return Rt ? [parseInt(Rt[1], 16), parseInt(Rt[2], 16), parseInt(Rt[3], 16)] : null
            }
            function oo(Vt) {
                const wt = Vt.match(/^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
                if (wt)
                    return [parseInt(wt[1] + wt[1], 16), parseInt(wt[2] + wt[2], 16), parseInt(wt[3] + wt[3], 16), No(parseInt(wt[4] + wt[4], 16), 0, 255, 0, 1)];
                const Rt = Vt.match(/^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/);
                return Rt ? [parseInt(Rt[1], 16), parseInt(Rt[2], 16), parseInt(Rt[3], 16), No(parseInt(Rt[4], 16), 0, 255, 0, 1)] : null
            }
            function ev(Vt) {
                const wt = Vt.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
                if (!wt)
                    return null;
                const Rt = [parseFloat(wt[1]), parseFloat(wt[2]), parseFloat(wt[3])];
                return isNaN(Rt[0]) || isNaN(Rt[1]) || isNaN(Rt[2]) ? null : Rt
            }
            function mn(Vt) {
                return wt => {
                    const Rt = ev(wt);
                    return Rt ? new xo(Rt,"rgb",Vt) : null
                }
            }
            function lo(Vt) {
                const wt = Vt.match(/^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/);
                if (!wt)
                    return null;
                const Rt = [parseFloat(wt[1]), parseFloat(wt[2]), parseFloat(wt[3]), parseFloat(wt[4])];
                return isNaN(Rt[0]) || isNaN(Rt[1]) || isNaN(Rt[2]) || isNaN(Rt[3]) ? null : Rt
            }
            function rm(Vt) {
                return wt => {
                    const Rt = lo(wt);
                    return Rt ? new xo(Rt,"rgb",Vt) : null
                }
            }
            const tv = [{
                parser: ws,
                result: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "hex"
                }
            }, {
                parser: oo,
                result: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "hex"
                }
            }, {
                parser: _u,
                result: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "func"
                }
            }, {
                parser: qo,
                result: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "func"
                }
            }, {
                parser: Fu,
                result: {
                    alpha: !1,
                    mode: "hsl",
                    notation: "func"
                }
            }, {
                parser: Km,
                result: {
                    alpha: !0,
                    mode: "hsl",
                    notation: "func"
                }
            }, {
                parser: ev,
                result: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "object"
                }
            }, {
                parser: lo,
                result: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "object"
                }
            }];
            function Jm(Vt, wt="int") {
                const Rt = function(zt) {
                    return tv.reduce( (nr, {parser: mr, result: Tr}) => nr || (mr(zt) ? Tr : null), null)
                }(Vt);
                return Rt ? Rt.notation === "hex" && wt !== "float" ? Object.assign(Object.assign({}, Rt), {
                    type: "int"
                }) : Rt.notation === "func" ? Object.assign(Object.assign({}, Rt), {
                    type: wt
                }) : null : null
            }
            const vu = {
                int: [function(Vt) {
                    const wt = ws(Vt);
                    return wt ? new xo(wt,"rgb","int") : null
                }
                , function(Vt) {
                    const wt = oo(Vt);
                    return wt ? new xo(wt,"rgb","int") : null
                }
                , Ms("int"), em("int"), tm("int"), gp("int"), mn("int"), rm("int")],
                float: [Ms("float"), em("float"), tm("float"), gp("float"), mn("float"), rm("float")]
            };
            function yu(Vt) {
                const wt = vu[Vt];
                return Rt => wt.reduce( (zt, nr) => zt || nr(Rt), null)
            }
            function Zm(Vt) {
                const wt = Wo(Math.floor(Vt), 0, 255).toString(16);
                return wt.length === 1 ? `0${wt}` : wt
            }
            function _f(Vt, wt="#") {
                return `${wt}${gu(Vt.getComponents("rgb")).map(Zm).join("")}`
            }
            function xu(Vt, wt="#") {
                const Rt = Vt.getComponents("rgb");
                return `${wt}${[Rt[0], Rt[1], Rt[2], 255 * Rt[3]].map(Zm).join("")}`
            }
            function _g(Vt, wt) {
                const Rt = ts(wt === "float" ? 2 : 0);
                return `rgb(${gu(Vt.getComponents("rgb", wt)).map(zt => Rt(zt)).join(", ")})`
            }
            function rv(Vt) {
                return wt => _g(wt, Vt)
            }
            function bu(Vt, wt) {
                const Rt = ts(2)
                  , zt = ts(wt === "float" ? 2 : 0);
                return `rgba(${Vt.getComponents("rgb", wt).map( (nr, mr) => (mr === 3 ? Rt : zt)(nr)).join(", ")})`
            }
            function R0(Vt) {
                return wt => bu(wt, Vt)
            }
            function Do(Vt, wt) {
                const Rt = ts(wt === "float" ? 2 : 0)
                  , zt = ["r", "g", "b"];
                return `{${gu(Vt.getComponents("rgb", wt)).map( (nr, mr) => `${zt[mr]}: ${Rt(nr)}`).join(", ")}}`
            }
            function Uu(Vt) {
                return wt => Do(wt, Vt)
            }
            function nm(Vt, wt) {
                const Rt = ts(2)
                  , zt = ts(wt === "float" ? 2 : 0)
                  , nr = ["r", "g", "b", "a"];
                return `{${Vt.getComponents("rgb", wt).map( (mr, Tr) => `${nr[Tr]}: ${(Tr === 3 ? Rt : zt)(mr)}`).join(", ")}}`
            }
            function ju(Vt) {
                return wt => nm(wt, Vt)
            }
            const e_ = [{
                format: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "hex",
                    type: "int"
                },
                stringifier: _f
            }, {
                format: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "hex",
                    type: "int"
                },
                stringifier: xu
            }, {
                format: {
                    alpha: !1,
                    mode: "hsl",
                    notation: "func",
                    type: "int"
                },
                stringifier: function(Vt) {
                    const wt = [ts(0), up, up];
                    return `hsl(${gu(Vt.getComponents("hsl")).map( (Rt, zt) => wt[zt](Rt)).join(", ")})`
                }
            }, {
                format: {
                    alpha: !0,
                    mode: "hsl",
                    notation: "func",
                    type: "int"
                },
                stringifier: function(Vt) {
                    const wt = [ts(0), up, up, ts(2)];
                    return `hsla(${Vt.getComponents("hsl").map( (Rt, zt) => wt[zt](Rt)).join(", ")})`
                }
            }, ...["int", "float"].reduce( (Vt, wt) => [...Vt, {
                format: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "func",
                    type: wt
                },
                stringifier: rv(wt)
            }, {
                format: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "func",
                    type: wt
                },
                stringifier: R0(wt)
            }, {
                format: {
                    alpha: !1,
                    mode: "rgb",
                    notation: "object",
                    type: wt
                },
                stringifier: Uu(wt)
            }, {
                format: {
                    alpha: !0,
                    mode: "rgb",
                    notation: "object",
                    type: wt
                },
                stringifier: ju(wt)
            }], [])];
            function t_(Vt) {
                return e_.reduce( (wt, Rt) => {
                    return wt || (zt = Rt.format,
                    nr = Vt,
                    zt.alpha === nr.alpha && zt.mode === nr.mode && zt.notation === nr.notation && zt.type === nr.type ? Rt.stringifier : null);
                    var zt, nr
                }
                , null)
            }
            const ga = Et("apl");
            class r_ {
                constructor(wt, Rt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.value = Rt.value,
                    this.value.emitter.on("change", this.onValueChange_),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(ga()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    Rt.viewProps.bindTabIndex(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(ga("b")),
                    this.element.appendChild(zt);
                    const nr = wt.createElement("div");
                    nr.classList.add(ga("c")),
                    zt.appendChild(nr),
                    this.colorElem_ = nr;
                    const mr = wt.createElement("div");
                    mr.classList.add(ga("m")),
                    this.element.appendChild(mr),
                    this.markerElem_ = mr;
                    const Tr = wt.createElement("div");
                    Tr.classList.add(ga("p")),
                    this.markerElem_.appendChild(Tr),
                    this.previewElem_ = Tr,
                    this.update_()
                }
                update_() {
                    const wt = this.value.rawValue
                      , Rt = wt.getComponents("rgb")
                      , zt = new xo([Rt[0], Rt[1], Rt[2], 0],"rgb")
                      , nr = new xo([Rt[0], Rt[1], Rt[2], 255],"rgb")
                      , mr = ["to right", bu(zt), bu(nr)];
                    this.colorElem_.style.background = `linear-gradient(${mr.join(",")})`,
                    this.previewElem_.style.backgroundColor = bu(wt);
                    const Tr = No(Rt[3], 0, 1, 0, 100);
                    this.markerElem_.style.left = `${Tr}%`
                }
                onValueChange_() {
                    this.update_()
                }
            }
            class I0 {
                constructor(wt, Rt) {
                    this.onKeyDown_ = this.onKeyDown_.bind(this),
                    this.onKeyUp_ = this.onKeyUp_.bind(this),
                    this.onPointerDown_ = this.onPointerDown_.bind(this),
                    this.onPointerMove_ = this.onPointerMove_.bind(this),
                    this.onPointerUp_ = this.onPointerUp_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new r_(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.ptHandler_ = new ps(this.view.element),
                    this.ptHandler_.emitter.on("down", this.onPointerDown_),
                    this.ptHandler_.emitter.on("move", this.onPointerMove_),
                    this.ptHandler_.emitter.on("up", this.onPointerUp_),
                    this.view.element.addEventListener("keydown", this.onKeyDown_),
                    this.view.element.addEventListener("keyup", this.onKeyUp_)
                }
                handlePointerEvent_(wt, Rt) {
                    if (!wt.point)
                        return;
                    const zt = wt.point.x / wt.bounds.width
                      , nr = this.value.rawValue
                      , [mr,Tr,$r] = nr.getComponents("hsv");
                    this.value.setRawValue(new xo([mr, Tr, $r, zt],"hsv"), Rt)
                }
                onPointerDown_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerMove_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerUp_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !0,
                        last: !0
                    })
                }
                onKeyDown_(wt) {
                    const Rt = Oo(na(!0), Xo(wt));
                    if (Rt === 0)
                        return;
                    const zt = this.value.rawValue
                      , [nr,mr,Tr,$r] = zt.getComponents("hsv");
                    this.value.setRawValue(new xo([nr, mr, Tr, $r + Rt],"hsv"), {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onKeyUp_(wt) {
                    Oo(na(!0), Xo(wt)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                        forceEmit: !0,
                        last: !0
                    })
                }
            }
            const Ho = Et("coltxt");
            class Lo {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Ho()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(Ho("m")),
                    this.modeElem_ = function(Tr) {
                        const $r = Tr.createElement("select");
                        return $r.appendChild([{
                            text: "RGB",
                            value: "rgb"
                        }, {
                            text: "HSL",
                            value: "hsl"
                        }, {
                            text: "HSV",
                            value: "hsv"
                        }].reduce( (vn, zn) => {
                            const co = Tr.createElement("option");
                            return co.textContent = zn.text,
                            co.value = zn.value,
                            vn.appendChild(co),
                            vn
                        }
                        , Tr.createDocumentFragment())),
                        $r
                    }(wt),
                    this.modeElem_.classList.add(Ho("ms")),
                    zt.appendChild(this.modeSelectElement),
                    Rt.viewProps.bindDisabled(this.modeElem_);
                    const nr = wt.createElement("div");
                    nr.classList.add(Ho("mm")),
                    nr.appendChild(Wn(wt, "dropdown")),
                    zt.appendChild(nr),
                    this.element.appendChild(zt);
                    const mr = wt.createElement("div");
                    mr.classList.add(Ho("w")),
                    this.element.appendChild(mr),
                    this.textsElem_ = mr,
                    this.textViews_ = Rt.textViews,
                    this.applyTextViews_(),
                    It(Rt.colorMode, Tr => {
                        this.modeElem_.value = Tr
                    }
                    )
                }
                get modeSelectElement() {
                    return this.modeElem_
                }
                get textViews() {
                    return this.textViews_
                }
                set textViews(wt) {
                    this.textViews_ = wt,
                    this.applyTextViews_()
                }
                applyTextViews_() {
                    Ur(this.textsElem_);
                    const wt = this.element.ownerDocument;
                    this.textViews_.forEach(Rt => {
                        const zt = wt.createElement("div");
                        zt.classList.add(Ho("c")),
                        zt.appendChild(Rt.element),
                        this.textsElem_.appendChild(zt)
                    }
                    )
                }
            }
            function nv(Vt, wt, Rt) {
                const zt = Jp(Vt, wt)[Rt];
                return new Xl({
                    min: 0,
                    max: zt
                })
            }
            function Rs(Vt, wt, Rt) {
                return new pp(Vt,{
                    arrayPosition: Rt === 0 ? "fst" : Rt === 2 ? "lst" : "mid",
                    baseStep: na(!1),
                    parser: wt.parser,
                    props: ir.fromObject({
                        draggingScale: wt.colorType === "float" ? .01 : 1,
                        formatter: (zt = wt.colorType,
                        ts(zt === "float" ? 2 : 0))
                    }),
                    value: or(0, {
                        constraint: nv(wt.colorMode, wt.colorType, Rt)
                    }),
                    viewProps: wt.viewProps
                });
                var zt
            }
            class im {
                constructor(wt, Rt) {
                    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this),
                    this.colorType_ = Rt.colorType,
                    this.parser_ = Rt.parser,
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.colorMode = or(this.value.rawValue.mode),
                    this.ccs_ = this.createComponentControllers_(wt),
                    this.view = new Lo(wt,{
                        colorMode: this.colorMode,
                        textViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
                        viewProps: this.viewProps
                    }),
                    this.view.modeSelectElement.addEventListener("change", this.onModeSelectChange_)
                }
                createComponentControllers_(wt) {
                    const Rt = {
                        colorMode: this.colorMode.rawValue,
                        colorType: this.colorType_,
                        parser: this.parser_,
                        viewProps: this.viewProps
                    }
                      , zt = [Rs(wt, Rt, 0), Rs(wt, Rt, 1), Rs(wt, Rt, 2)];
                    return zt.forEach( (nr, mr) => {
                        Lu({
                            primary: this.value,
                            secondary: nr.value,
                            forward: Tr => Tr.rawValue.getComponents(this.colorMode.rawValue, this.colorType_)[mr],
                            backward: (Tr, $r) => {
                                const vn = this.colorMode.rawValue
                                  , zn = Tr.rawValue.getComponents(vn, this.colorType_);
                                return zn[mr] = $r.rawValue,
                                new xo(K_(gu(zn), zn[3]),vn,this.colorType_)
                            }
                        })
                    }
                    ),
                    zt
                }
                onModeSelectChange_(wt) {
                    const Rt = wt.currentTarget;
                    this.colorMode.rawValue = Rt.value,
                    this.ccs_ = this.createComponentControllers_(this.view.element.ownerDocument),
                    this.view.textViews = [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view]
                }
            }
            const n_ = Et("hpl");
            class i_ {
                constructor(wt, Rt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.value = Rt.value,
                    this.value.emitter.on("change", this.onValueChange_),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(n_()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    Rt.viewProps.bindTabIndex(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(n_("c")),
                    this.element.appendChild(zt);
                    const nr = wt.createElement("div");
                    nr.classList.add(n_("m")),
                    this.element.appendChild(nr),
                    this.markerElem_ = nr,
                    this.update_()
                }
                update_() {
                    const wt = this.value.rawValue
                      , [Rt] = wt.getComponents("hsv");
                    this.markerElem_.style.backgroundColor = _g(new xo([Rt, 100, 100],"hsv"));
                    const zt = No(Rt, 0, 360, 0, 100);
                    this.markerElem_.style.left = `${zt}%`
                }
                onValueChange_() {
                    this.update_()
                }
            }
            class k0 {
                constructor(wt, Rt) {
                    this.onKeyDown_ = this.onKeyDown_.bind(this),
                    this.onKeyUp_ = this.onKeyUp_.bind(this),
                    this.onPointerDown_ = this.onPointerDown_.bind(this),
                    this.onPointerMove_ = this.onPointerMove_.bind(this),
                    this.onPointerUp_ = this.onPointerUp_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new i_(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.ptHandler_ = new ps(this.view.element),
                    this.ptHandler_.emitter.on("down", this.onPointerDown_),
                    this.ptHandler_.emitter.on("move", this.onPointerMove_),
                    this.ptHandler_.emitter.on("up", this.onPointerUp_),
                    this.view.element.addEventListener("keydown", this.onKeyDown_),
                    this.view.element.addEventListener("keyup", this.onKeyUp_)
                }
                handlePointerEvent_(wt, Rt) {
                    if (!wt.point)
                        return;
                    const zt = No(Wo(wt.point.x, 0, wt.bounds.width), 0, wt.bounds.width, 0, 360)
                      , nr = this.value.rawValue
                      , [,mr,Tr,$r] = nr.getComponents("hsv");
                    this.value.setRawValue(new xo([zt, mr, Tr, $r],"hsv"), Rt)
                }
                onPointerDown_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerMove_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerUp_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !0,
                        last: !0
                    })
                }
                onKeyDown_(wt) {
                    const Rt = Oo(na(!1), Xo(wt));
                    if (Rt === 0)
                        return;
                    const zt = this.value.rawValue
                      , [nr,mr,Tr,$r] = zt.getComponents("hsv");
                    this.value.setRawValue(new xo([nr + Rt, mr, Tr, $r],"hsv"), {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onKeyUp_(wt) {
                    Oo(na(!1), Xo(wt)) !== 0 && this.value.setRawValue(this.value.rawValue, {
                        forceEmit: !0,
                        last: !0
                    })
                }
            }
            const o_ = Et("svp");
            class Is {
                constructor(wt, Rt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.value = Rt.value,
                    this.value.emitter.on("change", this.onValueChange_),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(o_()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    Rt.viewProps.bindTabIndex(this.element);
                    const zt = wt.createElement("canvas");
                    zt.height = 64,
                    zt.width = 64,
                    zt.classList.add(o_("c")),
                    this.element.appendChild(zt),
                    this.canvasElement = zt;
                    const nr = wt.createElement("div");
                    nr.classList.add(o_("m")),
                    this.element.appendChild(nr),
                    this.markerElem_ = nr,
                    this.update_()
                }
                update_() {
                    const wt = function(zn) {
                        const co = zn.ownerDocument.defaultView;
                        return co && "document"in co ? zn.getContext("2d", {
                            willReadFrequently: !0
                        }) : null
                    }(this.canvasElement);
                    if (!wt)
                        return;
                    const Rt = this.value.rawValue.getComponents("hsv")
                      , zt = this.canvasElement.width
                      , nr = this.canvasElement.height
                      , mr = wt.getImageData(0, 0, zt, nr)
                      , Tr = mr.data;
                    for (let zn = 0; zn < nr; zn++)
                        for (let co = 0; co < zt; co++) {
                            const is = No(co, 0, zt, 0, 100)
                              , Ts = No(zn, 0, nr, 100, 0)
                              , ks = Nu(Rt[0], is, Ts)
                              , Fn = 4 * (zn * zt + co);
                            Tr[Fn] = ks[0],
                            Tr[Fn + 1] = ks[1],
                            Tr[Fn + 2] = ks[2],
                            Tr[Fn + 3] = 255
                        }
                    wt.putImageData(mr, 0, 0);
                    const $r = No(Rt[1], 0, 100, 0, 100);
                    this.markerElem_.style.left = `${$r}%`;
                    const vn = No(Rt[2], 0, 100, 100, 0);
                    this.markerElem_.style.top = `${vn}%`
                }
                onValueChange_() {
                    this.update_()
                }
            }
            class Er {
                constructor(wt, Rt) {
                    this.onKeyDown_ = this.onKeyDown_.bind(this),
                    this.onKeyUp_ = this.onKeyUp_.bind(this),
                    this.onPointerDown_ = this.onPointerDown_.bind(this),
                    this.onPointerMove_ = this.onPointerMove_.bind(this),
                    this.onPointerUp_ = this.onPointerUp_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new Is(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.ptHandler_ = new ps(this.view.element),
                    this.ptHandler_.emitter.on("down", this.onPointerDown_),
                    this.ptHandler_.emitter.on("move", this.onPointerMove_),
                    this.ptHandler_.emitter.on("up", this.onPointerUp_),
                    this.view.element.addEventListener("keydown", this.onKeyDown_),
                    this.view.element.addEventListener("keyup", this.onKeyUp_)
                }
                handlePointerEvent_(wt, Rt) {
                    if (!wt.point)
                        return;
                    const zt = No(wt.point.x, 0, wt.bounds.width, 0, 100)
                      , nr = No(wt.point.y, 0, wt.bounds.height, 100, 0)
                      , [mr,,,Tr] = this.value.rawValue.getComponents("hsv");
                    this.value.setRawValue(new xo([mr, zt, nr, Tr],"hsv"), Rt)
                }
                onPointerDown_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerMove_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerUp_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !0,
                        last: !0
                    })
                }
                onKeyDown_(wt) {
                    dp(wt.key) && wt.preventDefault();
                    const [Rt,zt,nr,mr] = this.value.rawValue.getComponents("hsv")
                      , Tr = na(!1)
                      , $r = Oo(Tr, Xo(wt))
                      , vn = Oo(Tr, jo(wt));
                    $r === 0 && vn === 0 || this.value.setRawValue(new xo([Rt, zt + $r, nr + vn, mr],"hsv"), {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onKeyUp_(wt) {
                    const Rt = na(!1)
                      , zt = Oo(Rt, Xo(wt))
                      , nr = Oo(Rt, jo(wt));
                    zt === 0 && nr === 0 || this.value.setRawValue(this.value.rawValue, {
                        forceEmit: !0,
                        last: !0
                    })
                }
            }
            class s_ {
                constructor(wt, Rt) {
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.hPaletteC_ = new k0(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.svPaletteC_ = new Er(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.alphaIcs_ = Rt.supportsAlpha ? {
                        palette: new I0(wt,{
                            value: this.value,
                            viewProps: this.viewProps
                        }),
                        text: new pp(wt,{
                            parser: Ll,
                            baseStep: .1,
                            props: ir.fromObject({
                                draggingScale: .01,
                                formatter: ts(2)
                            }),
                            value: or(0, {
                                constraint: new Xl({
                                    min: 0,
                                    max: 1
                                })
                            }),
                            viewProps: this.viewProps
                        })
                    } : null,
                    this.alphaIcs_ && Lu({
                        primary: this.value,
                        secondary: this.alphaIcs_.text.value,
                        forward: zt => zt.rawValue.getComponents()[3],
                        backward: (zt, nr) => {
                            const mr = zt.rawValue.getComponents();
                            return mr[3] = nr.rawValue,
                            new xo(mr,zt.rawValue.mode)
                        }
                    }),
                    this.textC_ = new im(wt,{
                        colorType: Rt.colorType,
                        parser: Ll,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view = new Ym(wt,{
                        alphaViews: this.alphaIcs_ ? {
                            palette: this.alphaIcs_.palette.view,
                            text: this.alphaIcs_.text.view
                        } : null,
                        hPaletteView: this.hPaletteC_.view,
                        supportsAlpha: Rt.supportsAlpha,
                        svPaletteView: this.svPaletteC_.view,
                        textView: this.textC_.view,
                        viewProps: this.viewProps
                    })
                }
                get textController() {
                    return this.textC_
                }
            }
            const om = Et("colsw");
            class Tl {
                constructor(wt, Rt) {
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    Rt.value.emitter.on("change", this.onValueChange_),
                    this.value = Rt.value,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(om()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(om("sw")),
                    this.element.appendChild(zt),
                    this.swatchElem_ = zt;
                    const nr = wt.createElement("button");
                    nr.classList.add(om("b")),
                    Rt.viewProps.bindDisabled(nr),
                    this.element.appendChild(nr),
                    this.buttonElement = nr,
                    this.update_()
                }
                update_() {
                    const wt = this.value.rawValue;
                    this.swatchElem_.style.backgroundColor = xu(wt)
                }
                onValueChange_() {
                    this.update_()
                }
            }
            class Nl {
                constructor(wt, Rt) {
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new Tl(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    })
                }
            }
            class xa {
                constructor(wt, Rt) {
                    this.onButtonBlur_ = this.onButtonBlur_.bind(this),
                    this.onButtonClick_ = this.onButtonClick_.bind(this),
                    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this),
                    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.foldable_ = Or.create(Rt.expanded),
                    this.swatchC_ = new Nl(wt,{
                        value: this.value,
                        viewProps: this.viewProps
                    });
                    const zt = this.swatchC_.view.buttonElement;
                    zt.addEventListener("blur", this.onButtonBlur_),
                    zt.addEventListener("click", this.onButtonClick_),
                    this.textC_ = new Iu(wt,{
                        parser: Rt.parser,
                        props: ir.fromObject({
                            formatter: Rt.formatter
                        }),
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view = new Y_(wt,{
                        foldable: this.foldable_,
                        pickerLayout: Rt.pickerLayout
                    }),
                    this.view.swatchElement.appendChild(this.swatchC_.view.element),
                    this.view.textElement.appendChild(this.textC_.view.element),
                    this.popC_ = Rt.pickerLayout === "popup" ? new Hp(wt,{
                        viewProps: this.viewProps
                    }) : null;
                    const nr = new s_(wt,{
                        colorType: Rt.colorType,
                        supportsAlpha: Rt.supportsAlpha,
                        value: this.value,
                        viewProps: this.viewProps
                    });
                    nr.view.allFocusableElements.forEach(mr => {
                        mr.addEventListener("blur", this.onPopupChildBlur_),
                        mr.addEventListener("keydown", this.onPopupChildKeydown_)
                    }
                    ),
                    this.pickerC_ = nr,
                    this.popC_ ? (this.view.element.appendChild(this.popC_.view.element),
                    this.popC_.view.element.appendChild(nr.view.element),
                    Lu({
                        primary: this.foldable_.value("expanded"),
                        secondary: this.popC_.shows,
                        forward: mr => mr.rawValue,
                        backward: (mr, Tr) => Tr.rawValue
                    })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element),
                    gn(this.foldable_, this.view.pickerElement))
                }
                get textController() {
                    return this.textC_
                }
                onButtonBlur_(wt) {
                    if (!this.popC_)
                        return;
                    const Rt = this.view.element
                      , zt = wt.relatedTarget;
                    zt && Rt.contains(zt) || (this.popC_.shows.rawValue = !1)
                }
                onButtonClick_() {
                    this.foldable_.set("expanded", !this.foldable_.get("expanded")),
                    this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
                }
                onPopupChildBlur_(wt) {
                    if (!this.popC_)
                        return;
                    const Rt = this.popC_.view.element
                      , zt = nn(wt);
                    zt && Rt.contains(zt) || zt && zt === this.swatchC_.view.buttonElement && !rn(Rt.ownerDocument) || (this.popC_.shows.rawValue = !1)
                }
                onPopupChildKeydown_(wt) {
                    this.popC_ ? wt.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && wt.key === "Escape" && this.swatchC_.view.buttonElement.focus()
                }
            }
            function Vu(Vt) {
                return gu(Vt.getComponents("rgb")).reduce( (wt, Rt) => wt << 8 | 255 & Math.floor(Rt), 0)
            }
            function Gu(Vt) {
                return Vt.getComponents("rgb").reduce( (wt, Rt, zt) => wt << 8 | 255 & Math.floor(zt === 3 ? 255 * Rt : Rt), 0) >>> 0
            }
            function zu(Vt) {
                return typeof Vt != "number" ? xo.black() : new xo([(wt = Vt) >> 16 & 255, wt >> 8 & 255, 255 & wt],"rgb");
                var wt
            }
            function Hu(Vt) {
                return typeof Vt != "number" ? xo.black() : new xo([(wt = Vt) >> 24 & 255, wt >> 16 & 255, wt >> 8 & 255, No(255 & wt, 0, 255, 0, 1)],"rgb");
                var wt
            }
            function Cl(Vt) {
                var wt;
                return !(!(Vt != null && Vt.alpha) && !(!((wt = Vt == null ? void 0 : Vt.color) === null || wt === void 0) && wt.alpha))
            }
            function _c(Vt) {
                return Vt ? wt => xu(wt, "0x") : wt => _f(wt, "0x")
            }
            const Au = {
                id: "input-color-number",
                type: "input",
                accept: (Vt, wt) => {
                    if (typeof Vt != "number" || !function(zt) {
                        return "color"in zt || "view"in zt && zt.view === "color"
                    }(wt))
                        return null;
                    const Rt = Qs(wt);
                    return Rt ? {
                        initialValue: Vt,
                        params: Rt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => Cl(Vt.params) ? Hu : zu,
                    equals: xo.equals,
                    writer: Vt => function(wt) {
                        const Rt = wt ? Gu : Vu;
                        return (zt, nr) => {
                            hp(zt, Rt(nr))
                        }
                    }(Cl(Vt.params))
                },
                controller: Vt => {
                    const wt = Cl(Vt.params)
                      , Rt = "expanded"in Vt.params ? Vt.params.expanded : void 0
                      , zt = "picker"in Vt.params ? Vt.params.picker : void 0;
                    return new xa(Vt.document,{
                        colorType: "int",
                        expanded: Rt != null && Rt,
                        formatter: _c(wt),
                        parser: yu("int"),
                        pickerLayout: zt ?? "popup",
                        supportsAlpha: wt,
                        value: Vt.value,
                        viewProps: Vt.viewProps
                    })
                }
            };
            function _p(Vt) {
                return wt => function(Rt, zt) {
                    return xo.isColorObject(Rt) ? xo.fromObject(Rt, zt) : xo.black(zt)
                }(wt, Vt)
            }
            function sm(Vt, wt) {
                return Rt => Vt ? nm(Rt, wt) : Do(Rt, wt)
            }
            const am = {
                id: "input-color-object",
                type: "input",
                accept: (Vt, wt) => {
                    if (!xo.isColorObject(Vt))
                        return null;
                    const Rt = Qs(wt);
                    return Rt ? {
                        initialValue: Vt,
                        params: Rt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => _p(As(Vt.params)),
                    equals: xo.equals,
                    writer: Vt => {
                        return zt = Vt.initialValue,
                        wt = xo.isRgbaColorObject(zt),
                        Rt = As(Vt.params),
                        (nr, mr) => {
                            wt ? function(Tr, $r, vn) {
                                const zn = $r.toRgbaObject(vn);
                                Tr.writeProperty("r", zn.r),
                                Tr.writeProperty("g", zn.g),
                                Tr.writeProperty("b", zn.b),
                                Tr.writeProperty("a", zn.a)
                            }(nr, mr, Rt) : function(Tr, $r, vn) {
                                const zn = $r.toRgbaObject(vn);
                                Tr.writeProperty("r", zn.r),
                                Tr.writeProperty("g", zn.g),
                                Tr.writeProperty("b", zn.b)
                            }(nr, mr, Rt)
                        }
                        ;
                        var wt, Rt, zt
                    }
                },
                controller: Vt => {
                    var wt;
                    const Rt = xo.isRgbaColorObject(Vt.initialValue)
                      , zt = "expanded"in Vt.params ? Vt.params.expanded : void 0
                      , nr = "picker"in Vt.params ? Vt.params.picker : void 0
                      , mr = (wt = As(Vt.params)) !== null && wt !== void 0 ? wt : "int";
                    return new xa(Vt.document,{
                        colorType: mr,
                        expanded: zt != null && zt,
                        formatter: sm(Rt, mr),
                        parser: yu(mr),
                        pickerLayout: nr ?? "popup",
                        supportsAlpha: Rt,
                        value: Vt.value,
                        viewProps: Vt.viewProps
                    })
                }
            }
              , wu = {
                id: "input-color-string",
                type: "input",
                accept: (Vt, wt) => {
                    if (typeof Vt != "string" || "view"in wt && wt.view === "text")
                        return null;
                    const Rt = Jm(Vt, As(wt));
                    if (!Rt || !t_(Rt))
                        return null;
                    const zt = Qs(wt);
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => {
                        var wt;
                        return function(Rt) {
                            const zt = vu[Rt];
                            return nr => {
                                if (typeof nr != "string")
                                    return xo.black(Rt);
                                const mr = zt.reduce( (Tr, $r) => Tr || $r(nr), null);
                                return mr ?? xo.black(Rt)
                            }
                        }((wt = As(Vt.params)) !== null && wt !== void 0 ? wt : "int")
                    }
                    ,
                    equals: xo.equals,
                    writer: Vt => {
                        const wt = Jm(Vt.initialValue, As(Vt.params));
                        if (!wt)
                            throw _t.shouldNeverHappen();
                        const Rt = function(zt) {
                            const nr = t_(zt);
                            return nr ? (mr, Tr) => {
                                hp(mr, nr(Tr))
                            }
                            : null
                        }(wt);
                        if (!Rt)
                            throw _t.notBindable();
                        return Rt
                    }
                },
                controller: Vt => {
                    const wt = Jm(Vt.initialValue, As(Vt.params));
                    if (!wt)
                        throw _t.shouldNeverHappen();
                    const Rt = t_(wt);
                    if (!Rt)
                        throw _t.shouldNeverHappen();
                    const zt = "expanded"in Vt.params ? Vt.params.expanded : void 0
                      , nr = "picker"in Vt.params ? Vt.params.picker : void 0;
                    return new xa(Vt.document,{
                        colorType: wt.type,
                        expanded: zt != null && zt,
                        formatter: Rt,
                        parser: yu(wt.type),
                        pickerLayout: nr ?? "popup",
                        supportsAlpha: wt.alpha,
                        value: Vt.value,
                        viewProps: Vt.viewProps
                    })
                }
            };
            class Pl {
                constructor(wt) {
                    this.components = wt.components,
                    this.asm_ = wt.assembly
                }
                constrain(wt) {
                    const Rt = this.asm_.toComponents(wt).map( (zt, nr) => {
                        var mr, Tr;
                        return (Tr = (mr = this.components[nr]) === null || mr === void 0 ? void 0 : mr.constrain(zt)) !== null && Tr !== void 0 ? Tr : zt
                    }
                    );
                    return this.asm_.fromComponents(Rt)
                }
            }
            const iv = Et("pndtxt");
            class vp {
                constructor(wt, Rt) {
                    this.textViews = Rt.textViews,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(iv()),
                    this.textViews.forEach(zt => {
                        const nr = wt.createElement("div");
                        nr.classList.add(iv("a")),
                        nr.appendChild(zt.element),
                        this.element.appendChild(nr)
                    }
                    )
                }
            }
            class yp {
                constructor(wt, Rt) {
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.acs_ = Rt.axes.map( (zt, nr) => function(mr, Tr, $r) {
                        return new pp(mr,{
                            arrayPosition: $r === 0 ? "fst" : $r === Tr.axes.length - 1 ? "lst" : "mid",
                            baseStep: Tr.axes[$r].baseStep,
                            parser: Tr.parser,
                            props: Tr.axes[$r].textProps,
                            value: or(0, {
                                constraint: Tr.axes[$r].constraint
                            }),
                            viewProps: Tr.viewProps
                        })
                    }(wt, Rt, nr)),
                    this.acs_.forEach( (zt, nr) => {
                        Lu({
                            primary: this.value,
                            secondary: zt.value,
                            forward: mr => Rt.assembly.toComponents(mr.rawValue)[nr],
                            backward: (mr, Tr) => {
                                const $r = Rt.assembly.toComponents(mr.rawValue);
                                return $r[nr] = Tr.rawValue,
                                Rt.assembly.fromComponents($r)
                            }
                        })
                    }
                    ),
                    this.view = new vp(wt,{
                        textViews: this.acs_.map(zt => zt.view)
                    })
                }
            }
            function Ws(Vt, wt) {
                return "step"in Vt && !at(Vt.step) ? new Ru(Vt.step,wt) : null
            }
            function Ml(Vt) {
                return at(Vt.max) || at(Vt.min) ? at(Vt.max) && at(Vt.min) ? null : new Gp({
                    max: Vt.max,
                    min: Vt.min
                }) : new Xl({
                    max: Vt.max,
                    min: Vt.min
                })
            }
            const a_ = {
                id: "input-number",
                type: "input",
                accept: (Vt, wt) => {
                    if (typeof Vt != "number")
                        return null;
                    const Rt = hr
                      , zt = gr(wt, {
                        format: Rt.optional.function,
                        max: Rt.optional.number,
                        min: Rt.optional.number,
                        options: Rt.optional.custom(Kp),
                        step: Rt.optional.number
                    });
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => H_,
                    constraint: Vt => function(wt, Rt) {
                        const zt = []
                          , nr = Ws(wt, Rt);
                        nr && zt.push(nr);
                        const mr = Ml(wt);
                        mr && zt.push(mr);
                        const Tr = Xm(wt.options);
                        return Tr && zt.push(Tr),
                        new lu(zt)
                    }(Vt.params, Vt.initialValue),
                    writer: Vt => hp
                },
                controller: Vt => {
                    var wt;
                    const Rt = Vt.value
                      , zt = Vt.constraint
                      , nr = zt && Zs(zt, cu);
                    if (nr)
                        return new uu(Vt.document,{
                            props: new ir({
                                options: nr.values.value("options")
                            }),
                            value: Rt,
                            viewProps: Vt.viewProps
                        });
                    const mr = (wt = "format"in Vt.params ? Vt.params.format : void 0) !== null && wt !== void 0 ? wt : ts(mp(zt, Rt.rawValue))
                      , Tr = zt && Zs(zt, Xl);
                    return Tr ? new $m(Vt.document,{
                        baseStep: mu(zt),
                        parser: Ll,
                        sliderProps: new ir({
                            maxValue: Tr.values.value("max"),
                            minValue: Tr.values.value("min")
                        }),
                        textProps: ir.fromObject({
                            draggingScale: fu(zt, Rt.rawValue),
                            formatter: mr
                        }),
                        value: Rt,
                        viewProps: Vt.viewProps
                    }) : new pp(Vt.document,{
                        baseStep: mu(zt),
                        parser: Ll,
                        props: ir.fromObject({
                            draggingScale: fu(zt, Rt.rawValue),
                            formatter: mr
                        }),
                        value: Rt,
                        viewProps: Vt.viewProps
                    })
                }
            };
            class ba {
                constructor(wt=0, Rt=0) {
                    this.x = wt,
                    this.y = Rt
                }
                getComponents() {
                    return [this.x, this.y]
                }
                static isObject(wt) {
                    if (at(wt))
                        return !1;
                    const Rt = wt.x
                      , zt = wt.y;
                    return typeof Rt == "number" && typeof zt == "number"
                }
                static equals(wt, Rt) {
                    return wt.x === Rt.x && wt.y === Rt.y
                }
                toObject() {
                    return {
                        x: this.x,
                        y: this.y
                    }
                }
            }
            const Fl = {
                toComponents: Vt => Vt.getComponents(),
                fromComponents: Vt => new ba(...Vt)
            }
              , eu = Et("p2d");
            class lm {
                constructor(wt, Rt) {
                    this.element = wt.createElement("div"),
                    this.element.classList.add(eu()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    It(Rt.expanded, Gt(this.element, eu(void 0, "expanded")));
                    const zt = wt.createElement("div");
                    zt.classList.add(eu("h")),
                    this.element.appendChild(zt);
                    const nr = wt.createElement("button");
                    nr.classList.add(eu("b")),
                    nr.appendChild(Wn(wt, "p2dpad")),
                    Rt.viewProps.bindDisabled(nr),
                    zt.appendChild(nr),
                    this.buttonElement = nr;
                    const mr = wt.createElement("div");
                    if (mr.classList.add(eu("t")),
                    zt.appendChild(mr),
                    this.textElement = mr,
                    Rt.pickerLayout === "inline") {
                        const Tr = wt.createElement("div");
                        Tr.classList.add(eu("p")),
                        this.element.appendChild(Tr),
                        this.pickerElement = Tr
                    } else
                        this.pickerElement = null
                }
            }
            const Rl = Et("p2dp");
            class Qu {
                constructor(wt, Rt) {
                    this.onFoldableChange_ = this.onFoldableChange_.bind(this),
                    this.onValueChange_ = this.onValueChange_.bind(this),
                    this.invertsY_ = Rt.invertsY,
                    this.maxValue_ = Rt.maxValue,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(Rl()),
                    Rt.layout === "popup" && this.element.classList.add(Rl(void 0, "p")),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("div");
                    zt.classList.add(Rl("p")),
                    Rt.viewProps.bindTabIndex(zt),
                    this.element.appendChild(zt),
                    this.padElement = zt;
                    const nr = wt.createElementNS(vr, "svg");
                    nr.classList.add(Rl("g")),
                    this.padElement.appendChild(nr),
                    this.svgElem_ = nr;
                    const mr = wt.createElementNS(vr, "line");
                    mr.classList.add(Rl("ax")),
                    mr.setAttributeNS(null, "x1", "0"),
                    mr.setAttributeNS(null, "y1", "50%"),
                    mr.setAttributeNS(null, "x2", "100%"),
                    mr.setAttributeNS(null, "y2", "50%"),
                    this.svgElem_.appendChild(mr);
                    const Tr = wt.createElementNS(vr, "line");
                    Tr.classList.add(Rl("ax")),
                    Tr.setAttributeNS(null, "x1", "50%"),
                    Tr.setAttributeNS(null, "y1", "0"),
                    Tr.setAttributeNS(null, "x2", "50%"),
                    Tr.setAttributeNS(null, "y2", "100%"),
                    this.svgElem_.appendChild(Tr);
                    const $r = wt.createElementNS(vr, "line");
                    $r.classList.add(Rl("l")),
                    $r.setAttributeNS(null, "x1", "50%"),
                    $r.setAttributeNS(null, "y1", "50%"),
                    this.svgElem_.appendChild($r),
                    this.lineElem_ = $r;
                    const vn = wt.createElement("div");
                    vn.classList.add(Rl("m")),
                    this.padElement.appendChild(vn),
                    this.markerElem_ = vn,
                    Rt.value.emitter.on("change", this.onValueChange_),
                    this.value = Rt.value,
                    this.update_()
                }
                get allFocusableElements() {
                    return [this.padElement]
                }
                update_() {
                    const [wt,Rt] = this.value.rawValue.getComponents()
                      , zt = this.maxValue_
                      , nr = No(wt, -zt, +zt, 0, 100)
                      , mr = No(Rt, -zt, +zt, 0, 100)
                      , Tr = this.invertsY_ ? 100 - mr : mr;
                    this.lineElem_.setAttributeNS(null, "x2", `${nr}%`),
                    this.lineElem_.setAttributeNS(null, "y2", `${Tr}%`),
                    this.markerElem_.style.left = `${nr}%`,
                    this.markerElem_.style.top = `${Tr}%`
                }
                onValueChange_() {
                    this.update_()
                }
                onFoldableChange_() {
                    this.update_()
                }
            }
            function no(Vt, wt, Rt) {
                return [Oo(wt[0], Xo(Vt)), Oo(wt[1], jo(Vt)) * (Rt ? 1 : -1)]
            }
            class Wu {
                constructor(wt, Rt) {
                    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this),
                    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this),
                    this.onPointerDown_ = this.onPointerDown_.bind(this),
                    this.onPointerMove_ = this.onPointerMove_.bind(this),
                    this.onPointerUp_ = this.onPointerUp_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.baseSteps_ = Rt.baseSteps,
                    this.maxValue_ = Rt.maxValue,
                    this.invertsY_ = Rt.invertsY,
                    this.view = new Qu(wt,{
                        invertsY: this.invertsY_,
                        layout: Rt.layout,
                        maxValue: this.maxValue_,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.ptHandler_ = new ps(this.view.padElement),
                    this.ptHandler_.emitter.on("down", this.onPointerDown_),
                    this.ptHandler_.emitter.on("move", this.onPointerMove_),
                    this.ptHandler_.emitter.on("up", this.onPointerUp_),
                    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_),
                    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_)
                }
                handlePointerEvent_(wt, Rt) {
                    if (!wt.point)
                        return;
                    const zt = this.maxValue_
                      , nr = No(wt.point.x, 0, wt.bounds.width, -zt, +zt)
                      , mr = No(this.invertsY_ ? wt.bounds.height - wt.point.y : wt.point.y, 0, wt.bounds.height, -zt, +zt);
                    this.value.setRawValue(new ba(nr,mr), Rt)
                }
                onPointerDown_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerMove_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPointerUp_(wt) {
                    this.handlePointerEvent_(wt.data, {
                        forceEmit: !0,
                        last: !0
                    })
                }
                onPadKeyDown_(wt) {
                    dp(wt.key) && wt.preventDefault();
                    const [Rt,zt] = no(wt, this.baseSteps_, this.invertsY_);
                    Rt === 0 && zt === 0 || this.value.setRawValue(new ba(this.value.rawValue.x + Rt,this.value.rawValue.y + zt), {
                        forceEmit: !1,
                        last: !1
                    })
                }
                onPadKeyUp_(wt) {
                    const [Rt,zt] = no(wt, this.baseSteps_, this.invertsY_);
                    Rt === 0 && zt === 0 || this.value.setRawValue(this.value.rawValue, {
                        forceEmit: !0,
                        last: !0
                    })
                }
            }
            class $a {
                constructor(wt, Rt) {
                    var zt, nr;
                    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this),
                    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this),
                    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this),
                    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this),
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.foldable_ = Or.create(Rt.expanded),
                    this.popC_ = Rt.pickerLayout === "popup" ? new Hp(wt,{
                        viewProps: this.viewProps
                    }) : null;
                    const mr = new Wu(wt,{
                        baseSteps: [Rt.axes[0].baseStep, Rt.axes[1].baseStep],
                        invertsY: Rt.invertsY,
                        layout: Rt.pickerLayout,
                        maxValue: Rt.maxValue,
                        value: this.value,
                        viewProps: this.viewProps
                    });
                    mr.view.allFocusableElements.forEach(Tr => {
                        Tr.addEventListener("blur", this.onPopupChildBlur_),
                        Tr.addEventListener("keydown", this.onPopupChildKeydown_)
                    }
                    ),
                    this.pickerC_ = mr,
                    this.textC_ = new yp(wt,{
                        assembly: Fl,
                        axes: Rt.axes,
                        parser: Rt.parser,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    this.view = new lm(wt,{
                        expanded: this.foldable_.value("expanded"),
                        pickerLayout: Rt.pickerLayout,
                        viewProps: this.viewProps
                    }),
                    this.view.textElement.appendChild(this.textC_.view.element),
                    (zt = this.view.buttonElement) === null || zt === void 0 || zt.addEventListener("blur", this.onPadButtonBlur_),
                    (nr = this.view.buttonElement) === null || nr === void 0 || nr.addEventListener("click", this.onPadButtonClick_),
                    this.popC_ ? (this.view.element.appendChild(this.popC_.view.element),
                    this.popC_.view.element.appendChild(this.pickerC_.view.element),
                    Lu({
                        primary: this.foldable_.value("expanded"),
                        secondary: this.popC_.shows,
                        forward: Tr => Tr.rawValue,
                        backward: (Tr, $r) => $r.rawValue
                    })) : this.view.pickerElement && (this.view.pickerElement.appendChild(this.pickerC_.view.element),
                    gn(this.foldable_, this.view.pickerElement))
                }
                onPadButtonBlur_(wt) {
                    if (!this.popC_)
                        return;
                    const Rt = this.view.element
                      , zt = wt.relatedTarget;
                    zt && Rt.contains(zt) || (this.popC_.shows.rawValue = !1)
                }
                onPadButtonClick_() {
                    this.foldable_.set("expanded", !this.foldable_.get("expanded")),
                    this.foldable_.get("expanded") && this.pickerC_.view.allFocusableElements[0].focus()
                }
                onPopupChildBlur_(wt) {
                    if (!this.popC_)
                        return;
                    const Rt = this.popC_.view.element
                      , zt = nn(wt);
                    zt && Rt.contains(zt) || zt && zt === this.view.buttonElement && !rn(Rt.ownerDocument) || (this.popC_.shows.rawValue = !1)
                }
                onPopupChildKeydown_(wt) {
                    this.popC_ ? wt.key === "Escape" && (this.popC_.shows.rawValue = !1) : this.view.pickerElement && wt.key === "Escape" && this.view.buttonElement.focus()
                }
            }
            class qu {
                constructor(wt=0, Rt=0, zt=0) {
                    this.x = wt,
                    this.y = Rt,
                    this.z = zt
                }
                getComponents() {
                    return [this.x, this.y, this.z]
                }
                static isObject(wt) {
                    if (at(wt))
                        return !1;
                    const Rt = wt.x
                      , zt = wt.y
                      , nr = wt.z;
                    return typeof Rt == "number" && typeof zt == "number" && typeof nr == "number"
                }
                static equals(wt, Rt) {
                    return wt.x === Rt.x && wt.y === Rt.y && wt.z === Rt.z
                }
                toObject() {
                    return {
                        x: this.x,
                        y: this.y,
                        z: this.z
                    }
                }
            }
            const ov = {
                toComponents: Vt => Vt.getComponents(),
                fromComponents: Vt => new qu(...Vt)
            };
            function tu(Vt) {
                return qu.isObject(Vt) ? new qu(Vt.x,Vt.y,Vt.z) : new qu
            }
            function cm(Vt, wt) {
                Vt.writeProperty("x", wt.x),
                Vt.writeProperty("y", wt.y),
                Vt.writeProperty("z", wt.z)
            }
            function Ss(Vt, wt) {
                return {
                    baseStep: mu(wt),
                    constraint: wt,
                    textProps: ir.fromObject({
                        draggingScale: fu(wt, Vt),
                        formatter: ts(mp(wt, Vt))
                    })
                }
            }
            const sv = {
                id: "input-point3d",
                type: "input",
                accept: (Vt, wt) => {
                    if (!qu.isObject(Vt))
                        return null;
                    const Rt = hr
                      , zt = gr(wt, {
                        x: Rt.optional.custom(Yl),
                        y: Rt.optional.custom(Yl),
                        z: Rt.optional.custom(Yl)
                    });
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => tu,
                    constraint: Vt => {
                        return wt = Vt.params,
                        Rt = Vt.initialValue,
                        new Pl({
                            assembly: ov,
                            components: [_l("x"in wt ? wt.x : void 0, Rt.x), _l("y"in wt ? wt.y : void 0, Rt.y), _l("z"in wt ? wt.z : void 0, Rt.z)]
                        });
                        var wt, Rt
                    }
                    ,
                    equals: qu.equals,
                    writer: Vt => cm
                },
                controller: Vt => {
                    const wt = Vt.value
                      , Rt = Vt.constraint;
                    if (!(Rt instanceof Pl))
                        throw _t.shouldNeverHappen();
                    return new yp(Vt.document,{
                        assembly: ov,
                        axes: [Ss(wt.rawValue.x, Rt.components[0]), Ss(wt.rawValue.y, Rt.components[1]), Ss(wt.rawValue.z, Rt.components[2])],
                        parser: Ll,
                        value: wt,
                        viewProps: Vt.viewProps
                    })
                }
            };
            class Su {
                constructor(wt=0, Rt=0, zt=0, nr=0) {
                    this.x = wt,
                    this.y = Rt,
                    this.z = zt,
                    this.w = nr
                }
                getComponents() {
                    return [this.x, this.y, this.z, this.w]
                }
                static isObject(wt) {
                    if (at(wt))
                        return !1;
                    const Rt = wt.x
                      , zt = wt.y
                      , nr = wt.z
                      , mr = wt.w;
                    return typeof Rt == "number" && typeof zt == "number" && typeof nr == "number" && typeof mr == "number"
                }
                static equals(wt, Rt) {
                    return wt.x === Rt.x && wt.y === Rt.y && wt.z === Rt.z && wt.w === Rt.w
                }
                toObject() {
                    return {
                        x: this.x,
                        y: this.y,
                        z: this.z,
                        w: this.w
                    }
                }
            }
            const $u = {
                toComponents: Vt => Vt.getComponents(),
                fromComponents: Vt => new Su(...Vt)
            };
            function um(Vt) {
                return Su.isObject(Vt) ? new Su(Vt.x,Vt.y,Vt.z,Vt.w) : new Su
            }
            function D0(Vt, wt) {
                Vt.writeProperty("x", wt.x),
                Vt.writeProperty("y", wt.y),
                Vt.writeProperty("z", wt.z),
                Vt.writeProperty("w", wt.w)
            }
            const av = {
                id: "input-point4d",
                type: "input",
                accept: (Vt, wt) => {
                    if (!Su.isObject(Vt))
                        return null;
                    const Rt = hr
                      , zt = gr(wt, {
                        x: Rt.optional.custom(Yl),
                        y: Rt.optional.custom(Yl),
                        z: Rt.optional.custom(Yl),
                        w: Rt.optional.custom(Yl)
                    });
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => um,
                    constraint: Vt => {
                        return wt = Vt.params,
                        Rt = Vt.initialValue,
                        new Pl({
                            assembly: $u,
                            components: [_l("x"in wt ? wt.x : void 0, Rt.x), _l("y"in wt ? wt.y : void 0, Rt.y), _l("z"in wt ? wt.z : void 0, Rt.z), _l("w"in wt ? wt.w : void 0, Rt.w)]
                        });
                        var wt, Rt
                    }
                    ,
                    equals: Su.equals,
                    writer: Vt => D0
                },
                controller: Vt => {
                    const wt = Vt.value
                      , Rt = Vt.constraint;
                    if (!(Rt instanceof Pl))
                        throw _t.shouldNeverHappen();
                    return new yp(Vt.document,{
                        assembly: $u,
                        axes: wt.rawValue.getComponents().map( (zt, nr) => {
                            return mr = zt,
                            {
                                baseStep: mu(Tr = Rt.components[nr]),
                                constraint: Tr,
                                textProps: ir.fromObject({
                                    draggingScale: fu(Tr, mr),
                                    formatter: ts(mp(Tr, mr))
                                })
                            };
                            var mr, Tr
                        }
                        ),
                        parser: Ll,
                        value: wt,
                        viewProps: Vt.viewProps
                    })
                }
            }
              , Xu = {
                id: "input-string",
                type: "input",
                accept: (Vt, wt) => {
                    if (typeof Vt != "string")
                        return null;
                    const Rt = gr(wt, {
                        options: hr.optional.custom(Kp)
                    });
                    return Rt ? {
                        initialValue: Vt,
                        params: Rt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => Qm,
                    constraint: Vt => function(wt) {
                        const Rt = []
                          , zt = Xm(wt.options);
                        return zt && Rt.push(zt),
                        new lu(Rt)
                    }(Vt.params),
                    writer: Vt => hp
                },
                controller: Vt => {
                    const wt = Vt.document
                      , Rt = Vt.value
                      , zt = Vt.constraint
                      , nr = zt && Zs(zt, cu);
                    return nr ? new uu(wt,{
                        props: new ir({
                            options: nr.values.value("options")
                        }),
                        value: Rt,
                        viewProps: Vt.viewProps
                    }) : new Iu(wt,{
                        parser: mr => mr,
                        props: ir.fromObject({
                            formatter: El
                        }),
                        value: Rt,
                        viewProps: Vt.viewProps
                    })
                }
            }
              , Ns = {
                defaultInterval: 200,
                defaultLineCount: 3
            }
              , xp = Et("mll");
            class bp {
                constructor(wt, Rt) {
                    this.onValueUpdate_ = this.onValueUpdate_.bind(this),
                    this.formatter_ = Rt.formatter,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(xp()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("textarea");
                    zt.classList.add(xp("i")),
                    zt.style.height = `calc(var(--bld-us) * ${Rt.lineCount})`,
                    zt.readOnly = !0,
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.textareaElem_ = zt,
                    Rt.value.emitter.on("change", this.onValueUpdate_),
                    this.value = Rt.value,
                    this.update_()
                }
                update_() {
                    const wt = this.textareaElem_
                      , Rt = wt.scrollTop === wt.scrollHeight - wt.clientHeight
                      , zt = [];
                    this.value.rawValue.forEach(nr => {
                        nr !== void 0 && zt.push(this.formatter_(nr))
                    }
                    ),
                    wt.textContent = zt.join(`
`),
                    Rt && (wt.scrollTop = wt.scrollHeight)
                }
                onValueUpdate_() {
                    this.update_()
                }
            }
            class l_ {
                constructor(wt, Rt) {
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new bp(wt,{
                        formatter: Rt.formatter,
                        lineCount: Rt.lineCount,
                        value: this.value,
                        viewProps: this.viewProps
                    })
                }
            }
            const lv = Et("sgl");
            class cv {
                constructor(wt, Rt) {
                    this.onValueUpdate_ = this.onValueUpdate_.bind(this),
                    this.formatter_ = Rt.formatter,
                    this.element = wt.createElement("div"),
                    this.element.classList.add(lv()),
                    Rt.viewProps.bindClassModifiers(this.element);
                    const zt = wt.createElement("input");
                    zt.classList.add(lv("i")),
                    zt.readOnly = !0,
                    zt.type = "text",
                    Rt.viewProps.bindDisabled(zt),
                    this.element.appendChild(zt),
                    this.inputElement = zt,
                    Rt.value.emitter.on("change", this.onValueUpdate_),
                    this.value = Rt.value,
                    this.update_()
                }
                update_() {
                    const wt = this.value.rawValue
                      , Rt = wt[wt.length - 1];
                    this.inputElement.value = Rt !== void 0 ? this.formatter_(Rt) : ""
                }
                onValueUpdate_() {
                    this.update_()
                }
            }
            class dm {
                constructor(wt, Rt) {
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.view = new cv(wt,{
                        formatter: Rt.formatter,
                        value: this.value,
                        viewProps: this.viewProps
                    })
                }
            }
            const uv = {
                id: "monitor-bool",
                type: "monitor",
                accept: (Vt, wt) => {
                    if (typeof Vt != "boolean")
                        return null;
                    const Rt = gr(wt, {
                        lineCount: hr.optional.number
                    });
                    return Rt ? {
                        initialValue: Vt,
                        params: Rt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => Wp
                },
                controller: Vt => {
                    var wt;
                    return Vt.value.rawValue.length === 1 ? new dm(Vt.document,{
                        formatter: sp,
                        value: Vt.value,
                        viewProps: Vt.viewProps
                    }) : new l_(Vt.document,{
                        formatter: sp,
                        lineCount: (wt = Vt.params.lineCount) !== null && wt !== void 0 ? wt : Ns.defaultLineCount,
                        value: Vt.value,
                        viewProps: Vt.viewProps
                    })
                }
            }
              , ru = Et("grl");
            class B0 {
                constructor(wt, Rt) {
                    this.onCursorChange_ = this.onCursorChange_.bind(this),
                    this.onValueUpdate_ = this.onValueUpdate_.bind(this),
                    this.element = wt.createElement("div"),
                    this.element.classList.add(ru()),
                    Rt.viewProps.bindClassModifiers(this.element),
                    this.formatter_ = Rt.formatter,
                    this.props_ = Rt.props,
                    this.cursor_ = Rt.cursor,
                    this.cursor_.emitter.on("change", this.onCursorChange_);
                    const zt = wt.createElementNS(vr, "svg");
                    zt.classList.add(ru("g")),
                    zt.style.height = `calc(var(--bld-us) * ${Rt.lineCount})`,
                    this.element.appendChild(zt),
                    this.svgElem_ = zt;
                    const nr = wt.createElementNS(vr, "polyline");
                    this.svgElem_.appendChild(nr),
                    this.lineElem_ = nr;
                    const mr = wt.createElement("div");
                    mr.classList.add(ru("t"), Et("tt")()),
                    this.element.appendChild(mr),
                    this.tooltipElem_ = mr,
                    Rt.value.emitter.on("change", this.onValueUpdate_),
                    this.value = Rt.value,
                    this.update_()
                }
                get graphElement() {
                    return this.svgElem_
                }
                update_() {
                    const wt = this.svgElem_.getBoundingClientRect()
                      , Rt = this.value.rawValue.length - 1
                      , zt = this.props_.get("minValue")
                      , nr = this.props_.get("maxValue")
                      , mr = [];
                    this.value.rawValue.forEach( (co, is) => {
                        if (co === void 0)
                            return;
                        const Ts = No(is, 0, Rt, 0, wt.width)
                          , ks = No(co, zt, nr, wt.height, 0);
                        mr.push([Ts, ks].join(","))
                    }
                    ),
                    this.lineElem_.setAttributeNS(null, "points", mr.join(" "));
                    const Tr = this.tooltipElem_
                      , $r = this.value.rawValue[this.cursor_.rawValue];
                    if ($r === void 0)
                        return void Tr.classList.remove(ru("t", "a"));
                    const vn = No(this.cursor_.rawValue, 0, Rt, 0, wt.width)
                      , zn = No($r, zt, nr, wt.height, 0);
                    Tr.style.left = `${vn}px`,
                    Tr.style.top = `${zn}px`,
                    Tr.textContent = `${this.formatter_($r)}`,
                    Tr.classList.contains(ru("t", "a")) || (Tr.classList.add(ru("t", "a"), ru("t", "in")),
                    Zr(Tr),
                    Tr.classList.remove(ru("t", "in")))
                }
                onValueUpdate_() {
                    this.update_()
                }
                onCursorChange_() {
                    this.update_()
                }
            }
            class Mo {
                constructor(wt, Rt) {
                    if (this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this),
                    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this),
                    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this),
                    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this),
                    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this),
                    this.props_ = Rt.props,
                    this.value = Rt.value,
                    this.viewProps = Rt.viewProps,
                    this.cursor_ = or(-1),
                    this.view = new B0(wt,{
                        cursor: this.cursor_,
                        formatter: Rt.formatter,
                        lineCount: Rt.lineCount,
                        props: this.props_,
                        value: this.value,
                        viewProps: this.viewProps
                    }),
                    rn(wt)) {
                        const zt = new ps(this.view.element);
                        zt.emitter.on("down", this.onGraphPointerDown_),
                        zt.emitter.on("move", this.onGraphPointerMove_),
                        zt.emitter.on("up", this.onGraphPointerUp_)
                    } else
                        this.view.element.addEventListener("mousemove", this.onGraphMouseMove_),
                        this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_)
                }
                onGraphMouseLeave_() {
                    this.cursor_.rawValue = -1
                }
                onGraphMouseMove_(wt) {
                    const Rt = this.view.element.getBoundingClientRect();
                    this.cursor_.rawValue = Math.floor(No(wt.offsetX, 0, Rt.width, 0, this.value.rawValue.length))
                }
                onGraphPointerDown_(wt) {
                    this.onGraphPointerMove_(wt)
                }
                onGraphPointerMove_(wt) {
                    wt.data.point ? this.cursor_.rawValue = Math.floor(No(wt.data.point.x, 0, wt.data.bounds.width, 0, this.value.rawValue.length)) : this.cursor_.rawValue = -1
                }
                onGraphPointerUp_() {
                    this.cursor_.rawValue = -1
                }
            }
            function Fs(Vt) {
                return "format"in Vt && !at(Vt.format) ? Vt.format : ts(2)
            }
            function Il(Vt) {
                return "view"in Vt && Vt.view === "graph"
            }
            const c_ = {
                id: "monitor-number",
                type: "monitor",
                accept: (Vt, wt) => {
                    if (typeof Vt != "number")
                        return null;
                    const Rt = hr
                      , zt = gr(wt, {
                        format: Rt.optional.function,
                        lineCount: Rt.optional.number,
                        max: Rt.optional.number,
                        min: Rt.optional.number,
                        view: Rt.optional.string
                    });
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    defaultBufferSize: Vt => Il(Vt) ? 64 : 1,
                    reader: Vt => H_
                },
                controller: Vt => Il(Vt.params) ? function(wt) {
                    var Rt, zt, nr;
                    return new Mo(wt.document,{
                        formatter: Fs(wt.params),
                        lineCount: (Rt = wt.params.lineCount) !== null && Rt !== void 0 ? Rt : Ns.defaultLineCount,
                        props: ir.fromObject({
                            maxValue: (zt = "max"in wt.params ? wt.params.max : null) !== null && zt !== void 0 ? zt : 100,
                            minValue: (nr = "min"in wt.params ? wt.params.min : null) !== null && nr !== void 0 ? nr : 0
                        }),
                        value: wt.value,
                        viewProps: wt.viewProps
                    })
                }(Vt) : function(wt) {
                    var Rt;
                    return wt.value.rawValue.length === 1 ? new dm(wt.document,{
                        formatter: Fs(wt.params),
                        value: wt.value,
                        viewProps: wt.viewProps
                    }) : new l_(wt.document,{
                        formatter: Fs(wt.params),
                        lineCount: (Rt = wt.params.lineCount) !== null && Rt !== void 0 ? Rt : Ns.defaultLineCount,
                        value: wt.value,
                        viewProps: wt.viewProps
                    })
                }(Vt)
            }
              , Ul = {
                id: "monitor-string",
                type: "monitor",
                accept: (Vt, wt) => {
                    if (typeof Vt != "string")
                        return null;
                    const Rt = hr
                      , zt = gr(wt, {
                        lineCount: Rt.optional.number,
                        multiline: Rt.optional.boolean
                    });
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => Qm
                },
                controller: Vt => {
                    var wt;
                    const Rt = Vt.value;
                    return Rt.rawValue.length > 1 || "multiline"in Vt.params && Vt.params.multiline ? new l_(Vt.document,{
                        formatter: El,
                        lineCount: (wt = Vt.params.lineCount) !== null && wt !== void 0 ? wt : Ns.defaultLineCount,
                        value: Rt,
                        viewProps: Vt.viewProps
                    }) : new dm(Vt.document,{
                        formatter: El,
                        value: Rt,
                        viewProps: Vt.viewProps
                    })
                }
            };
            function Yu(Vt, wt) {
                return wt === 0 ? new bs : new Bl(Vt,wt ?? Ns.defaultInterval)
            }
            class Ku {
                constructor() {
                    this.pluginsMap_ = {
                        blades: [],
                        inputs: [],
                        monitors: []
                    }
                }
                getAll() {
                    return [...this.pluginsMap_.blades, ...this.pluginsMap_.inputs, ...this.pluginsMap_.monitors]
                }
                register(wt) {
                    wt.type === "blade" ? this.pluginsMap_.blades.unshift(wt) : wt.type === "input" ? this.pluginsMap_.inputs.unshift(wt) : wt.type === "monitor" && this.pluginsMap_.monitors.unshift(wt)
                }
                createInput(wt, Rt, zt) {
                    if (at(Rt.read()))
                        throw new _t({
                            context: {
                                key: Rt.key
                            },
                            type: "nomatchingcontroller"
                        });
                    const nr = this.pluginsMap_.inputs.reduce( (mr, Tr) => mr ?? function($r, vn) {
                        var zn;
                        const co = $r.accept(vn.target.read(), vn.params);
                        if (at(co))
                            return null;
                        const is = hr
                          , Ts = {
                            target: vn.target,
                            initialValue: co.initialValue,
                            params: co.params
                        }
                          , ks = $r.binding.reader(Ts)
                          , Fn = $r.binding.constraint ? $r.binding.constraint(Ts) : void 0
                          , m_ = or(ks(co.initialValue), {
                            constraint: Fn,
                            equals: $r.binding.equals
                        })
                          , fm = new Bm({
                            reader: ks,
                            target: vn.target,
                            value: m_,
                            writer: $r.binding.writer(Ts)
                        })
                          , Ds = is.optional.boolean(vn.params.disabled).value
                          , Ju = is.optional.boolean(vn.params.hidden).value
                          , Gl = $r.controller({
                            constraint: Fn,
                            document: vn.document,
                            initialValue: co.initialValue,
                            params: co.params,
                            value: fm.value,
                            viewProps: Rr.create({
                                disabled: Ds,
                                hidden: Ju
                            })
                        });
                        return new Cn(vn.document,{
                            binding: fm,
                            blade: Qr(),
                            props: ir.fromObject({
                                label: "label"in vn.params ? (zn = is.optional.string(vn.params.label).value) !== null && zn !== void 0 ? zn : null : vn.target.key
                            }),
                            valueController: Gl
                        })
                    }(Tr, {
                        document: wt,
                        target: Rt,
                        params: zt
                    }), null);
                    if (nr)
                        return nr;
                    throw new _t({
                        context: {
                            key: Rt.key
                        },
                        type: "nomatchingcontroller"
                    })
                }
                createMonitor(wt, Rt, zt) {
                    const nr = this.pluginsMap_.monitors.reduce( (mr, Tr) => mr ?? function($r, vn) {
                        var zn, co, is;
                        const Ts = hr
                          , ks = $r.accept(vn.target.read(), vn.params);
                        if (at(ks))
                            return null;
                        const Fn = {
                            target: vn.target,
                            initialValue: ks.initialValue,
                            params: ks.params
                        }
                          , m_ = $r.binding.reader(Fn)
                          , fm = (co = (zn = Ts.optional.number(vn.params.bufferSize).value) !== null && zn !== void 0 ? zn : $r.binding.defaultBufferSize && $r.binding.defaultBufferSize(ks.params)) !== null && co !== void 0 ? co : 1
                          , Ds = Ts.optional.number(vn.params.interval).value
                          , Ju = new G_({
                            reader: m_,
                            target: vn.target,
                            ticker: Yu(vn.document, Ds),
                            value: Lm(fm)
                        })
                          , Gl = Ts.optional.boolean(vn.params.disabled).value
                          , Us = Ts.optional.boolean(vn.params.hidden).value
                          , Ap = $r.controller({
                            document: vn.document,
                            params: ks.params,
                            value: Ju.value,
                            viewProps: Rr.create({
                                disabled: Gl,
                                hidden: Us
                            })
                        });
                        return new bn(vn.document,{
                            binding: Ju,
                            blade: Qr(),
                            props: ir.fromObject({
                                label: "label"in vn.params ? (is = Ts.optional.string(vn.params.label).value) !== null && is !== void 0 ? is : null : vn.target.key
                            }),
                            valueController: Ap
                        })
                    }(Tr, {
                        document: wt,
                        params: zt,
                        target: Rt
                    }), null);
                    if (nr)
                        return nr;
                    throw new _t({
                        context: {
                            key: Rt.key
                        },
                        type: "nomatchingcontroller"
                    })
                }
                createBlade(wt, Rt) {
                    const zt = this.pluginsMap_.blades.reduce( (nr, mr) => nr ?? function(Tr, $r) {
                        const vn = Tr.accept($r.params);
                        if (!vn)
                            return null;
                        const zn = hr.optional.boolean($r.params.disabled).value
                          , co = hr.optional.boolean($r.params.hidden).value;
                        return Tr.controller({
                            blade: Qr(),
                            document: $r.document,
                            params: Object.assign(Object.assign({}, vn.params), {
                                disabled: zn,
                                hidden: co
                            }),
                            viewProps: Rr.create({
                                disabled: zn,
                                hidden: co
                            })
                        })
                    }(mr, {
                        document: wt,
                        params: Rt
                    }), null);
                    if (!zt)
                        throw new _t({
                            type: "nomatchingview",
                            context: {
                                params: Rt
                            }
                        });
                    return zt
                }
                createBladeApi(wt) {
                    if (wt instanceof Cn)
                        return new wn(wt);
                    if (wt instanceof bn)
                        return new fn(wt);
                    if (wt instanceof zo)
                        return new Rn(wt,this);
                    const Rt = this.pluginsMap_.blades.reduce( (zt, nr) => zt ?? nr.api({
                        controller: wt,
                        pool: this
                    }), null);
                    if (!Rt)
                        throw _t.shouldNeverHappen();
                    return Rt
                }
            }
            function dv(Vt) {
                return ba.isObject(Vt) ? new ba(Vt.x,Vt.y) : new ba
            }
            function u_(Vt, wt) {
                Vt.writeProperty("x", wt.x),
                Vt.writeProperty("y", wt.y)
            }
            function _l(Vt, wt) {
                if (!Vt)
                    return;
                const Rt = []
                  , zt = Ws(Vt, wt);
                zt && Rt.push(zt);
                const nr = Ml(Vt);
                return nr && Rt.push(nr),
                new lu(Rt)
            }
            function pm(Vt, wt) {
                const [Rt,zt] = Vt ? function(mr) {
                    const Tr = Zs(mr, Xl);
                    if (Tr)
                        return [Tr.values.get("min"), Tr.values.get("max")];
                    const $r = Zs(mr, Gp);
                    return $r ? [$r.minValue, $r.maxValue] : [void 0, void 0]
                }(Vt) : [];
                if (!at(Rt) || !at(zt))
                    return Math.max(Math.abs(Rt ?? 0), Math.abs(zt ?? 0));
                const nr = mu(Vt);
                return Math.max(10 * Math.abs(nr), 10 * Math.abs(wt))
            }
            function hm(Vt, wt) {
                const Rt = wt instanceof Pl ? wt.components[0] : void 0
                  , zt = wt instanceof Pl ? wt.components[1] : void 0
                  , nr = pm(Rt, Vt.x)
                  , mr = pm(zt, Vt.y);
                return Math.max(nr, mr)
            }
            function Es(Vt, wt) {
                return {
                    baseStep: mu(wt),
                    constraint: wt,
                    textProps: ir.fromObject({
                        draggingScale: fu(wt, Vt),
                        formatter: ts(mp(wt, Vt))
                    })
                }
            }
            function L0(Vt) {
                if (!("y"in Vt))
                    return !1;
                const wt = Vt.y;
                return !!wt && "inverted"in wt && !!wt.inverted
            }
            const hs = {
                id: "input-point2d",
                type: "input",
                accept: (Vt, wt) => {
                    if (!ba.isObject(Vt))
                        return null;
                    const Rt = hr
                      , zt = gr(wt, {
                        expanded: Rt.optional.boolean,
                        picker: Rt.optional.custom(Q_),
                        x: Rt.optional.custom(Yl),
                        y: Rt.optional.object({
                            inverted: Rt.optional.boolean,
                            max: Rt.optional.number,
                            min: Rt.optional.number,
                            step: Rt.optional.number
                        })
                    });
                    return zt ? {
                        initialValue: Vt,
                        params: zt
                    } : null
                }
                ,
                binding: {
                    reader: Vt => dv,
                    constraint: Vt => {
                        return wt = Vt.params,
                        Rt = Vt.initialValue,
                        new Pl({
                            assembly: Fl,
                            components: [_l("x"in wt ? wt.x : void 0, Rt.x), _l("y"in wt ? wt.y : void 0, Rt.y)]
                        });
                        var wt, Rt
                    }
                    ,
                    equals: ba.equals,
                    writer: Vt => u_
                },
                controller: Vt => {
                    const wt = Vt.document
                      , Rt = Vt.value
                      , zt = Vt.constraint;
                    if (!(zt instanceof Pl))
                        throw _t.shouldNeverHappen();
                    const nr = "expanded"in Vt.params ? Vt.params.expanded : void 0
                      , mr = "picker"in Vt.params ? Vt.params.picker : void 0;
                    return new $a(wt,{
                        axes: [Es(Rt.rawValue.x, zt.components[0]), Es(Rt.rawValue.y, zt.components[1])],
                        expanded: nr != null && nr,
                        invertsY: L0(Vt.params),
                        maxValue: hm(Rt.rawValue, zt),
                        parser: Ll,
                        pickerLayout: mr ?? "popup",
                        value: Rt,
                        viewProps: Vt.viewProps
                    })
                }
            };
            class d_ extends h {
                constructor(wt) {
                    super(wt),
                    this.emitter_ = new St,
                    this.controller_.valueController.value.emitter.on("change", Rt => {
                        this.emitter_.emit("change", {
                            event: new b(this,Rt.rawValue)
                        })
                    }
                    )
                }
                get label() {
                    return this.controller_.props.get("label")
                }
                set label(wt) {
                    this.controller_.props.set("label", wt)
                }
                get options() {
                    return this.controller_.valueController.props.get("options")
                }
                set options(wt) {
                    this.controller_.valueController.props.set("options", wt)
                }
                get value() {
                    return this.controller_.valueController.value.rawValue
                }
                set value(wt) {
                    this.controller_.valueController.value.rawValue = wt
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
            }
            class p_ extends h {
                constructor(wt) {
                    super(wt),
                    this.emitter_ = new St,
                    this.controller_.valueController.value.emitter.on("change", Rt => {
                        this.emitter_.emit("change", {
                            event: new b(this,Rt.rawValue)
                        })
                    }
                    )
                }
                get label() {
                    return this.controller_.props.get("label")
                }
                set label(wt) {
                    this.controller_.props.set("label", wt)
                }
                get maxValue() {
                    return this.controller_.valueController.sliderController.props.get("maxValue")
                }
                set maxValue(wt) {
                    this.controller_.valueController.sliderController.props.set("maxValue", wt)
                }
                get minValue() {
                    return this.controller_.valueController.sliderController.props.get("minValue")
                }
                set minValue(wt) {
                    this.controller_.valueController.sliderController.props.set("minValue", wt)
                }
                get value() {
                    return this.controller_.valueController.value.rawValue
                }
                set value(wt) {
                    this.controller_.valueController.value.rawValue = wt
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
            }
            class Vl extends h {
                constructor(wt) {
                    super(wt),
                    this.emitter_ = new St,
                    this.controller_.valueController.value.emitter.on("change", Rt => {
                        this.emitter_.emit("change", {
                            event: new b(this,Rt.rawValue)
                        })
                    }
                    )
                }
                get label() {
                    return this.controller_.props.get("label")
                }
                set label(wt) {
                    this.controller_.props.set("label", wt)
                }
                get formatter() {
                    return this.controller_.valueController.props.get("formatter")
                }
                set formatter(wt) {
                    this.controller_.valueController.props.set("formatter", wt)
                }
                get value() {
                    return this.controller_.valueController.value.rawValue
                }
                set value(wt) {
                    this.controller_.valueController.value.rawValue = wt
                }
                on(wt, Rt) {
                    const zt = Rt.bind(this);
                    return this.emitter_.on(wt, nr => {
                        zt(nr.event)
                    }
                    ),
                    this
                }
            }
            const mm = {
                id: "list",
                type: "blade",
                accept(Vt) {
                    const wt = hr
                      , Rt = gr(Vt, {
                        options: wt.required.custom(Kp),
                        value: wt.required.raw,
                        view: wt.required.constant("list"),
                        label: wt.optional.string
                    });
                    return Rt ? {
                        params: Rt
                    } : null
                },
                controller(Vt) {
                    const wt = new cu(W_(Vt.params.options))
                      , Rt = or(Vt.params.value, {
                        constraint: wt
                    })
                      , zt = new uu(Vt.document,{
                        props: new ir({
                            options: wt.values.value("options")
                        }),
                        value: Rt,
                        viewProps: Vt.viewProps
                    });
                    return new Os(Vt.document,{
                        blade: Vt.blade,
                        props: ir.fromObject({
                            label: Vt.params.label
                        }),
                        valueController: zt
                    })
                },
                api(Vt) {
                    return Vt.controller instanceof Os && Vt.controller.valueController instanceof uu ? new d_(Vt.controller) : null
                }
            };
            class h_ extends Yn {
                constructor(wt, Rt) {
                    super(wt, Rt)
                }
                get element() {
                    return this.controller_.view.element
                }
                importPreset(wt) {
                    (function(Rt, zt) {
                        Rt.forEach(nr => {
                            const mr = zt[nr.target.presetKey];
                            mr !== void 0 && nr.writer(nr.target, nr.reader(mr))
                        }
                        )
                    }
                    )(this.controller_.rackController.rack.find(Cn).map(Rt => Rt.binding), wt),
                    this.refresh()
                }
                exportPreset() {
                    return this.controller_.rackController.rack.find(Cn).map(wt => wt.binding.target).reduce( (wt, Rt) => Object.assign(wt, {
                        [Rt.presetKey]: Rt.read()
                    }), {})
                }
                refresh() {
                    this.controller_.rackController.rack.find(Cn).forEach(wt => {
                        wt.binding.read()
                    }
                    ),
                    this.controller_.rackController.rack.find(bn).forEach(wt => {
                        wt.binding.read()
                    }
                    )
                }
            }
            class Gn extends Yo {
                constructor(wt, Rt) {
                    super(wt, {
                        expanded: Rt.expanded,
                        blade: Rt.blade,
                        props: Rt.props,
                        root: !0,
                        viewProps: Rt.viewProps
                    })
                }
            }
            const ms = {
                id: "slider",
                type: "blade",
                accept(Vt) {
                    const wt = hr
                      , Rt = gr(Vt, {
                        max: wt.required.number,
                        min: wt.required.number,
                        view: wt.required.constant("slider"),
                        format: wt.optional.function,
                        label: wt.optional.string,
                        value: wt.optional.number
                    });
                    return Rt ? {
                        params: Rt
                    } : null
                },
                controller(Vt) {
                    var wt, Rt;
                    const zt = (wt = Vt.params.value) !== null && wt !== void 0 ? wt : 0
                      , nr = new Xl({
                        max: Vt.params.max,
                        min: Vt.params.min
                    })
                      , mr = new $m(Vt.document,{
                        baseStep: 1,
                        parser: Ll,
                        sliderProps: new ir({
                            maxValue: nr.values.value("max"),
                            minValue: nr.values.value("min")
                        }),
                        textProps: ir.fromObject({
                            draggingScale: fu(void 0, zt),
                            formatter: (Rt = Vt.params.format) !== null && Rt !== void 0 ? Rt : S0
                        }),
                        value: or(zt, {
                            constraint: nr
                        }),
                        viewProps: Vt.viewProps
                    });
                    return new Os(Vt.document,{
                        blade: Vt.blade,
                        props: ir.fromObject({
                            label: Vt.params.label
                        }),
                        valueController: mr
                    })
                },
                api(Vt) {
                    return Vt.controller instanceof Os && Vt.controller.valueController instanceof $m ? new p_(Vt.controller) : null
                }
            }
              , nu = {
                id: "text",
                type: "blade",
                accept(Vt) {
                    const wt = hr
                      , Rt = gr(Vt, {
                        parse: wt.required.function,
                        value: wt.required.raw,
                        view: wt.required.constant("text"),
                        format: wt.optional.function,
                        label: wt.optional.string
                    });
                    return Rt ? {
                        params: Rt
                    } : null
                },
                controller(Vt) {
                    var wt;
                    const Rt = new Iu(Vt.document,{
                        parser: Vt.params.parse,
                        props: ir.fromObject({
                            formatter: (wt = Vt.params.format) !== null && wt !== void 0 ? wt : zt => String(zt)
                        }),
                        value: or(Vt.params.value),
                        viewProps: Vt.viewProps
                    });
                    return new Os(Vt.document,{
                        blade: Vt.blade,
                        props: ir.fromObject({
                            label: Vt.params.label
                        }),
                        valueController: Rt
                    })
                },
                api(Vt) {
                    return Vt.controller instanceof Os && Vt.controller.valueController instanceof Iu ? new Vl(Vt.controller) : null
                }
            };
            function Dl(Vt, wt, Rt) {
                if (Vt.querySelector(`style[data-tp-style=${wt}]`))
                    return;
                const zt = Vt.createElement("style");
                zt.dataset.tpStyle = wt,
                zt.textContent = Rt,
                Vt.head.appendChild(zt)
            }
            const O0 = new class {
                constructor(Vt) {
                    const [wt,Rt] = Vt.split("-")
                      , zt = wt.split(".");
                    this.major = parseInt(zt[0], 10),
                    this.minor = parseInt(zt[1], 10),
                    this.patch = parseInt(zt[2], 10),
                    this.prerelease = Rt ?? null
                }
                toString() {
                    const Vt = [this.major, this.minor, this.patch].join(".");
                    return this.prerelease !== null ? [Vt, this.prerelease].join("-") : Vt
                }
            }
            ("3.1.10");
            c.BladeApi = h,
            c.ButtonApi = bt,
            c.FolderApi = Yn,
            c.InputBindingApi = wn,
            c.ListApi = d_,
            c.MonitorBindingApi = fn,
            c.Pane = class extends h_ {
                constructor(Vt) {
                    var wt, Rt;
                    const zt = Vt ?? {}
                      , nr = (wt = zt.document) !== null && wt !== void 0 ? wt : hn()
                      , mr = function() {
                        const Tr = new Ku;
                        return [hs, sv, av, Xu, a_, wu, am, Au, X_, uv, Ul, c_, Ir, ss, as, Js].forEach($r => {
                            Tr.register($r)
                        }
                        ),
                        Tr
                    }();
                    super(new Gn(nr,{
                        expanded: zt.expanded,
                        blade: Qr(),
                        props: ir.fromObject({
                            title: zt.title
                        }),
                        viewProps: Rr.create()
                    }), mr),
                    this.pool_ = mr,
                    this.containerElem_ = (Rt = zt.container) !== null && Rt !== void 0 ? Rt : function(Tr) {
                        const $r = Tr.createElement("div");
                        return $r.classList.add(Et("dfw")()),
                        Tr.body && Tr.body.appendChild($r),
                        $r
                    }(nr),
                    this.containerElem_.appendChild(this.element),
                    this.doc_ = nr,
                    this.usesDefaultWrapper_ = !zt.container,
                    this.setUpDefaultPlugins_()
                }
                get document() {
                    if (!this.doc_)
                        throw _t.alreadyDisposed();
                    return this.doc_
                }
                dispose() {
                    const Vt = this.containerElem_;
                    if (!Vt)
                        throw _t.alreadyDisposed();
                    if (this.usesDefaultWrapper_) {
                        const wt = Vt.parentElement;
                        wt && wt.removeChild(Vt)
                    }
                    this.containerElem_ = null,
                    this.doc_ = null,
                    super.dispose()
                }
                registerPlugin(Vt) {
                    ("plugin"in Vt ? [Vt.plugin] : "plugins"in Vt ? Vt.plugins : []).forEach(wt => {
                        this.pool_.register(wt),
                        this.embedPluginStyle_(wt)
                    }
                    )
                }
                embedPluginStyle_(Vt) {
                    Vt.css && Dl(this.document, `plugin-${Vt.id}`, Vt.css)
                }
                setUpDefaultPlugins_() {
                    Dl(this.document, "default", '.tp-tbiv_b,.tp-coltxtv_ms,.tp-ckbv_i,.tp-rotv_b,.tp-fldv_b,.tp-mllv_i,.tp-sglv_i,.tp-grlv_g,.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw,.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;font-family:inherit;font-size:inherit;font-weight:inherit;margin:0;outline:none;padding:0}.tp-p2dv_b,.tp-btnv_b,.tp-lstv_s{background-color:var(--btn-bg);border-radius:var(--elm-br);color:var(--btn-fg);cursor:pointer;display:block;font-weight:bold;height:var(--bld-us);line-height:var(--bld-us);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.tp-p2dv_b:hover,.tp-btnv_b:hover,.tp-lstv_s:hover{background-color:var(--btn-bg-h)}.tp-p2dv_b:focus,.tp-btnv_b:focus,.tp-lstv_s:focus{background-color:var(--btn-bg-f)}.tp-p2dv_b:active,.tp-btnv_b:active,.tp-lstv_s:active{background-color:var(--btn-bg-a)}.tp-p2dv_b:disabled,.tp-btnv_b:disabled,.tp-lstv_s:disabled{opacity:.5}.tp-txtv_i,.tp-p2dpv_p,.tp-colswv_sw{background-color:var(--in-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--in-fg);font-family:inherit;height:var(--bld-us);line-height:var(--bld-us);min-width:0;width:100%}.tp-txtv_i:hover,.tp-p2dpv_p:hover,.tp-colswv_sw:hover{background-color:var(--in-bg-h)}.tp-txtv_i:focus,.tp-p2dpv_p:focus,.tp-colswv_sw:focus{background-color:var(--in-bg-f)}.tp-txtv_i:active,.tp-p2dpv_p:active,.tp-colswv_sw:active{background-color:var(--in-bg-a)}.tp-txtv_i:disabled,.tp-p2dpv_p:disabled,.tp-colswv_sw:disabled{opacity:.5}.tp-mllv_i,.tp-sglv_i,.tp-grlv_g{background-color:var(--mo-bg);border-radius:var(--elm-br);box-sizing:border-box;color:var(--mo-fg);height:var(--bld-us);scrollbar-color:currentColor rgba(0,0,0,0);scrollbar-width:thin;width:100%}.tp-mllv_i::-webkit-scrollbar,.tp-sglv_i::-webkit-scrollbar,.tp-grlv_g::-webkit-scrollbar{height:8px;width:8px}.tp-mllv_i::-webkit-scrollbar-corner,.tp-sglv_i::-webkit-scrollbar-corner,.tp-grlv_g::-webkit-scrollbar-corner{background-color:rgba(0,0,0,0)}.tp-mllv_i::-webkit-scrollbar-thumb,.tp-sglv_i::-webkit-scrollbar-thumb,.tp-grlv_g::-webkit-scrollbar-thumb{background-clip:padding-box;background-color:currentColor;border:rgba(0,0,0,0) solid 2px;border-radius:4px}.tp-rotv{--font-family: var(--tp-font-family, Roboto Mono, Source Code Pro, Menlo, Courier, monospace);--bs-br: var(--tp-base-border-radius, 6px);--cnt-h-p: var(--tp-container-horizontal-padding, 4px);--cnt-v-p: var(--tp-container-vertical-padding, 4px);--elm-br: var(--tp-element-border-radius, 2px);--bld-s: var(--tp-blade-spacing, 4px);--bld-us: var(--tp-blade-unit-size, 20px);--bs-bg: var(--tp-base-background-color, hsl(230, 7%, 17%));--bs-sh: var(--tp-base-shadow-color, rgba(0, 0, 0, 0.2));--btn-bg: var(--tp-button-background-color, hsl(230, 7%, 70%));--btn-bg-a: var(--tp-button-background-color-active, #d6d7db);--btn-bg-f: var(--tp-button-background-color-focus, #c8cad0);--btn-bg-h: var(--tp-button-background-color-hover, #bbbcc4);--btn-fg: var(--tp-button-foreground-color, hsl(230, 7%, 17%));--cnt-bg: var(--tp-container-background-color, rgba(187, 188, 196, 0.1));--cnt-bg-a: var(--tp-container-background-color-active, rgba(187, 188, 196, 0.25));--cnt-bg-f: var(--tp-container-background-color-focus, rgba(187, 188, 196, 0.2));--cnt-bg-h: var(--tp-container-background-color-hover, rgba(187, 188, 196, 0.15));--cnt-fg: var(--tp-container-foreground-color, hsl(230, 7%, 75%));--in-bg: var(--tp-input-background-color, rgba(187, 188, 196, 0.1));--in-bg-a: var(--tp-input-background-color-active, rgba(187, 188, 196, 0.25));--in-bg-f: var(--tp-input-background-color-focus, rgba(187, 188, 196, 0.2));--in-bg-h: var(--tp-input-background-color-hover, rgba(187, 188, 196, 0.15));--in-fg: var(--tp-input-foreground-color, hsl(230, 7%, 75%));--lbl-fg: var(--tp-label-foreground-color, rgba(187, 188, 196, 0.7));--mo-bg: var(--tp-monitor-background-color, rgba(0, 0, 0, 0.2));--mo-fg: var(--tp-monitor-foreground-color, rgba(187, 188, 196, 0.7));--grv-fg: var(--tp-groove-foreground-color, rgba(187, 188, 196, 0.1))}.tp-rotv_c>.tp-cntv.tp-v-lst,.tp-tabv_c .tp-brkv>.tp-cntv.tp-v-lst,.tp-fldv_c>.tp-cntv.tp-v-lst{margin-bottom:calc(-1*var(--cnt-v-p))}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_c,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_c{border-bottom-left-radius:0}.tp-rotv_c>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-tabv_c .tp-brkv>.tp-fldv.tp-v-lst .tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-v-lst .tp-fldv_b{border-bottom-left-radius:0}.tp-rotv_c>*:not(.tp-v-fst),.tp-tabv_c .tp-brkv>*:not(.tp-v-fst),.tp-fldv_c>*:not(.tp-v-fst){margin-top:var(--bld-s)}.tp-rotv_c>.tp-sprv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-fst),.tp-fldv_c>.tp-sprv:not(.tp-v-fst),.tp-rotv_c>.tp-cntv:not(.tp-v-fst),.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-fst),.tp-fldv_c>.tp-cntv:not(.tp-v-fst){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-sprv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-sprv+*:not(.tp-v-hidden),.tp-rotv_c>.tp-cntv+*:not(.tp-v-hidden),.tp-tabv_c .tp-brkv>.tp-cntv+*:not(.tp-v-hidden),.tp-fldv_c>.tp-cntv+*:not(.tp-v-hidden){margin-top:var(--cnt-v-p)}.tp-rotv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-tabv_c .tp-brkv>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-fldv_c>.tp-sprv:not(.tp-v-hidden)+.tp-sprv,.tp-rotv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-tabv_c .tp-brkv>.tp-cntv:not(.tp-v-hidden)+.tp-cntv,.tp-fldv_c>.tp-cntv:not(.tp-v-hidden)+.tp-cntv{margin-top:0}.tp-tabv_c .tp-brkv>.tp-cntv,.tp-fldv_c>.tp-cntv{margin-left:4px}.tp-tabv_c .tp-brkv>.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-fldv>.tp-fldv_b{border-top-left-radius:var(--elm-br);border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-fldv.tp-fldv-expanded>.tp-fldv_b,.tp-fldv_c>.tp-fldv.tp-fldv-expanded>.tp-fldv_b{border-bottom-left-radius:0}.tp-tabv_c .tp-brkv .tp-fldv>.tp-fldv_c,.tp-fldv_c .tp-fldv>.tp-fldv_c{border-bottom-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-fldv>.tp-fldv_b,.tp-fldv_c>.tp-cntv+.tp-fldv>.tp-fldv_b{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-cntv+.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-cntv+.tp-tabv>.tp-tabv_t{border-top-left-radius:0}.tp-tabv_c .tp-brkv>.tp-tabv>.tp-tabv_t,.tp-fldv_c>.tp-tabv>.tp-tabv_t{border-top-left-radius:var(--elm-br)}.tp-tabv_c .tp-brkv .tp-tabv>.tp-tabv_c,.tp-fldv_c .tp-tabv>.tp-tabv_c{border-bottom-left-radius:var(--elm-br)}.tp-rotv_b,.tp-fldv_b{background-color:var(--cnt-bg);color:var(--cnt-fg);cursor:pointer;display:block;height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);overflow:hidden;padding-left:var(--cnt-h-p);padding-right:calc(4px + var(--bld-us) + var(--cnt-h-p));position:relative;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:100%;transition:border-radius .2s ease-in-out .2s}.tp-rotv_b:hover,.tp-fldv_b:hover{background-color:var(--cnt-bg-h)}.tp-rotv_b:focus,.tp-fldv_b:focus{background-color:var(--cnt-bg-f)}.tp-rotv_b:active,.tp-fldv_b:active{background-color:var(--cnt-bg-a)}.tp-rotv_b:disabled,.tp-fldv_b:disabled{opacity:.5}.tp-rotv_m,.tp-fldv_m{background:linear-gradient(to left, var(--cnt-fg), var(--cnt-fg) 2px, transparent 2px, transparent 4px, var(--cnt-fg) 4px);border-radius:2px;bottom:0;content:"";display:block;height:6px;right:calc(var(--cnt-h-p) + (var(--bld-us) + 4px - 6px)/2 - 2px);margin:auto;opacity:.5;position:absolute;top:0;transform:rotate(90deg);transition:transform .2s ease-in-out;width:6px}.tp-rotv.tp-rotv-expanded .tp-rotv_m,.tp-fldv.tp-fldv-expanded>.tp-fldv_b>.tp-fldv_m{transform:none}.tp-rotv_c,.tp-fldv_c{box-sizing:border-box;height:0;opacity:0;overflow:hidden;padding-bottom:0;padding-top:0;position:relative;transition:height .2s ease-in-out,opacity .2s linear,padding .2s ease-in-out}.tp-rotv.tp-rotv-cpl:not(.tp-rotv-expanded) .tp-rotv_c,.tp-fldv.tp-fldv-cpl:not(.tp-fldv-expanded)>.tp-fldv_c{display:none}.tp-rotv.tp-rotv-expanded .tp-rotv_c,.tp-fldv.tp-fldv-expanded>.tp-fldv_c{opacity:1;padding-bottom:var(--cnt-v-p);padding-top:var(--cnt-v-p);transform:none;overflow:visible;transition:height .2s ease-in-out,opacity .2s linear .2s,padding .2s ease-in-out}.tp-lstv,.tp-coltxtv_m{position:relative}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m,.tp-coltxtv_mm{bottom:0;margin:auto;pointer-events:none;position:absolute;right:2px;top:0}.tp-lstv_m svg,.tp-coltxtv_mm svg{bottom:0;height:16px;margin:auto;position:absolute;right:0;top:0;width:16px}.tp-lstv_m svg path,.tp-coltxtv_mm svg path{fill:currentColor}.tp-pndtxtv,.tp-coltxtv_w{display:flex}.tp-pndtxtv_a,.tp-coltxtv_c{width:100%}.tp-pndtxtv_a+.tp-pndtxtv_a,.tp-coltxtv_c+.tp-pndtxtv_a,.tp-pndtxtv_a+.tp-coltxtv_c,.tp-coltxtv_c+.tp-coltxtv_c{margin-left:2px}.tp-btnv_b{width:100%}.tp-btnv_t{text-align:center}.tp-ckbv_l{display:block;position:relative}.tp-ckbv_i{left:0;opacity:0;position:absolute;top:0}.tp-ckbv_w{background-color:var(--in-bg);border-radius:var(--elm-br);cursor:pointer;display:block;height:var(--bld-us);position:relative;width:var(--bld-us)}.tp-ckbv_w svg{bottom:0;display:block;height:16px;left:0;margin:auto;opacity:0;position:absolute;right:0;top:0;width:16px}.tp-ckbv_w svg path{fill:none;stroke:var(--in-fg);stroke-width:2}.tp-ckbv_i:hover+.tp-ckbv_w{background-color:var(--in-bg-h)}.tp-ckbv_i:focus+.tp-ckbv_w{background-color:var(--in-bg-f)}.tp-ckbv_i:active+.tp-ckbv_w{background-color:var(--in-bg-a)}.tp-ckbv_i:checked+.tp-ckbv_w svg{opacity:1}.tp-ckbv.tp-v-disabled .tp-ckbv_w{opacity:.5}.tp-colv{position:relative}.tp-colv_h{display:flex}.tp-colv_s{flex-grow:0;flex-shrink:0;width:var(--bld-us)}.tp-colv_t{flex:1;margin-left:4px}.tp-colv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-colv.tp-colv-expanded.tp-colv-cpl .tp-colv_p{overflow:visible}.tp-colv.tp-colv-expanded .tp-colv_p{margin-top:var(--bld-s);opacity:1}.tp-colv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-colpv_h,.tp-colpv_ap{margin-left:6px;margin-right:6px}.tp-colpv_h{margin-top:var(--bld-s)}.tp-colpv_rgb{display:flex;margin-top:var(--bld-s);width:100%}.tp-colpv_a{display:flex;margin-top:var(--cnt-v-p);padding-top:calc(var(--cnt-v-p) + 2px);position:relative}.tp-colpv_a::before{background-color:var(--grv-fg);content:"";height:2px;left:calc(-1*var(--cnt-h-p));position:absolute;right:calc(-1*var(--cnt-h-p));top:0}.tp-colpv.tp-v-disabled .tp-colpv_a::before{opacity:.5}.tp-colpv_ap{align-items:center;display:flex;flex:3}.tp-colpv_at{flex:1;margin-left:4px}.tp-svpv{border-radius:var(--elm-br);outline:none;overflow:hidden;position:relative}.tp-svpv.tp-v-disabled{opacity:.5}.tp-svpv_c{cursor:crosshair;display:block;height:calc(var(--bld-us)*4);width:100%}.tp-svpv_m{border-radius:100%;border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;filter:drop-shadow(0 0 1px rgba(0, 0, 0, 0.3));height:12px;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;width:12px}.tp-svpv:focus .tp-svpv_m{border-color:#fff}.tp-hplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative}.tp-hplv.tp-v-disabled{opacity:.5}.tp-hplv_c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAABCAYAAABubagXAAAAQ0lEQVQoU2P8z8Dwn0GCgQEDi2OK/RBgYHjBgIpfovFh8j8YBIgzFGQxuqEgPhaDOT5gOhPkdCxOZeBg+IDFZZiGAgCaSSMYtcRHLgAAAABJRU5ErkJggg==);background-position:left top;background-repeat:no-repeat;background-size:100% 100%;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;position:absolute;top:50%;width:100%}.tp-hplv_m{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-shadow:0 0 2px rgba(0,0,0,.1);box-sizing:border-box;height:12px;left:50%;margin-left:-6px;margin-top:-6px;pointer-events:none;position:absolute;top:50%;width:12px}.tp-hplv:focus .tp-hplv_m{border-color:#fff}.tp-aplv{cursor:pointer;height:var(--bld-us);outline:none;position:relative;width:100%}.tp-aplv.tp-v-disabled{opacity:.5}.tp-aplv_b{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:4px 4px;background-position:0 0,2px 2px;border-radius:2px;display:block;height:4px;left:0;margin-top:-2px;overflow:hidden;position:absolute;top:50%;width:100%}.tp-aplv_c{bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv_m{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:12px 12px;background-position:0 0,6px 6px;border-radius:var(--elm-br);box-shadow:0 0 2px rgba(0,0,0,.1);height:12px;left:50%;margin-left:-6px;margin-top:-6px;overflow:hidden;pointer-events:none;position:absolute;top:50%;width:12px}.tp-aplv_p{border-radius:var(--elm-br);border:rgba(255,255,255,.75) solid 2px;box-sizing:border-box;bottom:0;left:0;position:absolute;right:0;top:0}.tp-aplv:focus .tp-aplv_p{border-color:#fff}.tp-colswv{background-color:#fff;background-image:linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%),linear-gradient(to top right, #ddd 25%, transparent 25%, transparent 75%, #ddd 75%);background-size:10px 10px;background-position:0 0,5px 5px;border-radius:var(--elm-br);overflow:hidden}.tp-colswv.tp-v-disabled{opacity:.5}.tp-colswv_sw{border-radius:0}.tp-colswv_b{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:rgba(0,0,0,0);border-width:0;cursor:pointer;display:block;height:var(--bld-us);left:0;margin:0;outline:none;padding:0;position:absolute;top:0;width:var(--bld-us)}.tp-colswv_b:focus::after{border:rgba(255,255,255,.75) solid 2px;border-radius:var(--elm-br);bottom:0;content:"";display:block;left:0;position:absolute;right:0;top:0}.tp-coltxtv{display:flex;width:100%}.tp-coltxtv_m{margin-right:4px}.tp-coltxtv_ms{border-radius:var(--elm-br);color:var(--lbl-fg);cursor:pointer;height:var(--bld-us);line-height:var(--bld-us);padding:0 18px 0 4px}.tp-coltxtv_ms:hover{background-color:var(--in-bg-h)}.tp-coltxtv_ms:focus{background-color:var(--in-bg-f)}.tp-coltxtv_ms:active{background-color:var(--in-bg-a)}.tp-coltxtv_mm{color:var(--lbl-fg)}.tp-coltxtv.tp-v-disabled .tp-coltxtv_mm{opacity:.5}.tp-coltxtv_w{flex:1}.tp-dfwv{position:absolute;top:8px;right:8px;width:256px}.tp-fldv{position:relative}.tp-fldv.tp-fldv-not .tp-fldv_b{display:none}.tp-fldv_t{padding-left:4px}.tp-fldv_b:disabled .tp-fldv_m{display:none}.tp-fldv_c{padding-left:4px}.tp-fldv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-fldv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-fldv_b:hover+.tp-fldv_i{color:var(--cnt-bg-h)}.tp-fldv_b:focus+.tp-fldv_i{color:var(--cnt-bg-f)}.tp-fldv_b:active+.tp-fldv_i{color:var(--cnt-bg-a)}.tp-fldv.tp-v-disabled>.tp-fldv_i{opacity:.5}.tp-grlv{position:relative}.tp-grlv_g{display:block;height:calc(var(--bld-us)*3)}.tp-grlv_g polyline{fill:none;stroke:var(--mo-fg);stroke-linejoin:round}.tp-grlv_t{margin-top:-4px;transition:left .05s,top .05s;visibility:hidden}.tp-grlv_t.tp-grlv_t-a{visibility:visible}.tp-grlv_t.tp-grlv_t-in{transition:none}.tp-grlv.tp-v-disabled .tp-grlv_g{opacity:.5}.tp-grlv .tp-ttv{background-color:var(--mo-fg)}.tp-grlv .tp-ttv::before{border-top-color:var(--mo-fg)}.tp-lblv{align-items:center;display:flex;line-height:1.3;padding-left:var(--cnt-h-p);padding-right:var(--cnt-h-p)}.tp-lblv.tp-lblv-nol{display:block}.tp-lblv_l{color:var(--lbl-fg);flex:1;-webkit-hyphens:auto;hyphens:auto;overflow:hidden;padding-left:4px;padding-right:16px}.tp-lblv.tp-v-disabled .tp-lblv_l{opacity:.5}.tp-lblv.tp-lblv-nol .tp-lblv_l{display:none}.tp-lblv_v{align-self:flex-start;flex-grow:0;flex-shrink:0;width:160px}.tp-lblv.tp-lblv-nol .tp-lblv_v{width:100%}.tp-lstv_s{padding:0 20px 0 4px;width:100%}.tp-lstv_m{color:var(--btn-fg)}.tp-sglv_i{padding:0 4px}.tp-sglv.tp-v-disabled .tp-sglv_i{opacity:.5}.tp-mllv_i{display:block;height:calc(var(--bld-us)*3);line-height:var(--bld-us);padding:0 4px;resize:none;white-space:pre}.tp-mllv.tp-v-disabled .tp-mllv_i{opacity:.5}.tp-p2dv{position:relative}.tp-p2dv_h{display:flex}.tp-p2dv_b{height:var(--bld-us);margin-right:4px;position:relative;width:var(--bld-us)}.tp-p2dv_b svg{display:block;height:16px;left:50%;margin-left:-8px;margin-top:-8px;position:absolute;top:50%;width:16px}.tp-p2dv_b svg path{stroke:currentColor;stroke-width:2}.tp-p2dv_b svg circle{fill:currentColor}.tp-p2dv_t{flex:1}.tp-p2dv_p{height:0;margin-top:0;opacity:0;overflow:hidden;transition:height .2s ease-in-out,opacity .2s linear,margin .2s ease-in-out}.tp-p2dv.tp-p2dv-expanded .tp-p2dv_p{margin-top:var(--bld-s);opacity:1}.tp-p2dv .tp-popv{left:calc(-1*var(--cnt-h-p));right:calc(-1*var(--cnt-h-p));top:var(--bld-us)}.tp-p2dpv{padding-left:calc(var(--bld-us) + 4px)}.tp-p2dpv_p{cursor:crosshair;height:0;overflow:hidden;padding-bottom:100%;position:relative}.tp-p2dpv.tp-v-disabled .tp-p2dpv_p{opacity:.5}.tp-p2dpv_g{display:block;height:100%;left:0;pointer-events:none;position:absolute;top:0;width:100%}.tp-p2dpv_ax{opacity:.1;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_l{opacity:.5;stroke:var(--in-fg);stroke-dasharray:1}.tp-p2dpv_m{border:var(--in-fg) solid 1px;border-radius:50%;box-sizing:border-box;height:4px;margin-left:-2px;margin-top:-2px;position:absolute;width:4px}.tp-p2dpv_p:focus .tp-p2dpv_m{background-color:var(--in-fg);border-width:0}.tp-popv{background-color:var(--bs-bg);border-radius:6px;box-shadow:0 2px 4px var(--bs-sh);display:none;max-width:168px;padding:var(--cnt-v-p) var(--cnt-h-p);position:absolute;visibility:hidden;z-index:1000}.tp-popv.tp-popv-v{display:block;visibility:visible}.tp-sprv_r{background-color:var(--grv-fg);border-width:0;display:block;height:2px;margin:0;width:100%}.tp-sprv.tp-v-disabled .tp-sprv_r{opacity:.5}.tp-sldv.tp-v-disabled{opacity:.5}.tp-sldv_t{box-sizing:border-box;cursor:pointer;height:var(--bld-us);margin:0 6px;outline:none;position:relative}.tp-sldv_t::before{background-color:var(--in-bg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin:auto;position:absolute;right:0;top:0}.tp-sldv_k{height:100%;left:0;position:absolute;top:0}.tp-sldv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";display:block;height:2px;left:0;margin-bottom:auto;margin-top:auto;position:absolute;right:0;top:0}.tp-sldv_k::after{background-color:var(--btn-bg);border-radius:var(--elm-br);bottom:0;content:"";display:block;height:12px;margin-bottom:auto;margin-top:auto;position:absolute;right:-6px;top:0;width:12px}.tp-sldv_t:hover .tp-sldv_k::after{background-color:var(--btn-bg-h)}.tp-sldv_t:focus .tp-sldv_k::after{background-color:var(--btn-bg-f)}.tp-sldv_t:active .tp-sldv_k::after{background-color:var(--btn-bg-a)}.tp-sldtxtv{display:flex}.tp-sldtxtv_s{flex:2}.tp-sldtxtv_t{flex:1;margin-left:4px}.tp-tabv{position:relative}.tp-tabv_t{align-items:flex-end;color:var(--cnt-bg);display:flex;overflow:hidden;position:relative}.tp-tabv_t:hover{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus){color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active){color:var(--cnt-bg-a)}.tp-tabv_t::before{background-color:currentColor;bottom:0;content:"";height:2px;left:0;pointer-events:none;position:absolute;right:0}.tp-tabv.tp-v-disabled .tp-tabv_t::before{opacity:.5}.tp-tabv.tp-tabv-nop .tp-tabv_t{height:calc(var(--bld-us) + 4px);position:relative}.tp-tabv.tp-tabv-nop .tp-tabv_t::before{background-color:var(--cnt-bg);bottom:0;content:"";height:2px;left:0;position:absolute;right:0}.tp-tabv_c{padding-bottom:var(--cnt-v-p);padding-left:4px;padding-top:var(--cnt-v-p)}.tp-tabv_i{bottom:0;color:var(--cnt-bg);left:0;overflow:hidden;position:absolute;top:calc(var(--bld-us) + 4px);width:var(--bs-br)}.tp-tabv_i::before{background-color:currentColor;bottom:0;content:"";left:0;position:absolute;top:0;width:4px}.tp-tabv_t:hover+.tp-tabv_i{color:var(--cnt-bg-h)}.tp-tabv_t:has(*:focus)+.tp-tabv_i{color:var(--cnt-bg-f)}.tp-tabv_t:has(*:active)+.tp-tabv_i{color:var(--cnt-bg-a)}.tp-tabv.tp-v-disabled>.tp-tabv_i{opacity:.5}.tp-tbiv{flex:1;min-width:0;position:relative}.tp-tbiv+.tp-tbiv{margin-left:2px}.tp-tbiv+.tp-tbiv.tp-v-disabled::before{opacity:.5}.tp-tbiv_b{display:block;padding-left:calc(var(--cnt-h-p) + 4px);padding-right:calc(var(--cnt-h-p) + 4px);position:relative;width:100%}.tp-tbiv_b:disabled{opacity:.5}.tp-tbiv_b::before{background-color:var(--cnt-bg);bottom:2px;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.tp-tbiv_b:hover::before{background-color:var(--cnt-bg-h)}.tp-tbiv_b:focus::before{background-color:var(--cnt-bg-f)}.tp-tbiv_b:active::before{background-color:var(--cnt-bg-a)}.tp-tbiv_t{color:var(--cnt-fg);height:calc(var(--bld-us) + 4px);line-height:calc(var(--bld-us) + 4px);opacity:.5;overflow:hidden;text-overflow:ellipsis}.tp-tbiv.tp-tbiv-sel .tp-tbiv_t{opacity:1}.tp-txtv{position:relative}.tp-txtv_i{padding:0 4px}.tp-txtv.tp-txtv-fst .tp-txtv_i{border-bottom-right-radius:0;border-top-right-radius:0}.tp-txtv.tp-txtv-mid .tp-txtv_i{border-radius:0}.tp-txtv.tp-txtv-lst .tp-txtv_i{border-bottom-left-radius:0;border-top-left-radius:0}.tp-txtv.tp-txtv-num .tp-txtv_i{text-align:right}.tp-txtv.tp-txtv-drg .tp-txtv_i{opacity:.3}.tp-txtv_k{cursor:pointer;height:100%;left:-3px;position:absolute;top:0;width:12px}.tp-txtv_k::before{background-color:var(--in-fg);border-radius:1px;bottom:0;content:"";height:calc(var(--bld-us) - 4px);left:50%;margin-bottom:auto;margin-left:-1px;margin-top:auto;opacity:.1;position:absolute;top:0;transition:border-radius .1s,height .1s,transform .1s,width .1s;width:2px}.tp-txtv_k:hover::before,.tp-txtv.tp-txtv-drg .tp-txtv_k::before{opacity:1}.tp-txtv.tp-txtv-drg .tp-txtv_k::before{border-radius:50%;height:4px;transform:translateX(-1px);width:4px}.tp-txtv_g{bottom:0;display:block;height:8px;left:50%;margin:auto;overflow:visible;pointer-events:none;position:absolute;top:0;visibility:hidden;width:100%}.tp-txtv.tp-txtv-drg .tp-txtv_g{visibility:visible}.tp-txtv_gb{fill:none;stroke:var(--in-fg);stroke-dasharray:1}.tp-txtv_gh{fill:none;stroke:var(--in-fg)}.tp-txtv .tp-ttv{margin-left:6px;visibility:hidden}.tp-txtv.tp-txtv-drg .tp-ttv{visibility:visible}.tp-ttv{background-color:var(--in-fg);border-radius:var(--elm-br);color:var(--bs-bg);padding:2px 4px;pointer-events:none;position:absolute;transform:translate(-50%, -100%)}.tp-ttv::before{border-color:var(--in-fg) rgba(0,0,0,0) rgba(0,0,0,0) rgba(0,0,0,0);border-style:solid;border-width:2px;box-sizing:border-box;content:"";font-size:.9em;height:4px;left:50%;margin-left:-2px;position:absolute;top:100%;width:4px}.tp-rotv{background-color:var(--bs-bg);border-radius:var(--bs-br);box-shadow:0 2px 4px var(--bs-sh);font-family:var(--font-family);font-size:11px;font-weight:500;line-height:1;text-align:left}.tp-rotv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br);border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br);padding-left:calc(4px + var(--bld-us) + var(--cnt-h-p));text-align:center}.tp-rotv.tp-rotv-expanded .tp-rotv_b{border-bottom-left-radius:0;border-bottom-right-radius:0}.tp-rotv.tp-rotv-not .tp-rotv_b{display:none}.tp-rotv_b:disabled .tp-rotv_m{display:none}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst>.tp-fldv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv_c>.tp-fldv.tp-v-lst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c .tp-fldv.tp-v-vlst:not(.tp-fldv-expanded)>.tp-fldv_b{border-bottom-right-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-fldv.tp-v-fst>.tp-fldv_b{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_c{border-bottom-left-radius:var(--bs-br);border-bottom-right-radius:var(--bs-br)}.tp-rotv_c>.tp-tabv.tp-v-lst>.tp-tabv_i{border-bottom-left-radius:var(--bs-br)}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst{margin-top:calc(-1*var(--cnt-v-p))}.tp-rotv.tp-rotv-not .tp-rotv_c>.tp-tabv.tp-v-fst>.tp-tabv_t{border-top-left-radius:var(--bs-br);border-top-right-radius:var(--bs-br)}.tp-rotv.tp-v-disabled,.tp-rotv .tp-v-disabled{pointer-events:none}.tp-rotv.tp-v-hidden,.tp-rotv .tp-v-hidden{display:none}'),
                    this.pool_.getAll().forEach(Vt => {
                        this.embedPluginStyle_(Vt)
                    }
                    ),
                    this.registerPlugin({
                        plugins: [ms, mm, Js, nu]
                    })
                }
            }
            ,
            c.SeparatorApi = $l,
            c.SliderApi = p_,
            c.TabApi = Ks,
            c.TabPageApi = Sl,
            c.TextApi = Vl,
            c.TpChangeEvent = b,
            c.VERSION = O0,
            Object.defineProperty(c, "__esModule", {
                value: !0
            })
        }
        )(o)
    },
    161: function(d) {
        d.exports = function(o, c, h) {
            return o.length === 0 ? o : c ? (h || o.sort(c),
            function(_, b) {
                for (var _e = 1, nt = _.length, it = _[0], at = _[0], ut = 1; ut < nt; ++ut)
                    if (at = it,
                    b(it = _[ut], at)) {
                        if (ut === _e) {
                            _e++;
                            continue
                        }
                        _[_e++] = it
                    }
                return _.length = _e,
                _
            }(o, c)) : (h || o.sort(),
            function(_) {
                for (var b = 1, _e = _.length, nt = _[0], it = _[0], at = 1; at < _e; ++at,
                it = nt)
                    if (it = nt,
                    (nt = _[at]) !== it) {
                        if (at === b) {
                            b++;
                            continue
                        }
                        _[b++] = nt
                    }
                return _.length = b,
                _
            }(o))
        }
    },
    957: function(__unused_webpack_module, __webpackgi_exports__, __webpackgi_require__) {
        __webpackgi_require__.d(__webpackgi_exports__, {
            Z: function() {
                return DRACOLoader2
            }
        });
        var three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpackgi_require__(149)
          , three__WEBPACK_IMPORTED_MODULE_1__ = __webpackgi_require__(848);
        class DRACOLoader2 extends three_examples_jsm_loaders_DRACOLoader__WEBPACK_IMPORTED_MODULE_0__.Z {
            constructor(d) {
                super(d),
                this.encoderPending = null,
                this.encoderConfig = {
                    type: "js"
                },
                this.isDRACOLoader2 = !0,
                this.setDecoderPath(DRACOLoader2.LIB_CDN_PATH),
                this.setDecoderConfig({
                    type: "js"
                })
            }
            transform(d, o) {
                return d ? new three__WEBPACK_IMPORTED_MODULE_1__.eaF(d,new three__WEBPACK_IMPORTED_MODULE_1__._4j) : void 0
            }
            preload(d=!0, o=!1) {
                return d && super.preload(),
                o && this.initEncoder(),
                this
            }
            async initEncoder() {
                if (this.encoderPending)
                    return this.encoderPending;
                const useJS = typeof WebAssembly != "object" || this.encoderConfig.type === "js"
                  , librariesPending = []
                  , libLoader = this._loadLibrary.bind(this);
                return useJS ? librariesPending.push(libLoader("draco_encoder.js", "text")) : (librariesPending.push(libLoader("draco_wasm_wrapper.js", "text")),
                librariesPending.push(libLoader("draco_encoder.wasm", "arraybuffer"))),
                this.encoderPending = Promise.all(librariesPending).then(libraries => {
                    var _a;
                    const jsContent = libraries[0];
                    return useJS || (this.encoderConfig.wasmBinary = libraries[1]),
                    (_a = eval(jsContent + `
DracoEncoderModule;`)) === null || _a === void 0 ? void 0 : _a()
                }
                ),
                this.encoderPending
            }
            async initDecoder() {
                var _a;
                await this._initDecoder();
                const jsContent = await fetch(this.workerSourceURL).then(async d => d.text()).then(d => {
                    const o = d.indexOf("/* worker */");
                    if (o < 1)
                        throw new Error("unable to load decoder module");
                    return d.substring(0, o - 1)
                }
                );
                return (_a = eval(jsContent + `
DracoDecoderModule;`)) === null || _a === void 0 ? void 0 : _a()
            }
            async _loadLibrary(d, o) {
                return DRACOLoader2.LibraryValueMap[d] ? DRACOLoader2.LibraryValueMap[d] : DRACOLoader2.LibraryValueMap[d] = await super._loadLibrary(d, o)
            }
            static SetDecoderJsString(d) {
                this.LibraryValueMap["draco_decoder.js"] = d
            }
        }
        DRACOLoader2.LIB_CDN_PATH = "https://cdn.jsdelivr.net/gh/google/draco@1.4.1/javascript/",
        DRACOLoader2.LibraryValueMap = {}
    },
    848: function(d, o, c) {
        c.d(o, {
            $EB: function() {
                return St
            },
            $Kf: function() {
                return K0
            },
            $NF: function() {
                return O_
            },
            $O9: function() {
                return Xn
            },
            $_I: function() {
                return vo
            },
            $ei: function() {
                return Jt
            },
            $p8: function() {
                return kA
            },
            A$4: function() {
                return co
            },
            AKb: function() {
                return AS
            },
            ALV: function() {
                return k0
            },
            AT1: function() {
                return o_
            },
            Am1: function() {
                return OS
            },
            B69: function() {
                return Mo
            },
            B6O: function() {
                return Xx
            },
            BH$: function() {
                return Z0
            },
            BKk: function() {
                return zl
            },
            BND: function() {
                return fE
            },
            BRH: function() {
                return PS
            },
            BXX: function() {
                return Bl
            },
            B_h: function() {
                return cu
            },
            BdL: function() {
                return V0
            },
            CMB: function() {
                return Vn
            },
            CR7: function() {
                return Q_
            },
            CSG: function() {
                return H0
            },
            CV9: function() {
                return ly
            },
            CVz: function() {
                return G_
            },
            CWW: function() {
                return ap
            },
            Cfg: function() {
                return En
            },
            CmU: function() {
                return OA
            },
            CwR: function() {
                return GS
            },
            D$Q: function() {
                return dA
            },
            DAe: function() {
                return Xp
            },
            DAr: function() {
                return ps
            },
            DXC: function() {
                return iu
            },
            Df: function() {
                return mA
            },
            E0M: function() {
                return _E
            },
            EAD: function() {
                return Lv
            },
            EQC: function() {
                return $p
            },
            EZo: function() {
                return It
            },
            EdD: function() {
                return Gt
            },
            F1T: function() {
                return Gy
            },
            F1l: function() {
                return aE
            },
            FCc: function() {
                return Hx
            },
            FFZ: function() {
                return Y_
            },
            FNr: function() {
                return _A
            },
            FV: function() {
                return pr
            },
            FXf: function() {
                return Ut
            },
            FZo: function() {
                return LA
            },
            Fn: function() {
                return sp
            },
            Fpm: function() {
                return oE
            },
            FvD: function() {
                return jv
            },
            Fvt: function() {
                return vA
            },
            G3T: function() {
                return ku
            },
            GBG: function() {
                return wA
            },
            GJx: function() {
                return Tn
            },
            GOR: function() {
                return dS
            },
            GTy: function() {
                return At
            },
            GWd: function() {
                return as
            },
            GYF: function() {
                return Pm
            },
            GZZ: function() {
                return sy
            },
            G_z: function() {
                return gA
            },
            Gu$: function() {
                return I_
            },
            Gwm: function() {
                return rn
            },
            GxU: function() {
                return Rt
            },
            H23: function() {
                return jm
            },
            HLH: function() {
                return Wm
            },
            HO_: function() {
                return zm
            },
            HPb: function() {
                return $m
            },
            HXV: function() {
                return Lm
            },
            HgN: function() {
                return e_
            },
            HiM: function() {
                return RA
            },
            Hit: function() {
                return D_
            },
            Ho_: function() {
                return Im
            },
            Hrb: function() {
                return zn
            },
            Hrq: function() {
                return J_
            },
            I46: function() {
                return Bx
            },
            I9Y: function() {
                return mn
            },
            IE4: function() {
                return xs
            },
            IUQ: function() {
                return Lo
            },
            IWo: function() {
                return mE
            },
            Ipv: function() {
                return Hl
            },
            Iw4: function() {
                return XS
            },
            IzY: function() {
                return vE
            },
            JeP: function() {
                return xx
            },
            Jnc: function() {
                return it
            },
            K52: function() {
                return hn
            },
            KDk: function() {
                return Zs
            },
            KLL: function() {
                return Vo
            },
            KPJ: function() {
                return vy
            },
            KRh: function() {
                return qn
            },
            Ke9: function() {
                return Hm
            },
            Kef: function() {
                return z_
            },
            Ktl: function() {
                return K_
            },
            Kwu: function() {
                return Dt
            },
            Kzg: function() {
                return LS
            },
            Kzv: function() {
                return Ln
            },
            Ld9: function() {
                return yE
            },
            LiQ: function() {
                return ar
            },
            LlO: function() {
                return Vy
            },
            LoY: function() {
                return bo
            },
            LuO: function() {
                return JS
            },
            MBL: function() {
                return Dm
            },
            MOq: function() {
                return Zp
            },
            MSw: function() {
                return n0
            },
            MW4: function() {
                return Ts
            },
            Mjd: function() {
                return xn
            },
            N1A: function() {
                return ep
            },
            N2s: function() {
                return qA
            },
            N5j: function() {
                return Qm
            },
            NRn: function() {
                return Tl
            },
            NTi: function() {
                return Pt
            },
            NZq: function() {
                return Hn
            },
            Nt7: function() {
                return cr
            },
            Nv2: function() {
                return aS
            },
            Nwf: function() {
                return Ro
            },
            Nz6: function() {
                return Js
            },
            O0B: function() {
                return nv
            },
            O3Y: function() {
                return o0
            },
            O49: function() {
                return H_
            },
            O9p: function() {
                return $u
            },
            ONl: function() {
                return Wx
            },
            OUM: function() {
                return $n
            },
            Oax: function() {
                return ks
            },
            Om: function() {
                return Mn
            },
            OuU: function() {
                return gr
            },
            P5j: function() {
                return qS
            },
            PFK: function() {
                return pE
            },
            PJ3: function() {
                return lp
            },
            PPD: function() {
                return Av
            },
            PTz: function() {
                return Is
            },
            Pdi: function() {
                return bA
            },
            Pem: function() {
                return lS
            },
            Pf$: function() {
                return US
            },
            Pq0: function() {
                return Er
            },
            Q1f: function() {
                return Gn
            },
            QCA: function() {
                return e0
            },
            QP0: function() {
                return pt
            },
            Qev: function() {
                return As
            },
            Qrf: function() {
                return op
            },
            R1W: function() {
                return cE
            },
            RJ4: function() {
                return Ll
            },
            ROr: function() {
                return E0
            },
            RQf: function() {
                return ss
            },
            RcT: function() {
                return Yl
            },
            RiT: function() {
                return B_
            },
            Riy: function() {
                return lu
            },
            Rkk: function() {
                return up
            },
            RlV: function() {
                return Qu
            },
            RoJ: function() {
                return q0
            },
            Ru$: function() {
                return T0
            },
            RyA: function() {
                return _t
            },
            S$4: function() {
                return Wp
            },
            S20: function() {
                return Vv
            },
            S2Q: function() {
                return Ol
            },
            S3G: function() {
                return bx
            },
            SUR: function() {
                return NA
            },
            ScU: function() {
                return CS
            },
            T6I: function() {
                return _y
            },
            TDQ: function() {
                return eA
            },
            THS: function() {
                return mr
            },
            TMh: function() {
                return Xm
            },
            Tap: function() {
                return MS
            },
            TdN: function() {
                return Qs
            },
            TiK: function() {
                return q_
            },
            TkQ: function() {
                return yo
            },
            U3G: function() {
                return Zr
            },
            UJ6: function() {
                return Ql
            },
            UPV: function() {
                return s0
            },
            UTZ: function() {
                return jr
            },
            Ua6: function() {
                return _h
            },
            Ufg: function() {
                return R_
            },
            UpK: function() {
                return Px
            },
            UtB: function() {
                return nE
            },
            UtX: function() {
                return wy
            },
            V3x: function() {
                return Ps
            },
            V58: function() {
                return m_
            },
            V5c: function() {
                return dp
            },
            V9B: function() {
                return nu
            },
            VCu: function() {
                return yx
            },
            VT0: function() {
                return Sl
            },
            VVr: function() {
                return Yp
            },
            Vb5: function() {
                return nt
            },
            VnP: function() {
                return Jx
            },
            Vnu: function() {
                return gu
            },
            VxR: function() {
                return No
            },
            W9U: function() {
                return Vm
            },
            WBB: function() {
                return t0
            },
            WNZ: function() {
                return _e
            },
            WTh: function() {
                return hE
            },
            Wdf: function() {
                return Ym
            },
            Wew: function() {
                return $l
            },
            Wk7: function() {
                return ht
            },
            Wyr: function() {
                return Jl
            },
            XG_: function() {
                return Gm
            },
            XIg: function() {
                return Et
            },
            XJ7: function() {
                return aA
            },
            XTe: function() {
                return DS
            },
            XrR: function() {
                return mo
            },
            Y9S: function() {
                return su
            },
            YHV: function() {
                return tE
            },
            YJl: function() {
                return Am
            },
            YOZ: function() {
                return Ip
            },
            YRT: function() {
                return TS
            },
            Yhb: function() {
                return AA
            },
            Yuy: function() {
                return $o
            },
            Z0B: function() {
                return oy
            },
            Z58: function() {
                return Ax
            },
            ZLX: function() {
                return Fx
            },
            ZM4: function() {
                return gE
            },
            ZQM: function() {
                return Ks
            },
            Zcv: function() {
                return _d
            },
            Zpd: function() {
                return i0
            },
            Zr2: function() {
                return Xo
            },
            ZyN: function() {
                return IA
            },
            _4j: function() {
                return hy
            },
            _QJ: function() {
                return zp
            },
            _xc: function() {
                return sE
            },
            a$r: function() {
                return Qn
            },
            a5J: function() {
                return uu
            },
            aEY: function() {
                return wr
            },
            aHM: function() {
                return $s
            },
            aMy: function() {
                return Du
            },
            aVO: function() {
                return Q0
            },
            agE: function() {
                return Nu
            },
            amv: function() {
                return mu
            },
            b4q: function() {
                return f_
            },
            bC7: function() {
                return Qp
            },
            bCz: function() {
                return Bt
            },
            bI3: function() {
                return El
            },
            bTm: function() {
                return ut
            },
            baL: function() {
                return $r
            },
            bdM: function() {
                return g_
            },
            bkx: function() {
                return Yo
            },
            brA: function() {
                return fr
            },
            bw0: function() {
                return Nn
            },
            c5h: function() {
                return uS
            },
            c90: function() {
                return ko
            },
            cHt: function() {
                return Zo
            },
            cRK: function() {
                return Pv
            },
            cZY: function() {
                return iE
            },
            caT: function() {
                return Wn
            },
            cj9: function() {
                return ev
            },
            czI: function() {
                return Gp
            },
            dAo: function() {
                return ay
            },
            dYF: function() {
                return i_
            },
            dcC: function() {
                return Eo
            },
            dhZ: function() {
                return cp
            },
            dth: function() {
                return EA
            },
            dwI: function() {
                return lo
            },
            dzP: function() {
                return KS
            },
            eB$: function() {
                return Rv
            },
            eHc: function() {
                return Cr
            },
            eHs: function() {
                return Cp
            },
            eaF: function() {
                return gs
            },
            eoi: function() {
                return $_
            },
            er$: function() {
                return jo
            },
            ezk: function() {
                return gy
            },
            f4X: function() {
                return lr
            },
            fBL: function() {
                return zo
            },
            fCn: function() {
                return Dn
            },
            fJr: function() {
                return qm
            },
            fP5: function() {
                return QA
            },
            fTw: function() {
                return uE
            },
            fc6: function() {
                return vn
            },
            g7M: function() {
                return Ir
            },
            gJ2: function() {
                return wl
            },
            gO9: function() {
                return kt
            },
            gPd: function() {
                return Ho
            },
            gWB: function() {
                return Kl
            },
            ghU: function() {
                return wn
            },
            h2z: function() {
                return pu
            },
            hB5: function() {
                return vt
            },
            hIf: function() {
                return Jp
            },
            hZF: function() {
                return kp
            },
            h_9: function() {
                return SA
            },
            hdd: function() {
                return dr
            },
            hfX: function() {
                return _x
            },
            hgQ: function() {
                return Rr
            },
            hjs: function() {
                return rE
            },
            hsX: function() {
                return bt
            },
            hxR: function() {
                return fn
            },
            hy7: function() {
                return Qr
            },
            hzE: function() {
                return dE
            },
            i7d: function() {
                return xv
            },
            i7u: function() {
                return na
            },
            iNn: function() {
                return Zu
            },
            iOZ: function() {
                return cS
            },
            iUH: function() {
                return Bo
            },
            ibB: function() {
                return $x
            },
            ie2: function() {
                return hr
            },
            imn: function() {
                return hs
            },
            ix0: function() {
                return Os
            },
            iyt: function() {
                return Ws
            },
            j6: function() {
                return a0
            },
            jGm: function() {
                return Zx
            },
            jR7: function() {
                return bs
            },
            jUj: function() {
                return Mv
            },
            jf0: function() {
                return Oo
            },
            jsO: function() {
                return Kp
            },
            jut: function() {
                return l0
            },
            jzd: function() {
                return X_
            },
            k6Q: function() {
                return Bm
            },
            k6q: function() {
                return Rn
            },
            kBv: function() {
                return _
            },
            kEx: function() {
                return ES
            },
            kG0: function() {
                return pp
            },
            kLi: function() {
                return ga
            },
            kO0: function() {
                return fp
            },
            kRr: function() {
                return Yn
            },
            kTW: function() {
                return Cn
            },
            kTp: function() {
                return Vp
            },
            kYr: function() {
                return hp
            },
            keZ: function() {
                return NS
            },
            klZ: function() {
                return W_
            },
            kn4: function() {
                return no
            },
            kqe: function() {
                return Hs
            },
            kxk: function() {
                return Tx
            },
            kyO: function() {
                return nn
            },
            l2R: function() {
                return Eu
            },
            lGu: function() {
                return tr
            },
            lGw: function() {
                return k_
            },
            lMl: function() {
                return Es
            },
            lPF: function() {
                return Zm
            },
            lc7: function() {
                return qp
            },
            ljd: function() {
                return Bu
            },
            lyL: function() {
                return Hp
            },
            mrM: function() {
                return Gs
            },
            nCl: function() {
                return PA
            },
            nEu: function() {
                return qv
            },
            nNL: function() {
                return ur
            },
            nST: function() {
                return Ht
            },
            nWS: function() {
                return Rs
            },
            nZQ: function() {
                return vx
            },
            nc$: function() {
                return Ty
            },
            nzx: function() {
                return T_
            },
            o6l: function() {
                return zy
            },
            oVO: function() {
                return C0
            },
            oh6: function() {
                return ZS
            },
            ojh: function() {
                return or
            },
            ojs: function() {
                return Iu
            },
            pBf: function() {
                return Om
            },
            pFK: function() {
                return tp
            },
            pHI: function() {
                return bn
            },
            pPE: function() {
                return $A
            },
            paN: function() {
                return ds
            },
            ppV: function() {
                return Do
            },
            psI: function() {
                return Nm
            },
            q2: function() {
                return uA
            },
            qBx: function() {
                return fA
            },
            qFE: function() {
                return Wv
            },
            qIQ: function() {
                return hu
            },
            qU7: function() {
                return Hv
            },
            qUd: function() {
                return Sv
            },
            qa3: function() {
                return Xl
            },
            qad: function() {
                return ir
            },
            qtW: function() {
                return Fn
            },
            r6x: function() {
                return Ay
            },
            rFo: function() {
                return im
            },
            rKP: function() {
                return r0
            },
            rOG: function() {
                return xo
            },
            rQf: function() {
                return du
            },
            rSH: function() {
                return Ru
            },
            rYR: function() {
                return S0
            },
            s0K: function() {
                return Kx
            },
            sKt: function() {
                return mp
            },
            sPf: function() {
                return h
            },
            tBo: function() {
                return eE
            },
            tJf: function() {
                return ao
            },
            tXL: function() {
                return hA
            },
            tcD: function() {
                return Qv
            },
            tgE: function() {
                return ts
            },
            tz3: function() {
                return L_
            },
            uB5: function() {
                return Fm
            },
            uSd: function() {
                return pA
            },
            uV5: function() {
                return gn
            },
            uWO: function() {
                return Mm
            },
            uXQ: function() {
                return P0
            },
            ubm: function() {
                return Cs
            },
            uov: function() {
                return M0
            },
            ure: function() {
                return DA
            },
            veJ: function() {
                return rp
            },
            vim: function() {
                return fu
            },
            vmz: function() {
                return is
            },
            vxI: function() {
                return go
            },
            vyJ: function() {
                return Lu
            },
            wAk: function() {
                return E_
            },
            wfO: function() {
                return qr
            },
            wn6: function() {
                return Ar
            },
            wqq: function() {
                return Ou
            },
            wrO: function() {
                return ys
            },
            wtR: function() {
                return b
            },
            wvS: function() {
                return Tr
            },
            xFO: function() {
                return Or
            },
            xJ6: function() {
                return ou
            },
            xOk: function() {
                return BA
            },
            xSv: function() {
                return vr
            },
            xZx: function() {
                return VS
            },
            xfg: function() {
                return cy
            },
            y3Z: function() {
                return Um
            },
            y9J: function() {
                return n_
            },
            y_p: function() {
                return Ur
            },
            ypk: function() {
                return Pp
            },
            ywQ: function() {
                return at
            },
            z5: function() {
                return Wo
            },
            zD7: function() {
                return GA
            },
            zdS: function() {
                return Ys
            },
            zgK: function() {
                return um
            },
            zkh: function() {
                return qs
            },
            znC: function() {
                return Kt
            }
        });
        const h = "157"
          , _ = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2
        }
          , b = {
            ROTATE: 0,
            PAN: 1,
            DOLLY_PAN: 2,
            DOLLY_ROTATE: 3
        }
          , _e = 0
          , nt = 1
          , it = 2
          , at = 3
          , ut = 0
          , pt = 1
          , ht = 2
          , _t = 3
          , vt = 0
          , bt = 1
          , St = 2
          , At = 2
          , Et = 0
          , Pt = 1
          , It = 2
          , Dt = 3
          , Gt = 4
          , Bt = 5
          , kt = 100
          , Ut = 101
          , Ht = 102
          , Kt = 103
          , Jt = 104
          , or = 200
          , ir = 201
          , lr = 202
          , ar = 203
          , hr = 204
          , gr = 205
          , dr = 206
          , cr = 207
          , Ar = 208
          , wr = 209
          , Rr = 210
          , Cr = 0
          , tr = 1
          , fr = 2
          , vr = 3
          , Zr = 4
          , rn = 5
          , hn = 6
          , Nn = 7
          , Wn = 0
          , qn = 1
          , mo = 2
          , Ur = 0
          , nn = 1
          , xn = 2
          , ur = 3
          , pr = 4
          , Ir = 5
          , jr = 300
          , Qr = 301
          , Or = 302
          , qr = 303
          , gn = 304
          , Mn = 306
          , Tn = 1e3
          , wn = 1001
          , Cn = 1002
          , fn = 1003
          , bn = 1004
          , Xn = 1004
          , En = 1005
          , Qn = 1005
          , Rn = 1006
          , Yn = 1007
          , Bo = 1007
          , vo = 1008
          , Hn = 1008
          , $n = 1009
          , ao = 1010
          , zo = 1011
          , Zo = 1012
          , $o = 1013
          , Yo = 1014
          , ss = 1015
          , Os = 1016
          , $l = 1017
          , wl = 1018
          , Ps = 1020
          , ys = 1021
          , as = 1023
          , Ln = 1024
          , Vn = 1025
          , Ys = 1026
          , Eo = 1027
          , Sl = 1028
          , Ks = 1029
          , ds = 1030
          , yo = 1031
          , ko = 1033
          , xs = 33776
          , Js = 33777
          , bs = 33778
          , Bl = 33779
          , Bm = 35840
          , Vp = 35841
          , Lm = 35842
          , Om = 35843
          , G_ = 36196
          , lu = 37492
          , Zs = 37496
          , Xl = 37808
          , cu = 37809
          , Gp = 37810
          , Ru = 37811
          , op = 37812
          , Nm = 37813
          , uu = 37814
          , zp = 37815
          , Fm = 37816
          , Hp = 37817
          , Qp = 37818
          , Um = 37819
          , Iu = 37820
          , Wp = 37821
          , sp = 36492
          , jm = 36494
          , Vm = 36495
          , z_ = 36283
          , Gm = 36284
          , zm = 36285
          , ap = 36286
          , ku = 2200
          , Du = 2201
          , qp = 2202
          , Bu = 2300
          , lp = 2301
          , $p = 2302
          , du = 2400
          , pu = 2401
          , cp = 2402
          , Hm = 2500
          , Xp = 2501
          , Ll = 0
          , H_ = 1
          , S0 = 2
          , ts = 3e3
          , Ol = 3001
          , up = 3200
          , Qm = 3201
          , El = 0
          , Lu = 1
          , Oo = ""
          , jo = "srgb"
          , Xo = "srgb-linear"
          , dp = "display-p3"
          , hu = "display-p3-linear"
          , ps = "rgbm-16"
          , No = "linear"
          , Vo = "srgb"
          , Wo = "rec709"
          , Ou = "p3"
          , Hs = 0
          , Yp = 7680
          , pp = 7681
          , Wm = 7682
          , E0 = 7683
          , T0 = 34055
          , qm = 34056
          , C0 = 5386
          , $m = 512
          , hp = 513
          , Kp = 514
          , Q_ = 515
          , Yl = 516
          , W_ = 517
          , Xm = 518
          , mp = 519
          , mu = 512
          , fu = 513
          , fp = 514
          , q_ = 515
          , $_ = 516
          , X_ = 517
          , Kl = 518
          , Y_ = 519
          , Nu = 35044
          , gu = 35048
          , K_ = 35040
          , P0 = 35045
          , Jp = 35049
          , M0 = 35041
          , J_ = 35046
          , Zp = 35050
          , xo = 35042
          , Jl = "100"
          , Ym = "300 es"
          , _h = 1035
          , Qs = 2e3
          , na = 2001;
        class As {
            addEventListener(tt, lt) {
                this._listeners === void 0 && (this._listeners = {});
                const mt = this._listeners;
                mt[tt] === void 0 && (mt[tt] = []),
                mt[tt].indexOf(lt) === -1 && mt[tt].push(lt)
            }
            hasEventListener(tt, lt) {
                if (this._listeners === void 0)
                    return !1;
                const mt = this._listeners;
                return mt[tt] !== void 0 && mt[tt].indexOf(lt) !== -1
            }
            removeEventListener(tt, lt) {
                if (this._listeners === void 0)
                    return;
                const mt = this._listeners[tt];
                if (mt !== void 0) {
                    const ft = mt.indexOf(lt);
                    ft !== -1 && mt.splice(ft, 1)
                }
            }
            dispatchEvent(tt) {
                if (this._listeners === void 0)
                    return;
                const lt = this._listeners[tt.type];
                if (lt !== void 0) {
                    tt.target = this;
                    const mt = lt.slice(0);
                    for (let ft = 0, xt = mt.length; ft < xt; ft++)
                        mt[ft].call(this, tt);
                    tt.target = null
                }
            }
        }
        const Go = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let Z_ = 1234567;
        const Zl = Math.PI / 180
          , _u = 180 / Math.PI;
        function Ms() {
            const Tt = 4294967295 * Math.random() | 0
              , tt = 4294967295 * Math.random() | 0
              , lt = 4294967295 * Math.random() | 0
              , mt = 4294967295 * Math.random() | 0;
            return (Go[255 & Tt] + Go[Tt >> 8 & 255] + Go[Tt >> 16 & 255] + Go[Tt >> 24 & 255] + "-" + Go[255 & tt] + Go[tt >> 8 & 255] + "-" + Go[tt >> 16 & 15 | 64] + Go[tt >> 24 & 255] + "-" + Go[63 & lt | 128] + Go[lt >> 8 & 255] + "-" + Go[lt >> 16 & 255] + Go[lt >> 24 & 255] + Go[255 & mt] + Go[mt >> 8 & 255] + Go[mt >> 16 & 255] + Go[mt >> 24 & 255]).toLowerCase()
        }
        function qo(Tt, tt, lt) {
            return Math.max(tt, Math.min(lt, Tt))
        }
        function em(Tt, tt) {
            return (Tt % tt + tt) % tt
        }
        function Fu(Tt, tt, lt) {
            return (1 - lt) * Tt + lt * tt
        }
        function tm(Tt) {
            return !(Tt & Tt - 1) && Tt !== 0
        }
        function Km(Tt) {
            return Math.pow(2, Math.ceil(Math.log(Tt) / Math.LN2))
        }
        function gp(Tt) {
            return Math.pow(2, Math.floor(Math.log(Tt) / Math.LN2))
        }
        function ws(Tt, tt) {
            switch (tt.constructor) {
            case Float32Array:
                return Tt;
            case Uint32Array:
                return Tt / 4294967295;
            case Uint16Array:
                return Tt / 65535;
            case Uint8Array:
                return Tt / 255;
            case Int32Array:
                return Math.max(Tt / 2147483647, -1);
            case Int16Array:
                return Math.max(Tt / 32767, -1);
            case Int8Array:
                return Math.max(Tt / 127, -1);
            default:
                throw new Error("Invalid component type.")
            }
        }
        function oo(Tt, tt) {
            switch (tt.constructor) {
            case Float32Array:
                return Tt;
            case Uint32Array:
                return Math.round(4294967295 * Tt);
            case Uint16Array:
                return Math.round(65535 * Tt);
            case Uint8Array:
                return Math.round(255 * Tt);
            case Int32Array:
                return Math.round(2147483647 * Tt);
            case Int16Array:
                return Math.round(32767 * Tt);
            case Int8Array:
                return Math.round(127 * Tt);
            default:
                throw new Error("Invalid component type.")
            }
        }
        const ev = {
            DEG2RAD: Zl,
            RAD2DEG: _u,
            generateUUID: Ms,
            clamp: qo,
            euclideanModulo: em,
            mapLinear: function(Tt, tt, lt, mt, ft) {
                return mt + (Tt - tt) * (ft - mt) / (lt - tt)
            },
            inverseLerp: function(Tt, tt, lt) {
                return Tt !== tt ? (lt - Tt) / (tt - Tt) : 0
            },
            lerp: Fu,
            damp: function(Tt, tt, lt, mt) {
                return Fu(Tt, tt, 1 - Math.exp(-lt * mt))
            },
            pingpong: function(Tt, tt=1) {
                return tt - Math.abs(em(Tt, 2 * tt) - tt)
            },
            smoothstep: function(Tt, tt, lt) {
                return Tt <= tt ? 0 : Tt >= lt ? 1 : (Tt = (Tt - tt) / (lt - tt)) * Tt * (3 - 2 * Tt)
            },
            smootherstep: function(Tt, tt, lt) {
                return Tt <= tt ? 0 : Tt >= lt ? 1 : (Tt = (Tt - tt) / (lt - tt)) * Tt * Tt * (Tt * (6 * Tt - 15) + 10)
            },
            randInt: function(Tt, tt) {
                return Tt + Math.floor(Math.random() * (tt - Tt + 1))
            },
            randFloat: function(Tt, tt) {
                return Tt + Math.random() * (tt - Tt)
            },
            randFloatSpread: function(Tt) {
                return Tt * (.5 - Math.random())
            },
            seededRandom: function(Tt) {
                Tt !== void 0 && (Z_ = Tt);
                let tt = Z_ += 1831565813;
                return tt = Math.imul(tt ^ tt >>> 15, 1 | tt),
                tt ^= tt + Math.imul(tt ^ tt >>> 7, 61 | tt),
                ((tt ^ tt >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(Tt) {
                return Tt * Zl
            },
            radToDeg: function(Tt) {
                return Tt * _u
            },
            isPowerOfTwo: tm,
            ceilPowerOfTwo: Km,
            floorPowerOfTwo: gp,
            setQuaternionFromProperEuler: function(Tt, tt, lt, mt, ft) {
                const xt = Math.cos
                  , Ct = Math.sin
                  , Mt = xt(lt / 2)
                  , Lt = Ct(lt / 2)
                  , Nt = xt((tt + mt) / 2)
                  , jt = Ct((tt + mt) / 2)
                  , Wt = xt((tt - mt) / 2)
                  , Qt = Ct((tt - mt) / 2)
                  , qt = xt((mt - tt) / 2)
                  , Xt = Ct((mt - tt) / 2);
                switch (ft) {
                case "XYX":
                    Tt.set(Mt * jt, Lt * Wt, Lt * Qt, Mt * Nt);
                    break;
                case "YZY":
                    Tt.set(Lt * Qt, Mt * jt, Lt * Wt, Mt * Nt);
                    break;
                case "ZXZ":
                    Tt.set(Lt * Wt, Lt * Qt, Mt * jt, Mt * Nt);
                    break;
                case "XZX":
                    Tt.set(Mt * jt, Lt * Xt, Lt * qt, Mt * Nt);
                    break;
                case "YXY":
                    Tt.set(Lt * qt, Mt * jt, Lt * Xt, Mt * Nt);
                    break;
                case "ZYZ":
                    Tt.set(Lt * Xt, Lt * qt, Mt * jt, Mt * Nt);
                    break;
                default:
                    console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + ft)
                }
            },
            normalize: oo,
            denormalize: ws
        };
        class mn {
            constructor(tt=0, lt=0) {
                mn.prototype.isVector2 = !0,
                this.x = tt,
                this.y = lt
            }
            get width() {
                return this.x
            }
            set width(tt) {
                this.x = tt
            }
            get height() {
                return this.y
            }
            set height(tt) {
                this.y = tt
            }
            set(tt, lt) {
                return this.x = tt,
                this.y = lt,
                this
            }
            setScalar(tt) {
                return this.x = tt,
                this.y = tt,
                this
            }
            setX(tt) {
                return this.x = tt,
                this
            }
            setY(tt) {
                return this.y = tt,
                this
            }
            setComponent(tt, lt) {
                switch (tt) {
                case 0:
                    this.x = lt;
                    break;
                case 1:
                    this.y = lt;
                    break;
                default:
                    throw new Error("index is out of range: " + tt)
                }
                return this
            }
            getComponent(tt) {
                switch (tt) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw new Error("index is out of range: " + tt)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            copy(tt) {
                return this.x = tt.x,
                this.y = tt.y,
                this
            }
            add(tt) {
                return this.x += tt.x,
                this.y += tt.y,
                this
            }
            addScalar(tt) {
                return this.x += tt,
                this.y += tt,
                this
            }
            addVectors(tt, lt) {
                return this.x = tt.x + lt.x,
                this.y = tt.y + lt.y,
                this
            }
            addScaledVector(tt, lt) {
                return this.x += tt.x * lt,
                this.y += tt.y * lt,
                this
            }
            sub(tt) {
                return this.x -= tt.x,
                this.y -= tt.y,
                this
            }
            subScalar(tt) {
                return this.x -= tt,
                this.y -= tt,
                this
            }
            subVectors(tt, lt) {
                return this.x = tt.x - lt.x,
                this.y = tt.y - lt.y,
                this
            }
            multiply(tt) {
                return this.x *= tt.x,
                this.y *= tt.y,
                this
            }
            multiplyScalar(tt) {
                return this.x *= tt,
                this.y *= tt,
                this
            }
            divide(tt) {
                return this.x /= tt.x,
                this.y /= tt.y,
                this
            }
            divideScalar(tt) {
                return this.multiplyScalar(1 / tt)
            }
            applyMatrix3(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = tt.elements;
                return this.x = ft[0] * lt + ft[3] * mt + ft[6],
                this.y = ft[1] * lt + ft[4] * mt + ft[7],
                this
            }
            min(tt) {
                return this.x = Math.min(this.x, tt.x),
                this.y = Math.min(this.y, tt.y),
                this
            }
            max(tt) {
                return this.x = Math.max(this.x, tt.x),
                this.y = Math.max(this.y, tt.y),
                this
            }
            clamp(tt, lt) {
                return this.x = Math.max(tt.x, Math.min(lt.x, this.x)),
                this.y = Math.max(tt.y, Math.min(lt.y, this.y)),
                this
            }
            clampScalar(tt, lt) {
                return this.x = Math.max(tt, Math.min(lt, this.x)),
                this.y = Math.max(tt, Math.min(lt, this.y)),
                this
            }
            clampLength(tt, lt) {
                const mt = this.length();
                return this.divideScalar(mt || 1).multiplyScalar(Math.max(tt, Math.min(lt, mt)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this
            }
            dot(tt) {
                return this.x * tt.x + this.y * tt.y
            }
            cross(tt) {
                return this.x * tt.y - this.y * tt.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(tt) {
                const lt = Math.sqrt(this.lengthSq() * tt.lengthSq());
                if (lt === 0)
                    return Math.PI / 2;
                const mt = this.dot(tt) / lt;
                return Math.acos(qo(mt, -1, 1))
            }
            distanceTo(tt) {
                return Math.sqrt(this.distanceToSquared(tt))
            }
            distanceToSquared(tt) {
                const lt = this.x - tt.x
                  , mt = this.y - tt.y;
                return lt * lt + mt * mt
            }
            manhattanDistanceTo(tt) {
                return Math.abs(this.x - tt.x) + Math.abs(this.y - tt.y)
            }
            setLength(tt) {
                return this.normalize().multiplyScalar(tt)
            }
            lerp(tt, lt) {
                return this.x += (tt.x - this.x) * lt,
                this.y += (tt.y - this.y) * lt,
                this
            }
            lerpVectors(tt, lt, mt) {
                return this.x = tt.x + (lt.x - tt.x) * mt,
                this.y = tt.y + (lt.y - tt.y) * mt,
                this
            }
            equals(tt) {
                return tt.x === this.x && tt.y === this.y
            }
            fromArray(tt, lt=0) {
                return this.x = tt[lt],
                this.y = tt[lt + 1],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.x,
                tt[lt + 1] = this.y,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.x = tt.getX(lt),
                this.y = tt.getY(lt),
                this
            }
            rotateAround(tt, lt) {
                const mt = Math.cos(lt)
                  , ft = Math.sin(lt)
                  , xt = this.x - tt.x
                  , Ct = this.y - tt.y;
                return this.x = xt * mt - Ct * ft + tt.x,
                this.y = xt * ft + Ct * mt + tt.y,
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y
            }
        }
        class lo {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                lo.prototype.isMatrix3 = !0,
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                tt !== void 0 && this.set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt)
            }
            set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                const jt = this.elements;
                return jt[0] = tt,
                jt[1] = ft,
                jt[2] = Mt,
                jt[3] = lt,
                jt[4] = xt,
                jt[5] = Lt,
                jt[6] = mt,
                jt[7] = Ct,
                jt[8] = Nt,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
                this
            }
            copy(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                return lt[0] = mt[0],
                lt[1] = mt[1],
                lt[2] = mt[2],
                lt[3] = mt[3],
                lt[4] = mt[4],
                lt[5] = mt[5],
                lt[6] = mt[6],
                lt[7] = mt[7],
                lt[8] = mt[8],
                this
            }
            extractBasis(tt, lt, mt) {
                return tt.setFromMatrix3Column(this, 0),
                lt.setFromMatrix3Column(this, 1),
                mt.setFromMatrix3Column(this, 2),
                this
            }
            setFromMatrix4(tt) {
                const lt = tt.elements;
                return this.set(lt[0], lt[4], lt[8], lt[1], lt[5], lt[9], lt[2], lt[6], lt[10]),
                this
            }
            multiply(tt) {
                return this.multiplyMatrices(this, tt)
            }
            premultiply(tt) {
                return this.multiplyMatrices(tt, this)
            }
            multiplyMatrices(tt, lt) {
                const mt = tt.elements
                  , ft = lt.elements
                  , xt = this.elements
                  , Ct = mt[0]
                  , Mt = mt[3]
                  , Lt = mt[6]
                  , Nt = mt[1]
                  , jt = mt[4]
                  , Wt = mt[7]
                  , Qt = mt[2]
                  , qt = mt[5]
                  , Xt = mt[8]
                  , Zt = ft[0]
                  , Yt = ft[3]
                  , sr = ft[6]
                  , er = ft[1]
                  , rr = ft[4]
                  , xr = ft[7]
                  , br = ft[2]
                  , yr = ft[5]
                  , Pr = ft[8];
                return xt[0] = Ct * Zt + Mt * er + Lt * br,
                xt[3] = Ct * Yt + Mt * rr + Lt * yr,
                xt[6] = Ct * sr + Mt * xr + Lt * Pr,
                xt[1] = Nt * Zt + jt * er + Wt * br,
                xt[4] = Nt * Yt + jt * rr + Wt * yr,
                xt[7] = Nt * sr + jt * xr + Wt * Pr,
                xt[2] = Qt * Zt + qt * er + Xt * br,
                xt[5] = Qt * Yt + qt * rr + Xt * yr,
                xt[8] = Qt * sr + qt * xr + Xt * Pr,
                this
            }
            multiplyScalar(tt) {
                const lt = this.elements;
                return lt[0] *= tt,
                lt[3] *= tt,
                lt[6] *= tt,
                lt[1] *= tt,
                lt[4] *= tt,
                lt[7] *= tt,
                lt[2] *= tt,
                lt[5] *= tt,
                lt[8] *= tt,
                this
            }
            determinant() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[1]
                  , ft = tt[2]
                  , xt = tt[3]
                  , Ct = tt[4]
                  , Mt = tt[5]
                  , Lt = tt[6]
                  , Nt = tt[7]
                  , jt = tt[8];
                return lt * Ct * jt - lt * Mt * Nt - mt * xt * jt + mt * Mt * Lt + ft * xt * Nt - ft * Ct * Lt
            }
            invert() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[1]
                  , ft = tt[2]
                  , xt = tt[3]
                  , Ct = tt[4]
                  , Mt = tt[5]
                  , Lt = tt[6]
                  , Nt = tt[7]
                  , jt = tt[8]
                  , Wt = jt * Ct - Mt * Nt
                  , Qt = Mt * Lt - jt * xt
                  , qt = Nt * xt - Ct * Lt
                  , Xt = lt * Wt + mt * Qt + ft * qt;
                if (Xt === 0)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const Zt = 1 / Xt;
                return tt[0] = Wt * Zt,
                tt[1] = (ft * Nt - jt * mt) * Zt,
                tt[2] = (Mt * mt - ft * Ct) * Zt,
                tt[3] = Qt * Zt,
                tt[4] = (jt * lt - ft * Lt) * Zt,
                tt[5] = (ft * xt - Mt * lt) * Zt,
                tt[6] = qt * Zt,
                tt[7] = (mt * Lt - Nt * lt) * Zt,
                tt[8] = (Ct * lt - mt * xt) * Zt,
                this
            }
            transpose() {
                let tt;
                const lt = this.elements;
                return tt = lt[1],
                lt[1] = lt[3],
                lt[3] = tt,
                tt = lt[2],
                lt[2] = lt[6],
                lt[6] = tt,
                tt = lt[5],
                lt[5] = lt[7],
                lt[7] = tt,
                this
            }
            getNormalMatrix(tt) {
                return this.setFromMatrix4(tt).invert().transpose()
            }
            transposeIntoArray(tt) {
                const lt = this.elements;
                return tt[0] = lt[0],
                tt[1] = lt[3],
                tt[2] = lt[6],
                tt[3] = lt[1],
                tt[4] = lt[4],
                tt[5] = lt[7],
                tt[6] = lt[2],
                tt[7] = lt[5],
                tt[8] = lt[8],
                this
            }
            setUvTransform(tt, lt, mt, ft, xt, Ct, Mt) {
                const Lt = Math.cos(xt)
                  , Nt = Math.sin(xt);
                return this.set(mt * Lt, mt * Nt, -mt * (Lt * Ct + Nt * Mt) + Ct + tt, -ft * Nt, ft * Lt, -ft * (-Nt * Ct + Lt * Mt) + Mt + lt, 0, 0, 1),
                this
            }
            scale(tt, lt) {
                return this.premultiply(rm.makeScale(tt, lt)),
                this
            }
            rotate(tt) {
                return this.premultiply(rm.makeRotation(-tt)),
                this
            }
            translate(tt, lt) {
                return this.premultiply(rm.makeTranslation(tt, lt)),
                this
            }
            makeTranslation(tt, lt) {
                return tt.isVector2 ? this.set(1, 0, tt.x, 0, 1, tt.y, 0, 0, 1) : this.set(1, 0, tt, 0, 1, lt, 0, 0, 1),
                this
            }
            makeRotation(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(lt, -mt, 0, mt, lt, 0, 0, 0, 1),
                this
            }
            makeScale(tt, lt) {
                return this.set(tt, 0, 0, 0, lt, 0, 0, 0, 1),
                this
            }
            equals(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                for (let ft = 0; ft < 9; ft++)
                    if (lt[ft] !== mt[ft])
                        return !1;
                return !0
            }
            fromArray(tt, lt=0) {
                for (let mt = 0; mt < 9; mt++)
                    this.elements[mt] = tt[mt + lt];
                return this
            }
            toArray(tt=[], lt=0) {
                const mt = this.elements;
                return tt[lt] = mt[0],
                tt[lt + 1] = mt[1],
                tt[lt + 2] = mt[2],
                tt[lt + 3] = mt[3],
                tt[lt + 4] = mt[4],
                tt[lt + 5] = mt[5],
                tt[lt + 6] = mt[6],
                tt[lt + 7] = mt[7],
                tt[lt + 8] = mt[8],
                tt
            }
            clone() {
                return new this.constructor().fromArray(this.elements)
            }
        }
        const rm = new lo;
        function tv(Tt) {
            for (let tt = Tt.length - 1; tt >= 0; --tt)
                if (Tt[tt] >= 65535)
                    return !0;
            return !1
        }
        const Jm = {
            Int8Array,
            Uint8Array,
            Uint8ClampedArray,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array
        };
        function vu(Tt, tt) {
            return new Jm[Tt](tt)
        }
        function yu(Tt) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", Tt)
        }
        function Zm() {
            const Tt = yu("canvas");
            return Tt.style.display = "block",
            Tt
        }
        const _f = {};
        function xu(Tt) {
            Tt in _f || (_f[Tt] = !0,
            console.warn(Tt))
        }
        const _g = new lo().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
          , rv = new lo().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
          , bu = {
            [Xo]: {
                transfer: No,
                primaries: Wo,
                toReference: Tt => Tt,
                fromReference: Tt => Tt
            },
            [jo]: {
                transfer: Vo,
                primaries: Wo,
                toReference: Tt => Tt.convertSRGBToLinear(),
                fromReference: Tt => Tt.convertLinearToSRGB()
            },
            [hu]: {
                transfer: No,
                primaries: Ou,
                toReference: Tt => Tt.applyMatrix3(rv),
                fromReference: Tt => Tt.applyMatrix3(_g)
            },
            [dp]: {
                transfer: Vo,
                primaries: Ou,
                toReference: Tt => Tt.convertSRGBToLinear().applyMatrix3(rv),
                fromReference: Tt => Tt.applyMatrix3(_g).convertLinearToSRGB()
            }
        }
          , R0 = new Set([Xo, hu])
          , Do = {
            enabled: !0,
            _workingColorSpace: Xo,
            get legacyMode() {
                return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                !this.enabled
            },
            set legacyMode(Tt) {
                console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),
                this.enabled = !Tt
            },
            get workingColorSpace() {
                return this._workingColorSpace
            },
            set workingColorSpace(Tt) {
                if (!R0.has(Tt))
                    throw new Error(`Unsupported working color space, "${Tt}".`);
                this._workingColorSpace = Tt
            },
            convert: function(Tt, tt, lt) {
                if (this.enabled === !1 || tt === lt || !tt || !lt)
                    return Tt;
                const mt = bu[tt].toReference;
                return (0,
                bu[lt].fromReference)(mt(Tt))
            },
            fromWorkingColorSpace: function(Tt, tt) {
                return this.convert(Tt, this._workingColorSpace, tt)
            },
            toWorkingColorSpace: function(Tt, tt) {
                return this.convert(Tt, tt, this._workingColorSpace)
            },
            getPrimaries: function(Tt) {
                return bu[Tt].primaries
            },
            getTransfer: function(Tt) {
                return Tt === Oo || Tt === ps ? No : bu[Tt].transfer
            }
        };
        function Uu(Tt) {
            return Tt < .04045 ? .0773993808 * Tt : Math.pow(.9478672986 * Tt + .0521327014, 2.4)
        }
        function nm(Tt) {
            return Tt < .0031308 ? 12.92 * Tt : 1.055 * Math.pow(Tt, .41666) - .055
        }
        let ju;
        class e_ {
            static getDataURL(tt, lt=!1) {
                if (/^data:/i.test(tt.src) || typeof HTMLCanvasElement > "u")
                    return tt.src;
                let mt;
                if (tt instanceof HTMLCanvasElement)
                    mt = tt;
                else {
                    ju === void 0 && (ju = yu("canvas")),
                    ju.width = tt.width,
                    ju.height = tt.height;
                    const ft = ju.getContext("2d");
                    tt instanceof ImageData ? ft.putImageData(tt, 0, 0) : ft.drawImage(tt, 0, 0, tt.width, tt.height),
                    mt = ju
                }
                return !lt && (mt.width > 2048 || mt.height > 2048) ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", tt),
                mt.toDataURL("image/jpeg", .6)) : mt.toDataURL("image/png")
            }
            static sRGBToLinear(tt) {
                if (typeof HTMLImageElement < "u" && tt instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && tt instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && tt instanceof ImageBitmap) {
                    const lt = yu("canvas");
                    lt.width = tt.width,
                    lt.height = tt.height;
                    const mt = lt.getContext("2d");
                    mt.drawImage(tt, 0, 0, tt.width, tt.height);
                    const ft = mt.getImageData(0, 0, tt.width, tt.height)
                      , xt = ft.data;
                    for (let Ct = 0; Ct < xt.length; Ct++)
                        xt[Ct] = 255 * Uu(xt[Ct] / 255);
                    return mt.putImageData(ft, 0, 0),
                    lt
                }
                if (tt.data) {
                    const lt = tt.data.slice(0);
                    for (let mt = 0; mt < lt.length; mt++)
                        lt instanceof Uint8Array || lt instanceof Uint8ClampedArray ? lt[mt] = Math.floor(255 * Uu(lt[mt] / 255)) : lt[mt] = Uu(lt[mt]);
                    return {
                        data: lt,
                        width: tt.width,
                        height: tt.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
                tt
            }
        }
        let t_ = 0;
        class ga {
            constructor(tt=null) {
                this.isSource = !0,
                Object.defineProperty(this, "id", {
                    value: t_++
                }),
                this.uuid = Ms(),
                this.data = tt,
                this.version = 0
            }
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string";
                if (!lt && tt.images[this.uuid] !== void 0)
                    return tt.images[this.uuid];
                const mt = {
                    uuid: this.uuid,
                    url: ""
                }
                  , ft = this.data;
                if (ft !== null) {
                    let xt;
                    if (Array.isArray(ft)) {
                        xt = [];
                        for (let Ct = 0, Mt = ft.length; Ct < Mt; Ct++)
                            ft[Ct].isDataTexture ? xt.push(r_(ft[Ct].image)) : xt.push(r_(ft[Ct]))
                    } else
                        xt = r_(ft);
                    mt.url = xt
                }
                return lt || (tt.images[this.uuid] = mt),
                mt
            }
        }
        function r_(Tt) {
            if (typeof HTMLImageElement < "u" && Tt instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Tt instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Tt instanceof ImageBitmap)
                return e_.getDataURL(Tt);
            if (Tt.data) {
                let tt = [];
                try {
                    tt = Array.from(Tt.data)
                } catch (lt) {
                    lt.message.includes("Invalid array length") ? console.warn("Serializing large texture, might not be saved in JSON structure.") : console.error(lt),
                    tt = Tt.data
                }
                return {
                    data: tt,
                    width: Tt.width,
                    height: Tt.height,
                    type: Tt.data.constructor.name
                }
            }
            return Tt.url !== void 0 ? Tt.url : (console.warn("THREE.Texture: Unable to serialize Texture."),
            {})
        }
        let I0 = 0;
        class Ho extends As {
            constructor(tt=Ho.DEFAULT_IMAGE, lt=Ho.DEFAULT_MAPPING, mt=wn, ft=wn, xt=Rn, Ct=vo, Mt=as, Lt=$n, Nt=Ho.DEFAULT_ANISOTROPY, jt=Oo) {
                super(),
                this.isTexture = !0,
                Object.defineProperty(this, "id", {
                    value: I0++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.source = new ga(tt),
                this.mipmaps = [],
                this.mapping = lt,
                this.channel = 0,
                this.wrapS = mt,
                this.wrapT = ft,
                this.magFilter = xt,
                this.minFilter = Ct,
                this.anisotropy = Nt,
                this.format = Mt,
                this.internalFormat = null,
                this.type = Lt,
                this.offset = new mn(0,0),
                this.repeat = new mn(1,1),
                this.center = new mn(0,0),
                this.rotation = 0,
                this.matrixAutoUpdate = !0,
                this.matrix = new lo,
                this.generateMipmaps = !0,
                this.premultiplyAlpha = !1,
                this.flipY = !0,
                this.unpackAlignment = 4,
                typeof jt == "string" ? this.colorSpace = jt : (xu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = jt === Ol ? jo : Oo),
                this.userData = {},
                this.version = 0,
                this.onUpdate = null,
                this.isRenderTargetTexture = !1,
                this.needsPMREMUpdate = !1,
                tt instanceof ImageData && (this.needsUpdate = !0)
            }
            get image() {
                return this.source.data
            }
            set image(tt=null) {
                this.source.data = tt
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.name = tt.name,
                this.source = tt.source,
                this.mipmaps = tt.mipmaps.slice(0),
                this.mapping = tt.mapping,
                this.channel = tt.channel,
                this.wrapS = tt.wrapS,
                this.wrapT = tt.wrapT,
                this.magFilter = tt.magFilter,
                this.minFilter = tt.minFilter,
                this.anisotropy = tt.anisotropy,
                this.format = tt.format,
                this.internalFormat = tt.internalFormat,
                this.type = tt.type,
                this.offset.copy(tt.offset),
                this.repeat.copy(tt.repeat),
                this.center.copy(tt.center),
                this.rotation = tt.rotation,
                this.matrixAutoUpdate = tt.matrixAutoUpdate,
                this.matrix.copy(tt.matrix),
                this.generateMipmaps = tt.generateMipmaps,
                this.premultiplyAlpha = tt.premultiplyAlpha,
                this.flipY = tt.flipY,
                this.unpackAlignment = tt.unpackAlignment,
                this.colorSpace = tt.colorSpace,
                this.userData = JSON.parse(JSON.stringify(tt.userData)),
                this.needsUpdate = !0,
                this
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string";
                if (!lt && tt.textures && tt.textures[this.uuid] !== void 0)
                    return tt.textures[this.uuid];
                const mt = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(tt).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    encoding: this.colorSpace === jo ? Ol : ts,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (mt.userData = this.userData),
                !lt && tt.textures && (tt.textures[this.uuid] = mt),
                mt
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(tt) {
                if (this.mapping !== jr)
                    return tt;
                if (tt.applyMatrix3(this.matrix),
                tt.x < 0 || tt.x > 1)
                    switch (this.wrapS) {
                    case Tn:
                        tt.x = tt.x - Math.floor(tt.x);
                        break;
                    case wn:
                        tt.x = tt.x < 0 ? 0 : 1;
                        break;
                    case Cn:
                        Math.abs(Math.floor(tt.x) % 2) === 1 ? tt.x = Math.ceil(tt.x) - tt.x : tt.x = tt.x - Math.floor(tt.x)
                    }
                if (tt.y < 0 || tt.y > 1)
                    switch (this.wrapT) {
                    case Tn:
                        tt.y = tt.y - Math.floor(tt.y);
                        break;
                    case wn:
                        tt.y = tt.y < 0 ? 0 : 1;
                        break;
                    case Cn:
                        Math.abs(Math.floor(tt.y) % 2) === 1 ? tt.y = Math.ceil(tt.y) - tt.y : tt.y = tt.y - Math.floor(tt.y)
                    }
                return this.flipY && (tt.y = 1 - tt.y),
                tt
            }
            set needsUpdate(tt) {
                tt === !0 && (this.version++,
                this.source.needsUpdate = !0,
                this.dispatchEvent({
                    type: "update"
                }))
            }
            get encoding() {
                return xu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace === jo ? Ol : ts
            }
            set encoding(tt) {
                xu("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
                this.colorSpace = tt === Ol ? jo : Oo
            }
        }
        Ho.DEFAULT_IMAGE = null,
        Ho.DEFAULT_MAPPING = jr,
        Ho.DEFAULT_ANISOTROPY = 1;
        class Lo {
            constructor(tt=0, lt=0, mt=0, ft=1) {
                Lo.prototype.isVector4 = !0,
                this.x = tt,
                this.y = lt,
                this.z = mt,
                this.w = ft
            }
            get width() {
                return this.z
            }
            set width(tt) {
                this.z = tt
            }
            get height() {
                return this.w
            }
            set height(tt) {
                this.w = tt
            }
            set(tt, lt, mt, ft) {
                return this.x = tt,
                this.y = lt,
                this.z = mt,
                this.w = ft,
                this
            }
            setScalar(tt) {
                return this.x = tt,
                this.y = tt,
                this.z = tt,
                this.w = tt,
                this
            }
            setX(tt) {
                return this.x = tt,
                this
            }
            setY(tt) {
                return this.y = tt,
                this
            }
            setZ(tt) {
                return this.z = tt,
                this
            }
            setW(tt) {
                return this.w = tt,
                this
            }
            setComponent(tt, lt) {
                switch (tt) {
                case 0:
                    this.x = lt;
                    break;
                case 1:
                    this.y = lt;
                    break;
                case 2:
                    this.z = lt;
                    break;
                case 3:
                    this.w = lt;
                    break;
                default:
                    throw new Error("index is out of range: " + tt)
                }
                return this
            }
            getComponent(tt) {
                switch (tt) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw new Error("index is out of range: " + tt)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copy(tt) {
                return this.x = tt.x,
                this.y = tt.y,
                this.z = tt.z,
                this.w = tt.w !== void 0 ? tt.w : 1,
                this
            }
            add(tt) {
                return this.x += tt.x,
                this.y += tt.y,
                this.z += tt.z,
                this.w += tt.w,
                this
            }
            addScalar(tt) {
                return this.x += tt,
                this.y += tt,
                this.z += tt,
                this.w += tt,
                this
            }
            addVectors(tt, lt) {
                return this.x = tt.x + lt.x,
                this.y = tt.y + lt.y,
                this.z = tt.z + lt.z,
                this.w = tt.w + lt.w,
                this
            }
            addScaledVector(tt, lt) {
                return this.x += tt.x * lt,
                this.y += tt.y * lt,
                this.z += tt.z * lt,
                this.w += tt.w * lt,
                this
            }
            sub(tt) {
                return this.x -= tt.x,
                this.y -= tt.y,
                this.z -= tt.z,
                this.w -= tt.w,
                this
            }
            subScalar(tt) {
                return this.x -= tt,
                this.y -= tt,
                this.z -= tt,
                this.w -= tt,
                this
            }
            subVectors(tt, lt) {
                return this.x = tt.x - lt.x,
                this.y = tt.y - lt.y,
                this.z = tt.z - lt.z,
                this.w = tt.w - lt.w,
                this
            }
            multiply(tt) {
                return this.x *= tt.x,
                this.y *= tt.y,
                this.z *= tt.z,
                this.w *= tt.w,
                this
            }
            multiplyScalar(tt) {
                return this.x *= tt,
                this.y *= tt,
                this.z *= tt,
                this.w *= tt,
                this
            }
            applyMatrix4(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = this.w
                  , Ct = tt.elements;
                return this.x = Ct[0] * lt + Ct[4] * mt + Ct[8] * ft + Ct[12] * xt,
                this.y = Ct[1] * lt + Ct[5] * mt + Ct[9] * ft + Ct[13] * xt,
                this.z = Ct[2] * lt + Ct[6] * mt + Ct[10] * ft + Ct[14] * xt,
                this.w = Ct[3] * lt + Ct[7] * mt + Ct[11] * ft + Ct[15] * xt,
                this
            }
            divideScalar(tt) {
                return this.multiplyScalar(1 / tt)
            }
            setAxisAngleFromQuaternion(tt) {
                this.w = 2 * Math.acos(tt.w);
                const lt = Math.sqrt(1 - tt.w * tt.w);
                return lt < 1e-4 ? (this.x = 1,
                this.y = 0,
                this.z = 0) : (this.x = tt.x / lt,
                this.y = tt.y / lt,
                this.z = tt.z / lt),
                this
            }
            setAxisAngleFromRotationMatrix(tt) {
                let lt, mt, ft, xt;
                const Lt = tt.elements
                  , Nt = Lt[0]
                  , jt = Lt[4]
                  , Wt = Lt[8]
                  , Qt = Lt[1]
                  , qt = Lt[5]
                  , Xt = Lt[9]
                  , Zt = Lt[2]
                  , Yt = Lt[6]
                  , sr = Lt[10];
                if (Math.abs(jt - Qt) < .01 && Math.abs(Wt - Zt) < .01 && Math.abs(Xt - Yt) < .01) {
                    if (Math.abs(jt + Qt) < .1 && Math.abs(Wt + Zt) < .1 && Math.abs(Xt + Yt) < .1 && Math.abs(Nt + qt + sr - 3) < .1)
                        return this.set(1, 0, 0, 0),
                        this;
                    lt = Math.PI;
                    const rr = (Nt + 1) / 2
                      , xr = (qt + 1) / 2
                      , br = (sr + 1) / 2
                      , yr = (jt + Qt) / 4
                      , Pr = (Wt + Zt) / 4
                      , zr = (Xt + Yt) / 4;
                    return rr > xr && rr > br ? rr < .01 ? (mt = 0,
                    ft = .707106781,
                    xt = .707106781) : (mt = Math.sqrt(rr),
                    ft = yr / mt,
                    xt = Pr / mt) : xr > br ? xr < .01 ? (mt = .707106781,
                    ft = 0,
                    xt = .707106781) : (ft = Math.sqrt(xr),
                    mt = yr / ft,
                    xt = zr / ft) : br < .01 ? (mt = .707106781,
                    ft = .707106781,
                    xt = 0) : (xt = Math.sqrt(br),
                    mt = Pr / xt,
                    ft = zr / xt),
                    this.set(mt, ft, xt, lt),
                    this
                }
                let er = Math.sqrt((Yt - Xt) * (Yt - Xt) + (Wt - Zt) * (Wt - Zt) + (Qt - jt) * (Qt - jt));
                return Math.abs(er) < .001 && (er = 1),
                this.x = (Yt - Xt) / er,
                this.y = (Wt - Zt) / er,
                this.z = (Qt - jt) / er,
                this.w = Math.acos((Nt + qt + sr - 1) / 2),
                this
            }
            min(tt) {
                return this.x = Math.min(this.x, tt.x),
                this.y = Math.min(this.y, tt.y),
                this.z = Math.min(this.z, tt.z),
                this.w = Math.min(this.w, tt.w),
                this
            }
            max(tt) {
                return this.x = Math.max(this.x, tt.x),
                this.y = Math.max(this.y, tt.y),
                this.z = Math.max(this.z, tt.z),
                this.w = Math.max(this.w, tt.w),
                this
            }
            clamp(tt, lt) {
                return this.x = Math.max(tt.x, Math.min(lt.x, this.x)),
                this.y = Math.max(tt.y, Math.min(lt.y, this.y)),
                this.z = Math.max(tt.z, Math.min(lt.z, this.z)),
                this.w = Math.max(tt.w, Math.min(lt.w, this.w)),
                this
            }
            clampScalar(tt, lt) {
                return this.x = Math.max(tt, Math.min(lt, this.x)),
                this.y = Math.max(tt, Math.min(lt, this.y)),
                this.z = Math.max(tt, Math.min(lt, this.z)),
                this.w = Math.max(tt, Math.min(lt, this.w)),
                this
            }
            clampLength(tt, lt) {
                const mt = this.length();
                return this.divideScalar(mt || 1).multiplyScalar(Math.max(tt, Math.min(lt, mt)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this.w = Math.floor(this.w),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this.w = Math.ceil(this.w),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this.w = Math.round(this.w),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this.w = Math.trunc(this.w),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this.w = -this.w,
                this
            }
            dot(tt) {
                return this.x * tt.x + this.y * tt.y + this.z * tt.z + this.w * tt.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(tt) {
                return this.normalize().multiplyScalar(tt)
            }
            lerp(tt, lt) {
                return this.x += (tt.x - this.x) * lt,
                this.y += (tt.y - this.y) * lt,
                this.z += (tt.z - this.z) * lt,
                this.w += (tt.w - this.w) * lt,
                this
            }
            lerpVectors(tt, lt, mt) {
                return this.x = tt.x + (lt.x - tt.x) * mt,
                this.y = tt.y + (lt.y - tt.y) * mt,
                this.z = tt.z + (lt.z - tt.z) * mt,
                this.w = tt.w + (lt.w - tt.w) * mt,
                this
            }
            equals(tt) {
                return tt.x === this.x && tt.y === this.y && tt.z === this.z && tt.w === this.w
            }
            fromArray(tt, lt=0) {
                return this.x = tt[lt],
                this.y = tt[lt + 1],
                this.z = tt[lt + 2],
                this.w = tt[lt + 3],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.x,
                tt[lt + 1] = this.y,
                tt[lt + 2] = this.z,
                tt[lt + 3] = this.w,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.x = tt.getX(lt),
                this.y = tt.getY(lt),
                this.z = tt.getZ(lt),
                this.w = tt.getW(lt),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this.w = Math.random(),
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z,
                yield this.w
            }
        }
        class nv extends As {
            constructor(tt=1, lt=1, mt={}) {
                super(),
                this.isRenderTarget = !0,
                this.width = tt,
                this.height = lt,
                this.depth = 1,
                this.scissor = new Lo(0,0,tt,lt),
                this.scissorTest = !1,
                this.viewport = new Lo(0,0,tt,lt);
                const ft = {
                    width: tt,
                    height: lt,
                    depth: 1
                };
                mt.encoding !== void 0 && (xu("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),
                mt.colorSpace = mt.encoding === Ol ? jo : Oo),
                mt = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: Rn,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    depthTexture: null,
                    samples: 0
                }, mt),
                this.texture = new Ho(ft,mt.mapping,mt.wrapS,mt.wrapT,mt.magFilter,mt.minFilter,mt.format,mt.type,mt.anisotropy,mt.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.flipY = !1,
                this.texture.generateMipmaps = mt.generateMipmaps,
                this.texture.internalFormat = mt.internalFormat,
                this.depthBuffer = mt.depthBuffer,
                this.stencilBuffer = mt.stencilBuffer,
                this.depthTexture = mt.depthTexture,
                this.samples = mt.samples
            }
            setSize(tt, lt, mt=1) {
                this.width === tt && this.height === lt && this.depth === mt || (this.width = tt,
                this.height = lt,
                this.depth = mt,
                this.texture.image.width = tt,
                this.texture.image.height = lt,
                this.texture.image.depth = mt,
                this.dispose()),
                this.viewport.set(0, 0, tt, lt),
                this.scissor.set(0, 0, tt, lt)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                this.width = tt.width,
                this.height = tt.height,
                this.depth = tt.depth,
                this.scissor.copy(tt.scissor),
                this.scissorTest = tt.scissorTest,
                this.viewport.copy(tt.viewport),
                this.texture = tt.texture.clone(),
                this.texture.isRenderTargetTexture = !0;
                const lt = Object.assign({}, tt.texture.image);
                return this.texture.source = new ga(lt),
                this.depthBuffer = tt.depthBuffer,
                this.stencilBuffer = tt.stencilBuffer,
                tt.depthTexture && (this.depthTexture = tt.depthTexture.clone()),
                this.samples = tt.samples,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Rs extends nv {
            constructor(tt=1, lt=1, mt={}) {
                super(tt, lt, mt),
                this.isWebGLRenderTarget = !0
            }
        }
        class im extends Ho {
            constructor(tt=null, lt=1, mt=1, ft=1) {
                super(null),
                this.isDataArrayTexture = !0,
                this.image = {
                    data: tt,
                    width: lt,
                    height: mt,
                    depth: ft
                },
                this.magFilter = fn,
                this.minFilter = fn,
                this.wrapR = wn,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class n_ extends Rs {
            constructor(tt=1, lt=1, mt=1) {
                super(tt, lt),
                this.isWebGLArrayRenderTarget = !0,
                this.depth = mt,
                this.texture = new im(null,tt,lt,mt),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class i_ extends Ho {
            constructor(tt=null, lt=1, mt=1, ft=1) {
                super(null),
                this.isData3DTexture = !0,
                this.image = {
                    data: tt,
                    width: lt,
                    height: mt,
                    depth: ft
                },
                this.magFilter = fn,
                this.minFilter = fn,
                this.wrapR = wn,
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        class k0 extends Rs {
            constructor(tt=1, lt=1, mt=1) {
                super(tt, lt),
                this.isWebGL3DRenderTarget = !0,
                this.depth = mt,
                this.texture = new i_(null,tt,lt,mt),
                this.texture.isRenderTargetTexture = !0
            }
        }
        class o_ extends Rs {
            constructor(tt=1, lt=1, mt=1, ft={}) {
                super(tt, lt, ft),
                this.isWebGLMultipleRenderTargets = !0;
                const xt = this.texture;
                this.texture = [];
                for (let Ct = 0; Ct < mt; Ct++)
                    this.texture[Ct] = xt.clone(),
                    this.texture[Ct].isRenderTargetTexture = !0
            }
            setSize(tt, lt, mt=1) {
                if (this.width !== tt || this.height !== lt || this.depth !== mt) {
                    this.width = tt,
                    this.height = lt,
                    this.depth = mt;
                    for (let ft = 0, xt = this.texture.length; ft < xt; ft++)
                        this.texture[ft].image.width = tt,
                        this.texture[ft].image.height = lt,
                        this.texture[ft].image.depth = mt;
                    this.dispose()
                }
                this.viewport.set(0, 0, tt, lt),
                this.scissor.set(0, 0, tt, lt)
            }
            copy(tt) {
                this.dispose(),
                this.width = tt.width,
                this.height = tt.height,
                this.depth = tt.depth,
                this.scissor.copy(tt.scissor),
                this.scissorTest = tt.scissorTest,
                this.viewport.copy(tt.viewport),
                this.depthBuffer = tt.depthBuffer,
                this.stencilBuffer = tt.stencilBuffer,
                tt.depthTexture !== null && (this.depthTexture = tt.depthTexture.clone()),
                this.texture.length = 0;
                for (let lt = 0, mt = tt.texture.length; lt < mt; lt++)
                    this.texture[lt] = tt.texture[lt].clone(),
                    this.texture[lt].isRenderTargetTexture = !0;
                return this
            }
        }
        class Is {
            constructor(tt=0, lt=0, mt=0, ft=1) {
                this.isQuaternion = !0,
                this._x = tt,
                this._y = lt,
                this._z = mt,
                this._w = ft
            }
            static slerpFlat(tt, lt, mt, ft, xt, Ct, Mt) {
                let Lt = mt[ft + 0]
                  , Nt = mt[ft + 1]
                  , jt = mt[ft + 2]
                  , Wt = mt[ft + 3];
                const Qt = xt[Ct + 0]
                  , qt = xt[Ct + 1]
                  , Xt = xt[Ct + 2]
                  , Zt = xt[Ct + 3];
                if (Mt === 0)
                    return tt[lt + 0] = Lt,
                    tt[lt + 1] = Nt,
                    tt[lt + 2] = jt,
                    void (tt[lt + 3] = Wt);
                if (Mt === 1)
                    return tt[lt + 0] = Qt,
                    tt[lt + 1] = qt,
                    tt[lt + 2] = Xt,
                    void (tt[lt + 3] = Zt);
                if (Wt !== Zt || Lt !== Qt || Nt !== qt || jt !== Xt) {
                    let Yt = 1 - Mt;
                    const sr = Lt * Qt + Nt * qt + jt * Xt + Wt * Zt
                      , er = sr >= 0 ? 1 : -1
                      , rr = 1 - sr * sr;
                    if (rr > Number.EPSILON) {
                        const br = Math.sqrt(rr)
                          , yr = Math.atan2(br, sr * er);
                        Yt = Math.sin(Yt * yr) / br,
                        Mt = Math.sin(Mt * yr) / br
                    }
                    const xr = Mt * er;
                    if (Lt = Lt * Yt + Qt * xr,
                    Nt = Nt * Yt + qt * xr,
                    jt = jt * Yt + Xt * xr,
                    Wt = Wt * Yt + Zt * xr,
                    Yt === 1 - Mt) {
                        const br = 1 / Math.sqrt(Lt * Lt + Nt * Nt + jt * jt + Wt * Wt);
                        Lt *= br,
                        Nt *= br,
                        jt *= br,
                        Wt *= br
                    }
                }
                tt[lt] = Lt,
                tt[lt + 1] = Nt,
                tt[lt + 2] = jt,
                tt[lt + 3] = Wt
            }
            static multiplyQuaternionsFlat(tt, lt, mt, ft, xt, Ct) {
                const Mt = mt[ft]
                  , Lt = mt[ft + 1]
                  , Nt = mt[ft + 2]
                  , jt = mt[ft + 3]
                  , Wt = xt[Ct]
                  , Qt = xt[Ct + 1]
                  , qt = xt[Ct + 2]
                  , Xt = xt[Ct + 3];
                return tt[lt] = Mt * Xt + jt * Wt + Lt * qt - Nt * Qt,
                tt[lt + 1] = Lt * Xt + jt * Qt + Nt * Wt - Mt * qt,
                tt[lt + 2] = Nt * Xt + jt * qt + Mt * Qt - Lt * Wt,
                tt[lt + 3] = jt * Xt - Mt * Wt - Lt * Qt - Nt * qt,
                tt
            }
            get x() {
                return this._x
            }
            set x(tt) {
                this._x = tt,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(tt) {
                this._y = tt,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(tt) {
                this._z = tt,
                this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(tt) {
                this._w = tt,
                this._onChangeCallback()
            }
            set(tt, lt, mt, ft) {
                return this._x = tt,
                this._y = lt,
                this._z = mt,
                this._w = ft,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copy(tt) {
                return this._x = tt.x,
                this._y = tt.y,
                this._z = tt.z,
                this._w = tt.w,
                this._onChangeCallback(),
                this
            }
            setFromEuler(tt, lt) {
                const mt = tt._x
                  , ft = tt._y
                  , xt = tt._z
                  , Ct = tt._order
                  , Mt = Math.cos
                  , Lt = Math.sin
                  , Nt = Mt(mt / 2)
                  , jt = Mt(ft / 2)
                  , Wt = Mt(xt / 2)
                  , Qt = Lt(mt / 2)
                  , qt = Lt(ft / 2)
                  , Xt = Lt(xt / 2);
                switch (Ct) {
                case "XYZ":
                    this._x = Qt * jt * Wt + Nt * qt * Xt,
                    this._y = Nt * qt * Wt - Qt * jt * Xt,
                    this._z = Nt * jt * Xt + Qt * qt * Wt,
                    this._w = Nt * jt * Wt - Qt * qt * Xt;
                    break;
                case "YXZ":
                    this._x = Qt * jt * Wt + Nt * qt * Xt,
                    this._y = Nt * qt * Wt - Qt * jt * Xt,
                    this._z = Nt * jt * Xt - Qt * qt * Wt,
                    this._w = Nt * jt * Wt + Qt * qt * Xt;
                    break;
                case "ZXY":
                    this._x = Qt * jt * Wt - Nt * qt * Xt,
                    this._y = Nt * qt * Wt + Qt * jt * Xt,
                    this._z = Nt * jt * Xt + Qt * qt * Wt,
                    this._w = Nt * jt * Wt - Qt * qt * Xt;
                    break;
                case "ZYX":
                    this._x = Qt * jt * Wt - Nt * qt * Xt,
                    this._y = Nt * qt * Wt + Qt * jt * Xt,
                    this._z = Nt * jt * Xt - Qt * qt * Wt,
                    this._w = Nt * jt * Wt + Qt * qt * Xt;
                    break;
                case "YZX":
                    this._x = Qt * jt * Wt + Nt * qt * Xt,
                    this._y = Nt * qt * Wt + Qt * jt * Xt,
                    this._z = Nt * jt * Xt - Qt * qt * Wt,
                    this._w = Nt * jt * Wt - Qt * qt * Xt;
                    break;
                case "XZY":
                    this._x = Qt * jt * Wt - Nt * qt * Xt,
                    this._y = Nt * qt * Wt - Qt * jt * Xt,
                    this._z = Nt * jt * Xt + Qt * qt * Wt,
                    this._w = Nt * jt * Wt + Qt * qt * Xt;
                    break;
                default:
                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + Ct)
                }
                return lt !== !1 && this._onChangeCallback(),
                this
            }
            setFromAxisAngle(tt, lt) {
                const mt = lt / 2
                  , ft = Math.sin(mt);
                return this._x = tt.x * ft,
                this._y = tt.y * ft,
                this._z = tt.z * ft,
                this._w = Math.cos(mt),
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(tt) {
                const lt = tt.elements
                  , mt = lt[0]
                  , ft = lt[4]
                  , xt = lt[8]
                  , Ct = lt[1]
                  , Mt = lt[5]
                  , Lt = lt[9]
                  , Nt = lt[2]
                  , jt = lt[6]
                  , Wt = lt[10]
                  , Qt = mt + Mt + Wt;
                if (Qt > 0) {
                    const qt = .5 / Math.sqrt(Qt + 1);
                    this._w = .25 / qt,
                    this._x = (jt - Lt) * qt,
                    this._y = (xt - Nt) * qt,
                    this._z = (Ct - ft) * qt
                } else if (mt > Mt && mt > Wt) {
                    const qt = 2 * Math.sqrt(1 + mt - Mt - Wt);
                    this._w = (jt - Lt) / qt,
                    this._x = .25 * qt,
                    this._y = (ft + Ct) / qt,
                    this._z = (xt + Nt) / qt
                } else if (Mt > Wt) {
                    const qt = 2 * Math.sqrt(1 + Mt - mt - Wt);
                    this._w = (xt - Nt) / qt,
                    this._x = (ft + Ct) / qt,
                    this._y = .25 * qt,
                    this._z = (Lt + jt) / qt
                } else {
                    const qt = 2 * Math.sqrt(1 + Wt - mt - Mt);
                    this._w = (Ct - ft) / qt,
                    this._x = (xt + Nt) / qt,
                    this._y = (Lt + jt) / qt,
                    this._z = .25 * qt
                }
                return this._onChangeCallback(),
                this
            }
            setFromUnitVectors(tt, lt) {
                let mt = tt.dot(lt) + 1;
                return mt < Number.EPSILON ? (mt = 0,
                Math.abs(tt.x) > Math.abs(tt.z) ? (this._x = -tt.y,
                this._y = tt.x,
                this._z = 0,
                this._w = mt) : (this._x = 0,
                this._y = -tt.z,
                this._z = tt.y,
                this._w = mt)) : (this._x = tt.y * lt.z - tt.z * lt.y,
                this._y = tt.z * lt.x - tt.x * lt.z,
                this._z = tt.x * lt.y - tt.y * lt.x,
                this._w = mt),
                this.normalize()
            }
            angleTo(tt) {
                return 2 * Math.acos(Math.abs(qo(this.dot(tt), -1, 1)))
            }
            rotateTowards(tt, lt) {
                const mt = this.angleTo(tt);
                if (mt === 0)
                    return this;
                const ft = Math.min(1, lt / mt);
                return this.slerp(tt, ft),
                this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._onChangeCallback(),
                this
            }
            dot(tt) {
                return this._x * tt._x + this._y * tt._y + this._z * tt._z + this._w * tt._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let tt = this.length();
                return tt === 0 ? (this._x = 0,
                this._y = 0,
                this._z = 0,
                this._w = 1) : (tt = 1 / tt,
                this._x = this._x * tt,
                this._y = this._y * tt,
                this._z = this._z * tt,
                this._w = this._w * tt),
                this._onChangeCallback(),
                this
            }
            multiply(tt) {
                return this.multiplyQuaternions(this, tt)
            }
            premultiply(tt) {
                return this.multiplyQuaternions(tt, this)
            }
            multiplyQuaternions(tt, lt) {
                const mt = tt._x
                  , ft = tt._y
                  , xt = tt._z
                  , Ct = tt._w
                  , Mt = lt._x
                  , Lt = lt._y
                  , Nt = lt._z
                  , jt = lt._w;
                return this._x = mt * jt + Ct * Mt + ft * Nt - xt * Lt,
                this._y = ft * jt + Ct * Lt + xt * Mt - mt * Nt,
                this._z = xt * jt + Ct * Nt + mt * Lt - ft * Mt,
                this._w = Ct * jt - mt * Mt - ft * Lt - xt * Nt,
                this._onChangeCallback(),
                this
            }
            slerp(tt, lt) {
                if (lt === 0)
                    return this;
                if (lt === 1)
                    return this.copy(tt);
                const mt = this._x
                  , ft = this._y
                  , xt = this._z
                  , Ct = this._w;
                let Mt = Ct * tt._w + mt * tt._x + ft * tt._y + xt * tt._z;
                if (Mt < 0 ? (this._w = -tt._w,
                this._x = -tt._x,
                this._y = -tt._y,
                this._z = -tt._z,
                Mt = -Mt) : this.copy(tt),
                Mt >= 1)
                    return this._w = Ct,
                    this._x = mt,
                    this._y = ft,
                    this._z = xt,
                    this;
                const Lt = 1 - Mt * Mt;
                if (Lt <= Number.EPSILON) {
                    const qt = 1 - lt;
                    return this._w = qt * Ct + lt * this._w,
                    this._x = qt * mt + lt * this._x,
                    this._y = qt * ft + lt * this._y,
                    this._z = qt * xt + lt * this._z,
                    this.normalize(),
                    this._onChangeCallback(),
                    this
                }
                const Nt = Math.sqrt(Lt)
                  , jt = Math.atan2(Nt, Mt)
                  , Wt = Math.sin((1 - lt) * jt) / Nt
                  , Qt = Math.sin(lt * jt) / Nt;
                return this._w = Ct * Wt + this._w * Qt,
                this._x = mt * Wt + this._x * Qt,
                this._y = ft * Wt + this._y * Qt,
                this._z = xt * Wt + this._z * Qt,
                this._onChangeCallback(),
                this
            }
            slerpQuaternions(tt, lt, mt) {
                return this.copy(tt).slerp(lt, mt)
            }
            random() {
                const tt = Math.random()
                  , lt = Math.sqrt(1 - tt)
                  , mt = Math.sqrt(tt)
                  , ft = 2 * Math.PI * Math.random()
                  , xt = 2 * Math.PI * Math.random();
                return this.set(lt * Math.cos(ft), mt * Math.sin(xt), mt * Math.cos(xt), lt * Math.sin(ft))
            }
            equals(tt) {
                return tt._x === this._x && tt._y === this._y && tt._z === this._z && tt._w === this._w
            }
            fromArray(tt, lt=0) {
                return this._x = tt[lt],
                this._y = tt[lt + 1],
                this._z = tt[lt + 2],
                this._w = tt[lt + 3],
                this._onChangeCallback(),
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this._x,
                tt[lt + 1] = this._y,
                tt[lt + 2] = this._z,
                tt[lt + 3] = this._w,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this._x = tt.getX(lt),
                this._y = tt.getY(lt),
                this._z = tt.getZ(lt),
                this._w = tt.getW(lt),
                this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(tt) {
                return this._onChangeCallback = tt,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._w
            }
        }
        class Er {
            constructor(tt=0, lt=0, mt=0) {
                Er.prototype.isVector3 = !0,
                this.x = tt,
                this.y = lt,
                this.z = mt
            }
            set(tt, lt, mt) {
                return mt === void 0 && (mt = this.z),
                this.x = tt,
                this.y = lt,
                this.z = mt,
                this
            }
            setScalar(tt) {
                return this.x = tt,
                this.y = tt,
                this.z = tt,
                this
            }
            setX(tt) {
                return this.x = tt,
                this
            }
            setY(tt) {
                return this.y = tt,
                this
            }
            setZ(tt) {
                return this.z = tt,
                this
            }
            setComponent(tt, lt) {
                switch (tt) {
                case 0:
                    this.x = lt;
                    break;
                case 1:
                    this.y = lt;
                    break;
                case 2:
                    this.z = lt;
                    break;
                default:
                    throw new Error("index is out of range: " + tt)
                }
                return this
            }
            getComponent(tt) {
                switch (tt) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw new Error("index is out of range: " + tt)
                }
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z)
            }
            copy(tt) {
                return this.x = tt.x,
                this.y = tt.y,
                this.z = tt.z,
                this
            }
            add(tt) {
                return this.x += tt.x,
                this.y += tt.y,
                this.z += tt.z,
                this
            }
            addScalar(tt) {
                return this.x += tt,
                this.y += tt,
                this.z += tt,
                this
            }
            addVectors(tt, lt) {
                return this.x = tt.x + lt.x,
                this.y = tt.y + lt.y,
                this.z = tt.z + lt.z,
                this
            }
            addScaledVector(tt, lt) {
                return this.x += tt.x * lt,
                this.y += tt.y * lt,
                this.z += tt.z * lt,
                this
            }
            sub(tt) {
                return this.x -= tt.x,
                this.y -= tt.y,
                this.z -= tt.z,
                this
            }
            subScalar(tt) {
                return this.x -= tt,
                this.y -= tt,
                this.z -= tt,
                this
            }
            subVectors(tt, lt) {
                return this.x = tt.x - lt.x,
                this.y = tt.y - lt.y,
                this.z = tt.z - lt.z,
                this
            }
            multiply(tt) {
                return this.x *= tt.x,
                this.y *= tt.y,
                this.z *= tt.z,
                this
            }
            multiplyScalar(tt) {
                return this.x *= tt,
                this.y *= tt,
                this.z *= tt,
                this
            }
            multiplyVectors(tt, lt) {
                return this.x = tt.x * lt.x,
                this.y = tt.y * lt.y,
                this.z = tt.z * lt.z,
                this
            }
            applyEuler(tt) {
                return this.applyQuaternion(om.setFromEuler(tt))
            }
            applyAxisAngle(tt, lt) {
                return this.applyQuaternion(om.setFromAxisAngle(tt, lt))
            }
            applyMatrix3(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.elements;
                return this.x = xt[0] * lt + xt[3] * mt + xt[6] * ft,
                this.y = xt[1] * lt + xt[4] * mt + xt[7] * ft,
                this.z = xt[2] * lt + xt[5] * mt + xt[8] * ft,
                this
            }
            applyNormalMatrix(tt) {
                return this.applyMatrix3(tt).normalize()
            }
            applyMatrix4(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.elements
                  , Ct = 1 / (xt[3] * lt + xt[7] * mt + xt[11] * ft + xt[15]);
                return this.x = (xt[0] * lt + xt[4] * mt + xt[8] * ft + xt[12]) * Ct,
                this.y = (xt[1] * lt + xt[5] * mt + xt[9] * ft + xt[13]) * Ct,
                this.z = (xt[2] * lt + xt[6] * mt + xt[10] * ft + xt[14]) * Ct,
                this
            }
            applyQuaternion(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.x
                  , Ct = tt.y
                  , Mt = tt.z
                  , Lt = tt.w
                  , Nt = Lt * lt + Ct * ft - Mt * mt
                  , jt = Lt * mt + Mt * lt - xt * ft
                  , Wt = Lt * ft + xt * mt - Ct * lt
                  , Qt = -xt * lt - Ct * mt - Mt * ft;
                return this.x = Nt * Lt + Qt * -xt + jt * -Mt - Wt * -Ct,
                this.y = jt * Lt + Qt * -Ct + Wt * -xt - Nt * -Mt,
                this.z = Wt * Lt + Qt * -Mt + Nt * -Ct - jt * -xt,
                this
            }
            project(tt) {
                return this.applyMatrix4(tt.matrixWorldInverse).applyMatrix4(tt.projectionMatrix)
            }
            unproject(tt) {
                return this.applyMatrix4(tt.projectionMatrixInverse).applyMatrix4(tt.matrixWorld)
            }
            transformDirection(tt) {
                const lt = this.x
                  , mt = this.y
                  , ft = this.z
                  , xt = tt.elements;
                return this.x = xt[0] * lt + xt[4] * mt + xt[8] * ft,
                this.y = xt[1] * lt + xt[5] * mt + xt[9] * ft,
                this.z = xt[2] * lt + xt[6] * mt + xt[10] * ft,
                this.normalize()
            }
            divide(tt) {
                return this.x /= tt.x,
                this.y /= tt.y,
                this.z /= tt.z,
                this
            }
            divideScalar(tt) {
                return this.multiplyScalar(1 / tt)
            }
            min(tt) {
                return this.x = Math.min(this.x, tt.x),
                this.y = Math.min(this.y, tt.y),
                this.z = Math.min(this.z, tt.z),
                this
            }
            max(tt) {
                return this.x = Math.max(this.x, tt.x),
                this.y = Math.max(this.y, tt.y),
                this.z = Math.max(this.z, tt.z),
                this
            }
            clamp(tt, lt) {
                return this.x = Math.max(tt.x, Math.min(lt.x, this.x)),
                this.y = Math.max(tt.y, Math.min(lt.y, this.y)),
                this.z = Math.max(tt.z, Math.min(lt.z, this.z)),
                this
            }
            clampScalar(tt, lt) {
                return this.x = Math.max(tt, Math.min(lt, this.x)),
                this.y = Math.max(tt, Math.min(lt, this.y)),
                this.z = Math.max(tt, Math.min(lt, this.z)),
                this
            }
            clampLength(tt, lt) {
                const mt = this.length();
                return this.divideScalar(mt || 1).multiplyScalar(Math.max(tt, Math.min(lt, mt)))
            }
            floor() {
                return this.x = Math.floor(this.x),
                this.y = Math.floor(this.y),
                this.z = Math.floor(this.z),
                this
            }
            ceil() {
                return this.x = Math.ceil(this.x),
                this.y = Math.ceil(this.y),
                this.z = Math.ceil(this.z),
                this
            }
            round() {
                return this.x = Math.round(this.x),
                this.y = Math.round(this.y),
                this.z = Math.round(this.z),
                this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x),
                this.y = Math.trunc(this.y),
                this.z = Math.trunc(this.z),
                this
            }
            negate() {
                return this.x = -this.x,
                this.y = -this.y,
                this.z = -this.z,
                this
            }
            dot(tt) {
                return this.x * tt.x + this.y * tt.y + this.z * tt.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(tt) {
                return this.normalize().multiplyScalar(tt)
            }
            lerp(tt, lt) {
                return this.x += (tt.x - this.x) * lt,
                this.y += (tt.y - this.y) * lt,
                this.z += (tt.z - this.z) * lt,
                this
            }
            lerpVectors(tt, lt, mt) {
                return this.x = tt.x + (lt.x - tt.x) * mt,
                this.y = tt.y + (lt.y - tt.y) * mt,
                this.z = tt.z + (lt.z - tt.z) * mt,
                this
            }
            cross(tt) {
                return this.crossVectors(this, tt)
            }
            crossVectors(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = lt.x
                  , Mt = lt.y
                  , Lt = lt.z;
                return this.x = ft * Lt - xt * Mt,
                this.y = xt * Ct - mt * Lt,
                this.z = mt * Mt - ft * Ct,
                this
            }
            projectOnVector(tt) {
                const lt = tt.lengthSq();
                if (lt === 0)
                    return this.set(0, 0, 0);
                const mt = tt.dot(this) / lt;
                return this.copy(tt).multiplyScalar(mt)
            }
            projectOnPlane(tt) {
                return s_.copy(this).projectOnVector(tt),
                this.sub(s_)
            }
            reflect(tt) {
                return this.sub(s_.copy(tt).multiplyScalar(2 * this.dot(tt)))
            }
            angleTo(tt) {
                const lt = Math.sqrt(this.lengthSq() * tt.lengthSq());
                if (lt === 0)
                    return Math.PI / 2;
                const mt = this.dot(tt) / lt;
                return Math.acos(qo(mt, -1, 1))
            }
            distanceTo(tt) {
                return Math.sqrt(this.distanceToSquared(tt))
            }
            distanceToSquared(tt) {
                const lt = this.x - tt.x
                  , mt = this.y - tt.y
                  , ft = this.z - tt.z;
                return lt * lt + mt * mt + ft * ft
            }
            manhattanDistanceTo(tt) {
                return Math.abs(this.x - tt.x) + Math.abs(this.y - tt.y) + Math.abs(this.z - tt.z)
            }
            setFromSpherical(tt) {
                return this.setFromSphericalCoords(tt.radius, tt.phi, tt.theta)
            }
            setFromSphericalCoords(tt, lt, mt) {
                const ft = Math.sin(lt) * tt;
                return this.x = ft * Math.sin(mt),
                this.y = Math.cos(lt) * tt,
                this.z = ft * Math.cos(mt),
                this
            }
            setFromCylindrical(tt) {
                return this.setFromCylindricalCoords(tt.radius, tt.theta, tt.y)
            }
            setFromCylindricalCoords(tt, lt, mt) {
                return this.x = tt * Math.sin(lt),
                this.y = mt,
                this.z = tt * Math.cos(lt),
                this
            }
            setFromMatrixPosition(tt) {
                const lt = tt.elements;
                return this.x = lt[12],
                this.y = lt[13],
                this.z = lt[14],
                this
            }
            setFromMatrixScale(tt) {
                const lt = this.setFromMatrixColumn(tt, 0).length()
                  , mt = this.setFromMatrixColumn(tt, 1).length()
                  , ft = this.setFromMatrixColumn(tt, 2).length();
                return this.x = lt,
                this.y = mt,
                this.z = ft,
                this
            }
            setFromMatrixColumn(tt, lt) {
                return this.fromArray(tt.elements, 4 * lt)
            }
            setFromMatrix3Column(tt, lt) {
                return this.fromArray(tt.elements, 3 * lt)
            }
            setFromEuler(tt) {
                return this.x = tt._x,
                this.y = tt._y,
                this.z = tt._z,
                this
            }
            setFromColor(tt) {
                return this.x = tt.r,
                this.y = tt.g,
                this.z = tt.b,
                this
            }
            equals(tt) {
                return tt.x === this.x && tt.y === this.y && tt.z === this.z
            }
            fromArray(tt, lt=0) {
                return this.x = tt[lt],
                this.y = tt[lt + 1],
                this.z = tt[lt + 2],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.x,
                tt[lt + 1] = this.y,
                tt[lt + 2] = this.z,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.x = tt.getX(lt),
                this.y = tt.getY(lt),
                this.z = tt.getZ(lt),
                this
            }
            random() {
                return this.x = Math.random(),
                this.y = Math.random(),
                this.z = Math.random(),
                this
            }
            randomDirection() {
                const tt = 2 * (Math.random() - .5)
                  , lt = Math.random() * Math.PI * 2
                  , mt = Math.sqrt(1 - tt ** 2);
                return this.x = mt * Math.cos(lt),
                this.y = mt * Math.sin(lt),
                this.z = tt,
                this
            }
            *[Symbol.iterator]() {
                yield this.x,
                yield this.y,
                yield this.z
            }
        }
        const s_ = new Er
          , om = new Is;
        class Tl {
            constructor(tt=new Er(1 / 0,1 / 0,1 / 0), lt=new Er(-1 / 0,-1 / 0,-1 / 0)) {
                this.isBox3 = !0,
                this.min = tt,
                this.max = lt
            }
            set(tt, lt) {
                return this.min.copy(tt),
                this.max.copy(lt),
                this
            }
            setFromArray(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.length; lt < mt; lt += 3)
                    this.expandByPoint(xa.fromArray(tt, lt));
                return this
            }
            setFromBufferAttribute(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.count; lt < mt; lt++)
                    this.expandByPoint(xa.fromBufferAttribute(tt, lt));
                return this
            }
            setFromPoints(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.length; lt < mt; lt++)
                    this.expandByPoint(tt[lt]);
                return this
            }
            setFromCenterAndSize(tt, lt) {
                const mt = xa.copy(lt).multiplyScalar(.5);
                return this.min.copy(tt).sub(mt),
                this.max.copy(tt).add(mt),
                this
            }
            setFromObject(tt, lt=!1) {
                return this.makeEmpty(),
                this.expandByObject(tt, lt)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.min.copy(tt.min),
                this.max.copy(tt.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(tt) {
                return this.isEmpty() ? tt.set(0, 0, 0) : tt.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(tt) {
                return this.isEmpty() ? tt.set(0, 0, 0) : tt.subVectors(this.max, this.min)
            }
            expandByPoint(tt) {
                return this.min.min(tt),
                this.max.max(tt),
                this
            }
            expandByVector(tt) {
                return this.min.sub(tt),
                this.max.add(tt),
                this
            }
            expandByScalar(tt) {
                return this.min.addScalar(-tt),
                this.max.addScalar(tt),
                this
            }
            expandByObject(tt, lt=!1) {
                if (tt.updateWorldMatrix(!1, !1),
                tt.boundingBox !== void 0)
                    tt.boundingBox === null && tt.computeBoundingBox(),
                    Vu.copy(tt.boundingBox),
                    Vu.applyMatrix4(tt.matrixWorld),
                    this.union(Vu);
                else {
                    const ft = tt.geometry;
                    if (ft !== void 0)
                        if (lt && ft.attributes !== void 0 && ft.attributes.position !== void 0) {
                            const xt = ft.attributes.position;
                            for (let Ct = 0, Mt = xt.count; Ct < Mt; Ct++)
                                xa.fromBufferAttribute(xt, Ct).applyMatrix4(tt.matrixWorld),
                                this.expandByPoint(xa)
                        } else
                            ft.boundingBox === null && ft.computeBoundingBox(),
                            Vu.copy(ft.boundingBox),
                            Vu.applyMatrix4(tt.matrixWorld),
                            this.union(Vu)
                }
                const mt = tt.children;
                for (let ft = 0, xt = mt.length; ft < xt; ft++)
                    this.expandByObject(mt[ft], lt);
                return this
            }
            containsPoint(tt) {
                return !(tt.x < this.min.x || tt.x > this.max.x || tt.y < this.min.y || tt.y > this.max.y || tt.z < this.min.z || tt.z > this.max.z)
            }
            containsBox(tt) {
                return this.min.x <= tt.min.x && tt.max.x <= this.max.x && this.min.y <= tt.min.y && tt.max.y <= this.max.y && this.min.z <= tt.min.z && tt.max.z <= this.max.z
            }
            getParameter(tt, lt) {
                return lt.set((tt.x - this.min.x) / (this.max.x - this.min.x), (tt.y - this.min.y) / (this.max.y - this.min.y), (tt.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(tt) {
                return !(tt.max.x < this.min.x || tt.min.x > this.max.x || tt.max.y < this.min.y || tt.min.y > this.max.y || tt.max.z < this.min.z || tt.min.z > this.max.z)
            }
            intersectsSphere(tt) {
                return this.clampPoint(tt.center, xa),
                xa.distanceToSquared(tt.center) <= tt.radius * tt.radius
            }
            intersectsPlane(tt) {
                let lt, mt;
                return tt.normal.x > 0 ? (lt = tt.normal.x * this.min.x,
                mt = tt.normal.x * this.max.x) : (lt = tt.normal.x * this.max.x,
                mt = tt.normal.x * this.min.x),
                tt.normal.y > 0 ? (lt += tt.normal.y * this.min.y,
                mt += tt.normal.y * this.max.y) : (lt += tt.normal.y * this.max.y,
                mt += tt.normal.y * this.min.y),
                tt.normal.z > 0 ? (lt += tt.normal.z * this.min.z,
                mt += tt.normal.z * this.max.z) : (lt += tt.normal.z * this.max.z,
                mt += tt.normal.z * this.min.z),
                lt <= -tt.constant && mt >= -tt.constant
            }
            intersectsTriangle(tt) {
                if (this.isEmpty())
                    return !1;
                this.getCenter(_p),
                sm.subVectors(this.max, _p),
                Gu.subVectors(tt.a, _p),
                zu.subVectors(tt.b, _p),
                Hu.subVectors(tt.c, _p),
                Cl.subVectors(zu, Gu),
                _c.subVectors(Hu, zu),
                Au.subVectors(Gu, Hu);
                let lt = [0, -Cl.z, Cl.y, 0, -_c.z, _c.y, 0, -Au.z, Au.y, Cl.z, 0, -Cl.x, _c.z, 0, -_c.x, Au.z, 0, -Au.x, -Cl.y, Cl.x, 0, -_c.y, _c.x, 0, -Au.y, Au.x, 0];
                return !!Pl(lt, Gu, zu, Hu, sm) && (lt = [1, 0, 0, 0, 1, 0, 0, 0, 1],
                !!Pl(lt, Gu, zu, Hu, sm) && (am.crossVectors(Cl, _c),
                lt = [am.x, am.y, am.z],
                Pl(lt, Gu, zu, Hu, sm)))
            }
            clampPoint(tt, lt) {
                return lt.copy(tt).clamp(this.min, this.max)
            }
            distanceToPoint(tt) {
                return this.clampPoint(tt, xa).distanceTo(tt)
            }
            getBoundingSphere(tt) {
                return this.isEmpty() ? tt.makeEmpty() : (this.getCenter(tt.center),
                tt.radius = .5 * this.getSize(xa).length()),
                tt
            }
            intersect(tt) {
                return this.min.max(tt.min),
                this.max.min(tt.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(tt) {
                return this.min.min(tt.min),
                this.max.max(tt.max),
                this
            }
            applyMatrix4(tt) {
                return this.isEmpty() || (Nl[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(tt),
                Nl[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(tt),
                Nl[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(tt),
                Nl[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(tt),
                Nl[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(tt),
                Nl[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(tt),
                Nl[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(tt),
                Nl[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(tt),
                this.setFromPoints(Nl)),
                this
            }
            translate(tt) {
                return this.min.add(tt),
                this.max.add(tt),
                this
            }
            equals(tt) {
                return tt.min.equals(this.min) && tt.max.equals(this.max)
            }
        }
        const Nl = [new Er, new Er, new Er, new Er, new Er, new Er, new Er, new Er]
          , xa = new Er
          , Vu = new Tl
          , Gu = new Er
          , zu = new Er
          , Hu = new Er
          , Cl = new Er
          , _c = new Er
          , Au = new Er
          , _p = new Er
          , sm = new Er
          , am = new Er
          , wu = new Er;
        function Pl(Tt, tt, lt, mt, ft) {
            for (let xt = 0, Ct = Tt.length - 3; xt <= Ct; xt += 3) {
                wu.fromArray(Tt, xt);
                const Mt = ft.x * Math.abs(wu.x) + ft.y * Math.abs(wu.y) + ft.z * Math.abs(wu.z)
                  , Lt = tt.dot(wu)
                  , Nt = lt.dot(wu)
                  , jt = mt.dot(wu);
                if (Math.max(-Math.max(Lt, Nt, jt), Math.min(Lt, Nt, jt)) > Mt)
                    return !1
            }
            return !0
        }
        const iv = new Tl
          , vp = new Er
          , yp = new Er;
        class Ws {
            constructor(tt=new Er, lt=-1) {
                this.center = tt,
                this.radius = lt
            }
            set(tt, lt) {
                return this.center.copy(tt),
                this.radius = lt,
                this
            }
            setFromPoints(tt, lt) {
                const mt = this.center;
                lt !== void 0 ? mt.copy(lt) : iv.setFromPoints(tt).getCenter(mt);
                let ft = 0;
                for (let xt = 0, Ct = tt.length; xt < Ct; xt++)
                    ft = Math.max(ft, mt.distanceToSquared(tt[xt]));
                return this.radius = Math.sqrt(ft),
                this
            }
            copy(tt) {
                return this.center.copy(tt.center),
                this.radius = tt.radius,
                this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0),
                this.radius = -1,
                this
            }
            containsPoint(tt) {
                return tt.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(tt) {
                return tt.distanceTo(this.center) - this.radius
            }
            intersectsSphere(tt) {
                const lt = this.radius + tt.radius;
                return tt.center.distanceToSquared(this.center) <= lt * lt
            }
            intersectsBox(tt) {
                return tt.intersectsSphere(this)
            }
            intersectsPlane(tt) {
                return Math.abs(tt.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(tt, lt) {
                const mt = this.center.distanceToSquared(tt);
                return lt.copy(tt),
                mt > this.radius * this.radius && (lt.sub(this.center).normalize(),
                lt.multiplyScalar(this.radius).add(this.center)),
                lt
            }
            getBoundingBox(tt) {
                return this.isEmpty() ? (tt.makeEmpty(),
                tt) : (tt.set(this.center, this.center),
                tt.expandByScalar(this.radius),
                tt)
            }
            applyMatrix4(tt) {
                return this.center.applyMatrix4(tt),
                this.radius = this.radius * tt.getMaxScaleOnAxis(),
                this
            }
            translate(tt) {
                return this.center.add(tt),
                this
            }
            expandByPoint(tt) {
                if (this.isEmpty())
                    return this.center.copy(tt),
                    this.radius = 0,
                    this;
                vp.subVectors(tt, this.center);
                const lt = vp.lengthSq();
                if (lt > this.radius * this.radius) {
                    const mt = Math.sqrt(lt)
                      , ft = .5 * (mt - this.radius);
                    this.center.addScaledVector(vp, ft / mt),
                    this.radius += ft
                }
                return this
            }
            union(tt) {
                return tt.isEmpty() ? this : this.isEmpty() ? (this.copy(tt),
                this) : (this.center.equals(tt.center) === !0 ? this.radius = Math.max(this.radius, tt.radius) : (yp.subVectors(tt.center, this.center).setLength(tt.radius),
                this.expandByPoint(vp.copy(tt.center).add(yp)),
                this.expandByPoint(vp.copy(tt.center).sub(yp))),
                this)
            }
            equals(tt) {
                return tt.center.equals(this.center) && tt.radius === this.radius
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const Ml = new Er
          , a_ = new Er
          , ba = new Er
          , Fl = new Er
          , eu = new Er
          , lm = new Er
          , Rl = new Er;
        class Qu {
            constructor(tt=new Er, lt=new Er(0,0,-1)) {
                this.origin = tt,
                this.direction = lt
            }
            set(tt, lt) {
                return this.origin.copy(tt),
                this.direction.copy(lt),
                this
            }
            copy(tt) {
                return this.origin.copy(tt.origin),
                this.direction.copy(tt.direction),
                this
            }
            at(tt, lt) {
                return lt.copy(this.origin).addScaledVector(this.direction, tt)
            }
            lookAt(tt) {
                return this.direction.copy(tt).sub(this.origin).normalize(),
                this
            }
            recast(tt) {
                return this.origin.copy(this.at(tt, Ml)),
                this
            }
            closestPointToPoint(tt, lt) {
                lt.subVectors(tt, this.origin);
                const mt = lt.dot(this.direction);
                return mt < 0 ? lt.copy(this.origin) : lt.copy(this.origin).addScaledVector(this.direction, mt)
            }
            distanceToPoint(tt) {
                return Math.sqrt(this.distanceSqToPoint(tt))
            }
            distanceSqToPoint(tt) {
                const lt = Ml.subVectors(tt, this.origin).dot(this.direction);
                return lt < 0 ? this.origin.distanceToSquared(tt) : (Ml.copy(this.origin).addScaledVector(this.direction, lt),
                Ml.distanceToSquared(tt))
            }
            distanceSqToSegment(tt, lt, mt, ft) {
                a_.copy(tt).add(lt).multiplyScalar(.5),
                ba.copy(lt).sub(tt).normalize(),
                Fl.copy(this.origin).sub(a_);
                const xt = .5 * tt.distanceTo(lt)
                  , Ct = -this.direction.dot(ba)
                  , Mt = Fl.dot(this.direction)
                  , Lt = -Fl.dot(ba)
                  , Nt = Fl.lengthSq()
                  , jt = Math.abs(1 - Ct * Ct);
                let Wt, Qt, qt, Xt;
                if (jt > 0)
                    if (Wt = Ct * Lt - Mt,
                    Qt = Ct * Mt - Lt,
                    Xt = xt * jt,
                    Wt >= 0)
                        if (Qt >= -Xt)
                            if (Qt <= Xt) {
                                const Zt = 1 / jt;
                                Wt *= Zt,
                                Qt *= Zt,
                                qt = Wt * (Wt + Ct * Qt + 2 * Mt) + Qt * (Ct * Wt + Qt + 2 * Lt) + Nt
                            } else
                                Qt = xt,
                                Wt = Math.max(0, -(Ct * Qt + Mt)),
                                qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt;
                        else
                            Qt = -xt,
                            Wt = Math.max(0, -(Ct * Qt + Mt)),
                            qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt;
                    else
                        Qt <= -Xt ? (Wt = Math.max(0, -(-Ct * xt + Mt)),
                        Qt = Wt > 0 ? -xt : Math.min(Math.max(-xt, -Lt), xt),
                        qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt) : Qt <= Xt ? (Wt = 0,
                        Qt = Math.min(Math.max(-xt, -Lt), xt),
                        qt = Qt * (Qt + 2 * Lt) + Nt) : (Wt = Math.max(0, -(Ct * xt + Mt)),
                        Qt = Wt > 0 ? xt : Math.min(Math.max(-xt, -Lt), xt),
                        qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt);
                else
                    Qt = Ct > 0 ? -xt : xt,
                    Wt = Math.max(0, -(Ct * Qt + Mt)),
                    qt = -Wt * Wt + Qt * (Qt + 2 * Lt) + Nt;
                return mt && mt.copy(this.origin).addScaledVector(this.direction, Wt),
                ft && ft.copy(a_).addScaledVector(ba, Qt),
                qt
            }
            intersectSphere(tt, lt) {
                Ml.subVectors(tt.center, this.origin);
                const mt = Ml.dot(this.direction)
                  , ft = Ml.dot(Ml) - mt * mt
                  , xt = tt.radius * tt.radius;
                if (ft > xt)
                    return null;
                const Ct = Math.sqrt(xt - ft)
                  , Mt = mt - Ct
                  , Lt = mt + Ct;
                return Lt < 0 ? null : Mt < 0 ? this.at(Lt, lt) : this.at(Mt, lt)
            }
            intersectsSphere(tt) {
                return this.distanceSqToPoint(tt.center) <= tt.radius * tt.radius
            }
            distanceToPlane(tt) {
                const lt = tt.normal.dot(this.direction);
                if (lt === 0)
                    return tt.distanceToPoint(this.origin) === 0 ? 0 : null;
                const mt = -(this.origin.dot(tt.normal) + tt.constant) / lt;
                return mt >= 0 ? mt : null
            }
            intersectPlane(tt, lt) {
                const mt = this.distanceToPlane(tt);
                return mt === null ? null : this.at(mt, lt)
            }
            intersectsPlane(tt) {
                const lt = tt.distanceToPoint(this.origin);
                return lt === 0 || tt.normal.dot(this.direction) * lt < 0
            }
            intersectBox(tt, lt) {
                let mt, ft, xt, Ct, Mt, Lt;
                const Nt = 1 / this.direction.x
                  , jt = 1 / this.direction.y
                  , Wt = 1 / this.direction.z
                  , Qt = this.origin;
                return Nt >= 0 ? (mt = (tt.min.x - Qt.x) * Nt,
                ft = (tt.max.x - Qt.x) * Nt) : (mt = (tt.max.x - Qt.x) * Nt,
                ft = (tt.min.x - Qt.x) * Nt),
                jt >= 0 ? (xt = (tt.min.y - Qt.y) * jt,
                Ct = (tt.max.y - Qt.y) * jt) : (xt = (tt.max.y - Qt.y) * jt,
                Ct = (tt.min.y - Qt.y) * jt),
                mt > Ct || xt > ft ? null : ((xt > mt || isNaN(mt)) && (mt = xt),
                (Ct < ft || isNaN(ft)) && (ft = Ct),
                Wt >= 0 ? (Mt = (tt.min.z - Qt.z) * Wt,
                Lt = (tt.max.z - Qt.z) * Wt) : (Mt = (tt.max.z - Qt.z) * Wt,
                Lt = (tt.min.z - Qt.z) * Wt),
                mt > Lt || Mt > ft ? null : ((Mt > mt || mt != mt) && (mt = Mt),
                (Lt < ft || ft != ft) && (ft = Lt),
                ft < 0 ? null : this.at(mt >= 0 ? mt : ft, lt)))
            }
            intersectsBox(tt) {
                return this.intersectBox(tt, Ml) !== null
            }
            intersectTriangle(tt, lt, mt, ft, xt) {
                eu.subVectors(lt, tt),
                lm.subVectors(mt, tt),
                Rl.crossVectors(eu, lm);
                let Ct, Mt = this.direction.dot(Rl);
                if (Mt > 0) {
                    if (ft)
                        return null;
                    Ct = 1
                } else {
                    if (!(Mt < 0))
                        return null;
                    Ct = -1,
                    Mt = -Mt
                }
                Fl.subVectors(this.origin, tt);
                const Lt = Ct * this.direction.dot(lm.crossVectors(Fl, lm));
                if (Lt < 0)
                    return null;
                const Nt = Ct * this.direction.dot(eu.cross(Fl));
                if (Nt < 0 || Lt + Nt > Mt)
                    return null;
                const jt = -Ct * Fl.dot(Rl);
                return jt < 0 ? null : this.at(jt / Mt, xt)
            }
            applyMatrix4(tt) {
                return this.origin.applyMatrix4(tt),
                this.direction.transformDirection(tt),
                this
            }
            equals(tt) {
                return tt.origin.equals(this.origin) && tt.direction.equals(this.direction)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class no {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt, qt, Xt, Zt, Yt) {
                no.prototype.isMatrix4 = !0,
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                tt !== void 0 && this.set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt, qt, Xt, Zt, Yt)
            }
            set(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt, qt, Xt, Zt, Yt) {
                const sr = this.elements;
                return sr[0] = tt,
                sr[4] = lt,
                sr[8] = mt,
                sr[12] = ft,
                sr[1] = xt,
                sr[5] = Ct,
                sr[9] = Mt,
                sr[13] = Lt,
                sr[2] = Nt,
                sr[6] = jt,
                sr[10] = Wt,
                sr[14] = Qt,
                sr[3] = qt,
                sr[7] = Xt,
                sr[11] = Zt,
                sr[15] = Yt,
                this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            clone() {
                return new no().fromArray(this.elements)
            }
            copy(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                return lt[0] = mt[0],
                lt[1] = mt[1],
                lt[2] = mt[2],
                lt[3] = mt[3],
                lt[4] = mt[4],
                lt[5] = mt[5],
                lt[6] = mt[6],
                lt[7] = mt[7],
                lt[8] = mt[8],
                lt[9] = mt[9],
                lt[10] = mt[10],
                lt[11] = mt[11],
                lt[12] = mt[12],
                lt[13] = mt[13],
                lt[14] = mt[14],
                lt[15] = mt[15],
                this
            }
            copyPosition(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                return lt[12] = mt[12],
                lt[13] = mt[13],
                lt[14] = mt[14],
                this
            }
            setFromMatrix3(tt) {
                const lt = tt.elements;
                return this.set(lt[0], lt[3], lt[6], 0, lt[1], lt[4], lt[7], 0, lt[2], lt[5], lt[8], 0, 0, 0, 0, 1),
                this
            }
            extractBasis(tt, lt, mt) {
                return tt.setFromMatrixColumn(this, 0),
                lt.setFromMatrixColumn(this, 1),
                mt.setFromMatrixColumn(this, 2),
                this
            }
            makeBasis(tt, lt, mt) {
                return this.set(tt.x, lt.x, mt.x, 0, tt.y, lt.y, mt.y, 0, tt.z, lt.z, mt.z, 0, 0, 0, 0, 1),
                this
            }
            extractRotation(tt) {
                const lt = this.elements
                  , mt = tt.elements
                  , ft = 1 / Wu.setFromMatrixColumn(tt, 0).length()
                  , xt = 1 / Wu.setFromMatrixColumn(tt, 1).length()
                  , Ct = 1 / Wu.setFromMatrixColumn(tt, 2).length();
                return lt[0] = mt[0] * ft,
                lt[1] = mt[1] * ft,
                lt[2] = mt[2] * ft,
                lt[3] = 0,
                lt[4] = mt[4] * xt,
                lt[5] = mt[5] * xt,
                lt[6] = mt[6] * xt,
                lt[7] = 0,
                lt[8] = mt[8] * Ct,
                lt[9] = mt[9] * Ct,
                lt[10] = mt[10] * Ct,
                lt[11] = 0,
                lt[12] = 0,
                lt[13] = 0,
                lt[14] = 0,
                lt[15] = 1,
                this
            }
            makeRotationFromEuler(tt) {
                const lt = this.elements
                  , mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = Math.cos(mt)
                  , Mt = Math.sin(mt)
                  , Lt = Math.cos(ft)
                  , Nt = Math.sin(ft)
                  , jt = Math.cos(xt)
                  , Wt = Math.sin(xt);
                if (tt.order === "XYZ") {
                    const Qt = Ct * jt
                      , qt = Ct * Wt
                      , Xt = Mt * jt
                      , Zt = Mt * Wt;
                    lt[0] = Lt * jt,
                    lt[4] = -Lt * Wt,
                    lt[8] = Nt,
                    lt[1] = qt + Xt * Nt,
                    lt[5] = Qt - Zt * Nt,
                    lt[9] = -Mt * Lt,
                    lt[2] = Zt - Qt * Nt,
                    lt[6] = Xt + qt * Nt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "YXZ") {
                    const Qt = Lt * jt
                      , qt = Lt * Wt
                      , Xt = Nt * jt
                      , Zt = Nt * Wt;
                    lt[0] = Qt + Zt * Mt,
                    lt[4] = Xt * Mt - qt,
                    lt[8] = Ct * Nt,
                    lt[1] = Ct * Wt,
                    lt[5] = Ct * jt,
                    lt[9] = -Mt,
                    lt[2] = qt * Mt - Xt,
                    lt[6] = Zt + Qt * Mt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "ZXY") {
                    const Qt = Lt * jt
                      , qt = Lt * Wt
                      , Xt = Nt * jt
                      , Zt = Nt * Wt;
                    lt[0] = Qt - Zt * Mt,
                    lt[4] = -Ct * Wt,
                    lt[8] = Xt + qt * Mt,
                    lt[1] = qt + Xt * Mt,
                    lt[5] = Ct * jt,
                    lt[9] = Zt - Qt * Mt,
                    lt[2] = -Ct * Nt,
                    lt[6] = Mt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "ZYX") {
                    const Qt = Ct * jt
                      , qt = Ct * Wt
                      , Xt = Mt * jt
                      , Zt = Mt * Wt;
                    lt[0] = Lt * jt,
                    lt[4] = Xt * Nt - qt,
                    lt[8] = Qt * Nt + Zt,
                    lt[1] = Lt * Wt,
                    lt[5] = Zt * Nt + Qt,
                    lt[9] = qt * Nt - Xt,
                    lt[2] = -Nt,
                    lt[6] = Mt * Lt,
                    lt[10] = Ct * Lt
                } else if (tt.order === "YZX") {
                    const Qt = Ct * Lt
                      , qt = Ct * Nt
                      , Xt = Mt * Lt
                      , Zt = Mt * Nt;
                    lt[0] = Lt * jt,
                    lt[4] = Zt - Qt * Wt,
                    lt[8] = Xt * Wt + qt,
                    lt[1] = Wt,
                    lt[5] = Ct * jt,
                    lt[9] = -Mt * jt,
                    lt[2] = -Nt * jt,
                    lt[6] = qt * Wt + Xt,
                    lt[10] = Qt - Zt * Wt
                } else if (tt.order === "XZY") {
                    const Qt = Ct * Lt
                      , qt = Ct * Nt
                      , Xt = Mt * Lt
                      , Zt = Mt * Nt;
                    lt[0] = Lt * jt,
                    lt[4] = -Wt,
                    lt[8] = Nt * jt,
                    lt[1] = Qt * Wt + Zt,
                    lt[5] = Ct * jt,
                    lt[9] = qt * Wt - Xt,
                    lt[2] = Xt * Wt - qt,
                    lt[6] = Mt * jt,
                    lt[10] = Zt * Wt + Qt
                }
                return lt[3] = 0,
                lt[7] = 0,
                lt[11] = 0,
                lt[12] = 0,
                lt[13] = 0,
                lt[14] = 0,
                lt[15] = 1,
                this
            }
            makeRotationFromQuaternion(tt) {
                return this.compose(qu, tt, ov)
            }
            lookAt(tt, lt, mt) {
                const ft = this.elements;
                return Ss.subVectors(tt, lt),
                Ss.lengthSq() === 0 && (Ss.z = 1),
                Ss.normalize(),
                tu.crossVectors(mt, Ss),
                tu.lengthSq() === 0 && (Math.abs(mt.z) === 1 ? Ss.x += 1e-4 : Ss.z += 1e-4,
                Ss.normalize(),
                tu.crossVectors(mt, Ss)),
                tu.normalize(),
                cm.crossVectors(Ss, tu),
                ft[0] = tu.x,
                ft[4] = cm.x,
                ft[8] = Ss.x,
                ft[1] = tu.y,
                ft[5] = cm.y,
                ft[9] = Ss.y,
                ft[2] = tu.z,
                ft[6] = cm.z,
                ft[10] = Ss.z,
                this
            }
            multiply(tt) {
                return this.multiplyMatrices(this, tt)
            }
            premultiply(tt) {
                return this.multiplyMatrices(tt, this)
            }
            multiplyMatrices(tt, lt) {
                const mt = tt.elements
                  , ft = lt.elements
                  , xt = this.elements
                  , Ct = mt[0]
                  , Mt = mt[4]
                  , Lt = mt[8]
                  , Nt = mt[12]
                  , jt = mt[1]
                  , Wt = mt[5]
                  , Qt = mt[9]
                  , qt = mt[13]
                  , Xt = mt[2]
                  , Zt = mt[6]
                  , Yt = mt[10]
                  , sr = mt[14]
                  , er = mt[3]
                  , rr = mt[7]
                  , xr = mt[11]
                  , br = mt[15]
                  , yr = ft[0]
                  , Pr = ft[4]
                  , zr = ft[8]
                  , Nr = ft[12]
                  , Vr = ft[1]
                  , Gr = ft[5]
                  , Hr = ft[9]
                  , _n = ft[13]
                  , dn = ft[2]
                  , kn = ft[6]
                  , Bn = ft[10]
                  , cn = ft[14]
                  , Yr = ft[3]
                  , Jr = ft[7]
                  , sn = ft[11]
                  , on = ft[15];
                return xt[0] = Ct * yr + Mt * Vr + Lt * dn + Nt * Yr,
                xt[4] = Ct * Pr + Mt * Gr + Lt * kn + Nt * Jr,
                xt[8] = Ct * zr + Mt * Hr + Lt * Bn + Nt * sn,
                xt[12] = Ct * Nr + Mt * _n + Lt * cn + Nt * on,
                xt[1] = jt * yr + Wt * Vr + Qt * dn + qt * Yr,
                xt[5] = jt * Pr + Wt * Gr + Qt * kn + qt * Jr,
                xt[9] = jt * zr + Wt * Hr + Qt * Bn + qt * sn,
                xt[13] = jt * Nr + Wt * _n + Qt * cn + qt * on,
                xt[2] = Xt * yr + Zt * Vr + Yt * dn + sr * Yr,
                xt[6] = Xt * Pr + Zt * Gr + Yt * kn + sr * Jr,
                xt[10] = Xt * zr + Zt * Hr + Yt * Bn + sr * sn,
                xt[14] = Xt * Nr + Zt * _n + Yt * cn + sr * on,
                xt[3] = er * yr + rr * Vr + xr * dn + br * Yr,
                xt[7] = er * Pr + rr * Gr + xr * kn + br * Jr,
                xt[11] = er * zr + rr * Hr + xr * Bn + br * sn,
                xt[15] = er * Nr + rr * _n + xr * cn + br * on,
                this
            }
            multiplyScalar(tt) {
                const lt = this.elements;
                return lt[0] *= tt,
                lt[4] *= tt,
                lt[8] *= tt,
                lt[12] *= tt,
                lt[1] *= tt,
                lt[5] *= tt,
                lt[9] *= tt,
                lt[13] *= tt,
                lt[2] *= tt,
                lt[6] *= tt,
                lt[10] *= tt,
                lt[14] *= tt,
                lt[3] *= tt,
                lt[7] *= tt,
                lt[11] *= tt,
                lt[15] *= tt,
                this
            }
            determinant() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[4]
                  , ft = tt[8]
                  , xt = tt[12]
                  , Ct = tt[1]
                  , Mt = tt[5]
                  , Lt = tt[9]
                  , Nt = tt[13]
                  , jt = tt[2]
                  , Wt = tt[6]
                  , Qt = tt[10]
                  , qt = tt[14];
                return tt[3] * (+xt * Lt * Wt - ft * Nt * Wt - xt * Mt * Qt + mt * Nt * Qt + ft * Mt * qt - mt * Lt * qt) + tt[7] * (+lt * Lt * qt - lt * Nt * Qt + xt * Ct * Qt - ft * Ct * qt + ft * Nt * jt - xt * Lt * jt) + tt[11] * (+lt * Nt * Wt - lt * Mt * qt - xt * Ct * Wt + mt * Ct * qt + xt * Mt * jt - mt * Nt * jt) + tt[15] * (-ft * Mt * jt - lt * Lt * Wt + lt * Mt * Qt + ft * Ct * Wt - mt * Ct * Qt + mt * Lt * jt)
            }
            transpose() {
                const tt = this.elements;
                let lt;
                return lt = tt[1],
                tt[1] = tt[4],
                tt[4] = lt,
                lt = tt[2],
                tt[2] = tt[8],
                tt[8] = lt,
                lt = tt[6],
                tt[6] = tt[9],
                tt[9] = lt,
                lt = tt[3],
                tt[3] = tt[12],
                tt[12] = lt,
                lt = tt[7],
                tt[7] = tt[13],
                tt[13] = lt,
                lt = tt[11],
                tt[11] = tt[14],
                tt[14] = lt,
                this
            }
            setPosition(tt, lt, mt) {
                const ft = this.elements;
                return tt.isVector3 ? (ft[12] = tt.x,
                ft[13] = tt.y,
                ft[14] = tt.z) : (ft[12] = tt,
                ft[13] = lt,
                ft[14] = mt),
                this
            }
            invert() {
                const tt = this.elements
                  , lt = tt[0]
                  , mt = tt[1]
                  , ft = tt[2]
                  , xt = tt[3]
                  , Ct = tt[4]
                  , Mt = tt[5]
                  , Lt = tt[6]
                  , Nt = tt[7]
                  , jt = tt[8]
                  , Wt = tt[9]
                  , Qt = tt[10]
                  , qt = tt[11]
                  , Xt = tt[12]
                  , Zt = tt[13]
                  , Yt = tt[14]
                  , sr = tt[15]
                  , er = Wt * Yt * Nt - Zt * Qt * Nt + Zt * Lt * qt - Mt * Yt * qt - Wt * Lt * sr + Mt * Qt * sr
                  , rr = Xt * Qt * Nt - jt * Yt * Nt - Xt * Lt * qt + Ct * Yt * qt + jt * Lt * sr - Ct * Qt * sr
                  , xr = jt * Zt * Nt - Xt * Wt * Nt + Xt * Mt * qt - Ct * Zt * qt - jt * Mt * sr + Ct * Wt * sr
                  , br = Xt * Wt * Lt - jt * Zt * Lt - Xt * Mt * Qt + Ct * Zt * Qt + jt * Mt * Yt - Ct * Wt * Yt
                  , yr = lt * er + mt * rr + ft * xr + xt * br;
                if (yr === 0)
                    return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const Pr = 1 / yr;
                return tt[0] = er * Pr,
                tt[1] = (Zt * Qt * xt - Wt * Yt * xt - Zt * ft * qt + mt * Yt * qt + Wt * ft * sr - mt * Qt * sr) * Pr,
                tt[2] = (Mt * Yt * xt - Zt * Lt * xt + Zt * ft * Nt - mt * Yt * Nt - Mt * ft * sr + mt * Lt * sr) * Pr,
                tt[3] = (Wt * Lt * xt - Mt * Qt * xt - Wt * ft * Nt + mt * Qt * Nt + Mt * ft * qt - mt * Lt * qt) * Pr,
                tt[4] = rr * Pr,
                tt[5] = (jt * Yt * xt - Xt * Qt * xt + Xt * ft * qt - lt * Yt * qt - jt * ft * sr + lt * Qt * sr) * Pr,
                tt[6] = (Xt * Lt * xt - Ct * Yt * xt - Xt * ft * Nt + lt * Yt * Nt + Ct * ft * sr - lt * Lt * sr) * Pr,
                tt[7] = (Ct * Qt * xt - jt * Lt * xt + jt * ft * Nt - lt * Qt * Nt - Ct * ft * qt + lt * Lt * qt) * Pr,
                tt[8] = xr * Pr,
                tt[9] = (Xt * Wt * xt - jt * Zt * xt - Xt * mt * qt + lt * Zt * qt + jt * mt * sr - lt * Wt * sr) * Pr,
                tt[10] = (Ct * Zt * xt - Xt * Mt * xt + Xt * mt * Nt - lt * Zt * Nt - Ct * mt * sr + lt * Mt * sr) * Pr,
                tt[11] = (jt * Mt * xt - Ct * Wt * xt - jt * mt * Nt + lt * Wt * Nt + Ct * mt * qt - lt * Mt * qt) * Pr,
                tt[12] = br * Pr,
                tt[13] = (jt * Zt * ft - Xt * Wt * ft + Xt * mt * Qt - lt * Zt * Qt - jt * mt * Yt + lt * Wt * Yt) * Pr,
                tt[14] = (Xt * Mt * ft - Ct * Zt * ft - Xt * mt * Lt + lt * Zt * Lt + Ct * mt * Yt - lt * Mt * Yt) * Pr,
                tt[15] = (Ct * Wt * ft - jt * Mt * ft + jt * mt * Lt - lt * Wt * Lt - Ct * mt * Qt + lt * Mt * Qt) * Pr,
                this
            }
            scale(tt) {
                const lt = this.elements
                  , mt = tt.x
                  , ft = tt.y
                  , xt = tt.z;
                return lt[0] *= mt,
                lt[4] *= ft,
                lt[8] *= xt,
                lt[1] *= mt,
                lt[5] *= ft,
                lt[9] *= xt,
                lt[2] *= mt,
                lt[6] *= ft,
                lt[10] *= xt,
                lt[3] *= mt,
                lt[7] *= ft,
                lt[11] *= xt,
                this
            }
            getMaxScaleOnAxis() {
                const tt = this.elements
                  , lt = tt[0] * tt[0] + tt[1] * tt[1] + tt[2] * tt[2]
                  , mt = tt[4] * tt[4] + tt[5] * tt[5] + tt[6] * tt[6]
                  , ft = tt[8] * tt[8] + tt[9] * tt[9] + tt[10] * tt[10];
                return Math.sqrt(Math.max(lt, mt, ft))
            }
            makeTranslation(tt, lt, mt) {
                return tt.isVector3 ? this.set(1, 0, 0, tt.x, 0, 1, 0, tt.y, 0, 0, 1, tt.z, 0, 0, 0, 1) : this.set(1, 0, 0, tt, 0, 1, 0, lt, 0, 0, 1, mt, 0, 0, 0, 1),
                this
            }
            makeRotationX(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(1, 0, 0, 0, 0, lt, -mt, 0, 0, mt, lt, 0, 0, 0, 0, 1),
                this
            }
            makeRotationY(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(lt, 0, mt, 0, 0, 1, 0, 0, -mt, 0, lt, 0, 0, 0, 0, 1),
                this
            }
            makeRotationZ(tt) {
                const lt = Math.cos(tt)
                  , mt = Math.sin(tt);
                return this.set(lt, -mt, 0, 0, mt, lt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            }
            makeRotationAxis(tt, lt) {
                const mt = Math.cos(lt)
                  , ft = Math.sin(lt)
                  , xt = 1 - mt
                  , Ct = tt.x
                  , Mt = tt.y
                  , Lt = tt.z
                  , Nt = xt * Ct
                  , jt = xt * Mt;
                return this.set(Nt * Ct + mt, Nt * Mt - ft * Lt, Nt * Lt + ft * Mt, 0, Nt * Mt + ft * Lt, jt * Mt + mt, jt * Lt - ft * Ct, 0, Nt * Lt - ft * Mt, jt * Lt + ft * Ct, xt * Lt * Lt + mt, 0, 0, 0, 0, 1),
                this
            }
            makeScale(tt, lt, mt) {
                return this.set(tt, 0, 0, 0, 0, lt, 0, 0, 0, 0, mt, 0, 0, 0, 0, 1),
                this
            }
            makeShear(tt, lt, mt, ft, xt, Ct) {
                return this.set(1, mt, xt, 0, tt, 1, Ct, 0, lt, ft, 1, 0, 0, 0, 0, 1),
                this
            }
            compose(tt, lt, mt) {
                const ft = this.elements
                  , xt = lt._x
                  , Ct = lt._y
                  , Mt = lt._z
                  , Lt = lt._w
                  , Nt = xt + xt
                  , jt = Ct + Ct
                  , Wt = Mt + Mt
                  , Qt = xt * Nt
                  , qt = xt * jt
                  , Xt = xt * Wt
                  , Zt = Ct * jt
                  , Yt = Ct * Wt
                  , sr = Mt * Wt
                  , er = Lt * Nt
                  , rr = Lt * jt
                  , xr = Lt * Wt
                  , br = mt.x
                  , yr = mt.y
                  , Pr = mt.z;
                return ft[0] = (1 - (Zt + sr)) * br,
                ft[1] = (qt + xr) * br,
                ft[2] = (Xt - rr) * br,
                ft[3] = 0,
                ft[4] = (qt - xr) * yr,
                ft[5] = (1 - (Qt + sr)) * yr,
                ft[6] = (Yt + er) * yr,
                ft[7] = 0,
                ft[8] = (Xt + rr) * Pr,
                ft[9] = (Yt - er) * Pr,
                ft[10] = (1 - (Qt + Zt)) * Pr,
                ft[11] = 0,
                ft[12] = tt.x,
                ft[13] = tt.y,
                ft[14] = tt.z,
                ft[15] = 1,
                this
            }
            decompose(tt, lt, mt) {
                const ft = this.elements;
                let xt = Wu.set(ft[0], ft[1], ft[2]).length();
                const Ct = Wu.set(ft[4], ft[5], ft[6]).length()
                  , Mt = Wu.set(ft[8], ft[9], ft[10]).length();
                this.determinant() < 0 && (xt = -xt),
                tt.x = ft[12],
                tt.y = ft[13],
                tt.z = ft[14],
                $a.copy(this);
                const Lt = 1 / xt
                  , Nt = 1 / Ct
                  , jt = 1 / Mt;
                return $a.elements[0] *= Lt,
                $a.elements[1] *= Lt,
                $a.elements[2] *= Lt,
                $a.elements[4] *= Nt,
                $a.elements[5] *= Nt,
                $a.elements[6] *= Nt,
                $a.elements[8] *= jt,
                $a.elements[9] *= jt,
                $a.elements[10] *= jt,
                lt.setFromRotationMatrix($a),
                mt.x = xt,
                mt.y = Ct,
                mt.z = Mt,
                this
            }
            makePerspective(tt, lt, mt, ft, xt, Ct, Mt=Qs) {
                const Lt = this.elements
                  , Nt = 2 * xt / (lt - tt)
                  , jt = 2 * xt / (mt - ft)
                  , Wt = (lt + tt) / (lt - tt)
                  , Qt = (mt + ft) / (mt - ft);
                let qt, Xt;
                if (Mt === Qs)
                    qt = -(Ct + xt) / (Ct - xt),
                    Xt = -2 * Ct * xt / (Ct - xt);
                else {
                    if (Mt !== na)
                        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + Mt);
                    qt = -Ct / (Ct - xt),
                    Xt = -Ct * xt / (Ct - xt)
                }
                return Lt[0] = Nt,
                Lt[4] = 0,
                Lt[8] = Wt,
                Lt[12] = 0,
                Lt[1] = 0,
                Lt[5] = jt,
                Lt[9] = Qt,
                Lt[13] = 0,
                Lt[2] = 0,
                Lt[6] = 0,
                Lt[10] = qt,
                Lt[14] = Xt,
                Lt[3] = 0,
                Lt[7] = 0,
                Lt[11] = -1,
                Lt[15] = 0,
                this
            }
            makeOrthographic(tt, lt, mt, ft, xt, Ct, Mt=Qs) {
                const Lt = this.elements
                  , Nt = 1 / (lt - tt)
                  , jt = 1 / (mt - ft)
                  , Wt = 1 / (Ct - xt)
                  , Qt = (lt + tt) * Nt
                  , qt = (mt + ft) * jt;
                let Xt, Zt;
                if (Mt === Qs)
                    Xt = (Ct + xt) * Wt,
                    Zt = -2 * Wt;
                else {
                    if (Mt !== na)
                        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + Mt);
                    Xt = xt * Wt,
                    Zt = -1 * Wt
                }
                return Lt[0] = 2 * Nt,
                Lt[4] = 0,
                Lt[8] = 0,
                Lt[12] = -Qt,
                Lt[1] = 0,
                Lt[5] = 2 * jt,
                Lt[9] = 0,
                Lt[13] = -qt,
                Lt[2] = 0,
                Lt[6] = 0,
                Lt[10] = Zt,
                Lt[14] = -Xt,
                Lt[3] = 0,
                Lt[7] = 0,
                Lt[11] = 0,
                Lt[15] = 1,
                this
            }
            equals(tt) {
                const lt = this.elements
                  , mt = tt.elements;
                for (let ft = 0; ft < 16; ft++)
                    if (lt[ft] !== mt[ft])
                        return !1;
                return !0
            }
            fromArray(tt, lt=0) {
                for (let mt = 0; mt < 16; mt++)
                    this.elements[mt] = tt[mt + lt];
                return this
            }
            toArray(tt=[], lt=0) {
                const mt = this.elements;
                return tt[lt] = mt[0],
                tt[lt + 1] = mt[1],
                tt[lt + 2] = mt[2],
                tt[lt + 3] = mt[3],
                tt[lt + 4] = mt[4],
                tt[lt + 5] = mt[5],
                tt[lt + 6] = mt[6],
                tt[lt + 7] = mt[7],
                tt[lt + 8] = mt[8],
                tt[lt + 9] = mt[9],
                tt[lt + 10] = mt[10],
                tt[lt + 11] = mt[11],
                tt[lt + 12] = mt[12],
                tt[lt + 13] = mt[13],
                tt[lt + 14] = mt[14],
                tt[lt + 15] = mt[15],
                tt
            }
        }
        const Wu = new Er
          , $a = new no
          , qu = new Er(0,0,0)
          , ov = new Er(1,1,1)
          , tu = new Er
          , cm = new Er
          , Ss = new Er
          , sv = new no
          , Su = new Is;
        class $u {
            constructor(tt=0, lt=0, mt=0, ft=$u.DEFAULT_ORDER) {
                this.isEuler = !0,
                this._x = tt,
                this._y = lt,
                this._z = mt,
                this._order = ft
            }
            get x() {
                return this._x
            }
            set x(tt) {
                this._x = tt,
                this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(tt) {
                this._y = tt,
                this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(tt) {
                this._z = tt,
                this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(tt) {
                this._order = tt,
                this._onChangeCallback()
            }
            set(tt, lt, mt, ft=this._order) {
                return this._x = tt,
                this._y = lt,
                this._z = mt,
                this._order = ft,
                this._onChangeCallback(),
                this
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._order)
            }
            copy(tt) {
                return this._x = tt._x,
                this._y = tt._y,
                this._z = tt._z,
                this._order = tt._order,
                this._onChangeCallback(),
                this
            }
            setFromRotationMatrix(tt, lt=this._order, mt=!0) {
                const ft = tt.elements
                  , xt = ft[0]
                  , Ct = ft[4]
                  , Mt = ft[8]
                  , Lt = ft[1]
                  , Nt = ft[5]
                  , jt = ft[9]
                  , Wt = ft[2]
                  , Qt = ft[6]
                  , qt = ft[10];
                switch (lt) {
                case "XYZ":
                    this._y = Math.asin(qo(Mt, -1, 1)),
                    Math.abs(Mt) < .9999999 ? (this._x = Math.atan2(-jt, qt),
                    this._z = Math.atan2(-Ct, xt)) : (this._x = Math.atan2(Qt, Nt),
                    this._z = 0);
                    break;
                case "YXZ":
                    this._x = Math.asin(-qo(jt, -1, 1)),
                    Math.abs(jt) < .9999999 ? (this._y = Math.atan2(Mt, qt),
                    this._z = Math.atan2(Lt, Nt)) : (this._y = Math.atan2(-Wt, xt),
                    this._z = 0);
                    break;
                case "ZXY":
                    this._x = Math.asin(qo(Qt, -1, 1)),
                    Math.abs(Qt) < .9999999 ? (this._y = Math.atan2(-Wt, qt),
                    this._z = Math.atan2(-Ct, Nt)) : (this._y = 0,
                    this._z = Math.atan2(Lt, xt));
                    break;
                case "ZYX":
                    this._y = Math.asin(-qo(Wt, -1, 1)),
                    Math.abs(Wt) < .9999999 ? (this._x = Math.atan2(Qt, qt),
                    this._z = Math.atan2(Lt, xt)) : (this._x = 0,
                    this._z = Math.atan2(-Ct, Nt));
                    break;
                case "YZX":
                    this._z = Math.asin(qo(Lt, -1, 1)),
                    Math.abs(Lt) < .9999999 ? (this._x = Math.atan2(-jt, Nt),
                    this._y = Math.atan2(-Wt, xt)) : (this._x = 0,
                    this._y = Math.atan2(Mt, qt));
                    break;
                case "XZY":
                    this._z = Math.asin(-qo(Ct, -1, 1)),
                    Math.abs(Ct) < .9999999 ? (this._x = Math.atan2(Qt, Nt),
                    this._y = Math.atan2(Mt, xt)) : (this._x = Math.atan2(-jt, qt),
                    this._y = 0);
                    break;
                default:
                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + lt)
                }
                return this._order = lt,
                mt === !0 && this._onChangeCallback(),
                this
            }
            setFromQuaternion(tt, lt, mt) {
                return sv.makeRotationFromQuaternion(tt),
                this.setFromRotationMatrix(sv, lt, mt)
            }
            setFromVector3(tt, lt=this._order) {
                return this.set(tt.x, tt.y, tt.z, lt)
            }
            reorder(tt) {
                return Su.setFromEuler(this),
                this.setFromQuaternion(Su, tt)
            }
            equals(tt) {
                return tt._x === this._x && tt._y === this._y && tt._z === this._z && tt._order === this._order
            }
            fromArray(tt) {
                return this._x = tt[0],
                this._y = tt[1],
                this._z = tt[2],
                tt[3] !== void 0 && (this._order = tt[3]),
                this._onChangeCallback(),
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this._x,
                tt[lt + 1] = this._y,
                tt[lt + 2] = this._z,
                tt[lt + 3] = this._order,
                tt
            }
            _onChange(tt) {
                return this._onChangeCallback = tt,
                this
            }
            _onChangeCallback() {}
            *[Symbol.iterator]() {
                yield this._x,
                yield this._y,
                yield this._z,
                yield this._order
            }
        }
        $u.DEFAULT_ORDER = "XYZ";
        class um {
            constructor() {
                this.mask = 1
            }
            set(tt) {
                this.mask = 1 << tt >>> 0
            }
            enable(tt) {
                this.mask |= 1 << tt
            }
            enableAll() {
                this.mask = -1
            }
            toggle(tt) {
                this.mask ^= 1 << tt
            }
            disable(tt) {
                this.mask &= ~(1 << tt)
            }
            disableAll() {
                this.mask = 0
            }
            test(tt) {
                return !!(this.mask & tt.mask)
            }
            isEnabled(tt) {
                return !!(this.mask & 1 << tt)
            }
        }
        let D0 = 0;
        const av = new Er
          , Xu = new Is
          , Ns = new no
          , xp = new Er
          , bp = new Er
          , l_ = new Er
          , lv = new Is
          , cv = new Er(1,0,0)
          , dm = new Er(0,1,0)
          , uv = new Er(0,0,1)
          , ru = {
            type: "added"
        }
          , B0 = {
            type: "removed"
        };
        class Mo extends As {
            constructor() {
                super(),
                this.isObject3D = !0,
                Object.defineProperty(this, "id", {
                    value: D0++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.type = "Object3D",
                this.parent = null,
                this.children = [],
                this.up = Mo.DEFAULT_UP.clone();
                const tt = new Er
                  , lt = new $u
                  , mt = new Is
                  , ft = new Er(1,1,1);
                lt._onChange(function() {
                    mt.setFromEuler(lt, !1)
                }),
                mt._onChange(function() {
                    lt.setFromQuaternion(mt, void 0, !1)
                }),
                Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: tt
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: lt
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: mt
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: ft
                    },
                    modelViewMatrix: {
                        value: new no
                    },
                    normalMatrix: {
                        value: new lo
                    }
                }),
                this.matrix = new no,
                this.matrixWorld = new no,
                this.matrixAutoUpdate = Mo.DEFAULT_MATRIX_AUTO_UPDATE,
                this.matrixWorldNeedsUpdate = !1,
                this.matrixWorldAutoUpdate = Mo.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
                this.layers = new um,
                this.visible = !0,
                this.castShadow = !1,
                this.receiveShadow = !1,
                this.frustumCulled = !0,
                this.renderOrder = 0,
                this.animations = [],
                this.userData = {}
            }
            onBeforeRender(tt, lt, mt, ft, xt, Ct) {
                this.dispatchEvent({
                    type: "beforeRender",
                    renderer: tt,
                    scene: lt,
                    camera: mt,
                    geometry: ft,
                    material: xt,
                    group: Ct
                })
            }
            onAfterRender(tt, lt, mt, ft, xt, Ct) {
                this.dispatchEvent({
                    type: "afterRender",
                    renderer: tt,
                    scene: lt,
                    camera: mt,
                    geometry: ft,
                    material: xt,
                    group: Ct
                })
            }
            applyMatrix4(tt) {
                this.matrixAutoUpdate && this.updateMatrix(),
                this.matrix.premultiply(tt),
                this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(tt) {
                return this.quaternion.premultiply(tt),
                this
            }
            setRotationFromAxisAngle(tt, lt) {
                this.quaternion.setFromAxisAngle(tt, lt)
            }
            setRotationFromEuler(tt) {
                this.quaternion.setFromEuler(tt, !0)
            }
            setRotationFromMatrix(tt) {
                this.quaternion.setFromRotationMatrix(tt)
            }
            setRotationFromQuaternion(tt) {
                this.quaternion.copy(tt)
            }
            rotateOnAxis(tt, lt) {
                return Xu.setFromAxisAngle(tt, lt),
                this.quaternion.multiply(Xu),
                this
            }
            rotateOnWorldAxis(tt, lt) {
                return Xu.setFromAxisAngle(tt, lt),
                this.quaternion.premultiply(Xu),
                this
            }
            rotateX(tt) {
                return this.rotateOnAxis(cv, tt)
            }
            rotateY(tt) {
                return this.rotateOnAxis(dm, tt)
            }
            rotateZ(tt) {
                return this.rotateOnAxis(uv, tt)
            }
            translateOnAxis(tt, lt) {
                return av.copy(tt).applyQuaternion(this.quaternion),
                this.position.add(av.multiplyScalar(lt)),
                this
            }
            translateX(tt) {
                return this.translateOnAxis(cv, tt)
            }
            translateY(tt) {
                return this.translateOnAxis(dm, tt)
            }
            translateZ(tt) {
                return this.translateOnAxis(uv, tt)
            }
            localToWorld(tt) {
                return this.updateWorldMatrix(!0, !1),
                tt.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(tt) {
                return this.updateWorldMatrix(!0, !1),
                tt.applyMatrix4(Ns.copy(this.matrixWorld).invert())
            }
            lookAt(tt, lt, mt) {
                tt.isVector3 ? xp.copy(tt) : xp.set(tt, lt, mt);
                const ft = this.parent;
                this.updateWorldMatrix(!0, !1),
                bp.setFromMatrixPosition(this.matrixWorld),
                this.isCamera || this.isLight ? Ns.lookAt(bp, xp, this.up) : Ns.lookAt(xp, bp, this.up),
                this.quaternion.setFromRotationMatrix(Ns),
                ft && (Ns.extractRotation(ft.matrixWorld),
                Xu.setFromRotationMatrix(Ns),
                this.quaternion.premultiply(Xu.invert()))
            }
            add(tt) {
                if (arguments.length > 1) {
                    for (let lt = 0; lt < arguments.length; lt++)
                        this.add(arguments[lt]);
                    return this
                }
                return tt === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", tt),
                this) : (tt && tt.isObject3D ? (tt.parent !== null && tt.parent.remove(tt),
                tt.parent = this,
                this.children.push(tt),
                tt.dispatchEvent(ru)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", tt),
                this)
            }
            remove(tt) {
                if (arguments.length > 1) {
                    for (let mt = 0; mt < arguments.length; mt++)
                        this.remove(arguments[mt]);
                    return this
                }
                const lt = this.children.indexOf(tt);
                return lt !== -1 && (tt.parent = null,
                this.children.splice(lt, 1),
                tt.dispatchEvent(B0)),
                this
            }
            removeFromParent() {
                const tt = this.parent;
                return tt !== null && tt.remove(this),
                this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(tt) {
                return this.updateWorldMatrix(!0, !1),
                Ns.copy(this.matrixWorld).invert(),
                tt.parent !== null && (tt.parent.updateWorldMatrix(!0, !1),
                Ns.multiply(tt.parent.matrixWorld)),
                tt.applyMatrix4(Ns),
                this.add(tt),
                tt.updateWorldMatrix(!1, !0),
                this
            }
            getObjectById(tt) {
                return this.getObjectByProperty("id", tt)
            }
            getObjectByName(tt) {
                return this.getObjectByProperty("name", tt)
            }
            getObjectByProperty(tt, lt) {
                if (this[tt] === lt)
                    return this;
                for (let mt = 0, ft = this.children.length; mt < ft; mt++) {
                    const xt = this.children[mt].getObjectByProperty(tt, lt);
                    if (xt !== void 0)
                        return xt
                }
            }
            getObjectsByProperty(tt, lt) {
                let mt = [];
                this[tt] === lt && mt.push(this);
                for (let ft = 0, xt = this.children.length; ft < xt; ft++) {
                    const Ct = this.children[ft].getObjectsByProperty(tt, lt);
                    Ct.length > 0 && (mt = mt.concat(Ct))
                }
                return mt
            }
            getWorldPosition(tt) {
                return this.updateWorldMatrix(!0, !1),
                tt.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(tt) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(bp, tt, l_),
                tt
            }
            getWorldScale(tt) {
                return this.updateWorldMatrix(!0, !1),
                this.matrixWorld.decompose(bp, lv, tt),
                tt
            }
            getWorldDirection(tt) {
                this.updateWorldMatrix(!0, !1);
                const lt = this.matrixWorld.elements;
                return tt.set(lt[8], lt[9], lt[10]).normalize()
            }
            raycast() {}
            traverse(tt) {
                tt(this);
                const lt = this.children;
                for (let mt = 0, ft = lt.length; mt < ft; mt++)
                    lt[mt].traverse(tt)
            }
            traverseVisible(tt) {
                if (this.visible === !1)
                    return;
                tt(this);
                const lt = this.children;
                for (let mt = 0, ft = lt.length; mt < ft; mt++)
                    lt[mt].traverseVisible(tt)
            }
            traverseAncestors(tt) {
                const lt = this.parent;
                lt !== null && (tt(lt),
                lt.traverseAncestors(tt))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(tt) {
                this.matrixAutoUpdate && this.updateMatrix(),
                (this.matrixWorldNeedsUpdate || tt) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                this.matrixWorldNeedsUpdate = !1,
                tt = !0);
                const lt = this.children;
                for (let mt = 0, ft = lt.length; mt < ft; mt++) {
                    const xt = lt[mt];
                    xt.matrixWorldAutoUpdate !== !0 && tt !== !0 || xt.updateMatrixWorld(tt)
                }
            }
            updateWorldMatrix(tt, lt) {
                const mt = this.parent;
                if (tt === !0 && mt !== null && mt.matrixWorldAutoUpdate === !0 && mt.updateWorldMatrix(!0, !1),
                this.matrixAutoUpdate && this.updateMatrix(),
                this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
                lt === !0) {
                    const ft = this.children;
                    for (let xt = 0, Ct = ft.length; xt < Ct; xt++) {
                        const Mt = ft[xt];
                        Mt.matrixWorldAutoUpdate === !0 && Mt.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string"
                  , mt = {};
                lt && (tt = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {},
                    extras: {}
                },
                mt.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const ft = {};
                function xt(Mt, Lt) {
                    return Mt[Lt.uuid] === void 0 && (Mt[Lt.uuid] = Lt.toJSON(tt)),
                    Lt.uuid
                }
                if (ft.uuid = this.uuid,
                ft.type = this.type,
                this.name !== "" && (ft.name = this.name),
                this.castShadow === !0 && (ft.castShadow = !0),
                this.receiveShadow === !0 && (ft.receiveShadow = !0),
                this.visible === !1 && (ft.visible = !1),
                this.frustumCulled === !1 && (ft.frustumCulled = !1),
                this.renderOrder !== 0 && (ft.renderOrder = this.renderOrder),
                Object.keys(this.userData).length > 0 && (ft.userData = this.userData),
                ft.layers = this.layers.mask,
                ft.matrix = this.matrix.toArray(),
                ft.up = this.up.toArray(),
                this.matrixAutoUpdate === !1 && (ft.matrixAutoUpdate = !1),
                this.isInstancedMesh && (ft.type = "InstancedMesh",
                ft.count = this.count,
                ft.instanceMatrix = this.instanceMatrix.toJSON(),
                this.instanceColor !== null && (ft.instanceColor = this.instanceColor.toJSON())),
                this.isScene)
                    this.background && (this.background.isColor ? ft.background = this.background.toJSON() : this.background.isTexture && (ft.background = this.background.toJSON(tt).uuid)),
                    this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (ft.environment = this.environment.toJSON(tt).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    ft.geometry = xt(tt.geometries, this.geometry);
                    const Mt = this.geometry.parameters;
                    if (Mt !== void 0 && Mt.shapes !== void 0) {
                        const Lt = Mt.shapes;
                        if (Array.isArray(Lt))
                            for (let Nt = 0, jt = Lt.length; Nt < jt; Nt++) {
                                const Wt = Lt[Nt];
                                xt(tt.shapes, Wt)
                            }
                        else
                            xt(tt.shapes, Lt)
                    }
                }
                if (this.isSkinnedMesh && (ft.bindMode = this.bindMode,
                ft.bindMatrix = this.bindMatrix.toArray(),
                this.skeleton !== void 0 && (xt(tt.skeletons, this.skeleton),
                ft.skeleton = this.skeleton.uuid)),
                this.material !== void 0)
                    if (Array.isArray(this.material)) {
                        const Mt = [];
                        for (let Lt = 0, Nt = this.material.length; Lt < Nt; Lt++)
                            Mt.push(xt(tt.materials, this.material[Lt]));
                        ft.material = Mt
                    } else
                        ft.material = xt(tt.materials, this.material);
                if (this.children.length > 0) {
                    ft.children = [];
                    for (let Mt = 0; Mt < this.children.length; Mt++)
                        ft.children.push(this.children[Mt].toJSON(tt).object)
                }
                if (this.animations.length > 0) {
                    ft.animations = [];
                    for (let Mt = 0; Mt < this.animations.length; Mt++) {
                        const Lt = this.animations[Mt];
                        ft.animations.push(xt(tt.animations, Lt))
                    }
                }
                if (lt) {
                    const Mt = Ct(tt.geometries)
                      , Lt = Ct(tt.materials)
                      , Nt = Ct(tt.textures)
                      , jt = Ct(tt.images)
                      , Wt = Ct(tt.shapes)
                      , Qt = Ct(tt.skeletons)
                      , qt = Ct(tt.animations)
                      , Xt = Ct(tt.nodes);
                    Mt.length > 0 && (mt.geometries = Mt),
                    Lt.length > 0 && (mt.materials = Lt),
                    Nt.length > 0 && (mt.textures = Nt),
                    jt.length > 0 && (mt.images = jt),
                    Wt.length > 0 && (mt.shapes = Wt),
                    Qt.length > 0 && (mt.skeletons = Qt),
                    qt.length > 0 && (mt.animations = qt),
                    Xt.length > 0 && (mt.nodes = Xt)
                }
                return mt.object = ft,
                mt;
                function Ct(Mt) {
                    const Lt = [];
                    for (const Nt in Mt) {
                        const jt = Mt[Nt];
                        delete jt.metadata,
                        Lt.push(jt)
                    }
                    return Lt
                }
            }
            clone(tt) {
                return new this.constructor().copy(this, tt)
            }
            copy(tt, lt=!0) {
                this.name = tt.name,
                this.up.copy(tt.up),
                this.position.copy(tt.position),
                this.rotation.order = tt.rotation.order,
                this.quaternion.copy(tt.quaternion),
                this.scale.copy(tt.scale),
                this.matrix.copy(tt.matrix),
                this.matrixWorld.copy(tt.matrixWorld),
                this.matrixAutoUpdate = tt.matrixAutoUpdate,
                this.matrixWorldNeedsUpdate = tt.matrixWorldNeedsUpdate,
                this.matrixWorldAutoUpdate = tt.matrixWorldAutoUpdate,
                this.layers.mask = tt.layers.mask,
                this.visible = tt.visible,
                this.castShadow = tt.castShadow,
                this.receiveShadow = tt.receiveShadow,
                this.frustumCulled = tt.frustumCulled,
                this.renderOrder = tt.renderOrder,
                this.animations = tt.animations.slice(),
                this.userData = {};
                for (const [mt,ft] of Object.entries(tt.userData))
                    this.userData[mt] = !ft || ft && (ft.isTexture || ft.isObject3D) ? ft : JSON.parse(JSON.stringify(ft));
                if (lt === !0)
                    for (let mt = 0; mt < tt.children.length; mt++) {
                        const ft = tt.children[mt];
                        this.add(ft.clone())
                    }
                return this
            }
        }
        Mo.DEFAULT_UP = new Er(0,1,0),
        Mo.DEFAULT_MATRIX_AUTO_UPDATE = !0,
        Mo.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const Fs = new Er
          , Il = new Er
          , c_ = new Er
          , Ul = new Er
          , Yu = new Er
          , Ku = new Er
          , dv = new Er
          , u_ = new Er
          , _l = new Er
          , pm = new Er;
        let hm = !1;
        class Es {
            constructor(tt=new Er, lt=new Er, mt=new Er) {
                this.a = tt,
                this.b = lt,
                this.c = mt
            }
            static getNormal(tt, lt, mt, ft) {
                ft.subVectors(mt, lt),
                Fs.subVectors(tt, lt),
                ft.cross(Fs);
                const xt = ft.lengthSq();
                return xt > 0 ? ft.multiplyScalar(1 / Math.sqrt(xt)) : ft.set(0, 0, 0)
            }
            static getBarycoord(tt, lt, mt, ft, xt) {
                Fs.subVectors(ft, lt),
                Il.subVectors(mt, lt),
                c_.subVectors(tt, lt);
                const Ct = Fs.dot(Fs)
                  , Mt = Fs.dot(Il)
                  , Lt = Fs.dot(c_)
                  , Nt = Il.dot(Il)
                  , jt = Il.dot(c_)
                  , Wt = Ct * Nt - Mt * Mt;
                if (Wt === 0)
                    return xt.set(-2, -1, -1);
                const Qt = 1 / Wt
                  , qt = (Nt * Lt - Mt * jt) * Qt
                  , Xt = (Ct * jt - Mt * Lt) * Qt;
                return xt.set(1 - qt - Xt, Xt, qt)
            }
            static containsPoint(tt, lt, mt, ft) {
                return this.getBarycoord(tt, lt, mt, ft, Ul),
                Ul.x >= 0 && Ul.y >= 0 && Ul.x + Ul.y <= 1
            }
            static getUV(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                return hm === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                hm = !0),
                this.getInterpolation(tt, lt, mt, ft, xt, Ct, Mt, Lt)
            }
            static getInterpolation(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                return this.getBarycoord(tt, lt, mt, ft, Ul),
                Lt.setScalar(0),
                Lt.addScaledVector(xt, Ul.x),
                Lt.addScaledVector(Ct, Ul.y),
                Lt.addScaledVector(Mt, Ul.z),
                Lt
            }
            static isFrontFacing(tt, lt, mt, ft) {
                return Fs.subVectors(mt, lt),
                Il.subVectors(tt, lt),
                Fs.cross(Il).dot(ft) < 0
            }
            set(tt, lt, mt) {
                return this.a.copy(tt),
                this.b.copy(lt),
                this.c.copy(mt),
                this
            }
            setFromPointsAndIndices(tt, lt, mt, ft) {
                return this.a.copy(tt[lt]),
                this.b.copy(tt[mt]),
                this.c.copy(tt[ft]),
                this
            }
            setFromAttributeAndIndices(tt, lt, mt, ft) {
                return this.a.fromBufferAttribute(tt, lt),
                this.b.fromBufferAttribute(tt, mt),
                this.c.fromBufferAttribute(tt, ft),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.a.copy(tt.a),
                this.b.copy(tt.b),
                this.c.copy(tt.c),
                this
            }
            getArea() {
                return Fs.subVectors(this.c, this.b),
                Il.subVectors(this.a, this.b),
                .5 * Fs.cross(Il).length()
            }
            getMidpoint(tt) {
                return tt.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(tt) {
                return Es.getNormal(this.a, this.b, this.c, tt)
            }
            getPlane(tt) {
                return tt.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(tt, lt) {
                return Es.getBarycoord(tt, this.a, this.b, this.c, lt)
            }
            getUV(tt, lt, mt, ft, xt) {
                return hm === !1 && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),
                hm = !0),
                Es.getInterpolation(tt, this.a, this.b, this.c, lt, mt, ft, xt)
            }
            getInterpolation(tt, lt, mt, ft, xt) {
                return Es.getInterpolation(tt, this.a, this.b, this.c, lt, mt, ft, xt)
            }
            containsPoint(tt) {
                return Es.containsPoint(tt, this.a, this.b, this.c)
            }
            isFrontFacing(tt) {
                return Es.isFrontFacing(this.a, this.b, this.c, tt)
            }
            intersectsBox(tt) {
                return tt.intersectsTriangle(this)
            }
            closestPointToPoint(tt, lt) {
                const mt = this.a
                  , ft = this.b
                  , xt = this.c;
                let Ct, Mt;
                Yu.subVectors(ft, mt),
                Ku.subVectors(xt, mt),
                u_.subVectors(tt, mt);
                const Lt = Yu.dot(u_)
                  , Nt = Ku.dot(u_);
                if (Lt <= 0 && Nt <= 0)
                    return lt.copy(mt);
                _l.subVectors(tt, ft);
                const jt = Yu.dot(_l)
                  , Wt = Ku.dot(_l);
                if (jt >= 0 && Wt <= jt)
                    return lt.copy(ft);
                const Qt = Lt * Wt - jt * Nt;
                if (Qt <= 0 && Lt >= 0 && jt <= 0)
                    return Ct = Lt / (Lt - jt),
                    lt.copy(mt).addScaledVector(Yu, Ct);
                pm.subVectors(tt, xt);
                const qt = Yu.dot(pm)
                  , Xt = Ku.dot(pm);
                if (Xt >= 0 && qt <= Xt)
                    return lt.copy(xt);
                const Zt = qt * Nt - Lt * Xt;
                if (Zt <= 0 && Nt >= 0 && Xt <= 0)
                    return Mt = Nt / (Nt - Xt),
                    lt.copy(mt).addScaledVector(Ku, Mt);
                const Yt = jt * Xt - qt * Wt;
                if (Yt <= 0 && Wt - jt >= 0 && qt - Xt >= 0)
                    return dv.subVectors(xt, ft),
                    Mt = (Wt - jt) / (Wt - jt + (qt - Xt)),
                    lt.copy(ft).addScaledVector(dv, Mt);
                const sr = 1 / (Yt + Zt + Qt);
                return Ct = Zt * sr,
                Mt = Qt * sr,
                lt.copy(mt).addScaledVector(Yu, Ct).addScaledVector(Ku, Mt)
            }
            equals(tt) {
                return tt.a.equals(this.a) && tt.b.equals(this.b) && tt.c.equals(this.c)
            }
        }
        let L0 = 0;
        class hs extends As {
            constructor() {
                super(),
                this.isMaterial = !0,
                Object.defineProperty(this, "id", {
                    value: L0++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.type = "Material",
                this.blending = Pt,
                this.side = vt,
                this.vertexColors = !1,
                this.opacity = 1,
                this.transparent = !1,
                this.alphaHash = !1,
                this.blendSrc = hr,
                this.blendDst = gr,
                this.blendEquation = kt,
                this.blendSrcAlpha = null,
                this.blendDstAlpha = null,
                this.blendEquationAlpha = null,
                this.depthFunc = vr,
                this.depthTest = !0,
                this.depthWrite = !0,
                this.stencilWriteMask = 255,
                this.stencilFunc = mp,
                this.stencilRef = 0,
                this.stencilFuncMask = 255,
                this.stencilFail = Yp,
                this.stencilZFail = Yp,
                this.stencilZPass = Yp,
                this.stencilWrite = !1,
                this.clippingPlanes = null,
                this.clipIntersection = !1,
                this.clipShadows = !1,
                this.shadowSide = null,
                this.colorWrite = !0,
                this.precision = null,
                this.polygonOffset = !1,
                this.polygonOffsetFactor = 0,
                this.polygonOffsetUnits = 0,
                this.dithering = !1,
                this.alphaToCoverage = !1,
                this.premultipliedAlpha = !1,
                this.forceSinglePass = !1,
                this.visible = !0,
                this.toneMapped = !0,
                this.userData = {},
                this.version = 0,
                this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(tt) {
                this._alphaTest > 0 != tt > 0 && this.version++,
                this._alphaTest = tt
            }
            onBuild() {}
            onBeforeRender() {}
            onAfterRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(tt) {
                if (tt !== void 0)
                    for (const lt in tt) {
                        const mt = tt[lt];
                        if (mt === void 0) {
                            console.warn(`THREE.Material: parameter '${lt}' has value of undefined.`);
                            continue
                        }
                        const ft = this[lt];
                        ft !== void 0 && (ft && ft.isColor ? ft.set(mt) : ft && ft.isVector3 && mt && mt.isVector3 ? ft.copy(mt) : Array.isArray(mt) && ft && typeof ft.fromArray == "function" ? ft.fromArray(mt) : this[lt] = mt)
                    }
            }
            toJSON(tt) {
                const lt = tt === void 0 || typeof tt == "string";
                lt && (tt = {
                    textures: {},
                    images: {}
                });
                const mt = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                function ft(xt) {
                    const Ct = [];
                    for (const Mt in xt) {
                        const Lt = xt[Mt];
                        delete Lt.metadata,
                        Ct.push(Lt)
                    }
                    return Ct
                }
                if (mt.uuid = this.uuid,
                mt.type = this.type,
                this.name !== "" && (mt.name = this.name),
                this.color && this.color.isColor && (mt.color = this.color.getHex()),
                this.roughness !== void 0 && (mt.roughness = this.roughness),
                this.metalness !== void 0 && (mt.metalness = this.metalness),
                this.sheen !== void 0 && (mt.sheen = this.sheen),
                this.sheenColor && this.sheenColor.isColor && (mt.sheenColor = this.sheenColor.getHex()),
                this.sheenRoughness !== void 0 && (mt.sheenRoughness = this.sheenRoughness),
                this.emissive && this.emissive.isColor && (mt.emissive = this.emissive.getHex()),
                this.emissiveIntensity && this.emissiveIntensity !== 1 && (mt.emissiveIntensity = this.emissiveIntensity),
                this.specular && this.specular.isColor && (mt.specular = this.specular.getHex()),
                this.specularIntensity !== void 0 && (mt.specularIntensity = this.specularIntensity),
                this.specularColor && this.specularColor.isColor && (mt.specularColor = this.specularColor.getHex()),
                this.shininess !== void 0 && (mt.shininess = this.shininess),
                this.clearcoat !== void 0 && (mt.clearcoat = this.clearcoat),
                this.clearcoatRoughness !== void 0 && (mt.clearcoatRoughness = this.clearcoatRoughness),
                this.clearcoatMap && this.clearcoatMap.isTexture && (mt.clearcoatMap = this.clearcoatMap.toJSON(tt).uuid),
                this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (mt.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(tt).uuid),
                this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (mt.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(tt).uuid,
                mt.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
                this.iridescence !== void 0 && (mt.iridescence = this.iridescence),
                this.iridescenceIOR !== void 0 && (mt.iridescenceIOR = this.iridescenceIOR),
                this.iridescenceThicknessRange !== void 0 && (mt.iridescenceThicknessRange = this.iridescenceThicknessRange),
                this.iridescenceMap && this.iridescenceMap.isTexture && (mt.iridescenceMap = this.iridescenceMap.toJSON(tt).uuid),
                this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (mt.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(tt).uuid),
                this.anisotropy !== void 0 && (mt.anisotropy = this.anisotropy),
                this.anisotropyRotation !== void 0 && (mt.anisotropyRotation = this.anisotropyRotation),
                this.anisotropyMap && this.anisotropyMap.isTexture && (mt.anisotropyMap = this.anisotropyMap.toJSON(tt).uuid),
                this.map && this.map.isTexture && (mt.map = this.map.toJSON(tt).uuid),
                this.matcap && this.matcap.isTexture && (mt.matcap = this.matcap.toJSON(tt).uuid),
                this.alphaMap && this.alphaMap.isTexture && (mt.alphaMap = this.alphaMap.toJSON(tt).uuid),
                this.lightMap && this.lightMap.isTexture && (mt.lightMap = this.lightMap.toJSON(tt).uuid,
                mt.lightMapIntensity = this.lightMapIntensity),
                this.aoMap && this.aoMap.isTexture && (mt.aoMap = this.aoMap.toJSON(tt).uuid,
                mt.aoMapIntensity = this.aoMapIntensity),
                this.bumpMap && this.bumpMap.isTexture && (mt.bumpMap = this.bumpMap.toJSON(tt).uuid,
                mt.bumpScale = this.bumpScale),
                this.normalMap && this.normalMap.isTexture && (mt.normalMap = this.normalMap.toJSON(tt).uuid,
                mt.normalMapType = this.normalMapType,
                mt.normalScale = this.normalScale.toArray()),
                this.displacementMap && this.displacementMap.isTexture && (mt.displacementMap = this.displacementMap.toJSON(tt).uuid,
                mt.displacementScale = this.displacementScale,
                mt.displacementBias = this.displacementBias),
                this.roughnessMap && this.roughnessMap.isTexture && (mt.roughnessMap = this.roughnessMap.toJSON(tt).uuid),
                this.metalnessMap && this.metalnessMap.isTexture && (mt.metalnessMap = this.metalnessMap.toJSON(tt).uuid),
                this.emissiveMap && this.emissiveMap.isTexture && (mt.emissiveMap = this.emissiveMap.toJSON(tt).uuid),
                this.specularMap && this.specularMap.isTexture && (mt.specularMap = this.specularMap.toJSON(tt).uuid),
                this.specularIntensityMap && this.specularIntensityMap.isTexture && (mt.specularIntensityMap = this.specularIntensityMap.toJSON(tt).uuid),
                this.specularColorMap && this.specularColorMap.isTexture && (mt.specularColorMap = this.specularColorMap.toJSON(tt).uuid),
                this.envMap && this.envMap.isTexture && (mt.envMap = this.envMap.toJSON(tt).uuid,
                this.combine !== void 0 && (mt.combine = this.combine)),
                this.envMapIntensity !== void 0 && (mt.envMapIntensity = this.envMapIntensity),
                this.reflectivity !== void 0 && (mt.reflectivity = this.reflectivity),
                this.refractionRatio !== void 0 && (mt.refractionRatio = this.refractionRatio),
                this.gradientMap && this.gradientMap.isTexture && (mt.gradientMap = this.gradientMap.toJSON(tt).uuid),
                this.transmission !== void 0 && (mt.transmission = this.transmission),
                this.transmissionMap && this.transmissionMap.isTexture && (mt.transmissionMap = this.transmissionMap.toJSON(tt).uuid),
                this.thickness !== void 0 && (mt.thickness = this.thickness),
                this.thicknessMap && this.thicknessMap.isTexture && (mt.thicknessMap = this.thicknessMap.toJSON(tt).uuid),
                this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (mt.attenuationDistance = this.attenuationDistance),
                this.attenuationColor !== void 0 && (mt.attenuationColor = this.attenuationColor.getHex()),
                this.size !== void 0 && (mt.size = this.size),
                this.shadowSide !== null && (mt.shadowSide = this.shadowSide),
                this.sizeAttenuation !== void 0 && (mt.sizeAttenuation = this.sizeAttenuation),
                this.blending !== Pt && (mt.blending = this.blending),
                this.side !== vt && (mt.side = this.side),
                this.vertexColors === !0 && (mt.vertexColors = !0),
                this.opacity < 1 && (mt.opacity = this.opacity),
                this.transparent === !0 && (mt.transparent = !0),
                mt.depthFunc = this.depthFunc,
                mt.depthTest = this.depthTest,
                mt.depthWrite = this.depthWrite,
                mt.colorWrite = this.colorWrite,
                mt.stencilWrite = this.stencilWrite,
                mt.stencilWriteMask = this.stencilWriteMask,
                mt.stencilFunc = this.stencilFunc,
                mt.stencilRef = this.stencilRef,
                mt.stencilFuncMask = this.stencilFuncMask,
                mt.stencilFail = this.stencilFail,
                mt.stencilZFail = this.stencilZFail,
                mt.stencilZPass = this.stencilZPass,
                this.rotation !== void 0 && this.rotation !== 0 && (mt.rotation = this.rotation),
                this.polygonOffset === !0 && (mt.polygonOffset = !0),
                this.polygonOffsetFactor !== 0 && (mt.polygonOffsetFactor = this.polygonOffsetFactor),
                this.polygonOffsetUnits !== 0 && (mt.polygonOffsetUnits = this.polygonOffsetUnits),
                this.linewidth !== void 0 && this.linewidth !== 1 && (mt.linewidth = this.linewidth),
                this.dashSize !== void 0 && (mt.dashSize = this.dashSize),
                this.gapSize !== void 0 && (mt.gapSize = this.gapSize),
                this.scale !== void 0 && (mt.scale = this.scale),
                this.dithering === !0 && (mt.dithering = !0),
                this.alphaTest > 0 && (mt.alphaTest = this.alphaTest),
                this.alphaHash === !0 && (mt.alphaHash = !0),
                this.alphaToCoverage === !0 && (mt.alphaToCoverage = !0),
                this.premultipliedAlpha === !0 && (mt.premultipliedAlpha = !0),
                this.forceSinglePass === !0 && (mt.forceSinglePass = !0),
                this.wireframe === !0 && (mt.wireframe = !0),
                this.wireframeLinewidth > 1 && (mt.wireframeLinewidth = this.wireframeLinewidth),
                this.wireframeLinecap !== "round" && (mt.wireframeLinecap = this.wireframeLinecap),
                this.wireframeLinejoin !== "round" && (mt.wireframeLinejoin = this.wireframeLinejoin),
                this.flatShading === !0 && (mt.flatShading = !0),
                this.visible === !1 && (mt.visible = !1),
                this.toneMapped === !1 && (mt.toneMapped = !1),
                this.fog === !1 && (mt.fog = !1),
                Object.keys(this.userData).length > 0 && (mt.userData = this.userData),
                lt) {
                    const xt = ft(tt.textures)
                      , Ct = ft(tt.images);
                    xt.length > 0 && (mt.textures = xt),
                    Ct.length > 0 && (mt.images = Ct)
                }
                return mt
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                this.name = tt.name,
                this.blending = tt.blending,
                this.side = tt.side,
                this.vertexColors = tt.vertexColors,
                this.opacity = tt.opacity,
                this.transparent = tt.transparent,
                this.blendSrc = tt.blendSrc,
                this.blendDst = tt.blendDst,
                this.blendEquation = tt.blendEquation,
                this.blendSrcAlpha = tt.blendSrcAlpha,
                this.blendDstAlpha = tt.blendDstAlpha,
                this.blendEquationAlpha = tt.blendEquationAlpha,
                this.depthFunc = tt.depthFunc,
                this.depthTest = tt.depthTest,
                this.depthWrite = tt.depthWrite,
                this.stencilWriteMask = tt.stencilWriteMask,
                this.stencilFunc = tt.stencilFunc,
                this.stencilRef = tt.stencilRef,
                this.stencilFuncMask = tt.stencilFuncMask,
                this.stencilFail = tt.stencilFail,
                this.stencilZFail = tt.stencilZFail,
                this.stencilZPass = tt.stencilZPass,
                this.stencilWrite = tt.stencilWrite;
                const lt = tt.clippingPlanes;
                let mt = null;
                if (lt !== null) {
                    const ft = lt.length;
                    mt = new Array(ft);
                    for (let xt = 0; xt !== ft; ++xt)
                        mt[xt] = lt[xt].clone()
                }
                return this.clippingPlanes = mt,
                this.clipIntersection = tt.clipIntersection,
                this.clipShadows = tt.clipShadows,
                this.shadowSide = tt.shadowSide,
                this.colorWrite = tt.colorWrite,
                this.precision = tt.precision,
                this.polygonOffset = tt.polygonOffset,
                this.polygonOffsetFactor = tt.polygonOffsetFactor,
                this.polygonOffsetUnits = tt.polygonOffsetUnits,
                this.dithering = tt.dithering,
                this.alphaTest = tt.alphaTest,
                this.alphaHash = tt.alphaHash,
                this.alphaToCoverage = tt.alphaToCoverage,
                this.premultipliedAlpha = tt.premultipliedAlpha,
                this.forceSinglePass = tt.forceSinglePass,
                this.visible = tt.visible,
                this.toneMapped = tt.toneMapped,
                this.userData = d_({}, tt.userData),
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
        }
        function d_(Tt, tt) {
            if (!tt)
                return Tt;
            for (const lt of Object.keys(tt)) {
                if (lt.startsWith("__") || typeof Tt[lt] == "function" || typeof tt[lt] == "function")
                    continue;
                const mt = tt[lt]
                  , ft = !mt || mt.isTexture || mt.isObject3D || mt.isMaterial;
                ft || typeof tt[lt].clone != "function" ? ft || typeof tt[lt] != "object" && !Array.isArray(tt[lt]) ? Tt[lt] = tt[lt] : Tt[lt] = d_(Array.isArray(tt[lt]) ? [] : {}, tt[lt]) : Tt[lt] = tt[lt].clone()
            }
            return Tt
        }
        const p_ = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        }
          , Vl = {
            h: 0,
            s: 0,
            l: 0
        }
          , mm = {
            h: 0,
            s: 0,
            l: 0
        };
        function h_(Tt, tt, lt) {
            return lt < 0 && (lt += 1),
            lt > 1 && (lt -= 1),
            lt < 1 / 6 ? Tt + 6 * (tt - Tt) * lt : lt < .5 ? tt : lt < 2 / 3 ? Tt + 6 * (tt - Tt) * (2 / 3 - lt) : Tt
        }
        class Gn {
            constructor(tt, lt, mt) {
                return this.isColor = !0,
                this.r = 1,
                this.g = 1,
                this.b = 1,
                this.set(tt, lt, mt)
            }
            set(tt, lt, mt) {
                if (lt === void 0 && mt === void 0) {
                    const ft = tt;
                    ft && ft.isColor ? this.copy(ft) : typeof ft == "number" ? this.setHex(ft) : typeof ft == "string" && this.setStyle(ft)
                } else
                    this.setRGB(tt, lt, mt);
                return this
            }
            setScalar(tt) {
                return this.r = tt,
                this.g = tt,
                this.b = tt,
                this
            }
            setHex(tt, lt=jo) {
                return tt = Math.floor(tt),
                this.r = (tt >> 16 & 255) / 255,
                this.g = (tt >> 8 & 255) / 255,
                this.b = (255 & tt) / 255,
                Do.toWorkingColorSpace(this, lt),
                this
            }
            setRGB(tt, lt, mt, ft=Do.workingColorSpace) {
                return this.r = tt,
                this.g = lt,
                this.b = mt,
                Do.toWorkingColorSpace(this, ft),
                this
            }
            setHSL(tt, lt, mt, ft=Do.workingColorSpace) {
                if (tt = em(tt, 1),
                lt = qo(lt, 0, 1),
                mt = qo(mt, 0, 1),
                lt === 0)
                    this.r = this.g = this.b = mt;
                else {
                    const xt = mt <= .5 ? mt * (1 + lt) : mt + lt - mt * lt
                      , Ct = 2 * mt - xt;
                    this.r = h_(Ct, xt, tt + 1 / 3),
                    this.g = h_(Ct, xt, tt),
                    this.b = h_(Ct, xt, tt - 1 / 3)
                }
                return Do.toWorkingColorSpace(this, ft),
                this
            }
            setStyle(tt, lt=jo) {
                function mt(xt) {
                    xt !== void 0 && parseFloat(xt) < 1 && console.warn("THREE.Color: Alpha component of " + tt + " will be ignored.")
                }
                let ft;
                if (ft = /^(\w+)\(([^\)]*)\)/.exec(tt)) {
                    let xt;
                    const Ct = ft[1]
                      , Mt = ft[2];
                    switch (Ct) {
                    case "rgb":
                    case "rgba":
                        if (xt = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Mt))
                            return mt(xt[4]),
                            this.setRGB(Math.min(255, parseInt(xt[1], 10)) / 255, Math.min(255, parseInt(xt[2], 10)) / 255, Math.min(255, parseInt(xt[3], 10)) / 255, lt);
                        if (xt = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Mt))
                            return mt(xt[4]),
                            this.setRGB(Math.min(100, parseInt(xt[1], 10)) / 100, Math.min(100, parseInt(xt[2], 10)) / 100, Math.min(100, parseInt(xt[3], 10)) / 100, lt);
                        break;
                    case "hsl":
                    case "hsla":
                        if (xt = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Mt))
                            return mt(xt[4]),
                            this.setHSL(parseFloat(xt[1]) / 360, parseFloat(xt[2]) / 100, parseFloat(xt[3]) / 100, lt);
                        break;
                    default:
                        console.warn("THREE.Color: Unknown color model " + tt)
                    }
                } else if (ft = /^\#([A-Fa-f\d]+)$/.exec(tt)) {
                    const xt = ft[1]
                      , Ct = xt.length;
                    if (Ct === 3)
                        return this.setRGB(parseInt(xt.charAt(0), 16) / 15, parseInt(xt.charAt(1), 16) / 15, parseInt(xt.charAt(2), 16) / 15, lt);
                    if (Ct === 6)
                        return this.setHex(parseInt(xt, 16), lt);
                    console.warn("THREE.Color: Invalid hex color " + tt)
                } else if (tt && tt.length > 0)
                    return this.setColorName(tt, lt);
                return this
            }
            setColorName(tt, lt=jo) {
                const mt = p_[tt.toLowerCase()];
                return mt !== void 0 ? this.setHex(mt, lt) : console.warn("THREE.Color: Unknown color " + tt),
                this
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copy(tt) {
                return this.r = tt.r,
                this.g = tt.g,
                this.b = tt.b,
                this
            }
            copySRGBToLinear(tt) {
                return this.r = Uu(tt.r),
                this.g = Uu(tt.g),
                this.b = Uu(tt.b),
                this
            }
            copyLinearToSRGB(tt) {
                return this.r = nm(tt.r),
                this.g = nm(tt.g),
                this.b = nm(tt.b),
                this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this),
                this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this),
                this
            }
            getHex(tt=jo) {
                return Do.fromWorkingColorSpace(ms.copy(this), tt),
                65536 * Math.round(qo(255 * ms.r, 0, 255)) + 256 * Math.round(qo(255 * ms.g, 0, 255)) + Math.round(qo(255 * ms.b, 0, 255))
            }
            getHexString(tt=jo) {
                return ("000000" + this.getHex(tt).toString(16)).slice(-6)
            }
            getHSL(tt, lt=Do.workingColorSpace) {
                Do.fromWorkingColorSpace(ms.copy(this), lt);
                const mt = ms.r
                  , ft = ms.g
                  , xt = ms.b
                  , Ct = Math.max(mt, ft, xt)
                  , Mt = Math.min(mt, ft, xt);
                let Lt, Nt;
                const jt = (Mt + Ct) / 2;
                if (Mt === Ct)
                    Lt = 0,
                    Nt = 0;
                else {
                    const Wt = Ct - Mt;
                    switch (Nt = jt <= .5 ? Wt / (Ct + Mt) : Wt / (2 - Ct - Mt),
                    Ct) {
                    case mt:
                        Lt = (ft - xt) / Wt + (ft < xt ? 6 : 0);
                        break;
                    case ft:
                        Lt = (xt - mt) / Wt + 2;
                        break;
                    case xt:
                        Lt = (mt - ft) / Wt + 4
                    }
                    Lt /= 6
                }
                return tt.h = Lt,
                tt.s = Nt,
                tt.l = jt,
                tt
            }
            getRGB(tt, lt=Do.workingColorSpace) {
                return Do.fromWorkingColorSpace(ms.copy(this), lt),
                tt.r = ms.r,
                tt.g = ms.g,
                tt.b = ms.b,
                tt
            }
            getStyle(tt=jo) {
                Do.fromWorkingColorSpace(ms.copy(this), tt);
                const lt = ms.r
                  , mt = ms.g
                  , ft = ms.b;
                return tt !== jo ? `color(${tt} ${lt.toFixed(3)} ${mt.toFixed(3)} ${ft.toFixed(3)})` : `rgb(${Math.round(255 * lt)},${Math.round(255 * mt)},${Math.round(255 * ft)})`
            }
            offsetHSL(tt, lt, mt) {
                return this.getHSL(Vl),
                this.setHSL(Vl.h + tt, Vl.s + lt, Vl.l + mt)
            }
            add(tt) {
                return this.r += tt.r,
                this.g += tt.g,
                this.b += tt.b,
                this
            }
            addColors(tt, lt) {
                return this.r = tt.r + lt.r,
                this.g = tt.g + lt.g,
                this.b = tt.b + lt.b,
                this
            }
            addScalar(tt) {
                return this.r += tt,
                this.g += tt,
                this.b += tt,
                this
            }
            sub(tt) {
                return this.r = Math.max(0, this.r - tt.r),
                this.g = Math.max(0, this.g - tt.g),
                this.b = Math.max(0, this.b - tt.b),
                this
            }
            multiply(tt) {
                return this.r *= tt.r,
                this.g *= tt.g,
                this.b *= tt.b,
                this
            }
            multiplyScalar(tt) {
                return this.r *= tt,
                this.g *= tt,
                this.b *= tt,
                this
            }
            lerp(tt, lt) {
                return this.r += (tt.r - this.r) * lt,
                this.g += (tt.g - this.g) * lt,
                this.b += (tt.b - this.b) * lt,
                this
            }
            lerpColors(tt, lt, mt) {
                return this.r = tt.r + (lt.r - tt.r) * mt,
                this.g = tt.g + (lt.g - tt.g) * mt,
                this.b = tt.b + (lt.b - tt.b) * mt,
                this
            }
            lerpHSL(tt, lt) {
                this.getHSL(Vl),
                tt.getHSL(mm);
                const mt = Fu(Vl.h, mm.h, lt)
                  , ft = Fu(Vl.s, mm.s, lt)
                  , xt = Fu(Vl.l, mm.l, lt);
                return this.setHSL(mt, ft, xt),
                this
            }
            setFromVector3(tt) {
                return this.r = tt.x,
                this.g = tt.y,
                this.b = tt.z,
                this
            }
            applyMatrix3(tt) {
                const lt = this.r
                  , mt = this.g
                  , ft = this.b
                  , xt = tt.elements;
                return this.r = xt[0] * lt + xt[3] * mt + xt[6] * ft,
                this.g = xt[1] * lt + xt[4] * mt + xt[7] * ft,
                this.b = xt[2] * lt + xt[5] * mt + xt[8] * ft,
                this
            }
            equals(tt) {
                return tt.r === this.r && tt.g === this.g && tt.b === this.b
            }
            fromArray(tt, lt=0) {
                return this.r = tt[lt],
                this.g = tt[lt + 1],
                this.b = tt[lt + 2],
                this
            }
            toArray(tt=[], lt=0) {
                return tt[lt] = this.r,
                tt[lt + 1] = this.g,
                tt[lt + 2] = this.b,
                tt
            }
            fromBufferAttribute(tt, lt) {
                return this.r = tt.getX(lt),
                this.g = tt.getY(lt),
                this.b = tt.getZ(lt),
                this
            }
            toJSON() {
                return this.getHex()
            }
            *[Symbol.iterator]() {
                yield this.r,
                yield this.g,
                yield this.b
            }
        }
        const ms = new Gn;
        Gn.NAMES = p_;
        class nu extends hs {
            constructor(tt) {
                super(),
                this.isMeshBasicMaterial = !0,
                this.type = "MeshBasicMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Wn,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.specularMap = tt.specularMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.combine = tt.combine,
                this.reflectivity = tt.reflectivity,
                this.refractionRatio = tt.refractionRatio,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.fog = tt.fog,
                this
            }
        }
        const Dl = O0();
        function O0() {
            const Tt = new ArrayBuffer(4)
              , tt = new Float32Array(Tt)
              , lt = new Uint32Array(Tt)
              , mt = new Uint32Array(512)
              , ft = new Uint32Array(512);
            for (let Lt = 0; Lt < 256; ++Lt) {
                const Nt = Lt - 127;
                Nt < -27 ? (mt[Lt] = 0,
                mt[256 | Lt] = 32768,
                ft[Lt] = 24,
                ft[256 | Lt] = 24) : Nt < -14 ? (mt[Lt] = 1024 >> -Nt - 14,
                mt[256 | Lt] = 1024 >> -Nt - 14 | 32768,
                ft[Lt] = -Nt - 1,
                ft[256 | Lt] = -Nt - 1) : Nt <= 15 ? (mt[Lt] = Nt + 15 << 10,
                mt[256 | Lt] = Nt + 15 << 10 | 32768,
                ft[Lt] = 13,
                ft[256 | Lt] = 13) : Nt < 128 ? (mt[Lt] = 31744,
                mt[256 | Lt] = 64512,
                ft[Lt] = 24,
                ft[256 | Lt] = 24) : (mt[Lt] = 31744,
                mt[256 | Lt] = 64512,
                ft[Lt] = 13,
                ft[256 | Lt] = 13)
            }
            const xt = new Uint32Array(2048)
              , Ct = new Uint32Array(64)
              , Mt = new Uint32Array(64);
            for (let Lt = 1; Lt < 1024; ++Lt) {
                let Nt = Lt << 13
                  , jt = 0;
                for (; !(8388608 & Nt); )
                    Nt <<= 1,
                    jt -= 8388608;
                Nt &= -8388609,
                jt += 947912704,
                xt[Lt] = Nt | jt
            }
            for (let Lt = 1024; Lt < 2048; ++Lt)
                xt[Lt] = 939524096 + (Lt - 1024 << 13);
            for (let Lt = 1; Lt < 31; ++Lt)
                Ct[Lt] = Lt << 23;
            Ct[31] = 1199570944,
            Ct[32] = 2147483648;
            for (let Lt = 33; Lt < 63; ++Lt)
                Ct[Lt] = 2147483648 + (Lt - 32 << 23);
            Ct[63] = 3347054592;
            for (let Lt = 1; Lt < 64; ++Lt)
                Lt !== 32 && (Mt[Lt] = 1024);
            return {
                floatView: tt,
                uint32View: lt,
                baseTable: mt,
                shiftTable: ft,
                mantissaTable: xt,
                exponentTable: Ct,
                offsetTable: Mt
            }
        }
        function Vt(Tt) {
            Math.abs(Tt) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
            Tt = qo(Tt, -65504, 65504),
            Dl.floatView[0] = Tt;
            const tt = Dl.uint32View[0]
              , lt = tt >> 23 & 511;
            return Dl.baseTable[lt] + ((8388607 & tt) >> Dl.shiftTable[lt])
        }
        function wt(Tt) {
            const tt = Tt >> 10;
            return Dl.uint32View[0] = Dl.mantissaTable[Dl.offsetTable[tt] + (1023 & Tt)] + Dl.exponentTable[tt],
            Dl.floatView[0]
        }
        const Rt = {
            toHalfFloat: Vt,
            fromHalfFloat: wt
        }
          , zt = new Er
          , nr = new mn;
        class mr {
            constructor(tt, lt, mt=!1) {
                if (Array.isArray(tt))
                    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0,
                this.name = "",
                this.array = tt,
                this.itemSize = lt,
                this.count = tt !== void 0 ? tt.length / lt : 0,
                this.normalized = mt,
                this.usage = Nu,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.gpuType = ss,
                this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            setUsage(tt) {
                return this.usage = tt,
                this
            }
            copy(tt) {
                return this.name = tt.name,
                this.array = new tt.array.constructor(tt.array),
                this.itemSize = tt.itemSize,
                this.count = tt.count,
                this.normalized = tt.normalized,
                this.usage = tt.usage,
                this.gpuType = tt.gpuType,
                this
            }
            copyAt(tt, lt, mt) {
                tt *= this.itemSize,
                mt *= lt.itemSize;
                for (let ft = 0, xt = this.itemSize; ft < xt; ft++)
                    this.array[tt + ft] = lt.array[mt + ft];
                return this
            }
            copyArray(tt) {
                return this.array.set(tt),
                this
            }
            applyMatrix3(tt) {
                if (this.itemSize === 2)
                    for (let lt = 0, mt = this.count; lt < mt; lt++)
                        nr.fromBufferAttribute(this, lt),
                        nr.applyMatrix3(tt),
                        this.setXY(lt, nr.x, nr.y);
                else if (this.itemSize === 3)
                    for (let lt = 0, mt = this.count; lt < mt; lt++)
                        zt.fromBufferAttribute(this, lt),
                        zt.applyMatrix3(tt),
                        this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            applyMatrix4(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    zt.fromBufferAttribute(this, lt),
                    zt.applyMatrix4(tt),
                    this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            applyNormalMatrix(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    zt.fromBufferAttribute(this, lt),
                    zt.applyNormalMatrix(tt),
                    this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            transformDirection(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    zt.fromBufferAttribute(this, lt),
                    zt.transformDirection(tt),
                    this.setXYZ(lt, zt.x, zt.y, zt.z);
                return this
            }
            set(tt, lt=0) {
                return this.array.set(tt, lt),
                this
            }
            getComponent(tt, lt) {
                let mt = this.array[tt * this.itemSize + lt];
                return this.normalized && (mt = ws(mt, this.array)),
                mt
            }
            setComponent(tt, lt, mt) {
                return this.normalized && (mt = oo(mt, this.array)),
                this.array[tt * this.itemSize + lt] = mt,
                this
            }
            getX(tt) {
                let lt = this.array[tt * this.itemSize];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setX(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize] = lt,
                this
            }
            getY(tt) {
                let lt = this.array[tt * this.itemSize + 1];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setY(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 1] = lt,
                this
            }
            getZ(tt) {
                let lt = this.array[tt * this.itemSize + 2];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setZ(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 2] = lt,
                this
            }
            getW(tt) {
                let lt = this.array[tt * this.itemSize + 3];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setW(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 3] = lt,
                this
            }
            setXY(tt, lt, mt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array)),
                this.array[tt + 0] = lt,
                this.array[tt + 1] = mt,
                this
            }
            setXYZ(tt, lt, mt, ft) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array)),
                this.array[tt + 0] = lt,
                this.array[tt + 1] = mt,
                this.array[tt + 2] = ft,
                this
            }
            setXYZW(tt, lt, mt, ft, xt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array),
                xt = oo(xt, this.array)),
                this.array[tt + 0] = lt,
                this.array[tt + 1] = mt,
                this.array[tt + 2] = ft,
                this.array[tt + 3] = xt,
                this
            }
            onUpload(tt) {
                return this.onUploadCallback = tt,
                this
            }
            clone() {
                return new this.constructor(this.array,this.itemSize).copy(this)
            }
            toJSON() {
                const tt = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return this.name !== "" && (tt.name = this.name),
                this.usage !== Nu && (tt.usage = this.usage),
                this.updateRange.offset === 0 && this.updateRange.count === -1 || (tt.updateRange = this.updateRange),
                tt
            }
        }
        class Tr extends mr {
            constructor(tt, lt, mt) {
                super(new Int8Array(tt), lt, mt)
            }
        }
        class $r extends mr {
            constructor(tt, lt, mt) {
                super(new Uint8Array(tt), lt, mt)
            }
        }
        class vn extends mr {
            constructor(tt, lt, mt) {
                super(new Uint8ClampedArray(tt), lt, mt)
            }
        }
        class zn extends mr {
            constructor(tt, lt, mt) {
                super(new Int16Array(tt), lt, mt)
            }
        }
        class co extends mr {
            constructor(tt, lt, mt) {
                super(new Uint16Array(tt), lt, mt)
            }
        }
        class is extends mr {
            constructor(tt, lt, mt) {
                super(new Int32Array(tt), lt, mt)
            }
        }
        class Ts extends mr {
            constructor(tt, lt, mt) {
                super(new Uint32Array(tt), lt, mt)
            }
        }
        class ks extends mr {
            constructor(tt, lt, mt) {
                super(new Uint16Array(tt), lt, mt),
                this.isFloat16BufferAttribute = !0
            }
            getX(tt) {
                let lt = wt(this.array[tt * this.itemSize]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setX(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize] = Vt(lt),
                this
            }
            getY(tt) {
                let lt = wt(this.array[tt * this.itemSize + 1]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setY(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 1] = Vt(lt),
                this
            }
            getZ(tt) {
                let lt = wt(this.array[tt * this.itemSize + 2]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setZ(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 2] = Vt(lt),
                this
            }
            getW(tt) {
                let lt = wt(this.array[tt * this.itemSize + 3]);
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setW(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.array[tt * this.itemSize + 3] = Vt(lt),
                this
            }
            setXY(tt, lt, mt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array)),
                this.array[tt + 0] = Vt(lt),
                this.array[tt + 1] = Vt(mt),
                this
            }
            setXYZ(tt, lt, mt, ft) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array)),
                this.array[tt + 0] = Vt(lt),
                this.array[tt + 1] = Vt(mt),
                this.array[tt + 2] = Vt(ft),
                this
            }
            setXYZW(tt, lt, mt, ft, xt) {
                return tt *= this.itemSize,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array),
                xt = oo(xt, this.array)),
                this.array[tt + 0] = Vt(lt),
                this.array[tt + 1] = Vt(mt),
                this.array[tt + 2] = Vt(ft),
                this.array[tt + 3] = Vt(xt),
                this
            }
        }
        class Fn extends mr {
            constructor(tt, lt, mt) {
                super(new Float32Array(tt), lt, mt)
            }
        }
        class m_ extends mr {
            constructor(tt, lt, mt) {
                super(new Float64Array(tt), lt, mt)
            }
        }
        let fm = 0;
        const Ds = new no
          , Ju = new Mo
          , Gl = new Er
          , Us = new Tl
          , Ap = new Tl
          , fs = new Er;
        class bo extends As {
            constructor() {
                super(),
                this.isBufferGeometry = !0,
                Object.defineProperty(this, "id", {
                    value: fm++
                }),
                this.uuid = Ms(),
                this.name = "",
                this.type = "BufferGeometry",
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.morphTargetsRelative = !1,
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.drawRange = {
                    start: 0,
                    count: 1 / 0
                },
                this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(tt) {
                return Array.isArray(tt) ? this.index = new (tv(tt) ? Ts : co)(tt,1) : this.index = tt,
                this
            }
            getAttribute(tt) {
                return this.attributes[tt]
            }
            setAttribute(tt, lt) {
                return this.attributes[tt] = lt,
                this
            }
            deleteAttribute(tt) {
                return delete this.attributes[tt],
                this
            }
            hasAttribute(tt) {
                return this.attributes[tt] !== void 0
            }
            addGroup(tt, lt, mt=0) {
                this.groups.push({
                    start: tt,
                    count: lt,
                    materialIndex: mt
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(tt, lt) {
                this.drawRange.start = tt,
                this.drawRange.count = lt
            }
            applyMatrix4(tt) {
                const lt = this.attributes.position;
                lt !== void 0 && (lt.applyMatrix4(tt),
                lt.needsUpdate = !0);
                const mt = this.attributes.normal;
                if (mt !== void 0) {
                    const xt = new lo().getNormalMatrix(tt);
                    mt.applyNormalMatrix(xt),
                    mt.needsUpdate = !0
                }
                const ft = this.attributes.tangent;
                return ft !== void 0 && (ft.transformDirection(tt),
                ft.needsUpdate = !0),
                this.boundingBox !== null && this.computeBoundingBox(),
                this.boundingSphere !== null && this.computeBoundingSphere(),
                this
            }
            applyQuaternion(tt) {
                return Ds.makeRotationFromQuaternion(tt),
                this.applyMatrix4(Ds),
                this
            }
            rotateX(tt) {
                return Ds.makeRotationX(tt),
                this.applyMatrix4(Ds),
                this
            }
            rotateY(tt) {
                return Ds.makeRotationY(tt),
                this.applyMatrix4(Ds),
                this
            }
            rotateZ(tt) {
                return Ds.makeRotationZ(tt),
                this.applyMatrix4(Ds),
                this
            }
            translate(tt, lt, mt) {
                return Ds.makeTranslation(tt, lt, mt),
                this.applyMatrix4(Ds),
                this
            }
            scale(tt, lt, mt) {
                return Ds.makeScale(tt, lt, mt),
                this.applyMatrix4(Ds),
                this
            }
            lookAt(tt) {
                return Ju.lookAt(tt),
                Ju.updateMatrix(),
                this.applyMatrix4(Ju.matrix),
                this
            }
            center(tt=void 0) {
                return this.computeBoundingBox(),
                this.boundingBox.getCenter(Gl).negate(),
                this.translate(Gl.x, Gl.y, Gl.z),
                tt && tt.copy(Gl),
                this
            }
            setFromPoints(tt) {
                const lt = [];
                for (let mt = 0, ft = tt.length; mt < ft; mt++) {
                    const xt = tt[mt];
                    lt.push(xt.x, xt.y, xt.z || 0)
                }
                return this.setAttribute("position", new Fn(lt,3)),
                this
            }
            computeBoundingBox() {
                this.boundingBox === null && (this.boundingBox = new Tl);
                const tt = this.attributes.position
                  , lt = this.morphAttributes.position;
                if (tt && tt.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingBox.set(new Er(-1 / 0,-1 / 0,-1 / 0), new Er(1 / 0,1 / 0,1 / 0));
                if (tt !== void 0) {
                    if (this.boundingBox.setFromBufferAttribute(tt),
                    lt)
                        for (let mt = 0, ft = lt.length; mt < ft; mt++) {
                            const xt = lt[mt];
                            Us.setFromBufferAttribute(xt),
                            this.morphTargetsRelative ? (fs.addVectors(this.boundingBox.min, Us.min),
                            this.boundingBox.expandByPoint(fs),
                            fs.addVectors(this.boundingBox.max, Us.max),
                            this.boundingBox.expandByPoint(fs)) : (this.boundingBox.expandByPoint(Us.min),
                            this.boundingBox.expandByPoint(Us.max))
                        }
                } else
                    this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                this.boundingSphere === null && (this.boundingSphere = new Ws);
                const tt = this.attributes.position
                  , lt = this.morphAttributes.position;
                if (tt && tt.isGLBufferAttribute)
                    return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                    void this.boundingSphere.set(new Er, 1 / 0);
                if (tt) {
                    const mt = this.boundingSphere.center;
                    if (Us.setFromBufferAttribute(tt),
                    lt)
                        for (let xt = 0, Ct = lt.length; xt < Ct; xt++) {
                            const Mt = lt[xt];
                            Ap.setFromBufferAttribute(Mt),
                            this.morphTargetsRelative ? (fs.addVectors(Us.min, Ap.min),
                            Us.expandByPoint(fs),
                            fs.addVectors(Us.max, Ap.max),
                            Us.expandByPoint(fs)) : (Us.expandByPoint(Ap.min),
                            Us.expandByPoint(Ap.max))
                        }
                    Us.getCenter(mt);
                    let ft = 0;
                    for (let xt = 0, Ct = tt.count; xt < Ct; xt++)
                        fs.fromBufferAttribute(tt, xt),
                        ft = Math.max(ft, mt.distanceToSquared(fs));
                    if (lt)
                        for (let xt = 0, Ct = lt.length; xt < Ct; xt++) {
                            const Mt = lt[xt]
                              , Lt = this.morphTargetsRelative;
                            for (let Nt = 0, jt = Mt.count; Nt < jt; Nt++)
                                fs.fromBufferAttribute(Mt, Nt),
                                Lt && (Gl.fromBufferAttribute(tt, Nt),
                                fs.add(Gl)),
                                ft = Math.max(ft, mt.distanceToSquared(fs))
                        }
                    this.boundingSphere.radius = Math.sqrt(ft),
                    isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const tt = this.index
                  , lt = this.attributes;
                if (tt === null || lt.position === void 0 || lt.normal === void 0 || lt.uv === void 0)
                    return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const mt = tt.array
                  , ft = lt.position.array
                  , xt = lt.normal.array
                  , Ct = lt.uv.array
                  , Mt = ft.length / 3;
                this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new mr(new Float32Array(4 * Mt),4));
                const Lt = this.getAttribute("tangent").array
                  , Nt = []
                  , jt = [];
                for (let Vr = 0; Vr < Mt; Vr++)
                    Nt[Vr] = new Er,
                    jt[Vr] = new Er;
                const Wt = new Er
                  , Qt = new Er
                  , qt = new Er
                  , Xt = new mn
                  , Zt = new mn
                  , Yt = new mn
                  , sr = new Er
                  , er = new Er;
                function rr(Vr, Gr, Hr) {
                    Wt.fromArray(ft, 3 * Vr),
                    Qt.fromArray(ft, 3 * Gr),
                    qt.fromArray(ft, 3 * Hr),
                    Xt.fromArray(Ct, 2 * Vr),
                    Zt.fromArray(Ct, 2 * Gr),
                    Yt.fromArray(Ct, 2 * Hr),
                    Qt.sub(Wt),
                    qt.sub(Wt),
                    Zt.sub(Xt),
                    Yt.sub(Xt);
                    const _n = 1 / (Zt.x * Yt.y - Yt.x * Zt.y);
                    isFinite(_n) && (sr.copy(Qt).multiplyScalar(Yt.y).addScaledVector(qt, -Zt.y).multiplyScalar(_n),
                    er.copy(qt).multiplyScalar(Zt.x).addScaledVector(Qt, -Yt.x).multiplyScalar(_n),
                    Nt[Vr].add(sr),
                    Nt[Gr].add(sr),
                    Nt[Hr].add(sr),
                    jt[Vr].add(er),
                    jt[Gr].add(er),
                    jt[Hr].add(er))
                }
                let xr = this.groups;
                xr.length === 0 && (xr = [{
                    start: 0,
                    count: mt.length
                }]);
                for (let Vr = 0, Gr = xr.length; Vr < Gr; ++Vr) {
                    const Hr = xr[Vr]
                      , _n = Hr.start;
                    for (let dn = _n, kn = _n + Hr.count; dn < kn; dn += 3)
                        rr(mt[dn + 0], mt[dn + 1], mt[dn + 2])
                }
                const br = new Er
                  , yr = new Er
                  , Pr = new Er
                  , zr = new Er;
                function Nr(Vr) {
                    Pr.fromArray(xt, 3 * Vr),
                    zr.copy(Pr);
                    const Gr = Nt[Vr];
                    br.copy(Gr),
                    br.sub(Pr.multiplyScalar(Pr.dot(Gr))).normalize(),
                    yr.crossVectors(zr, Gr);
                    const Hr = yr.dot(jt[Vr]) < 0 ? -1 : 1;
                    Lt[4 * Vr] = br.x,
                    Lt[4 * Vr + 1] = br.y,
                    Lt[4 * Vr + 2] = br.z,
                    Lt[4 * Vr + 3] = Hr
                }
                for (let Vr = 0, Gr = xr.length; Vr < Gr; ++Vr) {
                    const Hr = xr[Vr]
                      , _n = Hr.start;
                    for (let dn = _n, kn = _n + Hr.count; dn < kn; dn += 3)
                        Nr(mt[dn + 0]),
                        Nr(mt[dn + 1]),
                        Nr(mt[dn + 2])
                }
            }
            computeVertexNormals() {
                const tt = this.index
                  , lt = this.getAttribute("position");
                if (lt !== void 0) {
                    let mt = this.getAttribute("normal");
                    if (mt === void 0)
                        mt = new mr(new Float32Array(3 * lt.count),3),
                        this.setAttribute("normal", mt);
                    else
                        for (let Qt = 0, qt = mt.count; Qt < qt; Qt++)
                            mt.setXYZ(Qt, 0, 0, 0);
                    const ft = new Er
                      , xt = new Er
                      , Ct = new Er
                      , Mt = new Er
                      , Lt = new Er
                      , Nt = new Er
                      , jt = new Er
                      , Wt = new Er;
                    if (tt)
                        for (let Qt = 0, qt = tt.count; Qt < qt; Qt += 3) {
                            const Xt = tt.getX(Qt + 0)
                              , Zt = tt.getX(Qt + 1)
                              , Yt = tt.getX(Qt + 2);
                            ft.fromBufferAttribute(lt, Xt),
                            xt.fromBufferAttribute(lt, Zt),
                            Ct.fromBufferAttribute(lt, Yt),
                            jt.subVectors(Ct, xt),
                            Wt.subVectors(ft, xt),
                            jt.cross(Wt),
                            Mt.fromBufferAttribute(mt, Xt),
                            Lt.fromBufferAttribute(mt, Zt),
                            Nt.fromBufferAttribute(mt, Yt),
                            Mt.add(jt),
                            Lt.add(jt),
                            Nt.add(jt),
                            mt.setXYZ(Xt, Mt.x, Mt.y, Mt.z),
                            mt.setXYZ(Zt, Lt.x, Lt.y, Lt.z),
                            mt.setXYZ(Yt, Nt.x, Nt.y, Nt.z)
                        }
                    else
                        for (let Qt = 0, qt = lt.count; Qt < qt; Qt += 3)
                            ft.fromBufferAttribute(lt, Qt + 0),
                            xt.fromBufferAttribute(lt, Qt + 1),
                            Ct.fromBufferAttribute(lt, Qt + 2),
                            jt.subVectors(Ct, xt),
                            Wt.subVectors(ft, xt),
                            jt.cross(Wt),
                            mt.setXYZ(Qt + 0, jt.x, jt.y, jt.z),
                            mt.setXYZ(Qt + 1, jt.x, jt.y, jt.z),
                            mt.setXYZ(Qt + 2, jt.x, jt.y, jt.z);
                    this.normalizeNormals(),
                    mt.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const tt = this.attributes.normal;
                for (let lt = 0, mt = tt.count; lt < mt; lt++)
                    fs.fromBufferAttribute(tt, lt),
                    fs.normalize(),
                    tt.setXYZ(lt, fs.x, fs.y, fs.z)
            }
            toNonIndexed() {
                function tt(Mt, Lt) {
                    const Nt = Mt.array
                      , jt = Mt.itemSize
                      , Wt = Mt.normalized
                      , Qt = new Nt.constructor(Lt.length * jt);
                    let qt = 0
                      , Xt = 0;
                    for (let Zt = 0, Yt = Lt.length; Zt < Yt; Zt++) {
                        qt = Mt.isInterleavedBufferAttribute ? Lt[Zt] * Mt.data.stride + Mt.offset : Lt[Zt] * jt;
                        for (let sr = 0; sr < jt; sr++)
                            Qt[Xt++] = Nt[qt++]
                    }
                    return new mr(Qt,jt,Wt)
                }
                if (this.index === null)
                    return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                    this;
                const lt = new bo
                  , mt = this.index.array
                  , ft = this.attributes;
                for (const Mt in ft) {
                    const Lt = tt(ft[Mt], mt);
                    lt.setAttribute(Mt, Lt)
                }
                const xt = this.morphAttributes;
                for (const Mt in xt) {
                    const Lt = []
                      , Nt = xt[Mt];
                    for (let jt = 0, Wt = Nt.length; jt < Wt; jt++) {
                        const Qt = tt(Nt[jt], mt);
                        Lt.push(Qt)
                    }
                    lt.morphAttributes[Mt] = Lt
                }
                lt.morphTargetsRelative = this.morphTargetsRelative;
                const Ct = this.groups;
                for (let Mt = 0, Lt = Ct.length; Mt < Lt; Mt++) {
                    const Nt = Ct[Mt];
                    lt.addGroup(Nt.start, Nt.count, Nt.materialIndex)
                }
                return lt
            }
            toJSON() {
                const tt = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (tt.uuid = this.uuid,
                tt.type = this.type,
                this.name !== "" && (tt.name = this.name),
                Object.keys(this.userData).length > 0 && (tt.userData = this.userData),
                this.parameters !== void 0) {
                    const Lt = this.parameters;
                    for (const Nt in Lt)
                        Lt[Nt] !== void 0 && (tt[Nt] = Lt[Nt]);
                    return tt
                }
                tt.data = {
                    attributes: {}
                };
                const lt = this.index;
                lt !== null && (tt.data.index = {
                    type: lt.array.constructor.name,
                    array: Array.prototype.slice.call(lt.array)
                });
                const mt = this.attributes;
                for (const Lt in mt) {
                    const Nt = mt[Lt];
                    tt.data.attributes[Lt] = Nt.toJSON(tt.data)
                }
                const ft = {};
                let xt = !1;
                for (const Lt in this.morphAttributes) {
                    const Nt = this.morphAttributes[Lt]
                      , jt = [];
                    for (let Wt = 0, Qt = Nt.length; Wt < Qt; Wt++) {
                        const qt = Nt[Wt];
                        jt.push(qt.toJSON(tt.data))
                    }
                    jt.length > 0 && (ft[Lt] = jt,
                    xt = !0)
                }
                xt && (tt.data.morphAttributes = ft,
                tt.data.morphTargetsRelative = this.morphTargetsRelative);
                const Ct = this.groups;
                Ct.length > 0 && (tt.data.groups = JSON.parse(JSON.stringify(Ct)));
                const Mt = this.boundingSphere;
                return Mt !== null && (tt.data.boundingSphere = {
                    center: Mt.center.toArray(),
                    radius: Mt.radius
                }),
                tt
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null;
                const lt = {};
                this.name = tt.name;
                const mt = tt.index;
                mt !== null && this.setIndex(mt.clone(lt));
                const ft = tt.attributes;
                for (const Nt in ft) {
                    const jt = ft[Nt];
                    this.setAttribute(Nt, jt.clone(lt))
                }
                const xt = tt.morphAttributes;
                for (const Nt in xt) {
                    const jt = []
                      , Wt = xt[Nt];
                    for (let Qt = 0, qt = Wt.length; Qt < qt; Qt++)
                        jt.push(Wt[Qt].clone(lt));
                    this.morphAttributes[Nt] = jt
                }
                this.morphTargetsRelative = tt.morphTargetsRelative;
                const Ct = tt.groups;
                for (let Nt = 0, jt = Ct.length; Nt < jt; Nt++) {
                    const Wt = Ct[Nt];
                    this.addGroup(Wt.start, Wt.count, Wt.materialIndex)
                }
                const Mt = tt.boundingBox;
                Mt !== null && (this.boundingBox = Mt.clone());
                const Lt = tt.boundingSphere;
                return Lt !== null && (this.boundingSphere = Lt.clone()),
                this.drawRange.start = tt.drawRange.start,
                this.drawRange.count = tt.drawRange.count,
                this.userData = tt.userData,
                this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Ly = new no
          , wp = new Qu
          , pv = new Ws
          , Oy = new Er
          , gm = new Er
          , _m = new Er
          , vm = new Er
          , N0 = new Er
          , hv = new Er
          , mv = new mn
          , fv = new mn
          , gv = new mn
          , Ny = new Er
          , Fy = new Er
          , Uy = new Er
          , _v = new Er
          , vv = new Er;
        class gs extends Mo {
            constructor(tt=new bo, lt=new nu) {
                super(),
                this.isMesh = !0,
                this.type = "Mesh",
                this.geometry = tt,
                this.material = lt,
                this.updateMorphTargets()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.isMesh ? (tt.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = tt.morphTargetInfluences.slice()),
                tt.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, tt.morphTargetDictionary)),
                this.material = Array.isArray(tt.material) ? tt.material.slice() : tt.material,
                this.geometry = tt.geometry,
                this) : this
            }
            updateMorphTargets() {
                const tt = this.geometry.morphAttributes
                  , lt = Object.keys(tt);
                if (lt.length > 0) {
                    const mt = tt[lt[0]];
                    if (mt !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                            const Ct = mt[ft].name || String(ft);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[Ct] = ft
                        }
                    }
                }
            }
            getVertexPosition(tt, lt) {
                const mt = this.geometry
                  , ft = mt.attributes.position
                  , xt = mt.morphAttributes.position
                  , Ct = mt.morphTargetsRelative;
                lt.fromBufferAttribute(ft, tt);
                const Mt = this.morphTargetInfluences;
                if (xt && Mt) {
                    hv.set(0, 0, 0);
                    for (let Lt = 0, Nt = xt.length; Lt < Nt; Lt++) {
                        const jt = Mt[Lt]
                          , Wt = xt[Lt];
                        jt !== 0 && (N0.fromBufferAttribute(Wt, tt),
                        Ct ? hv.addScaledVector(N0, jt) : hv.addScaledVector(N0.sub(lt), jt))
                    }
                    lt.add(hv)
                }
                return lt
            }
            raycast(tt, lt) {
                const mt = this.geometry
                  , ft = this.material
                  , xt = this.matrixWorld;
                if (ft !== void 0) {
                    if (mt.boundingSphere === null && mt.computeBoundingSphere(),
                    pv.copy(mt.boundingSphere),
                    pv.applyMatrix4(xt),
                    wp.copy(tt.ray).recast(tt.near),
                    pv.containsPoint(wp.origin) === !1 && (wp.intersectSphere(pv, Oy) === null || wp.origin.distanceToSquared(Oy) > (tt.far - tt.near) ** 2))
                        return;
                    Ly.copy(xt).invert(),
                    wp.copy(tt.ray).applyMatrix4(Ly),
                    mt.boundingBox !== null && wp.intersectsBox(mt.boundingBox) === !1 || this._computeIntersections(tt, lt, wp)
                }
            }
            _computeIntersections(tt, lt, mt) {
                let ft;
                const xt = this.geometry
                  , Ct = this.material
                  , Mt = xt.index
                  , Lt = xt.attributes.position
                  , Nt = xt.attributes.uv
                  , jt = xt.attributes.uv1
                  , Wt = xt.attributes.normal
                  , Qt = xt.groups
                  , qt = xt.drawRange;
                if (Mt !== null)
                    if (Array.isArray(Ct))
                        for (let Xt = 0, Zt = Qt.length; Xt < Zt; Xt++) {
                            const Yt = Qt[Xt]
                              , sr = Ct[Yt.materialIndex];
                            for (let er = Math.max(Yt.start, qt.start), rr = Math.min(Mt.count, Math.min(Yt.start + Yt.count, qt.start + qt.count)); er < rr; er += 3)
                                ft = yv(this, sr, tt, mt, Nt, jt, Wt, Mt.getX(er), Mt.getX(er + 1), Mt.getX(er + 2)),
                                ft && (ft.faceIndex = Math.floor(er / 3),
                                ft.face.materialIndex = Yt.materialIndex,
                                lt.push(ft))
                        }
                    else
                        for (let Xt = Math.max(0, qt.start), Zt = Math.min(Mt.count, qt.start + qt.count); Xt < Zt; Xt += 3)
                            ft = yv(this, Ct, tt, mt, Nt, jt, Wt, Mt.getX(Xt), Mt.getX(Xt + 1), Mt.getX(Xt + 2)),
                            ft && (ft.faceIndex = Math.floor(Xt / 3),
                            lt.push(ft));
                else if (Lt !== void 0)
                    if (Array.isArray(Ct))
                        for (let Xt = 0, Zt = Qt.length; Xt < Zt; Xt++) {
                            const Yt = Qt[Xt]
                              , sr = Ct[Yt.materialIndex];
                            for (let er = Math.max(Yt.start, qt.start), rr = Math.min(Lt.count, Math.min(Yt.start + Yt.count, qt.start + qt.count)); er < rr; er += 3)
                                ft = yv(this, sr, tt, mt, Nt, jt, Wt, er, er + 1, er + 2),
                                ft && (ft.faceIndex = Math.floor(er / 3),
                                ft.face.materialIndex = Yt.materialIndex,
                                lt.push(ft))
                        }
                    else
                        for (let Xt = Math.max(0, qt.start), Zt = Math.min(Lt.count, qt.start + qt.count); Xt < Zt; Xt += 3)
                            ft = yv(this, Ct, tt, mt, Nt, jt, Wt, Xt, Xt + 1, Xt + 2),
                            ft && (ft.faceIndex = Math.floor(Xt / 3),
                            lt.push(ft))
            }
        }
        function yv(Tt, tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
            Tt.getVertexPosition(Mt, gm),
            Tt.getVertexPosition(Lt, _m),
            Tt.getVertexPosition(Nt, vm);
            const jt = function(Wt, Qt, qt, Xt, Zt, Yt, sr, er) {
                let rr;
                if (rr = Qt.side === bt ? Xt.intersectTriangle(sr, Yt, Zt, !0, er) : Xt.intersectTriangle(Zt, Yt, sr, Qt.side === vt, er),
                rr === null)
                    return null;
                vv.copy(er),
                vv.applyMatrix4(Wt.matrixWorld);
                const xr = qt.ray.origin.distanceTo(vv);
                return xr < qt.near || xr > qt.far ? null : {
                    distance: xr,
                    point: vv.clone(),
                    object: Wt
                }
            }(Tt, tt, lt, mt, gm, _m, vm, _v);
            if (jt) {
                ft && (mv.fromBufferAttribute(ft, Mt),
                fv.fromBufferAttribute(ft, Lt),
                gv.fromBufferAttribute(ft, Nt),
                jt.uv = Es.getInterpolation(_v, gm, _m, vm, mv, fv, gv, new mn)),
                xt && (mv.fromBufferAttribute(xt, Mt),
                fv.fromBufferAttribute(xt, Lt),
                gv.fromBufferAttribute(xt, Nt),
                jt.uv1 = Es.getInterpolation(_v, gm, _m, vm, mv, fv, gv, new mn),
                jt.uv2 = jt.uv1),
                Ct && (Ny.fromBufferAttribute(Ct, Mt),
                Fy.fromBufferAttribute(Ct, Lt),
                Uy.fromBufferAttribute(Ct, Nt),
                jt.normal = Es.getInterpolation(_v, gm, _m, vm, Ny, Fy, Uy, new Er),
                jt.normal.dot(mt.direction) > 0 && jt.normal.multiplyScalar(-1));
                const Wt = {
                    a: Mt,
                    b: Lt,
                    c: Nt,
                    normal: new Er,
                    materialIndex: 0
                };
                Es.getNormal(gm, _m, vm, Wt.normal),
                jt.face = Wt
            }
            return jt
        }
        class Zu extends bo {
            constructor(tt=1, lt=1, mt=1, ft=1, xt=1, Ct=1) {
                super(),
                this.type = "BoxGeometry",
                this.parameters = {
                    width: tt,
                    height: lt,
                    depth: mt,
                    widthSegments: ft,
                    heightSegments: xt,
                    depthSegments: Ct
                };
                const Mt = this;
                ft = Math.floor(ft),
                xt = Math.floor(xt),
                Ct = Math.floor(Ct);
                const Lt = []
                  , Nt = []
                  , jt = []
                  , Wt = [];
                let Qt = 0
                  , qt = 0;
                function Xt(Zt, Yt, sr, er, rr, xr, br, yr, Pr, zr, Nr) {
                    const Vr = xr / Pr
                      , Gr = br / zr
                      , Hr = xr / 2
                      , _n = br / 2
                      , dn = yr / 2
                      , kn = Pr + 1
                      , Bn = zr + 1;
                    let cn = 0
                      , Yr = 0;
                    const Jr = new Er;
                    for (let sn = 0; sn < Bn; sn++) {
                        const on = sn * Gr - _n;
                        for (let Un = 0; Un < kn; Un++) {
                            const ro = Un * Vr - Hr;
                            Jr[Zt] = ro * er,
                            Jr[Yt] = on * rr,
                            Jr[sr] = dn,
                            Nt.push(Jr.x, Jr.y, Jr.z),
                            Jr[Zt] = 0,
                            Jr[Yt] = 0,
                            Jr[sr] = yr > 0 ? 1 : -1,
                            jt.push(Jr.x, Jr.y, Jr.z),
                            Wt.push(Un / Pr),
                            Wt.push(1 - sn / zr),
                            cn += 1
                        }
                    }
                    for (let sn = 0; sn < zr; sn++)
                        for (let on = 0; on < Pr; on++) {
                            const Un = Qt + on + kn * sn
                              , ro = Qt + on + kn * (sn + 1)
                              , Zn = Qt + (on + 1) + kn * (sn + 1)
                              , jn = Qt + (on + 1) + kn * sn;
                            Lt.push(Un, ro, jn),
                            Lt.push(ro, Zn, jn),
                            Yr += 6
                        }
                    Mt.addGroup(qt, Yr, Nr),
                    qt += Yr,
                    Qt += cn
                }
                Xt("z", "y", "x", -1, -1, mt, lt, tt, Ct, xt, 0),
                Xt("z", "y", "x", 1, -1, mt, lt, -tt, Ct, xt, 1),
                Xt("x", "z", "y", 1, 1, tt, mt, lt, ft, Ct, 2),
                Xt("x", "z", "y", 1, -1, tt, mt, -lt, ft, Ct, 3),
                Xt("x", "y", "z", 1, -1, tt, lt, mt, ft, xt, 4),
                Xt("x", "y", "z", -1, -1, tt, lt, -mt, ft, xt, 5),
                this.setIndex(Lt),
                this.setAttribute("position", new Fn(Nt,3)),
                this.setAttribute("normal", new Fn(jt,3)),
                this.setAttribute("uv", new Fn(Wt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new Zu(tt.width,tt.height,tt.depth,tt.widthSegments,tt.heightSegments,tt.depthSegments)
            }
        }
        function Sp(Tt) {
            const tt = {};
            for (const lt in Tt) {
                tt[lt] = {};
                for (const mt in Tt[lt]) {
                    const ft = Tt[lt][mt];
                    ft && (ft.isColor || ft.isMatrix3 || ft.isMatrix4 || ft.isVector2 || ft.isVector3 || ft.isVector4 || ft.isTexture || ft.isQuaternion) ? ft.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
                    tt[lt][mt] = null) : tt[lt][mt] = ft.clone() : Array.isArray(ft) ? tt[lt][mt] = ft.slice() : tt[lt][mt] = ft
                }
            }
            return tt
        }
        function js(Tt) {
            const tt = {};
            for (let lt = 0; lt < Tt.length; lt++) {
                const mt = Sp(Tt[lt]);
                for (const ft in mt)
                    tt[ft] = mt[ft]
            }
            return tt
        }
        function jy(Tt) {
            return Tt.getRenderTarget() === null ? Tt.outputColorSpace : Do.workingColorSpace
        }
        const Vy = {
            clone: Sp,
            merge: js
        };
        class zl extends hs {
            constructor(tt) {
                super(),
                this.isShaderMaterial = !0,
                this.type = "ShaderMaterial",
                this.defines = {},
                this.uniforms = {},
                this.uniformsGroups = [],
                this.vertexShader = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
                this.fragmentShader = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`,
                this.linewidth = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.fog = !1,
                this.lights = !1,
                this.clipping = !1,
                this.forceSinglePass = !0,
                this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                },
                this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                },
                this.index0AttributeName = void 0,
                this.uniformsNeedUpdate = !1,
                this.glslVersion = null,
                tt !== void 0 && this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.fragmentShader = tt.fragmentShader,
                this.vertexShader = tt.vertexShader,
                this.uniforms = Sp(tt.uniforms),
                this.uniformsGroups = function(lt) {
                    const mt = [];
                    for (let ft = 0; ft < lt.length; ft++)
                        mt.push(lt[ft].clone());
                    return mt
                }(tt.uniformsGroups),
                this.defines = Object.assign({}, tt.defines),
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.fog = tt.fog,
                this.lights = tt.lights,
                this.clipping = tt.clipping,
                this.extensions = Object.assign({}, tt.extensions),
                this.glslVersion = tt.glslVersion,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                lt.glslVersion = this.glslVersion,
                lt.uniforms = {};
                for (const ft in this.uniforms) {
                    const xt = this.uniforms[ft].value;
                    xt && xt.isTexture ? lt.uniforms[ft] = {
                        type: "t",
                        value: xt.toJSON(tt).uuid
                    } : xt && xt.isColor ? lt.uniforms[ft] = {
                        type: "c",
                        value: xt.getHex()
                    } : xt && xt.isVector2 ? lt.uniforms[ft] = {
                        type: "v2",
                        value: xt.toArray()
                    } : xt && xt.isVector3 ? lt.uniforms[ft] = {
                        type: "v3",
                        value: xt.toArray()
                    } : xt && xt.isVector4 ? lt.uniforms[ft] = {
                        type: "v4",
                        value: xt.toArray()
                    } : xt && xt.isMatrix3 ? lt.uniforms[ft] = {
                        type: "m3",
                        value: xt.toArray()
                    } : xt && xt.isMatrix4 ? lt.uniforms[ft] = {
                        type: "m4",
                        value: xt.toArray()
                    } : lt.uniforms[ft] = {
                        value: xt
                    }
                }
                Object.keys(this.defines).length > 0 && (lt.defines = this.defines),
                lt.vertexShader = this.vertexShader,
                lt.fragmentShader = this.fragmentShader,
                lt.lights = this.lights,
                lt.clipping = this.clipping;
                const mt = {};
                for (const ft in this.extensions)
                    this.extensions[ft] === !0 && (mt[ft] = !0);
                return Object.keys(mt).length > 0 && (lt.extensions = mt),
                lt
            }
        }
        class xv extends Mo {
            constructor() {
                super(),
                this.isCamera = !0,
                this.type = "Camera",
                this.matrixWorldInverse = new no,
                this.projectionMatrix = new no,
                this.projectionMatrixInverse = new no,
                this.coordinateSystem = Qs
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.matrixWorldInverse.copy(tt.matrixWorldInverse),
                this.projectionMatrix.copy(tt.projectionMatrix),
                this.projectionMatrixInverse.copy(tt.projectionMatrixInverse),
                this.coordinateSystem = tt.coordinateSystem,
                this
            }
            getWorldDirection(tt) {
                return super.getWorldDirection(tt).negate()
            }
            updateMatrixWorld(tt) {
                super.updateMatrixWorld(tt),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(tt, lt) {
                super.updateWorldMatrix(tt, lt),
                this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class Cs extends xv {
            constructor(tt=50, lt=1, mt=.1, ft=2e3) {
                super(),
                this.isPerspectiveCamera = !0,
                this.type = "PerspectiveCamera",
                this.fov = tt,
                this.zoom = 1,
                this.near = mt,
                this.far = ft,
                this.focus = 10,
                this.aspect = lt,
                this.view = null,
                this.filmGauge = 35,
                this.filmOffset = 0,
                this.updateProjectionMatrix()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.fov = tt.fov,
                this.zoom = tt.zoom,
                this.near = tt.near,
                this.far = tt.far,
                this.focus = tt.focus,
                this.aspect = tt.aspect,
                this.view = tt.view === null ? null : Object.assign({}, tt.view),
                this.filmGauge = tt.filmGauge,
                this.filmOffset = tt.filmOffset,
                this
            }
            setFocalLength(tt) {
                const lt = .5 * this.getFilmHeight() / tt;
                this.fov = 2 * _u * Math.atan(lt),
                this.updateProjectionMatrix()
            }
            getFocalLength() {
                const tt = Math.tan(.5 * Zl * this.fov);
                return .5 * this.getFilmHeight() / tt
            }
            getEffectiveFOV() {
                return 2 * _u * Math.atan(Math.tan(.5 * Zl * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            setViewOffset(tt, lt, mt, ft, xt, Ct) {
                this.aspect = tt / lt,
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = tt,
                this.view.fullHeight = lt,
                this.view.offsetX = mt,
                this.view.offsetY = ft,
                this.view.width = xt,
                this.view.height = Ct,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const tt = this.near;
                let lt = tt * Math.tan(.5 * Zl * this.fov) / this.zoom
                  , mt = 2 * lt
                  , ft = this.aspect * mt
                  , xt = -.5 * ft;
                const Ct = this.view;
                if (this.view !== null && this.view.enabled) {
                    const Lt = Ct.fullWidth
                      , Nt = Ct.fullHeight;
                    xt += Ct.offsetX * ft / Lt,
                    lt -= Ct.offsetY * mt / Nt,
                    ft *= Ct.width / Lt,
                    mt *= Ct.height / Nt
                }
                const Mt = this.filmOffset;
                Mt !== 0 && (xt += tt * Mt / this.getFilmWidth()),
                this.projectionMatrix.makePerspective(xt, xt + ft, lt, lt - mt, tt, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.fov = this.fov,
                lt.object.zoom = this.zoom,
                lt.object.near = this.near,
                lt.object.far = this.far,
                lt.object.focus = this.focus,
                lt.object.aspect = this.aspect,
                this.view !== null && (lt.object.view = Object.assign({}, this.view)),
                lt.object.filmGauge = this.filmGauge,
                lt.object.filmOffset = this.filmOffset,
                lt
            }
        }
        const ym = -90;
        class Gy extends Mo {
            constructor(tt, lt, mt) {
                super(),
                this.type = "CubeCamera",
                this.renderTarget = mt,
                this.coordinateSystem = null,
                this.activeMipmapLevel = 0;
                const ft = new Cs(ym,1,tt,lt);
                ft.layers = this.layers,
                this.add(ft);
                const xt = new Cs(ym,1,tt,lt);
                xt.layers = this.layers,
                this.add(xt);
                const Ct = new Cs(ym,1,tt,lt);
                Ct.layers = this.layers,
                this.add(Ct);
                const Mt = new Cs(ym,1,tt,lt);
                Mt.layers = this.layers,
                this.add(Mt);
                const Lt = new Cs(ym,1,tt,lt);
                Lt.layers = this.layers,
                this.add(Lt);
                const Nt = new Cs(ym,1,tt,lt);
                Nt.layers = this.layers,
                this.add(Nt)
            }
            updateCoordinateSystem() {
                const tt = this.coordinateSystem
                  , lt = this.children.concat()
                  , [mt,ft,xt,Ct,Mt,Lt] = lt;
                for (const Nt of lt)
                    this.remove(Nt);
                if (tt === Qs)
                    mt.up.set(0, 1, 0),
                    mt.lookAt(1, 0, 0),
                    ft.up.set(0, 1, 0),
                    ft.lookAt(-1, 0, 0),
                    xt.up.set(0, 0, -1),
                    xt.lookAt(0, 1, 0),
                    Ct.up.set(0, 0, 1),
                    Ct.lookAt(0, -1, 0),
                    Mt.up.set(0, 1, 0),
                    Mt.lookAt(0, 0, 1),
                    Lt.up.set(0, 1, 0),
                    Lt.lookAt(0, 0, -1);
                else {
                    if (tt !== na)
                        throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + tt);
                    mt.up.set(0, -1, 0),
                    mt.lookAt(-1, 0, 0),
                    ft.up.set(0, -1, 0),
                    ft.lookAt(1, 0, 0),
                    xt.up.set(0, 0, 1),
                    xt.lookAt(0, 1, 0),
                    Ct.up.set(0, 0, -1),
                    Ct.lookAt(0, -1, 0),
                    Mt.up.set(0, -1, 0),
                    Mt.lookAt(0, 0, 1),
                    Lt.up.set(0, -1, 0),
                    Lt.lookAt(0, 0, -1)
                }
                for (const Nt of lt)
                    this.add(Nt),
                    Nt.updateMatrixWorld()
            }
            update(tt, lt) {
                this.parent === null && this.updateMatrixWorld();
                const {renderTarget: mt, activeMipmapLevel: ft} = this;
                this.coordinateSystem !== tt.coordinateSystem && (this.coordinateSystem = tt.coordinateSystem,
                this.updateCoordinateSystem());
                const [xt,Ct,Mt,Lt,Nt,jt] = this.children
                  , Wt = tt.getRenderTarget()
                  , Qt = tt.getActiveCubeFace()
                  , qt = tt.getActiveMipmapLevel()
                  , Xt = tt.xr.enabled;
                tt.xr.enabled = !1;
                const Zt = mt.texture.generateMipmaps;
                mt.texture.generateMipmaps = !1,
                tt.setRenderTarget(mt, 0, ft),
                tt.render(lt, xt),
                tt.setRenderTarget(mt, 1, ft),
                tt.render(lt, Ct),
                tt.setRenderTarget(mt, 2, ft),
                tt.render(lt, Mt),
                tt.setRenderTarget(mt, 3, ft),
                tt.render(lt, Lt),
                tt.setRenderTarget(mt, 4, ft),
                tt.render(lt, Nt),
                mt.texture.generateMipmaps = Zt,
                tt.setRenderTarget(mt, 5, ft),
                tt.render(lt, jt),
                tt.setRenderTarget(Wt, Qt, qt),
                tt.xr.enabled = Xt,
                mt.texture.needsPMREMUpdate = !0
            }
        }
        class f_ extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt) {
                super(tt = tt !== void 0 ? tt : [], lt = lt !== void 0 ? lt : Qr, mt, ft, xt, Ct, Mt, Lt, Nt, jt),
                this.isCubeTexture = !0,
                this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(tt) {
                this.image = tt
            }
        }
        class zy extends Rs {
            constructor(tt=1, lt={}) {
                super(tt, tt, lt),
                this.isWebGLCubeRenderTarget = !0;
                const mt = {
                    width: tt,
                    height: tt,
                    depth: 1
                }
                  , ft = [mt, mt, mt, mt, mt, mt];
                lt.encoding !== void 0 && (xu("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),
                lt.colorSpace = lt.encoding === Ol ? jo : Oo),
                this.texture = new f_(ft,lt.mapping,lt.wrapS,lt.wrapT,lt.magFilter,lt.minFilter,lt.format,lt.type,lt.anisotropy,lt.colorSpace),
                this.texture.isRenderTargetTexture = !0,
                this.texture.generateMipmaps = lt.generateMipmaps !== void 0 && lt.generateMipmaps,
                this.texture.minFilter = lt.minFilter !== void 0 ? lt.minFilter : Rn
            }
            fromEquirectangularTexture(tt, lt) {
                this.texture.type = lt.type,
                this.texture.colorSpace = lt.colorSpace,
                this.texture.generateMipmaps = lt.generateMipmaps,
                this.texture.minFilter = lt.minFilter,
                this.texture.magFilter = lt.magFilter;
                const mt = {
                    tEquirect: {
                        value: null
                    }
                }
                  , ft = `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
                  , xt = `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                  , Ct = new Zu(5,5,5)
                  , Mt = new zl({
                    name: "CubemapFromEquirect",
                    uniforms: Sp(mt),
                    vertexShader: ft,
                    fragmentShader: xt,
                    side: bt,
                    blending: Et
                });
                Mt.uniforms.tEquirect.value = lt;
                const Lt = new gs(Ct,Mt)
                  , Nt = lt.minFilter;
                return lt.minFilter === vo && (lt.minFilter = Rn),
                new Gy(1,10,this).update(tt, Lt),
                lt.minFilter = Nt,
                Lt.geometry.dispose(),
                Lt.material.dispose(),
                this
            }
            clear(tt, lt, mt, ft) {
                const xt = tt.getRenderTarget();
                for (let Ct = 0; Ct < 6; Ct++)
                    tt.setRenderTarget(this, Ct),
                    tt.clear(lt, mt, ft);
                tt.setRenderTarget(xt)
            }
        }
        const F0 = new Er
          , Aw = new Er
          , ww = new lo;
        class _d {
            constructor(tt=new Er(1,0,0), lt=0) {
                this.isPlane = !0,
                this.normal = tt,
                this.constant = lt
            }
            set(tt, lt) {
                return this.normal.copy(tt),
                this.constant = lt,
                this
            }
            setComponents(tt, lt, mt, ft) {
                return this.normal.set(tt, lt, mt),
                this.constant = ft,
                this
            }
            setFromNormalAndCoplanarPoint(tt, lt) {
                return this.normal.copy(tt),
                this.constant = -lt.dot(this.normal),
                this
            }
            setFromCoplanarPoints(tt, lt, mt) {
                const ft = F0.subVectors(mt, lt).cross(Aw.subVectors(tt, lt)).normalize();
                return this.setFromNormalAndCoplanarPoint(ft, tt),
                this
            }
            copy(tt) {
                return this.normal.copy(tt.normal),
                this.constant = tt.constant,
                this
            }
            normalize() {
                const tt = 1 / this.normal.length();
                return this.normal.multiplyScalar(tt),
                this.constant *= tt,
                this
            }
            negate() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            }
            distanceToPoint(tt) {
                return this.normal.dot(tt) + this.constant
            }
            distanceToSphere(tt) {
                return this.distanceToPoint(tt.center) - tt.radius
            }
            projectPoint(tt, lt) {
                return lt.copy(tt).addScaledVector(this.normal, -this.distanceToPoint(tt))
            }
            intersectLine(tt, lt) {
                const mt = tt.delta(F0)
                  , ft = this.normal.dot(mt);
                if (ft === 0)
                    return this.distanceToPoint(tt.start) === 0 ? lt.copy(tt.start) : null;
                const xt = -(tt.start.dot(this.normal) + this.constant) / ft;
                return xt < 0 || xt > 1 ? null : lt.copy(tt.start).addScaledVector(mt, xt)
            }
            intersectsLine(tt) {
                const lt = this.distanceToPoint(tt.start)
                  , mt = this.distanceToPoint(tt.end);
                return lt < 0 && mt > 0 || mt < 0 && lt > 0
            }
            intersectsBox(tt) {
                return tt.intersectsPlane(this)
            }
            intersectsSphere(tt) {
                return tt.intersectsPlane(this)
            }
            coplanarPoint(tt) {
                return tt.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(tt, lt) {
                const mt = lt || ww.getNormalMatrix(tt)
                  , ft = this.coplanarPoint(F0).applyMatrix4(tt)
                  , xt = this.normal.applyMatrix3(mt).normalize();
                return this.constant = -ft.dot(xt),
                this
            }
            translate(tt) {
                return this.constant -= tt.dot(this.normal),
                this
            }
            equals(tt) {
                return tt.normal.equals(this.normal) && tt.constant === this.constant
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const Ep = new Ws
          , bv = new Er;
        class Av {
            constructor(tt=new _d, lt=new _d, mt=new _d, ft=new _d, xt=new _d, Ct=new _d) {
                this.planes = [tt, lt, mt, ft, xt, Ct]
            }
            set(tt, lt, mt, ft, xt, Ct) {
                const Mt = this.planes;
                return Mt[0].copy(tt),
                Mt[1].copy(lt),
                Mt[2].copy(mt),
                Mt[3].copy(ft),
                Mt[4].copy(xt),
                Mt[5].copy(Ct),
                this
            }
            copy(tt) {
                const lt = this.planes;
                for (let mt = 0; mt < 6; mt++)
                    lt[mt].copy(tt.planes[mt]);
                return this
            }
            setFromProjectionMatrix(tt, lt=Qs) {
                const mt = this.planes
                  , ft = tt.elements
                  , xt = ft[0]
                  , Ct = ft[1]
                  , Mt = ft[2]
                  , Lt = ft[3]
                  , Nt = ft[4]
                  , jt = ft[5]
                  , Wt = ft[6]
                  , Qt = ft[7]
                  , qt = ft[8]
                  , Xt = ft[9]
                  , Zt = ft[10]
                  , Yt = ft[11]
                  , sr = ft[12]
                  , er = ft[13]
                  , rr = ft[14]
                  , xr = ft[15];
                if (mt[0].setComponents(Lt - xt, Qt - Nt, Yt - qt, xr - sr).normalize(),
                mt[1].setComponents(Lt + xt, Qt + Nt, Yt + qt, xr + sr).normalize(),
                mt[2].setComponents(Lt + Ct, Qt + jt, Yt + Xt, xr + er).normalize(),
                mt[3].setComponents(Lt - Ct, Qt - jt, Yt - Xt, xr - er).normalize(),
                mt[4].setComponents(Lt - Mt, Qt - Wt, Yt - Zt, xr - rr).normalize(),
                lt === Qs)
                    mt[5].setComponents(Lt + Mt, Qt + Wt, Yt + Zt, xr + rr).normalize();
                else {
                    if (lt !== na)
                        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + lt);
                    mt[5].setComponents(Mt, Wt, Zt, rr).normalize()
                }
                return this
            }
            intersectsObject(tt) {
                if (tt.boundingSphere !== void 0)
                    tt.boundingSphere === null && tt.computeBoundingSphere(),
                    Ep.copy(tt.boundingSphere).applyMatrix4(tt.matrixWorld);
                else {
                    const lt = tt.geometry;
                    lt.boundingSphere === null && lt.computeBoundingSphere(),
                    Ep.copy(lt.boundingSphere).applyMatrix4(tt.matrixWorld)
                }
                return this.intersectsSphere(Ep)
            }
            intersectsSprite(tt) {
                return Ep.center.set(0, 0, 0),
                Ep.radius = .7071067811865476,
                Ep.applyMatrix4(tt.matrixWorld),
                this.intersectsSphere(Ep)
            }
            intersectsSphere(tt) {
                const lt = this.planes
                  , mt = tt.center
                  , ft = -tt.radius;
                for (let xt = 0; xt < 6; xt++)
                    if (lt[xt].distanceToPoint(mt) < ft)
                        return !1;
                return !0
            }
            intersectsBox(tt) {
                const lt = this.planes;
                for (let mt = 0; mt < 6; mt++) {
                    const ft = lt[mt];
                    if (bv.x = ft.normal.x > 0 ? tt.max.x : tt.min.x,
                    bv.y = ft.normal.y > 0 ? tt.max.y : tt.min.y,
                    bv.z = ft.normal.z > 0 ? tt.max.z : tt.min.z,
                    ft.distanceToPoint(bv) < 0)
                        return !1
                }
                return !0
            }
            containsPoint(tt) {
                const lt = this.planes;
                for (let mt = 0; mt < 6; mt++)
                    if (lt[mt].distanceToPoint(tt) < 0)
                        return !1;
                return !0
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        function Hy() {
            let Tt = null
              , tt = !1
              , lt = null
              , mt = null;
            function ft(xt, Ct) {
                lt(xt, Ct),
                mt = Tt.requestAnimationFrame(ft)
            }
            return {
                start: function() {
                    tt !== !0 && lt !== null && (mt = Tt.requestAnimationFrame(ft),
                    tt = !0)
                },
                stop: function() {
                    Tt.cancelAnimationFrame(mt),
                    tt = !1
                },
                setAnimationLoop: function(xt) {
                    lt = xt
                },
                setContext: function(xt) {
                    Tt = xt
                }
            }
        }
        function Sw(Tt, tt) {
            const lt = tt.isWebGL2
              , mt = new WeakMap;
            return {
                get: function(ft) {
                    return ft.isInterleavedBufferAttribute && (ft = ft.data),
                    mt.get(ft)
                },
                remove: function(ft) {
                    ft.isInterleavedBufferAttribute && (ft = ft.data);
                    const xt = mt.get(ft);
                    xt && (Tt.deleteBuffer(xt.buffer),
                    mt.delete(ft))
                },
                update: function(ft, xt) {
                    if (ft.isGLBufferAttribute) {
                        const Mt = mt.get(ft);
                        return void ((!Mt || Mt.version < ft.version) && mt.set(ft, {
                            buffer: ft.buffer,
                            type: ft.type,
                            bytesPerElement: ft.elementSize,
                            version: ft.version
                        }))
                    }
                    ft.isInterleavedBufferAttribute && (ft = ft.data);
                    const Ct = mt.get(ft);
                    Ct === void 0 ? mt.set(ft, function(Mt, Lt) {
                        const Nt = Mt.array
                          , jt = Mt.usage
                          , Wt = Tt.createBuffer();
                        let Qt;
                        if (Tt.bindBuffer(Lt, Wt),
                        Tt.bufferData(Lt, Nt, jt),
                        Mt.onUploadCallback(),
                        Nt instanceof Float32Array)
                            Qt = Tt.FLOAT;
                        else if (Nt instanceof Uint16Array)
                            if (Mt.isFloat16BufferAttribute) {
                                if (!lt)
                                    throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                Qt = Tt.HALF_FLOAT
                            } else
                                Qt = Tt.UNSIGNED_SHORT;
                        else if (Nt instanceof Int16Array)
                            Qt = Tt.SHORT;
                        else if (Nt instanceof Uint32Array)
                            Qt = Tt.UNSIGNED_INT;
                        else if (Nt instanceof Int32Array)
                            Qt = Tt.INT;
                        else if (Nt instanceof Int8Array)
                            Qt = Tt.BYTE;
                        else if (Nt instanceof Uint8Array)
                            Qt = Tt.UNSIGNED_BYTE;
                        else {
                            if (!(Nt instanceof Uint8ClampedArray))
                                throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + Nt);
                            Qt = Tt.UNSIGNED_BYTE
                        }
                        return {
                            buffer: Wt,
                            type: Qt,
                            bytesPerElement: Nt.BYTES_PER_ELEMENT,
                            version: Mt.version
                        }
                    }(ft, xt)) : Ct.version < ft.version && (function(Mt, Lt, Nt) {
                        const jt = Lt.array
                          , Wt = Lt.updateRange;
                        Tt.bindBuffer(Nt, Mt),
                        Wt.count === -1 ? Tt.bufferSubData(Nt, 0, jt) : (lt ? Tt.bufferSubData(Nt, Wt.offset * jt.BYTES_PER_ELEMENT, jt, Wt.offset, Wt.count) : Tt.bufferSubData(Nt, Wt.offset * jt.BYTES_PER_ELEMENT, jt.subarray(Wt.offset, Wt.offset + Wt.count)),
                        Wt.count = -1),
                        Lt.onUploadCallback()
                    }(Ct.buffer, ft, xt),
                    Ct.version = ft.version)
                }
            }
        }
        class g_ extends bo {
            constructor(tt=1, lt=1, mt=1, ft=1) {
                super(),
                this.type = "PlaneGeometry",
                this.parameters = {
                    width: tt,
                    height: lt,
                    widthSegments: mt,
                    heightSegments: ft
                };
                const xt = tt / 2
                  , Ct = lt / 2
                  , Mt = Math.floor(mt)
                  , Lt = Math.floor(ft)
                  , Nt = Mt + 1
                  , jt = Lt + 1
                  , Wt = tt / Mt
                  , Qt = lt / Lt
                  , qt = []
                  , Xt = []
                  , Zt = []
                  , Yt = [];
                for (let sr = 0; sr < jt; sr++) {
                    const er = sr * Qt - Ct;
                    for (let rr = 0; rr < Nt; rr++) {
                        const xr = rr * Wt - xt;
                        Xt.push(xr, -er, 0),
                        Zt.push(0, 0, 1),
                        Yt.push(rr / Mt),
                        Yt.push(1 - sr / Lt)
                    }
                }
                for (let sr = 0; sr < Lt; sr++)
                    for (let er = 0; er < Mt; er++) {
                        const rr = er + Nt * sr
                          , xr = er + Nt * (sr + 1)
                          , br = er + 1 + Nt * (sr + 1)
                          , yr = er + 1 + Nt * sr;
                        qt.push(rr, xr, yr),
                        qt.push(xr, br, yr)
                    }
                this.setIndex(qt),
                this.setAttribute("position", new Fn(Xt,3)),
                this.setAttribute("normal", new Fn(Zt,3)),
                this.setAttribute("uv", new Fn(Yt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new g_(tt.width,tt.height,tt.widthSegments,tt.heightSegments)
            }
        }
        const go = {
            alphahash_fragment: `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
            alphahash_pars_fragment: `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
            alphamap_fragment: `#ifdef USE_ALPHAMAP
	#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1
	diffuseColor.a *= 1.0-texture2D( alphaMap, vAlphaMapUv ).g;
	#else
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
	#endif
#endif`,
            alphamap_pars_fragment: `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
            alphatest_fragment: `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
            alphatest_pars_fragment: `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
            aomap_fragment: `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
            aomap_pars_fragment: `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
            begin_vertex: `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
            beginnormal_vertex: `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
            bsdfs: `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
            iridescence_fragment: `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
            bumpmap_pars_fragment: `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
            clipping_planes_fragment: `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
            clipping_planes_pars_fragment: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
            clipping_planes_pars_vertex: `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
            clipping_planes_vertex: `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
            color_fragment: `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
            color_pars_fragment: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
            color_pars_vertex: `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
            color_vertex: `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
            common: `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
            cube_uv_reflection_fragment: `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
            defaultnormal_vertex: `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
            displacementmap_pars_vertex: `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
            displacementmap_vertex: `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
            emissivemap_fragment: `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
            emissivemap_pars_fragment: `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
            colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            colorspace_pars_fragment: `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 RGBM16ToLinear( in vec4 value ) {
	return vec4( value.rgb * value.a * 16.0, 1.0 );
}
vec4 LinearToRGBM16( in vec4 value ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / 16.0, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * 16.0 ), M );
}`,
            envmap_fragment: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
            envmap_common_pars_fragment: `#ifdef USE_ENVMAP
	mat4 rotationMatrix(vec3 axis, float angle) {
		axis = normalize(axis);
		float s = sin(angle);
		float c = cos(angle);
		float oc = 1.0 - c;
		return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
					oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
					oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
					0.0,                                0.0,                                0.0,                                1.0);
	}
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform float envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`,
            envmap_pars_fragment: `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
            envmap_pars_vertex: `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
            envmap_physical_pars_fragment: `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
		#if defined( FIX_ENV_DIRECTION )
			vec3 worldNormal = normal;
		#else
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#endif
			worldNormal = transformDirection(worldNormal, rotationMatrix(vec3(0,1,0), envMapRotation));
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#if !defined( FIX_ENV_DIRECTION )
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			#endif
			reflectVec = transformDirection(reflectVec, rotationMatrix(vec3(0,1,0), envMapRotation));
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
            envmap_vertex: `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
            fog_vertex: `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
            fog_pars_vertex: `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
            fog_fragment: `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
            fog_pars_fragment: `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
            gradientmap_pars_fragment: `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
            lightmap_fragment: `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
            lightmap_pars_fragment: `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
            lights_lambert_fragment: `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
            lights_lambert_pars_fragment: `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
            lights_pars_begin: `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
            lights_toon_fragment: `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
            lights_toon_pars_fragment: `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
            lights_phong_fragment: `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
            lights_phong_pars_fragment: `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
            lights_physical_fragment: `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
            lights_physical_pars_fragment: `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#if defined( USE_ANISOTROPY ) || defined( USE_ANISOTROPY_BRDF )
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
            lights_fragment_begin: `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal;
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
            lights_fragment_maps: `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
            lights_fragment_end: `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
            logdepthbuf_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
            logdepthbuf_pars_fragment: `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
            logdepthbuf_pars_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
            logdepthbuf_vertex: `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
            map_fragment: `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
            map_pars_fragment: `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
            map_particle_fragment: `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
            map_particle_pars_fragment: `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
            metalnessmap_fragment: `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
            metalnessmap_pars_fragment: `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
            morphcolor_vertex: `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
            morphnormal_vertex: `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
            morphtarget_pars_vertex: `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
            morphtarget_vertex: `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
            normal_fragment_begin: `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
            normal_fragment_maps: `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
            normal_pars_fragment: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
            normal_pars_vertex: `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
            normal_vertex: `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
            normalmap_pars_fragment: `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
            clearcoat_normal_fragment_begin: `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
            clearcoat_normal_fragment_maps: `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
            clearcoat_pars_fragment: `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
            iridescence_pars_fragment: `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
            opaque_fragment: `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
diffuseColor.a = min(max(diffuseColor.a, 0.), 1.);
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
            packing: `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
            premultiplied_alpha_fragment: `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
            project_vertex: `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
            dithering_fragment: `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
            dithering_pars_fragment: `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
            roughnessmap_fragment: `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
            roughnessmap_pars_fragment: `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
            shadowmap_pars_fragment: `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
            shadowmap_pars_vertex: `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
            shadowmap_vertex: `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
            shadowmask_pars_fragment: `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
            skinbase_vertex: `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
            skinning_pars_vertex: `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
            skinning_vertex: `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
            skinnormal_vertex: `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
            specularmap_fragment: `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
            specularmap_pars_fragment: `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
            tonemapping_fragment: `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
            tonemapping_pars_fragment: `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
            transmission_fragment: `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
            transmission_pars_fragment: `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	#ifndef WebGL2Context
	#define textureLod texture2DLodEXT
	#define textureSize(s, lod) vec2(1024./pow(2.,float(lod)),1024./pow(2.,float(lod)))
	#define isinf(x) (x > 1e20 || x < -1e20)
	#endif
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		if(roughness == 0.0) return transmissionSamplerMapTexelToLinear( texture2D( transmissionSamplerMap, fragCoord.xy ) );
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return transmissionSamplerMapTexelToLinear( textureBicubic( transmissionSamplerMap, fragCoord.xy, lod ) );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) || attenuationDistance == 0.0) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
            uv_pars_fragment: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
            uv_pars_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
            uv_vertex: `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
            worldpos_vertex: `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,
            background_vert: `#ifdef HAS_TEXTURE
varying vec2 vUv;
uniform mat3 uvTransform;
uniform bool flipX;
uniform bool flipY;
#endif
void main() {
#ifdef HAS_TEXTURE
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
    vUv = flipX ? vec2( 1.0 - vUv.x, vUv.y ) : vUv;
    vUv = flipY ? vec2( vUv.x, 1.0 - vUv.y ) : vUv;
#endif
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
            background_frag: `#ifdef HAS_TEXTURE
uniform sampler2D t2D;
varying vec2 vUv;
#endif
uniform float backgroundIntensity;
uniform vec3 backgroundColor;
void main() {
#ifdef HAS_TEXTURE
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
#else
	vec4 texColor = vec4( 1.0 );
#endif
	texColor.rgb *= backgroundColor * backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            backgroundCube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            backgroundCube_frag: `#include <envmap_common_pars_fragment>
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
void main() {
	vec3 vReflect = vWorldDirection;
	vReflect = transformDirection(vReflect, rotationMatrix(vec3(0,1,0), envMapRotation));
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vReflect.x, vReflect.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vReflect, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	texColor.rgb *= envMapIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            cube_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
            cube_frag: `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            depth_vert: `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
            depth_frag: `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
            distanceRGBA_vert: `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
            distanceRGBA_frag: `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
            equirect_vert: `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
            equirect_frag: `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
            linedashed_vert: `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            linedashed_frag: `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            meshbasic_vert: `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
            meshbasic_frag: `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshlambert_vert: `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshlambert_frag: `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshmatcap_vert: `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
            meshmatcap_frag: `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshnormal_vert: `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
            meshnormal_frag: `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
            meshphong_vert: `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshphong_frag: `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshphysical_vert: `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
            meshphysical_frag: `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            meshtoon_vert: `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            meshtoon_frag: `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
            points_vert: `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
            points_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
            shadow_vert: `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
            shadow_frag: `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
            sprite_vert: `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
            sprite_frag: `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
        }
          , Dn = {
            common: {
                diffuse: {
                    value: new Gn(16777215)
                },
                opacity: {
                    value: 1
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new lo
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lo
                },
                alphaTest: {
                    value: 0
                }
            },
            specularmap: {
                specularMap: {
                    value: null
                },
                specularMapTransform: {
                    value: new lo
                }
            },
            envmap: {
                envMap: {
                    value: null
                },
                envMapRotation: {
                    value: 0
                },
                flipEnvMap: {
                    value: -1
                },
                reflectivity: {
                    value: 1
                },
                ior: {
                    value: 1.5
                },
                refractionRatio: {
                    value: .98
                }
            },
            aomap: {
                aoMap: {
                    value: null
                },
                aoMapIntensity: {
                    value: 1
                },
                aoMapTransform: {
                    value: new lo
                }
            },
            lightmap: {
                lightMap: {
                    value: null
                },
                lightMapIntensity: {
                    value: 1
                },
                lightMapTransform: {
                    value: new lo
                }
            },
            bumpmap: {
                bumpMap: {
                    value: null
                },
                bumpMapTransform: {
                    value: new lo
                },
                bumpScale: {
                    value: 1
                }
            },
            normalmap: {
                normalMap: {
                    value: null
                },
                normalMapTransform: {
                    value: new lo
                },
                normalScale: {
                    value: new mn(1,1)
                }
            },
            displacementmap: {
                displacementMap: {
                    value: null
                },
                displacementMapTransform: {
                    value: new lo
                },
                displacementScale: {
                    value: 1
                },
                displacementBias: {
                    value: 0
                }
            },
            emissivemap: {
                emissiveMap: {
                    value: null
                },
                emissiveMapTransform: {
                    value: new lo
                }
            },
            metalnessmap: {
                metalnessMap: {
                    value: null
                },
                metalnessMapTransform: {
                    value: new lo
                }
            },
            roughnessmap: {
                roughnessMap: {
                    value: null
                },
                roughnessMapTransform: {
                    value: new lo
                }
            },
            gradientmap: {
                gradientMap: {
                    value: null
                }
            },
            fog: {
                fogDensity: {
                    value: 25e-5
                },
                fogNear: {
                    value: 1
                },
                fogFar: {
                    value: 2e3
                },
                fogColor: {
                    value: new Gn(16777215)
                }
            },
            lights: {
                ambientLightColor: {
                    value: []
                },
                lightProbe: {
                    value: []
                },
                directionalLights: {
                    value: [],
                    properties: {
                        direction: {},
                        color: {}
                    }
                },
                directionalLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                directionalShadowMap: {
                    value: []
                },
                directionalShadowMatrix: {
                    value: []
                },
                spotLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        direction: {},
                        distance: {},
                        coneCos: {},
                        penumbraCos: {},
                        decay: {}
                    }
                },
                spotLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {}
                    }
                },
                spotLightMap: {
                    value: []
                },
                spotShadowMap: {
                    value: []
                },
                spotLightMatrix: {
                    value: []
                },
                pointLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        decay: {},
                        distance: {}
                    }
                },
                pointLightShadows: {
                    value: [],
                    properties: {
                        shadowBias: {},
                        shadowNormalBias: {},
                        shadowRadius: {},
                        shadowMapSize: {},
                        shadowCameraNear: {},
                        shadowCameraFar: {}
                    }
                },
                pointShadowMap: {
                    value: []
                },
                pointShadowMatrix: {
                    value: []
                },
                hemisphereLights: {
                    value: [],
                    properties: {
                        direction: {},
                        skyColor: {},
                        groundColor: {}
                    }
                },
                rectAreaLights: {
                    value: [],
                    properties: {
                        color: {},
                        position: {},
                        width: {},
                        height: {}
                    }
                },
                ltc_1: {
                    value: null
                },
                ltc_2: {
                    value: null
                }
            },
            points: {
                diffuse: {
                    value: new Gn(16777215)
                },
                opacity: {
                    value: 1
                },
                size: {
                    value: 1
                },
                scale: {
                    value: 1
                },
                map: {
                    value: null
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lo
                },
                alphaTest: {
                    value: 0
                },
                uvTransform: {
                    value: new lo
                }
            },
            sprite: {
                diffuse: {
                    value: new Gn(16777215)
                },
                opacity: {
                    value: 1
                },
                center: {
                    value: new mn(.5,.5)
                },
                rotation: {
                    value: 0
                },
                map: {
                    value: null
                },
                mapTransform: {
                    value: new lo
                },
                alphaMap: {
                    value: null
                },
                alphaMapTransform: {
                    value: new lo
                },
                alphaTest: {
                    value: 0
                }
            }
        }
          , qs = {
            basic: {
                uniforms: js([Dn.common, Dn.specularmap, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.fog]),
                vertexShader: go.meshbasic_vert,
                fragmentShader: go.meshbasic_frag
            },
            lambert: {
                uniforms: js([Dn.common, Dn.specularmap, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    }
                }]),
                vertexShader: go.meshlambert_vert,
                fragmentShader: go.meshlambert_frag
            },
            phong: {
                uniforms: js([Dn.common, Dn.specularmap, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    },
                    specular: {
                        value: new Gn(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: go.meshphong_vert,
                fragmentShader: go.meshphong_frag
            },
            standard: {
                uniforms: js([Dn.common, Dn.envmap, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.roughnessmap, Dn.metalnessmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    },
                    roughness: {
                        value: 1
                    },
                    metalness: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: go.meshphysical_vert,
                fragmentShader: go.meshphysical_frag
            },
            toon: {
                uniforms: js([Dn.common, Dn.aomap, Dn.lightmap, Dn.emissivemap, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.gradientmap, Dn.fog, Dn.lights, {
                    emissive: {
                        value: new Gn(0)
                    }
                }]),
                vertexShader: go.meshtoon_vert,
                fragmentShader: go.meshtoon_frag
            },
            matcap: {
                uniforms: js([Dn.common, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, Dn.fog, {
                    matcap: {
                        value: null
                    }
                }]),
                vertexShader: go.meshmatcap_vert,
                fragmentShader: go.meshmatcap_frag
            },
            points: {
                uniforms: js([Dn.points, Dn.fog]),
                vertexShader: go.points_vert,
                fragmentShader: go.points_frag
            },
            dashed: {
                uniforms: js([Dn.common, Dn.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: go.linedashed_vert,
                fragmentShader: go.linedashed_frag
            },
            depth: {
                uniforms: js([Dn.common, Dn.displacementmap]),
                vertexShader: go.depth_vert,
                fragmentShader: go.depth_frag
            },
            normal: {
                uniforms: js([Dn.common, Dn.bumpmap, Dn.normalmap, Dn.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.meshnormal_vert,
                fragmentShader: go.meshnormal_frag
            },
            sprite: {
                uniforms: js([Dn.sprite, Dn.fog]),
                vertexShader: go.sprite_vert,
                fragmentShader: go.sprite_frag
            },
            background: {
                uniforms: {
                    uvTransform: {
                        value: new lo
                    },
                    t2D: {
                        value: null
                    },
                    backgroundIntensity: {
                        value: 1
                    },
                    backgroundColor: {
                        value: new Gn(16777215)
                    },
                    flipX: {
                        value: !1
                    },
                    flipY: {
                        value: !1
                    }
                },
                vertexShader: go.background_vert,
                fragmentShader: go.background_frag
            },
            backgroundCube: {
                uniforms: {
                    envMap: {
                        value: null
                    },
                    envMapRotation: {
                        value: 0
                    },
                    envMapIntensity: {
                        value: 1
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    backgroundBlurriness: {
                        value: 0
                    },
                    backgroundIntensity: {
                        value: 1
                    }
                },
                vertexShader: go.backgroundCube_vert,
                fragmentShader: go.backgroundCube_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: go.cube_vert,
                fragmentShader: go.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: go.equirect_vert,
                fragmentShader: go.equirect_frag
            },
            distanceRGBA: {
                uniforms: js([Dn.common, Dn.displacementmap, {
                    referencePosition: {
                        value: new Er
                    },
                    nearDistance: {
                        value: 1
                    },
                    farDistance: {
                        value: 1e3
                    }
                }]),
                vertexShader: go.distanceRGBA_vert,
                fragmentShader: go.distanceRGBA_frag
            },
            shadow: {
                uniforms: js([Dn.lights, Dn.fog, {
                    color: {
                        value: new Gn(0)
                    },
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: go.shadow_vert,
                fragmentShader: go.shadow_frag
            }
        };
        qs.physical = {
            uniforms: js([qs.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new lo
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new lo
                },
                clearcoatNormalScale: {
                    value: new mn(1,1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new lo
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new lo
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new lo
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new Gn(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new lo
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new lo
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new lo
                },
                transmissionSamplerSize: {
                    value: new mn
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new lo
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new Gn(0)
                },
                specularColor: {
                    value: new Gn(1,1,1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new lo
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new lo
                },
                anisotropyVector: {
                    value: new mn
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new lo
                }
            }]),
            vertexShader: go.meshphysical_vert,
            fragmentShader: go.meshphysical_frag
        };
        const wv = {
            r: 0,
            b: 0,
            g: 0
        };
        function Ew(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = new Gn(0);
            let Lt, Nt, jt = xt === !0 ? 0 : 1, Wt = null, Qt = 0, qt = null;
            function Xt(Zt, Yt) {
                Zt.getRGB(wv, jy(Tt)),
                mt.buffers.color.setClear(wv.r, wv.g, wv.b, Yt, Ct)
            }
            return {
                getClearColor: function() {
                    return Mt
                },
                setClearColor: function(Zt, Yt=1) {
                    Mt.set(Zt),
                    jt = Yt,
                    Xt(Mt, jt)
                },
                getClearAlpha: function() {
                    return jt
                },
                setClearAlpha: function(Zt) {
                    jt = Zt,
                    Xt(Mt, jt)
                },
                getPlaneMesh: function() {
                    return Lt
                },
                getBoxMesh: function() {
                    return Nt
                },
                getBoxMesh2: function() {
                    return Nt === void 0 && (Nt = new gs(new Zu(1,1,1),new zl({
                        name: "BackgroundCubeMaterial",
                        uniforms: Sp(qs.backgroundCube.uniforms),
                        vertexShader: qs.backgroundCube.vertexShader,
                        fragmentShader: qs.backgroundCube.fragmentShader,
                        side: bt,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })),
                    Nt.geometry.deleteAttribute("normal"),
                    Nt.geometry.deleteAttribute("uv"),
                    Nt.onBeforeRender = function(Zt, Yt, sr) {
                        this.matrixWorld.copyPosition(sr.matrixWorld)
                    }
                    ,
                    Object.defineProperty(Nt.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }),
                    ft.update(Nt)),
                    Nt
                },
                render: function(Zt, Yt) {
                    let sr = !1
                      , er = Yt.isScene === !0 ? Yt.background : null;
                    const rr = Yt.isScene && Yt.backgroundColor !== void 0 ? Yt.backgroundColor : null;
                    er === "environment" && (er = Yt.environment),
                    er && er.isTexture && (er = (Yt.backgroundBlurriness > 0 ? lt : tt).get(er)),
                    er === null ? Xt(Mt, jt) : er && er.isColor && (Xt(er, 1),
                    sr = !0);
                    const xr = Tt.xr.getEnvironmentBlendMode();
                    if (xr === "additive" ? mt.buffers.color.setClear(0, 0, 0, 1, Ct) : xr === "alpha-blend" && mt.buffers.color.setClear(0, 0, 0, 0, Ct),
                    (Tt.autoClear || sr) && Tt.clear(Tt.autoClearColor, Tt.autoClearDepth, Tt.autoClearStencil),
                    er && (er.isCubeTexture || er.mapping === Mn))
                        Nt === void 0 && (Nt = new gs(new Zu(1,1,1),new zl({
                            name: "BackgroundCubeMaterial",
                            uniforms: Sp(qs.backgroundCube.uniforms),
                            vertexShader: qs.backgroundCube.vertexShader,
                            fragmentShader: qs.backgroundCube.fragmentShader,
                            side: bt,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        Nt.geometry.deleteAttribute("normal"),
                        Nt.geometry.deleteAttribute("uv"),
                        Nt.onBeforeRender = function(br, yr, Pr) {
                            this.matrixWorld.copyPosition(Pr.matrixWorld)
                        }
                        ,
                        Object.defineProperty(Nt.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }),
                        ft.update(Nt)),
                        Nt.material.uniforms.envMap.value = er,
                        Nt.material.uniforms.envMapRotation.value = er && er.rotation || 0,
                        Nt.material.uniforms.envMapIntensity.value = er === Yt.environment && Yt.envMapIntensity || 1,
                        Nt.material.uniforms.flipEnvMap.value = er.isCubeTexture && er.isRenderTargetTexture === !1 ? -1 : 1,
                        Nt.material.uniforms.backgroundBlurriness.value = Yt.backgroundBlurriness,
                        Nt.material.uniforms.backgroundIntensity.value = Yt.backgroundIntensity,
                        Nt.material.toneMapped = Do.getTransfer(er.colorSpace) !== Vo,
                        Wt === er && Qt === er.version && qt === Tt.toneMapping || (Nt.material.needsUpdate = !0,
                        Wt = er,
                        Qt = er.version,
                        qt = Tt.toneMapping),
                        Nt.layers.enableAll(),
                        Zt.unshift(Nt, Nt.geometry, Nt.material, 0, 0, null);
                    else if (er && er.isTexture || !er && rr) {
                        Lt === void 0 && (Lt = new gs(new g_(2,2),new zl({
                            name: "BackgroundMaterial",
                            uniforms: Sp(qs.background.uniforms),
                            vertexShader: qs.background.vertexShader,
                            fragmentShader: qs.background.fragmentShader,
                            side: vt,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })),
                        Lt.geometry.deleteAttribute("normal"),
                        Object.defineProperty(Lt.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }),
                        ft.update(Lt)),
                        Lt.material.uniforms.backgroundColor.value.set(rr || 16777215),
                        Lt.material.uniforms.t2D.value = er,
                        Lt.material.uniforms.backgroundIntensity.value = Yt.backgroundIntensity,
                        er ? (Lt.material.toneMapped = Do.getTransfer(er.colorSpace) !== Vo,
                        Lt.material.uniforms.flipX.value = er.userData.flipX || !1,
                        Lt.material.uniforms.flipY.value = er.userData.flipY || !1,
                        er.matrixAutoUpdate === !0 && er.updateMatrix(),
                        Lt.material.uniforms.uvTransform.value.copy(er.matrix),
                        Lt.material.defines.HAS_TEXTURE = "1") : Lt.material.defines.HAS_TEXTURE && delete Lt.material.defines.HAS_TEXTURE;
                        const br = er ? er.version : -1;
                        Wt === er && Qt === br && qt === Tt.toneMapping || (Lt.material.needsUpdate = !0,
                        Wt = er,
                        Qt = br,
                        qt = Tt.toneMapping),
                        Lt.layers.enableAll(),
                        Zt.unshift(Lt, Lt.geometry, Lt.material, 0, 0, null)
                    }
                }
            }
        }
        function Tw(Tt, tt, lt, mt) {
            const ft = Tt.getParameter(Tt.MAX_VERTEX_ATTRIBS)
              , xt = mt.isWebGL2 ? null : tt.get("OES_vertex_array_object")
              , Ct = mt.isWebGL2 || xt !== null
              , Mt = {}
              , Lt = qt(null);
            let Nt = Lt
              , jt = !1;
            function Wt(br) {
                return mt.isWebGL2 ? Tt.bindVertexArray(br) : xt.bindVertexArrayOES(br)
            }
            function Qt(br) {
                return mt.isWebGL2 ? Tt.deleteVertexArray(br) : xt.deleteVertexArrayOES(br)
            }
            function qt(br) {
                const yr = []
                  , Pr = []
                  , zr = [];
                for (let Nr = 0; Nr < ft; Nr++)
                    yr[Nr] = 0,
                    Pr[Nr] = 0,
                    zr[Nr] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: yr,
                    enabledAttributes: Pr,
                    attributeDivisors: zr,
                    object: br,
                    attributes: {},
                    index: null
                }
            }
            function Xt() {
                const br = Nt.newAttributes;
                for (let yr = 0, Pr = br.length; yr < Pr; yr++)
                    br[yr] = 0
            }
            function Zt(br) {
                Yt(br, 0)
            }
            function Yt(br, yr) {
                const Pr = Nt.newAttributes
                  , zr = Nt.enabledAttributes
                  , Nr = Nt.attributeDivisors;
                Pr[br] = 1,
                zr[br] === 0 && (Tt.enableVertexAttribArray(br),
                zr[br] = 1),
                Nr[br] !== yr && ((mt.isWebGL2 ? Tt : tt.get("ANGLE_instanced_arrays"))[mt.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](br, yr),
                Nr[br] = yr)
            }
            function sr() {
                const br = Nt.newAttributes
                  , yr = Nt.enabledAttributes;
                for (let Pr = 0, zr = yr.length; Pr < zr; Pr++)
                    yr[Pr] !== br[Pr] && (Tt.disableVertexAttribArray(Pr),
                    yr[Pr] = 0)
            }
            function er(br, yr, Pr, zr, Nr, Vr, Gr) {
                Gr === !0 ? Tt.vertexAttribIPointer(br, yr, Pr, Nr, Vr) : Tt.vertexAttribPointer(br, yr, Pr, zr, Nr, Vr)
            }
            function rr() {
                xr(),
                jt = !0,
                Nt !== Lt && (Nt = Lt,
                Wt(Nt.object))
            }
            function xr() {
                Lt.geometry = null,
                Lt.program = null,
                Lt.wireframe = !1
            }
            return {
                setup: function(br, yr, Pr, zr, Nr) {
                    let Vr = !1;
                    if (Ct) {
                        const Gr = function(Hr, _n, dn) {
                            const kn = dn.wireframe === !0;
                            let Bn = Mt[Hr.id];
                            Bn === void 0 && (Bn = {},
                            Mt[Hr.id] = Bn);
                            let cn = Bn[_n.id];
                            cn === void 0 && (cn = {},
                            Bn[_n.id] = cn);
                            let Yr = cn[kn];
                            return Yr === void 0 && (Yr = qt(mt.isWebGL2 ? Tt.createVertexArray() : xt.createVertexArrayOES()),
                            cn[kn] = Yr),
                            Yr
                        }(zr, Pr, yr);
                        Nt !== Gr && (Nt = Gr,
                        Wt(Nt.object)),
                        Vr = function(Hr, _n, dn, kn) {
                            const Bn = Nt.attributes
                              , cn = _n.attributes;
                            let Yr = 0;
                            const Jr = dn.getAttributes();
                            for (const sn in Jr)
                                if (Jr[sn].location >= 0) {
                                    const on = Bn[sn];
                                    let Un = cn[sn];
                                    if (Un === void 0 && (sn === "instanceMatrix" && Hr.instanceMatrix && (Un = Hr.instanceMatrix),
                                    sn === "instanceColor" && Hr.instanceColor && (Un = Hr.instanceColor)),
                                    on === void 0 || on.attribute !== Un || Un && on.data !== Un.data)
                                        return !0;
                                    Yr++
                                }
                            return Nt.attributesNum !== Yr || Nt.index !== kn
                        }(br, zr, Pr, Nr),
                        Vr && function(Hr, _n, dn, kn) {
                            const Bn = {}
                              , cn = _n.attributes;
                            let Yr = 0;
                            const Jr = dn.getAttributes();
                            for (const sn in Jr)
                                if (Jr[sn].location >= 0) {
                                    let on = cn[sn];
                                    on === void 0 && (sn === "instanceMatrix" && Hr.instanceMatrix && (on = Hr.instanceMatrix),
                                    sn === "instanceColor" && Hr.instanceColor && (on = Hr.instanceColor));
                                    const Un = {};
                                    Un.attribute = on,
                                    on && on.data && (Un.data = on.data),
                                    Bn[sn] = Un,
                                    Yr++
                                }
                            Nt.attributes = Bn,
                            Nt.attributesNum = Yr,
                            Nt.index = kn
                        }(br, zr, Pr, Nr)
                    } else {
                        const Gr = yr.wireframe === !0;
                        Nt.geometry === zr.id && Nt.program === Pr.id && Nt.wireframe === Gr || (Nt.geometry = zr.id,
                        Nt.program = Pr.id,
                        Nt.wireframe = Gr,
                        Vr = !0)
                    }
                    Nr !== null && lt.update(Nr, Tt.ELEMENT_ARRAY_BUFFER),
                    (Vr || jt) && (jt = !1,
                    function(Gr, Hr, _n, dn) {
                        if (mt.isWebGL2 === !1 && (Gr.isInstancedMesh || dn.isInstancedBufferGeometry) && tt.get("ANGLE_instanced_arrays") === null)
                            return;
                        Xt();
                        const kn = dn.attributes
                          , Bn = _n.getAttributes()
                          , cn = Hr.defaultAttributeValues;
                        for (const Yr in Bn) {
                            const Jr = Bn[Yr];
                            if (Jr.location >= 0) {
                                let sn = kn[Yr];
                                if (sn === void 0 && (Yr === "instanceMatrix" && Gr.instanceMatrix && (sn = Gr.instanceMatrix),
                                Yr === "instanceColor" && Gr.instanceColor && (sn = Gr.instanceColor)),
                                sn !== void 0) {
                                    const on = sn.normalized
                                      , Un = sn.itemSize
                                      , ro = lt.get(sn);
                                    if (ro === void 0)
                                        continue;
                                    const Zn = ro.buffer
                                      , jn = ro.type
                                      , uo = ro.bytesPerElement
                                      , Dr = mt.isWebGL2 === !0 && (jn === Tt.INT || jn === Tt.UNSIGNED_INT || sn.gpuType === $o);
                                    if (sn.isInterleavedBufferAttribute) {
                                        const Sr = sn.data
                                          , Fr = Sr.stride
                                          , Wr = sn.offset;
                                        if (Sr.isInstancedInterleavedBuffer) {
                                            for (let kr = 0; kr < Jr.locationSize; kr++)
                                                Yt(Jr.location + kr, Sr.meshPerAttribute);
                                            Gr.isInstancedMesh !== !0 && dn._maxInstanceCount === void 0 && (dn._maxInstanceCount = Sr.meshPerAttribute * Sr.count)
                                        } else
                                            for (let kr = 0; kr < Jr.locationSize; kr++)
                                                Zt(Jr.location + kr);
                                        Tt.bindBuffer(Tt.ARRAY_BUFFER, Zn);
                                        for (let kr = 0; kr < Jr.locationSize; kr++)
                                            er(Jr.location + kr, Un / Jr.locationSize, jn, on, Fr * uo, (Wr + Un / Jr.locationSize * kr) * uo, Dr)
                                    } else {
                                        if (sn.isInstancedBufferAttribute) {
                                            for (let Sr = 0; Sr < Jr.locationSize; Sr++)
                                                Yt(Jr.location + Sr, sn.meshPerAttribute);
                                            Gr.isInstancedMesh !== !0 && dn._maxInstanceCount === void 0 && (dn._maxInstanceCount = sn.meshPerAttribute * sn.count)
                                        } else
                                            for (let Sr = 0; Sr < Jr.locationSize; Sr++)
                                                Zt(Jr.location + Sr);
                                        Tt.bindBuffer(Tt.ARRAY_BUFFER, Zn);
                                        for (let Sr = 0; Sr < Jr.locationSize; Sr++)
                                            er(Jr.location + Sr, Un / Jr.locationSize, jn, on, Un * uo, Un / Jr.locationSize * Sr * uo, Dr)
                                    }
                                } else if (cn !== void 0) {
                                    const on = cn[Yr];
                                    if (on !== void 0)
                                        switch (on.length) {
                                        case 2:
                                            Tt.vertexAttrib2fv(Jr.location, on);
                                            break;
                                        case 3:
                                            Tt.vertexAttrib3fv(Jr.location, on);
                                            break;
                                        case 4:
                                            Tt.vertexAttrib4fv(Jr.location, on);
                                            break;
                                        default:
                                            Tt.vertexAttrib1fv(Jr.location, on)
                                        }
                                }
                            }
                        }
                        sr()
                    }(br, yr, Pr, zr),
                    Nr !== null && Tt.bindBuffer(Tt.ELEMENT_ARRAY_BUFFER, lt.get(Nr).buffer))
                },
                reset: rr,
                resetDefaultState: xr,
                dispose: function() {
                    rr();
                    for (const br in Mt) {
                        const yr = Mt[br];
                        for (const Pr in yr) {
                            const zr = yr[Pr];
                            for (const Nr in zr)
                                Qt(zr[Nr].object),
                                delete zr[Nr];
                            delete yr[Pr]
                        }
                        delete Mt[br]
                    }
                },
                releaseStatesOfGeometry: function(br) {
                    if (Mt[br.id] === void 0)
                        return;
                    const yr = Mt[br.id];
                    for (const Pr in yr) {
                        const zr = yr[Pr];
                        for (const Nr in zr)
                            Qt(zr[Nr].object),
                            delete zr[Nr];
                        delete yr[Pr]
                    }
                    delete Mt[br.id]
                },
                releaseStatesOfProgram: function(br) {
                    for (const yr in Mt) {
                        const Pr = Mt[yr];
                        if (Pr[br.id] === void 0)
                            continue;
                        const zr = Pr[br.id];
                        for (const Nr in zr)
                            Qt(zr[Nr].object),
                            delete zr[Nr];
                        delete Pr[br.id]
                    }
                },
                initAttributes: Xt,
                enableAttribute: Zt,
                disableUnusedAttributes: sr
            }
        }
        function Cw(Tt, tt, lt, mt) {
            const ft = mt.isWebGL2;
            let xt;
            this.setMode = function(Ct) {
                xt = Ct
            }
            ,
            this.render = function(Ct, Mt) {
                Tt.drawArrays(xt, Ct, Mt),
                lt.update(Mt, xt, 1)
            }
            ,
            this.renderInstances = function(Ct, Mt, Lt) {
                if (Lt === 0)
                    return;
                let Nt, jt;
                if (ft)
                    Nt = Tt,
                    jt = "drawArraysInstanced";
                else if (Nt = tt.get("ANGLE_instanced_arrays"),
                jt = "drawArraysInstancedANGLE",
                Nt === null)
                    return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                Nt[jt](xt, Ct, Mt, Lt),
                lt.update(Mt, xt, Lt)
            }
        }
        function Pw(Tt, tt, lt) {
            let mt;
            function ft(xr) {
                if (xr === "highp") {
                    if (Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.HIGH_FLOAT).precision > 0 && Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.HIGH_FLOAT).precision > 0)
                        return "highp";
                    xr = "mediump"
                }
                return xr === "mediump" && Tt.getShaderPrecisionFormat(Tt.VERTEX_SHADER, Tt.MEDIUM_FLOAT).precision > 0 && Tt.getShaderPrecisionFormat(Tt.FRAGMENT_SHADER, Tt.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            const xt = typeof WebGL2RenderingContext < "u" && Tt.constructor.name === "WebGL2RenderingContext";
            let Ct = lt.precision !== void 0 ? lt.precision : "highp";
            const Mt = ft(Ct);
            Mt !== Ct && (console.warn("THREE.WebGLRenderer:", Ct, "not supported, using", Mt, "instead."),
            Ct = Mt);
            const Lt = xt || tt.has("WEBGL_draw_buffers")
              , Nt = lt.logarithmicDepthBuffer === !0
              , jt = Tt.getParameter(Tt.MAX_TEXTURE_IMAGE_UNITS)
              , Wt = Tt.getParameter(Tt.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
              , Qt = Tt.getParameter(Tt.MAX_TEXTURE_SIZE)
              , qt = Tt.getParameter(Tt.MAX_CUBE_MAP_TEXTURE_SIZE)
              , Xt = Tt.getParameter(Tt.MAX_VERTEX_ATTRIBS)
              , Zt = Tt.getParameter(Tt.MAX_VERTEX_UNIFORM_VECTORS)
              , Yt = Tt.getParameter(Tt.MAX_VARYING_VECTORS)
              , sr = Tt.getParameter(Tt.MAX_FRAGMENT_UNIFORM_VECTORS)
              , er = Wt > 0
              , rr = xt || tt.has("OES_texture_float");
            return {
                isWebGL2: xt,
                drawBuffers: Lt,
                getMaxAnisotropy: function() {
                    if (mt !== void 0)
                        return mt;
                    if (tt.has("EXT_texture_filter_anisotropic") === !0) {
                        const xr = tt.get("EXT_texture_filter_anisotropic");
                        mt = Tt.getParameter(xr.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else
                        mt = 0;
                    return mt
                },
                getMaxPrecision: ft,
                precision: Ct,
                logarithmicDepthBuffer: Nt,
                maxTextures: jt,
                maxVertexTextures: Wt,
                maxTextureSize: Qt,
                maxCubemapSize: qt,
                maxAttributes: Xt,
                maxVertexUniforms: Zt,
                maxVaryings: Yt,
                maxFragmentUniforms: sr,
                vertexTextures: er,
                floatFragmentTextures: rr,
                floatVertexTextures: er && rr,
                maxSamples: xt ? Tt.getParameter(Tt.MAX_SAMPLES) : 0
            }
        }
        function Mw(Tt) {
            const tt = this;
            let lt = null
              , mt = 0
              , ft = !1
              , xt = !1;
            const Ct = new _d
              , Mt = new lo
              , Lt = {
                value: null,
                needsUpdate: !1
            };
            function Nt(jt, Wt, Qt, qt) {
                const Xt = jt !== null ? jt.length : 0;
                let Zt = null;
                if (Xt !== 0) {
                    if (Zt = Lt.value,
                    qt !== !0 || Zt === null) {
                        const Yt = Qt + 4 * Xt
                          , sr = Wt.matrixWorldInverse;
                        Mt.getNormalMatrix(sr),
                        (Zt === null || Zt.length < Yt) && (Zt = new Float32Array(Yt));
                        for (let er = 0, rr = Qt; er !== Xt; ++er,
                        rr += 4)
                            Ct.copy(jt[er]).applyMatrix4(sr, Mt),
                            Ct.normal.toArray(Zt, rr),
                            Zt[rr + 3] = Ct.constant
                    }
                    Lt.value = Zt,
                    Lt.needsUpdate = !0
                }
                return tt.numPlanes = Xt,
                tt.numIntersection = 0,
                Zt
            }
            this.uniform = Lt,
            this.numPlanes = 0,
            this.numIntersection = 0,
            this.init = function(jt, Wt) {
                const Qt = jt.length !== 0 || Wt || mt !== 0 || ft;
                return ft = Wt,
                mt = jt.length,
                Qt
            }
            ,
            this.beginShadows = function() {
                xt = !0,
                Nt(null)
            }
            ,
            this.endShadows = function() {
                xt = !1
            }
            ,
            this.setGlobalState = function(jt, Wt) {
                lt = Nt(jt, Wt, 0)
            }
            ,
            this.setState = function(jt, Wt, Qt) {
                const qt = jt.clippingPlanes
                  , Xt = jt.clipIntersection
                  , Zt = jt.clipShadows
                  , Yt = Tt.get(jt);
                if (!ft || qt === null || qt.length === 0 || xt && !Zt)
                    xt ? Nt(null) : (Lt.value !== lt && (Lt.value = lt,
                    Lt.needsUpdate = mt > 0),
                    tt.numPlanes = mt,
                    tt.numIntersection = 0);
                else {
                    const sr = xt ? 0 : mt
                      , er = 4 * sr;
                    let rr = Yt.clippingState || null;
                    Lt.value = rr,
                    rr = Nt(qt, Wt, er, Qt);
                    for (let xr = 0; xr !== er; ++xr)
                        rr[xr] = lt[xr];
                    Yt.clippingState = rr,
                    this.numIntersection = Xt ? this.numPlanes : 0,
                    this.numPlanes += sr
                }
            }
        }
        function Rw(Tt) {
            let tt = new WeakMap;
            function lt(ft, xt) {
                return xt === qr ? ft.mapping = Qr : xt === gn && (ft.mapping = Or),
                ft
            }
            function mt(ft) {
                const xt = ft.target;
                xt.removeEventListener("dispose", mt);
                const Ct = tt.get(xt);
                Ct !== void 0 && (tt.delete(xt),
                Ct.dispose())
            }
            return {
                get: function(ft) {
                    if (ft && ft.isTexture && ft.isRenderTargetTexture === !1) {
                        const xt = ft.mapping;
                        if (xt === qr || xt === gn) {
                            if (tt.has(ft)) {
                                const Ct = tt.get(ft).texture;
                                return Ct.rotation = ft.rotation,
                                lt(Ct, ft.mapping)
                            }
                            {
                                const Ct = ft.image;
                                if (Ct && Ct.height > 0) {
                                    const Mt = new zy(Ct.height / 2);
                                    return Mt.fromEquirectangularTexture(Tt, ft),
                                    Mt.texture.rotation = ft.rotation,
                                    tt.set(ft, Mt),
                                    ft.addEventListener("dispose", mt),
                                    lt(Mt.texture, ft.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return ft
                },
                dispose: function() {
                    tt = new WeakMap
                }
            }
        }
        class Sv extends xv {
            constructor(tt=-1, lt=1, mt=1, ft=-1, xt=.1, Ct=2e3) {
                super(),
                this.isOrthographicCamera = !0,
                this.type = "OrthographicCamera",
                this.zoom = 1,
                this.view = null,
                this.left = tt,
                this.right = lt,
                this.top = mt,
                this.bottom = ft,
                this.near = xt,
                this.far = Ct,
                this.updateProjectionMatrix()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.left = tt.left,
                this.right = tt.right,
                this.top = tt.top,
                this.bottom = tt.bottom,
                this.near = tt.near,
                this.far = tt.far,
                this.zoom = tt.zoom,
                this.view = tt.view === null ? null : Object.assign({}, tt.view),
                this
            }
            setViewOffset(tt, lt, mt, ft, xt, Ct) {
                this.view === null && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }),
                this.view.enabled = !0,
                this.view.fullWidth = tt,
                this.view.fullHeight = lt,
                this.view.offsetX = mt,
                this.view.offsetY = ft,
                this.view.width = xt,
                this.view.height = Ct,
                this.updateProjectionMatrix()
            }
            clearViewOffset() {
                this.view !== null && (this.view.enabled = !1),
                this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const tt = (this.right - this.left) / (2 * this.zoom)
                  , lt = (this.top - this.bottom) / (2 * this.zoom)
                  , mt = (this.right + this.left) / 2
                  , ft = (this.top + this.bottom) / 2;
                let xt = mt - tt
                  , Ct = mt + tt
                  , Mt = ft + lt
                  , Lt = ft - lt;
                if (this.view !== null && this.view.enabled) {
                    const Nt = (this.right - this.left) / this.view.fullWidth / this.zoom
                      , jt = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    xt += Nt * this.view.offsetX,
                    Ct = xt + Nt * this.view.width,
                    Mt -= jt * this.view.offsetY,
                    Lt = Mt - jt * this.view.height
                }
                this.projectionMatrix.makeOrthographic(xt, Ct, Mt, Lt, this.near, this.far, this.coordinateSystem),
                this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.zoom = this.zoom,
                lt.object.left = this.left,
                lt.object.right = this.right,
                lt.object.top = this.top,
                lt.object.bottom = this.bottom,
                lt.object.near = this.near,
                lt.object.far = this.far,
                this.view !== null && (lt.object.view = Object.assign({}, this.view)),
                lt
            }
        }
        const Qy = [.125, .215, .35, .446, .526, .582]
          , U0 = new Sv
          , Wy = new Gn;
        let j0 = null;
        const Tp = (1 + Math.sqrt(5)) / 2
          , xm = 1 / Tp
          , qy = [new Er(1,1,1), new Er(-1,1,1), new Er(1,1,-1), new Er(-1,1,-1), new Er(0,Tp,xm), new Er(0,Tp,-xm), new Er(xm,0,Tp), new Er(-xm,0,Tp), new Er(Tp,xm,0), new Er(-Tp,xm,0)];
        class V0 {
            constructor(tt) {
                this._renderer = tt,
                this._pingPongRenderTarget = null,
                this._lodMax = 0,
                this._cubeSize = 0,
                this._lodPlanes = [],
                this._sizeLods = [],
                this._sigmas = [],
                this._blurMaterial = null,
                this._cubemapMaterial = null,
                this._equirectMaterial = null,
                this._compileMaterial(this._blurMaterial)
            }
            fromScene(tt, lt=0, mt=.1, ft=100) {
                j0 = this._renderer.getRenderTarget(),
                this._setSize(256);
                const xt = this._allocateTargets();
                return xt.depthBuffer = !0,
                this._sceneToCubeUV(tt, mt, ft, xt),
                lt > 0 && this._blur(xt, 0, 0, lt),
                this._applyPMREM(xt),
                this._cleanup(xt),
                xt
            }
            fromEquirectangular(tt, lt=null) {
                return this._fromTexture(tt, lt)
            }
            fromCubemap(tt, lt=null) {
                return this._fromTexture(tt, lt)
            }
            compileCubemapShader() {
                this._cubemapMaterial === null && (this._cubemapMaterial = Yy(),
                this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                this._equirectMaterial === null && (this._equirectMaterial = Xy(),
                this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(),
                this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
                this._equirectMaterial !== null && this._equirectMaterial.dispose()
            }
            _setSize(tt) {
                this._lodMax = Math.floor(Math.log2(tt)),
                this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                this._blurMaterial !== null && this._blurMaterial.dispose(),
                this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
                for (let tt = 0; tt < this._lodPlanes.length; tt++)
                    this._lodPlanes[tt].dispose()
            }
            _cleanup(tt) {
                this._renderer.setRenderTarget(j0),
                tt.scissorTest = !1,
                Ev(tt, 0, 0, tt.width, tt.height)
            }
            _fromTexture(tt, lt) {
                tt.mapping === Qr || tt.mapping === Or ? this._setSize(tt.image.length === 0 ? 16 : tt.image[0].width || tt.image[0].image.width) : this._setSize(tt.image.width / 4),
                j0 = this._renderer.getRenderTarget();
                const mt = lt || this._allocateTargets();
                return this._textureToCubeUV(tt, mt),
                this._applyPMREM(mt),
                this._cleanup(mt),
                mt
            }
            _allocateTargets() {
                const tt = 3 * Math.max(this._cubeSize, 112)
                  , lt = 4 * this._cubeSize
                  , mt = {
                    magFilter: Rn,
                    minFilter: Rn,
                    generateMipmaps: !1,
                    type: Os,
                    format: as,
                    colorSpace: Xo,
                    depthBuffer: !1
                }
                  , ft = $y(tt, lt, mt);
                if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== tt || this._pingPongRenderTarget.height !== lt) {
                    this._pingPongRenderTarget !== null && this._dispose(),
                    this._pingPongRenderTarget = $y(tt, lt, mt);
                    const {_lodMax: xt} = this;
                    ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(Ct) {
                        const Mt = []
                          , Lt = []
                          , Nt = [];
                        let jt = Ct;
                        const Wt = Ct - 4 + 1 + Qy.length;
                        for (let Qt = 0; Qt < Wt; Qt++) {
                            const qt = Math.pow(2, jt);
                            Lt.push(qt);
                            let Xt = 1 / qt;
                            Qt > Ct - 4 ? Xt = Qy[Qt - Ct + 4 - 1] : Qt === 0 && (Xt = 0),
                            Nt.push(Xt);
                            const Zt = 1 / (qt - 2)
                              , Yt = -Zt
                              , sr = 1 + Zt
                              , er = [Yt, Yt, sr, Yt, sr, sr, Yt, Yt, sr, sr, Yt, sr]
                              , rr = 6
                              , xr = 6
                              , br = 3
                              , yr = 2
                              , Pr = 1
                              , zr = new Float32Array(br * xr * rr)
                              , Nr = new Float32Array(yr * xr * rr)
                              , Vr = new Float32Array(Pr * xr * rr);
                            for (let Hr = 0; Hr < rr; Hr++) {
                                const _n = Hr % 3 * 2 / 3 - 1
                                  , dn = Hr > 2 ? 0 : -1
                                  , kn = [_n, dn, 0, _n + 2 / 3, dn, 0, _n + 2 / 3, dn + 1, 0, _n, dn, 0, _n + 2 / 3, dn + 1, 0, _n, dn + 1, 0];
                                zr.set(kn, br * xr * Hr),
                                Nr.set(er, yr * xr * Hr);
                                const Bn = [Hr, Hr, Hr, Hr, Hr, Hr];
                                Vr.set(Bn, Pr * xr * Hr)
                            }
                            const Gr = new bo;
                            Gr.setAttribute("position", new mr(zr,br)),
                            Gr.setAttribute("uv", new mr(Nr,yr)),
                            Gr.setAttribute("faceIndex", new mr(Vr,Pr)),
                            Mt.push(Gr),
                            jt > 4 && jt--
                        }
                        return {
                            lodPlanes: Mt,
                            sizeLods: Lt,
                            sigmas: Nt
                        }
                    }(xt)),
                    this._blurMaterial = function(Ct, Mt, Lt) {
                        const Nt = new Float32Array(20)
                          , jt = new Er(0,1,0);
                        return new zl({
                            name: "SphericalGaussianBlur",
                            defines: {
                                n: 20,
                                CUBEUV_TEXEL_WIDTH: 1 / Mt,
                                CUBEUV_TEXEL_HEIGHT: 1 / Lt,
                                CUBEUV_MAX_MIP: `${Ct}.0`
                            },
                            uniforms: {
                                envMap: {
                                    value: null
                                },
                                samples: {
                                    value: 1
                                },
                                weights: {
                                    value: Nt
                                },
                                latitudinal: {
                                    value: !1
                                },
                                dTheta: {
                                    value: 0
                                },
                                mipInt: {
                                    value: 0
                                },
                                poleAxis: {
                                    value: jt
                                }
                            },
                            vertexShader: `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`,
                            fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                            blending: Et,
                            depthTest: !1,
                            depthWrite: !1
                        })
                    }(xt, tt, lt)
                }
                return ft
            }
            _compileMaterial(tt) {
                const lt = new gs(this._lodPlanes[0],tt);
                this._renderer.compile(lt, U0)
            }
            _sceneToCubeUV(tt, lt, mt, ft) {
                const xt = new Cs(90,1,lt,mt)
                  , Ct = [1, -1, 1, 1, 1, 1]
                  , Mt = [1, 1, 1, -1, -1, -1]
                  , Lt = this._renderer
                  , Nt = Lt.autoClear
                  , jt = Lt.toneMapping;
                Lt.getClearColor(Wy),
                Lt.toneMapping = Ur,
                Lt.autoClear = !1;
                const Wt = new nu({
                    name: "PMREM.Background",
                    side: bt,
                    depthWrite: !1,
                    depthTest: !1
                })
                  , Qt = new gs(new Zu,Wt);
                let qt = !1;
                const Xt = tt.background;
                Xt ? Xt.isColor && (Wt.color.copy(Xt),
                tt.background = null,
                qt = !0) : (Wt.color.copy(Wy),
                qt = !0);
                for (let Zt = 0; Zt < 6; Zt++) {
                    const Yt = Zt % 3;
                    Yt === 0 ? (xt.up.set(0, Ct[Zt], 0),
                    xt.lookAt(Mt[Zt], 0, 0)) : Yt === 1 ? (xt.up.set(0, 0, Ct[Zt]),
                    xt.lookAt(0, Mt[Zt], 0)) : (xt.up.set(0, Ct[Zt], 0),
                    xt.lookAt(0, 0, Mt[Zt]));
                    const sr = this._cubeSize;
                    Ev(ft, Yt * sr, Zt > 2 ? sr : 0, sr, sr),
                    Lt.setRenderTarget(ft),
                    qt && Lt.render(Qt, xt),
                    Lt.render(tt, xt)
                }
                Qt.geometry.dispose(),
                Qt.material.dispose(),
                Lt.toneMapping = jt,
                Lt.autoClear = Nt,
                tt.background = Xt
            }
            _textureToCubeUV(tt, lt) {
                const mt = this._renderer
                  , ft = tt.mapping === Qr || tt.mapping === Or;
                ft ? (this._cubemapMaterial === null && (this._cubemapMaterial = Yy()),
                this._cubemapMaterial.uniforms.flipEnvMap.value = tt.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Xy());
                const xt = ft ? this._cubemapMaterial : this._equirectMaterial
                  , Ct = new gs(this._lodPlanes[0],xt);
                xt.uniforms.envMap.value = tt;
                const Mt = this._cubeSize;
                Ev(lt, 0, 0, 3 * Mt, 2 * Mt),
                mt.setRenderTarget(lt),
                mt.render(Ct, U0)
            }
            _applyPMREM(tt) {
                const lt = this._renderer
                  , mt = lt.autoClear;
                lt.autoClear = !1;
                for (let ft = 1; ft < this._lodPlanes.length; ft++) {
                    const xt = Math.sqrt(this._sigmas[ft] * this._sigmas[ft] - this._sigmas[ft - 1] * this._sigmas[ft - 1])
                      , Ct = qy[(ft - 1) % qy.length];
                    this._blur(tt, ft - 1, ft, xt, Ct)
                }
                lt.autoClear = mt
            }
            _blur(tt, lt, mt, ft, xt) {
                const Ct = this._pingPongRenderTarget;
                this._halfBlur(tt, Ct, lt, mt, ft, "latitudinal", xt),
                this._halfBlur(Ct, tt, mt, mt, ft, "longitudinal", xt)
            }
            _halfBlur(tt, lt, mt, ft, xt, Ct, Mt) {
                const Lt = this._renderer
                  , Nt = this._blurMaterial;
                Ct !== "latitudinal" && Ct !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
                const jt = new gs(this._lodPlanes[ft],Nt)
                  , Wt = Nt.uniforms
                  , Qt = this._sizeLods[mt] - 1
                  , qt = isFinite(xt) ? Math.PI / (2 * Qt) : 2 * Math.PI / 39
                  , Xt = xt / qt
                  , Zt = isFinite(xt) ? 1 + Math.floor(3 * Xt) : 20;
                Zt > 20 && console.warn(`sigmaRadians, ${xt}, is too large and will clip, as it requested ${Zt} samples when the maximum is set to 20`);
                const Yt = [];
                let sr = 0;
                for (let xr = 0; xr < 20; ++xr) {
                    const br = xr / Xt
                      , yr = Math.exp(-br * br / 2);
                    Yt.push(yr),
                    xr === 0 ? sr += yr : xr < Zt && (sr += 2 * yr)
                }
                for (let xr = 0; xr < Yt.length; xr++)
                    Yt[xr] = Yt[xr] / sr;
                Wt.envMap.value = tt.texture,
                Wt.samples.value = Zt,
                Wt.weights.value = Yt,
                Wt.latitudinal.value = Ct === "latitudinal",
                Mt && (Wt.poleAxis.value = Mt);
                const {_lodMax: er} = this;
                Wt.dTheta.value = qt,
                Wt.mipInt.value = er - mt;
                const rr = this._sizeLods[ft];
                Ev(lt, 3 * rr * (ft > er - 4 ? ft - er + 4 : 0), 4 * (this._cubeSize - rr), 3 * rr, 2 * rr),
                Lt.setRenderTarget(lt),
                Lt.render(jt, U0)
            }
        }
        function $y(Tt, tt, lt) {
            const mt = new Rs(Tt,tt,lt);
            return mt.texture.mapping = Mn,
            mt.texture.name = "PMREM.cubeUv",
            mt.scissorTest = !0,
            mt
        }
        function Ev(Tt, tt, lt, mt, ft) {
            Tt.viewport.set(tt, lt, mt, ft),
            Tt.scissor.set(tt, lt, mt, ft)
        }
        function Xy() {
            return new zl({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`,
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                blending: Et,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Yy() {
            return new zl({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`,
                fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                blending: Et,
                depthTest: !1,
                depthWrite: !1
            })
        }
        function Iw(Tt) {
            let tt = new WeakMap
              , lt = null;
            function mt(ft) {
                const xt = ft.target;
                xt.removeEventListener("dispose", mt);
                const Ct = tt.get(xt);
                Ct !== void 0 && (tt.delete(xt),
                Ct.dispose())
            }
            return {
                get: function(ft) {
                    if (ft && ft.isTexture) {
                        const xt = ft.mapping
                          , Ct = xt === qr || xt === gn
                          , Mt = xt === Qr || xt === Or;
                        if (Ct || Mt) {
                            if (ft.isRenderTargetTexture && ft.needsPMREMUpdate === !0) {
                                ft.needsPMREMUpdate = !1;
                                let Lt = tt.get(ft);
                                return lt === null && (lt = new V0(Tt)),
                                Lt = Ct ? lt.fromEquirectangular(ft, Lt) : lt.fromCubemap(ft, Lt),
                                tt.set(ft, Lt),
                                Lt.texture
                            }
                            if (tt.has(ft))
                                return tt.get(ft).texture;
                            {
                                const Lt = ft.image;
                                if (Ct && Lt && Lt.height > 0 || Mt && Lt && function(Nt) {
                                    let jt = 0;
                                    for (let Wt = 0; Wt < 6; Wt++)
                                        Nt[Wt] !== void 0 && jt++;
                                    return jt === 6
                                }(Lt)) {
                                    lt === null && (lt = new V0(Tt));
                                    const Nt = Ct ? lt.fromEquirectangular(ft) : lt.fromCubemap(ft);
                                    return tt.set(ft, Nt),
                                    ft.addEventListener("dispose", mt),
                                    Nt.texture
                                }
                                return null
                            }
                        }
                    }
                    return ft
                },
                dispose: function() {
                    tt = new WeakMap,
                    lt !== null && (lt.dispose(),
                    lt = null)
                }
            }
        }
        function kw(Tt) {
            const tt = {};
            function lt(mt) {
                if (tt[mt] !== void 0)
                    return tt[mt];
                let ft;
                switch (mt) {
                case "WEBGL_depth_texture":
                    ft = Tt.getExtension("WEBGL_depth_texture") || Tt.getExtension("MOZ_WEBGL_depth_texture") || Tt.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    ft = Tt.getExtension("EXT_texture_filter_anisotropic") || Tt.getExtension("MOZ_EXT_texture_filter_anisotropic") || Tt.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    ft = Tt.getExtension("WEBGL_compressed_texture_s3tc") || Tt.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || Tt.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    ft = Tt.getExtension("WEBGL_compressed_texture_pvrtc") || Tt.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    ft = Tt.getExtension(mt)
                }
                return tt[mt] = ft,
                ft
            }
            return {
                has: function(mt) {
                    return lt(mt) !== null
                },
                init: function(mt) {
                    mt.isWebGL2 ? lt("EXT_color_buffer_float") : (lt("WEBGL_depth_texture"),
                    lt("OES_texture_float"),
                    lt("OES_texture_half_float"),
                    lt("OES_texture_half_float_linear"),
                    lt("OES_standard_derivatives"),
                    lt("OES_element_index_uint"),
                    lt("OES_vertex_array_object"),
                    lt("ANGLE_instanced_arrays")),
                    lt("OES_texture_float_linear"),
                    lt("EXT_color_buffer_half_float"),
                    lt("WEBGL_multisampled_render_to_texture")
                },
                get: function(mt) {
                    const ft = lt(mt);
                    return ft === null && console.warn("THREE.WebGLRenderer: " + mt + " extension not supported."),
                    ft
                }
            }
        }
        function Dw(Tt, tt, lt, mt) {
            const ft = {}
              , xt = new WeakMap;
            function Ct(Lt) {
                const Nt = Lt.target;
                Nt.index !== null && tt.remove(Nt.index);
                for (const Wt in Nt.attributes)
                    tt.remove(Nt.attributes[Wt]);
                for (const Wt in Nt.morphAttributes) {
                    const Qt = Nt.morphAttributes[Wt];
                    for (let qt = 0, Xt = Qt.length; qt < Xt; qt++)
                        tt.remove(Qt[qt])
                }
                Nt.removeEventListener("dispose", Ct),
                delete ft[Nt.id];
                const jt = xt.get(Nt);
                jt && (tt.remove(jt),
                xt.delete(Nt)),
                mt.releaseStatesOfGeometry(Nt),
                Nt.isInstancedBufferGeometry === !0 && delete Nt._maxInstanceCount,
                lt.memory.geometries--
            }
            function Mt(Lt) {
                const Nt = []
                  , jt = Lt.index
                  , Wt = Lt.attributes.position;
                let Qt = 0;
                if (jt !== null) {
                    const Zt = jt.array;
                    Qt = jt.version;
                    for (let Yt = 0, sr = Zt.length; Yt < sr; Yt += 3) {
                        const er = Zt[Yt + 0]
                          , rr = Zt[Yt + 1]
                          , xr = Zt[Yt + 2];
                        Nt.push(er, rr, rr, xr, xr, er)
                    }
                } else {
                    if (Wt === void 0)
                        return;
                    {
                        const Zt = Wt.array;
                        Qt = Wt.version;
                        for (let Yt = 0, sr = Zt.length / 3 - 1; Yt < sr; Yt += 3) {
                            const er = Yt + 0
                              , rr = Yt + 1
                              , xr = Yt + 2;
                            Nt.push(er, rr, rr, xr, xr, er)
                        }
                    }
                }
                const qt = new (tv(Nt) ? Ts : co)(Nt,1);
                qt.version = Qt;
                const Xt = xt.get(Lt);
                Xt && tt.remove(Xt),
                xt.set(Lt, qt)
            }
            return {
                get: function(Lt, Nt) {
                    return ft[Nt.id] === !0 || (Nt.addEventListener("dispose", Ct),
                    ft[Nt.id] = !0,
                    lt.memory.geometries++),
                    Nt
                },
                update: function(Lt) {
                    const Nt = Lt.attributes;
                    for (const Wt in Nt)
                        tt.update(Nt[Wt], Tt.ARRAY_BUFFER);
                    const jt = Lt.morphAttributes;
                    for (const Wt in jt) {
                        const Qt = jt[Wt];
                        for (let qt = 0, Xt = Qt.length; qt < Xt; qt++)
                            tt.update(Qt[qt], Tt.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(Lt) {
                    const Nt = xt.get(Lt);
                    if (Nt) {
                        const jt = Lt.index;
                        jt !== null && Nt.version < jt.version && Mt(Lt)
                    } else
                        Mt(Lt);
                    return xt.get(Lt)
                }
            }
        }
        function Bw(Tt, tt, lt, mt) {
            const ft = mt.isWebGL2;
            let xt, Ct, Mt;
            this.setMode = function(Lt) {
                xt = Lt
            }
            ,
            this.setIndex = function(Lt) {
                Ct = Lt.type,
                Mt = Lt.bytesPerElement
            }
            ,
            this.render = function(Lt, Nt) {
                Tt.drawElements(xt, Nt, Ct, Lt * Mt),
                lt.update(Nt, xt, 1)
            }
            ,
            this.renderInstances = function(Lt, Nt, jt) {
                if (jt === 0)
                    return;
                let Wt, Qt;
                if (ft)
                    Wt = Tt,
                    Qt = "drawElementsInstanced";
                else if (Wt = tt.get("ANGLE_instanced_arrays"),
                Qt = "drawElementsInstancedANGLE",
                Wt === null)
                    return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                Wt[Qt](xt, Nt, Ct, Lt * Mt, jt),
                lt.update(Nt, xt, jt)
            }
        }
        function Lw(Tt) {
            const tt = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: tt,
                programs: null,
                autoReset: !0,
                reset: function() {
                    tt.calls = 0,
                    tt.triangles = 0,
                    tt.points = 0,
                    tt.lines = 0
                },
                update: function(lt, mt, ft) {
                    switch (tt.calls++,
                    mt) {
                    case Tt.TRIANGLES:
                        tt.triangles += ft * (lt / 3);
                        break;
                    case Tt.LINES:
                        tt.lines += ft * (lt / 2);
                        break;
                    case Tt.LINE_STRIP:
                        tt.lines += ft * (lt - 1);
                        break;
                    case Tt.LINE_LOOP:
                        tt.lines += ft * lt;
                        break;
                    case Tt.POINTS:
                        tt.points += ft * lt;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", mt)
                    }
                }
            }
        }
        function Ow(Tt, tt) {
            return Tt[0] - tt[0]
        }
        function Nw(Tt, tt) {
            return Math.abs(tt[1]) - Math.abs(Tt[1])
        }
        function Fw(Tt, tt, lt) {
            const mt = {}
              , ft = new Float32Array(8)
              , xt = new WeakMap
              , Ct = new Lo
              , Mt = [];
            for (let Lt = 0; Lt < 8; Lt++)
                Mt[Lt] = [Lt, 0];
            return {
                update: function(Lt, Nt, jt) {
                    const Wt = Lt.morphTargetInfluences;
                    if (tt.isWebGL2 === !0) {
                        const Qt = Nt.morphAttributes.position || Nt.morphAttributes.normal || Nt.morphAttributes.color
                          , qt = Qt !== void 0 ? Qt.length : 0;
                        let Xt = xt.get(Nt);
                        if (Xt === void 0 || Xt.count !== qt) {
                            let _n = function() {
                                Gr.dispose(),
                                xt.delete(Nt),
                                Nt.removeEventListener("dispose", _n)
                            };
                            Xt !== void 0 && Xt.texture.dispose();
                            const sr = Nt.morphAttributes.position !== void 0
                              , er = Nt.morphAttributes.normal !== void 0
                              , rr = Nt.morphAttributes.color !== void 0
                              , xr = Nt.morphAttributes.position || []
                              , br = Nt.morphAttributes.normal || []
                              , yr = Nt.morphAttributes.color || [];
                            let Pr = 0;
                            sr === !0 && (Pr = 1),
                            er === !0 && (Pr = 2),
                            rr === !0 && (Pr = 3);
                            let zr = Nt.attributes.position.count * Pr
                              , Nr = 1;
                            zr > tt.maxTextureSize && (Nr = Math.ceil(zr / tt.maxTextureSize),
                            zr = tt.maxTextureSize);
                            const Vr = new Float32Array(zr * Nr * 4 * qt)
                              , Gr = new im(Vr,zr,Nr,qt);
                            Gr.type = ss,
                            Gr.needsUpdate = !0;
                            const Hr = 4 * Pr;
                            for (let dn = 0; dn < qt; dn++) {
                                const kn = xr[dn]
                                  , Bn = br[dn]
                                  , cn = yr[dn]
                                  , Yr = zr * Nr * 4 * dn;
                                for (let Jr = 0; Jr < kn.count; Jr++) {
                                    const sn = Jr * Hr;
                                    sr === !0 && (Ct.fromBufferAttribute(kn, Jr),
                                    Vr[Yr + sn + 0] = Ct.x,
                                    Vr[Yr + sn + 1] = Ct.y,
                                    Vr[Yr + sn + 2] = Ct.z,
                                    Vr[Yr + sn + 3] = 0),
                                    er === !0 && (Ct.fromBufferAttribute(Bn, Jr),
                                    Vr[Yr + sn + 4] = Ct.x,
                                    Vr[Yr + sn + 5] = Ct.y,
                                    Vr[Yr + sn + 6] = Ct.z,
                                    Vr[Yr + sn + 7] = 0),
                                    rr === !0 && (Ct.fromBufferAttribute(cn, Jr),
                                    Vr[Yr + sn + 8] = Ct.x,
                                    Vr[Yr + sn + 9] = Ct.y,
                                    Vr[Yr + sn + 10] = Ct.z,
                                    Vr[Yr + sn + 11] = cn.itemSize === 4 ? Ct.w : 1)
                                }
                            }
                            Xt = {
                                count: qt,
                                texture: Gr,
                                size: new mn(zr,Nr)
                            },
                            xt.set(Nt, Xt),
                            Nt.addEventListener("dispose", _n)
                        }
                        let Zt = 0;
                        for (let sr = 0; sr < Wt.length; sr++)
                            Zt += Wt[sr];
                        const Yt = Nt.morphTargetsRelative ? 1 : 1 - Zt;
                        jt.getUniforms().setValue(Tt, "morphTargetBaseInfluence", Yt),
                        jt.getUniforms().setValue(Tt, "morphTargetInfluences", Wt),
                        jt.getUniforms().setValue(Tt, "morphTargetsTexture", Xt.texture, lt),
                        jt.getUniforms().setValue(Tt, "morphTargetsTextureSize", Xt.size)
                    } else {
                        const Qt = Wt === void 0 ? 0 : Wt.length;
                        let qt = mt[Nt.id];
                        if (qt === void 0 || qt.length !== Qt) {
                            qt = [];
                            for (let er = 0; er < Qt; er++)
                                qt[er] = [er, 0];
                            mt[Nt.id] = qt
                        }
                        for (let er = 0; er < Qt; er++) {
                            const rr = qt[er];
                            rr[0] = er,
                            rr[1] = Wt[er]
                        }
                        qt.sort(Nw);
                        for (let er = 0; er < 8; er++)
                            er < Qt && qt[er][1] ? (Mt[er][0] = qt[er][0],
                            Mt[er][1] = qt[er][1]) : (Mt[er][0] = Number.MAX_SAFE_INTEGER,
                            Mt[er][1] = 0);
                        Mt.sort(Ow);
                        const Xt = Nt.morphAttributes.position
                          , Zt = Nt.morphAttributes.normal;
                        let Yt = 0;
                        for (let er = 0; er < 8; er++) {
                            const rr = Mt[er]
                              , xr = rr[0]
                              , br = rr[1];
                            xr !== Number.MAX_SAFE_INTEGER && br ? (Xt && Nt.getAttribute("morphTarget" + er) !== Xt[xr] && Nt.setAttribute("morphTarget" + er, Xt[xr]),
                            Zt && Nt.getAttribute("morphNormal" + er) !== Zt[xr] && Nt.setAttribute("morphNormal" + er, Zt[xr]),
                            ft[er] = br,
                            Yt += br) : (Xt && Nt.hasAttribute("morphTarget" + er) === !0 && Nt.deleteAttribute("morphTarget" + er),
                            Zt && Nt.hasAttribute("morphNormal" + er) === !0 && Nt.deleteAttribute("morphNormal" + er),
                            ft[er] = 0)
                        }
                        const sr = Nt.morphTargetsRelative ? 1 : 1 - Yt;
                        jt.getUniforms().setValue(Tt, "morphTargetBaseInfluence", sr),
                        jt.getUniforms().setValue(Tt, "morphTargetInfluences", ft)
                    }
                }
            }
        }
        function Uw(Tt, tt, lt, mt) {
            let ft = new WeakMap;
            function xt(Ct) {
                const Mt = Ct.target;
                Mt.removeEventListener("dispose", xt),
                lt.remove(Mt.instanceMatrix),
                Mt.instanceColor !== null && lt.remove(Mt.instanceColor)
            }
            return {
                update: function(Ct) {
                    const Mt = mt.render.frame
                      , Lt = Ct.geometry
                      , Nt = tt.get(Ct, Lt);
                    if (ft.get(Nt) !== Mt && (tt.update(Nt),
                    ft.set(Nt, Mt)),
                    Ct.isInstancedMesh && (Ct.hasEventListener("dispose", xt) === !1 && Ct.addEventListener("dispose", xt),
                    ft.get(Ct) !== Mt && (lt.update(Ct.instanceMatrix, Tt.ARRAY_BUFFER),
                    Ct.instanceColor !== null && lt.update(Ct.instanceColor, Tt.ARRAY_BUFFER),
                    ft.set(Ct, Mt))),
                    Ct.isSkinnedMesh) {
                        const jt = Ct.skeleton;
                        ft.get(jt) !== Mt && (jt.update(),
                        ft.set(jt, Mt))
                    }
                    return Nt
                },
                dispose: function() {
                    ft = new WeakMap
                }
            }
        }
        const Ky = new Ho
          , Jy = new im
          , Zy = new i_
          , ex = new f_
          , tx = []
          , rx = []
          , nx = new Float32Array(16)
          , ix = new Float32Array(9)
          , ox = new Float32Array(4);
        function bm(Tt, tt, lt) {
            const mt = Tt[0];
            if (mt <= 0 || mt > 0)
                return Tt;
            const ft = tt * lt;
            let xt = tx[ft];
            if (xt === void 0 && (xt = new Float32Array(ft),
            tx[ft] = xt),
            tt !== 0) {
                mt.toArray(xt, 0);
                for (let Ct = 1, Mt = 0; Ct !== tt; ++Ct)
                    Mt += lt,
                    Tt[Ct].toArray(xt, Mt)
            }
            return xt
        }
        function cs(Tt, tt) {
            if (Tt.length !== tt.length)
                return !1;
            for (let lt = 0, mt = Tt.length; lt < mt; lt++)
                if (Tt[lt] !== tt[lt])
                    return !1;
            return !0
        }
        function us(Tt, tt) {
            for (let lt = 0, mt = tt.length; lt < mt; lt++)
                Tt[lt] = tt[lt]
        }
        function Tv(Tt, tt) {
            let lt = rx[tt];
            lt === void 0 && (lt = new Int32Array(tt),
            rx[tt] = lt);
            for (let mt = 0; mt !== tt; ++mt)
                lt[mt] = Tt.allocateTextureUnit();
            return lt
        }
        function jw(Tt, tt) {
            const lt = this.cache;
            lt[0] !== tt && (Tt.uniform1f(this.addr, tt),
            lt[0] = tt)
        }
        function Vw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y || (Tt.uniform2f(this.addr, tt.x, tt.y),
                lt[0] = tt.x,
                lt[1] = tt.y);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform2fv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Gw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z || (Tt.uniform3f(this.addr, tt.x, tt.y, tt.z),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z);
            else if (tt.r !== void 0)
                lt[0] === tt.r && lt[1] === tt.g && lt[2] === tt.b || (Tt.uniform3f(this.addr, tt.r, tt.g, tt.b),
                lt[0] = tt.r,
                lt[1] = tt.g,
                lt[2] = tt.b);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform3fv(this.addr, tt),
                us(lt, tt)
            }
        }
        function zw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z && lt[3] === tt.w || (Tt.uniform4f(this.addr, tt.x, tt.y, tt.z, tt.w),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z,
                lt[3] = tt.w);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform4fv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Hw(Tt, tt) {
            const lt = this.cache
              , mt = tt.elements;
            if (mt === void 0) {
                if (cs(lt, tt))
                    return;
                Tt.uniformMatrix2fv(this.addr, !1, tt),
                us(lt, tt)
            } else {
                if (cs(lt, mt))
                    return;
                ox.set(mt),
                Tt.uniformMatrix2fv(this.addr, !1, ox),
                us(lt, mt)
            }
        }
        function Qw(Tt, tt) {
            const lt = this.cache
              , mt = tt.elements;
            if (mt === void 0) {
                if (cs(lt, tt))
                    return;
                Tt.uniformMatrix3fv(this.addr, !1, tt),
                us(lt, tt)
            } else {
                if (cs(lt, mt))
                    return;
                ix.set(mt),
                Tt.uniformMatrix3fv(this.addr, !1, ix),
                us(lt, mt)
            }
        }
        function Ww(Tt, tt) {
            const lt = this.cache
              , mt = tt.elements;
            if (mt === void 0) {
                if (cs(lt, tt))
                    return;
                Tt.uniformMatrix4fv(this.addr, !1, tt),
                us(lt, tt)
            } else {
                if (cs(lt, mt))
                    return;
                nx.set(mt),
                Tt.uniformMatrix4fv(this.addr, !1, nx),
                us(lt, mt)
            }
        }
        function qw(Tt, tt) {
            const lt = this.cache;
            lt[0] !== tt && (Tt.uniform1i(this.addr, tt),
            lt[0] = tt)
        }
        function $w(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y || (Tt.uniform2i(this.addr, tt.x, tt.y),
                lt[0] = tt.x,
                lt[1] = tt.y);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform2iv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Xw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z || (Tt.uniform3i(this.addr, tt.x, tt.y, tt.z),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform3iv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Yw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z && lt[3] === tt.w || (Tt.uniform4i(this.addr, tt.x, tt.y, tt.z, tt.w),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z,
                lt[3] = tt.w);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform4iv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Kw(Tt, tt) {
            const lt = this.cache;
            lt[0] !== tt && (Tt.uniform1ui(this.addr, tt),
            lt[0] = tt)
        }
        function Jw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y || (Tt.uniform2ui(this.addr, tt.x, tt.y),
                lt[0] = tt.x,
                lt[1] = tt.y);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform2uiv(this.addr, tt),
                us(lt, tt)
            }
        }
        function Zw(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z || (Tt.uniform3ui(this.addr, tt.x, tt.y, tt.z),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform3uiv(this.addr, tt),
                us(lt, tt)
            }
        }
        function e1(Tt, tt) {
            const lt = this.cache;
            if (tt.x !== void 0)
                lt[0] === tt.x && lt[1] === tt.y && lt[2] === tt.z && lt[3] === tt.w || (Tt.uniform4ui(this.addr, tt.x, tt.y, tt.z, tt.w),
                lt[0] = tt.x,
                lt[1] = tt.y,
                lt[2] = tt.z,
                lt[3] = tt.w);
            else {
                if (cs(lt, tt))
                    return;
                Tt.uniform4uiv(this.addr, tt),
                us(lt, tt)
            }
        }
        function t1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTexture2D(tt || Ky, ft)
        }
        function r1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTexture3D(tt || Zy, ft)
        }
        function n1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTextureCube(tt || ex, ft)
        }
        function i1(Tt, tt, lt) {
            const mt = this.cache
              , ft = lt.allocateTextureUnit();
            mt[0] !== ft && (Tt.uniform1i(this.addr, ft),
            mt[0] = ft),
            lt.setTexture2DArray(tt || Jy, ft)
        }
        function o1(Tt, tt) {
            Tt.uniform1fv(this.addr, tt)
        }
        function s1(Tt, tt) {
            const lt = bm(tt, this.size, 2);
            Tt.uniform2fv(this.addr, lt)
        }
        function a1(Tt, tt) {
            const lt = bm(tt, this.size, 3);
            Tt.uniform3fv(this.addr, lt)
        }
        function l1(Tt, tt) {
            const lt = bm(tt, this.size, 4);
            Tt.uniform4fv(this.addr, lt)
        }
        function c1(Tt, tt) {
            const lt = bm(tt, this.size, 4);
            Tt.uniformMatrix2fv(this.addr, !1, lt)
        }
        function u1(Tt, tt) {
            const lt = bm(tt, this.size, 9);
            Tt.uniformMatrix3fv(this.addr, !1, lt)
        }
        function d1(Tt, tt) {
            const lt = bm(tt, this.size, 16);
            Tt.uniformMatrix4fv(this.addr, !1, lt)
        }
        function p1(Tt, tt) {
            Tt.uniform1iv(this.addr, tt)
        }
        function h1(Tt, tt) {
            Tt.uniform2iv(this.addr, tt)
        }
        function m1(Tt, tt) {
            Tt.uniform3iv(this.addr, tt)
        }
        function f1(Tt, tt) {
            Tt.uniform4iv(this.addr, tt)
        }
        function g1(Tt, tt) {
            Tt.uniform1uiv(this.addr, tt)
        }
        function _1(Tt, tt) {
            Tt.uniform2uiv(this.addr, tt)
        }
        function y1(Tt, tt) {
            Tt.uniform3uiv(this.addr, tt)
        }
        function x1(Tt, tt) {
            Tt.uniform4uiv(this.addr, tt)
        }
        function b1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTexture2D(tt[Ct] || Ky, xt[Ct])
        }
        function A1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTexture3D(tt[Ct] || Zy, xt[Ct])
        }
        function w1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTextureCube(tt[Ct] || ex, xt[Ct])
        }
        function S1(Tt, tt, lt) {
            const mt = this.cache
              , ft = tt.length
              , xt = Tv(lt, ft);
            cs(mt, xt) || (Tt.uniform1iv(this.addr, xt),
            us(mt, xt));
            for (let Ct = 0; Ct !== ft; ++Ct)
                lt.setTexture2DArray(tt[Ct] || Jy, xt[Ct])
        }
        class E1 {
            constructor(tt, lt, mt) {
                this.id = tt,
                this.addr = mt,
                this.cache = [],
                this.setValue = function(ft) {
                    switch (ft) {
                    case 5126:
                        return jw;
                    case 35664:
                        return Vw;
                    case 35665:
                        return Gw;
                    case 35666:
                        return zw;
                    case 35674:
                        return Hw;
                    case 35675:
                        return Qw;
                    case 35676:
                        return Ww;
                    case 5124:
                    case 35670:
                        return qw;
                    case 35667:
                    case 35671:
                        return $w;
                    case 35668:
                    case 35672:
                        return Xw;
                    case 35669:
                    case 35673:
                        return Yw;
                    case 5125:
                        return Kw;
                    case 36294:
                        return Jw;
                    case 36295:
                        return Zw;
                    case 36296:
                        return e1;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return t1;
                    case 35679:
                    case 36299:
                    case 36307:
                        return r1;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return n1;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return i1
                    }
                }(lt.type)
            }
        }
        class T1 {
            constructor(tt, lt, mt) {
                this.id = tt,
                this.addr = mt,
                this.cache = [],
                this.size = lt.size,
                this.setValue = function(ft) {
                    switch (ft) {
                    case 5126:
                        return o1;
                    case 35664:
                        return s1;
                    case 35665:
                        return a1;
                    case 35666:
                        return l1;
                    case 35674:
                        return c1;
                    case 35675:
                        return u1;
                    case 35676:
                        return d1;
                    case 5124:
                    case 35670:
                        return p1;
                    case 35667:
                    case 35671:
                        return h1;
                    case 35668:
                    case 35672:
                        return m1;
                    case 35669:
                    case 35673:
                        return f1;
                    case 5125:
                        return g1;
                    case 36294:
                        return _1;
                    case 36295:
                        return y1;
                    case 36296:
                        return x1;
                    case 35678:
                    case 36198:
                    case 36298:
                    case 36306:
                    case 35682:
                        return b1;
                    case 35679:
                    case 36299:
                    case 36307:
                        return A1;
                    case 35680:
                    case 36300:
                    case 36308:
                    case 36293:
                        return w1;
                    case 36289:
                    case 36303:
                    case 36311:
                    case 36292:
                        return S1
                    }
                }(lt.type)
            }
        }
        class C1 {
            constructor(tt) {
                this.id = tt,
                this.seq = [],
                this.map = {}
            }
            setValue(tt, lt, mt) {
                const ft = this.seq;
                for (let xt = 0, Ct = ft.length; xt !== Ct; ++xt) {
                    const Mt = ft[xt];
                    Mt.setValue(tt, lt[Mt.id], mt)
                }
            }
        }
        const G0 = /(\w+)(\])?(\[|\.)?/g;
        function sx(Tt, tt) {
            Tt.seq.push(tt),
            Tt.map[tt.id] = tt
        }
        function P1(Tt, tt, lt) {
            const mt = Tt.name
              , ft = mt.length;
            for (G0.lastIndex = 0; ; ) {
                const xt = G0.exec(mt)
                  , Ct = G0.lastIndex;
                let Mt = xt[1];
                const Lt = xt[2] === "]"
                  , Nt = xt[3];
                if (Lt && (Mt |= 0),
                Nt === void 0 || Nt === "[" && Ct + 2 === ft) {
                    sx(lt, Nt === void 0 ? new E1(Mt,Tt,tt) : new T1(Mt,Tt,tt));
                    break
                }
                {
                    let jt = lt.map[Mt];
                    jt === void 0 && (jt = new C1(Mt),
                    sx(lt, jt)),
                    lt = jt
                }
            }
        }
        class Cv {
            constructor(tt, lt) {
                this.seq = [],
                this.map = {};
                const mt = tt.getProgramParameter(lt, tt.ACTIVE_UNIFORMS);
                for (let ft = 0; ft < mt; ++ft) {
                    const xt = tt.getActiveUniform(lt, ft);
                    P1(xt, tt.getUniformLocation(lt, xt.name), this)
                }
            }
            setValue(tt, lt, mt, ft) {
                const xt = this.map[lt];
                xt !== void 0 && xt.setValue(tt, mt, ft)
            }
            setOptional(tt, lt, mt) {
                const ft = lt[mt];
                ft !== void 0 && this.setValue(tt, mt, ft)
            }
            static upload(tt, lt, mt, ft) {
                for (let xt = 0, Ct = lt.length; xt !== Ct; ++xt) {
                    const Mt = lt[xt]
                      , Lt = mt[Mt.id];
                    Lt.needsUpdate !== !1 && Mt.setValue(tt, Lt.value, ft)
                }
            }
            static seqWithValue(tt, lt) {
                const mt = [];
                for (let ft = 0, xt = tt.length; ft !== xt; ++ft) {
                    const Ct = tt[ft];
                    Ct.id in lt && mt.push(Ct)
                }
                return mt
            }
        }
        function ax(Tt, tt, lt) {
            const mt = Tt.createShader(tt);
            return Tt.shaderSource(mt, lt),
            Tt.compileShader(mt),
            mt
        }
        let M1 = 0;
        function lx(Tt, tt, lt) {
            const mt = Tt.getShaderParameter(tt, Tt.COMPILE_STATUS)
              , ft = Tt.getShaderInfoLog(tt).trim();
            if (mt && ft === "")
                return "";
            const xt = /ERROR: 0:(\d+)/.exec(ft);
            if (xt) {
                const Ct = parseInt(xt[1]);
                return lt.toUpperCase() + `

` + ft + `

` + function(Mt, Lt) {
                    const Nt = Mt.split(`
`)
                      , jt = []
                      , Wt = Math.max(Lt - 6, 0)
                      , Qt = Math.min(Lt + 6, Nt.length);
                    for (let qt = Wt; qt < Qt; qt++) {
                        const Xt = qt + 1;
                        jt.push(`${Xt === Lt ? ">" : " "} ${Xt}: ${Nt[qt]}`)
                    }
                    return jt.join(`
`)
                }(Tt.getShaderSource(tt), Ct)
            }
            return ft
        }
        function R1(Tt, tt) {
            let lt;
            switch (tt) {
            case Xo:
                lt = "";
                break;
            case jo:
                lt = "sRGBToLinear";
                break;
            case ps:
                lt = "RGBM16ToLinear";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported color space:", tt),
                lt = ""
            }
            return `vec4 ${Tt}( vec4 value ) { return ${lt} ( value ); }`
        }
        function I1(Tt, tt) {
            const lt = function(mt) {
                const ft = Do.getPrimaries(Do.workingColorSpace)
                  , xt = mt === Oo || mt === ps ? null : Do.getPrimaries(mt);
                let Ct;
                switch (ft !== xt && xt ? ft === Ou && xt === Wo ? Ct = "LinearDisplayP3ToLinearSRGB" : ft === Wo && xt === Ou && (Ct = "LinearSRGBToLinearDisplayP3") : Ct = "",
                mt) {
                case Oo:
                    return ["", ""];
                case Xo:
                case hu:
                    return [Ct, "LinearTransferOETF"];
                case jo:
                case dp:
                    return [Ct, "sRGBTransferOETF"];
                case ps:
                    return ["", "LinearToRGBM16"];
                default:
                    return console.warn("THREE.WebGLProgram: Unsupported color space:", mt),
                    [Ct, "LinearTransferOETF"]
                }
            }(tt);
            return `vec4 ${Tt}( vec4 value ) { return ${lt[0]}( ${lt[1]}( value ) ); }`
        }
        function k1(Tt, tt) {
            let lt;
            switch (tt) {
            case nn:
                lt = "Linear";
                break;
            case xn:
                lt = "Reinhard";
                break;
            case ur:
                lt = "OptimizedCineon";
                break;
            case pr:
                lt = "ACESFilmic";
                break;
            case Ir:
                lt = "Custom";
                break;
            default:
                console.warn("THREE.WebGLProgram: Unsupported toneMapping:", tt),
                lt = "Linear"
            }
            return "vec3 " + Tt + "( vec3 color ) { return " + lt + "ToneMapping( color ); }"
        }
        function __(Tt) {
            return Tt !== ""
        }
        function cx(Tt, tt) {
            const lt = tt.numSpotLightShadows + tt.numSpotLightMaps - tt.numSpotLightShadowsWithMaps;
            return Tt.replace(/NUM_DIR_LIGHTS/g, tt.numDirLights).replace(/NUM_SPOT_LIGHTS/g, tt.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, tt.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, lt).replace(/NUM_RECT_AREA_LIGHTS/g, tt.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, tt.numPointLights).replace(/NUM_HEMI_LIGHTS/g, tt.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, tt.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, tt.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, tt.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, tt.numPointLightShadows)
        }
        function ux(Tt, tt) {
            return Tt.replace(/NUM_CLIPPING_PLANES/g, tt.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, tt.numClippingPlanes - tt.numClipIntersection)
        }
        const D1 = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function z0(Tt) {
            return Tt.replace(D1, L1)
        }
        const B1 = new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
        function L1(Tt, tt) {
            let lt = go[tt];
            if (lt === void 0) {
                const mt = B1.get(tt);
                if (mt === void 0)
                    throw new Error("Can not resolve #include <" + tt + ">");
                lt = go[mt],
                console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', tt, mt)
            }
            return z0(lt)
        }
        const O1 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function dx(Tt) {
            return Tt.replace(O1, N1)
        }
        function N1(Tt, tt, lt, mt) {
            let ft = "";
            for (let xt = parseInt(tt); xt < parseInt(lt); xt++)
                ft += mt.replace(/\[\s*i\s*\]/g, "[ " + xt + " ]").replace(/UNROLLED_LOOP_INDEX/g, xt);
            return ft
        }
        function hx(Tt) {
            let tt = "precision " + Tt.precision + ` float;
precision ` + Tt.precision + " int;";
            return Tt.precision === "highp" ? tt += `
#define HIGH_PRECISION` : Tt.precision === "mediump" ? tt += `
#define MEDIUM_PRECISION` : Tt.precision === "lowp" && (tt += `
#define LOW_PRECISION`),
            tt
        }
        function F1(Tt, tt, lt, mt) {
            const ft = Tt.getContext()
              , xt = lt.defines;
            let Ct = lt.vertexShader
              , Mt = lt.fragmentShader;
            const Lt = function(Nr) {
                let Vr = "SHADOWMAP_TYPE_BASIC";
                return Nr.shadowMapType === pt ? Vr = "SHADOWMAP_TYPE_PCF" : Nr.shadowMapType === ht ? Vr = "SHADOWMAP_TYPE_PCF_SOFT" : Nr.shadowMapType === _t && (Vr = "SHADOWMAP_TYPE_VSM"),
                Vr
            }(lt)
              , Nt = function(Nr) {
                let Vr = "ENVMAP_TYPE_CUBE";
                if (Nr.envMap)
                    switch (Nr.envMapMode) {
                    case Qr:
                    case Or:
                        Vr = "ENVMAP_TYPE_CUBE";
                        break;
                    case Mn:
                        Vr = "ENVMAP_TYPE_CUBE_UV"
                    }
                return Vr
            }(lt)
              , jt = function(Nr) {
                let Vr = "ENVMAP_MODE_REFLECTION";
                return Nr.envMap && Nr.envMapMode === Or && (Vr = "ENVMAP_MODE_REFRACTION"),
                Vr
            }(lt)
              , Wt = function(Nr) {
                let Vr = "ENVMAP_BLENDING_NONE";
                if (Nr.envMap)
                    switch (Nr.combine) {
                    case Wn:
                        Vr = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case qn:
                        Vr = "ENVMAP_BLENDING_MIX";
                        break;
                    case mo:
                        Vr = "ENVMAP_BLENDING_ADD"
                    }
                return Vr
            }(lt)
              , Qt = function(Nr) {
                const Vr = Nr.envMapCubeUVHeight;
                if (Vr === null)
                    return null;
                const Gr = Math.log2(Vr) - 2
                  , Hr = 1 / Vr;
                return {
                    texelWidth: 1 / (3 * Math.max(Math.pow(2, Gr), 112)),
                    texelHeight: Hr,
                    maxMip: Gr
                }
            }(lt)
              , qt = lt.isWebGL2 ? "" : function(Nr) {
                return [Nr.extensionDerivatives || Nr.envMapCubeUVHeight || Nr.bumpMap || Nr.normalMapTangentSpace || Nr.clearcoatNormalMap || Nr.flatShading || Nr.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (Nr.extensionFragDepth || Nr.logarithmicDepthBuffer) && Nr.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", Nr.extensionDrawBuffers && Nr.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (Nr.extensionShaderTextureLOD || Nr.envMap || Nr.transmission) && Nr.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(__).join(`
`)
            }(lt)
              , Xt = function(Nr) {
                const Vr = [];
                for (const Gr in Nr) {
                    const Hr = Nr[Gr];
                    Hr !== !1 && Vr.push("#define " + Gr + " " + Hr)
                }
                return Vr.join(`
`)
            }(xt)
              , Zt = ft.createProgram();
            let Yt, sr, er = lt.glslVersion ? "#version " + lt.glslVersion + `
` : "";
            lt.isRawShaderMaterial ? (Yt = ["#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt].filter(__).join(`
`),
            Yt.length > 0 && (Yt += `
`),
            sr = [qt, "#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt].filter(__).join(`
`),
            sr.length > 0 && (sr += `
`)) : (Yt = [hx(lt), "#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt, lt.instancing ? "#define USE_INSTANCING" : "", lt.instancingColor ? "#define USE_INSTANCING_COLOR" : "", lt.useFog && lt.fog ? "#define USE_FOG" : "", lt.useFog && lt.fogExp2 ? "#define FOG_EXP2" : "", lt.map ? "#define USE_MAP" : "", lt.envMap ? "#define USE_ENVMAP" : "", lt.envMap ? "#define " + jt : "", lt.lightMap ? "#define USE_LIGHTMAP" : "", lt.aoMap ? "#define USE_AOMAP" : "", lt.bumpMap ? "#define USE_BUMPMAP" : "", lt.normalMap ? "#define USE_NORMALMAP" : "", lt.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", lt.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", lt.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", lt.emissiveMap ? "#define USE_EMISSIVEMAP" : "", lt.anisotropy ? "#define USE_ANISOTROPY" : "", lt.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", lt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", lt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", lt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", lt.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", lt.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", lt.specularMap ? "#define USE_SPECULARMAP" : "", lt.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", lt.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", lt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", lt.metalnessMap ? "#define USE_METALNESSMAP" : "", lt.alphaMap ? "#define USE_ALPHAMAP" : "", lt.alphaHash ? "#define USE_ALPHAHASH" : "", lt.transmission ? "#define USE_TRANSMISSION" : "", lt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", lt.thicknessMap ? "#define USE_THICKNESSMAP" : "", lt.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", lt.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", lt.mapUv ? "#define MAP_UV " + lt.mapUv : "", lt.alphaMapUv ? "#define ALPHAMAP_UV " + lt.alphaMapUv : "", lt.lightMapUv ? "#define LIGHTMAP_UV " + lt.lightMapUv : "", lt.aoMapUv ? "#define AOMAP_UV " + lt.aoMapUv : "", lt.emissiveMapUv ? "#define EMISSIVEMAP_UV " + lt.emissiveMapUv : "", lt.bumpMapUv ? "#define BUMPMAP_UV " + lt.bumpMapUv : "", lt.normalMapUv ? "#define NORMALMAP_UV " + lt.normalMapUv : "", lt.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + lt.displacementMapUv : "", lt.metalnessMapUv ? "#define METALNESSMAP_UV " + lt.metalnessMapUv : "", lt.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + lt.roughnessMapUv : "", lt.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + lt.anisotropyMapUv : "", lt.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + lt.clearcoatMapUv : "", lt.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + lt.clearcoatNormalMapUv : "", lt.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + lt.clearcoatRoughnessMapUv : "", lt.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + lt.iridescenceMapUv : "", lt.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + lt.iridescenceThicknessMapUv : "", lt.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + lt.sheenColorMapUv : "", lt.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + lt.sheenRoughnessMapUv : "", lt.specularMapUv ? "#define SPECULARMAP_UV " + lt.specularMapUv : "", lt.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + lt.specularColorMapUv : "", lt.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + lt.specularIntensityMapUv : "", lt.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + lt.transmissionMapUv : "", lt.thicknessMapUv ? "#define THICKNESSMAP_UV " + lt.thicknessMapUv : "", lt.vertexTangents && lt.flatShading === !1 ? "#define USE_TANGENT" : "", lt.vertexColors ? "#define USE_COLOR" : "", lt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", lt.vertexUv1s ? "#define USE_UV1" : "", lt.vertexUv2s ? "#define USE_UV2" : "", lt.vertexUv3s ? "#define USE_UV3" : "", lt.pointsUvs ? "#define USE_POINTS_UV" : "", lt.flatShading ? "#define FLAT_SHADED" : "", lt.skinning ? "#define USE_SKINNING" : "", lt.morphTargets ? "#define USE_MORPHTARGETS" : "", lt.morphNormals && lt.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", lt.morphColors && lt.isWebGL2 ? "#define USE_MORPHCOLORS" : "", lt.morphTargetsCount > 0 && lt.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", lt.morphTargetsCount > 0 && lt.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + lt.morphTextureStride : "", lt.morphTargetsCount > 0 && lt.isWebGL2 ? "#define MORPHTARGETS_COUNT " + lt.morphTargetsCount : "", lt.doubleSided ? "#define DOUBLE_SIDED" : "", lt.flipSided ? "#define FLIP_SIDED" : "", lt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", lt.shadowMapEnabled ? "#define " + Lt : "", lt.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", lt.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", lt.useLegacyLights ? "#define LEGACY_LIGHTS" : "", lt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", lt.logarithmicDepthBuffer && lt.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(__).join(`
`),
            sr = [qt, hx(lt), "#define SHADER_TYPE " + lt.shaderType, "#define SHADER_NAME " + lt.shaderName, Xt, lt.instancing ? "#define USE_INSTANCING" : "", lt.instancingColor ? "#define USE_INSTANCING_COLOR" : "", lt.useFog && lt.fog ? "#define USE_FOG" : "", lt.useFog && lt.fogExp2 ? "#define FOG_EXP2" : "", lt.map ? "#define USE_MAP" : "", lt.matcap ? "#define USE_MATCAP" : "", lt.envMap ? "#define USE_ENVMAP" : "", lt.envMap ? "#define " + Nt : "", lt.envMap ? "#define " + jt : "", lt.envMap ? "#define " + Wt : "", Qt ? "#define CUBEUV_TEXEL_WIDTH " + Qt.texelWidth : "", Qt ? "#define CUBEUV_TEXEL_HEIGHT " + Qt.texelHeight : "", Qt ? "#define CUBEUV_MAX_MIP " + Qt.maxMip + ".0" : "", lt.lightMap ? "#define USE_LIGHTMAP" : "", lt.aoMap ? "#define USE_AOMAP" : "", lt.bumpMap ? "#define USE_BUMPMAP" : "", lt.normalMap ? "#define USE_NORMALMAP" : "", lt.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", lt.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", lt.emissiveMap ? "#define USE_EMISSIVEMAP" : "", lt.anisotropy ? "#define USE_ANISOTROPY" : "", lt.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", lt.clearcoat ? "#define USE_CLEARCOAT" : "", lt.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", lt.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", lt.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", lt.iridescence ? "#define USE_IRIDESCENCE" : "", lt.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", lt.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", lt.specularMap ? "#define USE_SPECULARMAP" : "", lt.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", lt.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", lt.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", lt.metalnessMap ? "#define USE_METALNESSMAP" : "", lt.alphaMap ? "#define USE_ALPHAMAP" : "", lt.alphaTest ? "#define USE_ALPHATEST" : "", lt.alphaHash ? "#define USE_ALPHAHASH" : "", lt.sheen ? "#define USE_SHEEN" : "", lt.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", lt.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", lt.transmission ? "#define USE_TRANSMISSION" : "", lt.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", lt.thicknessMap ? "#define USE_THICKNESSMAP" : "", lt.vertexTangents && lt.flatShading === !1 ? "#define USE_TANGENT" : "", lt.vertexColors || lt.instancingColor ? "#define USE_COLOR" : "", lt.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", lt.vertexUv1s ? "#define USE_UV1" : "", lt.vertexUv2s ? "#define USE_UV2" : "", lt.vertexUv3s ? "#define USE_UV3" : "", lt.pointsUvs ? "#define USE_POINTS_UV" : "", lt.gradientMap ? "#define USE_GRADIENTMAP" : "", lt.flatShading ? "#define FLAT_SHADED" : "", lt.doubleSided ? "#define DOUBLE_SIDED" : "", lt.flipSided ? "#define FLIP_SIDED" : "", lt.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", lt.shadowMapEnabled ? "#define " + Lt : "", lt.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", lt.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", lt.useLegacyLights ? "#define LEGACY_LIGHTS" : "", lt.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", lt.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", lt.logarithmicDepthBuffer && lt.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", lt.toneMapping !== Ur ? "#define TONE_MAPPING" : "", lt.toneMapping !== Ur ? go.tonemapping_pars_fragment : "", lt.toneMapping !== Ur ? k1("toneMapping", lt.toneMapping) : "", lt.dithering ? "#define DITHERING" : "", lt.opaque ? "#define OPAQUE" : "", go.colorspace_pars_fragment, I1("linearToOutputTexel", lt.outputColorSpace), lt.transmissionSamplerMapEncoding ? R1("transmissionSamplerMapTexelToLinear", lt.transmissionSamplerMapEncoding) : "", lt.useDepthPacking ? "#define DEPTH_PACKING " + lt.depthPacking : "", `
`].filter(__).join(`
`)),
            Ct = z0(Ct),
            Ct = cx(Ct, lt),
            Ct = ux(Ct, lt),
            Mt = z0(Mt),
            Mt = cx(Mt, lt),
            Mt = ux(Mt, lt),
            Ct = dx(Ct),
            Mt = dx(Mt),
            lt.isWebGL2 && lt.isRawShaderMaterial !== !0 && (er = `#version 300 es
`,
            Yt = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + Yt,
            sr = ["#define varying in", lt.glslVersion === Ym ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", lt.glslVersion === Ym ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad", "#define WebGL2Context 1"].join(`
`) + `
` + sr);
            const rr = er + Yt + Ct
              , xr = er + sr + Mt
              , br = ax(ft, ft.VERTEX_SHADER, rr)
              , yr = ax(ft, ft.FRAGMENT_SHADER, xr);
            if (ft.attachShader(Zt, br),
            ft.attachShader(Zt, yr),
            lt.index0AttributeName !== void 0 ? ft.bindAttribLocation(Zt, 0, lt.index0AttributeName) : lt.morphTargets === !0 && ft.bindAttribLocation(Zt, 0, "position"),
            ft.linkProgram(Zt),
            Tt.debug.checkShaderErrors) {
                const Nr = ft.getProgramInfoLog(Zt).trim()
                  , Vr = ft.getShaderInfoLog(br).trim()
                  , Gr = ft.getShaderInfoLog(yr).trim();
                let Hr = !0
                  , _n = !0;
                if (ft.getProgramParameter(Zt, ft.LINK_STATUS) === !1)
                    if (Hr = !1,
                    typeof Tt.debug.onShaderError == "function")
                        Tt.debug.onShaderError(ft, Zt, br, yr);
                    else {
                        const dn = lx(ft, br, "vertex")
                          , kn = lx(ft, yr, "fragment");
                        console.error("THREE.WebGLProgram: Shader Error " + ft.getError() + " - VALIDATE_STATUS " + ft.getProgramParameter(Zt, ft.VALIDATE_STATUS) + `

Program Info Log: ` + Nr + `
` + dn + `
` + kn)
                    }
                else
                    Nr !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Nr) : Vr !== "" && Gr !== "" || (_n = !1);
                _n && (this.diagnostics = {
                    runnable: Hr,
                    programLog: Nr,
                    vertexShader: {
                        log: Vr,
                        prefix: Yt
                    },
                    fragmentShader: {
                        log: Gr,
                        prefix: sr
                    }
                })
            }
            let Pr, zr;
            return ft.deleteShader(br),
            ft.deleteShader(yr),
            this.getUniforms = function() {
                return Pr === void 0 && (Pr = new Cv(ft,Zt)),
                Pr
            }
            ,
            this.getAttributes = function() {
                return zr === void 0 && (zr = function(Nr, Vr) {
                    const Gr = {}
                      , Hr = Nr.getProgramParameter(Vr, Nr.ACTIVE_ATTRIBUTES);
                    for (let _n = 0; _n < Hr; _n++) {
                        const dn = Nr.getActiveAttrib(Vr, _n)
                          , kn = dn.name;
                        let Bn = 1;
                        dn.type === Nr.FLOAT_MAT2 && (Bn = 2),
                        dn.type === Nr.FLOAT_MAT3 && (Bn = 3),
                        dn.type === Nr.FLOAT_MAT4 && (Bn = 4),
                        Gr[kn] = {
                            type: dn.type,
                            location: Nr.getAttribLocation(Vr, kn),
                            locationSize: Bn
                        }
                    }
                    return Gr
                }(ft, Zt)),
                zr
            }
            ,
            this.destroy = function() {
                mt.releaseStatesOfProgram(this),
                ft.deleteProgram(Zt),
                this.program = void 0
            }
            ,
            this.type = lt.shaderType,
            this.name = lt.shaderName,
            this.id = M1++,
            this.cacheKey = tt,
            this.usedTimes = 1,
            this.program = Zt,
            this.vertexShader = br,
            this.fragmentShader = yr,
            this
        }
        let U1 = 0;
        class j1 {
            constructor() {
                this.shaderCache = new Map,
                this.materialCache = new Map
            }
            update(tt) {
                const lt = tt.vertexShader
                  , mt = tt.fragmentShader
                  , ft = this._getShaderStage(lt)
                  , xt = this._getShaderStage(mt)
                  , Ct = this._getShaderCacheForMaterial(tt);
                return Ct.has(ft) === !1 && (Ct.add(ft),
                ft.usedTimes++),
                Ct.has(xt) === !1 && (Ct.add(xt),
                xt.usedTimes++),
                this
            }
            remove(tt) {
                const lt = this.materialCache.get(tt);
                for (const mt of lt)
                    mt.usedTimes--,
                    mt.usedTimes === 0 && this.shaderCache.delete(mt.code);
                return this.materialCache.delete(tt),
                this
            }
            getVertexShaderID(tt) {
                return this._getShaderStage(tt.vertexShader).id
            }
            getFragmentShaderID(tt) {
                return this._getShaderStage(tt.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(),
                this.materialCache.clear()
            }
            _getShaderCacheForMaterial(tt) {
                const lt = this.materialCache;
                let mt = lt.get(tt);
                return mt === void 0 && (mt = new Set,
                lt.set(tt, mt)),
                mt
            }
            _getShaderStage(tt) {
                const lt = this.shaderCache;
                let mt = lt.get(tt);
                return mt === void 0 && (mt = new V1(tt),
                lt.set(tt, mt)),
                mt
            }
        }
        class V1 {
            constructor(tt) {
                this.id = U1++,
                this.code = tt,
                this.usedTimes = 0
            }
        }
        function G1(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = new um
              , Lt = new j1
              , Nt = []
              , jt = ft.isWebGL2
              , Wt = ft.logarithmicDepthBuffer
              , Qt = ft.vertexTextures;
            let qt = ft.precision;
            const Xt = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };
            function Zt(Yt) {
                return Yt === 0 ? "uv" : `uv${Yt}`
            }
            return {
                getParameters: function(Yt, sr, er, rr, xr) {
                    const br = rr.fog
                      , yr = xr.geometry
                      , Pr = Yt.isMeshStandardMaterial ? rr.environment : null
                      , zr = (Yt.isMeshStandardMaterial ? lt : tt).get(Yt.envMap || Pr)
                      , Nr = zr && zr.mapping === Mn ? zr.image.height : null
                      , Vr = Xt[Yt.type];
                    Yt.precision !== null && (qt = ft.getMaxPrecision(Yt.precision),
                    qt !== Yt.precision && console.warn("THREE.WebGLProgram.getParameters:", Yt.precision, "not supported, using", qt, "instead."));
                    const Gr = yr.morphAttributes.position || yr.morphAttributes.normal || yr.morphAttributes.color
                      , Hr = Gr !== void 0 ? Gr.length : 0;
                    let _n, dn, kn, Bn, cn = 0;
                    if (yr.morphAttributes.position !== void 0 && (cn = 1),
                    yr.morphAttributes.normal !== void 0 && (cn = 2),
                    yr.morphAttributes.color !== void 0 && (cn = 3),
                    Vr) {
                        const F_ = qs[Vr];
                        _n = F_.vertexShader,
                        dn = F_.fragmentShader
                    } else
                        _n = Yt.vertexShader,
                        dn = Yt.fragmentShader,
                        Lt.update(Yt),
                        kn = Lt.getVertexShaderID(Yt),
                        Bn = Lt.getFragmentShaderID(Yt);
                    const Yr = Tt.getRenderTarget()
                      , Jr = Tt.userData && Tt.userData.transmissionRenderTarget
                      , sn = Yr ? Array.isArray(Yr.texture) ? Yr.texture[0] : Yr.texture : null
                      , on = xr.isInstancedMesh === !0
                      , Un = !!Yt.map
                      , ro = !!Yt.matcap
                      , Zn = !!zr
                      , jn = !!Yt.aoMap
                      , uo = !!Yt.lightMap
                      , Dr = !!Yt.bumpMap
                      , Sr = !!Yt.normalMap
                      , Fr = !!Yt.displacementMap
                      , Wr = !!Yt.emissiveMap
                      , kr = !!Yt.metalnessMap
                      , _r = !!Yt.roughnessMap
                      , Br = Yt.anisotropy > 0
                      , Lr = Yt.clearcoat > 0
                      , Xr = Yt.iridescence > 0
                      , Kr = Yt.sheen > 0
                      , An = Yt.transmission > 0
                      , pn = Br && !!Yt.anisotropyMap
                      , _o = Lr && !!Yt.clearcoatMap
                      , to = Lr && !!Yt.clearcoatNormalMap
                      , Pn = Lr && !!Yt.clearcoatRoughnessMap
                      , eo = Xr && !!Yt.iridescenceMap
                      , Kn = Xr && !!Yt.iridescenceThicknessMap
                      , po = Kr && !!Yt.sheenColorMap
                      , Ao = Kr && !!Yt.sheenRoughnessMap
                      , Fo = !!Yt.specularMap
                      , Io = !!Yt.specularColorMap
                      , Jn = !!Yt.specularIntensityMap
                      , Co = An && !!Yt.transmissionMap
                      , yl = An && !!Yt.thicknessMap
                      , ho = !!Yt.gradientMap
                      , Qo = !!Yt.alphaMap
                      , Po = Yt.alphaTest > 0
                      , Cu = !!Yt.alphaHash
                      , Pu = !!Yt.extensions
                      , en = !!yr.attributes.uv1
                      , g0 = !!yr.attributes.uv2
                      , _0 = !!yr.attributes.uv3;
                    let Bs = Ur;
                    return Yt.toneMapped && (Yr !== null && Yr.isXRRenderTarget !== !0 || (Bs = Tt.toneMapping)),
                    {
                        isWebGL2: jt,
                        shaderID: Vr,
                        shaderType: Yt.type,
                        shaderName: Yt.name,
                        vertexShader: _n,
                        fragmentShader: dn,
                        defines: Yt.defines,
                        customVertexShaderID: kn,
                        customFragmentShaderID: Bn,
                        isRawShaderMaterial: Yt.isRawShaderMaterial === !0,
                        glslVersion: Yt.glslVersion,
                        precision: qt,
                        instancing: on,
                        instancingColor: on && xr.instanceColor !== null,
                        supportsVertexTextures: Qt,
                        outputColorSpace: Yr === null ? Tt.outputColorSpace : Yr.isXRRenderTarget === !0 || sn.colorSpace && sn.colorSpace !== jo ? sn.colorSpace : Xo,
                        map: Un,
                        matcap: ro,
                        envMap: Zn,
                        envMapMode: Zn && zr.mapping,
                        envMapCubeUVHeight: Nr,
                        aoMap: jn,
                        lightMap: uo,
                        bumpMap: Dr,
                        normalMap: Sr,
                        displacementMap: Qt && Fr,
                        emissiveMap: Wr,
                        normalMapObjectSpace: Sr && Yt.normalMapType === Lu,
                        normalMapTangentSpace: Sr && Yt.normalMapType === El,
                        metalnessMap: kr,
                        roughnessMap: _r,
                        anisotropy: Br,
                        anisotropyMap: pn,
                        clearcoat: Lr,
                        clearcoatMap: _o,
                        clearcoatNormalMap: to,
                        clearcoatRoughnessMap: Pn,
                        iridescence: Xr,
                        iridescenceMap: eo,
                        iridescenceThicknessMap: Kn,
                        sheen: Kr,
                        sheenColorMap: po,
                        sheenRoughnessMap: Ao,
                        specularMap: Fo,
                        specularColorMap: Io,
                        specularIntensityMap: Jn,
                        transmission: An,
                        transmissionMap: Co,
                        thicknessMap: yl,
                        transmissionSamplerMapEncoding: Jr && Jr.texture.colorSpace || Xo,
                        gradientMap: ho,
                        opaque: Yt.transparent === !1 && Yt.blending === Pt && !(Yt.transmission > 0),
                        alphaMap: Qo,
                        alphaTest: Po,
                        alphaHash: Cu,
                        combine: Yt.combine,
                        mapUv: Un && Zt(Yt.map.channel),
                        aoMapUv: jn && Zt(Yt.aoMap.channel),
                        lightMapUv: uo && Zt(Yt.lightMap.channel),
                        bumpMapUv: Dr && Zt(Yt.bumpMap.channel),
                        normalMapUv: Sr && Zt(Yt.normalMap.channel),
                        displacementMapUv: Fr && Zt(Yt.displacementMap.channel),
                        emissiveMapUv: Wr && Zt(Yt.emissiveMap.channel),
                        metalnessMapUv: kr && Zt(Yt.metalnessMap.channel),
                        roughnessMapUv: _r && Zt(Yt.roughnessMap.channel),
                        anisotropyMapUv: pn && Zt(Yt.anisotropyMap.channel),
                        clearcoatMapUv: _o && Zt(Yt.clearcoatMap.channel),
                        clearcoatNormalMapUv: to && Zt(Yt.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: Pn && Zt(Yt.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: eo && Zt(Yt.iridescenceMap.channel),
                        iridescenceThicknessMapUv: Kn && Zt(Yt.iridescenceThicknessMap.channel),
                        sheenColorMapUv: po && Zt(Yt.sheenColorMap.channel),
                        sheenRoughnessMapUv: Ao && Zt(Yt.sheenRoughnessMap.channel),
                        specularMapUv: Fo && Zt(Yt.specularMap.channel),
                        specularColorMapUv: Io && Zt(Yt.specularColorMap.channel),
                        specularIntensityMapUv: Jn && Zt(Yt.specularIntensityMap.channel),
                        transmissionMapUv: Co && Zt(Yt.transmissionMap.channel),
                        thicknessMapUv: yl && Zt(Yt.thicknessMap.channel),
                        alphaMapUv: Qo && Zt(Yt.alphaMap.channel),
                        vertexTangents: !!yr.attributes.tangent && (Sr || Br || yr.userData.__forceUseTangent),
                        vertexColors: Yt.vertexColors,
                        vertexAlphas: Yt.vertexColors === !0 && !!yr.attributes.color && yr.attributes.color.itemSize === 4,
                        vertexUv1s: en,
                        vertexUv2s: g0,
                        vertexUv3s: _0,
                        pointsUvs: xr.isPoints === !0 && !!yr.attributes.uv && (Un || Qo),
                        fog: !!br,
                        useFog: Yt.fog === !0,
                        fogExp2: br && br.isFogExp2,
                        flatShading: Yt.flatShading === !0,
                        sizeAttenuation: Yt.sizeAttenuation === !0,
                        logarithmicDepthBuffer: Wt,
                        skinning: xr.isSkinnedMesh === !0,
                        morphTargets: yr.morphAttributes.position !== void 0,
                        morphNormals: yr.morphAttributes.normal !== void 0,
                        morphColors: yr.morphAttributes.color !== void 0,
                        morphTargetsCount: Hr,
                        morphTextureStride: cn,
                        numDirLights: sr.directional.length,
                        numPointLights: sr.point.length,
                        numSpotLights: sr.spot.length,
                        numSpotLightMaps: sr.spotLightMap.length,
                        numRectAreaLights: sr.rectArea.length,
                        numHemiLights: sr.hemi.length,
                        numDirLightShadows: sr.directionalShadowMap.length,
                        numPointLightShadows: sr.pointShadowMap.length,
                        numSpotLightShadows: sr.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: sr.numSpotLightShadowsWithMaps,
                        numLightProbes: sr.numLightProbes,
                        numClippingPlanes: Ct.numPlanes,
                        numClipIntersection: Ct.numIntersection,
                        dithering: Yt.dithering,
                        shadowMapEnabled: Tt.shadowMap.enabled && er.length > 0,
                        shadowMapType: Tt.shadowMap.type,
                        toneMapping: Bs,
                        useLegacyLights: Tt._useLegacyLights,
                        decodeVideoTexture: Un && Yt.map.isVideoTexture === !0 && Do.getTransfer(Yt.map.colorSpace) === Vo,
                        premultipliedAlpha: Yt.premultipliedAlpha,
                        doubleSided: Yt.side === St,
                        flipSided: Yt.side === bt,
                        useDepthPacking: Yt.depthPacking >= 0,
                        depthPacking: Yt.depthPacking || 0,
                        index0AttributeName: Yt.index0AttributeName,
                        extensionDerivatives: Pu && Yt.extensions.derivatives === !0,
                        extensionFragDepth: Pu && Yt.extensions.fragDepth === !0,
                        extensionDrawBuffers: Pu && Yt.extensions.drawBuffers === !0,
                        extensionShaderTextureLOD: Pu && Yt.extensions.shaderTextureLOD === !0,
                        rendererExtensionFragDepth: jt || mt.has("EXT_frag_depth"),
                        rendererExtensionDrawBuffers: jt || mt.has("WEBGL_draw_buffers"),
                        rendererExtensionShaderTextureLod: jt || mt.has("EXT_shader_texture_lod"),
                        customProgramCacheKey: Yt.customProgramCacheKey()
                    }
                },
                getProgramCacheKey: function(Yt) {
                    const sr = [];
                    if (Yt.shaderID ? sr.push(Yt.shaderID) : (sr.push(Yt.customVertexShaderID),
                    sr.push(Yt.customFragmentShaderID)),
                    Yt.defines !== void 0)
                        for (const er in Yt.defines)
                            sr.push(er),
                            sr.push(Yt.defines[er]);
                    return Yt.isRawShaderMaterial === !1 && (function(er, rr) {
                        er.push(rr.precision),
                        er.push(rr.outputColorSpace),
                        er.push(rr.envMapMode),
                        er.push(rr.envMapCubeUVHeight),
                        er.push(rr.mapUv),
                        er.push(rr.alphaMapUv),
                        er.push(rr.lightMapUv),
                        er.push(rr.aoMapUv),
                        er.push(rr.bumpMapUv),
                        er.push(rr.normalMapUv),
                        er.push(rr.displacementMapUv),
                        er.push(rr.emissiveMapUv),
                        er.push(rr.metalnessMapUv),
                        er.push(rr.roughnessMapUv),
                        er.push(rr.anisotropyMapUv),
                        er.push(rr.clearcoatMapUv),
                        er.push(rr.clearcoatNormalMapUv),
                        er.push(rr.clearcoatRoughnessMapUv),
                        er.push(rr.iridescenceMapUv),
                        er.push(rr.iridescenceThicknessMapUv),
                        er.push(rr.sheenColorMapUv),
                        er.push(rr.sheenRoughnessMapUv),
                        er.push(rr.specularMapUv),
                        er.push(rr.specularColorMapUv),
                        er.push(rr.specularIntensityMapUv),
                        er.push(rr.transmissionMapUv),
                        er.push(rr.thicknessMapUv),
                        er.push(rr.combine),
                        er.push(rr.fogExp2),
                        er.push(rr.sizeAttenuation),
                        er.push(rr.morphTargetsCount),
                        er.push(rr.morphAttributeCount),
                        er.push(rr.numDirLights),
                        er.push(rr.numPointLights),
                        er.push(rr.numSpotLights),
                        er.push(rr.numSpotLightMaps),
                        er.push(rr.numHemiLights),
                        er.push(rr.numRectAreaLights),
                        er.push(rr.numDirLightShadows),
                        er.push(rr.numPointLightShadows),
                        er.push(rr.numSpotLightShadows),
                        er.push(rr.numSpotLightShadowsWithMaps),
                        er.push(rr.numLightProbes),
                        er.push(rr.shadowMapType),
                        er.push(rr.toneMapping),
                        er.push(rr.numClippingPlanes),
                        er.push(rr.numClipIntersection),
                        er.push(rr.depthPacking)
                    }(sr, Yt),
                    function(er, rr) {
                        Mt.disableAll(),
                        rr.isWebGL2 && Mt.enable(0),
                        rr.supportsVertexTextures && Mt.enable(1),
                        rr.instancing && Mt.enable(2),
                        rr.instancingColor && Mt.enable(3),
                        rr.matcap && Mt.enable(4),
                        rr.envMap && Mt.enable(5),
                        rr.normalMapObjectSpace && Mt.enable(6),
                        rr.normalMapTangentSpace && Mt.enable(7),
                        rr.clearcoat && Mt.enable(8),
                        rr.iridescence && Mt.enable(9),
                        rr.alphaTest && Mt.enable(10),
                        rr.vertexColors && Mt.enable(11),
                        rr.vertexAlphas && Mt.enable(12),
                        rr.vertexUv1s && Mt.enable(13),
                        rr.vertexUv2s && Mt.enable(14),
                        rr.vertexUv3s && Mt.enable(15),
                        rr.vertexTangents && Mt.enable(16),
                        rr.anisotropy && Mt.enable(17),
                        er.push(Mt.mask),
                        Mt.disableAll(),
                        rr.fog && Mt.enable(0),
                        rr.useFog && Mt.enable(1),
                        rr.flatShading && Mt.enable(2),
                        rr.logarithmicDepthBuffer && Mt.enable(3),
                        rr.skinning && Mt.enable(4),
                        rr.morphTargets && Mt.enable(5),
                        rr.morphNormals && Mt.enable(6),
                        rr.morphColors && Mt.enable(7),
                        rr.premultipliedAlpha && Mt.enable(8),
                        rr.shadowMapEnabled && Mt.enable(9),
                        rr.useLegacyLights && Mt.enable(10),
                        rr.doubleSided && Mt.enable(11),
                        rr.flipSided && Mt.enable(12),
                        rr.useDepthPacking && Mt.enable(13),
                        rr.dithering && Mt.enable(14),
                        rr.transmission && Mt.enable(15),
                        rr.sheen && Mt.enable(16),
                        rr.opaque && Mt.enable(17),
                        rr.pointsUvs && Mt.enable(18),
                        rr.decodeVideoTexture && Mt.enable(19),
                        er.push(Mt.mask)
                    }(sr, Yt),
                    sr.push(Tt.outputColorSpace)),
                    sr.push(Yt.customProgramCacheKey),
                    sr.join()
                },
                getUniforms: function(Yt) {
                    const sr = Xt[Yt.type];
                    let er;
                    if (sr) {
                        const rr = qs[sr];
                        er = Vy.clone(rr.uniforms)
                    } else
                        er = Yt.uniforms;
                    return er
                },
                acquireProgram: function(Yt, sr) {
                    let er;
                    for (let rr = 0, xr = Nt.length; rr < xr; rr++) {
                        const br = Nt[rr];
                        if (br.cacheKey === sr) {
                            er = br,
                            ++er.usedTimes;
                            break
                        }
                    }
                    return er === void 0 && (er = new F1(Tt,sr,Yt,xt),
                    Nt.push(er)),
                    er
                },
                releaseProgram: function(Yt) {
                    if (--Yt.usedTimes == 0) {
                        const sr = Nt.indexOf(Yt);
                        Nt[sr] = Nt[Nt.length - 1],
                        Nt.pop(),
                        Yt.destroy()
                    }
                },
                releaseShaderCache: function(Yt) {
                    Lt.remove(Yt)
                },
                programs: Nt,
                dispose: function() {
                    Lt.dispose()
                }
            }
        }
        function z1() {
            let Tt = new WeakMap;
            return {
                get: function(tt) {
                    let lt = Tt.get(tt);
                    return lt === void 0 && (lt = {},
                    Tt.set(tt, lt)),
                    lt
                },
                remove: function(tt) {
                    Tt.delete(tt)
                },
                update: function(tt, lt, mt) {
                    Tt.get(tt)[lt] = mt
                },
                dispose: function() {
                    Tt = new WeakMap
                }
            }
        }
        function H1(Tt, tt) {
            return Tt.groupOrder !== tt.groupOrder ? Tt.groupOrder - tt.groupOrder : Tt.renderOrder !== tt.renderOrder ? Tt.renderOrder - tt.renderOrder : Tt.material.id !== tt.material.id ? Tt.material.id - tt.material.id : Tt.z !== tt.z ? Tt.z - tt.z : Tt.id - tt.id
        }
        function mx(Tt, tt) {
            return Tt.groupOrder !== tt.groupOrder ? Tt.groupOrder - tt.groupOrder : Tt.renderOrder !== tt.renderOrder ? Tt.renderOrder - tt.renderOrder : Tt.z !== tt.z ? tt.z - Tt.z : Tt.id - tt.id
        }
        function fx() {
            const Tt = [];
            let tt = 0;
            const lt = []
              , mt = []
              , ft = [];
            function xt(Ct, Mt, Lt, Nt, jt, Wt) {
                let Qt = Tt[tt];
                return Qt === void 0 ? (Qt = {
                    id: Ct.id,
                    object: Ct,
                    geometry: Mt,
                    material: Lt,
                    groupOrder: Nt,
                    renderOrder: Ct.renderOrder,
                    z: jt,
                    group: Wt
                },
                Tt[tt] = Qt) : (Qt.id = Ct.id,
                Qt.object = Ct,
                Qt.geometry = Mt,
                Qt.material = Lt,
                Qt.groupOrder = Nt,
                Qt.renderOrder = Ct.renderOrder,
                Qt.z = jt,
                Qt.group = Wt),
                tt++,
                Qt
            }
            return {
                opaque: lt,
                transmissive: mt,
                transparent: ft,
                init: function() {
                    tt = 0,
                    lt.length = 0,
                    mt.length = 0,
                    ft.length = 0
                },
                push: function(Ct, Mt, Lt, Nt, jt, Wt) {
                    const Qt = xt(Ct, Mt, Lt, Nt, jt, Wt);
                    Lt.transmission > 0 ? mt.push(Qt) : Lt.transparent === !0 ? ft.push(Qt) : lt.push(Qt)
                },
                unshift: function(Ct, Mt, Lt, Nt, jt, Wt) {
                    const Qt = xt(Ct, Mt, Lt, Nt, jt, Wt);
                    Lt.transmission > 0 ? mt.unshift(Qt) : Lt.transparent === !0 ? ft.unshift(Qt) : lt.unshift(Qt)
                },
                finish: function() {
                    for (let Ct = tt, Mt = Tt.length; Ct < Mt; Ct++) {
                        const Lt = Tt[Ct];
                        if (Lt.id === null)
                            break;
                        Lt.id = null,
                        Lt.object = null,
                        Lt.geometry = null,
                        Lt.material = null,
                        Lt.group = null
                    }
                },
                sort: function(Ct, Mt) {
                    lt.length > 1 && lt.sort(Ct || H1),
                    mt.length > 1 && mt.sort(Mt || mx),
                    ft.length > 1 && ft.sort(Mt || mx)
                }
            }
        }
        function Q1() {
            let Tt = new WeakMap;
            return {
                get: function(tt, lt) {
                    const mt = Tt.get(tt);
                    let ft;
                    return mt === void 0 ? (ft = new fx,
                    Tt.set(tt, [ft])) : lt >= mt.length ? (ft = new fx,
                    mt.push(ft)) : ft = mt[lt],
                    ft
                },
                dispose: function() {
                    Tt = new WeakMap
                }
            }
        }
        function W1() {
            const Tt = {};
            return {
                get: function(tt) {
                    if (Tt[tt.id] !== void 0)
                        return Tt[tt.id];
                    let lt;
                    switch (tt.type) {
                    case "DirectionalLight":
                        lt = {
                            direction: new Er,
                            color: new Gn
                        };
                        break;
                    case "SpotLight":
                        lt = {
                            position: new Er,
                            direction: new Er,
                            color: new Gn,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0
                        };
                        break;
                    case "PointLight":
                        lt = {
                            position: new Er,
                            color: new Gn,
                            distance: 0,
                            decay: 0
                        };
                        break;
                    case "HemisphereLight":
                        lt = {
                            direction: new Er,
                            skyColor: new Gn,
                            groundColor: new Gn
                        };
                        break;
                    case "RectAreaLight":
                        lt = {
                            color: new Gn,
                            position: new Er,
                            halfWidth: new Er,
                            halfHeight: new Er
                        }
                    }
                    return Tt[tt.id] = lt,
                    lt
                }
            }
        }
        let q1 = 0;
        function $1(Tt, tt) {
            return (tt.castShadow ? 2 : 0) - (Tt.castShadow ? 2 : 0) + (tt.map ? 1 : 0) - (Tt.map ? 1 : 0)
        }
        function X1(Tt, tt) {
            const lt = new W1
              , mt = function() {
                const Lt = {};
                return {
                    get: function(Nt) {
                        if (Lt[Nt.id] !== void 0)
                            return Lt[Nt.id];
                        let jt;
                        switch (Nt.type) {
                        case "DirectionalLight":
                        case "SpotLight":
                            jt = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new mn
                            };
                            break;
                        case "PointLight":
                            jt = {
                                shadowBias: 0,
                                shadowNormalBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new mn,
                                shadowCameraNear: 1,
                                shadowCameraFar: 1e3
                            }
                        }
                        return Lt[Nt.id] = jt,
                        jt
                    }
                }
            }()
              , ft = {
                version: 0,
                hash: {
                    directionalLength: -1,
                    pointLength: -1,
                    spotLength: -1,
                    rectAreaLength: -1,
                    hemiLength: -1,
                    numDirectionalShadows: -1,
                    numPointShadows: -1,
                    numSpotShadows: -1,
                    numSpotMaps: -1,
                    numLightProbes: -1
                },
                ambient: [0, 0, 0],
                probe: [],
                directional: [],
                directionalShadow: [],
                directionalShadowMap: [],
                directionalShadowMatrix: [],
                spot: [],
                spotLightMap: [],
                spotShadow: [],
                spotShadowMap: [],
                spotLightMatrix: [],
                rectArea: [],
                rectAreaLTC1: null,
                rectAreaLTC2: null,
                point: [],
                pointShadow: [],
                pointShadowMap: [],
                pointShadowMatrix: [],
                hemi: [],
                numSpotLightShadowsWithMaps: 0,
                numLightProbes: 0
            };
            for (let Lt = 0; Lt < 9; Lt++)
                ft.probe.push(new Er);
            const xt = new Er
              , Ct = new no
              , Mt = new no;
            return {
                setup: function(Lt, Nt) {
                    let jt = 0
                      , Wt = 0
                      , Qt = 0;
                    for (let Vr = 0; Vr < 9; Vr++)
                        ft.probe[Vr].set(0, 0, 0);
                    let qt = 0
                      , Xt = 0
                      , Zt = 0
                      , Yt = 0
                      , sr = 0
                      , er = 0
                      , rr = 0
                      , xr = 0
                      , br = 0
                      , yr = 0
                      , Pr = 0;
                    Lt.sort($1);
                    const zr = Nt === !0 ? Math.PI : 1;
                    for (let Vr = 0, Gr = Lt.length; Vr < Gr; Vr++) {
                        const Hr = Lt[Vr]
                          , _n = Hr.color
                          , dn = Hr.intensity
                          , kn = Hr.distance
                          , Bn = Hr.shadow && Hr.shadow.map ? Hr.shadow.map.texture : null;
                        if (Hr.isAmbientLight)
                            jt += _n.r * dn * zr,
                            Wt += _n.g * dn * zr,
                            Qt += _n.b * dn * zr;
                        else if (Hr.isLightProbe) {
                            for (let cn = 0; cn < 9; cn++)
                                ft.probe[cn].addScaledVector(Hr.sh.coefficients[cn], dn);
                            Pr++
                        } else if (Hr.isDirectionalLight) {
                            const cn = lt.get(Hr);
                            if (cn.color.copy(Hr.color).multiplyScalar(Hr.intensity * zr),
                            Hr.castShadow) {
                                const Yr = Hr.shadow
                                  , Jr = mt.get(Hr);
                                Jr.shadowBias = Yr.bias,
                                Jr.shadowNormalBias = Yr.normalBias,
                                Jr.shadowRadius = Yr.radius,
                                Jr.shadowMapSize = Yr.mapSize,
                                ft.directionalShadow[qt] = Jr,
                                ft.directionalShadowMap[qt] = Bn,
                                ft.directionalShadowMatrix[qt] = Hr.shadow.matrix,
                                er++
                            }
                            ft.directional[qt] = cn,
                            qt++
                        } else if (Hr.isSpotLight) {
                            const cn = lt.get(Hr);
                            cn.position.setFromMatrixPosition(Hr.matrixWorld),
                            cn.color.copy(_n).multiplyScalar(dn * zr),
                            cn.distance = kn,
                            cn.coneCos = Math.cos(Hr.angle),
                            cn.penumbraCos = Math.cos(Hr.angle * (1 - Hr.penumbra)),
                            cn.decay = Hr.decay,
                            ft.spot[Zt] = cn;
                            const Yr = Hr.shadow;
                            if (Hr.map && (ft.spotLightMap[br] = Hr.map,
                            br++,
                            Yr.updateMatrices(Hr),
                            Hr.castShadow && yr++),
                            ft.spotLightMatrix[Zt] = Yr.matrix,
                            Hr.castShadow) {
                                const Jr = mt.get(Hr);
                                Jr.shadowBias = Yr.bias,
                                Jr.shadowNormalBias = Yr.normalBias,
                                Jr.shadowRadius = Yr.radius,
                                Jr.shadowMapSize = Yr.mapSize,
                                ft.spotShadow[Zt] = Jr,
                                ft.spotShadowMap[Zt] = Bn,
                                xr++
                            }
                            Zt++
                        } else if (Hr.isRectAreaLight) {
                            const cn = lt.get(Hr);
                            cn.color.copy(_n).multiplyScalar(dn),
                            cn.halfWidth.set(.5 * Hr.width, 0, 0),
                            cn.halfHeight.set(0, .5 * Hr.height, 0),
                            ft.rectArea[Yt] = cn,
                            Yt++
                        } else if (Hr.isPointLight) {
                            const cn = lt.get(Hr);
                            if (cn.color.copy(Hr.color).multiplyScalar(Hr.intensity * zr),
                            cn.distance = Hr.distance,
                            cn.decay = Hr.decay,
                            Hr.castShadow) {
                                const Yr = Hr.shadow
                                  , Jr = mt.get(Hr);
                                Jr.shadowBias = Yr.bias,
                                Jr.shadowNormalBias = Yr.normalBias,
                                Jr.shadowRadius = Yr.radius,
                                Jr.shadowMapSize = Yr.mapSize,
                                Jr.shadowCameraNear = Yr.camera.near,
                                Jr.shadowCameraFar = Yr.camera.far,
                                ft.pointShadow[Xt] = Jr,
                                ft.pointShadowMap[Xt] = Bn,
                                ft.pointShadowMatrix[Xt] = Hr.shadow.matrix,
                                rr++
                            }
                            ft.point[Xt] = cn,
                            Xt++
                        } else if (Hr.isHemisphereLight) {
                            const cn = lt.get(Hr);
                            cn.skyColor.copy(Hr.color).multiplyScalar(dn * zr),
                            cn.groundColor.copy(Hr.groundColor).multiplyScalar(dn * zr),
                            ft.hemi[sr] = cn,
                            sr++
                        }
                    }
                    Yt > 0 && (tt.isWebGL2 || Tt.has("OES_texture_float_linear") === !0 ? (ft.rectAreaLTC1 = Dn.LTC_FLOAT_1,
                    ft.rectAreaLTC2 = Dn.LTC_FLOAT_2) : Tt.has("OES_texture_half_float_linear") === !0 ? (ft.rectAreaLTC1 = Dn.LTC_HALF_1,
                    ft.rectAreaLTC2 = Dn.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                    ft.ambient[0] = jt,
                    ft.ambient[1] = Wt,
                    ft.ambient[2] = Qt;
                    const Nr = ft.hash;
                    Nr.directionalLength === qt && Nr.pointLength === Xt && Nr.spotLength === Zt && Nr.rectAreaLength === Yt && Nr.hemiLength === sr && Nr.numDirectionalShadows === er && Nr.numPointShadows === rr && Nr.numSpotShadows === xr && Nr.numSpotMaps === br && Nr.numLightProbes === Pr || (ft.directional.length = qt,
                    ft.spot.length = Zt,
                    ft.rectArea.length = Yt,
                    ft.point.length = Xt,
                    ft.hemi.length = sr,
                    ft.directionalShadow.length = er,
                    ft.directionalShadowMap.length = er,
                    ft.pointShadow.length = rr,
                    ft.pointShadowMap.length = rr,
                    ft.spotShadow.length = xr,
                    ft.spotShadowMap.length = xr,
                    ft.directionalShadowMatrix.length = er,
                    ft.pointShadowMatrix.length = rr,
                    ft.spotLightMatrix.length = xr + br - yr,
                    ft.spotLightMap.length = br,
                    ft.numSpotLightShadowsWithMaps = yr,
                    ft.numLightProbes = Pr,
                    Nr.directionalLength = qt,
                    Nr.pointLength = Xt,
                    Nr.spotLength = Zt,
                    Nr.rectAreaLength = Yt,
                    Nr.hemiLength = sr,
                    Nr.numDirectionalShadows = er,
                    Nr.numPointShadows = rr,
                    Nr.numSpotShadows = xr,
                    Nr.numSpotMaps = br,
                    Nr.numLightProbes = Pr,
                    ft.version = q1++)
                },
                setupView: function(Lt, Nt) {
                    let jt = 0
                      , Wt = 0
                      , Qt = 0
                      , qt = 0
                      , Xt = 0;
                    const Zt = Nt.matrixWorldInverse;
                    for (let Yt = 0, sr = Lt.length; Yt < sr; Yt++) {
                        const er = Lt[Yt];
                        if (er.isDirectionalLight) {
                            const rr = ft.directional[jt];
                            rr.direction.setFromMatrixPosition(er.matrixWorld),
                            xt.setFromMatrixPosition(er.target.matrixWorld),
                            rr.direction.sub(xt),
                            rr.direction.transformDirection(Zt),
                            jt++
                        } else if (er.isSpotLight) {
                            const rr = ft.spot[Qt];
                            rr.position.setFromMatrixPosition(er.matrixWorld),
                            rr.position.applyMatrix4(Zt),
                            rr.direction.setFromMatrixPosition(er.matrixWorld),
                            xt.setFromMatrixPosition(er.target.matrixWorld),
                            rr.direction.sub(xt),
                            rr.direction.transformDirection(Zt),
                            Qt++
                        } else if (er.isRectAreaLight) {
                            const rr = ft.rectArea[qt];
                            rr.position.setFromMatrixPosition(er.matrixWorld),
                            rr.position.applyMatrix4(Zt),
                            Mt.identity(),
                            Ct.copy(er.matrixWorld),
                            Ct.premultiply(Zt),
                            Mt.extractRotation(Ct),
                            rr.halfWidth.set(.5 * er.width, 0, 0),
                            rr.halfHeight.set(0, .5 * er.height, 0),
                            rr.halfWidth.applyMatrix4(Mt),
                            rr.halfHeight.applyMatrix4(Mt),
                            qt++
                        } else if (er.isPointLight) {
                            const rr = ft.point[Wt];
                            rr.position.setFromMatrixPosition(er.matrixWorld),
                            rr.position.applyMatrix4(Zt),
                            Wt++
                        } else if (er.isHemisphereLight) {
                            const rr = ft.hemi[Xt];
                            rr.direction.setFromMatrixPosition(er.matrixWorld),
                            rr.direction.transformDirection(Zt),
                            Xt++
                        }
                    }
                },
                state: ft
            }
        }
        function gx(Tt, tt) {
            const lt = new X1(Tt,tt)
              , mt = []
              , ft = [];
            return {
                init: function() {
                    mt.length = 0,
                    ft.length = 0
                },
                state: {
                    lightsArray: mt,
                    shadowsArray: ft,
                    lights: lt
                },
                setupLights: function(xt) {
                    lt.setup(mt, xt)
                },
                setupLightsView: function(xt) {
                    lt.setupView(mt, xt)
                },
                pushLight: function(xt) {
                    mt.push(xt)
                },
                pushShadow: function(xt) {
                    ft.push(xt)
                }
            }
        }
        function Y1(Tt, tt) {
            let lt = new WeakMap;
            return {
                get: function(mt, ft=0) {
                    const xt = lt.get(mt);
                    let Ct;
                    return xt === void 0 ? (Ct = new gx(Tt,tt),
                    lt.set(mt, [Ct])) : ft >= xt.length ? (Ct = new gx(Tt,tt),
                    xt.push(Ct)) : Ct = xt[ft],
                    Ct
                },
                dispose: function() {
                    lt = new WeakMap
                }
            }
        }
        class H0 extends hs {
            constructor(tt) {
                super(),
                this.isMeshDepthMaterial = !0,
                this.type = "MeshDepthMaterial",
                this.depthPacking = up,
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.depthPacking = tt.depthPacking,
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this
            }
        }
        class Q0 extends hs {
            constructor(tt) {
                super(),
                this.isMeshDistanceMaterial = !0,
                this.type = "MeshDistanceMaterial",
                this.map = null,
                this.alphaMap = null,
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this
            }
        }
        function K1(Tt, tt, lt) {
            let mt = new Av;
            const ft = new mn
              , xt = new mn
              , Ct = new Lo
              , Mt = new H0({
                depthPacking: Qm
            })
              , Lt = new Q0
              , Nt = {}
              , jt = lt.maxTextureSize
              , Wt = {
                [vt]: bt,
                [bt]: vt,
                [St]: St
            }
              , Qt = new zl({
                defines: {
                    VSM_SAMPLES: 8
                },
                uniforms: {
                    shadow_pass: {
                        value: null
                    },
                    resolution: {
                        value: new mn
                    },
                    radius: {
                        value: 4
                    }
                },
                vertexShader: `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
                fragmentShader: `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
            })
              , qt = Qt.clone();
            qt.defines.HORIZONTAL_PASS = 1;
            const Xt = new bo;
            Xt.setAttribute("position", new mr(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
            const Zt = new gs(Xt,Qt)
              , Yt = this;
            this.enabled = !1,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this.type = pt;
            let sr = this.type;
            function er(br, yr) {
                const Pr = tt.update(Zt);
                Qt.defines.VSM_SAMPLES !== br.blurSamples && (Qt.defines.VSM_SAMPLES = br.blurSamples,
                qt.defines.VSM_SAMPLES = br.blurSamples,
                Qt.needsUpdate = !0,
                qt.needsUpdate = !0),
                br.mapPass === null && (br.mapPass = new Rs(ft.x,ft.y)),
                Qt.uniforms.shadow_pass.value = br.map.texture,
                Qt.uniforms.resolution.value = br.mapSize,
                Qt.uniforms.radius.value = br.radius,
                Tt.setRenderTarget(br.mapPass),
                Tt.clear(),
                Tt.renderBufferDirect(yr, null, Pr, Qt, Zt, null),
                qt.uniforms.shadow_pass.value = br.mapPass.texture,
                qt.uniforms.resolution.value = br.mapSize,
                qt.uniforms.radius.value = br.radius,
                Tt.setRenderTarget(br.map),
                Tt.clear(),
                Tt.renderBufferDirect(yr, null, Pr, qt, Zt, null)
            }
            function rr(br, yr, Pr, zr) {
                let Nr = null;
                const Vr = Pr.isPointLight === !0 ? br.customDistanceMaterial : br.customDepthMaterial;
                if (Vr !== void 0)
                    Nr = Vr;
                else if (Nr = Pr.isPointLight === !0 ? Lt : Mt,
                Tt.localClippingEnabled && yr.clipShadows === !0 && Array.isArray(yr.clippingPlanes) && yr.clippingPlanes.length !== 0 || yr.displacementMap && yr.displacementScale !== 0 || yr.alphaMap && yr.alphaTest > 0 || yr.map && yr.alphaTest > 0) {
                    const Gr = Nr.uuid
                      , Hr = yr.uuid;
                    let _n = Nt[Gr];
                    _n === void 0 && (_n = {},
                    Nt[Gr] = _n);
                    let dn = _n[Hr];
                    dn === void 0 && (dn = Nr.clone(),
                    _n[Hr] = dn),
                    Nr = dn
                }
                return Nr.visible = yr.visible,
                Nr.wireframe = yr.wireframe,
                Nr.side = zr === _t ? yr.shadowSide !== null ? yr.shadowSide : yr.side : yr.shadowSide !== null ? yr.shadowSide : Wt[yr.side],
                Nr.alphaMap = yr.alphaMap,
                Nr.alphaTest = yr.alphaTest,
                Nr.map = yr.map,
                Nr.clipShadows = yr.clipShadows,
                Nr.clippingPlanes = yr.clippingPlanes,
                Nr.clipIntersection = yr.clipIntersection,
                Nr.displacementMap = yr.displacementMap,
                Nr.displacementScale = yr.displacementScale,
                Nr.displacementBias = yr.displacementBias,
                Nr.wireframeLinewidth = yr.wireframeLinewidth,
                Nr.linewidth = yr.linewidth,
                Pr.isPointLight === !0 && Nr.isMeshDistanceMaterial === !0 && (Tt.properties.get(Nr).light = Pr),
                Nr
            }
            function xr(br, yr, Pr, zr, Nr) {
                if (br.visible === !1)
                    return;
                if (br.layers.test(yr.layers) && (br.isMesh || br.isLine || br.isPoints) && (br.castShadow || br.receiveShadow && Nr === _t) && (!br.frustumCulled || mt.intersectsObject(br))) {
                    br.modelViewMatrix.multiplyMatrices(Pr.matrixWorldInverse, br.matrixWorld);
                    const Gr = tt.update(br)
                      , Hr = br.material;
                    if (Array.isArray(Hr)) {
                        const _n = Gr.groups;
                        for (let dn = 0, kn = _n.length; dn < kn; dn++) {
                            const Bn = _n[dn]
                              , cn = Hr[Bn.materialIndex];
                            if (cn && cn.visible) {
                                const Yr = rr(br, cn, zr, Nr);
                                Tt.renderBufferDirect(Pr, null, Gr, Yr, br, Bn)
                            }
                        }
                    } else if (Hr.visible) {
                        const _n = rr(br, Hr, zr, Nr);
                        Tt.renderBufferDirect(Pr, null, Gr, _n, br, null)
                    }
                }
                const Vr = br.children;
                for (let Gr = 0, Hr = Vr.length; Gr < Hr; Gr++)
                    xr(Vr[Gr], yr, Pr, zr, Nr)
            }
            this.render = function(br, yr, Pr) {
                if (Yt.enabled === !1 || Yt.autoUpdate === !1 && Yt.needsUpdate === !1 || br.length === 0)
                    return;
                const zr = Tt.getRenderTarget()
                  , Nr = Tt.getActiveCubeFace()
                  , Vr = Tt.getActiveMipmapLevel()
                  , Gr = Tt.state;
                Gr.setBlending(Et),
                Gr.buffers.color.setClear(1, 1, 1, 1),
                Gr.buffers.depth.setTest(!0),
                Gr.setScissorTest(!1);
                const Hr = sr !== _t && this.type === _t
                  , _n = sr === _t && this.type !== _t;
                for (let dn = 0, kn = br.length; dn < kn; dn++) {
                    const Bn = br[dn]
                      , cn = Bn.shadow;
                    if (cn === void 0) {
                        console.warn("THREE.WebGLShadowMap:", Bn, "has no shadow.");
                        continue
                    }
                    if (cn.autoUpdate === !1 && cn.needsUpdate === !1)
                        continue;
                    ft.copy(cn.mapSize);
                    const Yr = cn.getFrameExtents();
                    if (ft.multiply(Yr),
                    xt.copy(cn.mapSize),
                    (ft.x > jt || ft.y > jt) && (ft.x > jt && (xt.x = Math.floor(jt / Yr.x),
                    ft.x = xt.x * Yr.x,
                    cn.mapSize.x = xt.x),
                    ft.y > jt && (xt.y = Math.floor(jt / Yr.y),
                    ft.y = xt.y * Yr.y,
                    cn.mapSize.y = xt.y)),
                    cn.map === null || Hr === !0 || _n === !0) {
                        const sn = this.type !== _t ? {
                            minFilter: fn,
                            magFilter: fn
                        } : {};
                        cn.map !== null && cn.map.dispose(),
                        cn.map = new Rs(ft.x,ft.y,sn),
                        cn.map.texture.name = Bn.name + ".shadowMap",
                        cn.camera.updateProjectionMatrix()
                    }
                    Tt.setRenderTarget(cn.map),
                    Tt.clear();
                    const Jr = cn.getViewportCount();
                    for (let sn = 0; sn < Jr; sn++) {
                        const on = cn.getViewport(sn);
                        Ct.set(xt.x * on.x, xt.y * on.y, xt.x * on.z, xt.y * on.w),
                        Gr.viewport(Ct),
                        cn.updateMatrices(Bn, sn),
                        mt = cn.getFrustum(),
                        xr(yr, Pr, cn.camera, Bn, this.type)
                    }
                    cn.isPointLightShadow !== !0 && this.type === _t && er(cn, Pr),
                    cn.needsUpdate = !1
                }
                sr = this.type,
                Yt.needsUpdate = !1,
                Tt.setRenderTarget(zr, Nr, Vr)
            }
        }
        function J1(Tt, tt, lt) {
            const mt = lt.isWebGL2
              , ft = new function() {
                let _r = !1;
                const Br = new Lo;
                let Lr = null;
                const Xr = new Lo(0,0,0,0);
                return {
                    setMask: function(Kr) {
                        Lr === Kr || _r || (Tt.colorMask(Kr, Kr, Kr, Kr),
                        Lr = Kr)
                    },
                    setLocked: function(Kr) {
                        _r = Kr
                    },
                    setClear: function(Kr, An, pn, _o, to) {
                        to === !0 && (Kr *= _o,
                        An *= _o,
                        pn *= _o),
                        Br.set(Kr, An, pn, _o),
                        Xr.equals(Br) === !1 && (Tt.clearColor(Kr, An, pn, _o),
                        Xr.copy(Br))
                    },
                    reset: function() {
                        _r = !1,
                        Lr = null,
                        Xr.set(-1, 0, 0, 0)
                    }
                }
            }
              , xt = new function() {
                let _r = !1
                  , Br = null
                  , Lr = null
                  , Xr = null;
                return {
                    setTest: function(Kr) {
                        Kr ? Zn(Tt.DEPTH_TEST) : jn(Tt.DEPTH_TEST)
                    },
                    setMask: function(Kr) {
                        Br === Kr || _r || (Tt.depthMask(Kr),
                        Br = Kr)
                    },
                    setFunc: function(Kr) {
                        if (Lr !== Kr) {
                            switch (Kr) {
                            case Cr:
                                Tt.depthFunc(Tt.NEVER);
                                break;
                            case tr:
                                Tt.depthFunc(Tt.ALWAYS);
                                break;
                            case fr:
                                Tt.depthFunc(Tt.LESS);
                                break;
                            case vr:
                                Tt.depthFunc(Tt.LEQUAL);
                                break;
                            case Zr:
                                Tt.depthFunc(Tt.EQUAL);
                                break;
                            case rn:
                                Tt.depthFunc(Tt.GEQUAL);
                                break;
                            case hn:
                                Tt.depthFunc(Tt.GREATER);
                                break;
                            case Nn:
                                Tt.depthFunc(Tt.NOTEQUAL);
                                break;
                            default:
                                Tt.depthFunc(Tt.LEQUAL)
                            }
                            Lr = Kr
                        }
                    },
                    setLocked: function(Kr) {
                        _r = Kr
                    },
                    setClear: function(Kr) {
                        Xr !== Kr && (Tt.clearDepth(Kr),
                        Xr = Kr)
                    },
                    reset: function() {
                        _r = !1,
                        Br = null,
                        Lr = null,
                        Xr = null
                    }
                }
            }
              , Ct = new function() {
                let _r = !1
                  , Br = null
                  , Lr = null
                  , Xr = null
                  , Kr = null
                  , An = null
                  , pn = null
                  , _o = null
                  , to = null;
                return {
                    setTest: function(Pn) {
                        _r || (Pn ? Zn(Tt.STENCIL_TEST) : jn(Tt.STENCIL_TEST))
                    },
                    setMask: function(Pn) {
                        Br === Pn || _r || (Tt.stencilMask(Pn),
                        Br = Pn)
                    },
                    setFunc: function(Pn, eo, Kn) {
                        Lr === Pn && Xr === eo && Kr === Kn || (Tt.stencilFunc(Pn, eo, Kn),
                        Lr = Pn,
                        Xr = eo,
                        Kr = Kn)
                    },
                    setOp: function(Pn, eo, Kn) {
                        An === Pn && pn === eo && _o === Kn || (Tt.stencilOp(Pn, eo, Kn),
                        An = Pn,
                        pn = eo,
                        _o = Kn)
                    },
                    setLocked: function(Pn) {
                        _r = Pn
                    },
                    setClear: function(Pn) {
                        to !== Pn && (Tt.clearStencil(Pn),
                        to = Pn)
                    },
                    reset: function() {
                        _r = !1,
                        Br = null,
                        Lr = null,
                        Xr = null,
                        Kr = null,
                        An = null,
                        pn = null,
                        _o = null,
                        to = null
                    }
                }
            }
              , Mt = new WeakMap
              , Lt = new WeakMap;
            let Nt = {}
              , jt = {}
              , Wt = new WeakMap
              , Qt = []
              , qt = null
              , Xt = !1
              , Zt = null
              , Yt = null
              , sr = null
              , er = null
              , rr = null
              , xr = null
              , br = null
              , yr = !1
              , Pr = null
              , zr = null
              , Nr = null
              , Vr = null
              , Gr = null;
            const Hr = Tt.getParameter(Tt.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let _n = !1
              , dn = 0;
            const kn = Tt.getParameter(Tt.VERSION);
            kn.indexOf("WebGL") !== -1 ? (dn = parseFloat(/^WebGL (\d)/.exec(kn)[1]),
            _n = dn >= 1) : kn.indexOf("OpenGL ES") !== -1 && (dn = parseFloat(/^OpenGL ES (\d)/.exec(kn)[1]),
            _n = dn >= 2);
            let Bn = null
              , cn = {};
            const Yr = Tt.getParameter(Tt.SCISSOR_BOX)
              , Jr = Tt.getParameter(Tt.VIEWPORT)
              , sn = new Lo().fromArray(Yr)
              , on = new Lo().fromArray(Jr);
            function Un(_r, Br, Lr, Xr) {
                const Kr = new Uint8Array(4)
                  , An = Tt.createTexture();
                Tt.bindTexture(_r, An),
                Tt.texParameteri(_r, Tt.TEXTURE_MIN_FILTER, Tt.NEAREST),
                Tt.texParameteri(_r, Tt.TEXTURE_MAG_FILTER, Tt.NEAREST);
                for (let pn = 0; pn < Lr; pn++)
                    !mt || _r !== Tt.TEXTURE_3D && _r !== Tt.TEXTURE_2D_ARRAY ? Tt.texImage2D(Br + pn, 0, Tt.RGBA, 1, 1, 0, Tt.RGBA, Tt.UNSIGNED_BYTE, Kr) : Tt.texImage3D(Br, 0, Tt.RGBA, 1, 1, Xr, 0, Tt.RGBA, Tt.UNSIGNED_BYTE, Kr);
                return An
            }
            const ro = {};
            function Zn(_r) {
                Nt[_r] !== !0 && (Tt.enable(_r),
                Nt[_r] = !0)
            }
            function jn(_r) {
                Nt[_r] !== !1 && (Tt.disable(_r),
                Nt[_r] = !1)
            }
            ro[Tt.TEXTURE_2D] = Un(Tt.TEXTURE_2D, Tt.TEXTURE_2D, 1),
            ro[Tt.TEXTURE_CUBE_MAP] = Un(Tt.TEXTURE_CUBE_MAP, Tt.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
            mt && (ro[Tt.TEXTURE_2D_ARRAY] = Un(Tt.TEXTURE_2D_ARRAY, Tt.TEXTURE_2D_ARRAY, 1, 1),
            ro[Tt.TEXTURE_3D] = Un(Tt.TEXTURE_3D, Tt.TEXTURE_3D, 1, 1)),
            ft.setClear(0, 0, 0, 1),
            xt.setClear(1),
            Ct.setClear(0),
            Zn(Tt.DEPTH_TEST),
            xt.setFunc(vr),
            Fr(!1),
            Wr(nt),
            Zn(Tt.CULL_FACE),
            Sr(Et);
            const uo = {
                [kt]: Tt.FUNC_ADD,
                [Ut]: Tt.FUNC_SUBTRACT,
                [Ht]: Tt.FUNC_REVERSE_SUBTRACT
            };
            if (mt)
                uo[Kt] = Tt.MIN,
                uo[Jt] = Tt.MAX;
            else {
                const _r = tt.get("EXT_blend_minmax");
                _r !== null && (uo[Kt] = _r.MIN_EXT,
                uo[Jt] = _r.MAX_EXT)
            }
            const Dr = {
                [or]: Tt.ZERO,
                [ir]: Tt.ONE,
                [lr]: Tt.SRC_COLOR,
                [hr]: Tt.SRC_ALPHA,
                [Rr]: Tt.SRC_ALPHA_SATURATE,
                [Ar]: Tt.DST_COLOR,
                [dr]: Tt.DST_ALPHA,
                [ar]: Tt.ONE_MINUS_SRC_COLOR,
                [gr]: Tt.ONE_MINUS_SRC_ALPHA,
                [wr]: Tt.ONE_MINUS_DST_COLOR,
                [cr]: Tt.ONE_MINUS_DST_ALPHA
            };
            function Sr(_r, Br, Lr, Xr, Kr, An, pn, _o) {
                if (_r !== Et) {
                    if (Xt === !1 && (Zn(Tt.BLEND),
                    Xt = !0),
                    _r === Bt)
                        Kr = Kr || Br,
                        An = An || Lr,
                        pn = pn || Xr,
                        Br === Yt && Kr === rr || (Tt.blendEquationSeparate(uo[Br], uo[Kr]),
                        Yt = Br,
                        rr = Kr),
                        Lr === sr && Xr === er && An === xr && pn === br || (Tt.blendFuncSeparate(Dr[Lr], Dr[Xr], Dr[An], Dr[pn]),
                        sr = Lr,
                        er = Xr,
                        xr = An,
                        br = pn),
                        Zt = _r,
                        yr = !1;
                    else if (_r !== Zt || _o !== yr) {
                        if (Yt === kt && rr === kt || (Tt.blendEquation(Tt.FUNC_ADD),
                        Yt = kt,
                        rr = kt),
                        _o)
                            switch (_r) {
                            case Pt:
                                Tt.blendFuncSeparate(Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA, Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA);
                                break;
                            case It:
                                Tt.blendFunc(Tt.ONE, Tt.ONE);
                                break;
                            case Dt:
                                Tt.blendFuncSeparate(Tt.ZERO, Tt.ONE_MINUS_SRC_COLOR, Tt.ZERO, Tt.ONE);
                                break;
                            case Gt:
                                Tt.blendFuncSeparate(Tt.ZERO, Tt.SRC_COLOR, Tt.ZERO, Tt.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", _r)
                            }
                        else
                            switch (_r) {
                            case Pt:
                                Tt.blendFuncSeparate(Tt.SRC_ALPHA, Tt.ONE_MINUS_SRC_ALPHA, Tt.ONE, Tt.ONE_MINUS_SRC_ALPHA);
                                break;
                            case It:
                                Tt.blendFunc(Tt.SRC_ALPHA, Tt.ONE);
                                break;
                            case Dt:
                                Tt.blendFuncSeparate(Tt.ZERO, Tt.ONE_MINUS_SRC_COLOR, Tt.ZERO, Tt.ONE);
                                break;
                            case Gt:
                                Tt.blendFunc(Tt.ZERO, Tt.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", _r)
                            }
                        sr = null,
                        er = null,
                        xr = null,
                        br = null,
                        Zt = _r,
                        yr = _o
                    }
                } else
                    Xt === !0 && (jn(Tt.BLEND),
                    Xt = !1)
            }
            function Fr(_r) {
                Pr !== _r && (_r ? Tt.frontFace(Tt.CW) : Tt.frontFace(Tt.CCW),
                Pr = _r)
            }
            function Wr(_r) {
                _r !== _e ? (Zn(Tt.CULL_FACE),
                _r !== zr && (_r === nt ? Tt.cullFace(Tt.BACK) : _r === it ? Tt.cullFace(Tt.FRONT) : Tt.cullFace(Tt.FRONT_AND_BACK))) : jn(Tt.CULL_FACE),
                zr = _r
            }
            function kr(_r, Br, Lr) {
                _r ? (Zn(Tt.POLYGON_OFFSET_FILL),
                Vr === Br && Gr === Lr || (Tt.polygonOffset(Br, Lr),
                Vr = Br,
                Gr = Lr)) : jn(Tt.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: ft,
                    depth: xt,
                    stencil: Ct
                },
                enable: Zn,
                disable: jn,
                bindFramebuffer: function(_r, Br) {
                    return jt[_r] !== Br && (Tt.bindFramebuffer(_r, Br),
                    jt[_r] = Br,
                    mt && (_r === Tt.DRAW_FRAMEBUFFER && (jt[Tt.FRAMEBUFFER] = Br),
                    _r === Tt.FRAMEBUFFER && (jt[Tt.DRAW_FRAMEBUFFER] = Br)),
                    !0)
                },
                drawBuffers: function(_r, Br) {
                    let Lr = Qt
                      , Xr = !1;
                    if (_r)
                        if (Lr = Wt.get(Br),
                        Lr === void 0 && (Lr = [],
                        Wt.set(Br, Lr)),
                        _r.isWebGLMultipleRenderTargets) {
                            const Kr = _r.texture;
                            if (Lr.length !== Kr.length || Lr[0] !== Tt.COLOR_ATTACHMENT0) {
                                for (let An = 0, pn = Kr.length; An < pn; An++)
                                    Lr[An] = Tt.COLOR_ATTACHMENT0 + An;
                                Lr.length = Kr.length,
                                Xr = !0
                            }
                        } else
                            Lr[0] !== Tt.COLOR_ATTACHMENT0 && (Lr[0] = Tt.COLOR_ATTACHMENT0,
                            Xr = !0);
                    else
                        Lr[0] !== Tt.BACK && (Lr[0] = Tt.BACK,
                        Xr = !0);
                    Xr && (lt.isWebGL2 ? Tt.drawBuffers(Lr) : tt.get("WEBGL_draw_buffers").drawBuffersWEBGL(Lr))
                },
                useProgram: function(_r) {
                    return qt !== _r && (Tt.useProgram(_r),
                    qt = _r,
                    !0)
                },
                setBlending: Sr,
                setMaterial: function(_r, Br) {
                    _r.side === St ? jn(Tt.CULL_FACE) : Zn(Tt.CULL_FACE);
                    let Lr = _r.side === bt;
                    Br && (Lr = !Lr),
                    Fr(Lr),
                    _r.blending === Pt && _r.transparent === !1 ? Sr(Et) : Sr(_r.blending, _r.blendEquation, _r.blendSrc, _r.blendDst, _r.blendEquationAlpha, _r.blendSrcAlpha, _r.blendDstAlpha, _r.premultipliedAlpha),
                    xt.setFunc(_r.depthFunc),
                    xt.setTest(_r.depthTest),
                    xt.setMask(_r.depthWrite),
                    ft.setMask(_r.colorWrite);
                    const Xr = _r.stencilWrite;
                    Ct.setTest(Xr),
                    Xr && (Ct.setMask(_r.stencilWriteMask),
                    Ct.setFunc(_r.stencilFunc, _r.stencilRef, _r.stencilFuncMask),
                    Ct.setOp(_r.stencilFail, _r.stencilZFail, _r.stencilZPass)),
                    kr(_r.polygonOffset, _r.polygonOffsetFactor, _r.polygonOffsetUnits),
                    _r.alphaToCoverage === !0 ? Zn(Tt.SAMPLE_ALPHA_TO_COVERAGE) : jn(Tt.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: Fr,
                setCullFace: Wr,
                setLineWidth: function(_r) {
                    _r !== Nr && (_n && Tt.lineWidth(_r),
                    Nr = _r)
                },
                setPolygonOffset: kr,
                setScissorTest: function(_r) {
                    _r ? Zn(Tt.SCISSOR_TEST) : jn(Tt.SCISSOR_TEST)
                },
                activeTexture: function(_r) {
                    _r === void 0 && (_r = Tt.TEXTURE0 + Hr - 1),
                    Bn !== _r && (Tt.activeTexture(_r),
                    Bn = _r)
                },
                bindTexture: function(_r, Br, Lr) {
                    Lr === void 0 && (Lr = Bn === null ? Tt.TEXTURE0 + Hr - 1 : Bn);
                    let Xr = cn[Lr];
                    Xr === void 0 && (Xr = {
                        type: void 0,
                        texture: void 0
                    },
                    cn[Lr] = Xr),
                    Xr.type === _r && Xr.texture === Br || (Bn !== Lr && (Tt.activeTexture(Lr),
                    Bn = Lr),
                    Tt.bindTexture(_r, Br || ro[_r]),
                    Xr.type = _r,
                    Xr.texture = Br)
                },
                unbindTexture: function() {
                    const _r = cn[Bn];
                    _r !== void 0 && _r.type !== void 0 && (Tt.bindTexture(_r.type, null),
                    _r.type = void 0,
                    _r.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        Tt.compressedTexImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        Tt.compressedTexImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texImage2D: function() {
                    try {
                        Tt.texImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texImage3D: function() {
                    try {
                        Tt.texImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                updateUBOMapping: function(_r, Br) {
                    let Lr = Lt.get(Br);
                    Lr === void 0 && (Lr = new WeakMap,
                    Lt.set(Br, Lr));
                    let Xr = Lr.get(_r);
                    Xr === void 0 && (Xr = Tt.getUniformBlockIndex(Br, _r.name),
                    Lr.set(_r, Xr))
                },
                uniformBlockBinding: function(_r, Br) {
                    const Lr = Lt.get(Br).get(_r);
                    Mt.get(Br) !== Lr && (Tt.uniformBlockBinding(Br, Lr, _r.__bindingPointIndex),
                    Mt.set(Br, Lr))
                },
                texStorage2D: function() {
                    try {
                        Tt.texStorage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texStorage3D: function() {
                    try {
                        Tt.texStorage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texSubImage2D: function() {
                    try {
                        Tt.texSubImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                texSubImage3D: function() {
                    try {
                        Tt.texSubImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        Tt.compressedTexSubImage2D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        Tt.compressedTexSubImage3D.apply(Tt, arguments)
                    } catch (_r) {
                        console.error("THREE.WebGLState:", _r)
                    }
                },
                scissor: function(_r) {
                    sn.equals(_r) === !1 && (Tt.scissor(_r.x, _r.y, _r.z, _r.w),
                    sn.copy(_r))
                },
                viewport: function(_r) {
                    on.equals(_r) === !1 && (Tt.viewport(_r.x, _r.y, _r.z, _r.w),
                    on.copy(_r))
                },
                reset: function() {
                    Tt.disable(Tt.BLEND),
                    Tt.disable(Tt.CULL_FACE),
                    Tt.disable(Tt.DEPTH_TEST),
                    Tt.disable(Tt.POLYGON_OFFSET_FILL),
                    Tt.disable(Tt.SCISSOR_TEST),
                    Tt.disable(Tt.STENCIL_TEST),
                    Tt.disable(Tt.SAMPLE_ALPHA_TO_COVERAGE),
                    Tt.blendEquation(Tt.FUNC_ADD),
                    Tt.blendFunc(Tt.ONE, Tt.ZERO),
                    Tt.blendFuncSeparate(Tt.ONE, Tt.ZERO, Tt.ONE, Tt.ZERO),
                    Tt.colorMask(!0, !0, !0, !0),
                    Tt.clearColor(0, 0, 0, 0),
                    Tt.depthMask(!0),
                    Tt.depthFunc(Tt.LESS),
                    Tt.clearDepth(1),
                    Tt.stencilMask(4294967295),
                    Tt.stencilFunc(Tt.ALWAYS, 0, 4294967295),
                    Tt.stencilOp(Tt.KEEP, Tt.KEEP, Tt.KEEP),
                    Tt.clearStencil(0),
                    Tt.cullFace(Tt.BACK),
                    Tt.frontFace(Tt.CCW),
                    Tt.polygonOffset(0, 0),
                    Tt.activeTexture(Tt.TEXTURE0),
                    Tt.bindFramebuffer(Tt.FRAMEBUFFER, null),
                    mt === !0 && (Tt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, null),
                    Tt.bindFramebuffer(Tt.READ_FRAMEBUFFER, null)),
                    Tt.useProgram(null),
                    Tt.lineWidth(1),
                    Tt.scissor(0, 0, Tt.canvas.width, Tt.canvas.height),
                    Tt.viewport(0, 0, Tt.canvas.width, Tt.canvas.height),
                    Nt = {},
                    Bn = null,
                    cn = {},
                    jt = {},
                    Wt = new WeakMap,
                    Qt = [],
                    qt = null,
                    Xt = !1,
                    Zt = null,
                    Yt = null,
                    sr = null,
                    er = null,
                    rr = null,
                    xr = null,
                    br = null,
                    yr = !1,
                    Pr = null,
                    zr = null,
                    Nr = null,
                    Vr = null,
                    Gr = null,
                    sn.set(0, 0, Tt.canvas.width, Tt.canvas.height),
                    on.set(0, 0, Tt.canvas.width, Tt.canvas.height),
                    ft.reset(),
                    xt.reset(),
                    Ct.reset()
                }
            }
        }
        function Z1(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = ft.isWebGL2
              , Lt = ft.maxTextures
              , Nt = ft.maxCubemapSize
              , jt = ft.maxTextureSize
              , Wt = ft.maxSamples
              , Qt = tt.has("WEBGL_multisampled_render_to_texture") ? tt.get("WEBGL_multisampled_render_to_texture") : null
              , qt = typeof navigator < "u" && /OculusBrowser/g.test(navigator.userAgent)
              , Xt = new WeakMap;
            let Zt;
            const Yt = new WeakMap;
            let sr = !1;
            try {
                sr = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
            } catch {}
            function er(Dr, Sr) {
                return sr ? new OffscreenCanvas(Dr,Sr) : yu("canvas")
            }
            function rr(Dr, Sr, Fr, Wr) {
                let kr = 1;
                if ((Dr.width > Wr || Dr.height > Wr) && (kr = Wr / Math.max(Dr.width, Dr.height)),
                kr < 1 || Sr === !0) {
                    if (typeof HTMLImageElement < "u" && Dr instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Dr instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Dr instanceof ImageBitmap) {
                        const _r = Sr ? gp : Math.floor
                          , Br = _r(kr * Dr.width)
                          , Lr = _r(kr * Dr.height);
                        Zt === void 0 && (Zt = er(Br, Lr));
                        const Xr = Fr ? er(Br, Lr) : Zt;
                        return Xr.width = Br,
                        Xr.height = Lr,
                        Xr.getContext("2d").drawImage(Dr, 0, 0, Br, Lr),
                        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Dr.width + "x" + Dr.height + ") to (" + Br + "x" + Lr + ")."),
                        Xr
                    }
                    return "data"in Dr && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Dr.width + "x" + Dr.height + ")."),
                    Dr
                }
                return Dr
            }
            function xr(Dr) {
                return tm(Dr.width) && tm(Dr.height)
            }
            function br(Dr, Sr) {
                return Dr.generateMipmaps && Sr && Dr.minFilter !== fn && Dr.minFilter !== Rn
            }
            function yr(Dr) {
                Tt.generateMipmap(Dr)
            }
            function Pr(Dr, Sr, Fr, Wr, kr=!1) {
                if (Mt === !1)
                    return Sr;
                if (Dr !== null) {
                    if (Tt[Dr] !== void 0)
                        return Tt[Dr];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + Dr + "'")
                }
                let _r = Sr;
                if (Sr === Tt.RED && (Fr === Tt.FLOAT && (_r = Tt.R32F),
                Fr === Tt.HALF_FLOAT && (_r = Tt.R16F),
                Fr === Tt.UNSIGNED_BYTE && (_r = Tt.R8)),
                Sr === Tt.RED_INTEGER && (Fr === Tt.UNSIGNED_BYTE && (_r = Tt.R8UI),
                Fr === Tt.UNSIGNED_SHORT && (_r = Tt.R16UI),
                Fr === Tt.UNSIGNED_INT && (_r = Tt.R32UI),
                Fr === Tt.BYTE && (_r = Tt.R8I),
                Fr === Tt.SHORT && (_r = Tt.R16I),
                Fr === Tt.INT && (_r = Tt.R32I)),
                Sr === Tt.RG && (Fr === Tt.FLOAT && (_r = Tt.RG32F),
                Fr === Tt.HALF_FLOAT && (_r = Tt.RG16F),
                Fr === Tt.UNSIGNED_BYTE && (_r = Tt.RG8)),
                Sr === Tt.RGBA) {
                    const Br = kr ? No : Do.getTransfer(Wr);
                    Fr === Tt.FLOAT && (_r = Tt.RGBA32F),
                    Fr === Tt.HALF_FLOAT && (_r = Tt.RGBA16F),
                    Fr === Tt.UNSIGNED_BYTE && (_r = Br === Vo ? Tt.SRGB8_ALPHA8 : Tt.RGBA8),
                    Fr === Tt.UNSIGNED_SHORT_4_4_4_4 && (_r = Tt.RGBA4),
                    Fr === Tt.UNSIGNED_SHORT_5_5_5_1 && (_r = Tt.RGB5_A1)
                }
                return _r !== Tt.R16F && _r !== Tt.R32F && _r !== Tt.RG16F && _r !== Tt.RG32F && _r !== Tt.RGBA16F && _r !== Tt.RGBA32F || tt.get("EXT_color_buffer_float"),
                _r
            }
            function zr(Dr, Sr, Fr) {
                return br(Dr, Fr) === !0 || Dr.isFramebufferTexture && Dr.minFilter !== fn && Dr.minFilter !== Rn ? Math.log2(Math.max(Sr.width, Sr.height)) + 1 : Dr.mipmaps !== void 0 && Dr.mipmaps.length > 0 ? Dr.mipmaps.length : Dr.isCompressedTexture && Array.isArray(Dr.image) ? Sr.mipmaps.length : 1
            }
            function Nr(Dr) {
                return Dr === fn || Dr === bn || Dr === En ? Tt.NEAREST : Tt.LINEAR
            }
            function Vr(Dr) {
                const Sr = Dr.target;
                Sr.removeEventListener("dispose", Vr),
                function(Fr) {
                    const Wr = mt.get(Fr);
                    if (Wr.__webglInit === void 0)
                        return;
                    const kr = Fr.source
                      , _r = Yt.get(kr);
                    if (_r) {
                        const Br = _r[Wr.__cacheKey];
                        Br.usedTimes--,
                        Br.usedTimes === 0 && Hr(Fr),
                        Object.keys(_r).length === 0 && Yt.delete(kr)
                    }
                    mt.remove(Fr)
                }(Sr),
                Sr.isVideoTexture && Xt.delete(Sr)
            }
            function Gr(Dr) {
                const Sr = Dr.target;
                Sr.removeEventListener("dispose", Gr),
                function(Fr) {
                    const Wr = Fr.texture
                      , kr = mt.get(Fr)
                      , _r = mt.get(Wr);
                    if (_r.__webglTexture !== void 0 && (Tt.deleteTexture(_r.__webglTexture),
                    Ct.memory.textures--),
                    Fr.depthTexture && Fr.depthTexture.dispose(),
                    Fr.isWebGLCubeRenderTarget)
                        for (let Br = 0; Br < 6; Br++) {
                            if (Array.isArray(kr.__webglFramebuffer[Br]))
                                for (let Lr = 0; Lr < kr.__webglFramebuffer[Br].length; Lr++)
                                    Tt.deleteFramebuffer(kr.__webglFramebuffer[Br][Lr]);
                            else
                                Tt.deleteFramebuffer(kr.__webglFramebuffer[Br]);
                            kr.__webglDepthbuffer && Tt.deleteRenderbuffer(kr.__webglDepthbuffer[Br])
                        }
                    else {
                        if (Array.isArray(kr.__webglFramebuffer))
                            for (let Br = 0; Br < kr.__webglFramebuffer.length; Br++)
                                Tt.deleteFramebuffer(kr.__webglFramebuffer[Br]);
                        else
                            Tt.deleteFramebuffer(kr.__webglFramebuffer);
                        if (kr.__webglDepthbuffer && Tt.deleteRenderbuffer(kr.__webglDepthbuffer),
                        kr.__webglMultisampledFramebuffer && Tt.deleteFramebuffer(kr.__webglMultisampledFramebuffer),
                        kr.__webglColorRenderbuffer)
                            for (let Br = 0; Br < kr.__webglColorRenderbuffer.length; Br++)
                                kr.__webglColorRenderbuffer[Br] && Tt.deleteRenderbuffer(kr.__webglColorRenderbuffer[Br]);
                        kr.__webglDepthRenderbuffer && Tt.deleteRenderbuffer(kr.__webglDepthRenderbuffer)
                    }
                    if (Fr.isWebGLMultipleRenderTargets)
                        for (let Br = 0, Lr = Wr.length; Br < Lr; Br++) {
                            const Xr = mt.get(Wr[Br]);
                            Xr.__webglTexture && (Tt.deleteTexture(Xr.__webglTexture),
                            Ct.memory.textures--),
                            mt.remove(Wr[Br])
                        }
                    mt.remove(Wr),
                    mt.remove(Fr)
                }(Sr)
            }
            function Hr(Dr) {
                const Sr = mt.get(Dr);
                Tt.deleteTexture(Sr.__webglTexture);
                const Fr = Dr.source;
                delete Yt.get(Fr)[Sr.__cacheKey],
                Ct.memory.textures--
            }
            let _n = 0;
            function dn(Dr, Sr) {
                const Fr = mt.get(Dr);
                if (Dr.isVideoTexture && function(Wr) {
                    const kr = Ct.render.frame;
                    Xt.get(Wr) !== kr && (Xt.set(Wr, kr),
                    Wr.update())
                }(Dr),
                Dr.isRenderTargetTexture === !1 && Dr.version > 0 && Fr.__version !== Dr.version) {
                    const Wr = Dr.image;
                    if (Wr === null)
                        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (Wr.complete !== !1)
                            return void sn(Fr, Dr, Sr);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                lt.bindTexture(Tt.TEXTURE_2D, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            const kn = {
                [Tn]: Tt.REPEAT,
                [wn]: Tt.CLAMP_TO_EDGE,
                [Cn]: Tt.MIRRORED_REPEAT
            }
              , Bn = {
                [fn]: Tt.NEAREST,
                [bn]: Tt.NEAREST_MIPMAP_NEAREST,
                [En]: Tt.NEAREST_MIPMAP_LINEAR,
                [Rn]: Tt.LINEAR,
                [Yn]: Tt.LINEAR_MIPMAP_NEAREST,
                [vo]: Tt.LINEAR_MIPMAP_LINEAR
            }
              , cn = {
                [mu]: Tt.NEVER,
                [Y_]: Tt.ALWAYS,
                [fu]: Tt.LESS,
                [q_]: Tt.LEQUAL,
                [fp]: Tt.EQUAL,
                [Kl]: Tt.GEQUAL,
                [$_]: Tt.GREATER,
                [X_]: Tt.NOTEQUAL
            };
            function Yr(Dr, Sr, Fr) {
                if (Fr ? (Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_S, kn[Sr.wrapS]),
                Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_T, kn[Sr.wrapT]),
                Dr !== Tt.TEXTURE_3D && Dr !== Tt.TEXTURE_2D_ARRAY || Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_R, kn[Sr.wrapR]),
                Tt.texParameteri(Dr, Tt.TEXTURE_MAG_FILTER, Bn[Sr.magFilter]),
                Tt.texParameteri(Dr, Tt.TEXTURE_MIN_FILTER, Bn[Sr.minFilter])) : (Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_S, Tt.CLAMP_TO_EDGE),
                Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_T, Tt.CLAMP_TO_EDGE),
                Dr !== Tt.TEXTURE_3D && Dr !== Tt.TEXTURE_2D_ARRAY || Tt.texParameteri(Dr, Tt.TEXTURE_WRAP_R, Tt.CLAMP_TO_EDGE),
                Sr.wrapS === wn && Sr.wrapT === wn || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
                Tt.texParameteri(Dr, Tt.TEXTURE_MAG_FILTER, Nr(Sr.magFilter)),
                Tt.texParameteri(Dr, Tt.TEXTURE_MIN_FILTER, Nr(Sr.minFilter)),
                Sr.minFilter !== fn && Sr.minFilter !== Rn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
                Sr.compareFunction && (Tt.texParameteri(Dr, Tt.TEXTURE_COMPARE_MODE, Tt.COMPARE_REF_TO_TEXTURE),
                Tt.texParameteri(Dr, Tt.TEXTURE_COMPARE_FUNC, cn[Sr.compareFunction])),
                tt.has("EXT_texture_filter_anisotropic") === !0) {
                    const Wr = tt.get("EXT_texture_filter_anisotropic");
                    if (Sr.magFilter === fn || Sr.minFilter !== En && Sr.minFilter !== vo || Sr.type === ss && tt.has("OES_texture_float_linear") === !1 || Mt === !1 && Sr.type === Os && tt.has("OES_texture_half_float_linear") === !1)
                        return;
                    (Sr.anisotropy > 1 || mt.get(Sr).__currentAnisotropy) && (Tt.texParameterf(Dr, Wr.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(Sr.anisotropy, ft.getMaxAnisotropy())),
                    mt.get(Sr).__currentAnisotropy = Sr.anisotropy)
                }
            }
            function Jr(Dr, Sr) {
                let Fr = !1;
                Dr.__webglInit === void 0 && (Dr.__webglInit = !0,
                Sr.addEventListener("dispose", Vr));
                const Wr = Sr.source;
                let kr = Yt.get(Wr);
                kr === void 0 && (kr = {},
                Yt.set(Wr, kr));
                const _r = function(Br) {
                    const Lr = [];
                    return Lr.push(Br.wrapS),
                    Lr.push(Br.wrapT),
                    Lr.push(Br.wrapR || 0),
                    Lr.push(Br.magFilter),
                    Lr.push(Br.minFilter),
                    Lr.push(Br.anisotropy),
                    Lr.push(Br.internalFormat),
                    Lr.push(Br.format),
                    Lr.push(Br.type),
                    Lr.push(Br.generateMipmaps),
                    Lr.push(Br.premultiplyAlpha),
                    Lr.push(Br.flipY),
                    Lr.push(Br.unpackAlignment),
                    Lr.push(Br.colorSpace),
                    Lr.join()
                }(Sr);
                if (_r !== Dr.__cacheKey) {
                    kr[_r] === void 0 && (kr[_r] = {
                        texture: Tt.createTexture(),
                        usedTimes: 0
                    },
                    Ct.memory.textures++,
                    Fr = !0),
                    kr[_r].usedTimes++;
                    const Br = kr[Dr.__cacheKey];
                    Br !== void 0 && (kr[Dr.__cacheKey].usedTimes--,
                    Br.usedTimes === 0 && Hr(Sr)),
                    Dr.__cacheKey = _r,
                    Dr.__webglTexture = kr[_r].texture
                }
                return Fr
            }
            function sn(Dr, Sr, Fr) {
                let Wr = Tt.TEXTURE_2D;
                (Sr.isDataArrayTexture || Sr.isCompressedArrayTexture) && (Wr = Tt.TEXTURE_2D_ARRAY),
                Sr.isData3DTexture && (Wr = Tt.TEXTURE_3D);
                const kr = Jr(Dr, Sr)
                  , _r = Sr.source;
                lt.bindTexture(Wr, Dr.__webglTexture, Tt.TEXTURE0 + Fr);
                const Br = mt.get(_r);
                if (_r.version !== Br.__version || kr === !0) {
                    lt.activeTexture(Tt.TEXTURE0 + Fr);
                    const Lr = Do.getPrimaries(Do.workingColorSpace)
                      , Xr = Sr.colorSpace === Oo || Sr.colorSpace === ps ? null : Do.getPrimaries(Sr.colorSpace)
                      , Kr = Sr.colorSpace === Oo || Sr.colorSpace === ps || Lr === Xr ? Tt.NONE : Tt.BROWSER_DEFAULT_WEBGL;
                    Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, Sr.flipY),
                    Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Sr.premultiplyAlpha),
                    Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, Sr.unpackAlignment),
                    Tt.pixelStorei(Tt.UNPACK_COLORSPACE_CONVERSION_WEBGL, Kr);
                    const An = function(Jn) {
                        return !Mt && (Jn.wrapS !== wn || Jn.wrapT !== wn || Jn.minFilter !== fn && Jn.minFilter !== Rn)
                    }(Sr) && xr(Sr.image) === !1;
                    let pn = rr(Sr.image, An, !1, jt);
                    pn = uo(Sr, pn);
                    const _o = xr(pn) || Mt
                      , to = xt.convert(Sr.format, Sr.colorSpace);
                    let Pn, eo = xt.convert(Sr.type), Kn = Pr(Sr.internalFormat, to, eo, Sr.colorSpace, Sr.isVideoTexture);
                    Yr(Wr, Sr, _o);
                    const po = Sr.mipmaps
                      , Ao = Mt && Sr.isVideoTexture !== !0
                      , Fo = Br.__version === void 0 || kr === !0
                      , Io = zr(Sr, pn, _o);
                    if (Sr.isDepthTexture)
                        Kn = Tt.DEPTH_COMPONENT,
                        Mt ? Kn = Sr.type === ss ? Tt.DEPTH_COMPONENT32F : Sr.type === Yo ? Tt.DEPTH_COMPONENT24 : Sr.type === Ps ? Tt.DEPTH24_STENCIL8 : Tt.DEPTH_COMPONENT16 : Sr.type === ss && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                        Sr.format === Ys && Kn === Tt.DEPTH_COMPONENT && Sr.type !== Zo && Sr.type !== Yo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                        Sr.type = Yo,
                        eo = xt.convert(Sr.type)),
                        Sr.format === Eo && Kn === Tt.DEPTH_COMPONENT && (Kn = Tt.DEPTH_STENCIL,
                        Sr.type !== Ps && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                        Sr.type = Ps,
                        eo = xt.convert(Sr.type))),
                        Fo && (Ao ? lt.texStorage2D(Tt.TEXTURE_2D, 1, Kn, pn.width, pn.height) : lt.texImage2D(Tt.TEXTURE_2D, 0, Kn, pn.width, pn.height, 0, to, eo, null));
                    else if (Sr.isDataTexture)
                        if (po.length > 0 && _o) {
                            Ao && Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, po[0].width, po[0].height);
                            for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                                Pn = po[Jn],
                                Ao ? lt.texSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, Pn.width, Pn.height, to, eo, Pn.data) : lt.texImage2D(Tt.TEXTURE_2D, Jn, Kn, Pn.width, Pn.height, 0, to, eo, Pn.data);
                            Sr.generateMipmaps = !1
                        } else
                            Ao ? (Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, pn.width, pn.height),
                            lt.texSubImage2D(Tt.TEXTURE_2D, 0, 0, 0, pn.width, pn.height, to, eo, pn.data)) : lt.texImage2D(Tt.TEXTURE_2D, 0, Kn, pn.width, pn.height, 0, to, eo, pn.data);
                    else if (Sr.isCompressedTexture)
                        if (Sr.isCompressedArrayTexture) {
                            Ao && Fo && lt.texStorage3D(Tt.TEXTURE_2D_ARRAY, Io, Kn, po[0].width, po[0].height, pn.depth);
                            for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                                Pn = po[Jn],
                                Sr.format !== as ? to !== null ? Ao ? lt.compressedTexSubImage3D(Tt.TEXTURE_2D_ARRAY, Jn, 0, 0, 0, Pn.width, Pn.height, pn.depth, to, Pn.data, 0, 0) : lt.compressedTexImage3D(Tt.TEXTURE_2D_ARRAY, Jn, Kn, Pn.width, Pn.height, pn.depth, 0, Pn.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ao ? lt.texSubImage3D(Tt.TEXTURE_2D_ARRAY, Jn, 0, 0, 0, Pn.width, Pn.height, pn.depth, to, eo, Pn.data) : lt.texImage3D(Tt.TEXTURE_2D_ARRAY, Jn, Kn, Pn.width, Pn.height, pn.depth, 0, to, eo, Pn.data)
                        } else {
                            Ao && Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, po[0].width, po[0].height);
                            for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                                Pn = po[Jn],
                                Sr.format !== as ? to !== null ? Ao ? lt.compressedTexSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, Pn.width, Pn.height, to, Pn.data) : lt.compressedTexImage2D(Tt.TEXTURE_2D, Jn, Kn, Pn.width, Pn.height, 0, Pn.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ao ? lt.texSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, Pn.width, Pn.height, to, eo, Pn.data) : lt.texImage2D(Tt.TEXTURE_2D, Jn, Kn, Pn.width, Pn.height, 0, to, eo, Pn.data)
                        }
                    else if (Sr.isDataArrayTexture)
                        Ao ? (Fo && lt.texStorage3D(Tt.TEXTURE_2D_ARRAY, Io, Kn, pn.width, pn.height, pn.depth),
                        lt.texSubImage3D(Tt.TEXTURE_2D_ARRAY, 0, 0, 0, 0, pn.width, pn.height, pn.depth, to, eo, pn.data)) : lt.texImage3D(Tt.TEXTURE_2D_ARRAY, 0, Kn, pn.width, pn.height, pn.depth, 0, to, eo, pn.data);
                    else if (Sr.isData3DTexture)
                        Ao ? (Fo && lt.texStorage3D(Tt.TEXTURE_3D, Io, Kn, pn.width, pn.height, pn.depth),
                        lt.texSubImage3D(Tt.TEXTURE_3D, 0, 0, 0, 0, pn.width, pn.height, pn.depth, to, eo, pn.data)) : lt.texImage3D(Tt.TEXTURE_3D, 0, Kn, pn.width, pn.height, pn.depth, 0, to, eo, pn.data);
                    else if (Sr.isFramebufferTexture) {
                        if (Fo)
                            if (Ao)
                                lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, pn.width, pn.height);
                            else {
                                let Jn = pn.width
                                  , Co = pn.height;
                                for (let yl = 0; yl < Io; yl++)
                                    lt.texImage2D(Tt.TEXTURE_2D, yl, Kn, Jn, Co, 0, to, eo, null),
                                    Jn >>= 1,
                                    Co >>= 1
                            }
                    } else if (po.length > 0 && _o) {
                        Ao && Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, po[0].width, po[0].height);
                        for (let Jn = 0, Co = po.length; Jn < Co; Jn++)
                            Pn = po[Jn],
                            Ao ? lt.texSubImage2D(Tt.TEXTURE_2D, Jn, 0, 0, to, eo, Pn) : lt.texImage2D(Tt.TEXTURE_2D, Jn, Kn, to, eo, Pn);
                        Sr.generateMipmaps = !1
                    } else
                        Ao ? (Fo && lt.texStorage2D(Tt.TEXTURE_2D, Io, Kn, pn.width, pn.height),
                        lt.texSubImage2D(Tt.TEXTURE_2D, 0, 0, 0, to, eo, pn)) : lt.texImage2D(Tt.TEXTURE_2D, 0, Kn, to, eo, pn);
                    br(Sr, _o) && yr(Wr),
                    Br.__version = _r.version,
                    Sr.onUpdate && Sr.onUpdate(Sr)
                }
                Dr.__version = Sr.version
            }
            function on(Dr, Sr, Fr, Wr, kr, _r) {
                const Br = xt.convert(Fr.format, Fr.colorSpace)
                  , Lr = xt.convert(Fr.type)
                  , Xr = Pr(Fr.internalFormat, Br, Lr, Fr.colorSpace);
                if (!mt.get(Sr).__hasExternalTextures) {
                    const Kr = Math.max(1, Sr.width >> _r)
                      , An = Math.max(1, Sr.height >> _r);
                    kr === Tt.TEXTURE_3D || kr === Tt.TEXTURE_2D_ARRAY ? lt.texImage3D(kr, _r, Xr, Kr, An, Sr.depth, 0, Br, Lr, null) : lt.texImage2D(kr, _r, Xr, Kr, An, 0, Br, Lr, null)
                }
                lt.bindFramebuffer(Tt.FRAMEBUFFER, Dr),
                jn(Sr) ? Qt.framebufferTexture2DMultisampleEXT(Tt.FRAMEBUFFER, Wr, kr, mt.get(Fr).__webglTexture, 0, Zn(Sr)) : (kr === Tt.TEXTURE_2D || kr >= Tt.TEXTURE_CUBE_MAP_POSITIVE_X && kr <= Tt.TEXTURE_CUBE_MAP_NEGATIVE_Z) && Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Wr, kr, mt.get(Fr).__webglTexture, _r),
                lt.bindFramebuffer(Tt.FRAMEBUFFER, null)
            }
            function Un(Dr, Sr, Fr) {
                if (Tt.bindRenderbuffer(Tt.RENDERBUFFER, Dr),
                Sr.depthBuffer && !Sr.stencilBuffer) {
                    let Wr = Mt === !0 ? Tt.DEPTH_COMPONENT24 : Tt.DEPTH_COMPONENT16;
                    if (Fr || jn(Sr)) {
                        const kr = Sr.depthTexture;
                        kr && kr.isDepthTexture && (kr.type === ss ? Wr = Tt.DEPTH_COMPONENT32F : kr.type === Yo && (Wr = Tt.DEPTH_COMPONENT24));
                        const _r = Zn(Sr);
                        jn(Sr) ? Qt.renderbufferStorageMultisampleEXT(Tt.RENDERBUFFER, _r, Wr, Sr.width, Sr.height) : Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, _r, Wr, Sr.width, Sr.height)
                    } else
                        Tt.renderbufferStorage(Tt.RENDERBUFFER, Wr, Sr.width, Sr.height);
                    Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.RENDERBUFFER, Dr)
                } else if (Sr.depthBuffer && Sr.stencilBuffer) {
                    const Wr = Zn(Sr);
                    Fr && jn(Sr) === !1 ? Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, Wr, Tt.DEPTH24_STENCIL8, Sr.width, Sr.height) : jn(Sr) ? Qt.renderbufferStorageMultisampleEXT(Tt.RENDERBUFFER, Wr, Tt.DEPTH24_STENCIL8, Sr.width, Sr.height) : Tt.renderbufferStorage(Tt.RENDERBUFFER, Tt.DEPTH_STENCIL, Sr.width, Sr.height),
                    Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.RENDERBUFFER, Dr)
                } else {
                    const Wr = Sr.isWebGLMultipleRenderTargets === !0 ? Sr.texture : [Sr.texture];
                    for (let kr = 0; kr < Wr.length; kr++) {
                        const _r = Wr[kr]
                          , Br = xt.convert(_r.format, _r.colorSpace)
                          , Lr = xt.convert(_r.type)
                          , Xr = Pr(_r.internalFormat, Br, Lr, _r.colorSpace)
                          , Kr = Zn(Sr);
                        Fr && jn(Sr) === !1 ? Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, Kr, Xr, Sr.width, Sr.height) : jn(Sr) ? Qt.renderbufferStorageMultisampleEXT(Tt.RENDERBUFFER, Kr, Xr, Sr.width, Sr.height) : Tt.renderbufferStorage(Tt.RENDERBUFFER, Xr, Sr.width, Sr.height)
                    }
                }
                Tt.bindRenderbuffer(Tt.RENDERBUFFER, null)
            }
            function ro(Dr) {
                const Sr = mt.get(Dr)
                  , Fr = Dr.isWebGLCubeRenderTarget === !0;
                if (Dr.depthTexture && !Sr.__autoAllocateDepthBuffer) {
                    if (Fr)
                        throw new Error("target.depthTexture not supported in Cube render targets");
                    (function(Wr, kr) {
                        if (kr && kr.isWebGLCubeRenderTarget)
                            throw new Error("Depth Texture with cube render targets is not supported");
                        if (lt.bindFramebuffer(Tt.FRAMEBUFFER, Wr),
                        !kr.depthTexture || !kr.depthTexture.isDepthTexture)
                            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        mt.get(kr.depthTexture).__webglTexture && kr.depthTexture.image.width === kr.width && kr.depthTexture.image.height === kr.height || (kr.depthTexture.image.width = kr.width,
                        kr.depthTexture.image.height = kr.height,
                        kr.depthTexture.needsUpdate = !0),
                        dn(kr.depthTexture, 0);
                        const _r = mt.get(kr.depthTexture).__webglTexture
                          , Br = Zn(kr);
                        if (kr.depthTexture.format === Ys)
                            jn(kr) ? Qt.framebufferTexture2DMultisampleEXT(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.TEXTURE_2D, _r, 0, Br) : Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.DEPTH_ATTACHMENT, Tt.TEXTURE_2D, _r, 0);
                        else {
                            if (kr.depthTexture.format !== Eo)
                                throw new Error("Unknown depthTexture format");
                            jn(kr) ? Qt.framebufferTexture2DMultisampleEXT(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.TEXTURE_2D, _r, 0, Br) : Tt.framebufferTexture2D(Tt.FRAMEBUFFER, Tt.DEPTH_STENCIL_ATTACHMENT, Tt.TEXTURE_2D, _r, 0)
                        }
                    }
                    )(Sr.__webglFramebuffer, Dr)
                } else if (Fr) {
                    Sr.__webglDepthbuffer = [];
                    for (let Wr = 0; Wr < 6; Wr++)
                        lt.bindFramebuffer(Tt.FRAMEBUFFER, Sr.__webglFramebuffer[Wr]),
                        Sr.__webglDepthbuffer[Wr] = Tt.createRenderbuffer(),
                        Un(Sr.__webglDepthbuffer[Wr], Dr, !1)
                } else
                    lt.bindFramebuffer(Tt.FRAMEBUFFER, Sr.__webglFramebuffer),
                    Sr.__webglDepthbuffer = Tt.createRenderbuffer(),
                    Un(Sr.__webglDepthbuffer, Dr, !1);
                lt.bindFramebuffer(Tt.FRAMEBUFFER, null)
            }
            function Zn(Dr) {
                return Math.min(Wt, Dr.samples)
            }
            function jn(Dr) {
                const Sr = mt.get(Dr);
                return Mt && Dr.samples > 0 && tt.has("WEBGL_multisampled_render_to_texture") === !0 && Sr.__useRenderToTexture !== !1
            }
            function uo(Dr, Sr) {
                const Fr = Dr.colorSpace
                  , Wr = Dr.format
                  , kr = Dr.type;
                return Dr.isCompressedTexture === !0 || Dr.isVideoTexture === !0 || Dr.format === _h || Fr !== Xo && Fr !== Oo && (Do.getTransfer(Fr) === Vo ? Mt === !1 ? tt.has("EXT_sRGB") === !0 && Wr === as ? (Dr.format = _h,
                Dr.minFilter = Rn,
                Dr.generateMipmaps = !1) : Sr = e_.sRGBToLinear(Sr) : Wr === as && kr === $n || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : Fr === ps || console.error("THREE.WebGLTextures: Unsupported texture color space:", Fr)),
                Sr
            }
            this.allocateTextureUnit = function() {
                const Dr = _n;
                return Dr >= Lt && console.warn("THREE.WebGLTextures: Trying to use " + Dr + " texture units while this GPU supports only " + Lt),
                _n += 1,
                Dr
            }
            ,
            this.resetTextureUnits = function() {
                _n = 0
            }
            ,
            this.setTexture2D = dn,
            this.setTexture2DArray = function(Dr, Sr) {
                const Fr = mt.get(Dr);
                Dr.version > 0 && Fr.__version !== Dr.version ? sn(Fr, Dr, Sr) : lt.bindTexture(Tt.TEXTURE_2D_ARRAY, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            ,
            this.setTexture3D = function(Dr, Sr) {
                const Fr = mt.get(Dr);
                Dr.version > 0 && Fr.__version !== Dr.version ? sn(Fr, Dr, Sr) : lt.bindTexture(Tt.TEXTURE_3D, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            ,
            this.setTextureCube = function(Dr, Sr) {
                const Fr = mt.get(Dr);
                Dr.version > 0 && Fr.__version !== Dr.version ? function(Wr, kr, _r) {
                    if (kr.image.length !== 6)
                        return;
                    const Br = Jr(Wr, kr)
                      , Lr = kr.source;
                    lt.bindTexture(Tt.TEXTURE_CUBE_MAP, Wr.__webglTexture, Tt.TEXTURE0 + _r);
                    const Xr = mt.get(Lr);
                    if (Lr.version !== Xr.__version || Br === !0) {
                        lt.activeTexture(Tt.TEXTURE0 + _r);
                        const Kr = Do.getPrimaries(Do.workingColorSpace)
                          , An = kr.colorSpace === Oo || kr.colorSpace === ps ? null : Do.getPrimaries(kr.colorSpace)
                          , pn = kr.colorSpace === Oo || kr.colorSpace === ps || Kr === An ? Tt.NONE : Tt.BROWSER_DEFAULT_WEBGL;
                        Tt.pixelStorei(Tt.UNPACK_FLIP_Y_WEBGL, kr.flipY),
                        Tt.pixelStorei(Tt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, kr.premultiplyAlpha),
                        Tt.pixelStorei(Tt.UNPACK_ALIGNMENT, kr.unpackAlignment),
                        Tt.pixelStorei(Tt.UNPACK_COLORSPACE_CONVERSION_WEBGL, pn);
                        const _o = kr.isCompressedTexture || kr.image[0].isCompressedTexture
                          , to = kr.image[0] && kr.image[0].isDataTexture
                          , Pn = [];
                        for (let ho = 0; ho < 6; ho++)
                            Pn[ho] = _o || to ? to ? kr.image[ho].image : kr.image[ho] : rr(kr.image[ho], !1, !0, Nt),
                            Pn[ho] = uo(kr, Pn[ho]);
                        const eo = Pn[0]
                          , Kn = xr(eo) || Mt
                          , po = xt.convert(kr.format, kr.colorSpace)
                          , Ao = xt.convert(kr.type)
                          , Fo = Pr(kr.internalFormat, po, Ao, kr.colorSpace)
                          , Io = Mt && kr.isVideoTexture !== !0
                          , Jn = Xr.__version === void 0 || Br === !0;
                        let Co, yl = zr(kr, eo, Kn);
                        if (Yr(Tt.TEXTURE_CUBE_MAP, kr, Kn),
                        _o) {
                            Io && Jn && lt.texStorage2D(Tt.TEXTURE_CUBE_MAP, yl, Fo, eo.width, eo.height);
                            for (let ho = 0; ho < 6; ho++) {
                                Co = Pn[ho].mipmaps;
                                for (let Qo = 0; Qo < Co.length; Qo++) {
                                    const Po = Co[Qo];
                                    kr.format !== as ? po !== null ? Io ? lt.compressedTexSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, 0, 0, Po.width, Po.height, po, Po.data) : lt.compressedTexImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, Fo, Po.width, Po.height, 0, Po.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, 0, 0, Po.width, Po.height, po, Ao, Po.data) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo, Fo, Po.width, Po.height, 0, po, Ao, Po.data)
                                }
                            }
                        } else {
                            Co = kr.mipmaps,
                            Io && Jn && (Co.length > 0 && yl++,
                            lt.texStorage2D(Tt.TEXTURE_CUBE_MAP, yl, Fo, Pn[0].width, Pn[0].height));
                            for (let ho = 0; ho < 6; ho++)
                                if (to) {
                                    Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, 0, 0, Pn[ho].width, Pn[ho].height, po, Ao, Pn[ho].data) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, Fo, Pn[ho].width, Pn[ho].height, 0, po, Ao, Pn[ho].data);
                                    for (let Qo = 0; Qo < Co.length; Qo++) {
                                        const Po = Co[Qo].image[ho].image;
                                        Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, 0, 0, Po.width, Po.height, po, Ao, Po.data) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, Fo, Po.width, Po.height, 0, po, Ao, Po.data)
                                    }
                                } else {
                                    Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, 0, 0, po, Ao, Pn[ho]) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, 0, Fo, po, Ao, Pn[ho]);
                                    for (let Qo = 0; Qo < Co.length; Qo++) {
                                        const Po = Co[Qo];
                                        Io ? lt.texSubImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, 0, 0, po, Ao, Po.image[ho]) : lt.texImage2D(Tt.TEXTURE_CUBE_MAP_POSITIVE_X + ho, Qo + 1, Fo, po, Ao, Po.image[ho])
                                    }
                                }
                        }
                        br(kr, Kn) && yr(Tt.TEXTURE_CUBE_MAP),
                        Xr.__version = Lr.version,
                        kr.onUpdate && kr.onUpdate(kr)
                    }
                    Wr.__version = kr.version
                }(Fr, Dr, Sr) : lt.bindTexture(Tt.TEXTURE_CUBE_MAP, Fr.__webglTexture, Tt.TEXTURE0 + Sr)
            }
            ,
            this.rebindTextures = function(Dr, Sr, Fr) {
                const Wr = mt.get(Dr);
                Sr !== void 0 && on(Wr.__webglFramebuffer, Dr, Dr.texture, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_2D, 0),
                Fr !== void 0 && ro(Dr)
            }
            ,
            this.setupRenderTarget = function(Dr) {
                const Sr = Dr.texture
                  , Fr = mt.get(Dr)
                  , Wr = mt.get(Sr);
                Dr.addEventListener("dispose", Gr),
                Dr.isWebGLMultipleRenderTargets !== !0 && (Wr.__webglTexture === void 0 && (Wr.__webglTexture = Tt.createTexture()),
                Wr.__version = Sr.version,
                Ct.memory.textures++);
                const kr = Dr.isWebGLCubeRenderTarget === !0
                  , _r = Dr.isWebGLMultipleRenderTargets === !0
                  , Br = xr(Dr) || Mt;
                if (kr) {
                    Fr.__webglFramebuffer = [];
                    for (let Lr = 0; Lr < 6; Lr++)
                        if (Mt && Sr.mipmaps && Sr.mipmaps.length > 0) {
                            Fr.__webglFramebuffer[Lr] = [];
                            for (let Xr = 0; Xr < Sr.mipmaps.length; Xr++)
                                Fr.__webglFramebuffer[Lr][Xr] = Tt.createFramebuffer()
                        } else
                            Fr.__webglFramebuffer[Lr] = Tt.createFramebuffer()
                } else {
                    if (Mt && Sr.mipmaps && Sr.mipmaps.length > 0) {
                        Fr.__webglFramebuffer = [];
                        for (let Lr = 0; Lr < Sr.mipmaps.length; Lr++)
                            Fr.__webglFramebuffer[Lr] = Tt.createFramebuffer()
                    } else
                        Fr.__webglFramebuffer = Tt.createFramebuffer();
                    if (_r)
                        if (ft.drawBuffers) {
                            const Lr = Dr.texture;
                            for (let Xr = 0, Kr = Lr.length; Xr < Kr; Xr++) {
                                const An = mt.get(Lr[Xr]);
                                An.__webglTexture === void 0 && (An.__webglTexture = Tt.createTexture(),
                                Ct.memory.textures++)
                            }
                        } else
                            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                    if (Mt && Dr.samples > 0 && jn(Dr) === !1) {
                        const Lr = _r ? Sr : [Sr];
                        Fr.__webglMultisampledFramebuffer = Tt.createFramebuffer(),
                        Fr.__webglColorRenderbuffer = [],
                        lt.bindFramebuffer(Tt.FRAMEBUFFER, Fr.__webglMultisampledFramebuffer);
                        for (let Xr = 0; Xr < Lr.length; Xr++) {
                            const Kr = Lr[Xr];
                            Fr.__webglColorRenderbuffer[Xr] = Tt.createRenderbuffer(),
                            Tt.bindRenderbuffer(Tt.RENDERBUFFER, Fr.__webglColorRenderbuffer[Xr]);
                            const An = xt.convert(Kr.format, Kr.colorSpace)
                              , pn = xt.convert(Kr.type)
                              , _o = Pr(Kr.internalFormat, An, pn, Kr.colorSpace, Dr.isXRRenderTarget === !0)
                              , to = Zn(Dr);
                            Tt.renderbufferStorageMultisample(Tt.RENDERBUFFER, to, _o, Dr.width, Dr.height),
                            Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Xr, Tt.RENDERBUFFER, Fr.__webglColorRenderbuffer[Xr])
                        }
                        Tt.bindRenderbuffer(Tt.RENDERBUFFER, null),
                        Dr.depthBuffer && (Fr.__webglDepthRenderbuffer = Tt.createRenderbuffer(),
                        Un(Fr.__webglDepthRenderbuffer, Dr, !0)),
                        lt.bindFramebuffer(Tt.FRAMEBUFFER, null)
                    }
                }
                if (kr) {
                    lt.bindTexture(Tt.TEXTURE_CUBE_MAP, Wr.__webglTexture),
                    Yr(Tt.TEXTURE_CUBE_MAP, Sr, Br);
                    for (let Lr = 0; Lr < 6; Lr++)
                        if (Mt && Sr.mipmaps && Sr.mipmaps.length > 0)
                            for (let Xr = 0; Xr < Sr.mipmaps.length; Xr++)
                                on(Fr.__webglFramebuffer[Lr][Xr], Dr, Sr, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_CUBE_MAP_POSITIVE_X + Lr, Xr);
                        else
                            on(Fr.__webglFramebuffer[Lr], Dr, Sr, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_CUBE_MAP_POSITIVE_X + Lr, 0);
                    br(Sr, Br) && yr(Tt.TEXTURE_CUBE_MAP),
                    lt.unbindTexture()
                } else if (_r) {
                    const Lr = Dr.texture;
                    for (let Xr = 0, Kr = Lr.length; Xr < Kr; Xr++) {
                        const An = Lr[Xr]
                          , pn = mt.get(An);
                        lt.bindTexture(Tt.TEXTURE_2D, pn.__webglTexture),
                        Yr(Tt.TEXTURE_2D, An, Br),
                        on(Fr.__webglFramebuffer, Dr, An, Tt.COLOR_ATTACHMENT0 + Xr, Tt.TEXTURE_2D, 0),
                        br(An, Br) && yr(Tt.TEXTURE_2D)
                    }
                    lt.unbindTexture()
                } else {
                    let Lr = Tt.TEXTURE_2D;
                    if ((Dr.isWebGL3DRenderTarget || Dr.isWebGLArrayRenderTarget) && (Mt ? Lr = Dr.isWebGL3DRenderTarget ? Tt.TEXTURE_3D : Tt.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
                    lt.bindTexture(Lr, Wr.__webglTexture),
                    Yr(Lr, Sr, Br),
                    Mt && Sr.mipmaps && Sr.mipmaps.length > 0)
                        for (let Xr = 0; Xr < Sr.mipmaps.length; Xr++)
                            on(Fr.__webglFramebuffer[Xr], Dr, Sr, Tt.COLOR_ATTACHMENT0, Lr, Xr);
                    else
                        on(Fr.__webglFramebuffer, Dr, Sr, Tt.COLOR_ATTACHMENT0, Lr, 0);
                    br(Sr, Br) && yr(Lr),
                    lt.unbindTexture()
                }
                Dr.depthBuffer && ro(Dr)
            }
            ,
            this.updateRenderTargetMipmap = function(Dr) {
                const Sr = xr(Dr) || Mt
                  , Fr = Dr.isWebGLMultipleRenderTargets === !0 ? Dr.texture : [Dr.texture]
                  , Wr = Dr.isWebGLCubeRenderTarget ? Tt.TEXTURE_CUBE_MAP : Tt.TEXTURE_2D;
                for (let kr = 0, _r = Fr.length; kr < _r; kr++) {
                    const Br = Fr[kr]
                      , Lr = mt.get(Br)
                      , Xr = Lr.__webglTexture;
                    Lr.__version !== Br.version && (lt.bindTexture(Wr, Xr),
                    Yr(Wr, Br, Sr),
                    lt.unbindTexture(),
                    Lr.__version = Br.version),
                    br(Br, Sr) && (lt.bindTexture(Wr, Xr),
                    yr(Wr),
                    lt.unbindTexture())
                }
            }
            ,
            this.updateMultisampleRenderTarget = function(Dr) {
                if (Mt && Dr.samples > 0 && jn(Dr) === !1) {
                    const Sr = Dr.isWebGLMultipleRenderTargets ? Dr.texture : [Dr.texture]
                      , Fr = Dr.width
                      , Wr = Dr.height;
                    let kr = Tt.COLOR_BUFFER_BIT;
                    const _r = []
                      , Br = Dr.stencilBuffer ? Tt.DEPTH_STENCIL_ATTACHMENT : Tt.DEPTH_ATTACHMENT
                      , Lr = mt.get(Dr)
                      , Xr = Dr.isWebGLMultipleRenderTargets === !0;
                    if (Xr)
                        for (let Kr = 0; Kr < Sr.length; Kr++)
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglMultisampledFramebuffer),
                            Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.RENDERBUFFER, null),
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglFramebuffer),
                            Tt.framebufferTexture2D(Tt.DRAW_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.TEXTURE_2D, null, 0);
                    lt.bindFramebuffer(Tt.READ_FRAMEBUFFER, Lr.__webglMultisampledFramebuffer),
                    lt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, Lr.__webglFramebuffer);
                    for (let Kr = 0; Kr < Sr.length; Kr++) {
                        _r.push(Tt.COLOR_ATTACHMENT0 + Kr),
                        Dr.depthBuffer && _r.push(Br);
                        const An = Lr.__ignoreDepthValues !== void 0 && Lr.__ignoreDepthValues;
                        if (An === !1 && (Dr.depthBuffer && (kr |= Tt.DEPTH_BUFFER_BIT),
                        Dr.stencilBuffer && (kr |= Tt.STENCIL_BUFFER_BIT)),
                        Xr && Tt.framebufferRenderbuffer(Tt.READ_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, Tt.RENDERBUFFER, Lr.__webglColorRenderbuffer[Kr]),
                        An === !0 && (Tt.invalidateFramebuffer(Tt.READ_FRAMEBUFFER, [Br]),
                        Tt.invalidateFramebuffer(Tt.DRAW_FRAMEBUFFER, [Br])),
                        Xr) {
                            const pn = mt.get(Sr[Kr]).__webglTexture;
                            Tt.framebufferTexture2D(Tt.DRAW_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0, Tt.TEXTURE_2D, pn, 0)
                        }
                        Tt.blitFramebuffer(0, 0, Fr, Wr, 0, 0, Fr, Wr, kr, Tt.NEAREST),
                        qt && Tt.invalidateFramebuffer(Tt.READ_FRAMEBUFFER, _r)
                    }
                    if (lt.bindFramebuffer(Tt.READ_FRAMEBUFFER, null),
                    lt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, null),
                    Xr)
                        for (let Kr = 0; Kr < Sr.length; Kr++) {
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglMultisampledFramebuffer),
                            Tt.framebufferRenderbuffer(Tt.FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.RENDERBUFFER, Lr.__webglColorRenderbuffer[Kr]);
                            const An = mt.get(Sr[Kr]).__webglTexture;
                            lt.bindFramebuffer(Tt.FRAMEBUFFER, Lr.__webglFramebuffer),
                            Tt.framebufferTexture2D(Tt.DRAW_FRAMEBUFFER, Tt.COLOR_ATTACHMENT0 + Kr, Tt.TEXTURE_2D, An, 0)
                        }
                    lt.bindFramebuffer(Tt.DRAW_FRAMEBUFFER, Lr.__webglMultisampledFramebuffer)
                }
            }
            ,
            this.setupDepthRenderbuffer = ro,
            this.setupFrameBufferTexture = on,
            this.useMultisampledRTT = jn
        }
        function _x(Tt, tt, lt) {
            const mt = lt.isWebGL2;
            return {
                convert: function(ft, xt=Oo) {
                    let Ct;
                    const Mt = Do.getTransfer(xt);
                    if (ft === $n)
                        return Tt.UNSIGNED_BYTE;
                    if (ft === $l)
                        return Tt.UNSIGNED_SHORT_4_4_4_4;
                    if (ft === wl)
                        return Tt.UNSIGNED_SHORT_5_5_5_1;
                    if (ft === ao)
                        return Tt.BYTE;
                    if (ft === zo)
                        return Tt.SHORT;
                    if (ft === Zo)
                        return Tt.UNSIGNED_SHORT;
                    if (ft === $o)
                        return Tt.INT;
                    if (ft === Yo)
                        return Tt.UNSIGNED_INT;
                    if (ft === ss)
                        return Tt.FLOAT;
                    if (ft === Os)
                        return mt ? Tt.HALF_FLOAT : (Ct = tt.get("OES_texture_half_float"),
                        Ct !== null ? Ct.HALF_FLOAT_OES : null);
                    if (ft === ys)
                        return Tt.ALPHA;
                    if (ft === as)
                        return Tt.RGBA;
                    if (ft === Ln)
                        return Tt.LUMINANCE;
                    if (ft === Vn)
                        return Tt.LUMINANCE_ALPHA;
                    if (ft === Ys)
                        return Tt.DEPTH_COMPONENT;
                    if (ft === Eo)
                        return Tt.DEPTH_STENCIL;
                    if (ft === _h)
                        return Ct = tt.get("EXT_sRGB"),
                        Ct !== null ? Ct.SRGB_ALPHA_EXT : null;
                    if (ft === Sl)
                        return Tt.RED;
                    if (ft === Ks)
                        return Tt.RED_INTEGER;
                    if (ft === ds)
                        return Tt.RG;
                    if (ft === yo)
                        return Tt.RG_INTEGER;
                    if (ft === ko)
                        return Tt.RGBA_INTEGER;
                    if (ft === xs || ft === Js || ft === bs || ft === Bl)
                        if (Mt === Vo) {
                            if (Ct = tt.get("WEBGL_compressed_texture_s3tc_srgb"),
                            Ct === null)
                                return null;
                            if (ft === xs)
                                return Ct.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (ft === Js)
                                return Ct.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (ft === bs)
                                return Ct.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (ft === Bl)
                                return Ct.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (Ct = tt.get("WEBGL_compressed_texture_s3tc"),
                            Ct === null)
                                return null;
                            if (ft === xs)
                                return Ct.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (ft === Js)
                                return Ct.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (ft === bs)
                                return Ct.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (ft === Bl)
                                return Ct.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (ft === Bm || ft === Vp || ft === Lm || ft === Om) {
                        if (Ct = tt.get("WEBGL_compressed_texture_pvrtc"),
                        Ct === null)
                            return null;
                        if (ft === Bm)
                            return Ct.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (ft === Vp)
                            return Ct.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (ft === Lm)
                            return Ct.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (ft === Om)
                            return Ct.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (ft === G_)
                        return Ct = tt.get("WEBGL_compressed_texture_etc1"),
                        Ct !== null ? Ct.COMPRESSED_RGB_ETC1_WEBGL : null;
                    if (ft === lu || ft === Zs) {
                        if (Ct = tt.get("WEBGL_compressed_texture_etc"),
                        Ct === null)
                            return null;
                        if (ft === lu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ETC2 : Ct.COMPRESSED_RGB8_ETC2;
                        if (ft === Zs)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : Ct.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (ft === Xl || ft === cu || ft === Gp || ft === Ru || ft === op || ft === Nm || ft === uu || ft === zp || ft === Fm || ft === Hp || ft === Qp || ft === Um || ft === Iu || ft === Wp) {
                        if (Ct = tt.get("WEBGL_compressed_texture_astc"),
                        Ct === null)
                            return null;
                        if (ft === Xl)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : Ct.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (ft === cu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : Ct.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (ft === Gp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : Ct.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (ft === Ru)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : Ct.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (ft === op)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : Ct.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (ft === Nm)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : Ct.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (ft === uu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : Ct.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (ft === zp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : Ct.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (ft === Fm)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : Ct.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (ft === Hp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : Ct.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (ft === Qp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : Ct.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (ft === Um)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : Ct.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (ft === Iu)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : Ct.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (ft === Wp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : Ct.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (ft === sp || ft === jm || ft === Vm) {
                        if (Ct = tt.get("EXT_texture_compression_bptc"),
                        Ct === null)
                            return null;
                        if (ft === sp)
                            return Mt === Vo ? Ct.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : Ct.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (ft === jm)
                            return Ct.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (ft === Vm)
                            return Ct.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (ft === z_ || ft === Gm || ft === zm || ft === ap) {
                        if (Ct = tt.get("EXT_texture_compression_rgtc"),
                        Ct === null)
                            return null;
                        if (ft === sp)
                            return Ct.COMPRESSED_RED_RGTC1_EXT;
                        if (ft === Gm)
                            return Ct.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (ft === zm)
                            return Ct.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (ft === ap)
                            return Ct.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return ft === Ps ? mt ? Tt.UNSIGNED_INT_24_8 : (Ct = tt.get("WEBGL_depth_texture"),
                    Ct !== null ? Ct.UNSIGNED_INT_24_8_WEBGL : null) : Tt[ft] !== void 0 ? Tt[ft] : null
                }
            }
        }
        class vx extends Cs {
            constructor(tt=[]) {
                super(),
                this.isArrayCamera = !0,
                this.cameras = tt
            }
        }
        class Am extends Mo {
            constructor() {
                super(),
                this.isGroup = !0,
                this.type = "Group"
            }
        }
        const eS = {
            type: "move"
        };
        class W0 {
            constructor() {
                this._targetRay = null,
                this._grip = null,
                this._hand = null
            }
            getHandSpace() {
                return this._hand === null && (this._hand = new Am,
                this._hand.matrixAutoUpdate = !1,
                this._hand.visible = !1,
                this._hand.joints = {},
                this._hand.inputState = {
                    pinching: !1
                }),
                this._hand
            }
            getTargetRaySpace() {
                return this._targetRay === null && (this._targetRay = new Am,
                this._targetRay.matrixAutoUpdate = !1,
                this._targetRay.visible = !1,
                this._targetRay.hasLinearVelocity = !1,
                this._targetRay.linearVelocity = new Er,
                this._targetRay.hasAngularVelocity = !1,
                this._targetRay.angularVelocity = new Er),
                this._targetRay
            }
            getGripSpace() {
                return this._grip === null && (this._grip = new Am,
                this._grip.matrixAutoUpdate = !1,
                this._grip.visible = !1,
                this._grip.hasLinearVelocity = !1,
                this._grip.linearVelocity = new Er,
                this._grip.hasAngularVelocity = !1,
                this._grip.angularVelocity = new Er),
                this._grip
            }
            dispatchEvent(tt) {
                return this._targetRay !== null && this._targetRay.dispatchEvent(tt),
                this._grip !== null && this._grip.dispatchEvent(tt),
                this._hand !== null && this._hand.dispatchEvent(tt),
                this
            }
            connect(tt) {
                if (tt && tt.hand) {
                    const lt = this._hand;
                    if (lt)
                        for (const mt of tt.hand.values())
                            this._getHandJoint(lt, mt)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: tt
                }),
                this
            }
            disconnect(tt) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: tt
                }),
                this._targetRay !== null && (this._targetRay.visible = !1),
                this._grip !== null && (this._grip.visible = !1),
                this._hand !== null && (this._hand.visible = !1),
                this
            }
            update(tt, lt, mt) {
                let ft = null
                  , xt = null
                  , Ct = null;
                const Mt = this._targetRay
                  , Lt = this._grip
                  , Nt = this._hand;
                if (tt && lt.session.visibilityState !== "visible-blurred") {
                    if (Nt && tt.hand) {
                        Ct = !0;
                        for (const Zt of tt.hand.values()) {
                            const Yt = lt.getJointPose(Zt, mt)
                              , sr = this._getHandJoint(Nt, Zt);
                            Yt !== null && (sr.matrix.fromArray(Yt.transform.matrix),
                            sr.matrix.decompose(sr.position, sr.rotation, sr.scale),
                            sr.matrixWorldNeedsUpdate = !0,
                            sr.jointRadius = Yt.radius),
                            sr.visible = Yt !== null
                        }
                        const jt = Nt.joints["index-finger-tip"]
                          , Wt = Nt.joints["thumb-tip"]
                          , Qt = jt.position.distanceTo(Wt.position)
                          , qt = .02
                          , Xt = .005;
                        Nt.inputState.pinching && Qt > qt + Xt ? (Nt.inputState.pinching = !1,
                        this.dispatchEvent({
                            type: "pinchend",
                            handedness: tt.handedness,
                            target: this
                        })) : !Nt.inputState.pinching && Qt <= qt - Xt && (Nt.inputState.pinching = !0,
                        this.dispatchEvent({
                            type: "pinchstart",
                            handedness: tt.handedness,
                            target: this
                        }))
                    } else
                        Lt !== null && tt.gripSpace && (xt = lt.getPose(tt.gripSpace, mt),
                        xt !== null && (Lt.matrix.fromArray(xt.transform.matrix),
                        Lt.matrix.decompose(Lt.position, Lt.rotation, Lt.scale),
                        Lt.matrixWorldNeedsUpdate = !0,
                        xt.linearVelocity ? (Lt.hasLinearVelocity = !0,
                        Lt.linearVelocity.copy(xt.linearVelocity)) : Lt.hasLinearVelocity = !1,
                        xt.angularVelocity ? (Lt.hasAngularVelocity = !0,
                        Lt.angularVelocity.copy(xt.angularVelocity)) : Lt.hasAngularVelocity = !1));
                    Mt !== null && (ft = lt.getPose(tt.targetRaySpace, mt),
                    ft === null && xt !== null && (ft = xt),
                    ft !== null && (Mt.matrix.fromArray(ft.transform.matrix),
                    Mt.matrix.decompose(Mt.position, Mt.rotation, Mt.scale),
                    Mt.matrixWorldNeedsUpdate = !0,
                    ft.linearVelocity ? (Mt.hasLinearVelocity = !0,
                    Mt.linearVelocity.copy(ft.linearVelocity)) : Mt.hasLinearVelocity = !1,
                    ft.angularVelocity ? (Mt.hasAngularVelocity = !0,
                    Mt.angularVelocity.copy(ft.angularVelocity)) : Mt.hasAngularVelocity = !1,
                    this.dispatchEvent(eS)))
                }
                return Mt !== null && (Mt.visible = ft !== null),
                Lt !== null && (Lt.visible = xt !== null),
                Nt !== null && (Nt.visible = Ct !== null),
                this
            }
            _getHandJoint(tt, lt) {
                if (tt.joints[lt.jointName] === void 0) {
                    const mt = new Am;
                    mt.matrixAutoUpdate = !1,
                    mt.visible = !1,
                    tt.joints[lt.jointName] = mt,
                    tt.add(mt)
                }
                return tt.joints[lt.jointName]
            }
        }
        class yx extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt) {
                if ((jt = jt !== void 0 ? jt : Ys) !== Ys && jt !== Eo)
                    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                mt === void 0 && jt === Ys && (mt = Yo),
                mt === void 0 && jt === Eo && (mt = Ps),
                super(null, ft, xt, Ct, Mt, Lt, jt, mt, Nt),
                this.isDepthTexture = !0,
                this.image = {
                    width: tt,
                    height: lt
                },
                this.magFilter = Mt !== void 0 ? Mt : fn,
                this.minFilter = Lt !== void 0 ? Lt : fn,
                this.flipY = !1,
                this.generateMipmaps = !1,
                this.compareFunction = null
            }
            copy(tt) {
                return super.copy(tt),
                this.compareFunction = tt.compareFunction,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return this.compareFunction !== null && (lt.compareFunction = this.compareFunction),
                lt
            }
        }
        class tS extends As {
            constructor(tt, lt) {
                super();
                const mt = this;
                let ft = null
                  , xt = 1
                  , Ct = null
                  , Mt = "local-floor"
                  , Lt = 1
                  , Nt = null
                  , jt = null
                  , Wt = null
                  , Qt = null
                  , qt = null
                  , Xt = null;
                const Zt = lt.getContextAttributes();
                let Yt = null
                  , sr = null;
                const er = []
                  , rr = []
                  , xr = new Cs;
                xr.layers.enable(1),
                xr.viewport = new Lo;
                const br = new Cs;
                br.layers.enable(2),
                br.viewport = new Lo;
                const yr = [xr, br]
                  , Pr = new vx;
                Pr.layers.enable(1),
                Pr.layers.enable(2);
                let zr = null
                  , Nr = null;
                function Vr(Yr) {
                    const Jr = rr.indexOf(Yr.inputSource);
                    if (Jr === -1)
                        return;
                    const sn = er[Jr];
                    sn !== void 0 && (sn.update(Yr.inputSource, Yr.frame, Nt || Ct),
                    sn.dispatchEvent({
                        type: Yr.type,
                        data: Yr.inputSource
                    }))
                }
                function Gr() {
                    ft.removeEventListener("select", Vr),
                    ft.removeEventListener("selectstart", Vr),
                    ft.removeEventListener("selectend", Vr),
                    ft.removeEventListener("squeeze", Vr),
                    ft.removeEventListener("squeezestart", Vr),
                    ft.removeEventListener("squeezeend", Vr),
                    ft.removeEventListener("end", Gr),
                    ft.removeEventListener("inputsourceschange", Hr);
                    for (let Yr = 0; Yr < er.length; Yr++) {
                        const Jr = rr[Yr];
                        Jr !== null && (rr[Yr] = null,
                        er[Yr].disconnect(Jr))
                    }
                    zr = null,
                    Nr = null,
                    tt.setRenderTarget(Yt),
                    qt = null,
                    Qt = null,
                    Wt = null,
                    ft = null,
                    sr = null,
                    cn.stop(),
                    mt.isPresenting = !1,
                    mt.dispatchEvent({
                        type: "sessionend"
                    })
                }
                function Hr(Yr) {
                    for (let Jr = 0; Jr < Yr.removed.length; Jr++) {
                        const sn = Yr.removed[Jr]
                          , on = rr.indexOf(sn);
                        on >= 0 && (rr[on] = null,
                        er[on].disconnect(sn))
                    }
                    for (let Jr = 0; Jr < Yr.added.length; Jr++) {
                        const sn = Yr.added[Jr];
                        let on = rr.indexOf(sn);
                        if (on === -1) {
                            for (let ro = 0; ro < er.length; ro++) {
                                if (ro >= rr.length) {
                                    rr.push(sn),
                                    on = ro;
                                    break
                                }
                                if (rr[ro] === null) {
                                    rr[ro] = sn,
                                    on = ro;
                                    break
                                }
                            }
                            if (on === -1)
                                break
                        }
                        const Un = er[on];
                        Un && Un.connect(sn)
                    }
                }
                this.cameraAutoUpdate = !0,
                this.enabled = !1,
                this.isPresenting = !1,
                this.getController = function(Yr) {
                    let Jr = er[Yr];
                    return Jr === void 0 && (Jr = new W0,
                    er[Yr] = Jr),
                    Jr.getTargetRaySpace()
                }
                ,
                this.getControllerGrip = function(Yr) {
                    let Jr = er[Yr];
                    return Jr === void 0 && (Jr = new W0,
                    er[Yr] = Jr),
                    Jr.getGripSpace()
                }
                ,
                this.getHand = function(Yr) {
                    let Jr = er[Yr];
                    return Jr === void 0 && (Jr = new W0,
                    er[Yr] = Jr),
                    Jr.getHandSpace()
                }
                ,
                this.setFramebufferScaleFactor = function(Yr) {
                    xt = Yr,
                    mt.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }
                ,
                this.setReferenceSpaceType = function(Yr) {
                    Mt = Yr,
                    mt.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }
                ,
                this.getReferenceSpace = function() {
                    return Nt || Ct
                }
                ,
                this.setReferenceSpace = function(Yr) {
                    Nt = Yr
                }
                ,
                this.getBaseLayer = function() {
                    return Qt !== null ? Qt : qt
                }
                ,
                this.getBinding = function() {
                    return Wt
                }
                ,
                this.getFrame = function() {
                    return Xt
                }
                ,
                this.getSession = function() {
                    return ft
                }
                ,
                this.setSession = async function(Yr) {
                    if (ft = Yr,
                    ft !== null) {
                        if (Yt = tt.getRenderTarget(),
                        ft.addEventListener("select", Vr),
                        ft.addEventListener("selectstart", Vr),
                        ft.addEventListener("selectend", Vr),
                        ft.addEventListener("squeeze", Vr),
                        ft.addEventListener("squeezestart", Vr),
                        ft.addEventListener("squeezeend", Vr),
                        ft.addEventListener("end", Gr),
                        ft.addEventListener("inputsourceschange", Hr),
                        Zt.xrCompatible !== !0 && await lt.makeXRCompatible(),
                        ft.renderState.layers === void 0 || tt.capabilities.isWebGL2 === !1) {
                            const Jr = {
                                antialias: ft.renderState.layers !== void 0 || Zt.antialias,
                                alpha: !0,
                                depth: Zt.depth,
                                stencil: Zt.stencil,
                                framebufferScaleFactor: xt
                            };
                            qt = new XRWebGLLayer(ft,lt,Jr),
                            ft.updateRenderState({
                                baseLayer: qt
                            }),
                            sr = new Rs(qt.framebufferWidth,qt.framebufferHeight,{
                                format: as,
                                type: $n,
                                colorSpace: tt.outputColorSpace,
                                stencilBuffer: Zt.stencil
                            })
                        } else {
                            let Jr = null
                              , sn = null
                              , on = null;
                            Zt.depth && (on = Zt.stencil ? lt.DEPTH24_STENCIL8 : lt.DEPTH_COMPONENT24,
                            Jr = Zt.stencil ? Eo : Ys,
                            sn = Zt.stencil ? Ps : Yo);
                            const Un = {
                                colorFormat: lt.RGBA8,
                                depthFormat: on,
                                scaleFactor: xt
                            };
                            Wt = new XRWebGLBinding(ft,lt),
                            Qt = Wt.createProjectionLayer(Un),
                            ft.updateRenderState({
                                layers: [Qt]
                            }),
                            sr = new Rs(Qt.textureWidth,Qt.textureHeight,{
                                format: as,
                                type: $n,
                                depthTexture: new yx(Qt.textureWidth,Qt.textureHeight,sn,void 0,void 0,void 0,void 0,void 0,void 0,Jr),
                                stencilBuffer: Zt.stencil,
                                colorSpace: tt.outputColorSpace,
                                samples: Zt.antialias ? 4 : 0
                            }),
                            tt.properties.get(sr).__ignoreDepthValues = Qt.ignoreDepthValues
                        }
                        sr.isXRRenderTarget = !0,
                        this.setFoveation(Lt),
                        Nt = null,
                        Ct = await ft.requestReferenceSpace(Mt),
                        cn.setContext(ft),
                        cn.start(),
                        mt.isPresenting = !0,
                        mt.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }
                ,
                this.getEnvironmentBlendMode = function() {
                    if (ft !== null)
                        return ft.environmentBlendMode
                }
                ;
                const _n = new Er
                  , dn = new Er;
                function kn(Yr, Jr) {
                    Jr === null ? Yr.matrixWorld.copy(Yr.matrix) : Yr.matrixWorld.multiplyMatrices(Jr.matrixWorld, Yr.matrix),
                    Yr.matrixWorldInverse.copy(Yr.matrixWorld).invert()
                }
                this.updateCamera = function(Yr) {
                    if (ft === null)
                        return;
                    Pr.near = br.near = xr.near = Yr.near,
                    Pr.far = br.far = xr.far = Yr.far,
                    zr === Pr.near && Nr === Pr.far || (ft.updateRenderState({
                        depthNear: Pr.near,
                        depthFar: Pr.far
                    }),
                    zr = Pr.near,
                    Nr = Pr.far);
                    const Jr = Yr.parent
                      , sn = Pr.cameras;
                    kn(Pr, Jr);
                    for (let on = 0; on < sn.length; on++)
                        kn(sn[on], Jr);
                    sn.length === 2 ? function(on, Un, ro) {
                        _n.setFromMatrixPosition(Un.matrixWorld),
                        dn.setFromMatrixPosition(ro.matrixWorld);
                        const Zn = _n.distanceTo(dn)
                          , jn = Un.projectionMatrix.elements
                          , uo = ro.projectionMatrix.elements
                          , Dr = jn[14] / (jn[10] - 1)
                          , Sr = jn[14] / (jn[10] + 1)
                          , Fr = (jn[9] + 1) / jn[5]
                          , Wr = (jn[9] - 1) / jn[5]
                          , kr = (jn[8] - 1) / jn[0]
                          , _r = (uo[8] + 1) / uo[0]
                          , Br = Dr * kr
                          , Lr = Dr * _r
                          , Xr = Zn / (-kr + _r)
                          , Kr = Xr * -kr;
                        Un.matrixWorld.decompose(on.position, on.quaternion, on.scale),
                        on.translateX(Kr),
                        on.translateZ(Xr),
                        on.matrixWorld.compose(on.position, on.quaternion, on.scale),
                        on.matrixWorldInverse.copy(on.matrixWorld).invert();
                        const An = Dr + Xr
                          , pn = Sr + Xr
                          , _o = Br - Kr
                          , to = Lr + (Zn - Kr)
                          , Pn = Fr * Sr / pn * An
                          , eo = Wr * Sr / pn * An;
                        on.projectionMatrix.makePerspective(_o, to, Pn, eo, An, pn),
                        on.projectionMatrixInverse.copy(on.projectionMatrix).invert()
                    }(Pr, xr, br) : Pr.projectionMatrix.copy(xr.projectionMatrix),
                    function(on, Un, ro) {
                        ro === null ? on.matrix.copy(Un.matrixWorld) : (on.matrix.copy(ro.matrixWorld),
                        on.matrix.invert(),
                        on.matrix.multiply(Un.matrixWorld)),
                        on.matrix.decompose(on.position, on.quaternion, on.scale),
                        on.updateMatrixWorld(!0),
                        on.projectionMatrix.copy(Un.projectionMatrix),
                        on.projectionMatrixInverse.copy(Un.projectionMatrixInverse),
                        on.isPerspectiveCamera && (on.fov = 2 * _u * Math.atan(1 / on.projectionMatrix.elements[5]),
                        on.zoom = 1)
                    }(Yr, Pr, Jr)
                }
                ,
                this.getCamera = function() {
                    return Pr
                }
                ,
                this.getFoveation = function() {
                    if (Qt !== null || qt !== null)
                        return Lt
                }
                ,
                this.setFoveation = function(Yr) {
                    Lt = Yr,
                    Qt !== null && (Qt.fixedFoveation = Yr),
                    qt !== null && qt.fixedFoveation !== void 0 && (qt.fixedFoveation = Yr)
                }
                ;
                let Bn = null;
                this.onPreAnimationFrameCallback = null;
                const cn = new Hy;
                cn.setAnimationLoop(function(Yr, Jr) {
                    if (mt.onPreAnimationFrameCallback && mt.onPreAnimationFrameCallback(Yr, Jr),
                    jt = Jr.getViewerPose(Nt || Ct),
                    Xt = Jr,
                    jt !== null) {
                        const sn = jt.views;
                        qt !== null && (tt.setRenderTargetFramebuffer(sr, qt.framebuffer),
                        tt.setRenderTarget(sr));
                        let on = !1;
                        sn.length !== Pr.cameras.length && (Pr.cameras.length = 0,
                        on = !0);
                        for (let Un = 0; Un < sn.length; Un++) {
                            const ro = sn[Un];
                            let Zn = null;
                            if (qt !== null)
                                Zn = qt.getViewport(ro);
                            else {
                                const uo = Wt.getViewSubImage(Qt, ro);
                                Zn = uo.viewport,
                                Un === 0 && (tt.setRenderTargetTextures(sr, uo.colorTexture, Qt.ignoreDepthValues ? void 0 : uo.depthStencilTexture),
                                tt.setRenderTarget(sr))
                            }
                            let jn = yr[Un];
                            jn === void 0 && (jn = new Cs,
                            jn.layers.enable(Un),
                            jn.viewport = new Lo,
                            yr[Un] = jn),
                            jn.matrix.fromArray(ro.transform.matrix),
                            jn.matrix.decompose(jn.position, jn.quaternion, jn.scale),
                            jn.projectionMatrix.fromArray(ro.projectionMatrix),
                            jn.projectionMatrixInverse.copy(jn.projectionMatrix).invert(),
                            jn.viewport.set(Zn.x, Zn.y, Zn.width, Zn.height),
                            Un === 0 && (Pr.matrix.copy(jn.matrix),
                            Pr.matrix.decompose(Pr.position, Pr.quaternion, Pr.scale)),
                            on === !0 && Pr.cameras.push(jn)
                        }
                    }
                    for (let sn = 0; sn < er.length; sn++) {
                        const on = rr[sn]
                          , Un = er[sn];
                        on !== null && Un !== void 0 && Un.update(on, Jr, Nt || Ct)
                    }
                    Bn && Bn(Yr, Jr),
                    Jr.detectedPlanes && mt.dispatchEvent({
                        type: "planesdetected",
                        data: Jr
                    }),
                    Xt = null
                }),
                this.setAnimationLoop = function(Yr) {
                    Bn = Yr
                }
                ,
                this.dispose = function() {}
            }
        }
        function rS(Tt, tt) {
            function lt(ft, xt) {
                ft.matrixAutoUpdate === !0 && ft.updateMatrix(),
                xt.value.copy(ft.matrix)
            }
            function mt(ft, xt) {
                ft.opacity.value = xt.opacity,
                xt.color && ft.diffuse.value.copy(xt.color),
                xt.emissive && ft.emissive.value.copy(xt.emissive).multiplyScalar(xt.emissiveIntensity),
                xt.map && (ft.map.value = xt.map,
                lt(xt.map, ft.mapTransform)),
                xt.alphaMap && (ft.alphaMap.value = xt.alphaMap,
                lt(xt.alphaMap, ft.alphaMapTransform)),
                xt.bumpMap && (ft.bumpMap.value = xt.bumpMap,
                lt(xt.bumpMap, ft.bumpMapTransform),
                ft.bumpScale.value = xt.bumpScale,
                xt.side === bt && (ft.bumpScale.value *= -1)),
                xt.normalMap && (ft.normalMap.value = xt.normalMap,
                lt(xt.normalMap, ft.normalMapTransform),
                ft.normalScale.value.copy(xt.normalScale),
                xt.side === bt && ft.normalScale.value.negate()),
                xt.displacementMap && (ft.displacementMap.value = xt.displacementMap,
                lt(xt.displacementMap, ft.displacementMapTransform),
                ft.displacementScale.value = xt.displacementScale,
                ft.displacementBias.value = xt.displacementBias),
                xt.emissiveMap && (ft.emissiveMap.value = xt.emissiveMap,
                lt(xt.emissiveMap, ft.emissiveMapTransform)),
                xt.specularMap && (ft.specularMap.value = xt.specularMap,
                lt(xt.specularMap, ft.specularMapTransform)),
                xt.alphaTest > 0 && (ft.alphaTest.value = xt.alphaTest);
                const Ct = tt.get(xt).envMap;
                if (Ct) {
                    ft.envMap.value = Ct;
                    const Mt = xt.envMap || tt.get(xt).environment || Ct;
                    ft.envMapRotation.value = Mt ? Mt.rotation : 0,
                    ft.flipEnvMap.value = Ct.isCubeTexture && Ct.isRenderTargetTexture === !1 ? -1 : 1,
                    ft.reflectivity.value = xt.reflectivity,
                    ft.ior.value = xt.ior,
                    ft.refractionRatio.value = xt.refractionRatio
                }
                if (xt.lightMap) {
                    ft.lightMap.value = xt.lightMap;
                    const Mt = Tt._useLegacyLights === !0 ? Math.PI : 1;
                    ft.lightMapIntensity.value = xt.lightMapIntensity * Mt,
                    lt(xt.lightMap, ft.lightMapTransform)
                }
                xt.aoMap && (ft.aoMap.value = xt.aoMap,
                ft.aoMapIntensity.value = xt.aoMapIntensity,
                lt(xt.aoMap, ft.aoMapTransform))
            }
            return {
                refreshTransformUniform: lt,
                refreshFogUniforms: function(ft, xt) {
                    xt.color.getRGB(ft.fogColor.value, jy(Tt)),
                    xt.isFog ? (ft.fogNear.value = xt.near,
                    ft.fogFar.value = xt.far) : xt.isFogExp2 && (ft.fogDensity.value = xt.density)
                },
                refreshMaterialUniforms: function(ft, xt, Ct, Mt, Lt) {
                    xt.isMeshBasicMaterial || xt.isMeshLambertMaterial ? mt(ft, xt) : xt.isMeshToonMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        jt.gradientMap && (Nt.gradientMap.value = jt.gradientMap)
                    }(ft, xt)) : xt.isMeshPhongMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        Nt.specular.value.copy(jt.specular),
                        Nt.shininess.value = Math.max(jt.shininess, 1e-4)
                    }(ft, xt)) : xt.isMeshStandardMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        Nt.metalness.value = jt.metalness,
                        jt.metalnessMap && (Nt.metalnessMap.value = jt.metalnessMap,
                        lt(jt.metalnessMap, Nt.metalnessMapTransform)),
                        Nt.roughness.value = jt.roughness,
                        jt.roughnessMap && (Nt.roughnessMap.value = jt.roughnessMap,
                        lt(jt.roughnessMap, Nt.roughnessMapTransform)),
                        tt.get(jt).envMap && (Nt.envMapIntensity.value = jt.envMapIntensity)
                    }(ft, xt),
                    xt.isMeshPhysicalMaterial && function(Nt, jt, Wt) {
                        Nt.ior.value = jt.ior,
                        jt.sheen > 0 && (Nt.sheenColor.value.copy(jt.sheenColor).multiplyScalar(jt.sheen),
                        Nt.sheenRoughness.value = jt.sheenRoughness,
                        jt.sheenColorMap && (Nt.sheenColorMap.value = jt.sheenColorMap,
                        lt(jt.sheenColorMap, Nt.sheenColorMapTransform)),
                        jt.sheenRoughnessMap && (Nt.sheenRoughnessMap.value = jt.sheenRoughnessMap,
                        lt(jt.sheenRoughnessMap, Nt.sheenRoughnessMapTransform))),
                        jt.clearcoat > 0 && (Nt.clearcoat.value = jt.clearcoat,
                        Nt.clearcoatRoughness.value = jt.clearcoatRoughness,
                        jt.clearcoatMap && (Nt.clearcoatMap.value = jt.clearcoatMap,
                        lt(jt.clearcoatMap, Nt.clearcoatMapTransform)),
                        jt.clearcoatRoughnessMap && (Nt.clearcoatRoughnessMap.value = jt.clearcoatRoughnessMap,
                        lt(jt.clearcoatRoughnessMap, Nt.clearcoatRoughnessMapTransform)),
                        jt.clearcoatNormalMap && (Nt.clearcoatNormalMap.value = jt.clearcoatNormalMap,
                        lt(jt.clearcoatNormalMap, Nt.clearcoatNormalMapTransform),
                        Nt.clearcoatNormalScale.value.copy(jt.clearcoatNormalScale),
                        jt.side === bt && Nt.clearcoatNormalScale.value.negate())),
                        jt.iridescence > 0 && (Nt.iridescence.value = jt.iridescence,
                        Nt.iridescenceIOR.value = jt.iridescenceIOR,
                        Nt.iridescenceThicknessMinimum.value = jt.iridescenceThicknessRange[0],
                        Nt.iridescenceThicknessMaximum.value = jt.iridescenceThicknessRange[1],
                        jt.iridescenceMap && (Nt.iridescenceMap.value = jt.iridescenceMap,
                        lt(jt.iridescenceMap, Nt.iridescenceMapTransform)),
                        jt.iridescenceThicknessMap && (Nt.iridescenceThicknessMap.value = jt.iridescenceThicknessMap,
                        lt(jt.iridescenceThicknessMap, Nt.iridescenceThicknessMapTransform))),
                        jt.transmission > 0 && (Nt.transmission.value = jt.transmission,
                        Nt.transmissionSamplerMap.value = Wt.texture,
                        Nt.transmissionSamplerSize.value.set(Wt.width, Wt.height),
                        jt.transmissionMap && (Nt.transmissionMap.value = jt.transmissionMap,
                        lt(jt.transmissionMap, Nt.transmissionMapTransform)),
                        Nt.thickness.value = jt.thickness,
                        jt.thicknessMap && (Nt.thicknessMap.value = jt.thicknessMap,
                        lt(jt.thicknessMap, Nt.thicknessMapTransform)),
                        Nt.attenuationDistance.value = jt.attenuationDistance,
                        Nt.attenuationColor.value.copy(jt.attenuationColor)),
                        jt.anisotropy > 0 && (Nt.anisotropyVector.value.set(jt.anisotropy * Math.cos(jt.anisotropyRotation), jt.anisotropy * Math.sin(jt.anisotropyRotation)),
                        jt.anisotropyMap && (Nt.anisotropyMap.value = jt.anisotropyMap,
                        lt(jt.anisotropyMap, Nt.anisotropyMapTransform))),
                        Nt.specularIntensity.value = jt.specularIntensity,
                        Nt.specularColor.value.copy(jt.specularColor),
                        jt.specularColorMap && (Nt.specularColorMap.value = jt.specularColorMap,
                        lt(jt.specularColorMap, Nt.specularColorMapTransform)),
                        jt.specularIntensityMap && (Nt.specularIntensityMap.value = jt.specularIntensityMap,
                        lt(jt.specularIntensityMap, Nt.specularIntensityMapTransform))
                    }(ft, xt, Lt)) : xt.isMeshMatcapMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        jt.matcap && (Nt.matcap.value = jt.matcap)
                    }(ft, xt)) : xt.isMeshDepthMaterial ? mt(ft, xt) : xt.isMeshDistanceMaterial ? (mt(ft, xt),
                    function(Nt, jt) {
                        const Wt = tt.get(jt).light;
                        Nt.referencePosition.value.setFromMatrixPosition(Wt.matrixWorld),
                        Nt.nearDistance.value = Wt.shadow.camera.near,
                        Nt.farDistance.value = Wt.shadow.camera.far
                    }(ft, xt)) : xt.isMeshNormalMaterial ? mt(ft, xt) : xt.isLineBasicMaterial ? (function(Nt, jt) {
                        Nt.diffuse.value.copy(jt.color),
                        Nt.opacity.value = jt.opacity,
                        jt.map && (Nt.map.value = jt.map,
                        lt(jt.map, Nt.mapTransform))
                    }(ft, xt),
                    xt.isLineDashedMaterial && function(Nt, jt) {
                        Nt.dashSize.value = jt.dashSize,
                        Nt.totalSize.value = jt.dashSize + jt.gapSize,
                        Nt.scale.value = jt.scale
                    }(ft, xt)) : xt.isPointsMaterial ? function(Nt, jt, Wt, Qt) {
                        Nt.diffuse.value.copy(jt.color),
                        Nt.opacity.value = jt.opacity,
                        Nt.size.value = jt.size * Wt,
                        Nt.scale.value = .5 * Qt,
                        jt.map && (Nt.map.value = jt.map,
                        lt(jt.map, Nt.uvTransform)),
                        jt.alphaMap && (Nt.alphaMap.value = jt.alphaMap,
                        lt(jt.alphaMap, Nt.alphaMapTransform)),
                        jt.alphaTest > 0 && (Nt.alphaTest.value = jt.alphaTest)
                    }(ft, xt, Ct, Mt) : xt.isSpriteMaterial ? function(Nt, jt) {
                        Nt.diffuse.value.copy(jt.color),
                        Nt.opacity.value = jt.opacity,
                        Nt.rotation.value = jt.rotation,
                        jt.map && (Nt.map.value = jt.map,
                        lt(jt.map, Nt.mapTransform)),
                        jt.alphaMap && (Nt.alphaMap.value = jt.alphaMap,
                        lt(jt.alphaMap, Nt.alphaMapTransform)),
                        jt.alphaTest > 0 && (Nt.alphaTest.value = jt.alphaTest)
                    }(ft, xt) : xt.isShadowMaterial ? (ft.color.value.copy(xt.color),
                    ft.opacity.value = xt.opacity) : xt.isShaderMaterial && (xt.transmission !== void 0 && (ft.transmission && (ft.transmission.value = xt.transmission),
                    ft.transmissionSamplerMap && Lt && (ft.transmissionSamplerMap.value = Lt ? Lt.texture : null),
                    ft.transmissionSamplerSize && Lt && ft.transmissionSamplerSize.value.set(Lt.width, Lt.height)),
                    xt.uniformsNeedUpdate = !1)
                }
            }
        }
        function nS(Tt, tt, lt, mt) {
            let ft = {}
              , xt = {}
              , Ct = [];
            const Mt = lt.isWebGL2 ? Tt.getParameter(Tt.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
            function Lt(Wt, Qt, qt) {
                const Xt = Wt.value;
                if (qt[Qt] === void 0) {
                    if (typeof Xt == "number")
                        qt[Qt] = Xt;
                    else {
                        const Zt = Array.isArray(Xt) ? Xt : [Xt]
                          , Yt = [];
                        for (let sr = 0; sr < Zt.length; sr++)
                            Yt.push(Zt[sr].clone());
                        qt[Qt] = Yt
                    }
                    return !0
                }
                if (typeof Xt == "number") {
                    if (qt[Qt] !== Xt)
                        return qt[Qt] = Xt,
                        !0
                } else {
                    const Zt = Array.isArray(qt[Qt]) ? qt[Qt] : [qt[Qt]]
                      , Yt = Array.isArray(Xt) ? Xt : [Xt];
                    for (let sr = 0; sr < Zt.length; sr++) {
                        const er = Zt[sr];
                        if (er.equals(Yt[sr]) === !1)
                            return er.copy(Yt[sr]),
                            !0
                    }
                }
                return !1
            }
            function Nt(Wt) {
                const Qt = {
                    boundary: 0,
                    storage: 0
                };
                return typeof Wt == "number" ? (Qt.boundary = 4,
                Qt.storage = 4) : Wt.isVector2 ? (Qt.boundary = 8,
                Qt.storage = 8) : Wt.isVector3 || Wt.isColor ? (Qt.boundary = 16,
                Qt.storage = 12) : Wt.isVector4 ? (Qt.boundary = 16,
                Qt.storage = 16) : Wt.isMatrix3 ? (Qt.boundary = 48,
                Qt.storage = 48) : Wt.isMatrix4 ? (Qt.boundary = 64,
                Qt.storage = 64) : Wt.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", Wt),
                Qt
            }
            function jt(Wt) {
                const Qt = Wt.target;
                Qt.removeEventListener("dispose", jt);
                const qt = Ct.indexOf(Qt.__bindingPointIndex);
                Ct.splice(qt, 1),
                Tt.deleteBuffer(ft[Qt.id]),
                delete ft[Qt.id],
                delete xt[Qt.id]
            }
            return {
                bind: function(Wt, Qt) {
                    const qt = Qt.program;
                    mt.uniformBlockBinding(Wt, qt)
                },
                update: function(Wt, Qt) {
                    let qt = ft[Wt.id];
                    qt === void 0 && (function(Yt) {
                        const sr = Yt.uniforms;
                        let er = 0
                          , rr = 0;
                        for (let xr = 0, br = sr.length; xr < br; xr++) {
                            const yr = sr[xr]
                              , Pr = {
                                boundary: 0,
                                storage: 0
                            }
                              , zr = Array.isArray(yr.value) ? yr.value : [yr.value];
                            for (let Nr = 0, Vr = zr.length; Nr < Vr; Nr++) {
                                const Gr = Nt(zr[Nr]);
                                Pr.boundary += Gr.boundary,
                                Pr.storage += Gr.storage
                            }
                            yr.__data = new Float32Array(Pr.storage / Float32Array.BYTES_PER_ELEMENT),
                            yr.__offset = er,
                            xr > 0 && (rr = er % 16,
                            rr !== 0 && 16 - rr - Pr.boundary < 0 && (er += 16 - rr,
                            yr.__offset = er)),
                            er += Pr.storage
                        }
                        rr = er % 16,
                        rr > 0 && (er += 16 - rr),
                        Yt.__size = er,
                        Yt.__cache = {}
                    }(Wt),
                    qt = function(Yt) {
                        const sr = function() {
                            for (let br = 0; br < Mt; br++)
                                if (Ct.indexOf(br) === -1)
                                    return Ct.push(br),
                                    br;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                            0
                        }();
                        Yt.__bindingPointIndex = sr;
                        const er = Tt.createBuffer()
                          , rr = Yt.__size
                          , xr = Yt.usage;
                        return Tt.bindBuffer(Tt.UNIFORM_BUFFER, er),
                        Tt.bufferData(Tt.UNIFORM_BUFFER, rr, xr),
                        Tt.bindBuffer(Tt.UNIFORM_BUFFER, null),
                        Tt.bindBufferBase(Tt.UNIFORM_BUFFER, sr, er),
                        er
                    }(Wt),
                    ft[Wt.id] = qt,
                    Wt.addEventListener("dispose", jt));
                    const Xt = Qt.program;
                    mt.updateUBOMapping(Wt, Xt);
                    const Zt = tt.render.frame;
                    xt[Wt.id] !== Zt && (function(Yt) {
                        const sr = ft[Yt.id]
                          , er = Yt.uniforms
                          , rr = Yt.__cache;
                        Tt.bindBuffer(Tt.UNIFORM_BUFFER, sr);
                        for (let xr = 0, br = er.length; xr < br; xr++) {
                            const yr = er[xr];
                            if (Lt(yr, xr, rr) === !0) {
                                const Pr = yr.__offset
                                  , zr = Array.isArray(yr.value) ? yr.value : [yr.value];
                                let Nr = 0;
                                for (let Vr = 0; Vr < zr.length; Vr++) {
                                    const Gr = zr[Vr]
                                      , Hr = Nt(Gr);
                                    typeof Gr == "number" ? (yr.__data[0] = Gr,
                                    Tt.bufferSubData(Tt.UNIFORM_BUFFER, Pr + Nr, yr.__data)) : Gr.isMatrix3 ? (yr.__data[0] = Gr.elements[0],
                                    yr.__data[1] = Gr.elements[1],
                                    yr.__data[2] = Gr.elements[2],
                                    yr.__data[3] = Gr.elements[0],
                                    yr.__data[4] = Gr.elements[3],
                                    yr.__data[5] = Gr.elements[4],
                                    yr.__data[6] = Gr.elements[5],
                                    yr.__data[7] = Gr.elements[0],
                                    yr.__data[8] = Gr.elements[6],
                                    yr.__data[9] = Gr.elements[7],
                                    yr.__data[10] = Gr.elements[8],
                                    yr.__data[11] = Gr.elements[0]) : (Gr.toArray(yr.__data, Nr),
                                    Nr += Hr.storage / Float32Array.BYTES_PER_ELEMENT)
                                }
                                Tt.bufferSubData(Tt.UNIFORM_BUFFER, Pr, yr.__data)
                            }
                        }
                        Tt.bindBuffer(Tt.UNIFORM_BUFFER, null)
                    }(Wt),
                    xt[Wt.id] = Zt)
                },
                dispose: function() {
                    for (const Wt in ft)
                        Tt.deleteBuffer(ft[Wt]);
                    Ct = [],
                    ft = {},
                    xt = {}
                }
            }
        }
        class xx {
            constructor(tt={}) {
                const {canvas: lt=Zm(), context: mt=null, depth: ft=!0, stencil: xt=!0, alpha: Ct=!1, antialias: Mt=!1, premultipliedAlpha: Lt=!0, preserveDrawingBuffer: Nt=!1, powerPreference: jt="default", failIfMajorPerformanceCaveat: Wt=!1} = tt;
                let Qt;
                this.isWebGLRenderer = !0,
                Qt = mt !== null ? mt.getContextAttributes().alpha : Ct;
                const qt = new Uint32Array(4)
                  , Xt = new Int32Array(4);
                let Zt = null
                  , Yt = null;
                const sr = []
                  , er = [];
                this.domElement = lt,
                this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                },
                this.autoClear = !0,
                this.autoClearColor = !0,
                this.autoClearDepth = !0,
                this.autoClearStencil = !0,
                this.sortObjects = !0,
                this.clippingPlanes = [],
                this.localClippingEnabled = !1,
                this._outputColorSpace = jo,
                this._useLegacyLights = !1,
                this.toneMapping = Ur,
                this.toneMappingExposure = 1,
                this.userData = {},
                this.onContextLost = () => {}
                ,
                this.onContextRestore = () => {}
                ,
                this.onContextCreationError = () => {}
                ;
                const rr = this;
                let xr = !1
                  , br = 0
                  , yr = 0
                  , Pr = null
                  , zr = -1
                  , Nr = null;
                const Vr = new Lo
                  , Gr = new Lo;
                let Hr = null;
                const _n = new Gn(0);
                let dn = 0
                  , kn = lt.width
                  , Bn = lt.height
                  , cn = 1
                  , Yr = null
                  , Jr = null;
                const sn = new Lo(0,0,kn,Bn)
                  , on = new Lo(0,0,kn,Bn);
                let Un = !1;
                const ro = new Av;
                let Zn = !1
                  , jn = !1
                  , uo = null;
                const Dr = new no
                  , Sr = new mn
                  , Fr = new Er
                  , Wr = {
                    background: null,
                    fog: null,
                    environment: null,
                    overrideMaterial: null,
                    isScene: !0
                };
                function kr() {
                    return Pr === null ? cn : 1
                }
                let _r, Br, Lr, Xr, Kr, An, pn, _o, to, Pn, eo, Kn, po, Ao, Fo, Io, Jn, Co, yl, ho, Qo, Po, Cu, Pu, en = mt;
                function g0(Mr, tn) {
                    for (let an = 0; an < Mr.length; an++) {
                        const un = Mr[an]
                          , yn = lt.getContext(un, tn);
                        if (yn !== null)
                            return yn
                    }
                    return null
                }
                try {
                    const Mr = {
                        alpha: !0,
                        depth: ft,
                        stencil: xt,
                        antialias: Mt,
                        premultipliedAlpha: Lt,
                        preserveDrawingBuffer: Nt,
                        powerPreference: jt,
                        failIfMajorPerformanceCaveat: Wt
                    };
                    if ("setAttribute"in lt && lt.setAttribute("data-engine", `three.js r${h}`),
                    lt.addEventListener("webglcontextlost", F_, !1),
                    lt.addEventListener("webglcontextrestored", ow, !1),
                    lt.addEventListener("webglcontextcreationerror", sw, !1),
                    en === null) {
                        const tn = ["webgl2", "webgl", "experimental-webgl"];
                        if (rr.isWebGL1Renderer === !0 && tn.shift(),
                        en = g0(tn, Mr),
                        en === null)
                            throw g0(tn) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    typeof WebGLRenderingContext < "u" && en instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),
                    en.getShaderPrecisionFormat === void 0 && (en.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }
                    )
                } catch (Mr) {
                    throw console.error("THREE.WebGLRenderer: " + Mr.message),
                    Mr
                }
                function _0() {
                    _r = new kw(en),
                    Br = new Pw(en,_r,tt),
                    _r.init(Br),
                    Po = new _x(en,_r,Br),
                    Lr = new J1(en,_r,Br),
                    Xr = new Lw(en),
                    Kr = new z1,
                    An = new Z1(en,_r,Lr,Kr,Br,Po,Xr),
                    pn = new Rw(rr),
                    _o = new Iw(rr),
                    to = new Sw(en,Br),
                    Cu = new Tw(en,_r,to,Br),
                    Pn = new Dw(en,to,Xr,Cu),
                    eo = new Uw(en,Pn,to,Xr),
                    yl = new Fw(en,Br,An),
                    Io = new Mw(Kr),
                    Kn = new G1(rr,pn,_o,_r,Br,Cu,Io),
                    po = new rS(rr,Kr),
                    Ao = new Q1,
                    Fo = new Y1(_r,Br),
                    Co = new Ew(rr,pn,_o,Lr,eo,Qt,Lt),
                    Jn = new K1(rr,eo,Br),
                    Pu = new nS(en,Xr,Br,Lr),
                    ho = new Cw(en,_r,Xr,Br),
                    Qo = new Bw(en,_r,Xr,Br),
                    Xr.programs = Kn.programs,
                    rr.capabilities = Br,
                    rr.extensions = _r,
                    rr.properties = Kr,
                    rr.renderLists = Ao,
                    rr.shadowMap = Jn,
                    rr.state = Lr,
                    rr.info = Xr,
                    rr.background = Co,
                    rr.cubemaps = pn,
                    rr.cubeuvmaps = _o,
                    rr.materials = po
                }
                _0();
                const Bs = new tS(rr,en);
                function F_(Mr) {
                    Mr.preventDefault(),
                    console.log("THREE.WebGLRenderer: Context Lost."),
                    xr = !0,
                    rr.onContextLost(Mr)
                }
                function ow() {
                    console.log("THREE.WebGLRenderer: Context Restored."),
                    xr = !1;
                    const Mr = rr.info ? rr.info.autoReset : void 0
                      , tn = Jn.enabled
                      , an = Jn.autoUpdate
                      , un = Jn.needsUpdate
                      , yn = Jn.type;
                    _0(),
                    rr.info && Mr !== void 0 && (rr.info.autoReset = Mr),
                    Jn.enabled = tn,
                    Jn.autoUpdate = an,
                    Jn.needsUpdate = un,
                    Jn.type = yn,
                    rr.onContextRestore && rr.onContextRestore()
                }
                function sw(Mr) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", Mr.statusMessage),
                    rr.onContextCreationError(Mr)
                }
                function aw(Mr) {
                    const tn = Mr.target;
                    tn.removeEventListener("dispose", aw),
                    function(an) {
                        (function(un) {
                            const yn = Kr.get(un).programs;
                            yn !== void 0 && (yn.forEach(function(On) {
                                Kn.releaseProgram(On)
                            }),
                            un.isShaderMaterial && Kn.releaseShaderCache(un))
                        }
                        )(an),
                        Kr.remove(an)
                    }(tn)
                }
                this.xr = Bs,
                this.getContext = function() {
                    return en
                }
                ,
                this.getContextAttributes = function() {
                    return en.getContextAttributes()
                }
                ,
                this.forceContextLoss = function() {
                    const Mr = _r.get("WEBGL_lose_context");
                    Mr && Mr.loseContext()
                }
                ,
                this.forceContextRestore = function() {
                    const Mr = _r.get("WEBGL_lose_context");
                    Mr && Mr.restoreContext()
                }
                ,
                this.getPixelRatio = function() {
                    return cn
                }
                ,
                this.setPixelRatio = function(Mr) {
                    Mr !== void 0 && (cn = Mr,
                    this.setSize(kn, Bn, !1))
                }
                ,
                this.getSize = function(Mr) {
                    return Mr.set(kn, Bn)
                }
                ,
                this.setSize = function(Mr, tn, an=!0) {
                    Bs.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (kn = Mr,
                    Bn = tn,
                    lt.width = Math.floor(Mr * cn),
                    lt.height = Math.floor(tn * cn),
                    an === !0 && (lt.style.width = Mr + "px",
                    lt.style.height = tn + "px"),
                    this.setViewport(0, 0, Mr, tn))
                }
                ,
                this.getDrawingBufferSize = function(Mr) {
                    return Mr.set(kn * cn, Bn * cn).floor()
                }
                ,
                this.setDrawingBufferSize = function(Mr, tn, an) {
                    kn = Mr,
                    Bn = tn,
                    cn = an,
                    lt.width = Math.floor(Mr * an),
                    lt.height = Math.floor(tn * an),
                    this.setViewport(0, 0, Mr, tn)
                }
                ,
                this.getCurrentViewport = function(Mr) {
                    return Mr.copy(Vr)
                }
                ,
                this.getViewport = function(Mr) {
                    return Mr.copy(sn)
                }
                ,
                this.setViewport = function(Mr, tn, an, un) {
                    Mr.isVector4 ? sn.set(Mr.x, Mr.y, Mr.z, Mr.w) : sn.set(Mr, tn, an, un),
                    Lr.viewport(Vr.copy(sn).multiplyScalar(cn).floor())
                }
                ,
                this.getScissor = function(Mr) {
                    return Mr.copy(on)
                }
                ,
                this.setScissor = function(Mr, tn, an, un) {
                    Mr.isVector4 ? on.set(Mr.x, Mr.y, Mr.z, Mr.w) : on.set(Mr, tn, an, un),
                    Lr.scissor(Gr.copy(on).multiplyScalar(cn).floor())
                }
                ,
                this.getScissorTest = function() {
                    return Un
                }
                ,
                this.setScissorTest = function(Mr) {
                    Lr.setScissorTest(Un = Mr)
                }
                ,
                this.setOpaqueSort = function(Mr) {
                    Yr = Mr
                }
                ,
                this.setTransparentSort = function(Mr) {
                    Jr = Mr
                }
                ,
                this.getClearColor = function(Mr) {
                    return Mr.copy(Co.getClearColor())
                }
                ,
                this.setClearColor = function() {
                    Co.setClearColor.apply(Co, arguments)
                }
                ,
                this.getClearAlpha = function() {
                    return Co.getClearAlpha()
                }
                ,
                this.setClearAlpha = function() {
                    Co.setClearAlpha.apply(Co, arguments)
                }
                ,
                this.clear = function(Mr=!0, tn=!0, an=!0) {
                    let un = 0;
                    if (Mr) {
                        let yn = !1;
                        if (Pr !== null) {
                            const On = Pr.texture.format;
                            yn = On === ko || On === yo || On === Ks
                        }
                        if (yn) {
                            const On = Pr.texture.type
                              , To = On === $n || On === Yo || On === Zo || On === Ps || On === $l || On === wl
                              , _i = Co.getClearColor()
                              , fo = Co.getClearAlpha()
                              , wo = _i.r
                              , So = _i.g
                              , so = _i.b;
                            To ? (qt[0] = wo,
                            qt[1] = So,
                            qt[2] = so,
                            qt[3] = fo,
                            en.clearBufferuiv(en.COLOR, 0, qt)) : (Xt[0] = wo,
                            Xt[1] = So,
                            Xt[2] = so,
                            Xt[3] = fo,
                            en.clearBufferiv(en.COLOR, 0, Xt))
                        } else
                            un |= en.COLOR_BUFFER_BIT
                    }
                    tn && (un |= en.DEPTH_BUFFER_BIT),
                    an && (un |= en.STENCIL_BUFFER_BIT),
                    en.clear(un)
                }
                ,
                this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }
                ,
                this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }
                ,
                this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }
                ,
                this.dispose = function() {
                    lt.removeEventListener("webglcontextlost", F_, !1),
                    lt.removeEventListener("webglcontextrestored", ow, !1),
                    lt.removeEventListener("webglcontextcreationerror", sw, !1),
                    Ao.dispose(),
                    Fo.dispose(),
                    Kr.dispose(),
                    pn.dispose(),
                    _o.dispose(),
                    eo.dispose(),
                    Cu.dispose(),
                    Pu.dispose(),
                    Kn.dispose(),
                    Bs.dispose(),
                    Bs.removeEventListener("sessionstart", lw),
                    Bs.removeEventListener("sessionend", cw),
                    uo && (uo.dispose(),
                    uo = null),
                    Fp.stop()
                }
                ,
                this.renderBufferDirect = function(Mr, tn, an, un, yn, On) {
                    tn === null && (tn = Wr);
                    const To = yn.isMesh && yn.matrixWorld.determinant() < 0
                      , _i = function(ns, Al, Xs, io, Jo) {
                        Al.isScene !== !0 && (Al = Wr),
                        An.resetTextureUnits();
                        const U_ = Al.fog
                          , xE = io.userData && io.userData.envMapSlotKey && Al.textureSlots && Al.textureSlots[io.userData.envMapSlotKey] ? Al.textureSlots[io.userData.envMapSlotKey] : io.isMeshStandardMaterial ? Al.environment : null
                          , bE = Pr === null ? rr.outputColorSpace : Pr.isXRRenderTarget === !0 || Pr.texture.colorSpace && Pr.texture.colorSpace !== jo ? Pr.texture.colorSpace : Xo
                          , b0 = (io.isMeshStandardMaterial ? _o : pn).get(io.envMap || xE)
                          , AE = io.vertexColors === !0 && !!Xs.attributes.color && Xs.attributes.color.itemSize === 4
                          , wE = !!Xs.attributes.tangent && (!!io.normalMap || io.anisotropy > 0 || Xs.userData.__forceUseTangent)
                          , SE = !!Xs.morphAttributes.position
                          , EE = !!Xs.morphAttributes.normal
                          , TE = !!Xs.morphAttributes.color;
                        let mw = Ur;
                        io.toneMapped && (Pr !== null && Pr.isXRRenderTarget !== !0 || (mw = rr.toneMapping));
                        const fw = Xs.morphAttributes.position || Xs.morphAttributes.normal || Xs.morphAttributes.color
                          , CE = fw !== void 0 ? fw.length : 0
                          , Uo = Kr.get(io)
                          , PE = Yt.state.lights;
                        if (Zn === !0 && (jn === !0 || ns !== Nr)) {
                            const zs = ns === Nr && io.id === zr;
                            Io.setState(io, ns, zs)
                        }
                        let Mu = !1;
                        io.version === Uo.__version ? Uo.needsLights && Uo.lightsStateVersion !== PE.state.version || Uo.outputColorSpace !== bE || Jo.isInstancedMesh && Uo.instancing === !1 ? Mu = !0 : Jo.isInstancedMesh || Uo.instancing !== !0 ? Jo.isSkinnedMesh && Uo.skinning === !1 ? Mu = !0 : Jo.isSkinnedMesh || Uo.skinning !== !0 ? Jo.isInstancedMesh && Uo.instancingColor === !0 && Jo.instanceColor === null || Jo.isInstancedMesh && Uo.instancingColor === !1 && Jo.instanceColor !== null || Uo.envMap !== b0 || io.fog === !0 && Uo.fog !== U_ ? Mu = !0 : Uo.numClippingPlanes === void 0 || Uo.numClippingPlanes === Io.numPlanes && Uo.numIntersection === Io.numIntersection ? (Uo.vertexAlphas !== AE || Uo.vertexTangents !== wE || Uo.morphTargets !== SE || Uo.morphNormals !== EE || Uo.morphColors !== TE || Uo.toneMapping !== mw || Br.isWebGL2 === !0 && Uo.morphTargetsCount !== CE) && (Mu = !0) : Mu = !0 : Mu = !0 : Mu = !0 : (Mu = !0,
                        Uo.__version = io.version);
                        let Up = Uo.currentProgram;
                        Mu === !0 && (Up = x0(io, Al, Jo));
                        let gw = !1
                          , j_ = !1
                          , Iy = !1;
                        const Ls = Up.getUniforms()
                          , jp = Uo.uniforms;
                        if (Lr.useProgram(Up.program) && (gw = !0,
                        j_ = !0,
                        Iy = !0),
                        io.id !== zr && (zr = io.id,
                        j_ = !0),
                        gw || Nr !== ns) {
                            Ls.setValue(en, "projectionMatrix", ns.projectionMatrix),
                            Ls.setValue(en, "viewMatrix", ns.matrixWorldInverse);
                            const zs = Ls.map.cameraPosition;
                            zs !== void 0 && zs.setValue(en, Fr.setFromMatrixPosition(ns.matrixWorld)),
                            Br.logarithmicDepthBuffer && Ls.setValue(en, "logDepthBufFC", 2 / (Math.log(ns.far + 1) / Math.LN2)),
                            (io.isMeshPhongMaterial || io.isMeshToonMaterial || io.isMeshLambertMaterial || io.isMeshBasicMaterial || io.isMeshStandardMaterial || io.isShaderMaterial) && Ls.setValue(en, "isOrthographic", ns.isOrthographicCamera === !0),
                            Nr !== ns && (Nr = ns,
                            j_ = !0,
                            Iy = !0)
                        }
                        if (Jo.isSkinnedMesh) {
                            Ls.setOptional(en, Jo, "bindMatrix"),
                            Ls.setOptional(en, Jo, "bindMatrixInverse");
                            const zs = Jo.skeleton;
                            zs && (Br.floatVertexTextures ? (zs.boneTexture === null && zs.computeBoneTexture(),
                            Ls.setValue(en, "boneTexture", zs.boneTexture, An),
                            Ls.setValue(en, "boneTextureSize", zs.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                        }
                        const ky = Xs.morphAttributes;
                        var au, Wl;
                        (ky.position !== void 0 || ky.normal !== void 0 || ky.color !== void 0 && Br.isWebGL2 === !0) && yl.update(Jo, Xs, Up),
                        (j_ || Uo.receiveShadow !== Jo.receiveShadow) && (Uo.receiveShadow = Jo.receiveShadow,
                        Ls.setValue(en, "receiveShadow", Jo.receiveShadow)),
                        io.isMeshGouraudMaterial && io.envMap !== null && (jp.envMap.value = b0,
                        jp.flipEnvMap.value = b0.isCubeTexture && b0.isRenderTargetTexture === !1 ? -1 : 1),
                        j_ && (Ls.setValue(en, "toneMappingExposure", rr.toneMappingExposure),
                        Uo.needsLights && (Wl = Iy,
                        (au = jp).ambientLightColor.needsUpdate = Wl,
                        au.lightProbe.needsUpdate = Wl,
                        au.directionalLights.needsUpdate = Wl,
                        au.directionalLightShadows.needsUpdate = Wl,
                        au.pointLights.needsUpdate = Wl,
                        au.pointLightShadows.needsUpdate = Wl,
                        au.spotLights.needsUpdate = Wl,
                        au.spotLightShadows.needsUpdate = Wl,
                        au.rectAreaLights.needsUpdate = Wl,
                        au.hemisphereLights.needsUpdate = Wl),
                        U_ && io.fog === !0 && po.refreshFogUniforms(jp, U_),
                        po.refreshMaterialUniforms(jp, io, cn, Bn, rr.userData.transmissionRenderTarget || uo),
                        Cv.upload(en, Uo.uniformsList, jp, An)),
                        io.isShaderMaterial && io.uniformsNeedUpdate === !0 && (Cv.upload(en, Uo.uniformsList, jp, An),
                        io.uniformsNeedUpdate = !1),
                        io.isSpriteMaterial && Ls.setValue(en, "center", Jo.center),
                        Ls.setValue(en, "modelViewMatrix", Jo.modelViewMatrix),
                        Ls.setValue(en, "normalMatrix", Jo.normalMatrix),
                        Ls.setValue(en, "modelMatrix", Jo.matrixWorld);
                        const _w = io.extraUniformsToUpload;
                        if (_w && Object.entries(_w).forEach( ([zs,V_]) => Ls.setValue(en, zs, V_.value, An)),
                        io.isShaderMaterial || io.isRawShaderMaterial) {
                            const zs = io.uniformsGroups;
                            for (let V_ = 0, ME = zs.length; V_ < ME; V_++)
                                if (Br.isWebGL2) {
                                    const yw = zs[V_];
                                    Pu.update(yw, Up),
                                    Pu.bind(yw, Up)
                                } else
                                    console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
                        }
                        return Up
                    }(Mr, tn, an, un, yn);
                    Lr.setMaterial(un, To);
                    let fo = an.index
                      , wo = 1;
                    if (un.wireframe === !0) {
                        if (fo = Pn.getWireframeAttribute(an),
                        fo === void 0)
                            return;
                        wo = 2
                    }
                    const So = an.drawRange
                      , so = an.attributes.position;
                    let _s = So.start * wo
                      , xl = (So.start + So.count) * wo;
                    On !== null && (_s = Math.max(_s, On.start * wo),
                    xl = Math.min(xl, (On.start + On.count) * wo)),
                    fo !== null ? (_s = Math.max(_s, 0),
                    xl = Math.min(xl, fo.count)) : so != null && (_s = Math.max(_s, 0),
                    xl = Math.min(xl, so.count));
                    const vs = xl - _s;
                    if (vs < 0 || vs === 1 / 0)
                        return;
                    let ip;
                    Cu.setup(yn, un, _i, an, fo);
                    let ls = ho;
                    if (fo !== null && (ip = to.get(fo),
                    ls = Qo,
                    ls.setIndex(ip)),
                    yn.isMesh)
                        un.wireframe === !0 ? (Lr.setLineWidth(un.wireframeLinewidth * kr()),
                        ls.setMode(en.LINES)) : ls.setMode(en.TRIANGLES);
                    else if (yn.isLine) {
                        let ns = un.linewidth;
                        ns === void 0 && (ns = 1),
                        Lr.setLineWidth(ns * kr()),
                        yn.isLineSegments ? ls.setMode(en.LINES) : yn.isLineLoop ? ls.setMode(en.LINE_LOOP) : ls.setMode(en.LINE_STRIP)
                    } else
                        yn.isPoints ? ls.setMode(en.POINTS) : yn.isSprite && ls.setMode(en.TRIANGLES);
                    if (yn.isInstancedMesh)
                        ls.renderInstances(_s, vs, yn.count);
                    else if (an.isInstancedBufferGeometry) {
                        const ns = an._maxInstanceCount !== void 0 ? an._maxInstanceCount : 1 / 0
                          , Al = Math.min(an.instanceCount, ns);
                        ls.renderInstances(_s, vs, Al)
                    } else
                        ls.render(_s, vs)
                }
                ,
                this.compile = function(Mr, tn) {
                    function an(un, yn, On) {
                        un.transparent === !0 && un.side === St && un.forceSinglePass === !1 ? (un.side = bt,
                        un.needsUpdate = !0,
                        x0(un, yn, On),
                        un.side = vt,
                        un.needsUpdate = !0,
                        x0(un, yn, On),
                        un.side = St) : x0(un, yn, On)
                    }
                    Yt = Fo.get(Mr),
                    Yt.init(),
                    er.push(Yt),
                    Mr.traverseVisible(function(un) {
                        un.isLight && un.layers.test(tn.layers) && (Yt.pushLight(un),
                        un.castShadow && Yt.pushShadow(un))
                    }),
                    Yt.setupLights(rr._useLegacyLights),
                    Mr.traverse(function(un) {
                        const yn = un.material;
                        if (yn)
                            if (Array.isArray(yn))
                                for (let On = 0; On < yn.length; On++)
                                    an(yn[On], Mr, un);
                            else
                                an(yn, Mr, un)
                    }),
                    er.pop(),
                    Yt = null
                }
                ;
                let Ry = null;
                function lw() {
                    Fp.stop()
                }
                function cw() {
                    Fp.start()
                }
                const Fp = new Hy;
                function uw(Mr, tn, an, un) {
                    if (Mr.visible === !1)
                        return;
                    if (Mr.layers.test(tn.layers)) {
                        if (Mr.isGroup)
                            an = Mr.renderOrder;
                        else if (Mr.isLOD)
                            Mr.autoUpdate === !0 && Mr.update(tn);
                        else if (Mr.isLight)
                            Yt.pushLight(Mr),
                            Mr.castShadow && Yt.pushShadow(Mr);
                        else if (Mr.isSprite) {
                            if (!Mr.frustumCulled || ro.intersectsSprite(Mr)) {
                                un && Fr.setFromMatrixPosition(Mr.matrixWorld).applyMatrix4(Dr);
                                const On = eo.update(Mr)
                                  , To = Mr.material;
                                To.visible && Zt.push(Mr, On, To, an, Fr.z, null)
                            }
                        } else if ((Mr.isMesh || Mr.isLine || Mr.isPoints) && (!Mr.frustumCulled || ro.intersectsObject(Mr))) {
                            const On = eo.update(Mr)
                              , To = Mr.material;
                            if (un && (Mr.boundingSphere !== void 0 ? (Mr.boundingSphere === null && Mr.computeBoundingSphere(),
                            Fr.copy(Mr.boundingSphere.center)) : (On.boundingSphere === null && On.computeBoundingSphere(),
                            Fr.copy(On.boundingSphere.center)),
                            Fr.applyMatrix4(Mr.matrixWorld).applyMatrix4(Dr)),
                            Array.isArray(To)) {
                                const _i = On.groups;
                                for (let fo = 0, wo = _i.length; fo < wo; fo++) {
                                    const So = _i[fo]
                                      , so = To[So.materialIndex];
                                    so && so.visible && Zt.push(Mr, On, so, an, Fr.z, So)
                                }
                            } else
                                To.visible && Zt.push(Mr, On, To, an, Fr.z, null)
                        }
                    }
                    const yn = Mr.children;
                    for (let On = 0, To = yn.length; On < To; On++)
                        uw(yn[On], tn, an, un)
                }
                function dw(Mr, tn, an, un) {
                    const yn = Mr.opaque
                      , On = Mr.transmissive
                      , To = Mr.transparent;
                    if (Yt.setupLightsView(an),
                    Zn === !0 && Io.setGlobalState(rr.clippingPlanes, an),
                    rr.userData.transmissionRender === void 0 && rr.userData.renderTransmissionPass !== !1 && On.length > 0 && function(_i, fo, wo, So) {
                        console.warn("three.js internal render transmission pass should not be called");
                        const so = Br.isWebGL2;
                        uo === null && (uo = new Rs(1,1,{
                            generateMipmaps: !0,
                            type: _r.has("EXT_color_buffer_half_float") ? Os : $n,
                            minFilter: vo,
                            samples: so ? 4 : 0
                        })),
                        rr.getDrawingBufferSize(Sr),
                        so ? uo.setSize(Sr.x, Sr.y) : uo.setSize(gp(Sr.x), gp(Sr.y));
                        const _s = rr.getRenderTarget();
                        rr.setRenderTarget(uo),
                        rr.getClearColor(_n),
                        dn = rr.getClearAlpha(),
                        dn < 1 && rr.setClearColor(16777215, .5),
                        rr.clear();
                        const xl = rr.toneMapping;
                        rr.toneMapping = Ur,
                        y0(_i, wo, So),
                        An.updateMultisampleRenderTarget(uo),
                        An.updateRenderTargetMipmap(uo);
                        let vs = !1;
                        for (let ip = 0, ls = fo.length; ip < ls; ip++) {
                            const ns = fo[ip]
                              , Al = ns.object
                              , Xs = ns.geometry
                              , io = ns.material
                              , Jo = ns.group;
                            if (io.side === St && Al.layers.test(So.layers)) {
                                const U_ = io.side;
                                io.side = bt,
                                io.needsUpdate = !0,
                                pw(Al, wo, So, Xs, io, Jo),
                                io.side = U_,
                                io.needsUpdate = !0,
                                vs = !0
                            }
                        }
                        vs === !0 && (An.updateMultisampleRenderTarget(uo),
                        An.updateRenderTargetMipmap(uo)),
                        rr.setRenderTarget(_s),
                        rr.setClearColor(_n, dn),
                        rr.toneMapping = xl
                    }([...yn, ...To], On, tn, an),
                    un && Lr.viewport(Vr.copy(un)),
                    rr.userData.opaqueRender !== !1 && yn.length > 0 && y0(yn, tn, an),
                    rr.userData.transparentRender !== !1 && To.length > 0 && y0(To, tn, an),
                    rr.userData.transmissionRender !== !1 && On.length > 0) {
                        uo || (uo = new Rs(1,1));
                        const _i = (rr.userData.transmissionRenderTarget || uo).texture
                          , fo = Br.isWebGL2
                          , wo = _i.generateMipmaps
                          , So = _i.minFilter;
                        fo && rr.userData.blurTransmissionTarget && rr.userData.transmissionRenderTarget && (_i.generateMipmaps = !0,
                        _i.minFilter = vo,
                        _i.needsUpdate = !0,
                        An.updateMultisampleRenderTarget(rr.userData.transmissionRenderTarget),
                        An.updateRenderTargetMipmap(rr.userData.transmissionRenderTarget)),
                        y0(On, tn, an),
                        fo && rr.userData.blurTransmissionTarget && rr.userData.transmissionRenderTarget && (_i.generateMipmaps = wo,
                        _i.minFilter = So,
                        _i.needsUpdate = !0,
                        An.updateMultisampleRenderTarget(rr.userData.transmissionRenderTarget),
                        An.updateRenderTargetMipmap(rr.userData.transmissionRenderTarget))
                    }
                    Lr.buffers.depth.setTest(!0),
                    Lr.buffers.depth.setMask(!0),
                    Lr.buffers.color.setMask(!0),
                    Lr.setPolygonOffset(!1)
                }
                function y0(Mr, tn, an) {
                    const un = {
                        ...rr.userData
                    };
                    rr.userData.opaqueRender = void 0,
                    rr.userData.transparentRender = void 0,
                    rr.userData.transmissionRender = void 0,
                    rr.userData.backgroundRender = void 0;
                    const yn = tn.isScene === !0 ? tn.overrideMaterial : null;
                    for (let On = 0, To = Mr.length; On < To; On++) {
                        const _i = Mr[On]
                          , fo = _i.object
                          , wo = _i.geometry
                          , So = yn === null ? _i.material : yn
                          , so = _i.group;
                        fo.layers.test(an.layers) && pw(fo, tn, an, wo, So, so)
                    }
                    Object.assign(rr.userData, un)
                }
                function pw(Mr, tn, an, un, yn, On) {
                    Mr.onBeforeRender(rr, tn, an, un, yn, On),
                    Mr.modelViewMatrix.multiplyMatrices(an.matrixWorldInverse, Mr.matrixWorld),
                    Mr.normalMatrix.getNormalMatrix(Mr.modelViewMatrix),
                    yn.onBeforeRender(rr, tn, an, un, Mr, On),
                    yn.transparent === !0 && yn.side === St && yn.forceSinglePass === !1 ? (yn.side = bt,
                    yn.needsUpdate = !0,
                    rr.renderBufferDirect(an, tn, un, yn, Mr, On),
                    yn.side = vt,
                    yn.needsUpdate = !0,
                    rr.renderBufferDirect(an, tn, un, yn, Mr, On),
                    yn.side = St) : rr.renderBufferDirect(an, tn, un, yn, Mr, On),
                    Mr.onAfterRender(rr, tn, an, un, yn, On),
                    yn.onAfterRender(rr, tn, an, un, Mr, On)
                }
                function x0(Mr, tn, an) {
                    tn.isScene !== !0 && (tn = Wr);
                    const un = Kr.get(Mr)
                      , yn = Yt.state.lights
                      , On = Yt.state.shadowsArray
                      , To = yn.state.version
                      , _i = Kn.getParameters(Mr, yn.state, On, tn, an)
                      , fo = Kn.getProgramCacheKey(_i);
                    let wo = un.programs;
                    un.environment = Mr.userData && Mr.userData.envMapSlotKey && tn.textureSlots && tn.textureSlots[Mr.userData.envMapSlotKey] ? tn.textureSlots[Mr.userData.envMapSlotKey] : Mr.isMeshStandardMaterial ? tn.environment : null,
                    un.fog = tn.fog,
                    un.envMap = (Mr.isMeshStandardMaterial ? _o : pn).get(Mr.envMap || un.environment),
                    wo === void 0 && (Mr.addEventListener("dispose", aw),
                    wo = new Map,
                    un.programs = wo);
                    let So = wo.get(fo);
                    if (So !== void 0) {
                        if (un.currentProgram === So && un.lightsStateVersion === To)
                            return hw(Mr, _i),
                            So
                    } else
                        _i.uniforms = Kn.getUniforms(Mr),
                        Mr.onBuild(an, _i, rr),
                        Mr.onBeforeCompile(_i, rr),
                        So = Kn.acquireProgram(_i, fo),
                        wo.set(fo, So),
                        un.uniforms = _i.uniforms;
                    const so = un.uniforms;
                    (Mr.isShaderMaterial || Mr.isRawShaderMaterial) && Mr.clipping !== !0 || (so.clippingPlanes = Io.uniform),
                    hw(Mr, _i),
                    un.needsLights = function(vs) {
                        return vs.isMeshLambertMaterial || vs.isMeshToonMaterial || vs.isMeshPhongMaterial || vs.isMeshStandardMaterial || vs.isShadowMaterial || vs.isShaderMaterial && vs.lights === !0
                    }(Mr),
                    un.lightsStateVersion = To,
                    un.needsLights && (so.ambientLightColor.value = yn.state.ambient,
                    so.lightProbe.value = yn.state.probe,
                    so.directionalLights.value = yn.state.directional,
                    so.directionalLightShadows.value = yn.state.directionalShadow,
                    so.spotLights.value = yn.state.spot,
                    so.spotLightShadows.value = yn.state.spotShadow,
                    so.rectAreaLights.value = yn.state.rectArea,
                    so.ltc_1.value = yn.state.rectAreaLTC1,
                    so.ltc_2.value = yn.state.rectAreaLTC2,
                    so.pointLights.value = yn.state.point,
                    so.pointLightShadows.value = yn.state.pointShadow,
                    so.hemisphereLights.value = yn.state.hemi,
                    so.directionalShadowMap.value = yn.state.directionalShadowMap,
                    so.directionalShadowMatrix.value = yn.state.directionalShadowMatrix,
                    so.spotShadowMap.value = yn.state.spotShadowMap,
                    so.spotLightMatrix.value = yn.state.spotLightMatrix,
                    so.spotLightMap.value = yn.state.spotLightMap,
                    so.pointShadowMap.value = yn.state.pointShadowMap,
                    so.pointShadowMatrix.value = yn.state.pointShadowMatrix);
                    const _s = So.getUniforms()
                      , xl = Cv.seqWithValue(_s.seq, so);
                    return un.currentProgram = So,
                    un.uniformsList = xl,
                    So
                }
                function hw(Mr, tn) {
                    const an = Kr.get(Mr);
                    an.outputColorSpace = tn.outputColorSpace,
                    an.instancing = tn.instancing,
                    an.instancingColor = tn.instancingColor,
                    an.skinning = tn.skinning,
                    an.morphTargets = tn.morphTargets,
                    an.morphNormals = tn.morphNormals,
                    an.morphColors = tn.morphColors,
                    an.morphTargetsCount = tn.morphTargetsCount,
                    an.numClippingPlanes = tn.numClippingPlanes,
                    an.numIntersection = tn.numClipIntersection,
                    an.vertexAlphas = tn.vertexAlphas,
                    an.vertexTangents = tn.vertexTangents,
                    an.toneMapping = tn.toneMapping
                }
                Fp.setAnimationLoop(function(Mr) {
                    Ry && Ry(Mr)
                }),
                typeof self < "u" && Fp.setContext(self),
                this.setAnimationLoop = function(Mr) {
                    Ry = Mr,
                    Bs.setAnimationLoop(Mr),
                    Mr === null ? Fp.stop() : Fp.start()
                }
                ,
                Bs.addEventListener("sessionstart", lw),
                Bs.addEventListener("sessionend", cw),
                this.render = function(Mr, tn) {
                    if (tn === void 0 || tn.isCamera === !0) {
                        if (xr !== !0) {
                            if (Mr.matrixWorldAutoUpdate === !0 && Mr.updateMatrixWorld(),
                            tn.parent === null && tn.matrixWorldAutoUpdate === !0 && tn.updateMatrixWorld(),
                            Bs.enabled === !0 && Bs.isPresenting === !0 && (Bs.cameraAutoUpdate === !0 && Bs.updateCamera(tn),
                            tn = Bs.getCamera()),
                            Mr.isScene === !0 && Mr.onBeforeRender(rr, Mr, tn, Pr),
                            Yt = Fo.get(Mr, er.length),
                            Yt.init(),
                            er.push(Yt),
                            Dr.multiplyMatrices(tn.projectionMatrix, tn.matrixWorldInverse),
                            ro.setFromProjectionMatrix(Dr),
                            jn = this.localClippingEnabled,
                            Zn = Io.init(this.clippingPlanes, jn),
                            Zt = Ao.get(Mr, sr.length),
                            Zt.init(),
                            sr.push(Zt),
                            uw(Mr, tn, 0, rr.sortObjects),
                            Zt.finish(),
                            rr.sortObjects === !0 && Zt.sort(Yr, Jr),
                            this.info.render.frame++,
                            rr.userData.shadowMapRender !== !1) {
                                Zn === !0 && Io.beginShadows();
                                const an = Yt.state.shadowsArray;
                                an.length > 0 && Jn.render(an, Mr, tn),
                                Zn === !0 && Io.endShadows()
                            }
                            if (this.info.autoReset === !0 && this.info.reset(),
                            rr.userData.backgroundRender !== !1 && Co.render(Zt, Mr),
                            rr.userData.sceneRender !== !1)
                                if (Yt.setupLights(rr._useLegacyLights),
                                tn.isArrayCamera) {
                                    const an = tn.cameras;
                                    for (let un = 0, yn = an.length; un < yn; un++) {
                                        const On = an[un];
                                        dw(Zt, Mr, On, On.viewport)
                                    }
                                } else
                                    dw(Zt, Mr, tn);
                            Pr !== null && (An.updateMultisampleRenderTarget(Pr),
                            An.updateRenderTargetMipmap(Pr)),
                            Mr.isScene === !0 && Mr.onAfterRender(rr, Mr, tn),
                            Cu.resetDefaultState(),
                            zr = -1,
                            Nr = null,
                            er.pop(),
                            Yt = er.length > 0 ? er[er.length - 1] : null,
                            sr.pop(),
                            Zt = sr.length > 0 ? sr[sr.length - 1] : null
                        }
                    } else
                        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }
                ,
                this.getActiveCubeFace = function() {
                    return br
                }
                ,
                this.getActiveMipmapLevel = function() {
                    return yr
                }
                ,
                this.getRenderTarget = function() {
                    return Pr
                }
                ,
                this.setRenderTargetTextures = function(Mr, tn, an) {
                    Kr.get(Mr.texture).__webglTexture = tn,
                    Kr.get(Mr.depthTexture).__webglTexture = an;
                    const un = Kr.get(Mr);
                    un.__hasExternalTextures = !0,
                    un.__hasExternalTextures && (un.__autoAllocateDepthBuffer = an === void 0,
                    un.__autoAllocateDepthBuffer || _r.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
                    un.__useRenderToTexture = !1))
                }
                ,
                this.setRenderTargetFramebuffer = function(Mr, tn) {
                    const an = Kr.get(Mr);
                    an.__webglFramebuffer = tn,
                    an.__useDefaultFramebuffer = tn === void 0
                }
                ,
                this.setRenderTarget = function(Mr, tn=0, an=0) {
                    Pr = Mr,
                    br = tn,
                    yr = an;
                    let un = !0
                      , yn = null
                      , On = !1
                      , To = !1;
                    if (Mr) {
                        const _i = Kr.get(Mr);
                        _i.__useDefaultFramebuffer !== void 0 ? (Lr.bindFramebuffer(en.FRAMEBUFFER, null),
                        un = !1) : _i.__webglFramebuffer === void 0 ? An.setupRenderTarget(Mr) : _i.__hasExternalTextures && An.rebindTextures(Mr, Kr.get(Mr.texture).__webglTexture, Kr.get(Mr.depthTexture).__webglTexture);
                        const fo = Mr.texture;
                        (fo.isData3DTexture || fo.isDataArrayTexture || fo.isCompressedArrayTexture) && (To = !0);
                        const wo = Kr.get(Mr).__webglFramebuffer;
                        Mr.isWebGLCubeRenderTarget ? (yn = Array.isArray(wo[tn]) ? wo[tn][an] : wo[tn],
                        On = !0) : yn = Br.isWebGL2 && Mr.samples > 0 && An.useMultisampledRTT(Mr) === !1 ? Kr.get(Mr).__webglMultisampledFramebuffer : Array.isArray(wo) ? wo[an] : wo,
                        Vr.copy(Mr.viewport),
                        Gr.copy(Mr.scissor),
                        Hr = Mr.scissorTest
                    } else
                        Vr.copy(sn).multiplyScalar(cn).floor(),
                        Gr.copy(on).multiplyScalar(cn).floor(),
                        Hr = Un;
                    if (Lr.bindFramebuffer(en.FRAMEBUFFER, yn) && Br.drawBuffers && un && Lr.drawBuffers(Mr, yn),
                    Lr.viewport(Vr),
                    Lr.scissor(Gr),
                    Lr.setScissorTest(Hr),
                    On) {
                        const _i = Kr.get(Mr.texture);
                        en.framebufferTexture2D(en.FRAMEBUFFER, en.COLOR_ATTACHMENT0, en.TEXTURE_CUBE_MAP_POSITIVE_X + tn, _i.__webglTexture, an)
                    } else if (To) {
                        const _i = Kr.get(Mr.texture)
                          , fo = tn || 0;
                        en.framebufferTextureLayer(en.FRAMEBUFFER, en.COLOR_ATTACHMENT0, _i.__webglTexture, an || 0, fo)
                    }
                    zr = -1
                }
                ,
                this.readRenderTargetPixels = function(Mr, tn, an, un, yn, On, To, _i) {
                    if (!Mr || !Mr.isWebGLRenderTarget)
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let fo = Kr.get(Mr).__webglFramebuffer;
                    if (Mr.isWebGLCubeRenderTarget && To !== void 0 && (fo = fo[To]),
                    fo) {
                        Lr.bindFramebuffer(en.FRAMEBUFFER, fo);
                        try {
                            const wo = Array.isArray(Mr.texture) ? Mr.texture[_i || 0] : Mr.texture
                              , So = wo.format
                              , so = wo.type;
                            if (So !== as && Po.convert(So) !== en.getParameter(en.IMPLEMENTATION_COLOR_READ_FORMAT))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const _s = so === Os && (_r.has("EXT_color_buffer_half_float") || Br.isWebGL2 && _r.has("EXT_color_buffer_float"));
                            if (!(so === $n || Po.convert(so) === en.getParameter(en.IMPLEMENTATION_COLOR_READ_TYPE) || so === ss && (Br.isWebGL2 || _r.has("OES_texture_float") || _r.has("WEBGL_color_buffer_float")) || _s))
                                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            tn >= 0 && tn <= Mr.width - un && an >= 0 && an <= Mr.height - yn && (Mr.isWebGLMultipleRenderTargets && en.readBuffer(en.COLOR_ATTACHMENT0 + _i),
                            en.readPixels(tn, an, un, yn, Po.convert(So), Po.convert(so), On))
                        } finally {
                            const wo = Pr ? Kr.get(Pr).__webglFramebuffer : null;
                            Lr.bindFramebuffer(en.FRAMEBUFFER, wo)
                        }
                    }
                }
                ,
                this.copyFramebufferToTexture = function(Mr, tn, an=0) {
                    const un = Math.pow(2, -an)
                      , yn = Math.floor(tn.image.width * un)
                      , On = Math.floor(tn.image.height * un);
                    An.setTexture2D(tn, 0),
                    en.copyTexSubImage2D(en.TEXTURE_2D, an, 0, 0, Mr.x, Mr.y, yn, On),
                    Lr.unbindTexture()
                }
                ,
                this.copyTextureToTexture = function(Mr, tn, an, un=0) {
                    const yn = tn.image.width
                      , On = tn.image.height
                      , To = Po.convert(an.format)
                      , _i = Po.convert(an.type);
                    An.setTexture2D(an, 0),
                    en.pixelStorei(en.UNPACK_FLIP_Y_WEBGL, an.flipY),
                    en.pixelStorei(en.UNPACK_PREMULTIPLY_ALPHA_WEBGL, an.premultiplyAlpha),
                    en.pixelStorei(en.UNPACK_ALIGNMENT, an.unpackAlignment),
                    tn.isDataTexture ? en.texSubImage2D(en.TEXTURE_2D, un, Mr.x, Mr.y, yn, On, To, _i, tn.image.data) : tn.isCompressedTexture ? en.compressedTexSubImage2D(en.TEXTURE_2D, un, Mr.x, Mr.y, tn.mipmaps[0].width, tn.mipmaps[0].height, To, tn.mipmaps[0].data) : en.texSubImage2D(en.TEXTURE_2D, un, Mr.x, Mr.y, To, _i, tn.image),
                    un === 0 && an.generateMipmaps && en.generateMipmap(en.TEXTURE_2D),
                    Lr.unbindTexture()
                }
                ,
                this.copyTextureToTexture3D = function(Mr, tn, an, un, yn=0) {
                    if (rr.isWebGL1Renderer)
                        return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const On = Mr.max.x - Mr.min.x + 1
                      , To = Mr.max.y - Mr.min.y + 1
                      , _i = Mr.max.z - Mr.min.z + 1
                      , fo = Po.convert(un.format)
                      , wo = Po.convert(un.type);
                    let So;
                    if (un.isData3DTexture)
                        An.setTexture3D(un, 0),
                        So = en.TEXTURE_3D;
                    else {
                        if (!un.isDataArrayTexture)
                            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        An.setTexture2DArray(un, 0),
                        So = en.TEXTURE_2D_ARRAY
                    }
                    en.pixelStorei(en.UNPACK_FLIP_Y_WEBGL, un.flipY),
                    en.pixelStorei(en.UNPACK_PREMULTIPLY_ALPHA_WEBGL, un.premultiplyAlpha),
                    en.pixelStorei(en.UNPACK_ALIGNMENT, un.unpackAlignment);
                    const so = en.getParameter(en.UNPACK_ROW_LENGTH)
                      , _s = en.getParameter(en.UNPACK_IMAGE_HEIGHT)
                      , xl = en.getParameter(en.UNPACK_SKIP_PIXELS)
                      , vs = en.getParameter(en.UNPACK_SKIP_ROWS)
                      , ip = en.getParameter(en.UNPACK_SKIP_IMAGES)
                      , ls = an.isCompressedTexture ? an.mipmaps[0] : an.image;
                    en.pixelStorei(en.UNPACK_ROW_LENGTH, ls.width),
                    en.pixelStorei(en.UNPACK_IMAGE_HEIGHT, ls.height),
                    en.pixelStorei(en.UNPACK_SKIP_PIXELS, Mr.min.x),
                    en.pixelStorei(en.UNPACK_SKIP_ROWS, Mr.min.y),
                    en.pixelStorei(en.UNPACK_SKIP_IMAGES, Mr.min.z),
                    an.isDataTexture || an.isData3DTexture ? en.texSubImage3D(So, yn, tn.x, tn.y, tn.z, On, To, _i, fo, wo, ls.data) : an.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
                    en.compressedTexSubImage3D(So, yn, tn.x, tn.y, tn.z, On, To, _i, fo, ls.data)) : en.texSubImage3D(So, yn, tn.x, tn.y, tn.z, On, To, _i, fo, wo, ls),
                    en.pixelStorei(en.UNPACK_ROW_LENGTH, so),
                    en.pixelStorei(en.UNPACK_IMAGE_HEIGHT, _s),
                    en.pixelStorei(en.UNPACK_SKIP_PIXELS, xl),
                    en.pixelStorei(en.UNPACK_SKIP_ROWS, vs),
                    en.pixelStorei(en.UNPACK_SKIP_IMAGES, ip),
                    yn === 0 && un.generateMipmaps && en.generateMipmap(So),
                    Lr.unbindTexture()
                }
                ,
                this.initTexture = function(Mr) {
                    Mr.isCubeTexture ? An.setTextureCube(Mr, 0) : Mr.isData3DTexture ? An.setTexture3D(Mr, 0) : Mr.isDataArrayTexture || Mr.isCompressedArrayTexture ? An.setTexture2DArray(Mr, 0) : An.setTexture2D(Mr, 0),
                    Lr.unbindTexture()
                }
                ,
                this.resetState = function() {
                    br = 0,
                    yr = 0,
                    Pr = null,
                    Lr.reset(),
                    Cu.reset()
                }
                ,
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            get coordinateSystem() {
                return Qs
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(tt) {
                this._outputColorSpace = tt;
                const lt = this.getContext();
                lt.drawingBufferColorSpace = tt === dp ? "display-p3" : "srgb",
                lt.unpackColorSpace = Do.workingColorSpace === hu ? "display-p3" : "srgb"
            }
            get physicallyCorrectLights() {
                return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                !this.useLegacyLights
            }
            set physicallyCorrectLights(tt) {
                console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),
                this.useLegacyLights = !tt
            }
            get outputEncoding() {
                return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace === jo ? Ol : ts
            }
            set outputEncoding(tt) {
                console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),
                this.outputColorSpace = tt === Ol ? jo : Xo
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights
            }
            set useLegacyLights(tt) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),
                this._useLegacyLights = tt
            }
        }
        class bx extends xx {
        }
        bx.prototype.isWebGL1Renderer = !0;
        class Pv {
            constructor(tt, lt=25e-5) {
                this.isFogExp2 = !0,
                this.name = "",
                this.color = new Gn(tt),
                this.density = lt
            }
            clone() {
                return new Pv(this.color,this.density)
            }
            toJSON() {
                return {
                    type: "FogExp2",
                    name: this.name,
                    color: this.color.getHex(),
                    density: this.density
                }
            }
        }
        class Mv {
            constructor(tt, lt=1, mt=1e3) {
                this.isFog = !0,
                this.name = "",
                this.color = new Gn(tt),
                this.near = lt,
                this.far = mt
            }
            clone() {
                return new Mv(this.color,this.near,this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class Ax extends Mo {
            constructor() {
                super(),
                this.isScene = !0,
                this.type = "Scene",
                this.background = null,
                this.environment = null,
                this.fog = null,
                this.backgroundBlurriness = 0,
                this.backgroundIntensity = 1,
                this.overrideMaterial = null,
                typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                    detail: this
                }))
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.background !== null && (this.background = tt.background.clone()),
                tt.environment !== null && (this.environment = tt.environment.clone()),
                tt.fog !== null && (this.fog = tt.fog.clone()),
                this.backgroundBlurriness = tt.backgroundBlurriness,
                this.backgroundIntensity = tt.backgroundIntensity,
                tt.overrideMaterial !== null && (this.overrideMaterial = tt.overrideMaterial.clone()),
                this.matrixAutoUpdate = tt.matrixAutoUpdate,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return this.fog !== null && (lt.object.fog = this.fog.toJSON()),
                this.backgroundBlurriness > 0 && (lt.object.backgroundBlurriness = this.backgroundBlurriness),
                this.backgroundIntensity !== 1 && (lt.object.backgroundIntensity = this.backgroundIntensity),
                lt
            }
        }
        class Rv {
            constructor(tt, lt) {
                this.isInterleavedBuffer = !0,
                this.array = tt,
                this.stride = lt,
                this.count = tt !== void 0 ? tt.length / lt : 0,
                this.usage = Nu,
                this.updateRange = {
                    offset: 0,
                    count: -1
                },
                this.version = 0,
                this.uuid = Ms()
            }
            onUploadCallback() {}
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            setUsage(tt) {
                return this.usage = tt,
                this
            }
            copy(tt) {
                return this.array = new tt.array.constructor(tt.array),
                this.count = tt.count,
                this.stride = tt.stride,
                this.usage = tt.usage,
                this
            }
            copyAt(tt, lt, mt) {
                tt *= this.stride,
                mt *= lt.stride;
                for (let ft = 0, xt = this.stride; ft < xt; ft++)
                    this.array[tt + ft] = lt.array[mt + ft];
                return this
            }
            set(tt, lt=0) {
                return this.array.set(tt, lt),
                this
            }
            clone(tt) {
                tt.arrayBuffers === void 0 && (tt.arrayBuffers = {}),
                this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ms()),
                tt.arrayBuffers[this.array.buffer._uuid] === void 0 && (tt.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const lt = new this.array.constructor(tt.arrayBuffers[this.array.buffer._uuid])
                  , mt = new this.constructor(lt,this.stride);
                return mt.setUsage(this.usage),
                mt
            }
            onUpload(tt) {
                return this.onUploadCallback = tt,
                this
            }
            toJSON(tt) {
                return tt.arrayBuffers === void 0 && (tt.arrayBuffers = {}),
                this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ms()),
                tt.arrayBuffers[this.array.buffer._uuid] === void 0 && (tt.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
                {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const Vs = new Er;
        class Cp {
            constructor(tt, lt, mt, ft=!1) {
                this.isInterleavedBufferAttribute = !0,
                this.name = "",
                this.data = tt,
                this.itemSize = lt,
                this.offset = mt,
                this.normalized = ft
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(tt) {
                this.data.needsUpdate = tt
            }
            applyMatrix4(tt) {
                for (let lt = 0, mt = this.data.count; lt < mt; lt++)
                    Vs.fromBufferAttribute(this, lt),
                    Vs.applyMatrix4(tt),
                    this.setXYZ(lt, Vs.x, Vs.y, Vs.z);
                return this
            }
            applyNormalMatrix(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    Vs.fromBufferAttribute(this, lt),
                    Vs.applyNormalMatrix(tt),
                    this.setXYZ(lt, Vs.x, Vs.y, Vs.z);
                return this
            }
            transformDirection(tt) {
                for (let lt = 0, mt = this.count; lt < mt; lt++)
                    Vs.fromBufferAttribute(this, lt),
                    Vs.transformDirection(tt),
                    this.setXYZ(lt, Vs.x, Vs.y, Vs.z);
                return this
            }
            setX(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset] = lt,
                this
            }
            setY(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset + 1] = lt,
                this
            }
            setZ(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset + 2] = lt,
                this
            }
            setW(tt, lt) {
                return this.normalized && (lt = oo(lt, this.array)),
                this.data.array[tt * this.data.stride + this.offset + 3] = lt,
                this
            }
            getX(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            getY(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset + 1];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            getZ(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset + 2];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            getW(tt) {
                let lt = this.data.array[tt * this.data.stride + this.offset + 3];
                return this.normalized && (lt = ws(lt, this.array)),
                lt
            }
            setXY(tt, lt, mt) {
                return tt = tt * this.data.stride + this.offset,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array)),
                this.data.array[tt + 0] = lt,
                this.data.array[tt + 1] = mt,
                this
            }
            setXYZ(tt, lt, mt, ft) {
                return tt = tt * this.data.stride + this.offset,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array)),
                this.data.array[tt + 0] = lt,
                this.data.array[tt + 1] = mt,
                this.data.array[tt + 2] = ft,
                this
            }
            setXYZW(tt, lt, mt, ft, xt) {
                return tt = tt * this.data.stride + this.offset,
                this.normalized && (lt = oo(lt, this.array),
                mt = oo(mt, this.array),
                ft = oo(ft, this.array),
                xt = oo(xt, this.array)),
                this.data.array[tt + 0] = lt,
                this.data.array[tt + 1] = mt,
                this.data.array[tt + 2] = ft,
                this.data.array[tt + 3] = xt,
                this
            }
            clone(tt) {
                if (tt === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const lt = [];
                    for (let mt = 0; mt < this.count; mt++) {
                        const ft = mt * this.data.stride + this.offset;
                        for (let xt = 0; xt < this.itemSize; xt++)
                            lt.push(this.data.array[ft + xt])
                    }
                    return new mr(new this.array.constructor(lt),this.itemSize,this.normalized)
                }
                return tt.interleavedBuffers === void 0 && (tt.interleavedBuffers = {}),
                tt.interleavedBuffers[this.data.uuid] === void 0 && (tt.interleavedBuffers[this.data.uuid] = this.data.clone(tt)),
                new Cp(tt.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
            }
            toJSON(tt) {
                if (tt === void 0) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const lt = [];
                    for (let mt = 0; mt < this.count; mt++) {
                        const ft = mt * this.data.stride + this.offset;
                        for (let xt = 0; xt < this.itemSize; xt++)
                            lt.push(this.data.array[ft + xt])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: lt,
                        normalized: this.normalized
                    }
                }
                return tt.interleavedBuffers === void 0 && (tt.interleavedBuffers = {}),
                tt.interleavedBuffers[this.data.uuid] === void 0 && (tt.interleavedBuffers[this.data.uuid] = this.data.toJSON(tt)),
                {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        class q0 extends hs {
            constructor(tt) {
                super(),
                this.isSpriteMaterial = !0,
                this.type = "SpriteMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.alphaMap = null,
                this.rotation = 0,
                this.sizeAttenuation = !0,
                this.transparent = !0,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.rotation = tt.rotation,
                this.sizeAttenuation = tt.sizeAttenuation,
                this.fog = tt.fog,
                this
            }
        }
        let wm;
        const v_ = new Er
          , Sm = new Er
          , Em = new Er
          , Tm = new mn
          , y_ = new mn
          , wx = new no
          , Iv = new Er
          , x_ = new Er
          , kv = new Er
          , Sx = new mn
          , $0 = new mn
          , Ex = new mn;
        class Tx extends Mo {
            constructor(tt=new q0) {
                if (super(),
                this.isSprite = !0,
                this.type = "Sprite",
                wm === void 0) {
                    wm = new bo;
                    const lt = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
                      , mt = new Rv(lt,5);
                    wm.setIndex([0, 1, 2, 0, 2, 3]),
                    wm.setAttribute("position", new Cp(mt,3,0,!1)),
                    wm.setAttribute("uv", new Cp(mt,2,3,!1))
                }
                this.geometry = wm,
                this.material = tt,
                this.center = new mn(.5,.5)
            }
            raycast(tt, lt) {
                tt.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
                Sm.setFromMatrixScale(this.matrixWorld),
                wx.copy(tt.camera.matrixWorld),
                this.modelViewMatrix.multiplyMatrices(tt.camera.matrixWorldInverse, this.matrixWorld),
                Em.setFromMatrixPosition(this.modelViewMatrix),
                tt.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Sm.multiplyScalar(-Em.z);
                const mt = this.material.rotation;
                let ft, xt;
                mt !== 0 && (xt = Math.cos(mt),
                ft = Math.sin(mt));
                const Ct = this.center;
                Dv(Iv.set(-.5, -.5, 0), Em, Ct, Sm, ft, xt),
                Dv(x_.set(.5, -.5, 0), Em, Ct, Sm, ft, xt),
                Dv(kv.set(.5, .5, 0), Em, Ct, Sm, ft, xt),
                Sx.set(0, 0),
                $0.set(1, 0),
                Ex.set(1, 1);
                let Mt = tt.ray.intersectTriangle(Iv, x_, kv, !1, v_);
                if (Mt === null && (Dv(x_.set(-.5, .5, 0), Em, Ct, Sm, ft, xt),
                $0.set(0, 1),
                Mt = tt.ray.intersectTriangle(Iv, kv, x_, !1, v_),
                Mt === null))
                    return;
                const Lt = tt.ray.origin.distanceTo(v_);
                Lt < tt.near || Lt > tt.far || lt.push({
                    distance: Lt,
                    point: v_.clone(),
                    uv: Es.getInterpolation(v_, Iv, x_, kv, Sx, $0, Ex, new mn),
                    face: null,
                    object: this
                })
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.center !== void 0 && this.center.copy(tt.center),
                this.material = tt.material,
                this
            }
        }
        function Dv(Tt, tt, lt, mt, ft, xt) {
            Tm.subVectors(Tt, lt).addScalar(.5).multiply(mt),
            ft !== void 0 ? (y_.x = xt * Tm.x - ft * Tm.y,
            y_.y = ft * Tm.x + xt * Tm.y) : y_.copy(Tm),
            Tt.copy(tt),
            Tt.x += y_.x,
            Tt.y += y_.y,
            Tt.applyMatrix4(wx)
        }
        const Bv = new Er
          , Cx = new Er;
        class Px extends Mo {
            constructor() {
                super(),
                this._currentLevel = 0,
                this.type = "LOD",
                Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    isLOD: {
                        value: !0
                    }
                }),
                this.autoUpdate = !0
            }
            copy(tt) {
                super.copy(tt, !1);
                const lt = tt.levels;
                for (let mt = 0, ft = lt.length; mt < ft; mt++) {
                    const xt = lt[mt];
                    this.addLevel(xt.object.clone(), xt.distance, xt.hysteresis)
                }
                return this.autoUpdate = tt.autoUpdate,
                this
            }
            addLevel(tt, lt=0, mt=0) {
                lt = Math.abs(lt);
                const ft = this.levels;
                let xt;
                for (xt = 0; xt < ft.length && !(lt < ft[xt].distance); xt++)
                    ;
                return ft.splice(xt, 0, {
                    distance: lt,
                    hysteresis: mt,
                    object: tt
                }),
                this.add(tt),
                this
            }
            getCurrentLevel() {
                return this._currentLevel
            }
            getObjectForDistance(tt) {
                const lt = this.levels;
                if (lt.length > 0) {
                    let mt, ft;
                    for (mt = 1,
                    ft = lt.length; mt < ft; mt++) {
                        let xt = lt[mt].distance;
                        if (lt[mt].object.visible && (xt -= xt * lt[mt].hysteresis),
                        tt < xt)
                            break
                    }
                    return lt[mt - 1].object
                }
                return null
            }
            raycast(tt, lt) {
                if (this.levels.length > 0) {
                    Bv.setFromMatrixPosition(this.matrixWorld);
                    const mt = tt.ray.origin.distanceTo(Bv);
                    this.getObjectForDistance(mt).raycast(tt, lt)
                }
            }
            update(tt) {
                const lt = this.levels;
                if (lt.length > 1) {
                    Bv.setFromMatrixPosition(tt.matrixWorld),
                    Cx.setFromMatrixPosition(this.matrixWorld);
                    const mt = Bv.distanceTo(Cx) / tt.zoom;
                    let ft, xt;
                    for (lt[0].object.visible = !0,
                    ft = 1,
                    xt = lt.length; ft < xt; ft++) {
                        let Ct = lt[ft].distance;
                        if (lt[ft].object.visible && (Ct -= Ct * lt[ft].hysteresis),
                        !(mt >= Ct))
                            break;
                        lt[ft - 1].object.visible = !1,
                        lt[ft].object.visible = !0
                    }
                    for (this._currentLevel = ft - 1; ft < xt; ft++)
                        lt[ft].object.visible = !1
                }
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                this.autoUpdate === !1 && (lt.object.autoUpdate = !1),
                lt.object.levels = [];
                const mt = this.levels;
                for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                    const Ct = mt[ft];
                    lt.object.levels.push({
                        object: Ct.object.uuid,
                        distance: Ct.distance,
                        hysteresis: Ct.hysteresis
                    })
                }
                return lt
            }
        }
        const Mx = new Er
          , Rx = new Lo
          , Ix = new Lo
          , iS = new Er
          , kx = new no
          , Cm = new Er
          , X0 = new Ws
          , Dx = new no
          , Y0 = new Qu;
        class Bx extends gs {
            constructor(tt, lt) {
                super(tt, lt),
                this.isSkinnedMesh = !0,
                this.type = "SkinnedMesh",
                this.bindMode = "attached",
                this.bindMatrix = new no,
                this.bindMatrixInverse = new no,
                this.boundingBox = null,
                this.boundingSphere = null
            }
            computeBoundingBox() {
                const tt = this.geometry;
                this.boundingBox === null && (this.boundingBox = new Tl),
                this.boundingBox.makeEmpty();
                const lt = tt.getAttribute("position");
                for (let mt = 0; mt < lt.count; mt++)
                    Cm.fromBufferAttribute(lt, mt),
                    this.applyBoneTransform(mt, Cm),
                    this.boundingBox.expandByPoint(Cm)
            }
            computeBoundingSphere() {
                const tt = this.geometry;
                this.boundingSphere === null && (this.boundingSphere = new Ws),
                this.boundingSphere.makeEmpty();
                const lt = tt.getAttribute("position");
                for (let mt = 0; mt < lt.count; mt++)
                    Cm.fromBufferAttribute(lt, mt),
                    this.applyBoneTransform(mt, Cm),
                    this.boundingSphere.expandByPoint(Cm)
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.bindMode = tt.bindMode,
                this.bindMatrix.copy(tt.bindMatrix),
                this.bindMatrixInverse.copy(tt.bindMatrixInverse),
                this.skeleton = tt.skeleton,
                tt.boundingBox !== null && (this.boundingBox = tt.boundingBox.clone()),
                tt.boundingSphere !== null && (this.boundingSphere = tt.boundingSphere.clone()),
                this
            }
            raycast(tt, lt) {
                const mt = this.material
                  , ft = this.matrixWorld;
                mt !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                X0.copy(this.boundingSphere),
                X0.applyMatrix4(ft),
                tt.ray.intersectsSphere(X0) !== !1 && (Dx.copy(ft).invert(),
                Y0.copy(tt.ray).applyMatrix4(Dx),
                this.boundingBox !== null && Y0.intersectsBox(this.boundingBox) === !1 || this._computeIntersections(tt, lt, Y0)))
            }
            getVertexPosition(tt, lt) {
                return super.getVertexPosition(tt, lt),
                this.applyBoneTransform(tt, lt),
                lt
            }
            bind(tt, lt) {
                this.skeleton = tt,
                lt === void 0 && (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                lt = this.matrixWorld),
                this.bindMatrix.copy(lt),
                this.bindMatrixInverse.copy(lt).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const tt = new Lo
                  , lt = this.geometry.attributes.skinWeight;
                for (let mt = 0, ft = lt.count; mt < ft; mt++) {
                    tt.fromBufferAttribute(lt, mt);
                    const xt = 1 / tt.manhattanLength();
                    xt !== 1 / 0 ? tt.multiplyScalar(xt) : tt.set(1, 0, 0, 0),
                    lt.setXYZW(mt, tt.x, tt.y, tt.z, tt.w)
                }
            }
            updateMatrixWorld(tt) {
                super.updateMatrixWorld(tt),
                this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(tt, lt) {
                const mt = this.skeleton
                  , ft = this.geometry;
                Rx.fromBufferAttribute(ft.attributes.skinIndex, tt),
                Ix.fromBufferAttribute(ft.attributes.skinWeight, tt),
                Mx.copy(lt).applyMatrix4(this.bindMatrix),
                lt.set(0, 0, 0);
                for (let xt = 0; xt < 4; xt++) {
                    const Ct = Ix.getComponent(xt);
                    if (Ct !== 0) {
                        const Mt = Rx.getComponent(xt);
                        kx.multiplyMatrices(mt.bones[Mt].matrixWorld, mt.boneInverses[Mt]),
                        lt.addScaledVector(iS.copy(Mx).applyMatrix4(kx), Ct)
                    }
                }
                return lt.applyMatrix4(this.bindMatrixInverse)
            }
            boneTransform(tt, lt) {
                return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),
                this.applyBoneTransform(tt, lt)
            }
        }
        class K0 extends Mo {
            constructor() {
                super(),
                this.isBone = !0,
                this.type = "Bone"
            }
        }
        class Pm extends Ho {
            constructor(tt=null, lt=1, mt=1, ft, xt, Ct, Mt, Lt, Nt=fn, jt=fn, Wt, Qt) {
                super(null, Ct, Mt, Lt, Nt, jt, ft, xt, Wt, Qt),
                this.isDataTexture = !0,
                this.image = {
                    data: tt,
                    width: lt,
                    height: mt
                },
                this.generateMipmaps = !1,
                this.flipY = !1,
                this.unpackAlignment = 1
            }
        }
        const Lx = new no
          , oS = new no;
        class Lv {
            constructor(tt=[], lt=[]) {
                this.uuid = Ms(),
                this.bones = tt.slice(0),
                this.boneInverses = lt,
                this.boneMatrices = null,
                this.boneTexture = null,
                this.boneTextureSize = 0,
                this.init()
            }
            init() {
                const tt = this.bones
                  , lt = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * tt.length),
                lt.length === 0)
                    this.calculateInverses();
                else if (tt.length !== lt.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
                    this.boneInverses = [];
                    for (let mt = 0, ft = this.bones.length; mt < ft; mt++)
                        this.boneInverses.push(new no)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let tt = 0, lt = this.bones.length; tt < lt; tt++) {
                    const mt = new no;
                    this.bones[tt] && mt.copy(this.bones[tt].matrixWorld).invert(),
                    this.boneInverses.push(mt)
                }
            }
            pose() {
                for (let tt = 0, lt = this.bones.length; tt < lt; tt++) {
                    const mt = this.bones[tt];
                    mt && mt.matrixWorld.copy(this.boneInverses[tt]).invert()
                }
                for (let tt = 0, lt = this.bones.length; tt < lt; tt++) {
                    const mt = this.bones[tt];
                    mt && (mt.parent && mt.parent.isBone ? (mt.matrix.copy(mt.parent.matrixWorld).invert(),
                    mt.matrix.multiply(mt.matrixWorld)) : mt.matrix.copy(mt.matrixWorld),
                    mt.matrix.decompose(mt.position, mt.quaternion, mt.scale))
                }
            }
            update() {
                const tt = this.bones
                  , lt = this.boneInverses
                  , mt = this.boneMatrices
                  , ft = this.boneTexture;
                for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                    const Mt = tt[xt] ? tt[xt].matrixWorld : oS;
                    Lx.multiplyMatrices(Mt, lt[xt]),
                    Lx.toArray(mt, 16 * xt)
                }
                ft !== null && (ft.needsUpdate = !0)
            }
            clone() {
                return new Lv(this.bones,this.boneInverses)
            }
            computeBoneTexture() {
                let tt = Math.sqrt(4 * this.bones.length);
                tt = Km(tt),
                tt = Math.max(tt, 4);
                const lt = new Float32Array(tt * tt * 4);
                lt.set(this.boneMatrices);
                const mt = new Pm(lt,tt,tt,as,ss);
                return mt.needsUpdate = !0,
                this.boneMatrices = lt,
                this.boneTexture = mt,
                this.boneTextureSize = tt,
                this
            }
            getBoneByName(tt) {
                for (let lt = 0, mt = this.bones.length; lt < mt; lt++) {
                    const ft = this.bones[lt];
                    if (ft.name === tt)
                        return ft
                }
            }
            dispose() {
                this.boneTexture !== null && (this.boneTexture.dispose(),
                this.boneTexture = null)
            }
            fromJSON(tt, lt) {
                this.uuid = tt.uuid;
                for (let mt = 0, ft = tt.bones.length; mt < ft; mt++) {
                    const xt = tt.bones[mt];
                    let Ct = lt[xt];
                    Ct === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", xt),
                    Ct = new K0),
                    this.bones.push(Ct),
                    this.boneInverses.push(new no().fromArray(tt.boneInverses[mt]))
                }
                return this.init(),
                this
            }
            toJSON() {
                const tt = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                tt.uuid = this.uuid;
                const lt = this.bones
                  , mt = this.boneInverses;
                for (let ft = 0, xt = lt.length; ft < xt; ft++) {
                    const Ct = lt[ft];
                    tt.bones.push(Ct.uuid);
                    const Mt = mt[ft];
                    tt.boneInverses.push(Mt.toArray())
                }
                return tt
            }
        }
        class Mm extends mr {
            constructor(tt, lt, mt, ft=1) {
                super(tt, lt, mt),
                this.isInstancedBufferAttribute = !0,
                this.meshPerAttribute = ft
            }
            copy(tt) {
                return super.copy(tt),
                this.meshPerAttribute = tt.meshPerAttribute,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.meshPerAttribute = this.meshPerAttribute,
                tt.isInstancedBufferAttribute = !0,
                tt
            }
        }
        const Rm = new no
          , Ox = new no
          , Ov = []
          , Nx = new Tl
          , sS = new no
          , b_ = new gs
          , A_ = new Ws;
        class Fx extends gs {
            constructor(tt, lt, mt) {
                super(tt, lt),
                this.isInstancedMesh = !0,
                this.instanceMatrix = new Mm(new Float32Array(16 * mt),16),
                this.instanceColor = null,
                this.sourceTrs = null,
                this.count = mt,
                this.boundingBox = null,
                this.boundingSphere = null;
                for (let ft = 0; ft < mt; ft++)
                    this.setMatrixAt(ft, sS)
            }
            computeBoundingBox() {
                const tt = this.geometry
                  , lt = this.count;
                this.boundingBox === null && (this.boundingBox = new Tl),
                tt.boundingBox === null && tt.computeBoundingBox(),
                this.boundingBox.makeEmpty();
                for (let mt = 0; mt < lt; mt++)
                    this.getMatrixAt(mt, Rm),
                    Nx.copy(tt.boundingBox).applyMatrix4(Rm),
                    this.boundingBox.union(Nx)
            }
            computeBoundingSphere() {
                const tt = this.geometry
                  , lt = this.count;
                this.boundingSphere === null && (this.boundingSphere = new Ws),
                tt.boundingSphere === null && tt.computeBoundingSphere(),
                this.boundingSphere.makeEmpty();
                for (let mt = 0; mt < lt; mt++)
                    this.getMatrixAt(mt, Rm),
                    A_.copy(tt.boundingSphere).applyMatrix4(Rm),
                    this.boundingSphere.union(A_)
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                tt.isInstancedMesh ? (this.instanceMatrix.copy(tt.instanceMatrix),
                tt.instanceColor !== null && (this.instanceColor = tt.instanceColor.clone()),
                this.count = tt.count,
                tt.boundingBox !== null && (this.boundingBox = tt.boundingBox.clone()),
                tt.boundingSphere !== null && (this.boundingSphere = tt.boundingSphere.clone()),
                this) : this
            }
            getColorAt(tt, lt) {
                lt.fromArray(this.instanceColor.array, 3 * tt)
            }
            getMatrixAt(tt, lt) {
                lt.fromArray(this.instanceMatrix.array, 16 * tt)
            }
            raycast(tt, lt) {
                const mt = this.matrixWorld
                  , ft = this.count;
                if (b_.geometry = this.geometry,
                b_.material = this.material,
                b_.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
                A_.copy(this.boundingSphere),
                A_.applyMatrix4(mt),
                tt.ray.intersectsSphere(A_) !== !1))
                    for (let xt = 0; xt < ft; xt++) {
                        this.getMatrixAt(xt, Rm),
                        Ox.multiplyMatrices(mt, Rm),
                        b_.matrixWorld = Ox,
                        b_.raycast(tt, Ov);
                        for (let Ct = 0, Mt = Ov.length; Ct < Mt; Ct++) {
                            const Lt = Ov[Ct];
                            Lt.instanceId = xt,
                            Lt.object = this,
                            lt.push(Lt)
                        }
                        Ov.length = 0
                    }
            }
            setColorAt(tt, lt) {
                this.instanceColor === null && (this.instanceColor = new Mm(new Float32Array(3 * this.instanceMatrix.count),3)),
                lt.toArray(this.instanceColor.array, 3 * tt)
            }
            setMatrixAt(tt, lt) {
                lt.toArray(this.instanceMatrix.array, 16 * tt)
            }
            updateMorphTargets() {}
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Gs extends hs {
            constructor(tt) {
                super(),
                this.isLineBasicMaterial = !0,
                this.type = "LineBasicMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.linewidth = 1,
                this.linecap = "round",
                this.linejoin = "round",
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.linewidth = tt.linewidth,
                this.linecap = tt.linecap,
                this.linejoin = tt.linejoin,
                this.fog = tt.fog,
                this
            }
        }
        const Ux = new Er
          , jx = new Er
          , Vx = new no
          , J0 = new Qu
          , Nv = new Ws;
        class ep extends Mo {
            constructor(tt=new bo, lt=new Gs) {
                super(),
                this.isLine = !0,
                this.type = "Line",
                this.geometry = tt,
                this.material = lt,
                this.updateMorphTargets()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.material = Array.isArray(tt.material) ? tt.material.slice() : tt.material,
                this.geometry = tt.geometry,
                this
            }
            computeLineDistances() {
                const tt = this.geometry;
                if (tt.index === null) {
                    const lt = tt.attributes.position
                      , mt = [0];
                    for (let ft = 1, xt = lt.count; ft < xt; ft++)
                        Ux.fromBufferAttribute(lt, ft - 1),
                        jx.fromBufferAttribute(lt, ft),
                        mt[ft] = mt[ft - 1],
                        mt[ft] += Ux.distanceTo(jx);
                    tt.setAttribute("lineDistance", new Fn(mt,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(tt, lt) {
                const mt = this.geometry
                  , ft = this.matrixWorld
                  , xt = tt.params.Line.threshold
                  , Ct = mt.drawRange;
                if (mt.boundingSphere === null && mt.computeBoundingSphere(),
                Nv.copy(mt.boundingSphere),
                Nv.applyMatrix4(ft),
                Nv.radius += xt,
                tt.ray.intersectsSphere(Nv) === !1)
                    return;
                Vx.copy(ft).invert(),
                J0.copy(tt.ray).applyMatrix4(Vx);
                const Mt = xt / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , Lt = Mt * Mt
                  , Nt = new Er
                  , jt = new Er
                  , Wt = new Er
                  , Qt = new Er
                  , qt = this.isLineSegments ? 2 : 1
                  , Xt = mt.index
                  , Zt = mt.attributes.position;
                if (Xt !== null)
                    for (let Yt = Math.max(0, Ct.start), sr = Math.min(Xt.count, Ct.start + Ct.count) - 1; Yt < sr; Yt += qt) {
                        const er = Xt.getX(Yt)
                          , rr = Xt.getX(Yt + 1);
                        if (Nt.fromBufferAttribute(Zt, er),
                        jt.fromBufferAttribute(Zt, rr),
                        J0.distanceSqToSegment(Nt, jt, Qt, Wt) > Lt)
                            continue;
                        Qt.applyMatrix4(this.matrixWorld);
                        const xr = tt.ray.origin.distanceTo(Qt);
                        xr < tt.near || xr > tt.far || lt.push({
                            distance: xr,
                            point: Wt.clone().applyMatrix4(this.matrixWorld),
                            index: Yt,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                else
                    for (let Yt = Math.max(0, Ct.start), sr = Math.min(Zt.count, Ct.start + Ct.count) - 1; Yt < sr; Yt += qt) {
                        if (Nt.fromBufferAttribute(Zt, Yt),
                        jt.fromBufferAttribute(Zt, Yt + 1),
                        J0.distanceSqToSegment(Nt, jt, Qt, Wt) > Lt)
                            continue;
                        Qt.applyMatrix4(this.matrixWorld);
                        const er = tt.ray.origin.distanceTo(Qt);
                        er < tt.near || er > tt.far || lt.push({
                            distance: er,
                            point: Wt.clone().applyMatrix4(this.matrixWorld),
                            index: Yt,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
            }
            updateMorphTargets() {
                const tt = this.geometry.morphAttributes
                  , lt = Object.keys(tt);
                if (lt.length > 0) {
                    const mt = tt[lt[0]];
                    if (mt !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                            const Ct = mt[ft].name || String(ft);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[Ct] = ft
                        }
                    }
                }
            }
        }
        const Gx = new Er
          , zx = new Er;
        class iu extends ep {
            constructor(tt, lt) {
                super(tt, lt),
                this.isLineSegments = !0,
                this.type = "LineSegments"
            }
            computeLineDistances() {
                const tt = this.geometry;
                if (tt.index === null) {
                    const lt = tt.attributes.position
                      , mt = [];
                    for (let ft = 0, xt = lt.count; ft < xt; ft += 2)
                        Gx.fromBufferAttribute(lt, ft),
                        zx.fromBufferAttribute(lt, ft + 1),
                        mt[ft] = ft === 0 ? 0 : mt[ft - 1],
                        mt[ft + 1] = mt[ft] + Gx.distanceTo(zx);
                    tt.setAttribute("lineDistance", new Fn(mt,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class Hx extends ep {
            constructor(tt, lt) {
                super(tt, lt),
                this.isLineLoop = !0,
                this.type = "LineLoop"
            }
        }
        class Z0 extends hs {
            constructor(tt) {
                super(),
                this.isPointsMaterial = !0,
                this.type = "PointsMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.alphaMap = null,
                this.size = 1,
                this.sizeAttenuation = !0,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.alphaMap = tt.alphaMap,
                this.size = tt.size,
                this.sizeAttenuation = tt.sizeAttenuation,
                this.fog = tt.fog,
                this
            }
        }
        const Qx = new no
          , ey = new Qu
          , Fv = new Ws
          , Uv = new Er;
        class Wx extends Mo {
            constructor(tt=new bo, lt=new Z0) {
                super(),
                this.isPoints = !0,
                this.type = "Points",
                this.geometry = tt,
                this.material = lt,
                this.updateMorphTargets()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.material = Array.isArray(tt.material) ? tt.material.slice() : tt.material,
                this.geometry = tt.geometry,
                this
            }
            raycast(tt, lt) {
                const mt = this.geometry
                  , ft = this.matrixWorld
                  , xt = tt.params.Points.threshold
                  , Ct = mt.drawRange;
                if (mt.boundingSphere === null && mt.computeBoundingSphere(),
                Fv.copy(mt.boundingSphere),
                Fv.applyMatrix4(ft),
                Fv.radius += xt,
                tt.ray.intersectsSphere(Fv) === !1)
                    return;
                Qx.copy(ft).invert(),
                ey.copy(tt.ray).applyMatrix4(Qx);
                const Mt = xt / ((this.scale.x + this.scale.y + this.scale.z) / 3)
                  , Lt = Mt * Mt
                  , Nt = mt.index
                  , jt = mt.attributes.position;
                if (Nt !== null)
                    for (let Wt = Math.max(0, Ct.start), Qt = Math.min(Nt.count, Ct.start + Ct.count); Wt < Qt; Wt++) {
                        const qt = Nt.getX(Wt);
                        Uv.fromBufferAttribute(jt, qt),
                        qx(Uv, qt, Lt, ft, tt, lt, this)
                    }
                else
                    for (let Wt = Math.max(0, Ct.start), Qt = Math.min(jt.count, Ct.start + Ct.count); Wt < Qt; Wt++)
                        Uv.fromBufferAttribute(jt, Wt),
                        qx(Uv, Wt, Lt, ft, tt, lt, this)
            }
            updateMorphTargets() {
                const tt = this.geometry.morphAttributes
                  , lt = Object.keys(tt);
                if (lt.length > 0) {
                    const mt = tt[lt[0]];
                    if (mt !== void 0) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let ft = 0, xt = mt.length; ft < xt; ft++) {
                            const Ct = mt[ft].name || String(ft);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[Ct] = ft
                        }
                    }
                }
            }
        }
        function qx(Tt, tt, lt, mt, ft, xt, Ct) {
            const Mt = ey.distanceSqToPoint(Tt);
            if (Mt < lt) {
                const Lt = new Er;
                ey.closestPointToPoint(Tt, Lt),
                Lt.applyMatrix4(mt);
                const Nt = ft.ray.origin.distanceTo(Lt);
                if (Nt < ft.near || Nt > ft.far)
                    return;
                xt.push({
                    distance: Nt,
                    distanceToRay: Math.sqrt(Mt),
                    point: Lt,
                    index: tt,
                    face: null,
                    object: Ct
                })
            }
        }
        class aS extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                super(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt),
                this.isVideoTexture = !0,
                this.minFilter = Ct !== void 0 ? Ct : Rn,
                this.magFilter = xt !== void 0 ? xt : Rn,
                this.generateMipmaps = !1;
                const jt = this;
                "requestVideoFrameCallback"in tt && tt.requestVideoFrameCallback(function Wt() {
                    jt.needsUpdate = !0,
                    tt.requestVideoFrameCallback(Wt)
                })
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const tt = this.image;
                !("requestVideoFrameCallback"in tt) && tt.readyState >= tt.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class lS extends Ho {
            constructor(tt, lt) {
                super({
                    width: tt,
                    height: lt
                }),
                this.isFramebufferTexture = !0,
                this.magFilter = fn,
                this.minFilter = fn,
                this.generateMipmaps = !1,
                this.needsUpdate = !0
            }
        }
        class jv extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt, jt, Wt, Qt) {
                super(null, Ct, Mt, Lt, Nt, jt, ft, xt, Wt, Qt),
                this.isCompressedTexture = !0,
                this.image = {
                    width: lt,
                    height: mt
                },
                this.mipmaps = tt,
                this.flipY = !1,
                this.generateMipmaps = !1
            }
        }
        class cS extends jv {
            constructor(tt, lt, mt, ft, xt, Ct) {
                super(tt, lt, mt, xt, Ct),
                this.isCompressedArrayTexture = !0,
                this.image.depth = ft,
                this.wrapR = wn
            }
        }
        class uS extends jv {
            constructor(tt, lt, mt) {
                super(void 0, tt[0].width, tt[0].height, lt, mt, Qr),
                this.isCompressedCubeTexture = !0,
                this.isCubeTexture = !0,
                this.image = tt
            }
        }
        class dS extends Ho {
            constructor(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt) {
                super(tt, lt, mt, ft, xt, Ct, Mt, Lt, Nt),
                this.isCanvasTexture = !0,
                this.needsUpdate = !0
            }
        }
        class Hl {
            constructor() {
                this.type = "Curve",
                this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            }
            getPointAt(tt, lt) {
                const mt = this.getUtoTmapping(tt);
                return this.getPoint(mt, lt)
            }
            getPoints(tt=5) {
                const lt = [];
                for (let mt = 0; mt <= tt; mt++)
                    lt.push(this.getPoint(mt / tt));
                return lt
            }
            getSpacedPoints(tt=5) {
                const lt = [];
                for (let mt = 0; mt <= tt; mt++)
                    lt.push(this.getPointAt(mt / tt));
                return lt
            }
            getLength() {
                const tt = this.getLengths();
                return tt[tt.length - 1]
            }
            getLengths(tt=this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === tt + 1 && !this.needsUpdate)
                    return this.cacheArcLengths;
                this.needsUpdate = !1;
                const lt = [];
                let mt, ft = this.getPoint(0), xt = 0;
                lt.push(0);
                for (let Ct = 1; Ct <= tt; Ct++)
                    mt = this.getPoint(Ct / tt),
                    xt += mt.distanceTo(ft),
                    lt.push(xt),
                    ft = mt;
                return this.cacheArcLengths = lt,
                lt
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.getLengths()
            }
            getUtoTmapping(tt, lt) {
                const mt = this.getLengths();
                let ft = 0;
                const xt = mt.length;
                let Ct;
                Ct = lt || tt * mt[xt - 1];
                let Mt, Lt = 0, Nt = xt - 1;
                for (; Lt <= Nt; )
                    if (ft = Math.floor(Lt + (Nt - Lt) / 2),
                    Mt = mt[ft] - Ct,
                    Mt < 0)
                        Lt = ft + 1;
                    else {
                        if (!(Mt > 0)) {
                            Nt = ft;
                            break
                        }
                        Nt = ft - 1
                    }
                if (ft = Nt,
                mt[ft] === Ct)
                    return ft / (xt - 1);
                const jt = mt[ft];
                return (ft + (Ct - jt) / (mt[ft + 1] - jt)) / (xt - 1)
            }
            getTangent(tt, lt) {
                let ft = tt - 1e-4
                  , xt = tt + 1e-4;
                ft < 0 && (ft = 0),
                xt > 1 && (xt = 1);
                const Ct = this.getPoint(ft)
                  , Mt = this.getPoint(xt)
                  , Lt = lt || (Ct.isVector2 ? new mn : new Er);
                return Lt.copy(Mt).sub(Ct).normalize(),
                Lt
            }
            getTangentAt(tt, lt) {
                const mt = this.getUtoTmapping(tt);
                return this.getTangent(mt, lt)
            }
            computeFrenetFrames(tt, lt) {
                const mt = new Er
                  , ft = []
                  , xt = []
                  , Ct = []
                  , Mt = new Er
                  , Lt = new no;
                for (let qt = 0; qt <= tt; qt++) {
                    const Xt = qt / tt;
                    ft[qt] = this.getTangentAt(Xt, new Er)
                }
                xt[0] = new Er,
                Ct[0] = new Er;
                let Nt = Number.MAX_VALUE;
                const jt = Math.abs(ft[0].x)
                  , Wt = Math.abs(ft[0].y)
                  , Qt = Math.abs(ft[0].z);
                jt <= Nt && (Nt = jt,
                mt.set(1, 0, 0)),
                Wt <= Nt && (Nt = Wt,
                mt.set(0, 1, 0)),
                Qt <= Nt && mt.set(0, 0, 1),
                Mt.crossVectors(ft[0], mt).normalize(),
                xt[0].crossVectors(ft[0], Mt),
                Ct[0].crossVectors(ft[0], xt[0]);
                for (let qt = 1; qt <= tt; qt++) {
                    if (xt[qt] = xt[qt - 1].clone(),
                    Ct[qt] = Ct[qt - 1].clone(),
                    Mt.crossVectors(ft[qt - 1], ft[qt]),
                    Mt.length() > Number.EPSILON) {
                        Mt.normalize();
                        const Xt = Math.acos(qo(ft[qt - 1].dot(ft[qt]), -1, 1));
                        xt[qt].applyMatrix4(Lt.makeRotationAxis(Mt, Xt))
                    }
                    Ct[qt].crossVectors(ft[qt], xt[qt])
                }
                if (lt === !0) {
                    let qt = Math.acos(qo(xt[0].dot(xt[tt]), -1, 1));
                    qt /= tt,
                    ft[0].dot(Mt.crossVectors(xt[0], xt[tt])) > 0 && (qt = -qt);
                    for (let Xt = 1; Xt <= tt; Xt++)
                        xt[Xt].applyMatrix4(Lt.makeRotationAxis(ft[Xt], qt * Xt)),
                        Ct[Xt].crossVectors(ft[Xt], xt[Xt])
                }
                return {
                    tangents: ft,
                    normals: xt,
                    binormals: Ct
                }
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.arcLengthDivisions = tt.arcLengthDivisions,
                this
            }
            toJSON() {
                const tt = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return tt.arcLengthDivisions = this.arcLengthDivisions,
                tt.type = this.type,
                tt
            }
            fromJSON(tt) {
                return this.arcLengthDivisions = tt.arcLengthDivisions,
                this
            }
        }
        class Vv extends Hl {
            constructor(tt=0, lt=0, mt=1, ft=1, xt=0, Ct=2 * Math.PI, Mt=!1, Lt=0) {
                super(),
                this.isEllipseCurve = !0,
                this.type = "EllipseCurve",
                this.aX = tt,
                this.aY = lt,
                this.xRadius = mt,
                this.yRadius = ft,
                this.aStartAngle = xt,
                this.aEndAngle = Ct,
                this.aClockwise = Mt,
                this.aRotation = Lt
            }
            getPoint(tt, lt) {
                const mt = lt || new mn
                  , ft = 2 * Math.PI;
                let xt = this.aEndAngle - this.aStartAngle;
                const Ct = Math.abs(xt) < Number.EPSILON;
                for (; xt < 0; )
                    xt += ft;
                for (; xt > ft; )
                    xt -= ft;
                xt < Number.EPSILON && (xt = Ct ? 0 : ft),
                this.aClockwise !== !0 || Ct || (xt === ft ? xt = -ft : xt -= ft);
                const Mt = this.aStartAngle + tt * xt;
                let Lt = this.aX + this.xRadius * Math.cos(Mt)
                  , Nt = this.aY + this.yRadius * Math.sin(Mt);
                if (this.aRotation !== 0) {
                    const jt = Math.cos(this.aRotation)
                      , Wt = Math.sin(this.aRotation)
                      , Qt = Lt - this.aX
                      , qt = Nt - this.aY;
                    Lt = Qt * jt - qt * Wt + this.aX,
                    Nt = Qt * Wt + qt * jt + this.aY
                }
                return mt.set(Lt, Nt)
            }
            copy(tt) {
                return super.copy(tt),
                this.aX = tt.aX,
                this.aY = tt.aY,
                this.xRadius = tt.xRadius,
                this.yRadius = tt.yRadius,
                this.aStartAngle = tt.aStartAngle,
                this.aEndAngle = tt.aEndAngle,
                this.aClockwise = tt.aClockwise,
                this.aRotation = tt.aRotation,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.aX = this.aX,
                tt.aY = this.aY,
                tt.xRadius = this.xRadius,
                tt.yRadius = this.yRadius,
                tt.aStartAngle = this.aStartAngle,
                tt.aEndAngle = this.aEndAngle,
                tt.aClockwise = this.aClockwise,
                tt.aRotation = this.aRotation,
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.aX = tt.aX,
                this.aY = tt.aY,
                this.xRadius = tt.xRadius,
                this.yRadius = tt.yRadius,
                this.aStartAngle = tt.aStartAngle,
                this.aEndAngle = tt.aEndAngle,
                this.aClockwise = tt.aClockwise,
                this.aRotation = tt.aRotation,
                this
            }
        }
        class $x extends Vv {
            constructor(tt, lt, mt, ft, xt, Ct) {
                super(tt, lt, mt, mt, ft, xt, Ct),
                this.isArcCurve = !0,
                this.type = "ArcCurve"
            }
        }
        function ty() {
            let Tt = 0
              , tt = 0
              , lt = 0
              , mt = 0;
            function ft(xt, Ct, Mt, Lt) {
                Tt = xt,
                tt = Mt,
                lt = -3 * xt + 3 * Ct - 2 * Mt - Lt,
                mt = 2 * xt - 2 * Ct + Mt + Lt
            }
            return {
                initCatmullRom: function(xt, Ct, Mt, Lt, Nt) {
                    ft(Ct, Mt, Nt * (Mt - xt), Nt * (Lt - Ct))
                },
                initNonuniformCatmullRom: function(xt, Ct, Mt, Lt, Nt, jt, Wt) {
                    let Qt = (Ct - xt) / Nt - (Mt - xt) / (Nt + jt) + (Mt - Ct) / jt
                      , qt = (Mt - Ct) / jt - (Lt - Ct) / (jt + Wt) + (Lt - Mt) / Wt;
                    Qt *= jt,
                    qt *= jt,
                    ft(Ct, Mt, Qt, qt)
                },
                calc: function(xt) {
                    const Ct = xt * xt;
                    return Tt + tt * xt + lt * Ct + mt * (Ct * xt)
                }
            }
        }
        const Gv = new Er
          , ry = new ty
          , ny = new ty
          , iy = new ty;
        class Xx extends Hl {
            constructor(tt=[], lt=!1, mt="centripetal", ft=.5) {
                super(),
                this.isCatmullRomCurve3 = !0,
                this.type = "CatmullRomCurve3",
                this.points = tt,
                this.closed = lt,
                this.curveType = mt,
                this.tension = ft
            }
            getPoint(tt, lt=new Er) {
                const mt = lt
                  , ft = this.points
                  , xt = ft.length
                  , Ct = (xt - (this.closed ? 0 : 1)) * tt;
                let Mt, Lt, Nt = Math.floor(Ct), jt = Ct - Nt;
                this.closed ? Nt += Nt > 0 ? 0 : (Math.floor(Math.abs(Nt) / xt) + 1) * xt : jt === 0 && Nt === xt - 1 && (Nt = xt - 2,
                jt = 1),
                this.closed || Nt > 0 ? Mt = ft[(Nt - 1) % xt] : (Gv.subVectors(ft[0], ft[1]).add(ft[0]),
                Mt = Gv);
                const Wt = ft[Nt % xt]
                  , Qt = ft[(Nt + 1) % xt];
                if (this.closed || Nt + 2 < xt ? Lt = ft[(Nt + 2) % xt] : (Gv.subVectors(ft[xt - 1], ft[xt - 2]).add(ft[xt - 1]),
                Lt = Gv),
                this.curveType === "centripetal" || this.curveType === "chordal") {
                    const qt = this.curveType === "chordal" ? .5 : .25;
                    let Xt = Math.pow(Mt.distanceToSquared(Wt), qt)
                      , Zt = Math.pow(Wt.distanceToSquared(Qt), qt)
                      , Yt = Math.pow(Qt.distanceToSquared(Lt), qt);
                    Zt < 1e-4 && (Zt = 1),
                    Xt < 1e-4 && (Xt = Zt),
                    Yt < 1e-4 && (Yt = Zt),
                    ry.initNonuniformCatmullRom(Mt.x, Wt.x, Qt.x, Lt.x, Xt, Zt, Yt),
                    ny.initNonuniformCatmullRom(Mt.y, Wt.y, Qt.y, Lt.y, Xt, Zt, Yt),
                    iy.initNonuniformCatmullRom(Mt.z, Wt.z, Qt.z, Lt.z, Xt, Zt, Yt)
                } else
                    this.curveType === "catmullrom" && (ry.initCatmullRom(Mt.x, Wt.x, Qt.x, Lt.x, this.tension),
                    ny.initCatmullRom(Mt.y, Wt.y, Qt.y, Lt.y, this.tension),
                    iy.initCatmullRom(Mt.z, Wt.z, Qt.z, Lt.z, this.tension));
                return mt.set(ry.calc(jt), ny.calc(jt), iy.calc(jt)),
                mt
            }
            copy(tt) {
                super.copy(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(ft.clone())
                }
                return this.closed = tt.closed,
                this.curveType = tt.curveType,
                this.tension = tt.tension,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.points = [];
                for (let lt = 0, mt = this.points.length; lt < mt; lt++) {
                    const ft = this.points[lt];
                    tt.points.push(ft.toArray())
                }
                return tt.closed = this.closed,
                tt.curveType = this.curveType,
                tt.tension = this.tension,
                tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(new Er().fromArray(ft))
                }
                return this.closed = tt.closed,
                this.curveType = tt.curveType,
                this.tension = tt.tension,
                this
            }
        }
        function Yx(Tt, tt, lt, mt, ft) {
            const xt = .5 * (mt - tt)
              , Ct = .5 * (ft - lt)
              , Mt = Tt * Tt;
            return (2 * lt - 2 * mt + xt + Ct) * (Tt * Mt) + (-3 * lt + 3 * mt - 2 * xt - Ct) * Mt + xt * Tt + lt
        }
        function w_(Tt, tt, lt, mt) {
            return function(ft, xt) {
                const Ct = 1 - ft;
                return Ct * Ct * xt
            }(Tt, tt) + function(ft, xt) {
                return 2 * (1 - ft) * ft * xt
            }(Tt, lt) + function(ft, xt) {
                return ft * ft * xt
            }(Tt, mt)
        }
        function S_(Tt, tt, lt, mt, ft) {
            return function(xt, Ct) {
                const Mt = 1 - xt;
                return Mt * Mt * Mt * Ct
            }(Tt, tt) + function(xt, Ct) {
                const Mt = 1 - xt;
                return 3 * Mt * Mt * xt * Ct
            }(Tt, lt) + function(xt, Ct) {
                return 3 * (1 - xt) * xt * xt * Ct
            }(Tt, mt) + function(xt, Ct) {
                return xt * xt * xt * Ct
            }(Tt, ft)
        }
        class oy extends Hl {
            constructor(tt=new mn, lt=new mn, mt=new mn, ft=new mn) {
                super(),
                this.isCubicBezierCurve = !0,
                this.type = "CubicBezierCurve",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt,
                this.v3 = ft
            }
            getPoint(tt, lt=new mn) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2
                  , Mt = this.v3;
                return mt.set(S_(tt, ft.x, xt.x, Ct.x, Mt.x), S_(tt, ft.y, xt.y, Ct.y, Mt.y)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this.v3.copy(tt.v3),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt.v3 = this.v3.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this.v3.fromArray(tt.v3),
                this
            }
        }
        class Kx extends Hl {
            constructor(tt=new Er, lt=new Er, mt=new Er, ft=new Er) {
                super(),
                this.isCubicBezierCurve3 = !0,
                this.type = "CubicBezierCurve3",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt,
                this.v3 = ft
            }
            getPoint(tt, lt=new Er) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2
                  , Mt = this.v3;
                return mt.set(S_(tt, ft.x, xt.x, Ct.x, Mt.x), S_(tt, ft.y, xt.y, Ct.y, Mt.y), S_(tt, ft.z, xt.z, Ct.z, Mt.z)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this.v3.copy(tt.v3),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt.v3 = this.v3.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this.v3.fromArray(tt.v3),
                this
            }
        }
        class sy extends Hl {
            constructor(tt=new mn, lt=new mn) {
                super(),
                this.isLineCurve = !0,
                this.type = "LineCurve",
                this.v1 = tt,
                this.v2 = lt
            }
            getPoint(tt, lt=new mn) {
                const mt = lt;
                return tt === 1 ? mt.copy(this.v2) : (mt.copy(this.v2).sub(this.v1),
                mt.multiplyScalar(tt).add(this.v1)),
                mt
            }
            getPointAt(tt, lt) {
                return this.getPoint(tt, lt)
            }
            getTangent(tt, lt=new mn) {
                return lt.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(tt, lt) {
                return this.getTangent(tt, lt)
            }
            copy(tt) {
                return super.copy(tt),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class Jx extends Hl {
            constructor(tt=new Er, lt=new Er) {
                super(),
                this.isLineCurve3 = !0,
                this.type = "LineCurve3",
                this.v1 = tt,
                this.v2 = lt
            }
            getPoint(tt, lt=new Er) {
                const mt = lt;
                return tt === 1 ? mt.copy(this.v2) : (mt.copy(this.v2).sub(this.v1),
                mt.multiplyScalar(tt).add(this.v1)),
                mt
            }
            getPointAt(tt, lt) {
                return this.getPoint(tt, lt)
            }
            getTangent(tt, lt=new Er) {
                return lt.subVectors(this.v2, this.v1).normalize()
            }
            getTangentAt(tt, lt) {
                return this.getTangent(tt, lt)
            }
            copy(tt) {
                return super.copy(tt),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class ay extends Hl {
            constructor(tt=new mn, lt=new mn, mt=new mn) {
                super(),
                this.isQuadraticBezierCurve = !0,
                this.type = "QuadraticBezierCurve",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt
            }
            getPoint(tt, lt=new mn) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2;
                return mt.set(w_(tt, ft.x, xt.x, Ct.x), w_(tt, ft.y, xt.y, Ct.y)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class ly extends Hl {
            constructor(tt=new Er, lt=new Er, mt=new Er) {
                super(),
                this.isQuadraticBezierCurve3 = !0,
                this.type = "QuadraticBezierCurve3",
                this.v0 = tt,
                this.v1 = lt,
                this.v2 = mt
            }
            getPoint(tt, lt=new Er) {
                const mt = lt
                  , ft = this.v0
                  , xt = this.v1
                  , Ct = this.v2;
                return mt.set(w_(tt, ft.x, xt.x, Ct.x), w_(tt, ft.y, xt.y, Ct.y), w_(tt, ft.z, xt.z, Ct.z)),
                mt
            }
            copy(tt) {
                return super.copy(tt),
                this.v0.copy(tt.v0),
                this.v1.copy(tt.v1),
                this.v2.copy(tt.v2),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.v0 = this.v0.toArray(),
                tt.v1 = this.v1.toArray(),
                tt.v2 = this.v2.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.v0.fromArray(tt.v0),
                this.v1.fromArray(tt.v1),
                this.v2.fromArray(tt.v2),
                this
            }
        }
        class cy extends Hl {
            constructor(tt=[]) {
                super(),
                this.isSplineCurve = !0,
                this.type = "SplineCurve",
                this.points = tt
            }
            getPoint(tt, lt=new mn) {
                const mt = lt
                  , ft = this.points
                  , xt = (ft.length - 1) * tt
                  , Ct = Math.floor(xt)
                  , Mt = xt - Ct
                  , Lt = ft[Ct === 0 ? Ct : Ct - 1]
                  , Nt = ft[Ct]
                  , jt = ft[Ct > ft.length - 2 ? ft.length - 1 : Ct + 1]
                  , Wt = ft[Ct > ft.length - 3 ? ft.length - 1 : Ct + 2];
                return mt.set(Yx(Mt, Lt.x, Nt.x, jt.x, Wt.x), Yx(Mt, Lt.y, Nt.y, jt.y, Wt.y)),
                mt
            }
            copy(tt) {
                super.copy(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(ft.clone())
                }
                return this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.points = [];
                for (let lt = 0, mt = this.points.length; lt < mt; lt++) {
                    const ft = this.points[lt];
                    tt.points.push(ft.toArray())
                }
                return tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.points = [];
                for (let lt = 0, mt = tt.points.length; lt < mt; lt++) {
                    const ft = tt.points[lt];
                    this.points.push(new mn().fromArray(ft))
                }
                return this
            }
        }
        var zv = Object.freeze({
            __proto__: null,
            ArcCurve: $x,
            CatmullRomCurve3: Xx,
            CubicBezierCurve: oy,
            CubicBezierCurve3: Kx,
            EllipseCurve: Vv,
            LineCurve: sy,
            LineCurve3: Jx,
            QuadraticBezierCurve: ay,
            QuadraticBezierCurve3: ly,
            SplineCurve: cy
        });
        class Zx extends Hl {
            constructor() {
                super(),
                this.type = "CurvePath",
                this.curves = [],
                this.autoClose = !1
            }
            add(tt) {
                this.curves.push(tt)
            }
            closePath() {
                const tt = this.curves[0].getPoint(0)
                  , lt = this.curves[this.curves.length - 1].getPoint(1);
                if (!tt.equals(lt)) {
                    const mt = tt.isVector2 === !0 ? "LineCurve" : "LineCurve3";
                    this.curves.push(new zv[mt](lt,tt))
                }
                return this
            }
            getPoint(tt, lt) {
                const mt = tt * this.getLength()
                  , ft = this.getCurveLengths();
                let xt = 0;
                for (; xt < ft.length; ) {
                    if (ft[xt] >= mt) {
                        const Ct = ft[xt] - mt
                          , Mt = this.curves[xt]
                          , Lt = Mt.getLength()
                          , Nt = Lt === 0 ? 0 : 1 - Ct / Lt;
                        return Mt.getPointAt(Nt, lt)
                    }
                    xt++
                }
                return null
            }
            getLength() {
                const tt = this.getCurveLengths();
                return tt[tt.length - 1]
            }
            updateArcLengths() {
                this.needsUpdate = !0,
                this.cacheLengths = null,
                this.getCurveLengths()
            }
            getCurveLengths() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                    return this.cacheLengths;
                const tt = [];
                let lt = 0;
                for (let mt = 0, ft = this.curves.length; mt < ft; mt++)
                    lt += this.curves[mt].getLength(),
                    tt.push(lt);
                return this.cacheLengths = tt,
                tt
            }
            getSpacedPoints(tt=40) {
                const lt = [];
                for (let mt = 0; mt <= tt; mt++)
                    lt.push(this.getPoint(mt / tt));
                return this.autoClose && lt.push(lt[0]),
                lt
            }
            getPoints(tt=12) {
                const lt = [];
                let mt;
                for (let ft = 0, xt = this.curves; ft < xt.length; ft++) {
                    const Ct = xt[ft]
                      , Mt = Ct.isEllipseCurve ? 2 * tt : Ct.isLineCurve || Ct.isLineCurve3 ? 1 : Ct.isSplineCurve ? tt * Ct.points.length : tt
                      , Lt = Ct.getPoints(Mt);
                    for (let Nt = 0; Nt < Lt.length; Nt++) {
                        const jt = Lt[Nt];
                        mt && mt.equals(jt) || (lt.push(jt),
                        mt = jt)
                    }
                }
                return this.autoClose && lt.length > 1 && !lt[lt.length - 1].equals(lt[0]) && lt.push(lt[0]),
                lt
            }
            copy(tt) {
                super.copy(tt),
                this.curves = [];
                for (let lt = 0, mt = tt.curves.length; lt < mt; lt++) {
                    const ft = tt.curves[lt];
                    this.curves.push(ft.clone())
                }
                return this.autoClose = tt.autoClose,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.autoClose = this.autoClose,
                tt.curves = [];
                for (let lt = 0, mt = this.curves.length; lt < mt; lt++) {
                    const ft = this.curves[lt];
                    tt.curves.push(ft.toJSON())
                }
                return tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.autoClose = tt.autoClose,
                this.curves = [];
                for (let lt = 0, mt = tt.curves.length; lt < mt; lt++) {
                    const ft = tt.curves[lt];
                    this.curves.push(new zv[ft.type]().fromJSON(ft))
                }
                return this
            }
        }
        class E_ extends Zx {
            constructor(tt) {
                super(),
                this.type = "Path",
                this.currentPoint = new mn,
                tt && this.setFromPoints(tt)
            }
            setFromPoints(tt) {
                this.moveTo(tt[0].x, tt[0].y);
                for (let lt = 1, mt = tt.length; lt < mt; lt++)
                    this.lineTo(tt[lt].x, tt[lt].y);
                return this
            }
            moveTo(tt, lt) {
                return this.currentPoint.set(tt, lt),
                this
            }
            lineTo(tt, lt) {
                const mt = new sy(this.currentPoint.clone(),new mn(tt,lt));
                return this.curves.push(mt),
                this.currentPoint.set(tt, lt),
                this
            }
            quadraticCurveTo(tt, lt, mt, ft) {
                const xt = new ay(this.currentPoint.clone(),new mn(tt,lt),new mn(mt,ft));
                return this.curves.push(xt),
                this.currentPoint.set(mt, ft),
                this
            }
            bezierCurveTo(tt, lt, mt, ft, xt, Ct) {
                const Mt = new oy(this.currentPoint.clone(),new mn(tt,lt),new mn(mt,ft),new mn(xt,Ct));
                return this.curves.push(Mt),
                this.currentPoint.set(xt, Ct),
                this
            }
            splineThru(tt) {
                const lt = [this.currentPoint.clone()].concat(tt)
                  , mt = new cy(lt);
                return this.curves.push(mt),
                this.currentPoint.copy(tt[tt.length - 1]),
                this
            }
            arc(tt, lt, mt, ft, xt, Ct) {
                const Mt = this.currentPoint.x
                  , Lt = this.currentPoint.y;
                return this.absarc(tt + Mt, lt + Lt, mt, ft, xt, Ct),
                this
            }
            absarc(tt, lt, mt, ft, xt, Ct) {
                return this.absellipse(tt, lt, mt, mt, ft, xt, Ct),
                this
            }
            ellipse(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                const Nt = this.currentPoint.x
                  , jt = this.currentPoint.y;
                return this.absellipse(tt + Nt, lt + jt, mt, ft, xt, Ct, Mt, Lt),
                this
            }
            absellipse(tt, lt, mt, ft, xt, Ct, Mt, Lt) {
                const Nt = new Vv(tt,lt,mt,ft,xt,Ct,Mt,Lt);
                if (this.curves.length > 0) {
                    const Wt = Nt.getPoint(0);
                    Wt.equals(this.currentPoint) || this.lineTo(Wt.x, Wt.y)
                }
                this.curves.push(Nt);
                const jt = Nt.getPoint(1);
                return this.currentPoint.copy(jt),
                this
            }
            copy(tt) {
                return super.copy(tt),
                this.currentPoint.copy(tt.currentPoint),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.currentPoint = this.currentPoint.toArray(),
                tt
            }
            fromJSON(tt) {
                return super.fromJSON(tt),
                this.currentPoint.fromArray(tt.currentPoint),
                this
            }
        }
        class T_ extends bo {
            constructor(tt=[new mn(0,-.5), new mn(.5,0), new mn(0,.5)], lt=12, mt=0, ft=2 * Math.PI) {
                super(),
                this.type = "LatheGeometry",
                this.parameters = {
                    points: tt,
                    segments: lt,
                    phiStart: mt,
                    phiLength: ft
                },
                lt = Math.floor(lt),
                ft = qo(ft, 0, 2 * Math.PI);
                const xt = []
                  , Ct = []
                  , Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = 1 / lt
                  , Wt = new Er
                  , Qt = new mn
                  , qt = new Er
                  , Xt = new Er
                  , Zt = new Er;
                let Yt = 0
                  , sr = 0;
                for (let er = 0; er <= tt.length - 1; er++)
                    switch (er) {
                    case 0:
                        Yt = tt[er + 1].x - tt[er].x,
                        sr = tt[er + 1].y - tt[er].y,
                        qt.x = 1 * sr,
                        qt.y = -Yt,
                        qt.z = 0 * sr,
                        Zt.copy(qt),
                        qt.normalize(),
                        Lt.push(qt.x, qt.y, qt.z);
                        break;
                    case tt.length - 1:
                        Lt.push(Zt.x, Zt.y, Zt.z);
                        break;
                    default:
                        Yt = tt[er + 1].x - tt[er].x,
                        sr = tt[er + 1].y - tt[er].y,
                        qt.x = 1 * sr,
                        qt.y = -Yt,
                        qt.z = 0 * sr,
                        Xt.copy(qt),
                        qt.x += Zt.x,
                        qt.y += Zt.y,
                        qt.z += Zt.z,
                        qt.normalize(),
                        Lt.push(qt.x, qt.y, qt.z),
                        Zt.copy(Xt)
                    }
                for (let er = 0; er <= lt; er++) {
                    const rr = mt + er * jt * ft
                      , xr = Math.sin(rr)
                      , br = Math.cos(rr);
                    for (let yr = 0; yr <= tt.length - 1; yr++) {
                        Wt.x = tt[yr].x * xr,
                        Wt.y = tt[yr].y,
                        Wt.z = tt[yr].x * br,
                        Ct.push(Wt.x, Wt.y, Wt.z),
                        Qt.x = er / lt,
                        Qt.y = yr / (tt.length - 1),
                        Mt.push(Qt.x, Qt.y);
                        const Pr = Lt[3 * yr + 0] * xr
                          , zr = Lt[3 * yr + 1]
                          , Nr = Lt[3 * yr + 0] * br;
                        Nt.push(Pr, zr, Nr)
                    }
                }
                for (let er = 0; er < lt; er++)
                    for (let rr = 0; rr < tt.length - 1; rr++) {
                        const xr = rr + er * tt.length
                          , br = xr
                          , yr = xr + tt.length
                          , Pr = xr + tt.length + 1
                          , zr = xr + 1;
                        xt.push(br, yr, zr),
                        xt.push(Pr, zr, yr)
                    }
                this.setIndex(xt),
                this.setAttribute("position", new Fn(Ct,3)),
                this.setAttribute("uv", new Fn(Mt,2)),
                this.setAttribute("normal", new Fn(Nt,3))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new T_(tt.points,tt.segments,tt.phiStart,tt.phiLength)
            }
        }
        class Hv extends T_ {
            constructor(tt=1, lt=1, mt=4, ft=8) {
                const xt = new E_;
                xt.absarc(0, -lt / 2, tt, 1.5 * Math.PI, 0),
                xt.absarc(0, lt / 2, tt, 0, .5 * Math.PI),
                super(xt.getPoints(mt), ft),
                this.type = "CapsuleGeometry",
                this.parameters = {
                    radius: tt,
                    length: lt,
                    capSegments: mt,
                    radialSegments: ft
                }
            }
            static fromJSON(tt) {
                return new Hv(tt.radius,tt.length,tt.capSegments,tt.radialSegments)
            }
        }
        class Qv extends bo {
            constructor(tt=1, lt=32, mt=0, ft=2 * Math.PI) {
                super(),
                this.type = "CircleGeometry",
                this.parameters = {
                    radius: tt,
                    segments: lt,
                    thetaStart: mt,
                    thetaLength: ft
                },
                lt = Math.max(3, lt);
                const xt = []
                  , Ct = []
                  , Mt = []
                  , Lt = []
                  , Nt = new Er
                  , jt = new mn;
                Ct.push(0, 0, 0),
                Mt.push(0, 0, 1),
                Lt.push(.5, .5);
                for (let Wt = 0, Qt = 3; Wt <= lt; Wt++,
                Qt += 3) {
                    const qt = mt + Wt / lt * ft;
                    Nt.x = tt * Math.cos(qt),
                    Nt.y = tt * Math.sin(qt),
                    Ct.push(Nt.x, Nt.y, Nt.z),
                    Mt.push(0, 0, 1),
                    jt.x = (Ct[Qt] / tt + 1) / 2,
                    jt.y = (Ct[Qt + 1] / tt + 1) / 2,
                    Lt.push(jt.x, jt.y)
                }
                for (let Wt = 1; Wt <= lt; Wt++)
                    xt.push(Wt, Wt + 1, 0);
                this.setIndex(xt),
                this.setAttribute("position", new Fn(Ct,3)),
                this.setAttribute("normal", new Fn(Mt,3)),
                this.setAttribute("uv", new Fn(Lt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new Qv(tt.radius,tt.segments,tt.thetaStart,tt.thetaLength)
            }
        }
        class Im extends bo {
            constructor(tt=1, lt=1, mt=1, ft=32, xt=1, Ct=!1, Mt=0, Lt=2 * Math.PI) {
                super(),
                this.type = "CylinderGeometry",
                this.parameters = {
                    radiusTop: tt,
                    radiusBottom: lt,
                    height: mt,
                    radialSegments: ft,
                    heightSegments: xt,
                    openEnded: Ct,
                    thetaStart: Mt,
                    thetaLength: Lt
                };
                const Nt = this;
                ft = Math.floor(ft),
                xt = Math.floor(xt);
                const jt = []
                  , Wt = []
                  , Qt = []
                  , qt = [];
                let Xt = 0;
                const Zt = []
                  , Yt = mt / 2;
                let sr = 0;
                function er(rr) {
                    const xr = Xt
                      , br = new mn
                      , yr = new Er;
                    let Pr = 0;
                    const zr = rr === !0 ? tt : lt
                      , Nr = rr === !0 ? 1 : -1;
                    for (let Gr = 1; Gr <= ft; Gr++)
                        Wt.push(0, Yt * Nr, 0),
                        Qt.push(0, Nr, 0),
                        qt.push(.5, .5),
                        Xt++;
                    const Vr = Xt;
                    for (let Gr = 0; Gr <= ft; Gr++) {
                        const Hr = Gr / ft * Lt + Mt
                          , _n = Math.cos(Hr)
                          , dn = Math.sin(Hr);
                        yr.x = zr * dn,
                        yr.y = Yt * Nr,
                        yr.z = zr * _n,
                        Wt.push(yr.x, yr.y, yr.z),
                        Qt.push(0, Nr, 0),
                        br.x = .5 * _n + .5,
                        br.y = .5 * dn * Nr + .5,
                        qt.push(br.x, br.y),
                        Xt++
                    }
                    for (let Gr = 0; Gr < ft; Gr++) {
                        const Hr = xr + Gr
                          , _n = Vr + Gr;
                        rr === !0 ? jt.push(_n, _n + 1, Hr) : jt.push(_n + 1, _n, Hr),
                        Pr += 3
                    }
                    Nt.addGroup(sr, Pr, rr === !0 ? 1 : 2),
                    sr += Pr
                }
                (function() {
                    const rr = new Er
                      , xr = new Er;
                    let br = 0;
                    const yr = (lt - tt) / mt;
                    for (let Pr = 0; Pr <= xt; Pr++) {
                        const zr = []
                          , Nr = Pr / xt
                          , Vr = Nr * (lt - tt) + tt;
                        for (let Gr = 0; Gr <= ft; Gr++) {
                            const Hr = Gr / ft
                              , _n = Hr * Lt + Mt
                              , dn = Math.sin(_n)
                              , kn = Math.cos(_n);
                            xr.x = Vr * dn,
                            xr.y = -Nr * mt + Yt,
                            xr.z = Vr * kn,
                            Wt.push(xr.x, xr.y, xr.z),
                            rr.set(dn, yr, kn).normalize(),
                            Qt.push(rr.x, rr.y, rr.z),
                            qt.push(Hr, 1 - Nr),
                            zr.push(Xt++)
                        }
                        Zt.push(zr)
                    }
                    for (let Pr = 0; Pr < ft; Pr++)
                        for (let zr = 0; zr < xt; zr++) {
                            const Nr = Zt[zr][Pr]
                              , Vr = Zt[zr + 1][Pr]
                              , Gr = Zt[zr + 1][Pr + 1]
                              , Hr = Zt[zr][Pr + 1];
                            jt.push(Nr, Vr, Hr),
                            jt.push(Vr, Gr, Hr),
                            br += 6
                        }
                    Nt.addGroup(sr, br, 0),
                    sr += br
                }
                )(),
                Ct === !1 && (tt > 0 && er(!0),
                lt > 0 && er(!1)),
                this.setIndex(jt),
                this.setAttribute("position", new Fn(Wt,3)),
                this.setAttribute("normal", new Fn(Qt,3)),
                this.setAttribute("uv", new Fn(qt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new Im(tt.radiusTop,tt.radiusBottom,tt.height,tt.radialSegments,tt.heightSegments,tt.openEnded,tt.thetaStart,tt.thetaLength)
            }
        }
        class Wv extends Im {
            constructor(tt=1, lt=1, mt=32, ft=1, xt=!1, Ct=0, Mt=2 * Math.PI) {
                super(0, tt, lt, mt, ft, xt, Ct, Mt),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: tt,
                    height: lt,
                    radialSegments: mt,
                    heightSegments: ft,
                    openEnded: xt,
                    thetaStart: Ct,
                    thetaLength: Mt
                }
            }
            static fromJSON(tt) {
                return new Wv(tt.radius,tt.height,tt.radialSegments,tt.heightSegments,tt.openEnded,tt.thetaStart,tt.thetaLength)
            }
        }
        class tp extends bo {
            constructor(tt=[], lt=[], mt=1, ft=0) {
                super(),
                this.type = "PolyhedronGeometry",
                this.parameters = {
                    vertices: tt,
                    indices: lt,
                    radius: mt,
                    detail: ft
                };
                const xt = []
                  , Ct = [];
                function Mt(Qt, qt, Xt, Zt) {
                    const Yt = Zt + 1
                      , sr = [];
                    for (let er = 0; er <= Yt; er++) {
                        sr[er] = [];
                        const rr = Qt.clone().lerp(Xt, er / Yt)
                          , xr = qt.clone().lerp(Xt, er / Yt)
                          , br = Yt - er;
                        for (let yr = 0; yr <= br; yr++)
                            sr[er][yr] = yr === 0 && er === Yt ? rr : rr.clone().lerp(xr, yr / br)
                    }
                    for (let er = 0; er < Yt; er++)
                        for (let rr = 0; rr < 2 * (Yt - er) - 1; rr++) {
                            const xr = Math.floor(rr / 2);
                            rr % 2 == 0 ? (Lt(sr[er][xr + 1]),
                            Lt(sr[er + 1][xr]),
                            Lt(sr[er][xr])) : (Lt(sr[er][xr + 1]),
                            Lt(sr[er + 1][xr + 1]),
                            Lt(sr[er + 1][xr]))
                        }
                }
                function Lt(Qt) {
                    xt.push(Qt.x, Qt.y, Qt.z)
                }
                function Nt(Qt, qt) {
                    const Xt = 3 * Qt;
                    qt.x = tt[Xt + 0],
                    qt.y = tt[Xt + 1],
                    qt.z = tt[Xt + 2]
                }
                function jt(Qt, qt, Xt, Zt) {
                    Zt < 0 && Qt.x === 1 && (Ct[qt] = Qt.x - 1),
                    Xt.x === 0 && Xt.z === 0 && (Ct[qt] = Zt / 2 / Math.PI + .5)
                }
                function Wt(Qt) {
                    return Math.atan2(Qt.z, -Qt.x)
                }
                (function(Qt) {
                    const qt = new Er
                      , Xt = new Er
                      , Zt = new Er;
                    for (let Yt = 0; Yt < lt.length; Yt += 3)
                        Nt(lt[Yt + 0], qt),
                        Nt(lt[Yt + 1], Xt),
                        Nt(lt[Yt + 2], Zt),
                        Mt(qt, Xt, Zt, Qt)
                }
                )(ft),
                function(Qt) {
                    const qt = new Er;
                    for (let Xt = 0; Xt < xt.length; Xt += 3)
                        qt.x = xt[Xt + 0],
                        qt.y = xt[Xt + 1],
                        qt.z = xt[Xt + 2],
                        qt.normalize().multiplyScalar(Qt),
                        xt[Xt + 0] = qt.x,
                        xt[Xt + 1] = qt.y,
                        xt[Xt + 2] = qt.z
                }(mt),
                function() {
                    const Qt = new Er;
                    for (let Xt = 0; Xt < xt.length; Xt += 3) {
                        Qt.x = xt[Xt + 0],
                        Qt.y = xt[Xt + 1],
                        Qt.z = xt[Xt + 2];
                        const Zt = Wt(Qt) / 2 / Math.PI + .5
                          , Yt = (qt = Qt,
                        Math.atan2(-qt.y, Math.sqrt(qt.x * qt.x + qt.z * qt.z)) / Math.PI + .5);
                        Ct.push(Zt, 1 - Yt)
                    }
                    var qt;
                    (function() {
                        const Xt = new Er
                          , Zt = new Er
                          , Yt = new Er
                          , sr = new Er
                          , er = new mn
                          , rr = new mn
                          , xr = new mn;
                        for (let br = 0, yr = 0; br < xt.length; br += 9,
                        yr += 6) {
                            Xt.set(xt[br + 0], xt[br + 1], xt[br + 2]),
                            Zt.set(xt[br + 3], xt[br + 4], xt[br + 5]),
                            Yt.set(xt[br + 6], xt[br + 7], xt[br + 8]),
                            er.set(Ct[yr + 0], Ct[yr + 1]),
                            rr.set(Ct[yr + 2], Ct[yr + 3]),
                            xr.set(Ct[yr + 4], Ct[yr + 5]),
                            sr.copy(Xt).add(Zt).add(Yt).divideScalar(3);
                            const Pr = Wt(sr);
                            jt(er, yr + 0, Xt, Pr),
                            jt(rr, yr + 2, Zt, Pr),
                            jt(xr, yr + 4, Yt, Pr)
                        }
                    }
                    )(),
                    function() {
                        for (let Xt = 0; Xt < Ct.length; Xt += 6) {
                            const Zt = Ct[Xt + 0]
                              , Yt = Ct[Xt + 2]
                              , sr = Ct[Xt + 4]
                              , er = Math.max(Zt, Yt, sr)
                              , rr = Math.min(Zt, Yt, sr);
                            er > .9 && rr < .1 && (Zt < .2 && (Ct[Xt + 0] += 1),
                            Yt < .2 && (Ct[Xt + 2] += 1),
                            sr < .2 && (Ct[Xt + 4] += 1))
                        }
                    }()
                }(),
                this.setAttribute("position", new Fn(xt,3)),
                this.setAttribute("normal", new Fn(xt.slice(),3)),
                this.setAttribute("uv", new Fn(Ct,2)),
                ft === 0 ? this.computeVertexNormals() : this.normalizeNormals()
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new tp(tt.vertices,tt.indices,tt.radius,tt.details)
            }
        }
        class qv extends tp {
            constructor(tt=1, lt=0) {
                const mt = (1 + Math.sqrt(5)) / 2
                  , ft = 1 / mt;
                super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -ft, -mt, 0, -ft, mt, 0, ft, -mt, 0, ft, mt, -ft, -mt, 0, -ft, mt, 0, ft, -mt, 0, ft, mt, 0, -mt, 0, -ft, mt, 0, -ft, -mt, 0, ft, mt, 0, ft], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], tt, lt),
                this.type = "DodecahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new qv(tt.radius,tt.detail)
            }
        }
        const $v = new Er
          , Xv = new Er
          , uy = new Er
          , Yv = new Es;
        class eA extends bo {
            constructor(tt=null, lt=1) {
                if (super(),
                this.type = "EdgesGeometry",
                this.parameters = {
                    geometry: tt,
                    thresholdAngle: lt
                },
                tt !== null) {
                    const ft = Math.pow(10, 4)
                      , xt = Math.cos(Zl * lt)
                      , Ct = tt.getIndex()
                      , Mt = tt.getAttribute("position")
                      , Lt = Ct ? Ct.count : Mt.count
                      , Nt = [0, 0, 0]
                      , jt = ["a", "b", "c"]
                      , Wt = new Array(3)
                      , Qt = {}
                      , qt = [];
                    for (let Xt = 0; Xt < Lt; Xt += 3) {
                        Ct ? (Nt[0] = Ct.getX(Xt),
                        Nt[1] = Ct.getX(Xt + 1),
                        Nt[2] = Ct.getX(Xt + 2)) : (Nt[0] = Xt,
                        Nt[1] = Xt + 1,
                        Nt[2] = Xt + 2);
                        const {a: Zt, b: Yt, c: sr} = Yv;
                        if (Zt.fromBufferAttribute(Mt, Nt[0]),
                        Yt.fromBufferAttribute(Mt, Nt[1]),
                        sr.fromBufferAttribute(Mt, Nt[2]),
                        Yv.getNormal(uy),
                        Wt[0] = `${Math.round(Zt.x * ft)},${Math.round(Zt.y * ft)},${Math.round(Zt.z * ft)}`,
                        Wt[1] = `${Math.round(Yt.x * ft)},${Math.round(Yt.y * ft)},${Math.round(Yt.z * ft)}`,
                        Wt[2] = `${Math.round(sr.x * ft)},${Math.round(sr.y * ft)},${Math.round(sr.z * ft)}`,
                        Wt[0] !== Wt[1] && Wt[1] !== Wt[2] && Wt[2] !== Wt[0])
                            for (let er = 0; er < 3; er++) {
                                const rr = (er + 1) % 3
                                  , xr = Wt[er]
                                  , br = Wt[rr]
                                  , yr = Yv[jt[er]]
                                  , Pr = Yv[jt[rr]]
                                  , zr = `${xr}_${br}`
                                  , Nr = `${br}_${xr}`;
                                Nr in Qt && Qt[Nr] ? (uy.dot(Qt[Nr].normal) <= xt && (qt.push(yr.x, yr.y, yr.z),
                                qt.push(Pr.x, Pr.y, Pr.z)),
                                Qt[Nr] = null) : zr in Qt || (Qt[zr] = {
                                    index0: Nt[er],
                                    index1: Nt[rr],
                                    normal: uy.clone()
                                })
                            }
                    }
                    for (const Xt in Qt)
                        if (Qt[Xt]) {
                            const {index0: Zt, index1: Yt} = Qt[Xt];
                            $v.fromBufferAttribute(Mt, Zt),
                            Xv.fromBufferAttribute(Mt, Yt),
                            qt.push($v.x, $v.y, $v.z),
                            qt.push(Xv.x, Xv.y, Xv.z)
                        }
                    this.setAttribute("position", new Fn(qt,3))
                }
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
        }
        class Pp extends E_ {
            constructor(tt) {
                super(tt),
                this.uuid = Ms(),
                this.type = "Shape",
                this.holes = []
            }
            getPointsHoles(tt) {
                const lt = [];
                for (let mt = 0, ft = this.holes.length; mt < ft; mt++)
                    lt[mt] = this.holes[mt].getPoints(tt);
                return lt
            }
            extractPoints(tt) {
                return {
                    shape: this.getPoints(tt),
                    holes: this.getPointsHoles(tt)
                }
            }
            copy(tt) {
                super.copy(tt),
                this.holes = [];
                for (let lt = 0, mt = tt.holes.length; lt < mt; lt++) {
                    const ft = tt.holes[lt];
                    this.holes.push(ft.clone())
                }
                return this
            }
            toJSON() {
                const tt = super.toJSON();
                tt.uuid = this.uuid,
                tt.holes = [];
                for (let lt = 0, mt = this.holes.length; lt < mt; lt++) {
                    const ft = this.holes[lt];
                    tt.holes.push(ft.toJSON())
                }
                return tt
            }
            fromJSON(tt) {
                super.fromJSON(tt),
                this.uuid = tt.uuid,
                this.holes = [];
                for (let lt = 0, mt = tt.holes.length; lt < mt; lt++) {
                    const ft = tt.holes[lt];
                    this.holes.push(new E_().fromJSON(ft))
                }
                return this
            }
        }
        function tA(Tt, tt, lt, mt, ft) {
            let xt, Ct;
            if (ft === function(Mt, Lt, Nt, jt) {
                let Wt = 0;
                for (let Qt = Lt, qt = Nt - jt; Qt < Nt; Qt += jt)
                    Wt += (Mt[qt] - Mt[Qt]) * (Mt[Qt + 1] + Mt[qt + 1]),
                    qt = Qt;
                return Wt
            }(Tt, tt, lt, mt) > 0)
                for (xt = tt; xt < lt; xt += mt)
                    Ct = iA(xt, Tt[xt], Tt[xt + 1], Ct);
            else
                for (xt = lt - mt; xt >= tt; xt -= mt)
                    Ct = iA(xt, Tt[xt], Tt[xt + 1], Ct);
            return Ct && Kv(Ct, Ct.next) && (M_(Ct),
            Ct = Ct.next),
            Ct
        }
        function Mp(Tt, tt) {
            if (!Tt)
                return Tt;
            tt || (tt = Tt);
            let lt, mt = Tt;
            do
                if (lt = !1,
                mt.steiner || !Kv(mt, mt.next) && Ko(mt.prev, mt, mt.next) !== 0)
                    mt = mt.next;
                else {
                    if (M_(mt),
                    mt = tt = mt.prev,
                    mt === mt.next)
                        break;
                    lt = !0
                }
            while (lt || mt !== tt);
            return tt
        }
        function C_(Tt, tt, lt, mt, ft, xt, Ct) {
            if (!Tt)
                return;
            !Ct && xt && function(jt, Wt, Qt, qt) {
                let Xt = jt;
                do
                    Xt.z === 0 && (Xt.z = dy(Xt.x, Xt.y, Wt, Qt, qt)),
                    Xt.prevZ = Xt.prev,
                    Xt.nextZ = Xt.next,
                    Xt = Xt.next;
                while (Xt !== jt);
                Xt.prevZ.nextZ = null,
                Xt.prevZ = null,
                function(Zt) {
                    let Yt, sr, er, rr, xr, br, yr, Pr, zr = 1;
                    do {
                        for (sr = Zt,
                        Zt = null,
                        xr = null,
                        br = 0; sr; ) {
                            for (br++,
                            er = sr,
                            yr = 0,
                            Yt = 0; Yt < zr && (yr++,
                            er = er.nextZ,
                            er); Yt++)
                                ;
                            for (Pr = zr; yr > 0 || Pr > 0 && er; )
                                yr !== 0 && (Pr === 0 || !er || sr.z <= er.z) ? (rr = sr,
                                sr = sr.nextZ,
                                yr--) : (rr = er,
                                er = er.nextZ,
                                Pr--),
                                xr ? xr.nextZ = rr : Zt = rr,
                                rr.prevZ = xr,
                                xr = rr;
                            sr = er
                        }
                        xr.nextZ = null,
                        zr *= 2
                    } while (br > 1)
                }(Xt)
            }(Tt, mt, ft, xt);
            let Mt, Lt, Nt = Tt;
            for (; Tt.prev !== Tt.next; )
                if (Mt = Tt.prev,
                Lt = Tt.next,
                xt ? hS(Tt, mt, ft, xt) : pS(Tt))
                    tt.push(Mt.i / lt | 0),
                    tt.push(Tt.i / lt | 0),
                    tt.push(Lt.i / lt | 0),
                    M_(Tt),
                    Tt = Lt.next,
                    Nt = Lt.next;
                else if ((Tt = Lt) === Nt) {
                    Ct ? Ct === 1 ? C_(Tt = mS(Mp(Tt), tt, lt), tt, lt, mt, ft, xt, 2) : Ct === 2 && fS(Tt, tt, lt, mt, ft, xt) : C_(Mp(Tt), tt, lt, mt, ft, xt, 1);
                    break
                }
        }
        function pS(Tt) {
            const tt = Tt.prev
              , lt = Tt
              , mt = Tt.next;
            if (Ko(tt, lt, mt) >= 0)
                return !1;
            const ft = tt.x
              , xt = lt.x
              , Ct = mt.x
              , Mt = tt.y
              , Lt = lt.y
              , Nt = mt.y
              , jt = ft < xt ? ft < Ct ? ft : Ct : xt < Ct ? xt : Ct
              , Wt = Mt < Lt ? Mt < Nt ? Mt : Nt : Lt < Nt ? Lt : Nt
              , Qt = ft > xt ? ft > Ct ? ft : Ct : xt > Ct ? xt : Ct
              , qt = Mt > Lt ? Mt > Nt ? Mt : Nt : Lt > Nt ? Lt : Nt;
            let Xt = mt.next;
            for (; Xt !== tt; ) {
                if (Xt.x >= jt && Xt.x <= Qt && Xt.y >= Wt && Xt.y <= qt && km(ft, Mt, xt, Lt, Ct, Nt, Xt.x, Xt.y) && Ko(Xt.prev, Xt, Xt.next) >= 0)
                    return !1;
                Xt = Xt.next
            }
            return !0
        }
        function hS(Tt, tt, lt, mt) {
            const ft = Tt.prev
              , xt = Tt
              , Ct = Tt.next;
            if (Ko(ft, xt, Ct) >= 0)
                return !1;
            const Mt = ft.x
              , Lt = xt.x
              , Nt = Ct.x
              , jt = ft.y
              , Wt = xt.y
              , Qt = Ct.y
              , qt = Mt < Lt ? Mt < Nt ? Mt : Nt : Lt < Nt ? Lt : Nt
              , Xt = jt < Wt ? jt < Qt ? jt : Qt : Wt < Qt ? Wt : Qt
              , Zt = Mt > Lt ? Mt > Nt ? Mt : Nt : Lt > Nt ? Lt : Nt
              , Yt = jt > Wt ? jt > Qt ? jt : Qt : Wt > Qt ? Wt : Qt
              , sr = dy(qt, Xt, tt, lt, mt)
              , er = dy(Zt, Yt, tt, lt, mt);
            let rr = Tt.prevZ
              , xr = Tt.nextZ;
            for (; rr && rr.z >= sr && xr && xr.z <= er; ) {
                if (rr.x >= qt && rr.x <= Zt && rr.y >= Xt && rr.y <= Yt && rr !== ft && rr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, rr.x, rr.y) && Ko(rr.prev, rr, rr.next) >= 0 || (rr = rr.prevZ,
                xr.x >= qt && xr.x <= Zt && xr.y >= Xt && xr.y <= Yt && xr !== ft && xr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, xr.x, xr.y) && Ko(xr.prev, xr, xr.next) >= 0))
                    return !1;
                xr = xr.nextZ
            }
            for (; rr && rr.z >= sr; ) {
                if (rr.x >= qt && rr.x <= Zt && rr.y >= Xt && rr.y <= Yt && rr !== ft && rr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, rr.x, rr.y) && Ko(rr.prev, rr, rr.next) >= 0)
                    return !1;
                rr = rr.prevZ
            }
            for (; xr && xr.z <= er; ) {
                if (xr.x >= qt && xr.x <= Zt && xr.y >= Xt && xr.y <= Yt && xr !== ft && xr !== Ct && km(Mt, jt, Lt, Wt, Nt, Qt, xr.x, xr.y) && Ko(xr.prev, xr, xr.next) >= 0)
                    return !1;
                xr = xr.nextZ
            }
            return !0
        }
        function mS(Tt, tt, lt) {
            let mt = Tt;
            do {
                const ft = mt.prev
                  , xt = mt.next.next;
                !Kv(ft, xt) && rA(ft, mt, mt.next, xt) && P_(ft, xt) && P_(xt, ft) && (tt.push(ft.i / lt | 0),
                tt.push(mt.i / lt | 0),
                tt.push(xt.i / lt | 0),
                M_(mt),
                M_(mt.next),
                mt = Tt = xt),
                mt = mt.next
            } while (mt !== Tt);
            return Mp(mt)
        }
        function fS(Tt, tt, lt, mt, ft, xt) {
            let Ct = Tt;
            do {
                let Mt = Ct.next.next;
                for (; Mt !== Ct.prev; ) {
                    if (Ct.i !== Mt.i && xS(Ct, Mt)) {
                        let Lt = nA(Ct, Mt);
                        return Ct = Mp(Ct, Ct.next),
                        Lt = Mp(Lt, Lt.next),
                        C_(Ct, tt, lt, mt, ft, xt, 0),
                        void C_(Lt, tt, lt, mt, ft, xt, 0)
                    }
                    Mt = Mt.next
                }
                Ct = Ct.next
            } while (Ct !== Tt)
        }
        function gS(Tt, tt) {
            return Tt.x - tt.x
        }
        function _S(Tt, tt) {
            const lt = function(ft, xt) {
                let Ct, Mt = xt, Lt = -1 / 0;
                const Nt = ft.x
                  , jt = ft.y;
                do {
                    if (jt <= Mt.y && jt >= Mt.next.y && Mt.next.y !== Mt.y) {
                        const Yt = Mt.x + (jt - Mt.y) * (Mt.next.x - Mt.x) / (Mt.next.y - Mt.y);
                        if (Yt <= Nt && Yt > Lt && (Lt = Yt,
                        Ct = Mt.x < Mt.next.x ? Mt : Mt.next,
                        Yt === Nt))
                            return Ct
                    }
                    Mt = Mt.next
                } while (Mt !== xt);
                if (!Ct)
                    return null;
                const Wt = Ct
                  , Qt = Ct.x
                  , qt = Ct.y;
                let Xt, Zt = 1 / 0;
                Mt = Ct;
                do
                    Nt >= Mt.x && Mt.x >= Qt && Nt !== Mt.x && km(jt < qt ? Nt : Lt, jt, Qt, qt, jt < qt ? Lt : Nt, jt, Mt.x, Mt.y) && (Xt = Math.abs(jt - Mt.y) / (Nt - Mt.x),
                    P_(Mt, ft) && (Xt < Zt || Xt === Zt && (Mt.x > Ct.x || Mt.x === Ct.x && vS(Ct, Mt))) && (Ct = Mt,
                    Zt = Xt)),
                    Mt = Mt.next;
                while (Mt !== Wt);
                return Ct
            }(Tt, tt);
            if (!lt)
                return tt;
            const mt = nA(lt, Tt);
            return Mp(mt, mt.next),
            Mp(lt, lt.next)
        }
        function vS(Tt, tt) {
            return Ko(Tt.prev, Tt, tt.prev) < 0 && Ko(tt.next, Tt, Tt.next) < 0
        }
        function dy(Tt, tt, lt, mt, ft) {
            return (Tt = 1431655765 & ((Tt = 858993459 & ((Tt = 252645135 & ((Tt = 16711935 & ((Tt = (Tt - lt) * ft | 0) | Tt << 8)) | Tt << 4)) | Tt << 2)) | Tt << 1)) | (tt = 1431655765 & ((tt = 858993459 & ((tt = 252645135 & ((tt = 16711935 & ((tt = (tt - mt) * ft | 0) | tt << 8)) | tt << 4)) | tt << 2)) | tt << 1)) << 1
        }
        function yS(Tt) {
            let tt = Tt
              , lt = Tt;
            do
                (tt.x < lt.x || tt.x === lt.x && tt.y < lt.y) && (lt = tt),
                tt = tt.next;
            while (tt !== Tt);
            return lt
        }
        function km(Tt, tt, lt, mt, ft, xt, Ct, Mt) {
            return (ft - Ct) * (tt - Mt) >= (Tt - Ct) * (xt - Mt) && (Tt - Ct) * (mt - Mt) >= (lt - Ct) * (tt - Mt) && (lt - Ct) * (xt - Mt) >= (ft - Ct) * (mt - Mt)
        }
        function xS(Tt, tt) {
            return Tt.next.i !== tt.i && Tt.prev.i !== tt.i && !function(lt, mt) {
                let ft = lt;
                do {
                    if (ft.i !== lt.i && ft.next.i !== lt.i && ft.i !== mt.i && ft.next.i !== mt.i && rA(ft, ft.next, lt, mt))
                        return !0;
                    ft = ft.next
                } while (ft !== lt);
                return !1
            }(Tt, tt) && (P_(Tt, tt) && P_(tt, Tt) && function(lt, mt) {
                let ft = lt
                  , xt = !1;
                const Ct = (lt.x + mt.x) / 2
                  , Mt = (lt.y + mt.y) / 2;
                do
                    ft.y > Mt != ft.next.y > Mt && ft.next.y !== ft.y && Ct < (ft.next.x - ft.x) * (Mt - ft.y) / (ft.next.y - ft.y) + ft.x && (xt = !xt),
                    ft = ft.next;
                while (ft !== lt);
                return xt
            }(Tt, tt) && (Ko(Tt.prev, Tt, tt.prev) || Ko(Tt, tt.prev, tt)) || Kv(Tt, tt) && Ko(Tt.prev, Tt, Tt.next) > 0 && Ko(tt.prev, tt, tt.next) > 0)
        }
        function Ko(Tt, tt, lt) {
            return (tt.y - Tt.y) * (lt.x - tt.x) - (tt.x - Tt.x) * (lt.y - tt.y)
        }
        function Kv(Tt, tt) {
            return Tt.x === tt.x && Tt.y === tt.y
        }
        function rA(Tt, tt, lt, mt) {
            const ft = Zv(Ko(Tt, tt, lt))
              , xt = Zv(Ko(Tt, tt, mt))
              , Ct = Zv(Ko(lt, mt, Tt))
              , Mt = Zv(Ko(lt, mt, tt));
            return ft !== xt && Ct !== Mt || !(ft !== 0 || !Jv(Tt, lt, tt)) || !(xt !== 0 || !Jv(Tt, mt, tt)) || !(Ct !== 0 || !Jv(lt, Tt, mt)) || !(Mt !== 0 || !Jv(lt, tt, mt))
        }
        function Jv(Tt, tt, lt) {
            return tt.x <= Math.max(Tt.x, lt.x) && tt.x >= Math.min(Tt.x, lt.x) && tt.y <= Math.max(Tt.y, lt.y) && tt.y >= Math.min(Tt.y, lt.y)
        }
        function Zv(Tt) {
            return Tt > 0 ? 1 : Tt < 0 ? -1 : 0
        }
        function P_(Tt, tt) {
            return Ko(Tt.prev, Tt, Tt.next) < 0 ? Ko(Tt, tt, Tt.next) >= 0 && Ko(Tt, Tt.prev, tt) >= 0 : Ko(Tt, tt, Tt.prev) < 0 || Ko(Tt, Tt.next, tt) < 0
        }
        function nA(Tt, tt) {
            const lt = new py(Tt.i,Tt.x,Tt.y)
              , mt = new py(tt.i,tt.x,tt.y)
              , ft = Tt.next
              , xt = tt.prev;
            return Tt.next = tt,
            tt.prev = Tt,
            lt.next = ft,
            ft.prev = lt,
            mt.next = lt,
            lt.prev = mt,
            xt.next = mt,
            mt.prev = xt,
            mt
        }
        function iA(Tt, tt, lt, mt) {
            const ft = new py(Tt,tt,lt);
            return mt ? (ft.next = mt.next,
            ft.prev = mt,
            mt.next.prev = ft,
            mt.next = ft) : (ft.prev = ft,
            ft.next = ft),
            ft
        }
        function M_(Tt) {
            Tt.next.prev = Tt.prev,
            Tt.prev.next = Tt.next,
            Tt.prevZ && (Tt.prevZ.nextZ = Tt.nextZ),
            Tt.nextZ && (Tt.nextZ.prevZ = Tt.prevZ)
        }
        function py(Tt, tt, lt) {
            this.i = Tt,
            this.x = tt,
            this.y = lt,
            this.prev = null,
            this.next = null,
            this.z = 0,
            this.prevZ = null,
            this.nextZ = null,
            this.steiner = !1
        }
        class ou {
            static area(tt) {
                const lt = tt.length;
                let mt = 0;
                for (let ft = lt - 1, xt = 0; xt < lt; ft = xt++)
                    mt += tt[ft].x * tt[xt].y - tt[xt].x * tt[ft].y;
                return .5 * mt
            }
            static isClockWise(tt) {
                return ou.area(tt) < 0
            }
            static triangulateShape(tt, lt) {
                const mt = []
                  , ft = []
                  , xt = [];
                oA(tt),
                sA(mt, tt);
                let Ct = tt.length;
                lt.forEach(oA);
                for (let Lt = 0; Lt < lt.length; Lt++)
                    ft.push(Ct),
                    Ct += lt[Lt].length,
                    sA(mt, lt[Lt]);
                const Mt = function(Lt, Nt, jt=2) {
                    const Wt = Nt && Nt.length
                      , Qt = Wt ? Nt[0] * jt : Lt.length;
                    let qt = tA(Lt, 0, Qt, jt, !0);
                    const Xt = [];
                    if (!qt || qt.next === qt.prev)
                        return Xt;
                    let Zt, Yt, sr, er, rr, xr, br;
                    if (Wt && (qt = function(yr, Pr, zr, Nr) {
                        const Vr = [];
                        let Gr, Hr, _n, dn, kn;
                        for (Gr = 0,
                        Hr = Pr.length; Gr < Hr; Gr++)
                            _n = Pr[Gr] * Nr,
                            dn = Gr < Hr - 1 ? Pr[Gr + 1] * Nr : yr.length,
                            kn = tA(yr, _n, dn, Nr, !1),
                            kn === kn.next && (kn.steiner = !0),
                            Vr.push(yS(kn));
                        for (Vr.sort(gS),
                        Gr = 0; Gr < Vr.length; Gr++)
                            zr = _S(Vr[Gr], zr);
                        return zr
                    }(Lt, Nt, qt, jt)),
                    Lt.length > 80 * jt) {
                        Zt = sr = Lt[0],
                        Yt = er = Lt[1];
                        for (let yr = jt; yr < Qt; yr += jt)
                            rr = Lt[yr],
                            xr = Lt[yr + 1],
                            rr < Zt && (Zt = rr),
                            xr < Yt && (Yt = xr),
                            rr > sr && (sr = rr),
                            xr > er && (er = xr);
                        br = Math.max(sr - Zt, er - Yt),
                        br = br !== 0 ? 32767 / br : 0
                    }
                    return C_(qt, Xt, jt, Zt, Yt, br, 0),
                    Xt
                }(mt, ft);
                for (let Lt = 0; Lt < Mt.length; Lt += 3)
                    xt.push(Mt.slice(Lt, Lt + 3));
                return xt
            }
        }
        function oA(Tt) {
            const tt = Tt.length;
            tt > 2 && Tt[tt - 1].equals(Tt[0]) && Tt.pop()
        }
        function sA(Tt, tt) {
            for (let lt = 0; lt < tt.length; lt++)
                Tt.push(tt[lt].x),
                Tt.push(tt[lt].y)
        }
        class e0 extends bo {
            constructor(tt=new Pp([new mn(.5,.5), new mn(-.5,.5), new mn(-.5,-.5), new mn(.5,-.5)]), lt={}) {
                super(),
                this.type = "ExtrudeGeometry",
                this.parameters = {
                    shapes: tt,
                    options: lt
                },
                tt = Array.isArray(tt) ? tt : [tt];
                const mt = this
                  , ft = []
                  , xt = [];
                for (let Mt = 0, Lt = tt.length; Mt < Lt; Mt++)
                    Ct(tt[Mt]);
                function Ct(Mt) {
                    const Lt = []
                      , Nt = lt.curveSegments !== void 0 ? lt.curveSegments : 12
                      , jt = lt.steps !== void 0 ? lt.steps : 1
                      , Wt = lt.depth !== void 0 ? lt.depth : 1;
                    let Qt = lt.bevelEnabled === void 0 || lt.bevelEnabled
                      , qt = lt.bevelThickness !== void 0 ? lt.bevelThickness : .2
                      , Xt = lt.bevelSize !== void 0 ? lt.bevelSize : qt - .1
                      , Zt = lt.bevelOffset !== void 0 ? lt.bevelOffset : 0
                      , Yt = lt.bevelSegments !== void 0 ? lt.bevelSegments : 3;
                    const sr = lt.extrudePath
                      , er = lt.UVGenerator !== void 0 ? lt.UVGenerator : bS;
                    let rr, xr, br, yr, Pr, zr = !1;
                    sr && (rr = sr.getSpacedPoints(jt),
                    zr = !0,
                    Qt = !1,
                    xr = sr.computeFrenetFrames(jt, !1),
                    br = new Er,
                    yr = new Er,
                    Pr = new Er),
                    Qt || (Yt = 0,
                    qt = 0,
                    Xt = 0,
                    Zt = 0);
                    const Nr = Mt.extractPoints(Nt);
                    let Vr = Nr.shape;
                    const Gr = Nr.holes;
                    if (!ou.isClockWise(Vr)) {
                        Vr = Vr.reverse();
                        for (let Fr = 0, Wr = Gr.length; Fr < Wr; Fr++) {
                            const kr = Gr[Fr];
                            ou.isClockWise(kr) && (Gr[Fr] = kr.reverse())
                        }
                    }
                    const Hr = ou.triangulateShape(Vr, Gr)
                      , _n = Vr;
                    for (let Fr = 0, Wr = Gr.length; Fr < Wr; Fr++) {
                        const kr = Gr[Fr];
                        Vr = Vr.concat(kr)
                    }
                    function dn(Fr, Wr, kr) {
                        return Wr || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                        Fr.clone().addScaledVector(Wr, kr)
                    }
                    const kn = Vr.length
                      , Bn = Hr.length;
                    function cn(Fr, Wr, kr) {
                        let _r, Br, Lr;
                        const Xr = Fr.x - Wr.x
                          , Kr = Fr.y - Wr.y
                          , An = kr.x - Fr.x
                          , pn = kr.y - Fr.y
                          , _o = Xr * Xr + Kr * Kr
                          , to = Xr * pn - Kr * An;
                        if (Math.abs(to) > Number.EPSILON) {
                            const Pn = Math.sqrt(_o)
                              , eo = Math.sqrt(An * An + pn * pn)
                              , Kn = Wr.x - Kr / Pn
                              , po = Wr.y + Xr / Pn
                              , Ao = ((kr.x - pn / eo - Kn) * pn - (kr.y + An / eo - po) * An) / (Xr * pn - Kr * An);
                            _r = Kn + Xr * Ao - Fr.x,
                            Br = po + Kr * Ao - Fr.y;
                            const Fo = _r * _r + Br * Br;
                            if (Fo <= 2)
                                return new mn(_r,Br);
                            Lr = Math.sqrt(Fo / 2)
                        } else {
                            let Pn = !1;
                            Xr > Number.EPSILON ? An > Number.EPSILON && (Pn = !0) : Xr < -Number.EPSILON ? An < -Number.EPSILON && (Pn = !0) : Math.sign(Kr) === Math.sign(pn) && (Pn = !0),
                            Pn ? (_r = -Kr,
                            Br = Xr,
                            Lr = Math.sqrt(_o)) : (_r = Xr,
                            Br = Kr,
                            Lr = Math.sqrt(_o / 2))
                        }
                        return new mn(_r / Lr,Br / Lr)
                    }
                    const Yr = [];
                    for (let Fr = 0, Wr = _n.length, kr = Wr - 1, _r = Fr + 1; Fr < Wr; Fr++,
                    kr++,
                    _r++)
                        kr === Wr && (kr = 0),
                        _r === Wr && (_r = 0),
                        Yr[Fr] = cn(_n[Fr], _n[kr], _n[_r]);
                    const Jr = [];
                    let sn, on = Yr.concat();
                    for (let Fr = 0, Wr = Gr.length; Fr < Wr; Fr++) {
                        const kr = Gr[Fr];
                        sn = [];
                        for (let _r = 0, Br = kr.length, Lr = Br - 1, Xr = _r + 1; _r < Br; _r++,
                        Lr++,
                        Xr++)
                            Lr === Br && (Lr = 0),
                            Xr === Br && (Xr = 0),
                            sn[_r] = cn(kr[_r], kr[Lr], kr[Xr]);
                        Jr.push(sn),
                        on = on.concat(sn)
                    }
                    for (let Fr = 0; Fr < Yt; Fr++) {
                        const Wr = Fr / Yt
                          , kr = qt * Math.cos(Wr * Math.PI / 2)
                          , _r = Xt * Math.sin(Wr * Math.PI / 2) + Zt;
                        for (let Br = 0, Lr = _n.length; Br < Lr; Br++) {
                            const Xr = dn(_n[Br], Yr[Br], _r);
                            Zn(Xr.x, Xr.y, -kr)
                        }
                        for (let Br = 0, Lr = Gr.length; Br < Lr; Br++) {
                            const Xr = Gr[Br];
                            sn = Jr[Br];
                            for (let Kr = 0, An = Xr.length; Kr < An; Kr++) {
                                const pn = dn(Xr[Kr], sn[Kr], _r);
                                Zn(pn.x, pn.y, -kr)
                            }
                        }
                    }
                    const Un = Xt + Zt;
                    for (let Fr = 0; Fr < kn; Fr++) {
                        const Wr = Qt ? dn(Vr[Fr], on[Fr], Un) : Vr[Fr];
                        zr ? (yr.copy(xr.normals[0]).multiplyScalar(Wr.x),
                        br.copy(xr.binormals[0]).multiplyScalar(Wr.y),
                        Pr.copy(rr[0]).add(yr).add(br),
                        Zn(Pr.x, Pr.y, Pr.z)) : Zn(Wr.x, Wr.y, 0)
                    }
                    for (let Fr = 1; Fr <= jt; Fr++)
                        for (let Wr = 0; Wr < kn; Wr++) {
                            const kr = Qt ? dn(Vr[Wr], on[Wr], Un) : Vr[Wr];
                            zr ? (yr.copy(xr.normals[Fr]).multiplyScalar(kr.x),
                            br.copy(xr.binormals[Fr]).multiplyScalar(kr.y),
                            Pr.copy(rr[Fr]).add(yr).add(br),
                            Zn(Pr.x, Pr.y, Pr.z)) : Zn(kr.x, kr.y, Wt / jt * Fr)
                        }
                    for (let Fr = Yt - 1; Fr >= 0; Fr--) {
                        const Wr = Fr / Yt
                          , kr = qt * Math.cos(Wr * Math.PI / 2)
                          , _r = Xt * Math.sin(Wr * Math.PI / 2) + Zt;
                        for (let Br = 0, Lr = _n.length; Br < Lr; Br++) {
                            const Xr = dn(_n[Br], Yr[Br], _r);
                            Zn(Xr.x, Xr.y, Wt + kr)
                        }
                        for (let Br = 0, Lr = Gr.length; Br < Lr; Br++) {
                            const Xr = Gr[Br];
                            sn = Jr[Br];
                            for (let Kr = 0, An = Xr.length; Kr < An; Kr++) {
                                const pn = dn(Xr[Kr], sn[Kr], _r);
                                zr ? Zn(pn.x, pn.y + rr[jt - 1].y, rr[jt - 1].x + kr) : Zn(pn.x, pn.y, Wt + kr)
                            }
                        }
                    }
                    function ro(Fr, Wr) {
                        let kr = Fr.length;
                        for (; --kr >= 0; ) {
                            const _r = kr;
                            let Br = kr - 1;
                            Br < 0 && (Br = Fr.length - 1);
                            for (let Lr = 0, Xr = jt + 2 * Yt; Lr < Xr; Lr++) {
                                const Kr = kn * Lr
                                  , An = kn * (Lr + 1);
                                uo(Wr + _r + Kr, Wr + Br + Kr, Wr + Br + An, Wr + _r + An)
                            }
                        }
                    }
                    function Zn(Fr, Wr, kr) {
                        Lt.push(Fr),
                        Lt.push(Wr),
                        Lt.push(kr)
                    }
                    function jn(Fr, Wr, kr) {
                        Dr(Fr),
                        Dr(Wr),
                        Dr(kr);
                        const _r = ft.length / 3
                          , Br = er.generateTopUV(mt, ft, _r - 3, _r - 2, _r - 1);
                        Sr(Br[0]),
                        Sr(Br[1]),
                        Sr(Br[2])
                    }
                    function uo(Fr, Wr, kr, _r) {
                        Dr(Fr),
                        Dr(Wr),
                        Dr(_r),
                        Dr(Wr),
                        Dr(kr),
                        Dr(_r);
                        const Br = ft.length / 3
                          , Lr = er.generateSideWallUV(mt, ft, Br - 6, Br - 3, Br - 2, Br - 1);
                        Sr(Lr[0]),
                        Sr(Lr[1]),
                        Sr(Lr[3]),
                        Sr(Lr[1]),
                        Sr(Lr[2]),
                        Sr(Lr[3])
                    }
                    function Dr(Fr) {
                        ft.push(Lt[3 * Fr + 0]),
                        ft.push(Lt[3 * Fr + 1]),
                        ft.push(Lt[3 * Fr + 2])
                    }
                    function Sr(Fr) {
                        xt.push(Fr.x),
                        xt.push(Fr.y)
                    }
                    (function() {
                        const Fr = ft.length / 3;
                        if (Qt) {
                            let Wr = 0
                              , kr = kn * Wr;
                            for (let _r = 0; _r < Bn; _r++) {
                                const Br = Hr[_r];
                                jn(Br[2] + kr, Br[1] + kr, Br[0] + kr)
                            }
                            Wr = jt + 2 * Yt,
                            kr = kn * Wr;
                            for (let _r = 0; _r < Bn; _r++) {
                                const Br = Hr[_r];
                                jn(Br[0] + kr, Br[1] + kr, Br[2] + kr)
                            }
                        } else {
                            for (let Wr = 0; Wr < Bn; Wr++) {
                                const kr = Hr[Wr];
                                jn(kr[2], kr[1], kr[0])
                            }
                            for (let Wr = 0; Wr < Bn; Wr++) {
                                const kr = Hr[Wr];
                                jn(kr[0] + kn * jt, kr[1] + kn * jt, kr[2] + kn * jt)
                            }
                        }
                        mt.addGroup(Fr, ft.length / 3 - Fr, 0)
                    }
                    )(),
                    function() {
                        const Fr = ft.length / 3;
                        let Wr = 0;
                        ro(_n, Wr),
                        Wr += _n.length;
                        for (let kr = 0, _r = Gr.length; kr < _r; kr++) {
                            const Br = Gr[kr];
                            ro(Br, Wr),
                            Wr += Br.length
                        }
                        mt.addGroup(Fr, ft.length / 3 - Fr, 1)
                    }()
                }
                this.setAttribute("position", new Fn(ft,3)),
                this.setAttribute("uv", new Fn(xt,2)),
                this.computeVertexNormals()
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return function(lt, mt, ft) {
                    if (ft.shapes = [],
                    Array.isArray(lt))
                        for (let xt = 0, Ct = lt.length; xt < Ct; xt++) {
                            const Mt = lt[xt];
                            ft.shapes.push(Mt.uuid)
                        }
                    else
                        ft.shapes.push(lt.uuid);
                    return ft.options = Object.assign({}, mt),
                    mt.extrudePath !== void 0 && (ft.options.extrudePath = mt.extrudePath.toJSON()),
                    ft
                }(this.parameters.shapes, this.parameters.options, tt)
            }
            static fromJSON(tt, lt) {
                const mt = [];
                for (let xt = 0, Ct = tt.shapes.length; xt < Ct; xt++) {
                    const Mt = lt[tt.shapes[xt]];
                    mt.push(Mt)
                }
                const ft = tt.options.extrudePath;
                return ft !== void 0 && (tt.options.extrudePath = new zv[ft.type]().fromJSON(ft)),
                new e0(mt,tt.options)
            }
        }
        const bS = {
            generateTopUV: function(Tt, tt, lt, mt, ft) {
                const xt = tt[3 * lt]
                  , Ct = tt[3 * lt + 1]
                  , Mt = tt[3 * mt]
                  , Lt = tt[3 * mt + 1]
                  , Nt = tt[3 * ft]
                  , jt = tt[3 * ft + 1];
                return [new mn(xt,Ct), new mn(Mt,Lt), new mn(Nt,jt)]
            },
            generateSideWallUV: function(Tt, tt, lt, mt, ft, xt) {
                const Ct = tt[3 * lt]
                  , Mt = tt[3 * lt + 1]
                  , Lt = tt[3 * lt + 2]
                  , Nt = tt[3 * mt]
                  , jt = tt[3 * mt + 1]
                  , Wt = tt[3 * mt + 2]
                  , Qt = tt[3 * ft]
                  , qt = tt[3 * ft + 1]
                  , Xt = tt[3 * ft + 2]
                  , Zt = tt[3 * xt]
                  , Yt = tt[3 * xt + 1]
                  , sr = tt[3 * xt + 2];
                return Math.abs(Mt - jt) < Math.abs(Ct - Nt) ? [new mn(Ct,1 - Lt), new mn(Nt,1 - Wt), new mn(Qt,1 - Xt), new mn(Zt,1 - sr)] : [new mn(Mt,1 - Lt), new mn(jt,1 - Wt), new mn(qt,1 - Xt), new mn(Yt,1 - sr)]
            }
        };
        class t0 extends tp {
            constructor(tt=1, lt=0) {
                const mt = (1 + Math.sqrt(5)) / 2;
                super([-1, mt, 0, 1, mt, 0, -1, -mt, 0, 1, -mt, 0, 0, -1, mt, 0, 1, mt, 0, -1, -mt, 0, 1, -mt, mt, 0, -1, mt, 0, 1, -mt, 0, -1, -mt, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], tt, lt),
                this.type = "IcosahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new t0(tt.radius,tt.detail)
            }
        }
        class R_ extends tp {
            constructor(tt=1, lt=0) {
                super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], tt, lt),
                this.type = "OctahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new R_(tt.radius,tt.detail)
            }
        }
        class r0 extends bo {
            constructor(tt=.5, lt=1, mt=32, ft=1, xt=0, Ct=2 * Math.PI) {
                super(),
                this.type = "RingGeometry",
                this.parameters = {
                    innerRadius: tt,
                    outerRadius: lt,
                    thetaSegments: mt,
                    phiSegments: ft,
                    thetaStart: xt,
                    thetaLength: Ct
                },
                mt = Math.max(3, mt);
                const Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = [];
                let Wt = tt;
                const Qt = (lt - tt) / (ft = Math.max(1, ft))
                  , qt = new Er
                  , Xt = new mn;
                for (let Zt = 0; Zt <= ft; Zt++) {
                    for (let Yt = 0; Yt <= mt; Yt++) {
                        const sr = xt + Yt / mt * Ct;
                        qt.x = Wt * Math.cos(sr),
                        qt.y = Wt * Math.sin(sr),
                        Lt.push(qt.x, qt.y, qt.z),
                        Nt.push(0, 0, 1),
                        Xt.x = (qt.x / lt + 1) / 2,
                        Xt.y = (qt.y / lt + 1) / 2,
                        jt.push(Xt.x, Xt.y)
                    }
                    Wt += Qt
                }
                for (let Zt = 0; Zt < ft; Zt++) {
                    const Yt = Zt * (mt + 1);
                    for (let sr = 0; sr < mt; sr++) {
                        const er = sr + Yt
                          , rr = er
                          , xr = er + mt + 1
                          , br = er + mt + 2
                          , yr = er + 1;
                        Mt.push(rr, xr, yr),
                        Mt.push(xr, br, yr)
                    }
                }
                this.setIndex(Mt),
                this.setAttribute("position", new Fn(Lt,3)),
                this.setAttribute("normal", new Fn(Nt,3)),
                this.setAttribute("uv", new Fn(jt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new r0(tt.innerRadius,tt.outerRadius,tt.thetaSegments,tt.phiSegments,tt.thetaStart,tt.thetaLength)
            }
        }
        class n0 extends bo {
            constructor(tt=new Pp([new mn(0,.5), new mn(-.5,-.5), new mn(.5,-.5)]), lt=12) {
                super(),
                this.type = "ShapeGeometry",
                this.parameters = {
                    shapes: tt,
                    curveSegments: lt
                };
                const mt = []
                  , ft = []
                  , xt = []
                  , Ct = [];
                let Mt = 0
                  , Lt = 0;
                if (Array.isArray(tt) === !1)
                    Nt(tt);
                else
                    for (let jt = 0; jt < tt.length; jt++)
                        Nt(tt[jt]),
                        this.addGroup(Mt, Lt, jt),
                        Mt += Lt,
                        Lt = 0;
                function Nt(jt) {
                    const Wt = ft.length / 3
                      , Qt = jt.extractPoints(lt);
                    let qt = Qt.shape;
                    const Xt = Qt.holes;
                    ou.isClockWise(qt) === !1 && (qt = qt.reverse());
                    for (let Yt = 0, sr = Xt.length; Yt < sr; Yt++) {
                        const er = Xt[Yt];
                        ou.isClockWise(er) === !0 && (Xt[Yt] = er.reverse())
                    }
                    const Zt = ou.triangulateShape(qt, Xt);
                    for (let Yt = 0, sr = Xt.length; Yt < sr; Yt++) {
                        const er = Xt[Yt];
                        qt = qt.concat(er)
                    }
                    for (let Yt = 0, sr = qt.length; Yt < sr; Yt++) {
                        const er = qt[Yt];
                        ft.push(er.x, er.y, 0),
                        xt.push(0, 0, 1),
                        Ct.push(er.x, er.y)
                    }
                    for (let Yt = 0, sr = Zt.length; Yt < sr; Yt++) {
                        const er = Zt[Yt]
                          , rr = er[0] + Wt
                          , xr = er[1] + Wt
                          , br = er[2] + Wt;
                        mt.push(rr, xr, br),
                        Lt += 3
                    }
                }
                this.setIndex(mt),
                this.setAttribute("position", new Fn(ft,3)),
                this.setAttribute("normal", new Fn(xt,3)),
                this.setAttribute("uv", new Fn(Ct,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return function(lt, mt) {
                    if (mt.shapes = [],
                    Array.isArray(lt))
                        for (let ft = 0, xt = lt.length; ft < xt; ft++) {
                            const Ct = lt[ft];
                            mt.shapes.push(Ct.uuid)
                        }
                    else
                        mt.shapes.push(lt.uuid);
                    return mt
                }(this.parameters.shapes, tt)
            }
            static fromJSON(tt, lt) {
                const mt = [];
                for (let ft = 0, xt = tt.shapes.length; ft < xt; ft++) {
                    const Ct = lt[tt.shapes[ft]];
                    mt.push(Ct)
                }
                return new n0(mt,tt.curveSegments)
            }
        }
        class I_ extends bo {
            constructor(tt=1, lt=32, mt=16, ft=0, xt=2 * Math.PI, Ct=0, Mt=Math.PI) {
                super(),
                this.type = "SphereGeometry",
                this.parameters = {
                    radius: tt,
                    widthSegments: lt,
                    heightSegments: mt,
                    phiStart: ft,
                    phiLength: xt,
                    thetaStart: Ct,
                    thetaLength: Mt
                },
                lt = Math.max(3, Math.floor(lt)),
                mt = Math.max(2, Math.floor(mt));
                const Lt = Math.min(Ct + Mt, Math.PI);
                let Nt = 0;
                const jt = []
                  , Wt = new Er
                  , Qt = new Er
                  , qt = []
                  , Xt = []
                  , Zt = []
                  , Yt = [];
                for (let sr = 0; sr <= mt; sr++) {
                    const er = []
                      , rr = sr / mt;
                    let xr = 0;
                    sr === 0 && Ct === 0 ? xr = .5 / lt : sr === mt && Lt === Math.PI && (xr = -.5 / lt);
                    for (let br = 0; br <= lt; br++) {
                        const yr = br / lt;
                        Wt.x = -tt * Math.cos(ft + yr * xt) * Math.sin(Ct + rr * Mt),
                        Wt.y = tt * Math.cos(Ct + rr * Mt),
                        Wt.z = tt * Math.sin(ft + yr * xt) * Math.sin(Ct + rr * Mt),
                        Xt.push(Wt.x, Wt.y, Wt.z),
                        Qt.copy(Wt).normalize(),
                        Zt.push(Qt.x, Qt.y, Qt.z),
                        Yt.push(yr + xr, 1 - rr),
                        er.push(Nt++)
                    }
                    jt.push(er)
                }
                for (let sr = 0; sr < mt; sr++)
                    for (let er = 0; er < lt; er++) {
                        const rr = jt[sr][er + 1]
                          , xr = jt[sr][er]
                          , br = jt[sr + 1][er]
                          , yr = jt[sr + 1][er + 1];
                        (sr !== 0 || Ct > 0) && qt.push(rr, xr, yr),
                        (sr !== mt - 1 || Lt < Math.PI) && qt.push(xr, br, yr)
                    }
                this.setIndex(qt),
                this.setAttribute("position", new Fn(Xt,3)),
                this.setAttribute("normal", new Fn(Zt,3)),
                this.setAttribute("uv", new Fn(Yt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new I_(tt.radius,tt.widthSegments,tt.heightSegments,tt.phiStart,tt.phiLength,tt.thetaStart,tt.thetaLength)
            }
        }
        class i0 extends tp {
            constructor(tt=1, lt=0) {
                super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], tt, lt),
                this.type = "TetrahedronGeometry",
                this.parameters = {
                    radius: tt,
                    detail: lt
                }
            }
            static fromJSON(tt) {
                return new i0(tt.radius,tt.detail)
            }
        }
        class o0 extends bo {
            constructor(tt=1, lt=.4, mt=12, ft=48, xt=2 * Math.PI) {
                super(),
                this.type = "TorusGeometry",
                this.parameters = {
                    radius: tt,
                    tube: lt,
                    radialSegments: mt,
                    tubularSegments: ft,
                    arc: xt
                },
                mt = Math.floor(mt),
                ft = Math.floor(ft);
                const Ct = []
                  , Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = new Er
                  , Wt = new Er
                  , Qt = new Er;
                for (let qt = 0; qt <= mt; qt++)
                    for (let Xt = 0; Xt <= ft; Xt++) {
                        const Zt = Xt / ft * xt
                          , Yt = qt / mt * Math.PI * 2;
                        Wt.x = (tt + lt * Math.cos(Yt)) * Math.cos(Zt),
                        Wt.y = (tt + lt * Math.cos(Yt)) * Math.sin(Zt),
                        Wt.z = lt * Math.sin(Yt),
                        Mt.push(Wt.x, Wt.y, Wt.z),
                        jt.x = tt * Math.cos(Zt),
                        jt.y = tt * Math.sin(Zt),
                        Qt.subVectors(Wt, jt).normalize(),
                        Lt.push(Qt.x, Qt.y, Qt.z),
                        Nt.push(Xt / ft),
                        Nt.push(qt / mt)
                    }
                for (let qt = 1; qt <= mt; qt++)
                    for (let Xt = 1; Xt <= ft; Xt++) {
                        const Zt = (ft + 1) * qt + Xt - 1
                          , Yt = (ft + 1) * (qt - 1) + Xt - 1
                          , sr = (ft + 1) * (qt - 1) + Xt
                          , er = (ft + 1) * qt + Xt;
                        Ct.push(Zt, Yt, er),
                        Ct.push(Yt, sr, er)
                    }
                this.setIndex(Ct),
                this.setAttribute("position", new Fn(Mt,3)),
                this.setAttribute("normal", new Fn(Lt,3)),
                this.setAttribute("uv", new Fn(Nt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new o0(tt.radius,tt.tube,tt.radialSegments,tt.tubularSegments,tt.arc)
            }
        }
        class s0 extends bo {
            constructor(tt=1, lt=.4, mt=64, ft=8, xt=2, Ct=3) {
                super(),
                this.type = "TorusKnotGeometry",
                this.parameters = {
                    radius: tt,
                    tube: lt,
                    tubularSegments: mt,
                    radialSegments: ft,
                    p: xt,
                    q: Ct
                },
                mt = Math.floor(mt),
                ft = Math.floor(ft);
                const Mt = []
                  , Lt = []
                  , Nt = []
                  , jt = []
                  , Wt = new Er
                  , Qt = new Er
                  , qt = new Er
                  , Xt = new Er
                  , Zt = new Er
                  , Yt = new Er
                  , sr = new Er;
                for (let rr = 0; rr <= mt; ++rr) {
                    const xr = rr / mt * xt * Math.PI * 2;
                    er(xr, xt, Ct, tt, qt),
                    er(xr + .01, xt, Ct, tt, Xt),
                    Yt.subVectors(Xt, qt),
                    sr.addVectors(Xt, qt),
                    Zt.crossVectors(Yt, sr),
                    sr.crossVectors(Zt, Yt),
                    Zt.normalize(),
                    sr.normalize();
                    for (let br = 0; br <= ft; ++br) {
                        const yr = br / ft * Math.PI * 2
                          , Pr = -lt * Math.cos(yr)
                          , zr = lt * Math.sin(yr);
                        Wt.x = qt.x + (Pr * sr.x + zr * Zt.x),
                        Wt.y = qt.y + (Pr * sr.y + zr * Zt.y),
                        Wt.z = qt.z + (Pr * sr.z + zr * Zt.z),
                        Lt.push(Wt.x, Wt.y, Wt.z),
                        Qt.subVectors(Wt, qt).normalize(),
                        Nt.push(Qt.x, Qt.y, Qt.z),
                        jt.push(rr / mt),
                        jt.push(br / ft)
                    }
                }
                for (let rr = 1; rr <= mt; rr++)
                    for (let xr = 1; xr <= ft; xr++) {
                        const br = (ft + 1) * (rr - 1) + (xr - 1)
                          , yr = (ft + 1) * rr + (xr - 1)
                          , Pr = (ft + 1) * rr + xr
                          , zr = (ft + 1) * (rr - 1) + xr;
                        Mt.push(br, yr, zr),
                        Mt.push(yr, Pr, zr)
                    }
                function er(rr, xr, br, yr, Pr) {
                    const zr = Math.cos(rr)
                      , Nr = Math.sin(rr)
                      , Vr = br / xr * rr
                      , Gr = Math.cos(Vr);
                    Pr.x = yr * (2 + Gr) * .5 * zr,
                    Pr.y = yr * (2 + Gr) * Nr * .5,
                    Pr.z = yr * Math.sin(Vr) * .5
                }
                this.setIndex(Mt),
                this.setAttribute("position", new Fn(Lt,3)),
                this.setAttribute("normal", new Fn(Nt,3)),
                this.setAttribute("uv", new Fn(jt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            static fromJSON(tt) {
                return new s0(tt.radius,tt.tube,tt.tubularSegments,tt.radialSegments,tt.p,tt.q)
            }
        }
        class a0 extends bo {
            constructor(tt=new ly(new Er(-1,-1,0),new Er(-1,1,0),new Er(1,1,0)), lt=64, mt=1, ft=8, xt=!1) {
                super(),
                this.type = "TubeGeometry",
                this.parameters = {
                    path: tt,
                    tubularSegments: lt,
                    radius: mt,
                    radialSegments: ft,
                    closed: xt
                };
                const Ct = tt.computeFrenetFrames(lt, xt);
                this.tangents = Ct.tangents,
                this.normals = Ct.normals,
                this.binormals = Ct.binormals;
                const Mt = new Er
                  , Lt = new Er
                  , Nt = new mn;
                let jt = new Er;
                const Wt = []
                  , Qt = []
                  , qt = []
                  , Xt = [];
                function Zt(Yt) {
                    jt = tt.getPointAt(Yt / lt, jt);
                    const sr = Ct.normals[Yt]
                      , er = Ct.binormals[Yt];
                    for (let rr = 0; rr <= ft; rr++) {
                        const xr = rr / ft * Math.PI * 2
                          , br = Math.sin(xr)
                          , yr = -Math.cos(xr);
                        Lt.x = yr * sr.x + br * er.x,
                        Lt.y = yr * sr.y + br * er.y,
                        Lt.z = yr * sr.z + br * er.z,
                        Lt.normalize(),
                        Qt.push(Lt.x, Lt.y, Lt.z),
                        Mt.x = jt.x + mt * Lt.x,
                        Mt.y = jt.y + mt * Lt.y,
                        Mt.z = jt.z + mt * Lt.z,
                        Wt.push(Mt.x, Mt.y, Mt.z)
                    }
                }
                (function() {
                    for (let Yt = 0; Yt < lt; Yt++)
                        Zt(Yt);
                    Zt(xt === !1 ? lt : 0),
                    function() {
                        for (let Yt = 0; Yt <= lt; Yt++)
                            for (let sr = 0; sr <= ft; sr++)
                                Nt.x = Yt / lt,
                                Nt.y = sr / ft,
                                qt.push(Nt.x, Nt.y)
                    }(),
                    function() {
                        for (let Yt = 1; Yt <= lt; Yt++)
                            for (let sr = 1; sr <= ft; sr++) {
                                const er = (ft + 1) * (Yt - 1) + (sr - 1)
                                  , rr = (ft + 1) * Yt + (sr - 1)
                                  , xr = (ft + 1) * Yt + sr
                                  , br = (ft + 1) * (Yt - 1) + sr;
                                Xt.push(er, rr, br),
                                Xt.push(rr, xr, br)
                            }
                    }()
                }
                )(),
                this.setIndex(Xt),
                this.setAttribute("position", new Fn(Wt,3)),
                this.setAttribute("normal", new Fn(Qt,3)),
                this.setAttribute("uv", new Fn(qt,2))
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.path = this.parameters.path.toJSON(),
                tt
            }
            static fromJSON(tt) {
                return new a0(new zv[tt.path.type]().fromJSON(tt.path),tt.tubularSegments,tt.radius,tt.radialSegments,tt.closed)
            }
        }
        class aA extends bo {
            constructor(tt=null) {
                if (super(),
                this.type = "WireframeGeometry",
                this.parameters = {
                    geometry: tt
                },
                tt !== null) {
                    const lt = []
                      , mt = new Set
                      , ft = new Er
                      , xt = new Er;
                    if (tt.index !== null) {
                        const Ct = tt.attributes.position
                          , Mt = tt.index;
                        let Lt = tt.groups;
                        Lt.length === 0 && (Lt = [{
                            start: 0,
                            count: Mt.count,
                            materialIndex: 0
                        }]);
                        for (let Nt = 0, jt = Lt.length; Nt < jt; ++Nt) {
                            const Wt = Lt[Nt]
                              , Qt = Wt.start;
                            for (let qt = Qt, Xt = Qt + Wt.count; qt < Xt; qt += 3)
                                for (let Zt = 0; Zt < 3; Zt++) {
                                    const Yt = Mt.getX(qt + Zt)
                                      , sr = Mt.getX(qt + (Zt + 1) % 3);
                                    ft.fromBufferAttribute(Ct, Yt),
                                    xt.fromBufferAttribute(Ct, sr),
                                    lA(ft, xt, mt) === !0 && (lt.push(ft.x, ft.y, ft.z),
                                    lt.push(xt.x, xt.y, xt.z))
                                }
                        }
                    } else {
                        const Ct = tt.attributes.position;
                        for (let Mt = 0, Lt = Ct.count / 3; Mt < Lt; Mt++)
                            for (let Nt = 0; Nt < 3; Nt++) {
                                const jt = 3 * Mt + Nt
                                  , Wt = 3 * Mt + (Nt + 1) % 3;
                                ft.fromBufferAttribute(Ct, jt),
                                xt.fromBufferAttribute(Ct, Wt),
                                lA(ft, xt, mt) === !0 && (lt.push(ft.x, ft.y, ft.z),
                                lt.push(xt.x, xt.y, xt.z))
                            }
                    }
                    this.setAttribute("position", new Fn(lt,3))
                }
            }
            copy(tt) {
                return super.copy(tt),
                this.parameters = Object.assign({}, tt.parameters),
                this
            }
        }
        function lA(Tt, tt, lt) {
            const mt = `${Tt.x},${Tt.y},${Tt.z}-${tt.x},${tt.y},${tt.z}`
              , ft = `${tt.x},${tt.y},${tt.z}-${Tt.x},${Tt.y},${Tt.z}`;
            return lt.has(mt) !== !0 && lt.has(ft) !== !0 && (lt.add(mt),
            lt.add(ft),
            !0)
        }
        var cA = Object.freeze({
            __proto__: null,
            BoxGeometry: Zu,
            CapsuleGeometry: Hv,
            CircleGeometry: Qv,
            ConeGeometry: Wv,
            CylinderGeometry: Im,
            DodecahedronGeometry: qv,
            EdgesGeometry: eA,
            ExtrudeGeometry: e0,
            IcosahedronGeometry: t0,
            LatheGeometry: T_,
            OctahedronGeometry: R_,
            PlaneGeometry: g_,
            PolyhedronGeometry: tp,
            RingGeometry: r0,
            ShapeGeometry: n0,
            SphereGeometry: I_,
            TetrahedronGeometry: i0,
            TorusGeometry: o0,
            TorusKnotGeometry: s0,
            TubeGeometry: a0,
            WireframeGeometry: aA
        });
        class uA extends hs {
            constructor(tt) {
                super(),
                this.isShadowMaterial = !0,
                this.type = "ShadowMaterial",
                this.color = new Gn(0),
                this.transparent = !0,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.fog = tt.fog,
                this
            }
        }
        class dA extends zl {
            constructor(tt) {
                super(tt),
                this.isRawShaderMaterial = !0,
                this.type = "RawShaderMaterial"
            }
        }
        class hy extends hs {
            constructor(tt) {
                super(),
                this.isMeshStandardMaterial = !0,
                this.defines = {
                    STANDARD: ""
                },
                this.type = "MeshStandardMaterial",
                this.color = new Gn(16777215),
                this.roughness = 1,
                this.metalness = 0,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.roughnessMap = null,
                this.metalnessMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.envMapIntensity = 1,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.defines = {
                    STANDARD: ""
                },
                this.color.copy(tt.color),
                this.roughness = tt.roughness,
                this.metalness = tt.metalness,
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.roughnessMap = tt.roughnessMap,
                this.metalnessMap = tt.metalnessMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.envMapIntensity = tt.envMapIntensity,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class pA extends hy {
            constructor(tt) {
                super(),
                this.isMeshPhysicalMaterial = !0,
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.type = "MeshPhysicalMaterial",
                this.anisotropyRotation = 0,
                this.anisotropyMap = null,
                this.clearcoatMap = null,
                this.clearcoatRoughness = 0,
                this.clearcoatRoughnessMap = null,
                this.clearcoatNormalScale = new mn(1,1),
                this.clearcoatNormalMap = null,
                this.ior = 1.5,
                Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return qo(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(lt) {
                        this.ior = (1 + .4 * lt) / (1 - .4 * lt)
                    }
                }),
                this.iridescenceMap = null,
                this.iridescenceIOR = 1.3,
                this.iridescenceThicknessRange = [100, 400],
                this.iridescenceThicknessMap = null,
                this.sheenColor = new Gn(0),
                this.sheenColorMap = null,
                this.sheenRoughness = 1,
                this.sheenRoughnessMap = null,
                this.transmissionMap = null,
                this.thickness = 0,
                this.thicknessMap = null,
                this.attenuationDistance = 1 / 0,
                this.attenuationColor = new Gn(1,1,1),
                this.specularIntensity = 1,
                this.specularIntensityMap = null,
                this.specularColor = new Gn(1,1,1),
                this.specularColorMap = null,
                this._anisotropy = 0,
                this._clearcoat = 0,
                this._iridescence = 0,
                this._sheen = 0,
                this._transmission = 0,
                this.setValues(tt)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(tt) {
                this._anisotropy > 0 != tt > 0 && this.version++,
                this._anisotropy = tt
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(tt) {
                this._clearcoat > 0 != tt > 0 && this.version++,
                this._clearcoat = tt
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(tt) {
                this._iridescence > 0 != tt > 0 && this.version++,
                this._iridescence = tt
            }
            get sheen() {
                return this._sheen
            }
            set sheen(tt) {
                this._sheen > 0 != tt > 0 && this.version++,
                this._sheen = tt
            }
            get transmission() {
                return this._transmission
            }
            set transmission(tt) {
                this._transmission > 0 != tt > 0 && this.version++,
                this._transmission = tt
            }
            copy(tt) {
                return super.copy(tt),
                this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                },
                this.anisotropy = tt.anisotropy,
                this.anisotropyRotation = tt.anisotropyRotation,
                this.anisotropyMap = tt.anisotropyMap,
                this.clearcoat = tt.clearcoat,
                this.clearcoatMap = tt.clearcoatMap,
                this.clearcoatRoughness = tt.clearcoatRoughness,
                this.clearcoatRoughnessMap = tt.clearcoatRoughnessMap,
                this.clearcoatNormalMap = tt.clearcoatNormalMap,
                this.clearcoatNormalScale.copy(tt.clearcoatNormalScale),
                this.ior = tt.ior,
                this.iridescence = tt.iridescence,
                this.iridescenceMap = tt.iridescenceMap,
                this.iridescenceIOR = tt.iridescenceIOR,
                this.iridescenceThicknessRange = [...tt.iridescenceThicknessRange],
                this.iridescenceThicknessMap = tt.iridescenceThicknessMap,
                this.sheen = tt.sheen,
                this.sheenColor.copy(tt.sheenColor),
                this.sheenColorMap = tt.sheenColorMap,
                this.sheenRoughness = tt.sheenRoughness,
                this.sheenRoughnessMap = tt.sheenRoughnessMap,
                this.transmission = tt.transmission,
                this.transmissionMap = tt.transmissionMap,
                this.thickness = tt.thickness,
                this.thicknessMap = tt.thicknessMap,
                this.attenuationDistance = tt.attenuationDistance,
                this.attenuationColor.copy(tt.attenuationColor),
                this.specularIntensity = tt.specularIntensity,
                this.specularIntensityMap = tt.specularIntensityMap,
                this.specularColor.copy(tt.specularColor),
                this.specularColorMap = tt.specularColorMap,
                this
            }
        }
        class hA extends hs {
            constructor(tt) {
                super(),
                this.isMeshPhongMaterial = !0,
                this.type = "MeshPhongMaterial",
                this.color = new Gn(16777215),
                this.specular = new Gn(1118481),
                this.shininess = 30,
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Wn,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.specular.copy(tt.specular),
                this.shininess = tt.shininess,
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.specularMap = tt.specularMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.combine = tt.combine,
                this.reflectivity = tt.reflectivity,
                this.refractionRatio = tt.refractionRatio,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class mA extends hs {
            constructor(tt) {
                super(),
                this.isMeshToonMaterial = !0,
                this.defines = {
                    TOON: ""
                },
                this.type = "MeshToonMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.gradientMap = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.gradientMap = tt.gradientMap,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.alphaMap = tt.alphaMap,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.fog = tt.fog,
                this
            }
        }
        class fA extends hs {
            constructor(tt) {
                super(),
                this.isMeshNormalMaterial = !0,
                this.type = "MeshNormalMaterial",
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.flatShading = !1,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.flatShading = tt.flatShading,
                this
            }
        }
        class gA extends hs {
            constructor(tt) {
                super(),
                this.isMeshLambertMaterial = !0,
                this.type = "MeshLambertMaterial",
                this.color = new Gn(16777215),
                this.map = null,
                this.lightMap = null,
                this.lightMapIntensity = 1,
                this.aoMap = null,
                this.aoMapIntensity = 1,
                this.emissive = new Gn(0),
                this.emissiveIntensity = 1,
                this.emissiveMap = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.specularMap = null,
                this.alphaMap = null,
                this.envMap = null,
                this.combine = Wn,
                this.reflectivity = 1,
                this.refractionRatio = .98,
                this.wireframe = !1,
                this.wireframeLinewidth = 1,
                this.wireframeLinecap = "round",
                this.wireframeLinejoin = "round",
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.color.copy(tt.color),
                this.map = tt.map,
                this.lightMap = tt.lightMap,
                this.lightMapIntensity = tt.lightMapIntensity,
                this.aoMap = tt.aoMap,
                this.aoMapIntensity = tt.aoMapIntensity,
                this.emissive.copy(tt.emissive),
                this.emissiveMap = tt.emissiveMap,
                this.emissiveIntensity = tt.emissiveIntensity,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.specularMap = tt.specularMap,
                this.alphaMap = tt.alphaMap,
                this.envMap = tt.envMap,
                this.combine = tt.combine,
                this.reflectivity = tt.reflectivity,
                this.refractionRatio = tt.refractionRatio,
                this.wireframe = tt.wireframe,
                this.wireframeLinewidth = tt.wireframeLinewidth,
                this.wireframeLinecap = tt.wireframeLinecap,
                this.wireframeLinejoin = tt.wireframeLinejoin,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class _A extends hs {
            constructor(tt) {
                super(),
                this.isMeshMatcapMaterial = !0,
                this.defines = {
                    MATCAP: ""
                },
                this.type = "MeshMatcapMaterial",
                this.color = new Gn(16777215),
                this.matcap = null,
                this.map = null,
                this.bumpMap = null,
                this.bumpScale = 1,
                this.normalMap = null,
                this.normalMapType = El,
                this.normalScale = new mn(1,1),
                this.displacementMap = null,
                this.displacementScale = 1,
                this.displacementBias = 0,
                this.alphaMap = null,
                this.flatShading = !1,
                this.fog = !0,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.defines = {
                    MATCAP: ""
                },
                this.color.copy(tt.color),
                this.matcap = tt.matcap,
                this.map = tt.map,
                this.bumpMap = tt.bumpMap,
                this.bumpScale = tt.bumpScale,
                this.normalMap = tt.normalMap,
                this.normalMapType = tt.normalMapType,
                this.normalScale.copy(tt.normalScale),
                this.displacementMap = tt.displacementMap,
                this.displacementScale = tt.displacementScale,
                this.displacementBias = tt.displacementBias,
                this.alphaMap = tt.alphaMap,
                this.flatShading = tt.flatShading,
                this.fog = tt.fog,
                this
            }
        }
        class vA extends Gs {
            constructor(tt) {
                super(),
                this.isLineDashedMaterial = !0,
                this.type = "LineDashedMaterial",
                this.scale = 1,
                this.dashSize = 3,
                this.gapSize = 1,
                this.setValues(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.scale = tt.scale,
                this.dashSize = tt.dashSize,
                this.gapSize = tt.gapSize,
                this
            }
        }
        function Rp(Tt, tt, lt) {
            return !Tt || !lt && Tt.constructor === tt ? Tt : typeof tt.BYTES_PER_ELEMENT == "number" ? new tt(Tt) : Array.prototype.slice.call(Tt)
        }
        function yA(Tt) {
            return ArrayBuffer.isView(Tt) && !(Tt instanceof DataView)
        }
        function xA(Tt) {
            const tt = Tt.length
              , lt = new Array(tt);
            for (let mt = 0; mt !== tt; ++mt)
                lt[mt] = mt;
            return lt.sort(function(mt, ft) {
                return Tt[mt] - Tt[ft]
            }),
            lt
        }
        function my(Tt, tt, lt) {
            const mt = Tt.length
              , ft = new Tt.constructor(mt);
            for (let xt = 0, Ct = 0; Ct !== mt; ++xt) {
                const Mt = lt[xt] * tt;
                for (let Lt = 0; Lt !== tt; ++Lt)
                    ft[Ct++] = Tt[Mt + Lt]
            }
            return ft
        }
        function fy(Tt, tt, lt, mt) {
            let ft = 1
              , xt = Tt[0];
            for (; xt !== void 0 && xt[mt] === void 0; )
                xt = Tt[ft++];
            if (xt === void 0)
                return;
            let Ct = xt[mt];
            if (Ct !== void 0)
                if (Array.isArray(Ct))
                    do
                        Ct = xt[mt],
                        Ct !== void 0 && (tt.push(xt.time),
                        lt.push.apply(lt, Ct)),
                        xt = Tt[ft++];
                    while (xt !== void 0);
                else if (Ct.toArray !== void 0)
                    do
                        Ct = xt[mt],
                        Ct !== void 0 && (tt.push(xt.time),
                        Ct.toArray(lt, lt.length)),
                        xt = Tt[ft++];
                    while (xt !== void 0);
                else
                    do
                        Ct = xt[mt],
                        Ct !== void 0 && (tt.push(xt.time),
                        lt.push(Ct)),
                        xt = Tt[ft++];
                    while (xt !== void 0)
        }
        const AS = {
            convertArray: Rp,
            isTypedArray: yA,
            getKeyframeOrder: xA,
            sortedArray: my,
            flattenJSON: fy,
            subclip: function(Tt, tt, lt, mt, ft=30) {
                const xt = Tt.clone();
                xt.name = tt;
                const Ct = [];
                for (let Lt = 0; Lt < xt.tracks.length; ++Lt) {
                    const Nt = xt.tracks[Lt]
                      , jt = Nt.getValueSize()
                      , Wt = []
                      , Qt = [];
                    for (let qt = 0; qt < Nt.times.length; ++qt) {
                        const Xt = Nt.times[qt] * ft;
                        if (!(Xt < lt || Xt >= mt)) {
                            Wt.push(Nt.times[qt]);
                            for (let Zt = 0; Zt < jt; ++Zt)
                                Qt.push(Nt.values[qt * jt + Zt])
                        }
                    }
                    Wt.length !== 0 && (Nt.times = Rp(Wt, Nt.times.constructor),
                    Nt.values = Rp(Qt, Nt.values.constructor),
                    Ct.push(Nt))
                }
                xt.tracks = Ct;
                let Mt = 1 / 0;
                for (let Lt = 0; Lt < xt.tracks.length; ++Lt)
                    Mt > xt.tracks[Lt].times[0] && (Mt = xt.tracks[Lt].times[0]);
                for (let Lt = 0; Lt < xt.tracks.length; ++Lt)
                    xt.tracks[Lt].shift(-1 * Mt);
                return xt.resetDuration(),
                xt
            },
            makeClipAdditive: function(Tt, tt=0, lt=Tt, mt=30) {
                mt <= 0 && (mt = 30);
                const ft = lt.tracks.length
                  , xt = tt / mt;
                for (let Ct = 0; Ct < ft; ++Ct) {
                    const Mt = lt.tracks[Ct]
                      , Lt = Mt.ValueTypeName;
                    if (Lt === "bool" || Lt === "string")
                        continue;
                    const Nt = Tt.tracks.find(function(sr) {
                        return sr.name === Mt.name && sr.ValueTypeName === Lt
                    });
                    if (Nt === void 0)
                        continue;
                    let jt = 0;
                    const Wt = Mt.getValueSize();
                    Mt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (jt = Wt / 3);
                    let Qt = 0;
                    const qt = Nt.getValueSize();
                    Nt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (Qt = qt / 3);
                    const Xt = Mt.times.length - 1;
                    let Zt;
                    if (xt <= Mt.times[0]) {
                        const sr = jt
                          , er = Wt - jt;
                        Zt = Mt.values.slice(sr, er)
                    } else if (xt >= Mt.times[Xt]) {
                        const sr = Xt * Wt + jt
                          , er = sr + Wt - jt;
                        Zt = Mt.values.slice(sr, er)
                    } else {
                        const sr = Mt.createInterpolant()
                          , er = jt
                          , rr = Wt - jt;
                        sr.evaluate(xt),
                        Zt = sr.resultBuffer.slice(er, rr)
                    }
                    Lt === "quaternion" && new Is().fromArray(Zt).normalize().conjugate().toArray(Zt);
                    const Yt = Nt.times.length;
                    for (let sr = 0; sr < Yt; ++sr) {
                        const er = sr * qt + Qt;
                        if (Lt === "quaternion")
                            Is.multiplyQuaternionsFlat(Nt.values, er, Zt, 0, Nt.values, er);
                        else {
                            const rr = qt - 2 * Qt;
                            for (let xr = 0; xr < rr; ++xr)
                                Nt.values[er + xr] -= Zt[xr]
                        }
                    }
                }
                return Tt.blendMode = Xp,
                Tt
            }
        };
        class k_ {
            constructor(tt, lt, mt, ft) {
                this.parameterPositions = tt,
                this._cachedIndex = 0,
                this.resultBuffer = ft !== void 0 ? ft : new lt.constructor(mt),
                this.sampleValues = lt,
                this.valueSize = mt,
                this.settings = null,
                this.DefaultSettings_ = {}
            }
            evaluate(tt) {
                const lt = this.parameterPositions;
                let mt = this._cachedIndex
                  , ft = lt[mt]
                  , xt = lt[mt - 1];
                e: {
                    t: {
                        let Ct;
                        r: {
                            n: if (!(tt < ft)) {
                                for (let Mt = mt + 2; ; ) {
                                    if (ft === void 0) {
                                        if (tt < xt)
                                            break n;
                                        return mt = lt.length,
                                        this._cachedIndex = mt,
                                        this.copySampleValue_(mt - 1)
                                    }
                                    if (mt === Mt)
                                        break;
                                    if (xt = ft,
                                    ft = lt[++mt],
                                    tt < ft)
                                        break t
                                }
                                Ct = lt.length;
                                break r
                            }
                            if (tt >= xt)
                                break e;
                            {
                                const Mt = lt[1];
                                tt < Mt && (mt = 2,
                                xt = Mt);
                                for (let Lt = mt - 2; ; ) {
                                    if (xt === void 0)
                                        return this._cachedIndex = 0,
                                        this.copySampleValue_(0);
                                    if (mt === Lt)
                                        break;
                                    if (ft = xt,
                                    xt = lt[--mt - 1],
                                    tt >= xt)
                                        break t
                                }
                                Ct = mt,
                                mt = 0
                            }
                        }
                        for (; mt < Ct; ) {
                            const Mt = mt + Ct >>> 1;
                            tt < lt[Mt] ? Ct = Mt : mt = Mt + 1
                        }
                        if (ft = lt[mt],
                        xt = lt[mt - 1],
                        xt === void 0)
                            return this._cachedIndex = 0,
                            this.copySampleValue_(0);
                        if (ft === void 0)
                            return mt = lt.length,
                            this._cachedIndex = mt,
                            this.copySampleValue_(mt - 1)
                    }
                    this._cachedIndex = mt,
                    this.intervalChanged_(mt, xt, ft)
                }
                return this.interpolate_(mt, xt, tt, ft)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(tt) {
                const lt = this.resultBuffer
                  , mt = this.sampleValues
                  , ft = this.valueSize
                  , xt = tt * ft;
                for (let Ct = 0; Ct !== ft; ++Ct)
                    lt[Ct] = mt[xt + Ct];
                return lt
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class bA extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft),
                this._weightPrev = -0,
                this._offsetPrev = -0,
                this._weightNext = -0,
                this._offsetNext = -0,
                this.DefaultSettings_ = {
                    endingStart: du,
                    endingEnd: du
                }
            }
            intervalChanged_(tt, lt, mt) {
                const ft = this.parameterPositions;
                let xt = tt - 2
                  , Ct = tt + 1
                  , Mt = ft[xt]
                  , Lt = ft[Ct];
                if (Mt === void 0)
                    switch (this.getSettings_().endingStart) {
                    case pu:
                        xt = tt,
                        Mt = 2 * lt - mt;
                        break;
                    case cp:
                        xt = ft.length - 2,
                        Mt = lt + ft[xt] - ft[xt + 1];
                        break;
                    default:
                        xt = tt,
                        Mt = mt
                    }
                if (Lt === void 0)
                    switch (this.getSettings_().endingEnd) {
                    case pu:
                        Ct = tt,
                        Lt = 2 * mt - lt;
                        break;
                    case cp:
                        Ct = 1,
                        Lt = mt + ft[1] - ft[0];
                        break;
                    default:
                        Ct = tt - 1,
                        Lt = lt
                    }
                const Nt = .5 * (mt - lt)
                  , jt = this.valueSize;
                this._weightPrev = Nt / (lt - Mt),
                this._weightNext = Nt / (Lt - mt),
                this._offsetPrev = xt * jt,
                this._offsetNext = Ct * jt
            }
            interpolate_(tt, lt, mt, ft) {
                const xt = this.resultBuffer
                  , Ct = this.sampleValues
                  , Mt = this.valueSize
                  , Lt = tt * Mt
                  , Nt = Lt - Mt
                  , jt = this._offsetPrev
                  , Wt = this._offsetNext
                  , Qt = this._weightPrev
                  , qt = this._weightNext
                  , Xt = (mt - lt) / (ft - lt)
                  , Zt = Xt * Xt
                  , Yt = Zt * Xt
                  , sr = -Qt * Yt + 2 * Qt * Zt - Qt * Xt
                  , er = (1 + Qt) * Yt + (-1.5 - 2 * Qt) * Zt + (-.5 + Qt) * Xt + 1
                  , rr = (-1 - qt) * Yt + (1.5 + qt) * Zt + .5 * Xt
                  , xr = qt * Yt - qt * Zt;
                for (let br = 0; br !== Mt; ++br)
                    xt[br] = sr * Ct[jt + br] + er * Ct[Nt + br] + rr * Ct[Lt + br] + xr * Ct[Wt + br];
                return xt
            }
        }
        class gy extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft)
            }
            interpolate_(tt, lt, mt, ft) {
                const xt = this.resultBuffer
                  , Ct = this.sampleValues
                  , Mt = this.valueSize
                  , Lt = tt * Mt
                  , Nt = Lt - Mt
                  , jt = (mt - lt) / (ft - lt)
                  , Wt = 1 - jt;
                for (let Qt = 0; Qt !== Mt; ++Qt)
                    xt[Qt] = Ct[Nt + Qt] * Wt + Ct[Lt + Qt] * jt;
                return xt
            }
        }
        class AA extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft)
            }
            interpolate_(tt) {
                return this.copySampleValue_(tt - 1)
            }
        }
        class Ql {
            constructor(tt, lt, mt, ft) {
                if (tt === void 0)
                    throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (lt === void 0 || lt.length === 0)
                    throw new Error("THREE.KeyframeTrack: no keyframes in track named " + tt);
                this.name = tt,
                this.times = Rp(lt, this.TimeBufferType),
                this.values = Rp(mt, this.ValueBufferType),
                this.setInterpolation(ft || this.DefaultInterpolation)
            }
            static toJSON(tt) {
                const lt = tt.constructor;
                let mt;
                if (lt.toJSON !== this.toJSON)
                    mt = lt.toJSON(tt);
                else {
                    mt = {
                        name: tt.name,
                        times: Rp(tt.times, Array),
                        values: Rp(tt.values, Array)
                    };
                    const ft = tt.getInterpolation();
                    ft !== tt.DefaultInterpolation && (mt.interpolation = ft)
                }
                return mt.type = tt.ValueTypeName,
                mt
            }
            InterpolantFactoryMethodDiscrete(tt) {
                return new AA(this.times,this.values,this.getValueSize(),tt)
            }
            InterpolantFactoryMethodLinear(tt) {
                return new gy(this.times,this.values,this.getValueSize(),tt)
            }
            InterpolantFactoryMethodSmooth(tt) {
                return new bA(this.times,this.values,this.getValueSize(),tt)
            }
            setInterpolation(tt) {
                let lt;
                switch (tt) {
                case Bu:
                    lt = this.InterpolantFactoryMethodDiscrete;
                    break;
                case lp:
                    lt = this.InterpolantFactoryMethodLinear;
                    break;
                case $p:
                    lt = this.InterpolantFactoryMethodSmooth
                }
                if (lt === void 0) {
                    const mt = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (this.createInterpolant === void 0) {
                        if (tt === this.DefaultInterpolation)
                            throw new Error(mt);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", mt),
                    this
                }
                return this.createInterpolant = lt,
                this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return Bu;
                case this.InterpolantFactoryMethodLinear:
                    return lp;
                case this.InterpolantFactoryMethodSmooth:
                    return $p
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(tt) {
                if (tt !== 0) {
                    const lt = this.times;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt)
                        lt[mt] += tt
                }
                return this
            }
            scale(tt) {
                if (tt !== 1) {
                    const lt = this.times;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt)
                        lt[mt] *= tt
                }
                return this
            }
            trim(tt, lt) {
                const mt = this.times
                  , ft = mt.length;
                let xt = 0
                  , Ct = ft - 1;
                for (; xt !== ft && mt[xt] < tt; )
                    ++xt;
                for (; Ct !== -1 && mt[Ct] > lt; )
                    --Ct;
                if (++Ct,
                xt !== 0 || Ct !== ft) {
                    xt >= Ct && (Ct = Math.max(Ct, 1),
                    xt = Ct - 1);
                    const Mt = this.getValueSize();
                    this.times = mt.slice(xt, Ct),
                    this.values = this.values.slice(xt * Mt, Ct * Mt)
                }
                return this
            }
            validate() {
                let tt = !0;
                const lt = this.getValueSize();
                lt - Math.floor(lt) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
                tt = !1);
                const mt = this.times
                  , ft = this.values
                  , xt = mt.length;
                xt === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
                tt = !1);
                let Ct = null;
                for (let Mt = 0; Mt !== xt; Mt++) {
                    const Lt = mt[Mt];
                    if (typeof Lt == "number" && isNaN(Lt)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, Mt, Lt),
                        tt = !1;
                        break
                    }
                    if (Ct !== null && Ct > Lt) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, Mt, Lt, Ct),
                        tt = !1;
                        break
                    }
                    Ct = Lt
                }
                if (ft !== void 0 && yA(ft))
                    for (let Mt = 0, Lt = ft.length; Mt !== Lt; ++Mt) {
                        const Nt = ft[Mt];
                        if (isNaN(Nt)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, Mt, Nt),
                            tt = !1;
                            break
                        }
                    }
                return tt
            }
            optimize() {
                const tt = this.times.slice()
                  , lt = this.values.slice()
                  , mt = this.getValueSize()
                  , ft = this.getInterpolation() === $p
                  , xt = tt.length - 1;
                let Ct = 1;
                for (let Mt = 1; Mt < xt; ++Mt) {
                    let Lt = !1;
                    const Nt = tt[Mt];
                    if (Nt !== tt[Mt + 1] && (Mt !== 1 || Nt !== tt[0]))
                        if (ft)
                            Lt = !0;
                        else {
                            const jt = Mt * mt
                              , Wt = jt - mt
                              , Qt = jt + mt;
                            for (let qt = 0; qt !== mt; ++qt) {
                                const Xt = lt[jt + qt];
                                if (Xt !== lt[Wt + qt] || Xt !== lt[Qt + qt]) {
                                    Lt = !0;
                                    break
                                }
                            }
                        }
                    if (Lt) {
                        if (Mt !== Ct) {
                            tt[Ct] = tt[Mt];
                            const jt = Mt * mt
                              , Wt = Ct * mt;
                            for (let Qt = 0; Qt !== mt; ++Qt)
                                lt[Wt + Qt] = lt[jt + Qt]
                        }
                        ++Ct
                    }
                }
                if (xt > 0) {
                    tt[Ct] = tt[xt];
                    for (let Mt = xt * mt, Lt = Ct * mt, Nt = 0; Nt !== mt; ++Nt)
                        lt[Lt + Nt] = lt[Mt + Nt];
                    ++Ct
                }
                return Ct !== tt.length ? (this.times = tt.slice(0, Ct),
                this.values = lt.slice(0, Ct * mt)) : (this.times = tt,
                this.values = lt),
                this
            }
            clone() {
                const tt = this.times.slice()
                  , lt = this.values.slice()
                  , mt = new this.constructor(this.name,tt,lt);
                return mt.createInterpolant = this.createInterpolant,
                mt
            }
        }
        Ql.prototype.TimeBufferType = Float32Array,
        Ql.prototype.ValueBufferType = Float32Array,
        Ql.prototype.DefaultInterpolation = lp;
        class Ip extends Ql {
        }
        Ip.prototype.ValueTypeName = "bool",
        Ip.prototype.ValueBufferType = Array,
        Ip.prototype.DefaultInterpolation = Bu,
        Ip.prototype.InterpolantFactoryMethodLinear = void 0,
        Ip.prototype.InterpolantFactoryMethodSmooth = void 0;
        class _y extends Ql {
        }
        _y.prototype.ValueTypeName = "color";
        class D_ extends Ql {
        }
        D_.prototype.ValueTypeName = "number";
        class wA extends k_ {
            constructor(tt, lt, mt, ft) {
                super(tt, lt, mt, ft)
            }
            interpolate_(tt, lt, mt, ft) {
                const xt = this.resultBuffer
                  , Ct = this.sampleValues
                  , Mt = this.valueSize
                  , Lt = (mt - lt) / (ft - lt);
                let Nt = tt * Mt;
                for (let jt = Nt + Mt; Nt !== jt; Nt += 4)
                    Is.slerpFlat(xt, 0, Ct, Nt - Mt, Ct, Nt, Lt);
                return xt
            }
        }
        class Dm extends Ql {
            InterpolantFactoryMethodLinear(tt) {
                return new wA(this.times,this.values,this.getValueSize(),tt)
            }
        }
        Dm.prototype.ValueTypeName = "quaternion",
        Dm.prototype.DefaultInterpolation = lp,
        Dm.prototype.InterpolantFactoryMethodSmooth = void 0;
        class kp extends Ql {
        }
        kp.prototype.ValueTypeName = "string",
        kp.prototype.ValueBufferType = Array,
        kp.prototype.DefaultInterpolation = Bu,
        kp.prototype.InterpolantFactoryMethodLinear = void 0,
        kp.prototype.InterpolantFactoryMethodSmooth = void 0;
        class B_ extends Ql {
        }
        B_.prototype.ValueTypeName = "vector";
        class L_ {
            constructor(tt, lt=-1, mt, ft=Hm) {
                this.name = tt,
                this.tracks = mt,
                this.duration = lt,
                this.blendMode = ft,
                this.uuid = Ms(),
                this.duration < 0 && this.resetDuration()
            }
            static parse(tt) {
                const lt = []
                  , mt = tt.tracks
                  , ft = 1 / (tt.fps || 1);
                for (let Ct = 0, Mt = mt.length; Ct !== Mt; ++Ct)
                    lt.push(wS(mt[Ct]).scale(ft));
                const xt = new this(tt.name,tt.duration,lt,tt.blendMode);
                return xt.uuid = tt.uuid,
                xt
            }
            static toJSON(tt) {
                const lt = []
                  , mt = tt.tracks
                  , ft = {
                    name: tt.name,
                    duration: tt.duration,
                    tracks: lt,
                    uuid: tt.uuid,
                    blendMode: tt.blendMode
                };
                for (let xt = 0, Ct = mt.length; xt !== Ct; ++xt)
                    lt.push(Ql.toJSON(mt[xt]));
                return ft
            }
            static CreateFromMorphTargetSequence(tt, lt, mt, ft) {
                const xt = lt.length
                  , Ct = [];
                for (let Mt = 0; Mt < xt; Mt++) {
                    let Lt = []
                      , Nt = [];
                    Lt.push((Mt + xt - 1) % xt, Mt, (Mt + 1) % xt),
                    Nt.push(0, 1, 0);
                    const jt = xA(Lt);
                    Lt = my(Lt, 1, jt),
                    Nt = my(Nt, 1, jt),
                    ft || Lt[0] !== 0 || (Lt.push(xt),
                    Nt.push(Nt[0])),
                    Ct.push(new D_(".morphTargetInfluences[" + lt[Mt].name + "]",Lt,Nt).scale(1 / mt))
                }
                return new this(tt,-1,Ct)
            }
            static findByName(tt, lt) {
                let mt = tt;
                if (!Array.isArray(tt)) {
                    const ft = tt;
                    mt = ft.geometry && ft.geometry.animations || ft.animations
                }
                for (let ft = 0; ft < mt.length; ft++)
                    if (mt[ft].name === lt)
                        return mt[ft];
                return null
            }
            static CreateClipsFromMorphTargetSequences(tt, lt, mt) {
                const ft = {}
                  , xt = /^([\w-]*?)([\d]+)$/;
                for (let Mt = 0, Lt = tt.length; Mt < Lt; Mt++) {
                    const Nt = tt[Mt]
                      , jt = Nt.name.match(xt);
                    if (jt && jt.length > 1) {
                        const Wt = jt[1];
                        let Qt = ft[Wt];
                        Qt || (ft[Wt] = Qt = []),
                        Qt.push(Nt)
                    }
                }
                const Ct = [];
                for (const Mt in ft)
                    Ct.push(this.CreateFromMorphTargetSequence(Mt, ft[Mt], lt, mt));
                return Ct
            }
            static parseAnimation(tt, lt) {
                if (!tt)
                    return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                    null;
                const mt = function(jt, Wt, Qt, qt, Xt) {
                    if (Qt.length !== 0) {
                        const Zt = []
                          , Yt = [];
                        fy(Qt, Zt, Yt, qt),
                        Zt.length !== 0 && Xt.push(new jt(Wt,Zt,Yt))
                    }
                }
                  , ft = []
                  , xt = tt.name || "default"
                  , Ct = tt.fps || 30
                  , Mt = tt.blendMode;
                let Lt = tt.length || -1;
                const Nt = tt.hierarchy || [];
                for (let jt = 0; jt < Nt.length; jt++) {
                    const Wt = Nt[jt].keys;
                    if (Wt && Wt.length !== 0)
                        if (Wt[0].morphTargets) {
                            const Qt = {};
                            let qt;
                            for (qt = 0; qt < Wt.length; qt++)
                                if (Wt[qt].morphTargets)
                                    for (let Xt = 0; Xt < Wt[qt].morphTargets.length; Xt++)
                                        Qt[Wt[qt].morphTargets[Xt]] = -1;
                            for (const Xt in Qt) {
                                const Zt = []
                                  , Yt = [];
                                for (let sr = 0; sr !== Wt[qt].morphTargets.length; ++sr) {
                                    const er = Wt[qt];
                                    Zt.push(er.time),
                                    Yt.push(er.morphTarget === Xt ? 1 : 0)
                                }
                                ft.push(new D_(".morphTargetInfluence[" + Xt + "]",Zt,Yt))
                            }
                            Lt = Qt.length * Ct
                        } else {
                            const Qt = ".bones[" + lt[jt].name + "]";
                            mt(B_, Qt + ".position", Wt, "pos", ft),
                            mt(Dm, Qt + ".quaternion", Wt, "rot", ft),
                            mt(B_, Qt + ".scale", Wt, "scl", ft)
                        }
                }
                return ft.length === 0 ? null : new this(xt,Lt,ft,Mt)
            }
            resetDuration() {
                let tt = 0;
                for (let lt = 0, mt = this.tracks.length; lt !== mt; ++lt) {
                    const ft = this.tracks[lt];
                    tt = Math.max(tt, ft.times[ft.times.length - 1])
                }
                return this.duration = tt,
                this
            }
            trim() {
                for (let tt = 0; tt < this.tracks.length; tt++)
                    this.tracks[tt].trim(0, this.duration);
                return this
            }
            validate() {
                let tt = !0;
                for (let lt = 0; lt < this.tracks.length; lt++)
                    tt = tt && this.tracks[lt].validate();
                return tt
            }
            optimize() {
                for (let tt = 0; tt < this.tracks.length; tt++)
                    this.tracks[tt].optimize();
                return this
            }
            clone() {
                const tt = [];
                for (let lt = 0; lt < this.tracks.length; lt++)
                    tt.push(this.tracks[lt].clone());
                return new this.constructor(this.name,this.duration,tt,this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }
        function wS(Tt) {
            if (Tt.type === void 0)
                throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const tt = function(lt) {
                switch (lt.toLowerCase()) {
                case "scalar":
                case "double":
                case "float":
                case "number":
                case "integer":
                    return D_;
                case "vector":
                case "vector2":
                case "vector3":
                case "vector4":
                    return B_;
                case "color":
                    return _y;
                case "quaternion":
                    return Dm;
                case "bool":
                case "boolean":
                    return Ip;
                case "string":
                    return kp
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + lt)
            }(Tt.type);
            if (Tt.times === void 0) {
                const lt = []
                  , mt = [];
                fy(Tt.keys, lt, mt, "value"),
                Tt.times = lt,
                Tt.values = mt
            }
            return tt.parse !== void 0 ? tt.parse(Tt) : new tt(Tt.name,Tt.times,Tt.values,Tt.interpolation)
        }
        const Eu = {
            enabled: !1,
            files: {},
            add: function(Tt, tt) {
                this.enabled !== !1 && (this.files[Tt] = tt)
            },
            get: function(Tt, tt) {
                return this.enabled === !1 ? tt ? Promise.resolve() : void 0 : tt ? Promise.resolve(this.files[Tt]) : this.files[Tt]
            },
            remove: function(Tt) {
                delete this.files[Tt]
            },
            clear: function() {
                this.files = {}
            }
        };
        class vy {
            constructor(tt, lt, mt) {
                const ft = this;
                let xt, Ct = !1, Mt = 0, Lt = 0;
                const Nt = [];
                this.onStart = void 0,
                this.onLoad = tt,
                this.onProgress = lt,
                this.onError = mt,
                this.itemStart = function(jt) {
                    Lt++,
                    Ct === !1 && ft.onStart !== void 0 && ft.onStart(jt, Mt, Lt),
                    Ct = !0
                }
                ,
                this.itemEnd = function(jt) {
                    Mt++,
                    ft.onProgress !== void 0 && ft.onProgress(jt, Mt, Lt),
                    Mt === Lt && (Ct = !1,
                    ft.onLoad !== void 0 && ft.onLoad())
                }
                ,
                this.itemError = function(jt) {
                    ft.onError !== void 0 && ft.onError(jt)
                }
                ,
                this.resolveURL = function(jt) {
                    return xt ? xt(jt) : jt
                }
                ,
                this.setURLModifier = function(jt) {
                    return xt = jt,
                    this
                }
                ,
                this.addHandler = function(jt, Wt) {
                    return Nt.push(jt, Wt),
                    this
                }
                ,
                this.removeHandler = function(jt) {
                    const Wt = Nt.indexOf(jt);
                    return Wt !== -1 && Nt.splice(Wt, 2),
                    this
                }
                ,
                this.getHandler = function(jt) {
                    for (let Wt = 0, Qt = Nt.length; Wt < Qt; Wt += 2) {
                        const qt = Nt[Wt]
                          , Xt = Nt[Wt + 1];
                        if (qt.global && (qt.lastIndex = 0),
                        qt.test(jt))
                            return Xt
                    }
                    return null
                }
            }
        }
        const SA = new vy;
        class $s {
            constructor(tt) {
                this.manager = tt !== void 0 ? tt : SA,
                this.crossOrigin = "anonymous",
                this.withCredentials = !1,
                this.path = "",
                this.resourcePath = "",
                this.requestHeader = {}
            }
            load() {}
            loadAsync(tt, lt) {
                const mt = this;
                return new Promise(function(ft, xt) {
                    mt.load(tt, ft, lt, xt)
                }
                )
            }
            parse() {}
            setCrossOrigin(tt) {
                return this.crossOrigin = tt,
                this
            }
            setWithCredentials(tt) {
                return this.withCredentials = tt,
                this
            }
            setPath(tt) {
                return this.path = tt,
                this
            }
            setResourcePath(tt) {
                return this.resourcePath = tt,
                this
            }
            setRequestHeader(tt) {
                return this.requestHeader = tt,
                this
            }
        }
        $s.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const Tu = {};
        class SS extends Error {
            constructor(tt, lt) {
                super(tt),
                this.response = lt
            }
        }
        class su extends $s {
            constructor(tt) {
                super(tt),
                this.responseType = "text",
                this.useCache = !0
            }
            load(tt, lt, mt, ft) {
                tt === void 0 && (tt = ""),
                this.path !== void 0 && (tt = this.path + tt),
                tt = this.manager.resolveURL(tt),
                (this.useCache ? Eu.get(tt, this.responseType, this.mimeType) : Promise.resolve(void 0)).then(xt => {
                    if (xt !== void 0)
                        return this.manager.itemStart(tt),
                        setTimeout( () => {
                            lt && lt(xt),
                            this.manager.itemEnd(tt)
                        }
                        , 0),
                        xt;
                    if (Tu[tt] !== void 0)
                        return void Tu[tt].push({
                            onLoad: lt,
                            onProgress: mt,
                            onError: ft
                        });
                    Tu[tt] = [],
                    Tu[tt].push({
                        onLoad: lt,
                        onProgress: mt,
                        onError: ft
                    });
                    const Ct = new Request(tt,{
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    })
                      , Mt = this.mimeType
                      , Lt = this.responseType;
                    fetch(Ct).then(Nt => {
                        if (Nt.status === 200 || Nt.status === 0) {
                            if (Nt.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                            typeof ReadableStream > "u" || Nt.body === void 0 || Nt.body.getReader === void 0)
                                return Nt;
                            const jt = Tu[tt]
                              , Wt = Nt.body.getReader()
                              , Qt = Nt.headers.get("Content-Length") || Nt.headers.get("X-File-Size")
                              , qt = Qt ? parseInt(Qt) : 0
                              , Xt = qt !== 0;
                            let Zt = 0;
                            const Yt = new ReadableStream({
                                start(sr) {
                                    (function er() {
                                        Wt.read().then( ({done: rr, value: xr}) => {
                                            if (rr)
                                                sr.close();
                                            else {
                                                Zt += xr.byteLength;
                                                const br = new ProgressEvent("progress",{
                                                    lengthComputable: Xt,
                                                    loaded: Zt,
                                                    total: qt
                                                });
                                                for (let yr = 0, Pr = jt.length; yr < Pr; yr++) {
                                                    const zr = jt[yr];
                                                    zr.onProgress && zr.onProgress(br)
                                                }
                                                sr.enqueue(xr),
                                                er()
                                            }
                                        }
                                        )
                                    }
                                    )()
                                }
                            });
                            return new Response(Yt)
                        }
                        throw new SS(`fetch for "${Nt.url}" responded with ${Nt.status}: ${Nt.statusText}`,Nt)
                    }
                    ).then(Nt => {
                        switch (Lt) {
                        case "arraybuffer":
                            return Nt.arrayBuffer();
                        case "blob":
                            return Nt.blob();
                        case "document":
                            return Nt.text().then(jt => new DOMParser().parseFromString(jt, Mt));
                        case "json":
                            return Nt.json();
                        default:
                            if (Mt === void 0)
                                return Nt.text();
                            {
                                const jt = /charset="?([^;"\s]*)"?/i.exec(Mt)
                                  , Wt = jt && jt[1] ? jt[1].toLowerCase() : void 0
                                  , Qt = new TextDecoder(Wt);
                                return Nt.arrayBuffer().then(qt => Qt.decode(qt))
                            }
                        }
                    }
                    ).then(Nt => {
                        this.useCache && Eu.add(tt, Nt, this.responseType);
                        const jt = Tu[tt];
                        delete Tu[tt];
                        for (let Wt = 0, Qt = jt.length; Wt < Qt; Wt++) {
                            const qt = jt[Wt];
                            qt.onLoad && qt.onLoad(Nt)
                        }
                    }
                    ).catch(Nt => {
                        const jt = Tu[tt];
                        if (jt === void 0)
                            throw this.manager.itemError(tt),
                            Nt;
                        delete Tu[tt];
                        for (let Wt = 0, Qt = jt.length; Wt < Qt; Wt++) {
                            const qt = jt[Wt];
                            qt.onError && qt.onError(Nt)
                        }
                        this.manager.itemError(tt)
                    }
                    ).finally( () => {
                        this.useCache && this.manager.itemEnd(tt)
                    }
                    ),
                    this.useCache && this.manager.itemStart(tt)
                }
                )
            }
            setResponseType(tt) {
                return this.responseType = tt,
                this
            }
            setMimeType(tt) {
                return this.mimeType = tt,
                this
            }
        }
        class ES extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(this.manager);
                Ct.setPath(this.path),
                Ct.setRequestHeader(this.requestHeader),
                Ct.setWithCredentials(this.withCredentials),
                Ct.load(tt, function(Mt) {
                    try {
                        lt(xt.parse(JSON.parse(Mt)))
                    } catch (Lt) {
                        ft ? ft(Lt) : console.error(Lt),
                        xt.manager.itemError(tt)
                    }
                }, mt, ft)
            }
            parse(tt) {
                const lt = [];
                for (let mt = 0; mt < tt.length; mt++) {
                    const ft = L_.parse(tt[mt]);
                    lt.push(ft)
                }
                return lt
            }
        }
        class TS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = []
                  , Mt = new jv
                  , Lt = new su(this.manager);
                Lt.setPath(this.path),
                Lt.setResponseType("arraybuffer"),
                Lt.setRequestHeader(this.requestHeader),
                Lt.setWithCredentials(xt.withCredentials);
                let Nt = 0;
                function jt(Wt) {
                    Lt.load(tt[Wt], function(Qt) {
                        const qt = xt.parse(Qt, !0);
                        Ct[Wt] = {
                            width: qt.width,
                            height: qt.height,
                            format: qt.format,
                            mipmaps: qt.mipmaps
                        },
                        Nt += 1,
                        Nt === 6 && (qt.mipmapCount === 1 && (Mt.minFilter = Rn),
                        Mt.image = Ct,
                        Mt.format = qt.format,
                        Mt.needsUpdate = !0,
                        lt && lt(Mt))
                    }, mt, ft)
                }
                if (Array.isArray(tt))
                    for (let Wt = 0, Qt = tt.length; Wt < Qt; ++Wt)
                        jt(Wt);
                else
                    Lt.load(tt, function(Wt) {
                        const Qt = xt.parse(Wt, !0);
                        if (Qt.isCubemap) {
                            const qt = Qt.mipmaps.length / Qt.mipmapCount;
                            for (let Xt = 0; Xt < qt; Xt++) {
                                Ct[Xt] = {
                                    mipmaps: []
                                };
                                for (let Zt = 0; Zt < Qt.mipmapCount; Zt++)
                                    Ct[Xt].mipmaps.push(Qt.mipmaps[Xt * Qt.mipmapCount + Zt]),
                                    Ct[Xt].format = Qt.format,
                                    Ct[Xt].width = Qt.width,
                                    Ct[Xt].height = Qt.height
                            }
                            Mt.image = Ct
                        } else
                            Mt.image.width = Qt.width,
                            Mt.image.height = Qt.height,
                            Mt.mipmaps = Qt.mipmaps;
                        Qt.mipmapCount === 1 && (Mt.minFilter = Rn),
                        Mt.format = Qt.format,
                        Mt.needsUpdate = !0,
                        lt && lt(Mt)
                    }, mt, ft);
                return Mt
            }
        }
        class O_ extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = tt;
                this.path !== void 0 && (tt = this.path + tt),
                tt = this.manager.resolveURL(tt);
                const Ct = this
                  , Mt = Eu.get(tt);
                if (Mt !== void 0)
                    return Ct.manager.itemStart(tt),
                    setTimeout(function() {
                        lt && lt(Mt),
                        Ct.manager.itemEnd(tt)
                    }, 0),
                    Mt;
                const Lt = yu("img");
                function Nt() {
                    Wt(),
                    Eu.add(tt, this),
                    lt && lt(this),
                    Ct.manager.itemEnd(tt)
                }
                function jt(Qt) {
                    Wt(),
                    ft && ft(Qt),
                    Ct.manager.itemError(tt),
                    Ct.manager.itemEnd(tt)
                }
                function Wt() {
                    Lt.removeEventListener("load", Nt, !1),
                    Lt.removeEventListener("error", jt, !1)
                }
                return Lt.addEventListener("load", Nt, !1),
                Lt.addEventListener("error", jt, !1),
                tt.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (Lt.crossOrigin = this.crossOrigin),
                Ct.manager.itemStart(tt),
                Eu.get(tt, "blob").then(Qt => {
                    if (Qt !== void 0 && !Qt.type.startsWith("text/plain"))
                        return Qt.type || (tt.endsWith(".svg") || tt.startsWith("data:image/svg")) && (Qt = new Blob([Qt],{
                            type: "image/svg+xml"
                        })),
                        void (Lt.src = URL.createObjectURL(Qt));
                    const qt = new su(this.manager);
                    qt.useCache = !1,
                    qt.setPath(this.path),
                    qt.setCrossOrigin(this.crossOrigin),
                    qt.setResponseType("blob"),
                    qt.load(xt, function(Xt) {
                        Xt.type || (tt.endsWith(".svg") || tt.startsWith("data:image/svg")) && (Xt = new Blob([Xt],{
                            type: "image/svg+xml"
                        })),
                        Eu.add(tt, Xt, "blob"),
                        Lt.src = URL.createObjectURL(Xt)
                    }, mt, Xt => {
                        Wt(),
                        ft && ft(Xt)
                    }
                    )
                }
                ),
                Lt
            }
        }
        class CS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = new f_;
                xt.colorSpace = jo;
                const Ct = new O_(this.manager);
                Ct.setCrossOrigin(this.crossOrigin),
                Ct.setPath(this.path);
                let Mt = 0;
                function Lt(Nt) {
                    Ct.load(tt[Nt], function(jt) {
                        xt.images[Nt] = jt,
                        Mt++,
                        Mt === 6 && (xt.needsUpdate = !0,
                        lt && lt(xt))
                    }, void 0, ft)
                }
                for (let Nt = 0; Nt < tt.length; ++Nt)
                    Lt(Nt);
                return xt
            }
        }
        class PS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new Pm
                  , Mt = new su(this.manager);
                return Mt.setResponseType("arraybuffer"),
                Mt.setRequestHeader(this.requestHeader),
                Mt.setPath(this.path),
                Mt.setWithCredentials(xt.withCredentials),
                Mt.load(tt, function(Lt) {
                    let Nt;
                    try {
                        Nt = xt.parse(Lt)
                    } catch (jt) {
                        if (ft === void 0)
                            return void console.error(jt);
                        ft(jt)
                    }
                    Nt.image !== void 0 ? Ct.image = Nt.image : Nt.data !== void 0 && (Ct.image.width = Nt.width,
                    Ct.image.height = Nt.height,
                    Ct.image.data = Nt.data,
                    Ct.image.complete = !0),
                    Ct.wrapS = Nt.wrapS !== void 0 ? Nt.wrapS : wn,
                    Ct.wrapT = Nt.wrapT !== void 0 ? Nt.wrapT : wn,
                    Ct.magFilter = Nt.magFilter !== void 0 ? Nt.magFilter : Rn,
                    Ct.minFilter = Nt.minFilter !== void 0 ? Nt.minFilter : Rn,
                    Ct.anisotropy = Nt.anisotropy !== void 0 ? Nt.anisotropy : 1,
                    Nt.colorSpace !== void 0 ? Ct.colorSpace = Nt.colorSpace : Nt.encoding !== void 0 && (Ct.encoding = Nt.encoding),
                    Nt.flipY !== void 0 && (Ct.flipY = Nt.flipY),
                    Nt.format !== void 0 && (Ct.format = Nt.format),
                    Nt.type !== void 0 && (Ct.type = Nt.type),
                    Nt.mipmaps !== void 0 && (Ct.mipmaps = Nt.mipmaps,
                    Ct.minFilter = vo),
                    Nt.mipmapCount === 1 && (Ct.minFilter = Rn),
                    Nt.generateMipmaps !== void 0 && (Ct.generateMipmaps = Nt.generateMipmaps),
                    Ct.needsUpdate = !0,
                    lt && lt(Ct, Nt)
                }, mt, ft),
                Ct
            }
        }
        class MS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = new Ho
                  , Ct = new O_(this.manager);
                return Ct.setCrossOrigin(this.crossOrigin),
                Ct.setPath(this.path),
                Ct.load(tt, function(Mt) {
                    xt.image = Mt,
                    xt.needsUpdate = !0,
                    lt !== void 0 && lt(xt)
                }, mt, ft),
                xt
            }
        }
        class rp extends Mo {
            constructor(tt, lt=1) {
                super(),
                this.isLight = !0,
                this.type = "Light",
                this.color = new Gn(tt),
                this.intensity = lt
            }
            dispose() {}
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.color.copy(tt.color),
                this.intensity = tt.intensity,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.color = this.color.getHex(),
                lt.object.intensity = this.intensity,
                this.groundColor !== void 0 && (lt.object.groundColor = this.groundColor.getHex()),
                this.distance !== void 0 && (lt.object.distance = this.distance),
                this.angle !== void 0 && (lt.object.angle = this.angle),
                this.decay !== void 0 && (lt.object.decay = this.decay),
                this.penumbra !== void 0 && (lt.object.penumbra = this.penumbra),
                this.shadow !== void 0 && (lt.object.shadow = this.shadow.toJSON()),
                lt
            }
        }
        class EA extends rp {
            constructor(tt, lt, mt) {
                super(tt, mt),
                this.isHemisphereLight = !0,
                this.type = "HemisphereLight",
                this.position.copy(Mo.DEFAULT_UP),
                this.updateMatrix(),
                this.groundColor = new Gn(lt)
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.groundColor.copy(tt.groundColor),
                this
            }
        }
        const yy = new no
          , TA = new Er
          , CA = new Er;
        class xy {
            constructor(tt) {
                this.camera = tt,
                this.bias = 0,
                this.normalBias = 0,
                this.radius = 1,
                this.blurSamples = 8,
                this.mapSize = new mn(512,512),
                this.map = null,
                this.mapPass = null,
                this.matrix = new no,
                this.autoUpdate = !0,
                this.needsUpdate = !1,
                this._frustum = new Av,
                this._frameExtents = new mn(1,1),
                this._viewportCount = 1,
                this._viewports = [new Lo(0,0,1,1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(tt) {
                const lt = this.camera
                  , mt = this.matrix;
                TA.setFromMatrixPosition(tt.matrixWorld),
                lt.position.copy(TA),
                CA.setFromMatrixPosition(tt.target.matrixWorld),
                lt.lookAt(CA),
                lt.updateMatrixWorld(),
                yy.multiplyMatrices(lt.projectionMatrix, lt.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(yy),
                mt.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                mt.multiply(yy)
            }
            getViewport(tt) {
                return this._viewports[tt]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(),
                this.mapPass && this.mapPass.dispose()
            }
            copy(tt) {
                return this.camera = tt.camera.clone(),
                this.bias = tt.bias,
                this.normalBias = tt.normalBias,
                this.radius = tt.radius,
                this.mapSize.copy(tt.mapSize),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            toJSON() {
                const tt = {};
                return this.bias !== 0 && (tt.bias = this.bias),
                this.normalBias !== 0 && (tt.normalBias = this.normalBias),
                this.radius !== 1 && (tt.radius = this.radius),
                this.mapSize.x === 512 && this.mapSize.y === 512 || (tt.mapSize = this.mapSize.toArray()),
                tt.camera = this.camera.toJSON(!1).object,
                delete tt.camera.matrix,
                tt
            }
        }
        class RS extends xy {
            constructor() {
                super(new Cs(50,1,.5,500)),
                this.isSpotLightShadow = !0,
                this.focus = 1
            }
            updateMatrices(tt) {
                const lt = this.camera
                  , mt = 2 * _u * tt.angle * this.focus
                  , ft = this.mapSize.width / this.mapSize.height
                  , xt = tt.distance || lt.far;
                mt === lt.fov && ft === lt.aspect && xt === lt.far || (lt.fov = mt,
                lt.aspect = ft,
                lt.far = xt,
                lt.updateProjectionMatrix()),
                super.updateMatrices(tt)
            }
            copy(tt) {
                return super.copy(tt),
                this.focus = tt.focus,
                this
            }
        }
        class PA extends rp {
            constructor(tt, lt, mt=0, ft=Math.PI / 3, xt=0, Ct=2) {
                super(tt, lt),
                this.isSpotLight = !0,
                this.type = "SpotLight",
                this.position.copy(Mo.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new Mo,
                this.distance = mt,
                this.angle = ft,
                this.penumbra = xt,
                this.decay = Ct,
                this.map = null,
                this.shadow = new RS
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(tt) {
                this.intensity = tt / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.distance = tt.distance,
                this.angle = tt.angle,
                this.penumbra = tt.penumbra,
                this.decay = tt.decay,
                this.target = tt.target.clone(),
                this.shadow = tt.shadow.clone(),
                this
            }
        }
        const MA = new no
          , N_ = new Er
          , by = new Er;
        class IS extends xy {
            constructor() {
                super(new Cs(90,1,.5,500)),
                this.isPointLightShadow = !0,
                this._frameExtents = new mn(4,2),
                this._viewportCount = 6,
                this._viewports = [new Lo(2,1,1,1), new Lo(0,1,1,1), new Lo(3,1,1,1), new Lo(1,1,1,1), new Lo(3,0,1,1), new Lo(1,0,1,1)],
                this._cubeDirections = [new Er(1,0,0), new Er(-1,0,0), new Er(0,0,1), new Er(0,0,-1), new Er(0,1,0), new Er(0,-1,0)],
                this._cubeUps = [new Er(0,1,0), new Er(0,1,0), new Er(0,1,0), new Er(0,1,0), new Er(0,0,1), new Er(0,0,-1)]
            }
            updateMatrices(tt, lt=0) {
                const mt = this.camera
                  , ft = this.matrix
                  , xt = tt.distance || mt.far;
                xt !== mt.far && (mt.far = xt,
                mt.updateProjectionMatrix()),
                N_.setFromMatrixPosition(tt.matrixWorld),
                mt.position.copy(N_),
                by.copy(mt.position),
                by.add(this._cubeDirections[lt]),
                mt.up.copy(this._cubeUps[lt]),
                mt.lookAt(by),
                mt.updateMatrixWorld(),
                ft.makeTranslation(-N_.x, -N_.y, -N_.z),
                MA.multiplyMatrices(mt.projectionMatrix, mt.matrixWorldInverse),
                this._frustum.setFromProjectionMatrix(MA)
            }
        }
        class RA extends rp {
            constructor(tt, lt, mt=0, ft=2) {
                super(tt, lt),
                this.isPointLight = !0,
                this.type = "PointLight",
                this.distance = mt,
                this.decay = ft,
                this.shadow = new IS
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(tt) {
                this.intensity = tt / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.distance = tt.distance,
                this.decay = tt.decay,
                this.shadow = tt.shadow.clone(),
                this
            }
        }
        class kS extends xy {
            constructor() {
                super(new Sv(-5,5,5,-5,.5,500)),
                this.isDirectionalLightShadow = !0
            }
        }
        class IA extends rp {
            constructor(tt, lt) {
                super(tt, lt),
                this.isDirectionalLight = !0,
                this.type = "DirectionalLight",
                this.position.copy(Mo.DEFAULT_UP),
                this.updateMatrix(),
                this.target = new Mo,
                this.shadow = new kS
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(tt) {
                return super.copy(tt),
                this.target = tt.target.clone(),
                this.shadow = tt.shadow.clone(),
                this
            }
        }
        class kA extends rp {
            constructor(tt, lt) {
                super(tt, lt),
                this.isAmbientLight = !0,
                this.type = "AmbientLight"
            }
        }
        class DA extends rp {
            constructor(tt, lt, mt=10, ft=10) {
                super(tt, lt),
                this.isRectAreaLight = !0,
                this.type = "RectAreaLight",
                this.width = mt,
                this.height = ft
            }
            get power() {
                return this.intensity * this.width * this.height * Math.PI
            }
            set power(tt) {
                this.intensity = tt / (this.width * this.height * Math.PI)
            }
            copy(tt) {
                return super.copy(tt),
                this.width = tt.width,
                this.height = tt.height,
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.width = this.width,
                lt.object.height = this.height,
                lt
            }
        }
        class BA {
            constructor() {
                this.isSphericalHarmonics3 = !0,
                this.coefficients = [];
                for (let tt = 0; tt < 9; tt++)
                    this.coefficients.push(new Er)
            }
            set(tt) {
                for (let lt = 0; lt < 9; lt++)
                    this.coefficients[lt].copy(tt[lt]);
                return this
            }
            zero() {
                for (let tt = 0; tt < 9; tt++)
                    this.coefficients[tt].set(0, 0, 0);
                return this
            }
            getAt(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = this.coefficients;
                return lt.copy(Ct[0]).multiplyScalar(.282095),
                lt.addScaledVector(Ct[1], .488603 * ft),
                lt.addScaledVector(Ct[2], .488603 * xt),
                lt.addScaledVector(Ct[3], .488603 * mt),
                lt.addScaledVector(Ct[4], mt * ft * 1.092548),
                lt.addScaledVector(Ct[5], ft * xt * 1.092548),
                lt.addScaledVector(Ct[6], .315392 * (3 * xt * xt - 1)),
                lt.addScaledVector(Ct[7], mt * xt * 1.092548),
                lt.addScaledVector(Ct[8], .546274 * (mt * mt - ft * ft)),
                lt
            }
            getIrradianceAt(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z
                  , Ct = this.coefficients;
                return lt.copy(Ct[0]).multiplyScalar(.886227),
                lt.addScaledVector(Ct[1], 1.023328 * ft),
                lt.addScaledVector(Ct[2], 1.023328 * xt),
                lt.addScaledVector(Ct[3], 1.023328 * mt),
                lt.addScaledVector(Ct[4], .858086 * mt * ft),
                lt.addScaledVector(Ct[5], .858086 * ft * xt),
                lt.addScaledVector(Ct[6], .743125 * xt * xt - .247708),
                lt.addScaledVector(Ct[7], .858086 * mt * xt),
                lt.addScaledVector(Ct[8], .429043 * (mt * mt - ft * ft)),
                lt
            }
            add(tt) {
                for (let lt = 0; lt < 9; lt++)
                    this.coefficients[lt].add(tt.coefficients[lt]);
                return this
            }
            addScaledSH(tt, lt) {
                for (let mt = 0; mt < 9; mt++)
                    this.coefficients[mt].addScaledVector(tt.coefficients[mt], lt);
                return this
            }
            scale(tt) {
                for (let lt = 0; lt < 9; lt++)
                    this.coefficients[lt].multiplyScalar(tt);
                return this
            }
            lerp(tt, lt) {
                for (let mt = 0; mt < 9; mt++)
                    this.coefficients[mt].lerp(tt.coefficients[mt], lt);
                return this
            }
            equals(tt) {
                for (let lt = 0; lt < 9; lt++)
                    if (!this.coefficients[lt].equals(tt.coefficients[lt]))
                        return !1;
                return !0
            }
            copy(tt) {
                return this.set(tt.coefficients)
            }
            clone() {
                return new this.constructor().copy(this)
            }
            fromArray(tt, lt=0) {
                const mt = this.coefficients;
                for (let ft = 0; ft < 9; ft++)
                    mt[ft].fromArray(tt, lt + 3 * ft);
                return this
            }
            toArray(tt=[], lt=0) {
                const mt = this.coefficients;
                for (let ft = 0; ft < 9; ft++)
                    mt[ft].toArray(tt, lt + 3 * ft);
                return tt
            }
            static getBasisAt(tt, lt) {
                const mt = tt.x
                  , ft = tt.y
                  , xt = tt.z;
                lt[0] = .282095,
                lt[1] = .488603 * ft,
                lt[2] = .488603 * xt,
                lt[3] = .488603 * mt,
                lt[4] = 1.092548 * mt * ft,
                lt[5] = 1.092548 * ft * xt,
                lt[6] = .315392 * (3 * xt * xt - 1),
                lt[7] = 1.092548 * mt * xt,
                lt[8] = .546274 * (mt * mt - ft * ft)
            }
        }
        class LA extends rp {
            constructor(tt=new BA, lt=1) {
                super(void 0, lt),
                this.isLightProbe = !0,
                this.sh = tt
            }
            copy(tt) {
                return super.copy(tt),
                this.sh.copy(tt.sh),
                this
            }
            fromJSON(tt) {
                return this.intensity = tt.intensity,
                this.sh.fromArray(tt.sh),
                this
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.object.sh = this.sh.toArray(),
                lt
            }
        }
        class l0 extends $s {
            constructor(tt) {
                super(tt),
                this.textures = {}
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(xt.manager);
                Ct.setPath(xt.path),
                Ct.setRequestHeader(xt.requestHeader),
                Ct.setWithCredentials(xt.withCredentials),
                Ct.load(tt, function(Mt) {
                    try {
                        lt(xt.parse(JSON.parse(Mt)))
                    } catch (Lt) {
                        ft ? ft(Lt) : console.error(Lt),
                        xt.manager.itemError(tt)
                    }
                }, mt, ft)
            }
            parse(tt) {
                const lt = this.textures;
                function mt(Ct) {
                    return lt[Ct] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", Ct),
                    lt[Ct]
                }
                const ft = tt.metadata && tt.metadata.version <= 4.5 ? Xo : void 0
                  , xt = l0.createMaterialFromType(tt.type);
                if (tt.uuid !== void 0 && (xt.uuid = tt.uuid),
                tt.name !== void 0 && (xt.name = tt.name),
                tt.color !== void 0 && xt.color !== void 0 && xt.color.setHex(tt.color, ft),
                tt.roughness !== void 0 && (xt.roughness = tt.roughness),
                tt.metalness !== void 0 && (xt.metalness = tt.metalness),
                tt.sheen !== void 0 && (xt.sheen = tt.sheen),
                tt.sheenColor !== void 0 && (xt.sheenColor = new Gn().setHex(tt.sheenColor, ft)),
                tt.sheenRoughness !== void 0 && (xt.sheenRoughness = tt.sheenRoughness),
                tt.emissive !== void 0 && xt.emissive !== void 0 && xt.emissive.setHex(tt.emissive, ft),
                tt.specular !== void 0 && xt.specular !== void 0 && xt.specular.setHex(tt.specular, ft),
                tt.specularIntensity !== void 0 && (xt.specularIntensity = tt.specularIntensity),
                tt.specularColor !== void 0 && xt.specularColor !== void 0 && xt.specularColor.setHex(tt.specularColor, ft),
                tt.shininess !== void 0 && (xt.shininess = tt.shininess),
                tt.clearcoat !== void 0 && (xt.clearcoat = tt.clearcoat),
                tt.clearcoatRoughness !== void 0 && (xt.clearcoatRoughness = tt.clearcoatRoughness),
                tt.iridescence !== void 0 && (xt.iridescence = tt.iridescence),
                tt.iridescenceIOR !== void 0 && (xt.iridescenceIOR = tt.iridescenceIOR),
                tt.iridescenceThicknessRange !== void 0 && (xt.iridescenceThicknessRange = tt.iridescenceThicknessRange),
                tt.transmission !== void 0 && (xt.transmission = tt.transmission),
                tt.thickness !== void 0 && (xt.thickness = tt.thickness),
                tt.attenuationDistance !== void 0 && (xt.attenuationDistance = tt.attenuationDistance),
                tt.attenuationColor !== void 0 && xt.attenuationColor !== void 0 && xt.attenuationColor.setHex(tt.attenuationColor, ft),
                tt.anisotropy !== void 0 && (xt.anisotropy = tt.anisotropy),
                tt.anisotropyRotation !== void 0 && (xt.anisotropyRotation = tt.anisotropyRotation),
                tt.fog !== void 0 && (xt.fog = tt.fog),
                tt.flatShading !== void 0 && (xt.flatShading = tt.flatShading),
                tt.blending !== void 0 && (xt.blending = tt.blending),
                tt.combine !== void 0 && (xt.combine = tt.combine),
                tt.side !== void 0 && (xt.side = tt.side),
                tt.shadowSide !== void 0 && (xt.shadowSide = tt.shadowSide),
                tt.opacity !== void 0 && (xt.opacity = tt.opacity),
                tt.transparent !== void 0 && (xt.transparent = tt.transparent),
                tt.alphaTest !== void 0 && (xt.alphaTest = tt.alphaTest),
                tt.alphaHash !== void 0 && (xt.alphaHash = tt.alphaHash),
                tt.depthTest !== void 0 && (xt.depthTest = tt.depthTest),
                tt.depthWrite !== void 0 && (xt.depthWrite = tt.depthWrite),
                tt.colorWrite !== void 0 && (xt.colorWrite = tt.colorWrite),
                tt.stencilWrite !== void 0 && (xt.stencilWrite = tt.stencilWrite),
                tt.stencilWriteMask !== void 0 && (xt.stencilWriteMask = tt.stencilWriteMask),
                tt.stencilFunc !== void 0 && (xt.stencilFunc = tt.stencilFunc),
                tt.stencilRef !== void 0 && (xt.stencilRef = tt.stencilRef),
                tt.stencilFuncMask !== void 0 && (xt.stencilFuncMask = tt.stencilFuncMask),
                tt.stencilFail !== void 0 && (xt.stencilFail = tt.stencilFail),
                tt.stencilZFail !== void 0 && (xt.stencilZFail = tt.stencilZFail),
                tt.stencilZPass !== void 0 && (xt.stencilZPass = tt.stencilZPass),
                tt.wireframe !== void 0 && (xt.wireframe = tt.wireframe),
                tt.wireframeLinewidth !== void 0 && (xt.wireframeLinewidth = tt.wireframeLinewidth),
                tt.wireframeLinecap !== void 0 && (xt.wireframeLinecap = tt.wireframeLinecap),
                tt.wireframeLinejoin !== void 0 && (xt.wireframeLinejoin = tt.wireframeLinejoin),
                tt.rotation !== void 0 && (xt.rotation = tt.rotation),
                tt.linewidth !== void 0 && (xt.linewidth = tt.linewidth),
                tt.dashSize !== void 0 && (xt.dashSize = tt.dashSize),
                tt.gapSize !== void 0 && (xt.gapSize = tt.gapSize),
                tt.scale !== void 0 && (xt.scale = tt.scale),
                tt.polygonOffset !== void 0 && (xt.polygonOffset = tt.polygonOffset),
                tt.polygonOffsetFactor !== void 0 && (xt.polygonOffsetFactor = tt.polygonOffsetFactor),
                tt.polygonOffsetUnits !== void 0 && (xt.polygonOffsetUnits = tt.polygonOffsetUnits),
                tt.dithering !== void 0 && (xt.dithering = tt.dithering),
                tt.alphaToCoverage !== void 0 && (xt.alphaToCoverage = tt.alphaToCoverage),
                tt.premultipliedAlpha !== void 0 && (xt.premultipliedAlpha = tt.premultipliedAlpha),
                tt.forceSinglePass !== void 0 && (xt.forceSinglePass = tt.forceSinglePass),
                tt.visible !== void 0 && (xt.visible = tt.visible),
                tt.toneMapped !== void 0 && (xt.toneMapped = tt.toneMapped),
                tt.userData !== void 0 && (xt.userData = tt.userData),
                tt.vertexColors !== void 0 && (typeof tt.vertexColors == "number" ? xt.vertexColors = tt.vertexColors > 0 : xt.vertexColors = tt.vertexColors),
                tt.uniforms !== void 0)
                    for (const Ct in tt.uniforms) {
                        const Mt = tt.uniforms[Ct];
                        switch (xt.uniforms[Ct] = {},
                        Mt.type) {
                        case "t":
                            xt.uniforms[Ct].value = mt(Mt.value);
                            break;
                        case "c":
                            xt.uniforms[Ct].value = new Gn().setHex(Mt.value, ft);
                            break;
                        case "v2":
                            xt.uniforms[Ct].value = new mn().fromArray(Mt.value);
                            break;
                        case "v3":
                            xt.uniforms[Ct].value = new Er().fromArray(Mt.value);
                            break;
                        case "v4":
                            xt.uniforms[Ct].value = new Lo().fromArray(Mt.value);
                            break;
                        case "m3":
                            xt.uniforms[Ct].value = new lo().fromArray(Mt.value);
                            break;
                        case "m4":
                            xt.uniforms[Ct].value = new no().fromArray(Mt.value);
                            break;
                        default:
                            xt.uniforms[Ct].value = Mt.value
                        }
                    }
                if (tt.defines !== void 0 && (xt.defines = tt.defines),
                tt.vertexShader !== void 0 && (xt.vertexShader = tt.vertexShader),
                tt.fragmentShader !== void 0 && (xt.fragmentShader = tt.fragmentShader),
                tt.glslVersion !== void 0 && (xt.glslVersion = tt.glslVersion),
                tt.extensions !== void 0)
                    for (const Ct in tt.extensions)
                        xt.extensions[Ct] = tt.extensions[Ct];
                if (tt.lights !== void 0 && (xt.lights = tt.lights),
                tt.clipping !== void 0 && (xt.clipping = tt.clipping),
                tt.size !== void 0 && (xt.size = tt.size),
                tt.sizeAttenuation !== void 0 && (xt.sizeAttenuation = tt.sizeAttenuation),
                tt.map !== void 0 && (xt.map = mt(tt.map)),
                tt.matcap !== void 0 && (xt.matcap = mt(tt.matcap)),
                tt.alphaMap !== void 0 && (xt.alphaMap = mt(tt.alphaMap)),
                tt.bumpMap !== void 0 && (xt.bumpMap = mt(tt.bumpMap)),
                tt.bumpScale !== void 0 && (xt.bumpScale = tt.bumpScale),
                tt.normalMap !== void 0 && (xt.normalMap = mt(tt.normalMap)),
                tt.normalMapType !== void 0 && (xt.normalMapType = tt.normalMapType),
                tt.normalScale !== void 0) {
                    let Ct = tt.normalScale;
                    Array.isArray(Ct) === !1 && (Ct = [Ct, Ct]),
                    xt.normalScale = new mn().fromArray(Ct)
                }
                return tt.displacementMap !== void 0 && (xt.displacementMap = mt(tt.displacementMap)),
                tt.displacementScale !== void 0 && (xt.displacementScale = tt.displacementScale),
                tt.displacementBias !== void 0 && (xt.displacementBias = tt.displacementBias),
                tt.roughnessMap !== void 0 && (xt.roughnessMap = mt(tt.roughnessMap)),
                tt.metalnessMap !== void 0 && (xt.metalnessMap = mt(tt.metalnessMap)),
                tt.emissiveMap !== void 0 && (xt.emissiveMap = mt(tt.emissiveMap)),
                tt.emissiveIntensity !== void 0 && (xt.emissiveIntensity = tt.emissiveIntensity),
                tt.specularMap !== void 0 && (xt.specularMap = mt(tt.specularMap)),
                tt.specularIntensityMap !== void 0 && (xt.specularIntensityMap = mt(tt.specularIntensityMap)),
                tt.specularColorMap !== void 0 && (xt.specularColorMap = mt(tt.specularColorMap)),
                tt.envMap !== void 0 && (xt.envMap = mt(tt.envMap)),
                tt.envMapIntensity !== void 0 && (xt.envMapIntensity = tt.envMapIntensity),
                tt.reflectivity !== void 0 && (xt.reflectivity = tt.reflectivity),
                tt.refractionRatio !== void 0 && (xt.refractionRatio = tt.refractionRatio),
                tt.lightMap !== void 0 && (xt.lightMap = mt(tt.lightMap)),
                tt.lightMapIntensity !== void 0 && (xt.lightMapIntensity = tt.lightMapIntensity),
                tt.aoMap !== void 0 && (xt.aoMap = mt(tt.aoMap)),
                tt.aoMapIntensity !== void 0 && (xt.aoMapIntensity = tt.aoMapIntensity),
                tt.gradientMap !== void 0 && (xt.gradientMap = mt(tt.gradientMap)),
                tt.clearcoatMap !== void 0 && (xt.clearcoatMap = mt(tt.clearcoatMap)),
                tt.clearcoatRoughnessMap !== void 0 && (xt.clearcoatRoughnessMap = mt(tt.clearcoatRoughnessMap)),
                tt.clearcoatNormalMap !== void 0 && (xt.clearcoatNormalMap = mt(tt.clearcoatNormalMap)),
                tt.clearcoatNormalScale !== void 0 && (xt.clearcoatNormalScale = new mn().fromArray(tt.clearcoatNormalScale)),
                tt.iridescenceMap !== void 0 && (xt.iridescenceMap = mt(tt.iridescenceMap)),
                tt.iridescenceThicknessMap !== void 0 && (xt.iridescenceThicknessMap = mt(tt.iridescenceThicknessMap)),
                tt.transmissionMap !== void 0 && (xt.transmissionMap = mt(tt.transmissionMap)),
                tt.thicknessMap !== void 0 && (xt.thicknessMap = mt(tt.thicknessMap)),
                tt.anisotropyMap !== void 0 && (xt.anisotropyMap = mt(tt.anisotropyMap)),
                tt.sheenColorMap !== void 0 && (xt.sheenColorMap = mt(tt.sheenColorMap)),
                tt.sheenRoughnessMap !== void 0 && (xt.sheenRoughnessMap = mt(tt.sheenRoughnessMap)),
                xt
            }
            setTextures(tt) {
                return this.textures = tt,
                this
            }
            static createMaterialFromType(tt) {
                return new {
                    ShadowMaterial: uA,
                    SpriteMaterial: q0,
                    RawShaderMaterial: dA,
                    ShaderMaterial: zl,
                    PointsMaterial: Z0,
                    MeshPhysicalMaterial: pA,
                    MeshStandardMaterial: hy,
                    MeshPhongMaterial: hA,
                    MeshToonMaterial: mA,
                    MeshNormalMaterial: fA,
                    MeshLambertMaterial: gA,
                    MeshDepthMaterial: H0,
                    MeshDistanceMaterial: Q0,
                    MeshBasicMaterial: nu,
                    MeshMatcapMaterial: _A,
                    LineDashedMaterial: vA,
                    LineBasicMaterial: Gs,
                    Material: hs
                }[tt]
            }
        }
        class Ay {
            static decodeText(tt) {
                if (typeof TextDecoder < "u")
                    return new TextDecoder().decode(tt);
                let lt = "";
                for (let mt = 0, ft = tt.length; mt < ft; mt++)
                    lt += String.fromCharCode(tt[mt]);
                try {
                    return decodeURIComponent(escape(lt))
                } catch {
                    return lt
                }
            }
            static extractUrlBase(tt) {
                const lt = tt.lastIndexOf("/");
                return lt === -1 ? "./" : tt.slice(0, lt + 1)
            }
            static resolveURL(tt, lt) {
                return typeof tt != "string" || tt === "" ? "" : (/^https?:\/\//i.test(lt) && /^\//.test(tt) && (lt = lt.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
                /^(https?:)?\/\//i.test(tt) || /^data:.*,.*$/i.test(tt) || /^blob:.*$/i.test(tt) ? tt : lt + tt)
            }
        }
        class OA extends bo {
            constructor() {
                super(),
                this.isInstancedBufferGeometry = !0,
                this.type = "InstancedBufferGeometry",
                this.instanceCount = 1 / 0
            }
            copy(tt) {
                return super.copy(tt),
                this.instanceCount = tt.instanceCount,
                this
            }
            toJSON() {
                const tt = super.toJSON();
                return tt.instanceCount = this.instanceCount,
                tt.isInstancedBufferGeometry = !0,
                tt
            }
        }
        class NA extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(xt.manager);
                Ct.setPath(xt.path),
                Ct.setRequestHeader(xt.requestHeader),
                Ct.setWithCredentials(xt.withCredentials),
                Ct.load(tt, function(Mt) {
                    try {
                        lt(xt.parse(JSON.parse(Mt)))
                    } catch (Lt) {
                        ft ? ft(Lt) : console.error(Lt),
                        xt.manager.itemError(tt)
                    }
                }, mt, ft)
            }
            parse(tt) {
                const lt = {}
                  , mt = {};
                function ft(Wt, Qt) {
                    if (lt[Qt] !== void 0)
                        return lt[Qt];
                    const qt = Wt.interleavedBuffers[Qt]
                      , Xt = function(sr, er) {
                        if (mt[er] !== void 0)
                            return mt[er];
                        const rr = sr.arrayBuffers[er]
                          , xr = new Uint32Array(rr).buffer;
                        return mt[er] = xr,
                        xr
                    }(Wt, qt.buffer)
                      , Zt = vu(qt.type, Xt)
                      , Yt = new Rv(Zt,qt.stride);
                    return Yt.uuid = qt.uuid,
                    lt[Qt] = Yt,
                    Yt
                }
                const xt = tt.isInstancedBufferGeometry ? new OA : new bo
                  , Ct = tt.data.index;
                if (Ct !== void 0) {
                    const Wt = vu(Ct.type, Ct.array);
                    xt.setIndex(new mr(Wt,1))
                }
                const Mt = tt.data.attributes;
                for (const Wt in Mt) {
                    const Qt = Mt[Wt];
                    let qt;
                    if (Qt.isInterleavedBufferAttribute) {
                        const Xt = ft(tt.data, Qt.data);
                        qt = new Cp(Xt,Qt.itemSize,Qt.offset,Qt.normalized)
                    } else {
                        const Xt = vu(Qt.type, Qt.array);
                        qt = new (Qt.isInstancedBufferAttribute ? Mm : mr)(Xt,Qt.itemSize,Qt.normalized)
                    }
                    Qt.name !== void 0 && (qt.name = Qt.name),
                    Qt.usage !== void 0 && qt.setUsage(Qt.usage),
                    Qt.updateRange !== void 0 && (qt.updateRange.offset = Qt.updateRange.offset,
                    qt.updateRange.count = Qt.updateRange.count),
                    xt.setAttribute(Wt, qt)
                }
                const Lt = tt.data.morphAttributes;
                if (Lt)
                    for (const Wt in Lt) {
                        const Qt = Lt[Wt]
                          , qt = [];
                        for (let Xt = 0, Zt = Qt.length; Xt < Zt; Xt++) {
                            const Yt = Qt[Xt];
                            let sr;
                            if (Yt.isInterleavedBufferAttribute) {
                                const er = ft(tt.data, Yt.data);
                                sr = new Cp(er,Yt.itemSize,Yt.offset,Yt.normalized)
                            } else {
                                const er = vu(Yt.type, Yt.array);
                                sr = new mr(er,Yt.itemSize,Yt.normalized)
                            }
                            Yt.name !== void 0 && (sr.name = Yt.name),
                            qt.push(sr)
                        }
                        xt.morphAttributes[Wt] = qt
                    }
                tt.data.morphTargetsRelative && (xt.morphTargetsRelative = !0);
                const Nt = tt.data.groups || tt.data.drawcalls || tt.data.offsets;
                if (Nt !== void 0)
                    for (let Wt = 0, Qt = Nt.length; Wt !== Qt; ++Wt) {
                        const qt = Nt[Wt];
                        xt.addGroup(qt.start, qt.count, qt.materialIndex)
                    }
                const jt = tt.data.boundingSphere;
                if (jt !== void 0) {
                    const Wt = new Er;
                    jt.center !== void 0 && Wt.fromArray(jt.center),
                    xt.boundingSphere = new Ws(Wt,jt.radius)
                }
                return tt.name && (xt.name = tt.name),
                tt.userData && (xt.userData = tt.userData),
                xt
            }
        }
        class DS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = this.path === "" ? Ay.extractUrlBase(tt) : this.path;
                this.resourcePath = this.resourcePath || Ct;
                const Mt = new su(this.manager);
                Mt.setPath(this.path),
                Mt.setRequestHeader(this.requestHeader),
                Mt.setWithCredentials(this.withCredentials),
                Mt.load(tt, function(Lt) {
                    let Nt = null;
                    try {
                        Nt = JSON.parse(Lt)
                    } catch (Wt) {
                        return ft !== void 0 && ft(Wt),
                        void console.error("THREE:ObjectLoader: Can't parse " + tt + ".", Wt.message)
                    }
                    const jt = Nt.metadata;
                    if (jt === void 0 || jt.type === void 0 || jt.type.toLowerCase() === "geometry")
                        return ft !== void 0 && ft(new Error("THREE.ObjectLoader: Can't load " + tt)),
                        void console.error("THREE.ObjectLoader: Can't load " + tt);
                    xt.parse(Nt, lt)
                }, mt, ft)
            }
            async loadAsync(tt, lt) {
                const mt = this.path === "" ? Ay.extractUrlBase(tt) : this.path;
                this.resourcePath = this.resourcePath || mt;
                const ft = new su(this.manager);
                ft.setPath(this.path),
                ft.setRequestHeader(this.requestHeader),
                ft.setWithCredentials(this.withCredentials);
                const xt = await ft.loadAsync(tt, lt)
                  , Ct = JSON.parse(xt)
                  , Mt = Ct.metadata;
                if (Mt === void 0 || Mt.type === void 0 || Mt.type.toLowerCase() === "geometry")
                    throw new Error("THREE.ObjectLoader: Can't load " + tt);
                return await this.parseAsync(Ct)
            }
            parse(tt, lt) {
                const mt = this.parseAnimations(tt.animations)
                  , ft = this.parseShapes(tt.shapes)
                  , xt = this.parseGeometries(tt.geometries, ft)
                  , Ct = this.parseImages(tt.images, function() {
                    lt !== void 0 && lt(Nt)
                })
                  , Mt = this.parseTextures(tt.textures, Ct)
                  , Lt = this.parseMaterials(tt.materials, Mt)
                  , Nt = this.parseObject(tt.object, xt, Lt, Mt, mt)
                  , jt = this.parseSkeletons(tt.skeletons, Nt);
                if (this.bindSkeletons(Nt, jt),
                lt !== void 0) {
                    let Wt = !1;
                    for (const Qt in Ct)
                        if (Ct[Qt].data instanceof HTMLImageElement) {
                            Wt = !0;
                            break
                        }
                    Wt === !1 && lt(Nt)
                }
                return Nt
            }
            async parseAsync(tt) {
                const lt = this.parseAnimations(tt.animations)
                  , mt = this.parseShapes(tt.shapes)
                  , ft = this.parseGeometries(tt.geometries, mt)
                  , xt = await this.parseImagesAsync(tt.images)
                  , Ct = this.parseTextures(tt.textures, xt)
                  , Mt = this.parseMaterials(tt.materials, Ct)
                  , Lt = this.parseObject(tt.object, ft, Mt, Ct, lt)
                  , Nt = this.parseSkeletons(tt.skeletons, Lt);
                return this.bindSkeletons(Lt, Nt),
                Lt
            }
            parseShapes(tt) {
                const lt = {};
                if (tt !== void 0)
                    for (let mt = 0, ft = tt.length; mt < ft; mt++) {
                        const xt = new Pp().fromJSON(tt[mt]);
                        lt[xt.uuid] = xt
                    }
                return lt
            }
            parseSkeletons(tt, lt) {
                const mt = {}
                  , ft = {};
                if (lt.traverse(function(xt) {
                    xt.isBone && (ft[xt.uuid] = xt)
                }),
                tt !== void 0)
                    for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                        const Mt = new Lv().fromJSON(tt[xt], ft);
                        mt[Mt.uuid] = Mt
                    }
                return mt
            }
            parseGeometries(tt, lt) {
                const mt = {};
                if (tt !== void 0) {
                    const ft = new NA;
                    for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                        let Mt;
                        const Lt = tt[xt];
                        switch (Lt.type) {
                        case "BufferGeometry":
                        case "InstancedBufferGeometry":
                            Mt = ft.parse(Lt);
                            break;
                        default:
                            Lt.type in cA ? Mt = cA[Lt.type].fromJSON(Lt, lt) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${Lt.type}"`)
                        }
                        Mt.uuid = Lt.uuid,
                        Lt.name !== void 0 && (Mt.name = Lt.name),
                        Lt.userData !== void 0 && (Mt.userData = Lt.userData),
                        mt[Lt.uuid] = Mt
                    }
                }
                return mt
            }
            parseMaterials(tt, lt) {
                const mt = {}
                  , ft = {};
                if (tt !== void 0) {
                    const xt = new l0;
                    xt.setTextures(lt);
                    for (let Ct = 0, Mt = tt.length; Ct < Mt; Ct++) {
                        const Lt = tt[Ct];
                        mt[Lt.uuid] === void 0 && (mt[Lt.uuid] = xt.parse(Lt)),
                        ft[Lt.uuid] = mt[Lt.uuid]
                    }
                }
                return ft
            }
            parseAnimations(tt) {
                const lt = {};
                if (tt !== void 0)
                    for (let mt = 0; mt < tt.length; mt++) {
                        const ft = tt[mt]
                          , xt = L_.parse(ft);
                        lt[xt.uuid] = xt
                    }
                return lt
            }
            parseImages(tt, lt) {
                const mt = this
                  , ft = {};
                let xt;
                function Ct(Mt) {
                    if (typeof Mt == "string") {
                        const Lt = Mt;
                        return function(Nt) {
                            return mt.manager.itemStart(Nt),
                            xt.load(Nt, function() {
                                mt.manager.itemEnd(Nt)
                            }, void 0, function() {
                                mt.manager.itemError(Nt),
                                mt.manager.itemEnd(Nt)
                            })
                        }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(Lt) ? Lt : mt.resourcePath + Lt)
                    }
                    return Mt.data ? {
                        data: vu(Mt.type, Mt.data),
                        width: Mt.width,
                        height: Mt.height,
                        complete: !0
                    } : null
                }
                if (tt !== void 0 && tt.length > 0) {
                    const Mt = new vy(lt);
                    xt = new O_(Mt),
                    xt.setCrossOrigin(this.crossOrigin);
                    for (let Lt = 0, Nt = tt.length; Lt < Nt; Lt++) {
                        const jt = tt[Lt]
                          , Wt = jt.url;
                        if (Array.isArray(Wt)) {
                            const Qt = [];
                            for (let qt = 0, Xt = Wt.length; qt < Xt; qt++) {
                                const Zt = Ct(Wt[qt]);
                                Zt !== null && (Zt instanceof HTMLImageElement ? Qt.push(Zt) : Qt.push(new Pm(Zt.data,Zt.width,Zt.height)))
                            }
                            ft[jt.uuid] = new ga(Qt)
                        } else {
                            const Qt = Ct(jt.url);
                            ft[jt.uuid] = new ga(Qt)
                        }
                    }
                }
                return ft
            }
            async parseImagesAsync(tt) {
                const lt = this
                  , mt = {};
                let ft;
                async function xt(Ct) {
                    if (typeof Ct == "string") {
                        const Mt = Ct
                          , Lt = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(Mt) ? Mt : lt.resourcePath + Mt;
                        return await ft.loadAsync(Lt)
                    }
                    return Ct.data ? {
                        data: vu(Ct.type, Ct.data),
                        width: Ct.width,
                        height: Ct.height,
                        complete: !0
                    } : null
                }
                if (tt !== void 0 && tt.length > 0) {
                    ft = new O_(this.manager),
                    ft.setCrossOrigin(this.crossOrigin);
                    for (let Ct = 0, Mt = tt.length; Ct < Mt; Ct++) {
                        const Lt = tt[Ct]
                          , Nt = Lt.url;
                        if (Array.isArray(Nt)) {
                            const jt = [];
                            for (let Wt = 0, Qt = Nt.length; Wt < Qt; Wt++) {
                                const qt = Nt[Wt]
                                  , Xt = await xt(qt);
                                Xt !== null && (Xt instanceof HTMLImageElement ? jt.push(Xt) : jt.push(new Pm(Xt.data,Xt.width,Xt.height)))
                            }
                            mt[Lt.uuid] = new ga(jt)
                        } else {
                            const jt = await xt(Lt.url);
                            mt[Lt.uuid] = new ga(jt)
                        }
                    }
                }
                return mt
            }
            parseTextures(tt, lt) {
                function mt(xt, Ct) {
                    return typeof xt == "number" ? xt : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", xt),
                    Ct[xt])
                }
                const ft = {};
                if (tt !== void 0)
                    for (let xt = 0, Ct = tt.length; xt < Ct; xt++) {
                        const Mt = tt[xt];
                        Mt.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', Mt.uuid),
                        lt[Mt.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", Mt.image);
                        const Lt = lt[Mt.image]
                          , Nt = Lt ? Lt.data : void 0;
                        let jt;
                        Array.isArray(Nt) ? (jt = new f_,
                        Nt.length === 6 && (jt.needsUpdate = !0)) : (jt = Nt && Nt.data ? new Pm : new Ho,
                        Nt && Nt.complete && (jt.needsUpdate = !0)),
                        jt.source = Lt,
                        jt.uuid = Mt.uuid,
                        Mt.name !== void 0 && (jt.name = Mt.name),
                        Mt.mapping !== void 0 && (jt.mapping = mt(Mt.mapping, BS)),
                        Mt.channel !== void 0 && (jt.channel = Mt.channel),
                        Mt.offset !== void 0 && jt.offset.fromArray(Mt.offset),
                        Mt.repeat !== void 0 && jt.repeat.fromArray(Mt.repeat),
                        Mt.center !== void 0 && jt.center.fromArray(Mt.center),
                        Mt.rotation !== void 0 && (jt.rotation = Mt.rotation),
                        Mt.wrap !== void 0 && (jt.wrapS = mt(Mt.wrap[0], FA),
                        jt.wrapT = mt(Mt.wrap[1], FA)),
                        Mt.format !== void 0 && (jt.format = Mt.format),
                        Mt.internalFormat !== void 0 && (jt.internalFormat = Mt.internalFormat),
                        Mt.type !== void 0 && (jt.type = Mt.type),
                        Mt.colorSpace !== void 0 ? jt.colorSpace = Mt.colorSpace : Mt.encoding !== void 0 && (jt.encoding = Mt.encoding),
                        Mt.minFilter !== void 0 && (jt.minFilter = mt(Mt.minFilter, UA)),
                        Mt.magFilter !== void 0 && (jt.magFilter = mt(Mt.magFilter, UA)),
                        Mt.anisotropy !== void 0 && (jt.anisotropy = Mt.anisotropy),
                        Mt.flipY !== void 0 && (jt.flipY = Mt.flipY),
                        Mt.generateMipmaps !== void 0 && (jt.generateMipmaps = Mt.generateMipmaps),
                        Mt.premultiplyAlpha !== void 0 && (jt.premultiplyAlpha = Mt.premultiplyAlpha),
                        Mt.unpackAlignment !== void 0 && (jt.unpackAlignment = Mt.unpackAlignment),
                        Mt.compareFunction !== void 0 && (jt.compareFunction = Mt.compareFunction),
                        Mt.userData !== void 0 && (jt.userData = Mt.userData),
                        ft[Mt.uuid] = jt
                    }
                return ft
            }
            parseObject(tt, lt, mt, ft, xt) {
                let Ct;
                const Mt = tt.metadata && tt.metadata.version <= 4.5 ? Xo : void 0;
                function Lt(qt) {
                    return lt[qt] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", qt),
                    lt[qt]
                }
                function Nt(qt) {
                    if (qt !== void 0) {
                        if (Array.isArray(qt)) {
                            const Xt = [];
                            for (let Zt = 0, Yt = qt.length; Zt < Yt; Zt++) {
                                const sr = qt[Zt];
                                mt[sr] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", sr),
                                Xt.push(mt[sr])
                            }
                            return Xt
                        }
                        return mt[qt] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", qt),
                        mt[qt]
                    }
                }
                function jt(qt) {
                    return ft[qt] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", qt),
                    ft[qt]
                }
                let Wt, Qt;
                switch (tt.type) {
                case "Scene":
                    Ct = new Ax,
                    tt.background !== void 0 && (Number.isInteger(tt.background) ? Ct.background = new Gn().setHex(tt.background, Mt) : Ct.background = jt(tt.background)),
                    tt.environment !== void 0 && (Ct.environment = jt(tt.environment)),
                    tt.fog !== void 0 && (tt.fog.type === "Fog" ? Ct.fog = new Mv(tt.fog.color,tt.fog.near,tt.fog.far) : tt.fog.type === "FogExp2" && (Ct.fog = new Pv(tt.fog.color,tt.fog.density)),
                    tt.fog.name !== "" && (Ct.fog.name = tt.fog.name)),
                    tt.backgroundBlurriness !== void 0 && (Ct.backgroundBlurriness = tt.backgroundBlurriness),
                    tt.backgroundIntensity !== void 0 && (Ct.backgroundIntensity = tt.backgroundIntensity);
                    break;
                case "PerspectiveCamera":
                    Ct = new Cs(tt.fov,tt.aspect,tt.near,tt.far),
                    tt.focus !== void 0 && (Ct.focus = tt.focus),
                    tt.zoom !== void 0 && (Ct.zoom = tt.zoom),
                    tt.filmGauge !== void 0 && (Ct.filmGauge = tt.filmGauge),
                    tt.filmOffset !== void 0 && (Ct.filmOffset = tt.filmOffset),
                    tt.view !== void 0 && (Ct.view = Object.assign({}, tt.view));
                    break;
                case "OrthographicCamera":
                    Ct = new Sv(tt.left,tt.right,tt.top,tt.bottom,tt.near,tt.far),
                    tt.zoom !== void 0 && (Ct.zoom = tt.zoom),
                    tt.view !== void 0 && (Ct.view = Object.assign({}, tt.view));
                    break;
                case "AmbientLight":
                    Ct = new kA(tt.color,tt.intensity);
                    break;
                case "DirectionalLight":
                    Ct = new IA(tt.color,tt.intensity);
                    break;
                case "PointLight":
                    Ct = new RA(tt.color,tt.intensity,tt.distance,tt.decay);
                    break;
                case "RectAreaLight":
                    Ct = new DA(tt.color,tt.intensity,tt.width,tt.height);
                    break;
                case "SpotLight":
                    Ct = new PA(tt.color,tt.intensity,tt.distance,tt.angle,tt.penumbra,tt.decay);
                    break;
                case "HemisphereLight":
                    Ct = new EA(tt.color,tt.groundColor,tt.intensity);
                    break;
                case "LightProbe":
                    Ct = new LA().fromJSON(tt);
                    break;
                case "SkinnedMesh":
                    Wt = Lt(tt.geometry),
                    Qt = Nt(tt.material),
                    Ct = new Bx(Wt,Qt),
                    tt.bindMode !== void 0 && (Ct.bindMode = tt.bindMode),
                    tt.bindMatrix !== void 0 && Ct.bindMatrix.fromArray(tt.bindMatrix),
                    tt.skeleton !== void 0 && (Ct.skeleton = tt.skeleton);
                    break;
                case "Mesh":
                    Wt = Lt(tt.geometry),
                    Qt = Nt(tt.material),
                    Ct = new gs(Wt,Qt);
                    break;
                case "InstancedMesh":
                    Wt = Lt(tt.geometry),
                    Qt = Nt(tt.material);
                    const qt = tt.count
                      , Xt = tt.instanceMatrix
                      , Zt = tt.instanceColor;
                    Ct = new Fx(Wt,Qt,qt),
                    Ct.instanceMatrix = new Mm(new Float32Array(Xt.array),16),
                    Zt !== void 0 && (Ct.instanceColor = new Mm(new Float32Array(Zt.array),Zt.itemSize));
                    break;
                case "LOD":
                    Ct = new Px;
                    break;
                case "Line":
                    Ct = new ep(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "LineLoop":
                    Ct = new Hx(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "LineSegments":
                    Ct = new iu(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "PointCloud":
                case "Points":
                    Ct = new Wx(Lt(tt.geometry),Nt(tt.material));
                    break;
                case "Sprite":
                    Ct = new Tx(Nt(tt.material));
                    break;
                case "Group":
                    Ct = new Am;
                    break;
                case "Bone":
                    Ct = new K0;
                    break;
                default:
                    Ct = new Mo
                }
                if (Ct.uuid = tt.uuid,
                tt.name !== void 0 && (Ct.name = tt.name),
                tt.matrix !== void 0 ? (Ct.matrix.fromArray(tt.matrix),
                tt.matrixAutoUpdate !== void 0 && (Ct.matrixAutoUpdate = tt.matrixAutoUpdate),
                Ct.matrixAutoUpdate && Ct.matrix.decompose(Ct.position, Ct.quaternion, Ct.scale)) : (tt.position !== void 0 && Ct.position.fromArray(tt.position),
                tt.rotation !== void 0 && Ct.rotation.fromArray(tt.rotation),
                tt.quaternion !== void 0 && Ct.quaternion.fromArray(tt.quaternion),
                tt.scale !== void 0 && Ct.scale.fromArray(tt.scale)),
                tt.up !== void 0 && Ct.up.fromArray(tt.up),
                tt.castShadow !== void 0 && (Ct.castShadow = tt.castShadow),
                tt.receiveShadow !== void 0 && (Ct.receiveShadow = tt.receiveShadow),
                tt.shadow && (tt.shadow.bias !== void 0 && (Ct.shadow.bias = tt.shadow.bias),
                tt.shadow.normalBias !== void 0 && (Ct.shadow.normalBias = tt.shadow.normalBias),
                tt.shadow.radius !== void 0 && (Ct.shadow.radius = tt.shadow.radius),
                tt.shadow.mapSize !== void 0 && Ct.shadow.mapSize.fromArray(tt.shadow.mapSize),
                tt.shadow.camera !== void 0 && (Ct.shadow.camera = this.parseObject(tt.shadow.camera))),
                tt.visible !== void 0 && (Ct.visible = tt.visible),
                tt.frustumCulled !== void 0 && (Ct.frustumCulled = tt.frustumCulled),
                tt.renderOrder !== void 0 && (Ct.renderOrder = tt.renderOrder),
                tt.userData !== void 0 && (Ct.userData = tt.userData),
                tt.layers !== void 0 && (Ct.layers.mask = tt.layers),
                tt.children !== void 0) {
                    const qt = tt.children;
                    for (let Xt = 0; Xt < qt.length; Xt++)
                        Ct.add(this.parseObject(qt[Xt], lt, mt, ft, xt))
                }
                if (tt.animations !== void 0) {
                    const qt = tt.animations;
                    for (let Xt = 0; Xt < qt.length; Xt++) {
                        const Zt = qt[Xt];
                        Ct.animations.push(xt[Zt])
                    }
                }
                if (tt.type === "LOD") {
                    tt.autoUpdate !== void 0 && (Ct.autoUpdate = tt.autoUpdate);
                    const qt = tt.levels;
                    for (let Xt = 0; Xt < qt.length; Xt++) {
                        const Zt = qt[Xt]
                          , Yt = Ct.getObjectByProperty("uuid", Zt.object);
                        Yt !== void 0 && Ct.addLevel(Yt, Zt.distance, Zt.hysteresis)
                    }
                }
                return Ct
            }
            bindSkeletons(tt, lt) {
                Object.keys(lt).length !== 0 && tt.traverse(function(mt) {
                    if (mt.isSkinnedMesh === !0 && mt.skeleton !== void 0) {
                        const ft = lt[mt.skeleton];
                        ft === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", mt.skeleton) : mt.bind(ft, mt.bindMatrix)
                    }
                })
            }
        }
        const BS = {
            UVMapping: jr,
            CubeReflectionMapping: Qr,
            CubeRefractionMapping: Or,
            EquirectangularReflectionMapping: qr,
            EquirectangularRefractionMapping: gn,
            CubeUVReflectionMapping: Mn
        }
          , FA = {
            RepeatWrapping: Tn,
            ClampToEdgeWrapping: wn,
            MirroredRepeatWrapping: Cn
        }
          , UA = {
            NearestFilter: fn,
            NearestMipmapNearestFilter: bn,
            NearestMipmapLinearFilter: En,
            LinearFilter: Rn,
            LinearMipmapNearestFilter: Yn,
            LinearMipmapLinearFilter: vo
        };
        class LS extends $s {
            constructor(tt) {
                super(tt),
                this.isImageBitmapLoader = !0,
                typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
                typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
                this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(tt) {
                return this.options = tt,
                this
            }
            load(tt, lt, mt, ft) {
                tt === void 0 && (tt = ""),
                this.path !== void 0 && (tt = this.path + tt),
                tt = this.manager.resolveURL(tt);
                const xt = this;
                Eu.get(tt, "blob").then(Ct => {
                    if (Ct !== void 0)
                        return xt.manager.itemStart(tt),
                        void createImageBitmap(Ct, Object.assign(xt.options, {
                            colorSpaceConversion: "none"
                        })).then(function(Lt) {
                            lt && lt(Lt),
                            xt.manager.itemEnd(tt)
                        }).catch(function(Lt) {
                            ft && ft(Lt),
                            xt.manager.itemError(tt),
                            xt.manager.itemEnd(tt)
                        });
                    const Mt = {};
                    Mt.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
                    Mt.headers = this.requestHeader,
                    fetch(tt, Mt).then(function(Lt) {
                        return Lt.blob()
                    }).then(function(Lt) {
                        return Eu.add(tt, Lt, "blob"),
                        createImageBitmap(Lt, Object.assign(xt.options, {
                            colorSpaceConversion: "none"
                        }))
                    }).then(function(Lt) {
                        lt && lt(Lt),
                        xt.manager.itemEnd(tt)
                    }).catch(function(Lt) {
                        ft && ft(Lt),
                        xt.manager.itemError(tt),
                        xt.manager.itemEnd(tt)
                    }),
                    xt.manager.itemStart(tt)
                }
                )
            }
        }
        let c0;
        class wy {
            static getContext() {
                return c0 === void 0 && (c0 = new (window.AudioContext || window.webkitAudioContext)),
                c0
            }
            static setContext(tt) {
                c0 = tt
            }
        }
        class OS extends $s {
            constructor(tt) {
                super(tt)
            }
            load(tt, lt, mt, ft) {
                const xt = this
                  , Ct = new su(this.manager);
                function Mt(Lt) {
                    ft ? ft(Lt) : console.error(Lt),
                    xt.manager.itemError(tt)
                }
                Ct.setResponseType("arraybuffer"),
                Ct.setPath(this.path),
                Ct.setRequestHeader(this.requestHeader),
                Ct.setWithCredentials(this.withCredentials),
                Ct.load(tt, function(Lt) {
                    try {
                        const Nt = Lt.slice(0);
                        wy.getContext().decodeAudioData(Nt, function(jt) {
                            lt(jt)
                        }, Mt)
                    } catch (Nt) {
                        Mt(Nt)
                    }
                }, mt, ft)
            }
        }
        const jA = new no
          , VA = new no
          , Dp = new no;
        class NS {
            constructor() {
                this.type = "StereoCamera",
                this.aspect = 1,
                this.eyeSep = .064,
                this.cameraL = new Cs,
                this.cameraL.layers.enable(1),
                this.cameraL.matrixAutoUpdate = !1,
                this.cameraR = new Cs,
                this.cameraR.layers.enable(2),
                this.cameraR.matrixAutoUpdate = !1,
                this._cache = {
                    focus: null,
                    fov: null,
                    aspect: null,
                    near: null,
                    far: null,
                    zoom: null,
                    eyeSep: null
                }
            }
            update(tt) {
                const lt = this._cache;
                if (lt.focus !== tt.focus || lt.fov !== tt.fov || lt.aspect !== tt.aspect * this.aspect || lt.near !== tt.near || lt.far !== tt.far || lt.zoom !== tt.zoom || lt.eyeSep !== this.eyeSep) {
                    lt.focus = tt.focus,
                    lt.fov = tt.fov,
                    lt.aspect = tt.aspect * this.aspect,
                    lt.near = tt.near,
                    lt.far = tt.far,
                    lt.zoom = tt.zoom,
                    lt.eyeSep = this.eyeSep,
                    Dp.copy(tt.projectionMatrix);
                    const mt = lt.eyeSep / 2
                      , ft = mt * lt.near / lt.focus
                      , xt = lt.near * Math.tan(Zl * lt.fov * .5) / lt.zoom;
                    let Ct, Mt;
                    VA.elements[12] = -mt,
                    jA.elements[12] = mt,
                    Ct = -xt * lt.aspect + ft,
                    Mt = xt * lt.aspect + ft,
                    Dp.elements[0] = 2 * lt.near / (Mt - Ct),
                    Dp.elements[8] = (Mt + Ct) / (Mt - Ct),
                    this.cameraL.projectionMatrix.copy(Dp),
                    Ct = -xt * lt.aspect - ft,
                    Mt = xt * lt.aspect - ft,
                    Dp.elements[0] = 2 * lt.near / (Mt - Ct),
                    Dp.elements[8] = (Mt + Ct) / (Mt - Ct),
                    this.cameraR.projectionMatrix.copy(Dp)
                }
                this.cameraL.matrixWorld.copy(tt.matrixWorld).multiply(VA),
                this.cameraR.matrixWorld.copy(tt.matrixWorld).multiply(jA)
            }
        }
        class GA {
            constructor(tt=!0) {
                this.autoStart = tt,
                this.startTime = 0,
                this.oldTime = 0,
                this.elapsedTime = 0,
                this.running = !1
            }
            start() {
                this.startTime = zA(),
                this.oldTime = this.startTime,
                this.elapsedTime = 0,
                this.running = !0
            }
            stop() {
                this.getElapsedTime(),
                this.running = !1,
                this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(),
                this.elapsedTime
            }
            getDelta() {
                let tt = 0;
                if (this.autoStart && !this.running)
                    return this.start(),
                    0;
                if (this.running) {
                    const lt = zA();
                    tt = (lt - this.oldTime) / 1e3,
                    this.oldTime = lt,
                    this.elapsedTime += tt
                }
                return tt
            }
        }
        function zA() {
            return (typeof performance > "u" ? Date : performance).now()
        }
        const Bp = new Er
          , HA = new Is
          , FS = new Er
          , Lp = new Er;
        class US extends Mo {
            constructor() {
                super(),
                this.type = "AudioListener",
                this.context = wy.getContext(),
                this.gain = this.context.createGain(),
                this.gain.connect(this.context.destination),
                this.filter = null,
                this.timeDelta = 0,
                this._clock = new GA
            }
            getInput() {
                return this.gain
            }
            removeFilter() {
                return this.filter !== null && (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination),
                this.gain.connect(this.context.destination),
                this.filter = null),
                this
            }
            getFilter() {
                return this.filter
            }
            setFilter(tt) {
                return this.filter !== null ? (this.gain.disconnect(this.filter),
                this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
                this.filter = tt,
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
            }
            getMasterVolume() {
                return this.gain.gain.value
            }
            setMasterVolume(tt) {
                return this.gain.gain.setTargetAtTime(tt, this.context.currentTime, .01),
                this
            }
            updateMatrixWorld(tt) {
                super.updateMatrixWorld(tt);
                const lt = this.context.listener
                  , mt = this.up;
                if (this.timeDelta = this._clock.getDelta(),
                this.matrixWorld.decompose(Bp, HA, FS),
                Lp.set(0, 0, -1).applyQuaternion(HA),
                lt.positionX) {
                    const ft = this.context.currentTime + this.timeDelta;
                    lt.positionX.linearRampToValueAtTime(Bp.x, ft),
                    lt.positionY.linearRampToValueAtTime(Bp.y, ft),
                    lt.positionZ.linearRampToValueAtTime(Bp.z, ft),
                    lt.forwardX.linearRampToValueAtTime(Lp.x, ft),
                    lt.forwardY.linearRampToValueAtTime(Lp.y, ft),
                    lt.forwardZ.linearRampToValueAtTime(Lp.z, ft),
                    lt.upX.linearRampToValueAtTime(mt.x, ft),
                    lt.upY.linearRampToValueAtTime(mt.y, ft),
                    lt.upZ.linearRampToValueAtTime(mt.z, ft)
                } else
                    lt.setPosition(Bp.x, Bp.y, Bp.z),
                    lt.setOrientation(Lp.x, Lp.y, Lp.z, mt.x, mt.y, mt.z)
            }
        }
        class QA extends Mo {
            constructor(tt) {
                super(),
                this.type = "Audio",
                this.listener = tt,
                this.context = tt.context,
                this.gain = this.context.createGain(),
                this.gain.connect(tt.getInput()),
                this.autoplay = !1,
                this.buffer = null,
                this.detune = 0,
                this.loop = !1,
                this.loopStart = 0,
                this.loopEnd = 0,
                this.offset = 0,
                this.duration = void 0,
                this.playbackRate = 1,
                this.isPlaying = !1,
                this.hasPlaybackControl = !0,
                this.source = null,
                this.sourceType = "empty",
                this._startedAt = 0,
                this._progress = 0,
                this._connected = !1,
                this.filters = []
            }
            getOutput() {
                return this.gain
            }
            setNodeSource(tt) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "audioNode",
                this.source = tt,
                this.connect(),
                this
            }
            setMediaElementSource(tt) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaNode",
                this.source = this.context.createMediaElementSource(tt),
                this.connect(),
                this
            }
            setMediaStreamSource(tt) {
                return this.hasPlaybackControl = !1,
                this.sourceType = "mediaStreamNode",
                this.source = this.context.createMediaStreamSource(tt),
                this.connect(),
                this
            }
            setBuffer(tt) {
                return this.buffer = tt,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            }
            play(tt=0) {
                if (this.isPlaying === !0)
                    return void console.warn("THREE.Audio: Audio is already playing.");
                if (this.hasPlaybackControl === !1)
                    return void console.warn("THREE.Audio: this Audio has no playback control.");
                this._startedAt = this.context.currentTime + tt;
                const lt = this.context.createBufferSource();
                return lt.buffer = this.buffer,
                lt.loop = this.loop,
                lt.loopStart = this.loopStart,
                lt.loopEnd = this.loopEnd,
                lt.onended = this.onEnded.bind(this),
                lt.start(this._startedAt, this._progress + this.offset, this.duration),
                this.isPlaying = !0,
                this.source = lt,
                this.setDetune(this.detune),
                this.setPlaybackRate(this.playbackRate),
                this.connect()
            }
            pause() {
                if (this.hasPlaybackControl !== !1)
                    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
                    this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)),
                    this.source.stop(),
                    this.source.onended = null,
                    this.isPlaying = !1),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            stop() {
                if (this.hasPlaybackControl !== !1)
                    return this._progress = 0,
                    this.source !== null && (this.source.stop(),
                    this.source.onended = null),
                    this.isPlaying = !1,
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            connect() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (let tt = 1, lt = this.filters.length; tt < lt; tt++)
                        this.filters[tt - 1].connect(this.filters[tt]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else
                    this.source.connect(this.getOutput());
                return this._connected = !0,
                this
            }
            disconnect() {
                if (this._connected !== !1) {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let tt = 1, lt = this.filters.length; tt < lt; tt++)
                            this.filters[tt - 1].disconnect(this.filters[tt]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else
                        this.source.disconnect(this.getOutput());
                    return this._connected = !1,
                    this
                }
            }
            getFilters() {
                return this.filters
            }
            setFilters(tt) {
                return tt || (tt = []),
                this._connected === !0 ? (this.disconnect(),
                this.filters = tt.slice(),
                this.connect()) : this.filters = tt.slice(),
                this
            }
            setDetune(tt) {
                if (this.detune = tt,
                this.source.detune !== void 0)
                    return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                    this
            }
            getDetune() {
                return this.detune
            }
            getFilter() {
                return this.getFilters()[0]
            }
            setFilter(tt) {
                return this.setFilters(tt ? [tt] : [])
            }
            setPlaybackRate(tt) {
                if (this.hasPlaybackControl !== !1)
                    return this.playbackRate = tt,
                    this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            getPlaybackRate() {
                return this.playbackRate
            }
            onEnded() {
                this.isPlaying = !1
            }
            getLoop() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."),
                !1) : this.loop
            }
            setLoop(tt) {
                if (this.hasPlaybackControl !== !1)
                    return this.loop = tt,
                    this.isPlaying === !0 && (this.source.loop = this.loop),
                    this;
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
            setLoopStart(tt) {
                return this.loopStart = tt,
                this
            }
            setLoopEnd(tt) {
                return this.loopEnd = tt,
                this
            }
            getVolume() {
                return this.gain.gain.value
            }
            setVolume(tt) {
                return this.gain.gain.setTargetAtTime(tt, this.context.currentTime, .01),
                this
            }
        }
        const Op = new Er
          , WA = new Is
          , jS = new Er
          , Np = new Er;
        class VS extends QA {
            constructor(tt) {
                super(tt),
                this.panner = this.context.createPanner(),
                this.panner.panningModel = "HRTF",
                this.panner.connect(this.gain)
            }
            connect() {
                super.connect(),
                this.panner.connect(this.gain)
            }
            disconnect() {
                super.disconnect(),
                this.panner.disconnect(this.gain)
            }
            getOutput() {
                return this.panner
            }
            getRefDistance() {
                return this.panner.refDistance
            }
            setRefDistance(tt) {
                return this.panner.refDistance = tt,
                this
            }
            getRolloffFactor() {
                return this.panner.rolloffFactor
            }
            setRolloffFactor(tt) {
                return this.panner.rolloffFactor = tt,
                this
            }
            getDistanceModel() {
                return this.panner.distanceModel
            }
            setDistanceModel(tt) {
                return this.panner.distanceModel = tt,
                this
            }
            getMaxDistance() {
                return this.panner.maxDistance
            }
            setMaxDistance(tt) {
                return this.panner.maxDistance = tt,
                this
            }
            setDirectionalCone(tt, lt, mt) {
                return this.panner.coneInnerAngle = tt,
                this.panner.coneOuterAngle = lt,
                this.panner.coneOuterGain = mt,
                this
            }
            updateMatrixWorld(tt) {
                if (super.updateMatrixWorld(tt),
                this.hasPlaybackControl === !0 && this.isPlaying === !1)
                    return;
                this.matrixWorld.decompose(Op, WA, jS),
                Np.set(0, 0, 1).applyQuaternion(WA);
                const lt = this.panner;
                if (lt.positionX) {
                    const mt = this.context.currentTime + this.listener.timeDelta;
                    lt.positionX.linearRampToValueAtTime(Op.x, mt),
                    lt.positionY.linearRampToValueAtTime(Op.y, mt),
                    lt.positionZ.linearRampToValueAtTime(Op.z, mt),
                    lt.orientationX.linearRampToValueAtTime(Np.x, mt),
                    lt.orientationY.linearRampToValueAtTime(Np.y, mt),
                    lt.orientationZ.linearRampToValueAtTime(Np.z, mt)
                } else
                    lt.setPosition(Op.x, Op.y, Op.z),
                    lt.setOrientation(Np.x, Np.y, Np.z)
            }
        }
        class GS {
            constructor(tt, lt=2048) {
                this.analyser = tt.context.createAnalyser(),
                this.analyser.fftSize = lt,
                this.data = new Uint8Array(this.analyser.frequencyBinCount),
                tt.getOutput().connect(this.analyser)
            }
            getFrequencyData() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            }
            getAverageFrequency() {
                let tt = 0;
                const lt = this.getFrequencyData();
                for (let mt = 0; mt < lt.length; mt++)
                    tt += lt[mt];
                return tt / lt.length
            }
        }
        class qA {
            constructor(tt, lt, mt) {
                let ft, xt, Ct;
                switch (this.binding = tt,
                this.valueSize = mt,
                lt) {
                case "quaternion":
                    ft = this._slerp,
                    xt = this._slerpAdditive,
                    Ct = this._setAdditiveIdentityQuaternion,
                    this.buffer = new Float64Array(6 * mt),
                    this._workIndex = 5;
                    break;
                case "string":
                case "bool":
                    ft = this._select,
                    xt = this._select,
                    Ct = this._setAdditiveIdentityOther,
                    this.buffer = new Array(5 * mt);
                    break;
                default:
                    ft = this._lerp,
                    xt = this._lerpAdditive,
                    Ct = this._setAdditiveIdentityNumeric,
                    this.buffer = new Float64Array(5 * mt)
                }
                this._mixBufferRegion = ft,
                this._mixBufferRegionAdditive = xt,
                this._setIdentity = Ct,
                this._origIndex = 3,
                this._addIndex = 4,
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                this.useCount = 0,
                this.referenceCount = 0
            }
            accumulate(tt, lt) {
                const mt = this.buffer
                  , ft = this.valueSize
                  , xt = tt * ft + ft;
                let Ct = this.cumulativeWeight;
                if (Ct === 0) {
                    for (let Mt = 0; Mt !== ft; ++Mt)
                        mt[xt + Mt] = mt[Mt];
                    Ct = lt
                } else {
                    Ct += lt;
                    const Mt = lt / Ct;
                    this._mixBufferRegion(mt, xt, 0, Mt, ft)
                }
                this.cumulativeWeight = Ct
            }
            accumulateAdditive(tt) {
                const lt = this.buffer
                  , mt = this.valueSize
                  , ft = mt * this._addIndex;
                this.cumulativeWeightAdditive === 0 && this._setIdentity(),
                this._mixBufferRegionAdditive(lt, ft, 0, tt, mt),
                this.cumulativeWeightAdditive += tt
            }
            apply(tt) {
                const lt = this.valueSize
                  , mt = this.buffer
                  , ft = tt * lt + lt
                  , xt = this.cumulativeWeight
                  , Ct = this.cumulativeWeightAdditive
                  , Mt = this.binding;
                if (this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0,
                xt < 1) {
                    const Lt = lt * this._origIndex;
                    this._mixBufferRegion(mt, ft, Lt, 1 - xt, lt)
                }
                Ct > 0 && this._mixBufferRegionAdditive(mt, ft, this._addIndex * lt, 1, lt);
                for (let Lt = lt, Nt = lt + lt; Lt !== Nt; ++Lt)
                    if (mt[Lt] !== mt[Lt + lt]) {
                        Mt.setValue(mt, ft);
                        break
                    }
            }
            saveOriginalState() {
                const tt = this.binding
                  , lt = this.buffer
                  , mt = this.valueSize
                  , ft = mt * this._origIndex;
                tt.getValue(lt, ft);
                for (let xt = mt, Ct = ft; xt !== Ct; ++xt)
                    lt[xt] = lt[ft + xt % mt];
                this._setIdentity(),
                this.cumulativeWeight = 0,
                this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const tt = 3 * this.valueSize;
                this.binding.setValue(this.buffer, tt)
            }
            _setAdditiveIdentityNumeric() {
                const tt = this._addIndex * this.valueSize
                  , lt = tt + this.valueSize;
                for (let mt = tt; mt < lt; mt++)
                    this.buffer[mt] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(),
                this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const tt = this._origIndex * this.valueSize
                  , lt = this._addIndex * this.valueSize;
                for (let mt = 0; mt < this.valueSize; mt++)
                    this.buffer[lt + mt] = this.buffer[tt + mt]
            }
            _select(tt, lt, mt, ft, xt) {
                if (ft >= .5)
                    for (let Ct = 0; Ct !== xt; ++Ct)
                        tt[lt + Ct] = tt[mt + Ct]
            }
            _slerp(tt, lt, mt, ft) {
                Is.slerpFlat(tt, lt, tt, lt, tt, mt, ft)
            }
            _slerpAdditive(tt, lt, mt, ft, xt) {
                const Ct = this._workIndex * xt;
                Is.multiplyQuaternionsFlat(tt, Ct, tt, lt, tt, mt),
                Is.slerpFlat(tt, lt, tt, lt, tt, Ct, ft)
            }
            _lerp(tt, lt, mt, ft, xt) {
                const Ct = 1 - ft;
                for (let Mt = 0; Mt !== xt; ++Mt) {
                    const Lt = lt + Mt;
                    tt[Lt] = tt[Lt] * Ct + tt[mt + Mt] * ft
                }
            }
            _lerpAdditive(tt, lt, mt, ft, xt) {
                for (let Ct = 0; Ct !== xt; ++Ct) {
                    const Mt = lt + Ct;
                    tt[Mt] = tt[Mt] + tt[mt + Ct] * ft
                }
            }
        }
        const Sy = "\\[\\]\\.:\\/"
          , zS = new RegExp("[" + Sy + "]","g")
          , Ey = "[^" + Sy + "]"
          , HS = "[^" + Sy.replace("\\.", "") + "]"
          , QS = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", Ey) + /(WCOD+)?/.source.replace("WCOD", HS) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ey) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ey) + "$")
          , WS = ["material", "materials", "bones", "map"];
        class Ro {
            constructor(tt, lt, mt) {
                this.path = lt,
                this.parsedPath = mt || Ro.parseTrackName(lt),
                this.node = Ro.findNode(tt, this.parsedPath.nodeName),
                this.rootNode = tt,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
            static create(tt, lt, mt) {
                return tt && tt.isAnimationObjectGroup ? new Ro.Composite(tt,lt,mt) : new Ro(tt,lt,mt)
            }
            static sanitizeNodeName(tt) {
                return tt.replace(/\s/g, "_").replace(zS, "")
            }
            static parseTrackName(tt) {
                const lt = QS.exec(tt);
                if (lt === null)
                    throw new Error("PropertyBinding: Cannot parse trackName: " + tt);
                const mt = {
                    nodeName: lt[2],
                    objectName: lt[3],
                    objectIndex: lt[4],
                    propertyName: lt[5],
                    propertyIndex: lt[6]
                }
                  , ft = mt.nodeName && mt.nodeName.lastIndexOf(".");
                if (ft !== void 0 && ft !== -1) {
                    const xt = mt.nodeName.substring(ft + 1);
                    WS.indexOf(xt) !== -1 && (mt.nodeName = mt.nodeName.substring(0, ft),
                    mt.objectName = xt)
                }
                if (mt.propertyName === null || mt.propertyName.length === 0)
                    throw new Error("PropertyBinding: can not parse propertyName from trackName: " + tt);
                return mt
            }
            static findNode(tt, lt) {
                if (lt === void 0 || lt === "" || lt === "." || lt === -1 || lt === tt.name || lt === tt.uuid)
                    return tt;
                if (tt.skeleton) {
                    const mt = tt.skeleton.getBoneByName(lt);
                    if (mt !== void 0)
                        return mt
                }
                if (tt.children) {
                    const mt = function(xt) {
                        for (let Ct = 0; Ct < xt.length; Ct++) {
                            const Mt = xt[Ct];
                            if (Mt.name === lt || Mt.uuid === lt)
                                return Mt;
                            const Lt = mt(Mt.children);
                            if (Lt)
                                return Lt
                        }
                        return null
                    }
                      , ft = mt(tt.children);
                    if (ft)
                        return ft
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(tt, lt) {
                tt[lt] = this.targetObject[this.propertyName]
            }
            _getValue_array(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    tt[lt++] = mt[ft]
            }
            _getValue_arrayElement(tt, lt) {
                tt[lt] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(tt, lt) {
                this.resolvedProperty.toArray(tt, lt)
            }
            _setValue_direct(tt, lt) {
                this.targetObject[this.propertyName] = tt[lt]
            }
            _setValue_direct_setNeedsUpdate(tt, lt) {
                this.targetObject[this.propertyName] = tt[lt],
                this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(tt, lt) {
                this.targetObject[this.propertyName] = tt[lt],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    mt[ft] = tt[lt++]
            }
            _setValue_array_setNeedsUpdate(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    mt[ft] = tt[lt++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(tt, lt) {
                const mt = this.resolvedProperty;
                for (let ft = 0, xt = mt.length; ft !== xt; ++ft)
                    mt[ft] = tt[lt++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(tt, lt) {
                this.resolvedProperty[this.propertyIndex] = tt[lt]
            }
            _setValue_arrayElement_setNeedsUpdate(tt, lt) {
                this.resolvedProperty[this.propertyIndex] = tt[lt],
                this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(tt, lt) {
                this.resolvedProperty[this.propertyIndex] = tt[lt],
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(tt, lt) {
                this.resolvedProperty.fromArray(tt, lt)
            }
            _setValue_fromArray_setNeedsUpdate(tt, lt) {
                this.resolvedProperty.fromArray(tt, lt),
                this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(tt, lt) {
                this.resolvedProperty.fromArray(tt, lt),
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(tt, lt) {
                this.bind(),
                this.getValue(tt, lt)
            }
            _setValue_unbound(tt, lt) {
                this.bind(),
                this.setValue(tt, lt)
            }
            bind() {
                let tt = this.node;
                const lt = this.parsedPath
                  , mt = lt.objectName
                  , ft = lt.propertyName;
                let xt = lt.propertyIndex;
                if (tt || (tt = Ro.findNode(this.rootNode, lt.nodeName),
                this.node = tt),
                this.getValue = this._getValue_unavailable,
                this.setValue = this._setValue_unavailable,
                !tt)
                    return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (mt) {
                    let Nt = lt.objectIndex;
                    switch (mt) {
                    case "materials":
                        if (!tt.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!tt.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        tt = tt.material.materials;
                        break;
                    case "bones":
                        if (!tt.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        tt = tt.skeleton.bones;
                        for (let jt = 0; jt < tt.length; jt++)
                            if (tt[jt].name === Nt) {
                                Nt = jt;
                                break
                            }
                        break;
                    case "map":
                        if ("map"in tt) {
                            tt = tt.map;
                            break
                        }
                        if (!tt.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!tt.material.map)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        tt = tt.material.map;
                        break;
                    default:
                        if (tt[mt] === void 0)
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        tt = tt[mt]
                    }
                    if (Nt !== void 0) {
                        if (tt[Nt] === void 0)
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, tt);
                        tt = tt[Nt]
                    }
                }
                const Ct = tt[ft];
                if (Ct === void 0) {
                    const Nt = lt.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + Nt + "." + ft + " but it wasn't found.", tt)
                }
                let Mt = this.Versioning.None;
                this.targetObject = tt,
                tt.needsUpdate !== void 0 ? Mt = this.Versioning.NeedsUpdate : tt.matrixWorldNeedsUpdate !== void 0 && (Mt = this.Versioning.MatrixWorldNeedsUpdate);
                let Lt = this.BindingType.Direct;
                if (xt !== void 0) {
                    if (ft === "morphTargetInfluences") {
                        if (!tt.geometry)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!tt.geometry.morphAttributes)
                            return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        tt.morphTargetDictionary[xt] !== void 0 && (xt = tt.morphTargetDictionary[xt])
                    }
                    Lt = this.BindingType.ArrayElement,
                    this.resolvedProperty = Ct,
                    this.propertyIndex = xt
                } else
                    Ct.fromArray !== void 0 && Ct.toArray !== void 0 ? (Lt = this.BindingType.HasFromToArray,
                    this.resolvedProperty = Ct) : Array.isArray(Ct) ? (Lt = this.BindingType.EntireArray,
                    this.resolvedProperty = Ct) : this.propertyName = ft;
                this.getValue = this.GetterByBindingType[Lt],
                this.setValue = this.SetterByBindingTypeAndVersioning[Lt][Mt]
            }
            unbind() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }
        Ro.Composite = class {
            constructor(Tt, tt, lt) {
                const mt = lt || Ro.parseTrackName(tt);
                this._targetGroup = Tt,
                this._bindings = Tt.subscribe_(tt, mt)
            }
            getValue(Tt, tt) {
                this.bind();
                const lt = this._targetGroup.nCachedObjects_
                  , mt = this._bindings[lt];
                mt !== void 0 && mt.getValue(Tt, tt)
            }
            setValue(Tt, tt) {
                const lt = this._bindings;
                for (let mt = this._targetGroup.nCachedObjects_, ft = lt.length; mt !== ft; ++mt)
                    lt[mt].setValue(Tt, tt)
            }
            bind() {
                const Tt = this._bindings;
                for (let tt = this._targetGroup.nCachedObjects_, lt = Tt.length; tt !== lt; ++tt)
                    Tt[tt].bind()
            }
            unbind() {
                const Tt = this._bindings;
                for (let tt = this._targetGroup.nCachedObjects_, lt = Tt.length; tt !== lt; ++tt)
                    Tt[tt].unbind()
            }
        }
        ,
        Ro.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Ro.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        Ro.prototype.GetterByBindingType = [Ro.prototype._getValue_direct, Ro.prototype._getValue_array, Ro.prototype._getValue_arrayElement, Ro.prototype._getValue_toArray],
        Ro.prototype.SetterByBindingTypeAndVersioning = [[Ro.prototype._setValue_direct, Ro.prototype._setValue_direct_setNeedsUpdate, Ro.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Ro.prototype._setValue_array, Ro.prototype._setValue_array_setNeedsUpdate, Ro.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Ro.prototype._setValue_arrayElement, Ro.prototype._setValue_arrayElement_setNeedsUpdate, Ro.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Ro.prototype._setValue_fromArray, Ro.prototype._setValue_fromArray_setNeedsUpdate, Ro.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
        class qS {
            constructor() {
                this.isAnimationObjectGroup = !0,
                this.uuid = Ms(),
                this._objects = Array.prototype.slice.call(arguments),
                this.nCachedObjects_ = 0;
                const tt = {};
                this._indicesByUUID = tt;
                for (let mt = 0, ft = arguments.length; mt !== ft; ++mt)
                    tt[arguments[mt].uuid] = mt;
                this._paths = [],
                this._parsedPaths = [],
                this._bindings = [],
                this._bindingsIndicesByPath = {};
                const lt = this;
                this.stats = {
                    objects: {
                        get total() {
                            return lt._objects.length
                        },
                        get inUse() {
                            return this.total - lt.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return lt._bindings.length
                    }
                }
            }
            add() {
                const tt = this._objects
                  , lt = this._indicesByUUID
                  , mt = this._paths
                  , ft = this._parsedPaths
                  , xt = this._bindings
                  , Ct = xt.length;
                let Mt, Lt = tt.length, Nt = this.nCachedObjects_;
                for (let jt = 0, Wt = arguments.length; jt !== Wt; ++jt) {
                    const Qt = arguments[jt]
                      , qt = Qt.uuid;
                    let Xt = lt[qt];
                    if (Xt === void 0) {
                        Xt = Lt++,
                        lt[qt] = Xt,
                        tt.push(Qt);
                        for (let Zt = 0, Yt = Ct; Zt !== Yt; ++Zt)
                            xt[Zt].push(new Ro(Qt,mt[Zt],ft[Zt]))
                    } else if (Xt < Nt) {
                        Mt = tt[Xt];
                        const Zt = --Nt
                          , Yt = tt[Zt];
                        lt[Yt.uuid] = Xt,
                        tt[Xt] = Yt,
                        lt[qt] = Zt,
                        tt[Zt] = Qt;
                        for (let sr = 0, er = Ct; sr !== er; ++sr) {
                            const rr = xt[sr]
                              , xr = rr[Zt];
                            let br = rr[Xt];
                            rr[Xt] = xr,
                            br === void 0 && (br = new Ro(Qt,mt[sr],ft[sr])),
                            rr[Zt] = br
                        }
                    } else
                        tt[Xt] !== Mt && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = Nt
            }
            remove() {
                const tt = this._objects
                  , lt = this._indicesByUUID
                  , mt = this._bindings
                  , ft = mt.length;
                let xt = this.nCachedObjects_;
                for (let Ct = 0, Mt = arguments.length; Ct !== Mt; ++Ct) {
                    const Lt = arguments[Ct]
                      , Nt = Lt.uuid
                      , jt = lt[Nt];
                    if (jt !== void 0 && jt >= xt) {
                        const Wt = xt++
                          , Qt = tt[Wt];
                        lt[Qt.uuid] = jt,
                        tt[jt] = Qt,
                        lt[Nt] = Wt,
                        tt[Wt] = Lt;
                        for (let qt = 0, Xt = ft; qt !== Xt; ++qt) {
                            const Zt = mt[qt]
                              , Yt = Zt[Wt]
                              , sr = Zt[jt];
                            Zt[jt] = Yt,
                            Zt[Wt] = sr
                        }
                    }
                }
                this.nCachedObjects_ = xt
            }
            uncache() {
                const tt = this._objects
                  , lt = this._indicesByUUID
                  , mt = this._bindings
                  , ft = mt.length;
                let xt = this.nCachedObjects_
                  , Ct = tt.length;
                for (let Mt = 0, Lt = arguments.length; Mt !== Lt; ++Mt) {
                    const Nt = arguments[Mt].uuid
                      , jt = lt[Nt];
                    if (jt !== void 0)
                        if (delete lt[Nt],
                        jt < xt) {
                            const Wt = --xt
                              , Qt = tt[Wt]
                              , qt = --Ct
                              , Xt = tt[qt];
                            lt[Qt.uuid] = jt,
                            tt[jt] = Qt,
                            lt[Xt.uuid] = Wt,
                            tt[Wt] = Xt,
                            tt.pop();
                            for (let Zt = 0, Yt = ft; Zt !== Yt; ++Zt) {
                                const sr = mt[Zt]
                                  , er = sr[Wt]
                                  , rr = sr[qt];
                                sr[jt] = er,
                                sr[Wt] = rr,
                                sr.pop()
                            }
                        } else {
                            const Wt = --Ct
                              , Qt = tt[Wt];
                            Wt > 0 && (lt[Qt.uuid] = jt),
                            tt[jt] = Qt,
                            tt.pop();
                            for (let qt = 0, Xt = ft; qt !== Xt; ++qt) {
                                const Zt = mt[qt];
                                Zt[jt] = Zt[Wt],
                                Zt.pop()
                            }
                        }
                }
                this.nCachedObjects_ = xt
            }
            subscribe_(tt, lt) {
                const mt = this._bindingsIndicesByPath;
                let ft = mt[tt];
                const xt = this._bindings;
                if (ft !== void 0)
                    return xt[ft];
                const Ct = this._paths
                  , Mt = this._parsedPaths
                  , Lt = this._objects
                  , Nt = Lt.length
                  , jt = this.nCachedObjects_
                  , Wt = new Array(Nt);
                ft = xt.length,
                mt[tt] = ft,
                Ct.push(tt),
                Mt.push(lt),
                xt.push(Wt);
                for (let Qt = jt, qt = Lt.length; Qt !== qt; ++Qt) {
                    const Xt = Lt[Qt];
                    Wt[Qt] = new Ro(Xt,tt,lt)
                }
                return Wt
            }
            unsubscribe_(tt) {
                const lt = this._bindingsIndicesByPath
                  , mt = lt[tt];
                if (mt !== void 0) {
                    const ft = this._paths
                      , xt = this._parsedPaths
                      , Ct = this._bindings
                      , Mt = Ct.length - 1
                      , Lt = Ct[Mt];
                    lt[tt[Mt]] = mt,
                    Ct[mt] = Lt,
                    Ct.pop(),
                    xt[mt] = xt[Mt],
                    xt.pop(),
                    ft[mt] = ft[Mt],
                    ft.pop()
                }
            }
        }
        class $A {
            constructor(tt, lt, mt=null, ft=lt.blendMode) {
                this._mixer = tt,
                this._clip = lt,
                this._localRoot = mt,
                this.blendMode = ft;
                const xt = lt.tracks
                  , Ct = xt.length
                  , Mt = new Array(Ct)
                  , Lt = {
                    endingStart: du,
                    endingEnd: du
                };
                for (let Nt = 0; Nt !== Ct; ++Nt) {
                    const jt = xt[Nt].createInterpolant(null);
                    Mt[Nt] = jt,
                    jt.settings = Lt
                }
                this._interpolantSettings = Lt,
                this._interpolants = Mt,
                this._propertyBindings = new Array(Ct),
                this._cacheIndex = null,
                this._byClipCacheIndex = null,
                this._timeScaleInterpolant = null,
                this._weightInterpolant = null,
                this.loop = Du,
                this._loopCount = -1,
                this._startTime = null,
                this.time = 0,
                this.timeScale = 1,
                this._effectiveTimeScale = 1,
                this.weight = 1,
                this._effectiveWeight = 1,
                this.repetitions = 1 / 0,
                this.paused = !1,
                this.enabled = !0,
                this.clampWhenFinished = !1,
                this.zeroSlopeAtStart = !0,
                this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this),
                this
            }
            stop() {
                return this._mixer._deactivateAction(this),
                this.reset()
            }
            reset() {
                return this.paused = !1,
                this.enabled = !0,
                this.time = 0,
                this._loopCount = -1,
                this._startTime = null,
                this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(tt) {
                return this._startTime = tt,
                this
            }
            setLoop(tt, lt) {
                return this.loop = tt,
                this.repetitions = lt,
                this
            }
            setEffectiveWeight(tt) {
                return this.weight = tt,
                this._effectiveWeight = this.enabled ? tt : 0,
                this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(tt) {
                return this._scheduleFading(tt, 0, 1)
            }
            fadeOut(tt) {
                return this._scheduleFading(tt, 1, 0)
            }
            crossFadeFrom(tt, lt, mt) {
                if (tt.fadeOut(lt),
                this.fadeIn(lt),
                mt) {
                    const ft = this._clip.duration
                      , xt = tt._clip.duration
                      , Ct = xt / ft
                      , Mt = ft / xt;
                    tt.warp(1, Ct, lt),
                    this.warp(Mt, 1, lt)
                }
                return this
            }
            crossFadeTo(tt, lt, mt) {
                return tt.crossFadeFrom(this, lt, mt)
            }
            stopFading() {
                const tt = this._weightInterpolant;
                return tt !== null && (this._weightInterpolant = null,
                this._mixer._takeBackControlInterpolant(tt)),
                this
            }
            setEffectiveTimeScale(tt) {
                return this.timeScale = tt,
                this._effectiveTimeScale = this.paused ? 0 : tt,
                this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(tt) {
                return this.timeScale = this._clip.duration / tt,
                this.stopWarping()
            }
            syncWith(tt) {
                return this.time = tt.time,
                this.timeScale = tt.timeScale,
                this.stopWarping()
            }
            halt(tt) {
                return this.warp(this._effectiveTimeScale, 0, tt)
            }
            warp(tt, lt, mt) {
                const ft = this._mixer
                  , xt = ft.time
                  , Ct = this.timeScale;
                let Mt = this._timeScaleInterpolant;
                Mt === null && (Mt = ft._lendControlInterpolant(),
                this._timeScaleInterpolant = Mt);
                const Lt = Mt.parameterPositions
                  , Nt = Mt.sampleValues;
                return Lt[0] = xt,
                Lt[1] = xt + mt,
                Nt[0] = tt / Ct,
                Nt[1] = lt / Ct,
                this
            }
            stopWarping() {
                const tt = this._timeScaleInterpolant;
                return tt !== null && (this._timeScaleInterpolant = null,
                this._mixer._takeBackControlInterpolant(tt)),
                this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(tt, lt, mt, ft) {
                if (!this.enabled)
                    return void this._updateWeight(tt);
                const xt = this._startTime;
                if (xt !== null) {
                    const Lt = (tt - xt) * mt;
                    Lt < 0 || mt === 0 ? lt = 0 : (this._startTime = null,
                    lt = mt * Lt)
                }
                lt *= this._updateTimeScale(tt);
                const Ct = this._updateTime(lt)
                  , Mt = this._updateWeight(tt);
                if (Mt > 0) {
                    const Lt = this._interpolants
                      , Nt = this._propertyBindings;
                    if (this.blendMode === Xp)
                        for (let jt = 0, Wt = Lt.length; jt !== Wt; ++jt)
                            Lt[jt].evaluate(Ct),
                            Nt[jt].accumulateAdditive(Mt);
                    else
                        for (let jt = 0, Wt = Lt.length; jt !== Wt; ++jt)
                            Lt[jt].evaluate(Ct),
                            Nt[jt].accumulate(ft, Mt)
                }
            }
            _updateWeight(tt) {
                let lt = 0;
                if (this.enabled) {
                    lt = this.weight;
                    const mt = this._weightInterpolant;
                    if (mt !== null) {
                        const ft = mt.evaluate(tt)[0];
                        lt *= ft,
                        tt > mt.parameterPositions[1] && (this.stopFading(),
                        ft === 0 && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = lt,
                lt
            }
            _updateTimeScale(tt) {
                let lt = 0;
                if (!this.paused) {
                    lt = this.timeScale;
                    const mt = this._timeScaleInterpolant;
                    mt !== null && (lt *= mt.evaluate(tt)[0],
                    tt > mt.parameterPositions[1] && (this.stopWarping(),
                    lt === 0 ? this.paused = !0 : this.timeScale = lt))
                }
                return this._effectiveTimeScale = lt,
                lt
            }
            _updateTime(tt) {
                const lt = this._clip.duration
                  , mt = this.loop;
                let ft = this.time + tt
                  , xt = this._loopCount;
                const Ct = mt === qp;
                if (tt === 0)
                    return xt === -1 || !Ct || 1 & ~xt ? ft : lt - ft;
                if (mt === ku) {
                    xt === -1 && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1));
                    e: {
                        if (ft >= lt)
                            ft = lt;
                        else {
                            if (!(ft < 0)) {
                                this.time = ft;
                                break e
                            }
                            ft = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = ft,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: tt < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (xt === -1 && (tt >= 0 ? (xt = 0,
                    this._setEndings(!0, this.repetitions === 0, Ct)) : this._setEndings(this.repetitions === 0, !0, Ct)),
                    ft >= lt || ft < 0) {
                        const Mt = Math.floor(ft / lt);
                        ft -= lt * Mt,
                        xt += Math.abs(Mt);
                        const Lt = this.repetitions - xt;
                        if (Lt <= 0)
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            ft = tt > 0 ? lt : 0,
                            this.time = ft,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: tt > 0 ? 1 : -1
                            });
                        else {
                            if (Lt === 1) {
                                const Nt = tt < 0;
                                this._setEndings(Nt, !Nt, Ct)
                            } else
                                this._setEndings(!1, !1, Ct);
                            this._loopCount = xt,
                            this.time = ft,
                            this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: Mt
                            })
                        }
                    } else
                        this.time = ft;
                    if (Ct && !(1 & ~xt))
                        return lt - ft
                }
                return ft
            }
            _setEndings(tt, lt, mt) {
                const ft = this._interpolantSettings;
                mt ? (ft.endingStart = pu,
                ft.endingEnd = pu) : (ft.endingStart = tt ? this.zeroSlopeAtStart ? pu : du : cp,
                ft.endingEnd = lt ? this.zeroSlopeAtEnd ? pu : du : cp)
            }
            _scheduleFading(tt, lt, mt) {
                const ft = this._mixer
                  , xt = ft.time;
                let Ct = this._weightInterpolant;
                Ct === null && (Ct = ft._lendControlInterpolant(),
                this._weightInterpolant = Ct);
                const Mt = Ct.parameterPositions
                  , Lt = Ct.sampleValues;
                return Mt[0] = xt,
                Lt[0] = lt,
                Mt[1] = xt + tt,
                Lt[1] = mt,
                this
            }
        }
        const $S = new Float32Array(1);
        class XS extends As {
            constructor(tt) {
                super(),
                this._root = tt,
                this._initMemoryManager(),
                this._accuIndex = 0,
                this.time = 0,
                this.timeScale = 1
            }
            _bindAction(tt, lt) {
                const mt = tt._localRoot || this._root
                  , ft = tt._clip.tracks
                  , xt = ft.length
                  , Ct = tt._propertyBindings
                  , Mt = tt._interpolants
                  , Lt = mt.uuid
                  , Nt = this._bindingsByRootAndName;
                let jt = Nt[Lt];
                jt === void 0 && (jt = {},
                Nt[Lt] = jt);
                for (let Wt = 0; Wt !== xt; ++Wt) {
                    const Qt = ft[Wt]
                      , qt = Qt.name;
                    let Xt = jt[qt];
                    if (Xt !== void 0)
                        ++Xt.referenceCount,
                        Ct[Wt] = Xt;
                    else {
                        if (Xt = Ct[Wt],
                        Xt !== void 0) {
                            Xt._cacheIndex === null && (++Xt.referenceCount,
                            this._addInactiveBinding(Xt, Lt, qt));
                            continue
                        }
                        const Zt = lt && lt._propertyBindings[Wt].binding.parsedPath;
                        Xt = new qA(Ro.create(mt, qt, Zt),Qt.ValueTypeName,Qt.getValueSize()),
                        ++Xt.referenceCount,
                        this._addInactiveBinding(Xt, Lt, qt),
                        Ct[Wt] = Xt
                    }
                    Mt[Wt].resultBuffer = Xt.buffer
                }
            }
            _activateAction(tt) {
                if (!this._isActiveAction(tt)) {
                    if (tt._cacheIndex === null) {
                        const mt = (tt._localRoot || this._root).uuid
                          , ft = tt._clip.uuid
                          , xt = this._actionsByClip[ft];
                        this._bindAction(tt, xt && xt.knownActions[0]),
                        this._addInactiveAction(tt, ft, mt)
                    }
                    const lt = tt._propertyBindings;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt) {
                        const xt = lt[mt];
                        xt.useCount++ == 0 && (this._lendBinding(xt),
                        xt.saveOriginalState())
                    }
                    this._lendAction(tt)
                }
            }
            _deactivateAction(tt) {
                if (this._isActiveAction(tt)) {
                    const lt = tt._propertyBindings;
                    for (let mt = 0, ft = lt.length; mt !== ft; ++mt) {
                        const xt = lt[mt];
                        --xt.useCount == 0 && (xt.restoreOriginalState(),
                        this._takeBackBinding(xt))
                    }
                    this._takeBackAction(tt)
                }
            }
            _initMemoryManager() {
                this._actions = [],
                this._nActiveActions = 0,
                this._actionsByClip = {},
                this._bindings = [],
                this._nActiveBindings = 0,
                this._bindingsByRootAndName = {},
                this._controlInterpolants = [],
                this._nActiveControlInterpolants = 0;
                const tt = this;
                this.stats = {
                    actions: {
                        get total() {
                            return tt._actions.length
                        },
                        get inUse() {
                            return tt._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return tt._bindings.length
                        },
                        get inUse() {
                            return tt._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return tt._controlInterpolants.length
                        },
                        get inUse() {
                            return tt._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(tt) {
                const lt = tt._cacheIndex;
                return lt !== null && lt < this._nActiveActions
            }
            _addInactiveAction(tt, lt, mt) {
                const ft = this._actions
                  , xt = this._actionsByClip;
                let Ct = xt[lt];
                if (Ct === void 0)
                    Ct = {
                        knownActions: [tt],
                        actionByRoot: {}
                    },
                    tt._byClipCacheIndex = 0,
                    xt[lt] = Ct;
                else {
                    const Mt = Ct.knownActions;
                    tt._byClipCacheIndex = Mt.length,
                    Mt.push(tt)
                }
                tt._cacheIndex = ft.length,
                ft.push(tt),
                Ct.actionByRoot[mt] = tt
            }
            _removeInactiveAction(tt) {
                const lt = this._actions
                  , mt = lt[lt.length - 1]
                  , ft = tt._cacheIndex;
                mt._cacheIndex = ft,
                lt[ft] = mt,
                lt.pop(),
                tt._cacheIndex = null;
                const xt = tt._clip.uuid
                  , Ct = this._actionsByClip
                  , Mt = Ct[xt]
                  , Lt = Mt.knownActions
                  , Nt = Lt[Lt.length - 1]
                  , jt = tt._byClipCacheIndex;
                Nt._byClipCacheIndex = jt,
                Lt[jt] = Nt,
                Lt.pop(),
                tt._byClipCacheIndex = null,
                delete Mt.actionByRoot[(tt._localRoot || this._root).uuid],
                Lt.length === 0 && delete Ct[xt],
                this._removeInactiveBindingsForAction(tt)
            }
            _removeInactiveBindingsForAction(tt) {
                const lt = tt._propertyBindings;
                for (let mt = 0, ft = lt.length; mt !== ft; ++mt) {
                    const xt = lt[mt];
                    --xt.referenceCount == 0 && this._removeInactiveBinding(xt)
                }
            }
            _lendAction(tt) {
                const lt = this._actions
                  , mt = tt._cacheIndex
                  , ft = this._nActiveActions++
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _takeBackAction(tt) {
                const lt = this._actions
                  , mt = tt._cacheIndex
                  , ft = --this._nActiveActions
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _addInactiveBinding(tt, lt, mt) {
                const ft = this._bindingsByRootAndName
                  , xt = this._bindings;
                let Ct = ft[lt];
                Ct === void 0 && (Ct = {},
                ft[lt] = Ct),
                Ct[mt] = tt,
                tt._cacheIndex = xt.length,
                xt.push(tt)
            }
            _removeInactiveBinding(tt) {
                const lt = this._bindings
                  , mt = tt.binding
                  , ft = mt.rootNode.uuid
                  , xt = mt.path
                  , Ct = this._bindingsByRootAndName
                  , Mt = Ct[ft]
                  , Lt = lt[lt.length - 1]
                  , Nt = tt._cacheIndex;
                Lt._cacheIndex = Nt,
                lt[Nt] = Lt,
                lt.pop(),
                delete Mt[xt],
                Object.keys(Mt).length === 0 && delete Ct[ft]
            }
            _lendBinding(tt) {
                const lt = this._bindings
                  , mt = tt._cacheIndex
                  , ft = this._nActiveBindings++
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _takeBackBinding(tt) {
                const lt = this._bindings
                  , mt = tt._cacheIndex
                  , ft = --this._nActiveBindings
                  , xt = lt[ft];
                tt._cacheIndex = ft,
                lt[ft] = tt,
                xt._cacheIndex = mt,
                lt[mt] = xt
            }
            _lendControlInterpolant() {
                const tt = this._controlInterpolants
                  , lt = this._nActiveControlInterpolants++;
                let mt = tt[lt];
                return mt === void 0 && (mt = new gy(new Float32Array(2),new Float32Array(2),1,$S),
                mt.__cacheIndex = lt,
                tt[lt] = mt),
                mt
            }
            _takeBackControlInterpolant(tt) {
                const lt = this._controlInterpolants
                  , mt = tt.__cacheIndex
                  , ft = --this._nActiveControlInterpolants
                  , xt = lt[ft];
                tt.__cacheIndex = ft,
                lt[ft] = tt,
                xt.__cacheIndex = mt,
                lt[mt] = xt
            }
            clipAction(tt, lt, mt) {
                const ft = lt || this._root
                  , xt = ft.uuid;
                let Ct = typeof tt == "string" ? L_.findByName(ft, tt) : tt;
                const Mt = Ct !== null ? Ct.uuid : tt
                  , Lt = this._actionsByClip[Mt];
                let Nt = null;
                if (mt === void 0 && (mt = Ct !== null ? Ct.blendMode : Hm),
                Lt !== void 0) {
                    const Wt = Lt.actionByRoot[xt];
                    if (Wt !== void 0 && Wt.blendMode === mt)
                        return Wt;
                    Nt = Lt.knownActions[0],
                    Ct === null && (Ct = Nt._clip)
                }
                if (Ct === null)
                    return null;
                const jt = new $A(this,Ct,lt,mt);
                return this._bindAction(jt, Nt),
                this._addInactiveAction(jt, Mt, xt),
                jt
            }
            existingAction(tt, lt) {
                const mt = lt || this._root
                  , ft = mt.uuid
                  , xt = typeof tt == "string" ? L_.findByName(mt, tt) : tt
                  , Ct = xt ? xt.uuid : tt
                  , Mt = this._actionsByClip[Ct];
                return Mt !== void 0 && Mt.actionByRoot[ft] || null
            }
            stopAllAction() {
                const tt = this._actions;
                for (let lt = this._nActiveActions - 1; lt >= 0; --lt)
                    tt[lt].stop();
                return this
            }
            update(tt) {
                tt *= this.timeScale;
                const lt = this._actions
                  , mt = this._nActiveActions
                  , ft = this.time += tt
                  , xt = Math.sign(tt)
                  , Ct = this._accuIndex ^= 1;
                for (let Nt = 0; Nt !== mt; ++Nt)
                    lt[Nt]._update(ft, tt, xt, Ct);
                const Mt = this._bindings
                  , Lt = this._nActiveBindings;
                for (let Nt = 0; Nt !== Lt; ++Nt)
                    Mt[Nt].apply(Ct);
                return this
            }
            setTime(tt) {
                this.time = 0;
                for (let lt = 0; lt < this._actions.length; lt++)
                    this._actions[lt].time = 0;
                return this.update(tt)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(tt) {
                const lt = this._actions
                  , mt = tt.uuid
                  , ft = this._actionsByClip
                  , xt = ft[mt];
                if (xt !== void 0) {
                    const Ct = xt.knownActions;
                    for (let Mt = 0, Lt = Ct.length; Mt !== Lt; ++Mt) {
                        const Nt = Ct[Mt];
                        this._deactivateAction(Nt);
                        const jt = Nt._cacheIndex
                          , Wt = lt[lt.length - 1];
                        Nt._cacheIndex = null,
                        Nt._byClipCacheIndex = null,
                        Wt._cacheIndex = jt,
                        lt[jt] = Wt,
                        lt.pop(),
                        this._removeInactiveBindingsForAction(Nt)
                    }
                    delete ft[mt]
                }
            }
            uncacheRoot(tt) {
                const lt = tt.uuid
                  , mt = this._actionsByClip;
                for (const xt in mt) {
                    const Ct = mt[xt].actionByRoot[lt];
                    Ct !== void 0 && (this._deactivateAction(Ct),
                    this._removeInactiveAction(Ct))
                }
                const ft = this._bindingsByRootAndName[lt];
                if (ft !== void 0)
                    for (const xt in ft) {
                        const Ct = ft[xt];
                        Ct.restoreOriginalState(),
                        this._removeInactiveBinding(Ct)
                    }
            }
            uncacheAction(tt, lt) {
                const mt = this.existingAction(tt, lt);
                mt !== null && (this._deactivateAction(mt),
                this._removeInactiveAction(mt))
            }
        }
        class Ty {
            constructor(tt) {
                this.value = tt
            }
            clone() {
                return new Ty(this.value.clone === void 0 ? this.value : this.value.clone())
            }
        }
        let YS = 0;
        class KS extends As {
            constructor() {
                super(),
                this.isUniformsGroup = !0,
                Object.defineProperty(this, "id", {
                    value: YS++
                }),
                this.name = "",
                this.usage = Nu,
                this.uniforms = []
            }
            add(tt) {
                return this.uniforms.push(tt),
                this
            }
            remove(tt) {
                const lt = this.uniforms.indexOf(tt);
                return lt !== -1 && this.uniforms.splice(lt, 1),
                this
            }
            setName(tt) {
                return this.name = tt,
                this
            }
            setUsage(tt) {
                return this.usage = tt,
                this
            }
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }),
                this
            }
            copy(tt) {
                this.name = tt.name,
                this.usage = tt.usage;
                const lt = tt.uniforms;
                this.uniforms.length = 0;
                for (let mt = 0, ft = lt.length; mt < ft; mt++)
                    this.uniforms.push(lt[mt].clone());
                return this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class JS extends Rv {
            constructor(tt, lt, mt=1) {
                super(tt, lt),
                this.isInstancedInterleavedBuffer = !0,
                this.meshPerAttribute = mt
            }
            copy(tt) {
                return super.copy(tt),
                this.meshPerAttribute = tt.meshPerAttribute,
                this
            }
            clone(tt) {
                const lt = super.clone(tt);
                return lt.meshPerAttribute = this.meshPerAttribute,
                lt
            }
            toJSON(tt) {
                const lt = super.toJSON(tt);
                return lt.isInstancedInterleavedBuffer = !0,
                lt.meshPerAttribute = this.meshPerAttribute,
                lt
            }
        }
        class ZS {
            constructor(tt, lt, mt, ft, xt) {
                this.isGLBufferAttribute = !0,
                this.name = "",
                this.buffer = tt,
                this.type = lt,
                this.itemSize = mt,
                this.elementSize = ft,
                this.count = xt,
                this.version = 0
            }
            set needsUpdate(tt) {
                tt === !0 && this.version++
            }
            setBuffer(tt) {
                return this.buffer = tt,
                this
            }
            setType(tt, lt) {
                return this.type = tt,
                this.elementSize = lt,
                this
            }
            setItemSize(tt) {
                return this.itemSize = tt,
                this
            }
            setCount(tt) {
                return this.count = tt,
                this
            }
        }
        class eE {
            constructor(tt, lt, mt=0, ft=1 / 0) {
                this.ray = new Qu(tt,lt),
                this.near = mt,
                this.far = ft,
                this.camera = null,
                this.layers = new um,
                this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(tt, lt) {
                this.ray.set(tt, lt)
            }
            setFromCamera(tt, lt) {
                lt.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(lt.matrixWorld),
                this.ray.direction.set(tt.x, tt.y, .5).unproject(lt).sub(this.ray.origin).normalize(),
                this.camera = lt) : lt.isOrthographicCamera ? (this.ray.origin.set(tt.x, tt.y, (lt.near + lt.far) / (lt.near - lt.far)).unproject(lt),
                this.ray.direction.set(0, 0, -1).transformDirection(lt.matrixWorld),
                this.camera = lt) : console.error("THREE.Raycaster: Unsupported camera type: " + lt.type)
            }
            intersectObject(tt, lt=!0, mt=[]) {
                return Cy(tt, this, mt, lt),
                mt.sort(XA),
                mt
            }
            intersectObjects(tt, lt=!0, mt=[]) {
                for (let ft = 0, xt = tt.length; ft < xt; ft++)
                    Cy(tt[ft], this, mt, lt);
                return mt.sort(XA),
                mt
            }
        }
        function XA(Tt, tt) {
            return Tt.distance - tt.distance
        }
        function Cy(Tt, tt, lt, mt) {
            if (Tt.layers.test(tt.layers) && Tt.raycast(tt, lt),
            mt === !0) {
                const ft = Tt.children;
                for (let xt = 0, Ct = ft.length; xt < Ct; xt++)
                    Cy(ft[xt], tt, lt, !0)
            }
        }
        class tE {
            constructor(tt=1, lt=0, mt=0) {
                return this.radius = tt,
                this.phi = lt,
                this.theta = mt,
                this
            }
            set(tt, lt, mt) {
                return this.radius = tt,
                this.phi = lt,
                this.theta = mt,
                this
            }
            copy(tt) {
                return this.radius = tt.radius,
                this.phi = tt.phi,
                this.theta = tt.theta,
                this
            }
            makeSafe() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
                this
            }
            setFromVector3(tt) {
                return this.setFromCartesianCoords(tt.x, tt.y, tt.z)
            }
            setFromCartesianCoords(tt, lt, mt) {
                return this.radius = Math.sqrt(tt * tt + lt * lt + mt * mt),
                this.radius === 0 ? (this.theta = 0,
                this.phi = 0) : (this.theta = Math.atan2(tt, mt),
                this.phi = Math.acos(qo(lt / this.radius, -1, 1))),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        class rE {
            constructor(tt=1, lt=0, mt=0) {
                return this.radius = tt,
                this.theta = lt,
                this.y = mt,
                this
            }
            set(tt, lt, mt) {
                return this.radius = tt,
                this.theta = lt,
                this.y = mt,
                this
            }
            copy(tt) {
                return this.radius = tt.radius,
                this.theta = tt.theta,
                this.y = tt.y,
                this
            }
            setFromVector3(tt) {
                return this.setFromCartesianCoords(tt.x, tt.y, tt.z)
            }
            setFromCartesianCoords(tt, lt, mt) {
                return this.radius = Math.sqrt(tt * tt + mt * mt),
                this.theta = Math.atan2(tt, mt),
                this.y = lt,
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const YA = new mn;
        class nE {
            constructor(tt=new mn(1 / 0,1 / 0), lt=new mn(-1 / 0,-1 / 0)) {
                this.isBox2 = !0,
                this.min = tt,
                this.max = lt
            }
            set(tt, lt) {
                return this.min.copy(tt),
                this.max.copy(lt),
                this
            }
            setFromPoints(tt) {
                this.makeEmpty();
                for (let lt = 0, mt = tt.length; lt < mt; lt++)
                    this.expandByPoint(tt[lt]);
                return this
            }
            setFromCenterAndSize(tt, lt) {
                const mt = YA.copy(lt).multiplyScalar(.5);
                return this.min.copy(tt).sub(mt),
                this.max.copy(tt).add(mt),
                this
            }
            clone() {
                return new this.constructor().copy(this)
            }
            copy(tt) {
                return this.min.copy(tt.min),
                this.max.copy(tt.max),
                this
            }
            makeEmpty() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -1 / 0,
                this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            }
            getCenter(tt) {
                return this.isEmpty() ? tt.set(0, 0) : tt.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(tt) {
                return this.isEmpty() ? tt.set(0, 0) : tt.subVectors(this.max, this.min)
            }
            expandByPoint(tt) {
                return this.min.min(tt),
                this.max.max(tt),
                this
            }
            expandByVector(tt) {
                return this.min.sub(tt),
                this.max.add(tt),
                this
            }
            expandByScalar(tt) {
                return this.min.addScalar(-tt),
                this.max.addScalar(tt),
                this
            }
            containsPoint(tt) {
                return !(tt.x < this.min.x || tt.x > this.max.x || tt.y < this.min.y || tt.y > this.max.y)
            }
            containsBox(tt) {
                return this.min.x <= tt.min.x && tt.max.x <= this.max.x && this.min.y <= tt.min.y && tt.max.y <= this.max.y
            }
            getParameter(tt, lt) {
                return lt.set((tt.x - this.min.x) / (this.max.x - this.min.x), (tt.y - this.min.y) / (this.max.y - this.min.y))
            }
            intersectsBox(tt) {
                return !(tt.max.x < this.min.x || tt.min.x > this.max.x || tt.max.y < this.min.y || tt.min.y > this.max.y)
            }
            clampPoint(tt, lt) {
                return lt.copy(tt).clamp(this.min, this.max)
            }
            distanceToPoint(tt) {
                return this.clampPoint(tt, YA).distanceTo(tt)
            }
            intersect(tt) {
                return this.min.max(tt.min),
                this.max.min(tt.max),
                this.isEmpty() && this.makeEmpty(),
                this
            }
            union(tt) {
                return this.min.min(tt.min),
                this.max.max(tt.max),
                this
            }
            translate(tt) {
                return this.min.add(tt),
                this.max.add(tt),
                this
            }
            equals(tt) {
                return tt.min.equals(this.min) && tt.max.equals(this.max)
            }
        }
        const KA = new Er
          , u0 = new Er;
        class iE {
            constructor(tt=new Er, lt=new Er) {
                this.start = tt,
                this.end = lt
            }
            set(tt, lt) {
                return this.start.copy(tt),
                this.end.copy(lt),
                this
            }
            copy(tt) {
                return this.start.copy(tt.start),
                this.end.copy(tt.end),
                this
            }
            getCenter(tt) {
                return tt.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(tt) {
                return tt.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(tt, lt) {
                return this.delta(lt).multiplyScalar(tt).add(this.start)
            }
            closestPointToPointParameter(tt, lt) {
                KA.subVectors(tt, this.start),
                u0.subVectors(this.end, this.start);
                const mt = u0.dot(u0);
                let ft = u0.dot(KA) / mt;
                return lt && (ft = qo(ft, 0, 1)),
                ft
            }
            closestPointToPoint(tt, lt, mt) {
                const ft = this.closestPointToPointParameter(tt, lt);
                return this.delta(mt).multiplyScalar(ft).add(this.start)
            }
            applyMatrix4(tt) {
                return this.start.applyMatrix4(tt),
                this.end.applyMatrix4(tt),
                this
            }
            equals(tt) {
                return tt.start.equals(this.start) && tt.end.equals(this.end)
            }
            clone() {
                return new this.constructor().copy(this)
            }
        }
        const JA = new Er;
        class oE extends Mo {
            constructor(tt, lt) {
                super(),
                this.light = tt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = lt,
                this.type = "SpotLightHelper";
                const mt = new bo
                  , ft = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                for (let Ct = 0, Mt = 1, Lt = 32; Ct < Lt; Ct++,
                Mt++) {
                    const Nt = Ct / Lt * Math.PI * 2
                      , jt = Mt / Lt * Math.PI * 2;
                    ft.push(Math.cos(Nt), Math.sin(Nt), 1, Math.cos(jt), Math.sin(jt), 1)
                }
                mt.setAttribute("position", new Fn(ft,3));
                const xt = new Gs({
                    fog: !1,
                    toneMapped: !1
                });
                this.cone = new iu(mt,xt),
                this.add(this.cone),
                this.update()
            }
            dispose() {
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1);
                const tt = this.light.distance ? this.light.distance : 1e3
                  , lt = tt * Math.tan(this.light.angle);
                this.cone.scale.set(lt, lt, tt),
                JA.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(JA),
                this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
            }
        }
        const np = new Er
          , d0 = new no
          , Py = new no;
        class sE extends iu {
            constructor(tt) {
                const lt = ZA(tt)
                  , mt = new bo
                  , ft = []
                  , xt = []
                  , Ct = new Gn(0,0,1)
                  , Mt = new Gn(0,1,0);
                for (let Lt = 0; Lt < lt.length; Lt++) {
                    const Nt = lt[Lt];
                    Nt.parent && Nt.parent.isBone && (ft.push(0, 0, 0),
                    ft.push(0, 0, 0),
                    xt.push(Ct.r, Ct.g, Ct.b),
                    xt.push(Mt.r, Mt.g, Mt.b))
                }
                mt.setAttribute("position", new Fn(ft,3)),
                mt.setAttribute("color", new Fn(xt,3)),
                super(mt, new Gs({
                    vertexColors: !0,
                    depthTest: !1,
                    depthWrite: !1,
                    toneMapped: !1,
                    transparent: !0
                })),
                this.isSkeletonHelper = !0,
                this.type = "SkeletonHelper",
                this.root = tt,
                this.bones = lt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1
            }
            updateMatrixWorld(tt) {
                const lt = this.bones
                  , mt = this.geometry
                  , ft = mt.getAttribute("position");
                Py.copy(this.root.matrixWorld).invert();
                for (let xt = 0, Ct = 0; xt < lt.length; xt++) {
                    const Mt = lt[xt];
                    Mt.parent && Mt.parent.isBone && (d0.multiplyMatrices(Py, Mt.matrixWorld),
                    np.setFromMatrixPosition(d0),
                    ft.setXYZ(Ct, np.x, np.y, np.z),
                    d0.multiplyMatrices(Py, Mt.parent.matrixWorld),
                    np.setFromMatrixPosition(d0),
                    ft.setXYZ(Ct + 1, np.x, np.y, np.z),
                    Ct += 2)
                }
                mt.getAttribute("position").needsUpdate = !0,
                super.updateMatrixWorld(tt)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function ZA(Tt) {
            const tt = [];
            Tt.isBone === !0 && tt.push(Tt);
            for (let lt = 0; lt < Tt.children.length; lt++)
                tt.push.apply(tt, ZA(Tt.children[lt]));
            return tt
        }
        class aE extends gs {
            constructor(tt, lt, mt) {
                super(new I_(lt,4,2), new nu({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                })),
                this.light = tt,
                this.color = mt,
                this.type = "PointLightHelper",
                this.matrix = this.light.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.update()
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }
        }
        const lE = new Er
          , ew = new Gn
          , tw = new Gn;
        class cE extends Mo {
            constructor(tt, lt, mt) {
                super(),
                this.light = tt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = mt,
                this.type = "HemisphereLightHelper";
                const ft = new R_(lt);
                ft.rotateY(.5 * Math.PI),
                this.material = new nu({
                    wireframe: !0,
                    fog: !1,
                    toneMapped: !1
                }),
                this.color === void 0 && (this.material.vertexColors = !0);
                const xt = ft.getAttribute("position")
                  , Ct = new Float32Array(3 * xt.count);
                ft.setAttribute("color", new mr(Ct,3)),
                this.add(new gs(ft,this.material)),
                this.update()
            }
            dispose() {
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
            update() {
                const tt = this.children[0];
                if (this.color !== void 0)
                    this.material.color.set(this.color);
                else {
                    const lt = tt.geometry.getAttribute("color");
                    ew.copy(this.light.color),
                    tw.copy(this.light.groundColor);
                    for (let mt = 0, ft = lt.count; mt < ft; mt++) {
                        const xt = mt < ft / 2 ? ew : tw;
                        lt.setXYZ(mt, xt.r, xt.g, xt.b)
                    }
                    lt.needsUpdate = !0
                }
                this.light.updateWorldMatrix(!0, !1),
                tt.lookAt(lE.setFromMatrixPosition(this.light.matrixWorld).negate())
            }
        }
        class uE extends iu {
            constructor(tt=10, lt=10, mt=4473924, ft=8947848) {
                mt = new Gn(mt),
                ft = new Gn(ft);
                const xt = lt / 2
                  , Ct = tt / lt
                  , Mt = tt / 2
                  , Lt = []
                  , Nt = [];
                for (let Wt = 0, Qt = 0, qt = -Mt; Wt <= lt; Wt++,
                qt += Ct) {
                    Lt.push(-Mt, 0, qt, Mt, 0, qt),
                    Lt.push(qt, 0, -Mt, qt, 0, Mt);
                    const Xt = Wt === xt ? mt : ft;
                    Xt.toArray(Nt, Qt),
                    Qt += 3,
                    Xt.toArray(Nt, Qt),
                    Qt += 3,
                    Xt.toArray(Nt, Qt),
                    Qt += 3,
                    Xt.toArray(Nt, Qt),
                    Qt += 3
                }
                const jt = new bo;
                jt.setAttribute("position", new Fn(Lt,3)),
                jt.setAttribute("color", new Fn(Nt,3)),
                super(jt, new Gs({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "GridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class dE extends iu {
            constructor(tt=10, lt=16, mt=8, ft=64, xt=4473924, Ct=8947848) {
                xt = new Gn(xt),
                Ct = new Gn(Ct);
                const Mt = []
                  , Lt = [];
                if (lt > 1)
                    for (let jt = 0; jt < lt; jt++) {
                        const Wt = jt / lt * (2 * Math.PI)
                          , Qt = Math.sin(Wt) * tt
                          , qt = Math.cos(Wt) * tt;
                        Mt.push(0, 0, 0),
                        Mt.push(Qt, 0, qt);
                        const Xt = 1 & jt ? xt : Ct;
                        Lt.push(Xt.r, Xt.g, Xt.b),
                        Lt.push(Xt.r, Xt.g, Xt.b)
                    }
                for (let jt = 0; jt < mt; jt++) {
                    const Wt = 1 & jt ? xt : Ct
                      , Qt = tt - tt / mt * jt;
                    for (let qt = 0; qt < ft; qt++) {
                        let Xt = qt / ft * (2 * Math.PI)
                          , Zt = Math.sin(Xt) * Qt
                          , Yt = Math.cos(Xt) * Qt;
                        Mt.push(Zt, 0, Yt),
                        Lt.push(Wt.r, Wt.g, Wt.b),
                        Xt = (qt + 1) / ft * (2 * Math.PI),
                        Zt = Math.sin(Xt) * Qt,
                        Yt = Math.cos(Xt) * Qt,
                        Mt.push(Zt, 0, Yt),
                        Lt.push(Wt.r, Wt.g, Wt.b)
                    }
                }
                const Nt = new bo;
                Nt.setAttribute("position", new Fn(Mt,3)),
                Nt.setAttribute("color", new Fn(Lt,3)),
                super(Nt, new Gs({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "PolarGridHelper"
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        const rw = new Er
          , p0 = new Er
          , nw = new Er;
        class pE extends Mo {
            constructor(tt, lt, mt) {
                super(),
                this.light = tt,
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.color = mt,
                this.type = "DirectionalLightHelper",
                lt === void 0 && (lt = 1);
                let ft = new bo;
                ft.setAttribute("position", new Fn([-lt, lt, 0, lt, lt, 0, lt, -lt, 0, -lt, -lt, 0, -lt, lt, 0],3));
                const xt = new Gs({
                    fog: !1,
                    toneMapped: !1
                });
                this.lightPlane = new ep(ft,xt),
                this.add(this.lightPlane),
                ft = new bo,
                ft.setAttribute("position", new Fn([0, 0, 0, 0, 0, 1],3)),
                this.targetLine = new ep(ft,xt),
                this.add(this.targetLine),
                this.update()
            }
            dispose() {
                this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose()
            }
            update() {
                this.light.updateWorldMatrix(!0, !1),
                this.light.target.updateWorldMatrix(!0, !1),
                rw.setFromMatrixPosition(this.light.matrixWorld),
                p0.setFromMatrixPosition(this.light.target.matrixWorld),
                nw.subVectors(p0, rw),
                this.lightPlane.lookAt(p0),
                this.color !== void 0 ? (this.lightPlane.material.color.set(this.color),
                this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
                this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(p0),
                this.targetLine.scale.z = nw.length()
            }
        }
        const h0 = new Er
          , rs = new xv;
        class hE extends iu {
            constructor(tt) {
                const lt = new bo
                  , mt = new Gs({
                    color: 16777215,
                    vertexColors: !0,
                    toneMapped: !1
                })
                  , ft = []
                  , xt = []
                  , Ct = {};
                function Mt(Xt, Zt) {
                    Lt(Xt),
                    Lt(Zt)
                }
                function Lt(Xt) {
                    ft.push(0, 0, 0),
                    xt.push(0, 0, 0),
                    Ct[Xt] === void 0 && (Ct[Xt] = []),
                    Ct[Xt].push(ft.length / 3 - 1)
                }
                Mt("n1", "n2"),
                Mt("n2", "n4"),
                Mt("n4", "n3"),
                Mt("n3", "n1"),
                Mt("f1", "f2"),
                Mt("f2", "f4"),
                Mt("f4", "f3"),
                Mt("f3", "f1"),
                Mt("n1", "f1"),
                Mt("n2", "f2"),
                Mt("n3", "f3"),
                Mt("n4", "f4"),
                Mt("p", "n1"),
                Mt("p", "n2"),
                Mt("p", "n3"),
                Mt("p", "n4"),
                Mt("u1", "u2"),
                Mt("u2", "u3"),
                Mt("u3", "u1"),
                Mt("c", "t"),
                Mt("p", "c"),
                Mt("cn1", "cn2"),
                Mt("cn3", "cn4"),
                Mt("cf1", "cf2"),
                Mt("cf3", "cf4"),
                lt.setAttribute("position", new Fn(ft,3)),
                lt.setAttribute("color", new Fn(xt,3)),
                super(lt, mt),
                this.type = "CameraHelper",
                this.camera = tt,
                this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
                this.matrix = tt.matrixWorld,
                this.matrixAutoUpdate = !1,
                this.pointMap = Ct,
                this.update();
                const Nt = new Gn(16755200)
                  , jt = new Gn(16711680)
                  , Wt = new Gn(43775)
                  , Qt = new Gn(16777215)
                  , qt = new Gn(3355443);
                this.setColors(Nt, jt, Wt, Qt, qt)
            }
            setColors(tt, lt, mt, ft, xt) {
                const Ct = this.geometry.getAttribute("color");
                Ct.setXYZ(0, tt.r, tt.g, tt.b),
                Ct.setXYZ(1, tt.r, tt.g, tt.b),
                Ct.setXYZ(2, tt.r, tt.g, tt.b),
                Ct.setXYZ(3, tt.r, tt.g, tt.b),
                Ct.setXYZ(4, tt.r, tt.g, tt.b),
                Ct.setXYZ(5, tt.r, tt.g, tt.b),
                Ct.setXYZ(6, tt.r, tt.g, tt.b),
                Ct.setXYZ(7, tt.r, tt.g, tt.b),
                Ct.setXYZ(8, tt.r, tt.g, tt.b),
                Ct.setXYZ(9, tt.r, tt.g, tt.b),
                Ct.setXYZ(10, tt.r, tt.g, tt.b),
                Ct.setXYZ(11, tt.r, tt.g, tt.b),
                Ct.setXYZ(12, tt.r, tt.g, tt.b),
                Ct.setXYZ(13, tt.r, tt.g, tt.b),
                Ct.setXYZ(14, tt.r, tt.g, tt.b),
                Ct.setXYZ(15, tt.r, tt.g, tt.b),
                Ct.setXYZ(16, tt.r, tt.g, tt.b),
                Ct.setXYZ(17, tt.r, tt.g, tt.b),
                Ct.setXYZ(18, tt.r, tt.g, tt.b),
                Ct.setXYZ(19, tt.r, tt.g, tt.b),
                Ct.setXYZ(20, tt.r, tt.g, tt.b),
                Ct.setXYZ(21, tt.r, tt.g, tt.b),
                Ct.setXYZ(22, tt.r, tt.g, tt.b),
                Ct.setXYZ(23, tt.r, tt.g, tt.b),
                Ct.setXYZ(24, lt.r, lt.g, lt.b),
                Ct.setXYZ(25, lt.r, lt.g, lt.b),
                Ct.setXYZ(26, lt.r, lt.g, lt.b),
                Ct.setXYZ(27, lt.r, lt.g, lt.b),
                Ct.setXYZ(28, lt.r, lt.g, lt.b),
                Ct.setXYZ(29, lt.r, lt.g, lt.b),
                Ct.setXYZ(30, lt.r, lt.g, lt.b),
                Ct.setXYZ(31, lt.r, lt.g, lt.b),
                Ct.setXYZ(32, mt.r, mt.g, mt.b),
                Ct.setXYZ(33, mt.r, mt.g, mt.b),
                Ct.setXYZ(34, mt.r, mt.g, mt.b),
                Ct.setXYZ(35, mt.r, mt.g, mt.b),
                Ct.setXYZ(36, mt.r, mt.g, mt.b),
                Ct.setXYZ(37, mt.r, mt.g, mt.b),
                Ct.setXYZ(38, ft.r, ft.g, ft.b),
                Ct.setXYZ(39, ft.r, ft.g, ft.b),
                Ct.setXYZ(40, xt.r, xt.g, xt.b),
                Ct.setXYZ(41, xt.r, xt.g, xt.b),
                Ct.setXYZ(42, xt.r, xt.g, xt.b),
                Ct.setXYZ(43, xt.r, xt.g, xt.b),
                Ct.setXYZ(44, xt.r, xt.g, xt.b),
                Ct.setXYZ(45, xt.r, xt.g, xt.b),
                Ct.setXYZ(46, xt.r, xt.g, xt.b),
                Ct.setXYZ(47, xt.r, xt.g, xt.b),
                Ct.setXYZ(48, xt.r, xt.g, xt.b),
                Ct.setXYZ(49, xt.r, xt.g, xt.b),
                Ct.needsUpdate = !0
            }
            update() {
                const tt = this.geometry
                  , lt = this.pointMap;
                rs.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
                os("c", lt, tt, rs, 0, 0, -1),
                os("t", lt, tt, rs, 0, 0, 1),
                os("n1", lt, tt, rs, -1, -1, -1),
                os("n2", lt, tt, rs, 1, -1, -1),
                os("n3", lt, tt, rs, -1, 1, -1),
                os("n4", lt, tt, rs, 1, 1, -1),
                os("f1", lt, tt, rs, -1, -1, 1),
                os("f2", lt, tt, rs, 1, -1, 1),
                os("f3", lt, tt, rs, -1, 1, 1),
                os("f4", lt, tt, rs, 1, 1, 1),
                os("u1", lt, tt, rs, .7, 1.1, -1),
                os("u2", lt, tt, rs, -.7, 1.1, -1),
                os("u3", lt, tt, rs, 0, 2, -1),
                os("cf1", lt, tt, rs, -1, 0, 1),
                os("cf2", lt, tt, rs, 1, 0, 1),
                os("cf3", lt, tt, rs, 0, -1, 1),
                os("cf4", lt, tt, rs, 0, 1, 1),
                os("cn1", lt, tt, rs, -1, 0, -1),
                os("cn2", lt, tt, rs, 1, 0, -1),
                os("cn3", lt, tt, rs, 0, -1, -1),
                os("cn4", lt, tt, rs, 0, 1, -1),
                tt.getAttribute("position").needsUpdate = !0
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        function os(Tt, tt, lt, mt, ft, xt, Ct) {
            h0.set(ft, xt, Ct).unproject(mt);
            const Mt = tt[Tt];
            if (Mt !== void 0) {
                const Lt = lt.getAttribute("position");
                for (let Nt = 0, jt = Mt.length; Nt < jt; Nt++)
                    Lt.setXYZ(Mt[Nt], h0.x, h0.y, h0.z)
            }
        }
        const m0 = new Tl;
        class mE extends iu {
            constructor(tt, lt=16776960) {
                const mt = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , ft = new Float32Array(24)
                  , xt = new bo;
                xt.setIndex(new mr(mt,1)),
                xt.setAttribute("position", new mr(ft,3)),
                super(xt, new Gs({
                    color: lt,
                    toneMapped: !1
                })),
                this.object = tt,
                this.type = "BoxHelper",
                this.matrixAutoUpdate = !1,
                this.update()
            }
            update(tt) {
                if (tt !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
                this.object !== void 0 && m0.setFromObject(this.object),
                m0.isEmpty())
                    return;
                const lt = m0.min
                  , mt = m0.max
                  , ft = this.geometry.attributes.position
                  , xt = ft.array;
                xt[0] = mt.x,
                xt[1] = mt.y,
                xt[2] = mt.z,
                xt[3] = lt.x,
                xt[4] = mt.y,
                xt[5] = mt.z,
                xt[6] = lt.x,
                xt[7] = lt.y,
                xt[8] = mt.z,
                xt[9] = mt.x,
                xt[10] = lt.y,
                xt[11] = mt.z,
                xt[12] = mt.x,
                xt[13] = mt.y,
                xt[14] = lt.z,
                xt[15] = lt.x,
                xt[16] = mt.y,
                xt[17] = lt.z,
                xt[18] = lt.x,
                xt[19] = lt.y,
                xt[20] = lt.z,
                xt[21] = mt.x,
                xt[22] = lt.y,
                xt[23] = lt.z,
                ft.needsUpdate = !0,
                this.geometry.computeBoundingSphere()
            }
            setFromObject(tt) {
                return this.object = tt,
                this.update(),
                this
            }
            copy(tt, lt) {
                return super.copy(tt, lt),
                this.object = tt.object,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class fE extends iu {
            constructor(tt, lt=16776960) {
                const mt = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
                  , ft = new bo;
                ft.setIndex(new mr(mt,1)),
                ft.setAttribute("position", new Fn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
                super(ft, new Gs({
                    color: lt,
                    toneMapped: !1
                })),
                this.box = tt,
                this.type = "Box3Helper",
                this.geometry.computeBoundingSphere()
            }
            updateMatrixWorld(tt) {
                const lt = this.box;
                lt.isEmpty() || (lt.getCenter(this.position),
                lt.getSize(this.scale),
                this.scale.multiplyScalar(.5),
                super.updateMatrixWorld(tt))
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class gE extends ep {
            constructor(tt, lt=1, mt=16776960) {
                const ft = mt
                  , xt = new bo;
                xt.setAttribute("position", new Fn([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
                xt.computeBoundingSphere(),
                super(xt, new Gs({
                    color: ft,
                    toneMapped: !1
                })),
                this.type = "PlaneHelper",
                this.plane = tt,
                this.size = lt;
                const Ct = new bo;
                Ct.setAttribute("position", new Fn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
                Ct.computeBoundingSphere(),
                this.add(new gs(Ct,new nu({
                    color: ft,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1,
                    toneMapped: !1
                })))
            }
            updateMatrixWorld(tt) {
                this.position.set(0, 0, 0),
                this.scale.set(.5 * this.size, .5 * this.size, 1),
                this.lookAt(this.plane.normal),
                this.translateZ(-this.plane.constant),
                super.updateMatrixWorld(tt)
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose(),
                this.children[0].geometry.dispose(),
                this.children[0].material.dispose()
            }
        }
        const iw = new Er;
        let f0, My;
        class _E extends Mo {
            constructor(tt=new Er(0,0,1), lt=new Er(0,0,0), mt=1, ft=16776960, xt=.2 * mt, Ct=.2 * xt) {
                super(),
                this.type = "ArrowHelper",
                f0 === void 0 && (f0 = new bo,
                f0.setAttribute("position", new Fn([0, 0, 0, 0, 1, 0],3)),
                My = new Im(0,.5,1,5,1),
                My.translate(0, -.5, 0)),
                this.position.copy(lt),
                this.line = new ep(f0,new Gs({
                    color: ft,
                    toneMapped: !1
                })),
                this.line.matrixAutoUpdate = !1,
                this.add(this.line),
                this.cone = new gs(My,new nu({
                    color: ft,
                    toneMapped: !1
                })),
                this.cone.matrixAutoUpdate = !1,
                this.add(this.cone),
                this.setDirection(tt),
                this.setLength(mt, xt, Ct)
            }
            setDirection(tt) {
                if (tt.y > .99999)
                    this.quaternion.set(0, 0, 0, 1);
                else if (tt.y < -.99999)
                    this.quaternion.set(1, 0, 0, 0);
                else {
                    iw.set(tt.z, 0, -tt.x).normalize();
                    const lt = Math.acos(tt.y);
                    this.quaternion.setFromAxisAngle(iw, lt)
                }
            }
            setLength(tt, lt=.2 * tt, mt=.2 * lt) {
                this.line.scale.set(1, Math.max(1e-4, tt - lt), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(mt, lt, mt),
                this.cone.position.y = tt,
                this.cone.updateMatrix()
            }
            setColor(tt) {
                this.line.material.color.set(tt),
                this.cone.material.color.set(tt)
            }
            copy(tt) {
                return super.copy(tt, !1),
                this.line.copy(tt.line),
                this.cone.copy(tt.cone),
                this
            }
            dispose() {
                this.line.geometry.dispose(),
                this.line.material.dispose(),
                this.cone.geometry.dispose(),
                this.cone.material.dispose()
            }
        }
        class vE extends iu {
            constructor(tt=1) {
                const lt = [0, 0, 0, tt, 0, 0, 0, 0, 0, 0, tt, 0, 0, 0, 0, 0, 0, tt]
                  , mt = new bo;
                mt.setAttribute("position", new Fn(lt,3)),
                mt.setAttribute("color", new Fn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
                super(mt, new Gs({
                    vertexColors: !0,
                    toneMapped: !1
                })),
                this.type = "AxesHelper"
            }
            setColors(tt, lt, mt) {
                const ft = new Gn
                  , xt = this.geometry.attributes.color.array;
                return ft.set(tt),
                ft.toArray(xt, 0),
                ft.toArray(xt, 3),
                ft.set(lt),
                ft.toArray(xt, 6),
                ft.toArray(xt, 9),
                ft.set(mt),
                ft.toArray(xt, 12),
                ft.toArray(xt, 15),
                this.geometry.attributes.color.needsUpdate = !0,
                this
            }
            dispose() {
                this.geometry.dispose(),
                this.material.dispose()
            }
        }
        class yE {
            constructor() {
                this.type = "ShapePath",
                this.color = new Gn,
                this.subPaths = [],
                this.currentPath = null
            }
            moveTo(tt, lt) {
                return this.currentPath = new E_,
                this.subPaths.push(this.currentPath),
                this.currentPath.moveTo(tt, lt),
                this
            }
            lineTo(tt, lt) {
                return this.currentPath.lineTo(tt, lt),
                this
            }
            quadraticCurveTo(tt, lt, mt, ft) {
                return this.currentPath.quadraticCurveTo(tt, lt, mt, ft),
                this
            }
            bezierCurveTo(tt, lt, mt, ft, xt, Ct) {
                return this.currentPath.bezierCurveTo(tt, lt, mt, ft, xt, Ct),
                this
            }
            splineThru(tt) {
                return this.currentPath.splineThru(tt),
                this
            }
            toShapes(tt) {
                function lt(Yt, sr) {
                    const er = sr.length;
                    let rr = !1;
                    for (let xr = er - 1, br = 0; br < er; xr = br++) {
                        let yr = sr[xr]
                          , Pr = sr[br]
                          , zr = Pr.x - yr.x
                          , Nr = Pr.y - yr.y;
                        if (Math.abs(Nr) > Number.EPSILON) {
                            if (Nr < 0 && (yr = sr[br],
                            zr = -zr,
                            Pr = sr[xr],
                            Nr = -Nr),
                            Yt.y < yr.y || Yt.y > Pr.y)
                                continue;
                            if (Yt.y === yr.y) {
                                if (Yt.x === yr.x)
                                    return !0
                            } else {
                                const Vr = Nr * (Yt.x - yr.x) - zr * (Yt.y - yr.y);
                                if (Vr === 0)
                                    return !0;
                                if (Vr < 0)
                                    continue;
                                rr = !rr
                            }
                        } else {
                            if (Yt.y !== yr.y)
                                continue;
                            if (Pr.x <= Yt.x && Yt.x <= yr.x || yr.x <= Yt.x && Yt.x <= Pr.x)
                                return !0
                        }
                    }
                    return rr
                }
                const mt = ou.isClockWise
                  , ft = this.subPaths;
                if (ft.length === 0)
                    return [];
                let xt, Ct, Mt;
                const Lt = [];
                if (ft.length === 1)
                    return Ct = ft[0],
                    Mt = new Pp,
                    Mt.curves = Ct.curves,
                    Lt.push(Mt),
                    Lt;
                let Nt = !mt(ft[0].getPoints());
                Nt = tt ? !Nt : Nt;
                const jt = []
                  , Wt = [];
                let Qt, qt, Xt = [], Zt = 0;
                Wt[Zt] = void 0,
                Xt[Zt] = [];
                for (let Yt = 0, sr = ft.length; Yt < sr; Yt++)
                    Ct = ft[Yt],
                    Qt = Ct.getPoints(),
                    xt = mt(Qt),
                    xt = tt ? !xt : xt,
                    xt ? (!Nt && Wt[Zt] && Zt++,
                    Wt[Zt] = {
                        s: new Pp,
                        p: Qt
                    },
                    Wt[Zt].s.curves = Ct.curves,
                    Nt && Zt++,
                    Xt[Zt] = []) : Xt[Zt].push({
                        h: Ct,
                        p: Qt[0]
                    });
                if (!Wt[0])
                    return function(Yt) {
                        const sr = [];
                        for (let er = 0, rr = Yt.length; er < rr; er++) {
                            const xr = Yt[er]
                              , br = new Pp;
                            br.curves = xr.curves,
                            sr.push(br)
                        }
                        return sr
                    }(ft);
                if (Wt.length > 1) {
                    let Yt = !1
                      , sr = 0;
                    for (let er = 0, rr = Wt.length; er < rr; er++)
                        jt[er] = [];
                    for (let er = 0, rr = Wt.length; er < rr; er++) {
                        const xr = Xt[er];
                        for (let br = 0; br < xr.length; br++) {
                            const yr = xr[br];
                            let Pr = !0;
                            for (let zr = 0; zr < Wt.length; zr++)
                                lt(yr.p, Wt[zr].p) && (er !== zr && sr++,
                                Pr ? (Pr = !1,
                                jt[zr].push(yr)) : Yt = !0);
                            Pr && jt[er].push(yr)
                        }
                    }
                    sr > 0 && Yt === !1 && (Xt = jt)
                }
                for (let Yt = 0, sr = Wt.length; Yt < sr; Yt++) {
                    Mt = Wt[Yt].s,
                    Lt.push(Mt),
                    qt = Xt[Yt];
                    for (let er = 0, rr = qt.length; er < rr; er++)
                        Mt.holes.push(qt[er].h)
                }
                return Lt
            }
        }
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
            detail: {
                revision: h
            }
        })),
        typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = h)
    },
    149: function(d, o, c) {
        c.d(o, {
            Z: function() {
                return b
            }
        });
        var h = c(848);
        const _ = new WeakMap;
        class b extends h.aHM {
            constructor(it) {
                super(it),
                this.decoderPath = "",
                this.decoderConfig = {},
                this.decoderBinary = null,
                this.decoderPending = null,
                this.workerLimit = 4,
                this.workerPool = [],
                this.workerNextTaskID = 1,
                this.workerSourceURL = "",
                this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                },
                this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(it) {
                return this.decoderPath = it,
                this
            }
            setDecoderConfig(it) {
                return this.decoderConfig = it,
                this
            }
            setWorkerLimit(it) {
                return this.workerLimit = it,
                this
            }
            load(it, at, ut, pt) {
                const ht = new h.Y9S(this.manager);
                ht.setPath(this.path),
                ht.setResponseType("arraybuffer"),
                ht.setRequestHeader(this.requestHeader),
                ht.setWithCredentials(this.withCredentials),
                ht.load(it, _t => {
                    this.parse(_t, at, pt)
                }
                , ut, pt)
            }
            parse(it, at, ut) {
                this.decodeDracoFile(it, at, null, null, h.er$).catch(ut)
            }
            decodeDracoFile(it, at, ut, pt, ht=h.Zr2) {
                const _t = {
                    attributeIDs: ut || this.defaultAttributeIDs,
                    attributeTypes: pt || this.defaultAttributeTypes,
                    useUniqueIDs: !!ut,
                    vertexColorSpace: ht
                };
                return this.decodeGeometry(it, _t).then(at)
            }
            decodeGeometry(it, at) {
                const ut = JSON.stringify(at);
                if (_.has(it)) {
                    const bt = _.get(it);
                    if (bt.key === ut)
                        return bt.promise;
                    if (it.byteLength === 0)
                        throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let pt;
                const ht = this.workerNextTaskID++
                  , _t = it.byteLength
                  , vt = this._getWorker(ht, _t).then(bt => (pt = bt,
                new Promise( (St, At) => {
                    pt._callbacks[ht] = {
                        resolve: St,
                        reject: At
                    },
                    pt.postMessage({
                        type: "decode",
                        id: ht,
                        taskConfig: at,
                        buffer: it
                    }, [it])
                }
                ))).then(bt => this._createGeometry(bt.geometry));
                return vt.catch( () => !0).then( () => {
                    pt && ht && this._releaseTask(pt, ht)
                }
                ),
                _.set(it, {
                    key: ut,
                    promise: vt
                }),
                vt
            }
            _createGeometry(it) {
                const at = new h.LoY;
                it.index && at.setIndex(new h.THS(it.index.array,1));
                for (let ut = 0; ut < it.attributes.length; ut++) {
                    const pt = it.attributes[ut]
                      , ht = pt.name
                      , _t = pt.array
                      , vt = pt.itemSize
                      , bt = new h.THS(_t,vt);
                    ht === "color" && (this._assignVertexColorSpace(bt, pt.vertexColorSpace),
                    bt.normalized = _t instanceof Float32Array == 0),
                    at.setAttribute(ht, bt)
                }
                return at
            }
            _assignVertexColorSpace(it, at) {
                if (at !== h.er$)
                    return;
                const ut = new h.Q1f;
                for (let pt = 0, ht = it.count; pt < ht; pt++)
                    ut.fromBufferAttribute(it, pt).convertSRGBToLinear(),
                    it.setXYZ(pt, ut.r, ut.g, ut.b)
            }
            _loadLibrary(it, at) {
                const ut = new h.Y9S(this.manager);
                return ut.setPath(this.decoderPath),
                ut.setResponseType(at),
                ut.setWithCredentials(this.withCredentials),
                new Promise( (pt, ht) => {
                    ut.load(it, pt, void 0, ht)
                }
                )
            }
            preload() {
                return this._initDecoder(),
                this
            }
            _initDecoder() {
                if (this.decoderPending)
                    return this.decoderPending;
                const it = typeof WebAssembly != "object" || this.decoderConfig.type === "js"
                  , at = [];
                return it ? at.push(this._loadLibrary("draco_decoder.js", "text")) : (at.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                at.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
                this.decoderPending = Promise.all(at).then(ut => {
                    const pt = ut[0];
                    it || (this.decoderConfig.wasmBinary = ut[1]);
                    const ht = _e
                      , _t = ["/* draco decoder */", pt, "", "/* worker */", ht.substring(ht.indexOf("{") + 1, ht.lastIndexOf("}"))].join(`
`);
                    this.workerSourceURL = URL.createObjectURL(new Blob([_t]))
                }
                ),
                this.decoderPending
            }
            _getWorker(it, at) {
                return this._initDecoder().then( () => {
                    if (this.workerPool.length < this.workerLimit) {
                        const pt = new Worker(this.workerSourceURL);
                        pt._callbacks = {},
                        pt._taskCosts = {},
                        pt._taskLoad = 0,
                        pt.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }),
                        pt.onmessage = function(ht) {
                            const _t = ht.data;
                            switch (_t.type) {
                            case "decode":
                                pt._callbacks[_t.id].resolve(_t);
                                break;
                            case "error":
                                pt._callbacks[_t.id].reject(_t);
                                break;
                            default:
                                console.error('THREE.DRACOLoader: Unexpected message, "' + _t.type + '"')
                            }
                        }
                        ,
                        this.workerPool.push(pt)
                    } else
                        this.workerPool.sort(function(pt, ht) {
                            return pt._taskLoad > ht._taskLoad ? -1 : 1
                        });
                    const ut = this.workerPool[this.workerPool.length - 1];
                    return ut._taskCosts[it] = at,
                    ut._taskLoad += at,
                    ut
                }
                )
            }
            _releaseTask(it, at) {
                it._taskLoad -= it._taskCosts[at],
                delete it._callbacks[at],
                delete it._taskCosts[at]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map(it => it._taskLoad))
            }
            dispose() {
                for (let it = 0; it < this.workerPool.length; ++it)
                    this.workerPool[it].terminate();
                return this.workerPool.length = 0,
                this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL),
                this
            }
        }
        const _e = `
function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();

					try {

						const geometry = decodeGeometry( draco, decoder, new Int8Array( buffer ), taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, array, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( array );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeArrayToMesh( array, array.byteLength, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeArrayToPointCloud( array, array.byteLength, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and .drc files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			const attributeResult = decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute );

			if ( attributeName === 'color' ) {

				attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;

			}

			geometry.attributes.push( attributeResult );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}
`
    }
