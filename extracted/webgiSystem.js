/* WEBGISYSTEM */
/* WebGI system and exports */
/* Lines: 42405-141961 */
/* Size: 3806450 characters */

var __webpackgi_exports__ = {}, ViewerState;
__webpackgi_require__.d(__webpackgi_exports__, {
    CZu: function() {
        return AAssetManagerProcessStatePlugin
    },
    FV: function() {
        return three_module.FV
    },
    oK2: function() {
        return ACameraControlsPlugin
    },
    SLH: function() {
        return ACanvasRecorder
    },
    yo9: function() {
        return ALL_WEBGI_EXTENSIONS
    },
    YJd: function() {
        return AMaterialManager
    },
    qnC: function() {
        return ARPlacementBox
    },
    TtJ: function() {
        return ARPlugin
    },
    rUH: function() {
        return ARTouchInputHelper
    },
    oAs: function() {
        return AShaderMaterial2
    },
    $fV: function() {
        return AViewerPlugin
    },
    upe: function() {
        return AWSClientPlugin
    },
    yPJ: function() {
        return AddBlendPass
    },
    gO9: function() {
        return three_module.gO9
    },
    XrR: function() {
        return three_module.XrR
    },
    DAe: function() {
        return three_module.DAe
    },
    EZo: function() {
        return three_module.EZo
    },
    wrO: function() {
        return three_module.wrO
    },
    FFZ: function() {
        return three_module.FFZ
    },
    lGu: function() {
        return three_module.lGu
    },
    sKt: function() {
        return three_module.sKt
    },
    $p8: function() {
        return three_module.$p8
    },
    nJr: function() {
        return AmbientLight2
    },
    pPE: function() {
        return three_module.pPE
    },
    tz3: function() {
        return three_module.tz3
    },
    kEx: function() {
        return three_module.kEx
    },
    Iw4: function() {
        return three_module.Iw4
    },
    P5j: function() {
        return three_module.P5j
    },
    AKb: function() {
        return three_module.AKb
    },
    GXy: function() {
        return AnisotropyPlugin
    },
    ibB: function() {
        return three_module.ibB
    },
    nZQ: function() {
        return three_module.nZQ
    },
    E0M: function() {
        return three_module.E0M
    },
    GLG: function() {
        return AssetExporter
    },
    $VP: function() {
        return AssetExporterPlugin
    },
    NeI: function() {
        return AssetImporter
    },
    rzc: function() {
        return AssetManagerBasicPopupPlugin
    },
    Kiu: function() {
        return AssetManagerLoadingBarPlugin
    },
    XDT: function() {
        return AssetManagerPlugin
    },
    XiN: function() {
        return AsyncGzip
    },
    _I9: function() {
        return AsyncDecompress
    },
    ShE: function() {
        return AsyncDeflate
    },
    OXP: function() {
        return AsyncGunzip
    },
    JZ8: function() {
        return AsyncGzip
    },
    gS4: function() {
        return AsyncInflate
    },
    eFx: function() {
        return AsyncUnzipInflate
    },
    peq: function() {
        return AsyncUnzlib
    },
    hw0: function() {
        return AsyncZipDeflate
    },
    _DG: function() {
        return AsyncZlib
    },
    fP5: function() {
        return three_module.fP5
    },
    CwR: function() {
        return three_module.CwR
    },
    UtX: function() {
        return three_module.UtX
    },
    Pf$: function() {
        return three_module.Pf$
    },
    Am1: function() {
        return three_module.Am1
    },
    IzY: function() {
        return three_module.IzY
    },
    hsX: function() {
        return three_module.hsX
    },
    XFr: function() {
        return BackgroundPresetGroup
    },
    Eh1: function() {
        return BaseGroundPlugin
    },
    RJS: function() {
        return BaseRenderer
    },
    Rkk: function() {
        return three_module.Rkk
    },
    bTm: function() {
        return three_module.bTm
    },
    Otl: function() {
        return BeringRingAnimation
    },
    pOj: function() {
        return BlobLoader
    },
    jg0: function() {
        return BloomPlugin
    },
    $Kf: function() {
        return three_module.$Kf
    },
    YOZ: function() {
        return three_module.YOZ
    },
    UtB: function() {
        return three_module.UtB
    },
    NRn: function() {
        return three_module.NRn
    },
    DYt: function() {
        return Box3B
    },
    BND: function() {
        return three_module.BND
    },
    iNn: function() {
        return three_module.iNn
    },
    IWo: function() {
        return three_module.IWo
    },
    SYd: function() {
        return BoxSelectionWidget
    },
    THS: function() {
        return three_module.THS
    },
    LoY: function() {
        return three_module.LoY
    },
    SUR: function() {
        return three_module.SUR
    },
    tJf: function() {
        return three_module.tJf
    },
    Y3u: function() {
        return CSGPluginBSP
    },
    poD: function() {
        return CSGPluginBVH
    },
    gaG: function() {
        return CSGPluginBase
    },
    z0x: function() {
        return CSS3DRendererPlugin
    },
    l2R: function() {
        return three_module.l2R
    },
    i7d: function() {
        return three_module.i7d
    },
    mL7: function() {
        return CameraController
    },
    WTh: function() {
        return three_module.WTh
    },
    l5h: function() {
        return CameraUiPlugin
    },
    hzv: function() {
        return CameraView
    },
    f_U: function() {
        return CameraViewControlPlugin
    },
    sxt: function() {
        return CameraViewPlugin
    },
    af0: function() {
        return CannonPhysicsPlugin
    },
    Phj: function() {
        return CanvasMediaRecorder
    },
    p5D: function() {
        return CanvasRecorder
    },
    CS6: function() {
        return CanvasRecorderPlugin
    },
    aKT: function() {
        return CanvasSnipper
    },
    RzO: function() {
        return CanvasSnipperPlugin
    },
    GOR: function() {
        return three_module.GOR
    },
    qU7: function() {
        return three_module.qU7
    },
    B6O: function() {
        return three_module.B6O
    },
    z1d: function() {
        return ChromaticAberrationPlugin
    },
    nNL: function() {
        return three_module.nNL
    },
    tcD: function() {
        return three_module.tcD
    },
    ghU: function() {
        return three_module.ghU
    },
    Dk8: function() {
        return ClearcoatTintPlugin
    },
    zD7: function() {
        return three_module.zD7
    },
    Q1f: function() {
        return three_module.Q1f
    },
    T6I: function() {
        return three_module.T6I
    },
    ppV: function() {
        return three_module.ppV
    },
    FvD: function() {
        return CombinedPostPlugin
    },
    n3b: function() {
        return Gzip
    },
    iOZ: function() {
        return three_module.iOZ
    },
    c5h: function() {
        return three_module.c5h
    },
    YSM: function() {
        return three_module.FvD
    },
    YRT: function() {
        return three_module.YRT
    },
    qFE: function() {
        return three_module.qFE
    },
    fCM: function() {
        return ContactShadowGroundPlugin
    },
    afc: function() {
        return CoreEditorApp
    },
    hLJ: function() {
        return CoreViewerApp
    },
    F1T: function() {
        return three_module.F1T
    },
    SXA: function() {
        return CubeNormalsCaptureHelper
    },
    hy7: function() {
        return three_module.hy7
    },
    xFO: function() {
        return three_module.xFO
    },
    b4q: function() {
        return three_module.b4q
    },
    ScU: function() {
        return three_module.ScU
    },
    Om: function() {
        return three_module.Om
    },
    Z0B: function() {
        return three_module.Z0B
    },
    s0K: function() {
        return three_module.s0K
    },
    Pdi: function() {
        return three_module.Pdi
    },
    Vb5: function() {
        return three_module.Vb5
    },
    Jnc: function() {
        return three_module.Jnc
    },
    ywQ: function() {
        return three_module.ywQ
    },
    WNZ: function() {
        return three_module.WNZ
    },
    Ipv: function() {
        return three_module.Ipv
    },
    jGm: function() {
        return three_module.jGm
    },
    Ogy: function() {
        return CustomAnimationHelper
    },
    xLk: function() {
        return CustomAnimationHelperPlugin
    },
    bCz: function() {
        return three_module.bCz
    },
    bGG: function() {
        return CustomBumpMapPlugin
    },
    g7M: function() {
        return three_module.g7M
    },
    Ho_: function() {
        return three_module.Ho_
    },
    hjs: function() {
        return three_module.hjs
    },
    Zn9: function() {
        return DRACOLoader2.Z
    },
    AHf: function() {
        return k$1
    },
    dYF: function() {
        return three_module.dYF
    },
    rFo: function() {
        return three_module.rFo
    },
    GYF: function() {
        return three_module.GYF
    },
    BRH: function() {
        return three_module.BRH
    },
    psi: function() {
        return DataUrlLoader
    },
    GxU: function() {
        return three_module.GxU
    },
    n2t: function() {
        return DebugPlugin
    },
    yuL: function() {
        return DecodeUTF8
    },
    YMq: function() {
        return Decompress
    },
    ROr: function() {
        return three_module.ROr
    },
    fJr: function() {
        return three_module.fJr
    },
    h_9: function() {
        return three_module.h_9
    },
    Gyi: function() {
        return Deflate
    },
    zdS: function() {
        return three_module.zdS
    },
    WCV: function() {
        return DepthOfFieldPass
    },
    _Vf: function() {
        return DepthOfFieldPlugin
    },
    dcC: function() {
        return three_module.dcC
    },
    VCu: function() {
        return three_module.VCu
    },
    n1S: function() {
        return DeviceOrientationControls2
    },
    sOF: function() {
        return DeviceOrientationControlsPlugin
    },
    aFP: function() {
        return DiamondMaterial
    },
    GMU: function() {
        return DiamondPlugin
    },
    ZyN: function() {
        return three_module.ZyN
    },
    rFg: function() {
        return DirectionalLight2
    },
    PFK: function() {
        return three_module.PFK
    },
    Yhb: function() {
        return three_module.Yhb
    },
    V5c: function() {
        return three_module.V5c
    },
    nEu: function() {
        return three_module.nEu
    },
    $EB: function() {
        return three_module.$EB
    },
    mRE: function() {
        return Dropzone
    },
    hSt: function() {
        return DropzonePlugin
    },
    hdd: function() {
        return three_module.hdd
    },
    wn6: function() {
        return three_module.wn6
    },
    MOq: function() {
        return three_module.MOq
    },
    Vnu: function() {
        return three_module.Vnu
    },
    hIf: function() {
        return three_module.hIf
    },
    d5G: function() {
        return EXRExporter2
    },
    vr8: function() {
        return EXRLoadPlugin
    },
    JCs: function() {
        return EasingFunctions
    },
    TDQ: function() {
        return three_module.TDQ
    },
    WYq: function() {
        return EffectComposer2
    },
    S20: function() {
        return three_module.S20
    },
    LWT: function() {
        return EllipseCurve3D
    },
    MJ1: function() {
        return EncodeUTF8
    },
    KDW: function() {
        return EncoderMethod
    },
    SQT: function() {
        return EnvironmentPresetGroup
    },
    kO0: function() {
        return three_module.kO0
    },
    U3G: function() {
        return three_module.U3G
    },
    jsO: function() {
        return three_module.jsO
    },
    wfO: function() {
        return three_module.wfO
    },
    uV5: function() {
        return three_module.uV5
    },
    O9p: function() {
        return three_module.O9p
    },
    Qev: function() {
        return three_module.Qev
    },
    j8I: function() {
        return ExtrasUiPlugin
    },
    QCA: function() {
        return three_module.QCA
    },
    ol2: function() {
        return FBXLoadPlugin
    },
    y74: function() {
        return FFMPEGRecorder
    },
    lT0: function() {
        return FSShadowMaterial
    },
    Y9S: function() {
        return three_module.Y9S
    },
    ryq: function() {
        return FileTransferPlugin
    },
    xcV: function() {
        return FilmicGrainPlugin
    },
    OMG: function() {
        return FirstPersonControls2
    },
    Vkg: function() {
        return FirstPersonControlsPlugin
    },
    Oax: function() {
        return three_module.Oax
    },
    qtW: function() {
        return three_module.qtW
    },
    V58: function() {
        return three_module.V58
    },
    RQf: function() {
        return three_module.RQf
    },
    jUj: function() {
        return three_module.jUj
    },
    cRK: function() {
        return three_module.cRK
    },
    ziY: function() {
        return FragmentClippingExtensionPlugin
    },
    kzd: function() {
        return FragmentClippingMode
    },
    VNy: function() {
        return FrameFadePlugin
    },
    Pem: function() {
        return three_module.Pem
    },
    hB5: function() {
        return three_module.hB5
    },
    PPD: function() {
        return three_module.PPD
    },
    BH6: function() {
        return FullScreenPlugin
    },
    HSI: function() {
        return GBufferPlugin
    },
    oh6: function() {
        return three_module.oh6
    },
    Wyr: function() {
        return three_module.Wyr
    },
    Wdf: function() {
        return three_module.Wdf
    },
    P3V: function() {
        return GLTFAnimationPlugin
    },
    s0N: function() {
        return GLTFDracoExportPlugin
    },
    _Js: function() {
        return GLTFDracoExporter
    },
    xQA: function() {
        return GLTFExporter2
    },
    Yeh: function() {
        return GLTFExporterMaterialsVariantsExtensionExport
    },
    N30: function() {
        return GLTFKHRMaterialVariantsPlugin
    },
    P44: function() {
        return GLTFLoader2
    },
    MdZ: function() {
        return GLTFMaterialsVariantsExtensionImport
    },
    Cc9: function() {
        return GLTFMeshGpuInstancingExporter
    },
    HjZ: function() {
        return GLTFMeshOptPlugin
    },
    UX5: function() {
        return GLTFSpecGlossinessConverterPlugin
    },
    fGP: function() {
        return GLTFWriter2
    },
    T03: function() {
        return GammaCorrectionExtension
    },
    fPK: function() {
        return GammaCorrectionPlugin
    },
    XpU: function() {
        return GemEnvironmentPresetGroup
    },
    hUz: function() {
        return GenericBlendTexturePass
    },
    pbu: function() {
        return GenericFilterPlugin
    },
    jhn: function() {
        return GeometryGeneratorPlugin
    },
    eoi: function() {
        return three_module.eoi
    },
    K52: function() {
        return three_module.K52
    },
    gWB: function() {
        return three_module.gWB
    },
    Gwm: function() {
        return three_module.Gwm
    },
    TMh: function() {
        return three_module.TMh
    },
    RcT: function() {
        return three_module.RcT
    },
    fTw: function() {
        return three_module.fTw
    },
    Hx_: function() {
        return GroundPlugin
    },
    YJl: function() {
        return three_module.YJl
    },
    asK: function() {
        return Gunzip
    },
    _qo: function() {
        return GyroInputDevice
    },
    Ne: function() {
        return Gzip
    },
    Guc: function() {
        return HDRiGroundPlugin
    },
    ix0: function() {
        return three_module.ix0
    },
    dth: function() {
        return three_module.dth
    },
    R1W: function() {
        return three_module.R1W
    },
    tcR: function() {
        return HierarchyUiPlugin
    },
    WBB: function() {
        return three_module.WBB
    },
    Kzg: function() {
        return three_module.Kzg
    },
    $NF: function() {
        return three_module.$NF
    },
    NuM: function() {
        return ImageSequenceRecorder
    },
    HgN: function() {
        return three_module.HgN
    },
    l9C: function() {
        return Importer
    },
    HLH: function() {
        return three_module.HLH
    },
    Ru$: function() {
        return three_module.Ru$
    },
    ELl: function() {
        return Inflate
    },
    uWO: function() {
        return three_module.uWO
    },
    CmU: function() {
        return three_module.CmU
    },
    LuO: function() {
        return three_module.LuO
    },
    ZLX: function() {
        return three_module.ZLX
    },
    Hrb: function() {
        return three_module.Hrb
    },
    vmz: function() {
        return three_module.vmz
    },
    wvS: function() {
        return three_module.wvS
    },
    Yuy: function() {
        return three_module.Yuy
    },
    K5h: function() {
        return InteractionPromptPlugin
    },
    eB$: function() {
        return three_module.eB$
    },
    eHs: function() {
        return three_module.eHs
    },
    lGw: function() {
        return three_module.lGw
    },
    ljd: function() {
        return three_module.ljd
    },
    PJ3: function() {
        return three_module.PJ3
    },
    EQC: function() {
        return three_module.EQC
    },
    oVO: function() {
        return three_module.oVO
    },
    Yj4: function() {
        return KHR_TEXTURE_BASISU
    },
    ZPL: function() {
        return KTX2LoadPlugin
    },
    $16: function() {
        return KTXLoadPlugin
    },
    VVr: function() {
        return three_module.VVr
    },
    UJ6: function() {
        return three_module.UJ6
    },
    UpK: function() {
        return three_module.UpK
    },
    ZYb: function() {
        return LUTPlugin
    },
    nzx: function() {
        return three_module.nzx
    },
    DLJ: function() {
        return LayeredMaterialPlugin
    },
    zgK: function() {
        return three_module.zgK
    },
    vim: function() {
        return three_module.vim
    },
    brA: function() {
        return three_module.brA
    },
    TiK: function() {
        return three_module.TiK
    },
    xSv: function() {
        return three_module.xSv
    },
    CR7: function() {
        return three_module.CR7
    },
    kYr: function() {
        return three_module.kYr
    },
    veJ: function() {
        return three_module.veJ
    },
    FZo: function() {
        return three_module.FZo
    },
    Dvx: function() {
        return LightsUiPlugin
    },
    N1A: function() {
        return three_module.N1A
    },
    XkL: function() {
        return Line2
    },
    cZY: function() {
        return three_module.cZY
    },
    mrM: function() {
        return three_module.mrM
    },
    GZZ: function() {
        return three_module.GZZ
    },
    VnP: function() {
        return three_module.VnP
    },
    Fvt: function() {
        return three_module.Fvt
    },
    vK6: function() {
        return LineGeometry
    },
    FCc: function() {
        return three_module.FCc
    },
    GV4: function() {
        return LineMaterial
    },
    DXC: function() {
        return three_module.DXC
    },
    bFd: function() {
        return LineSegments2
    },
    n31: function() {
        return LineSegmentsGeometry
    },
    qIQ: function() {
        return three_module.qIQ
    },
    tgE: function() {
        return three_module.tgE
    },
    k6q: function() {
        return three_module.k6q
    },
    ezk: function() {
        return three_module.ezk
    },
    NZq: function() {
        return three_module.NZq
    },
    iUH: function() {
        return three_module.iUH
    },
    $_I: function() {
        return three_module.$_I
    },
    kRr: function() {
        return three_module.kRr
    },
    Zr2: function() {
        return three_module.Zr2
    },
    kyO: function() {
        return three_module.kyO
    },
    VxR: function() {
        return three_module.VxR
    },
    aHM: function() {
        return three_module.aHM
    },
    r6x: function() {
        return three_module.r6x
    },
    KPJ: function() {
        return three_module.KPJ
    },
    O0Q: function() {
        return LoadingScreenPlugin
    },
    G3T: function() {
        return three_module.G3T
    },
    lc7: function() {
        return three_module.lc7
    },
    aMy: function() {
        return three_module.aMy
    },
    CMB: function() {
        return three_module.CMB
    },
    Kzv: function() {
        return three_module.Kzv
    },
    kBv: function() {
        return three_module.kBv
    },
    T6P: function() {
        return MTLLoader2
    },
    imn: function() {
        return three_module.imn
    },
    Bhh: function() {
        return MaterialConfiguratorBasePlugin
    },
    q$N: function() {
        return MaterialConfiguratorPlugin
    },
    pzC: function() {
        return MaterialExtender
    },
    xbg: function() {
        return MaterialLibPresetGroupPresetGroup
    },
    LTv: function() {
        return MaterialLibraryBasePlugin
    },
    usO: function() {
        return MaterialLibraryPlugin
    },
    jut: function() {
        return three_module.jut
    },
    Jxy: function() {
        return MaterialManager
    },
    Kmw: function() {
        return MaterialPresetPlugin$1
    },
    jR8: function() {
        return MaterialPreviewGenerator
    },
    cj9: function() {
        return three_module.cj9
    },
    dwI: function() {
        return three_module.dwI
    },
    kn4: function() {
        return three_module.kn4
    },
    $ei: function() {
        return three_module.$ei
    },
    eaF: function() {
        return three_module.eaF
    },
    V9B: function() {
        return three_module.V9B
    },
    NLY: function() {
        return MeshBasicMaterial2
    },
    CSG: function() {
        return three_module.CSG
    },
    aVO: function() {
        return three_module.aVO
    },
    G_z: function() {
        return three_module.G_z
    },
    FNr: function() {
        return three_module.FNr
    },
    qBx: function() {
        return three_module.qBx
    },
    onB: function() {
        return MeshOptSimplifyModifierPlugin
    },
    tXL: function() {
        return three_module.tXL
    },
    uSd: function() {
        return three_module.uSd
    },
    _4j: function() {
        return three_module._4j
    },
    gCR: function() {
        return MeshStandardMaterial2
    },
    Df: function() {
        return three_module.Df
    },
    znC: function() {
        return three_module.znC
    },
    kTW: function() {
        return three_module.kTW
    },
    KRh: function() {
        return three_module.KRh
    },
    $iG: function() {
        return ModelStagePlugin
    },
    eti: function() {
        return ModelStagePresetGroup
    },
    Um5: function() {
        return MouseInputDevice
    },
    tF0: function() {
        return MultiFilterPlugin
    },
    EdD: function() {
        return three_module.EdD
    },
    caT: function() {
        return three_module.caT
    },
    hxR: function() {
        return three_module.hxR
    },
    a$r: function() {
        return three_module.a$r
    },
    $O9: function() {
        return three_module.$O9
    },
    Cfg: function() {
        return three_module.Cfg
    },
    pHI: function() {
        return three_module.pHI
    },
    amv: function() {
        return three_module.amv
    },
    eHc: function() {
        return three_module.eHc
    },
    HPb: function() {
        return three_module.HPb
    },
    XIg: function() {
        return three_module.XIg
    },
    jf0: function() {
        return three_module.jf0
    },
    y_p: function() {
        return three_module.y_p
    },
    dFv: function() {
        return NoiseBumpMaterialPlugin
    },
    Ke9: function() {
        return three_module.Ke9
    },
    NTi: function() {
        return three_module.NTi
    },
    nqf: function() {
        return NormalBufferPlugin
    },
    hws: function() {
        return NormalCaptureMaterial
    },
    jzd: function() {
        return three_module.jzd
    },
    bw0: function() {
        return three_module.bw0
    },
    klZ: function() {
        return three_module.klZ
    },
    Hit: function() {
        return three_module.Hit
    },
    DJz: function() {
        return OBJLoader2
    },
    UwE: function() {
        return ObjMtlLoadPlugin
    },
    B69: function() {
        return three_module.B69
    },
    QA8: function() {
        return Object3DModel
    },
    $xz: function() {
        return Object3DWidgetsPlugin
    },
    XTe: function() {
        return three_module.XTe
    },
    zjB: function() {
        return ObjectLoader2
    },
    sHL: function() {
        return ObjectPicker
    },
    Upe: function() {
        return ObjectProcessorMap
    },
    nEH: function() {
        return ObjectRotationPlugin
    },
    vyJ: function() {
        return three_module.vyJ
    },
    Ufg: function() {
        return three_module.Ufg
    },
    qad: function() {
        return three_module.qad
    },
    Nt7: function() {
        return three_module.Nt7
    },
    aEY: function() {
        return three_module.aEY
    },
    OuU: function() {
        return three_module.OuU
    },
    LiQ: function() {
        return three_module.LiQ
    },
    xYO: function() {
        return OrbitControls2
    },
    c07: function() {
        return OrbitControls3
    },
    qUd: function() {
        return three_module.qUd
    },
    I_i: function() {
        return OutlinePlugin
    },
    wqq: function() {
        return three_module.wqq
    },
    QP0: function() {
        return three_module.QP0
    },
    Wk7: function() {
        return three_module.Wk7
    },
    BdL: function() {
        return three_module.BdL
    },
    Q7O: function() {
        return PMREMGeneratorPlugin
    },
    uxM: function() {
        return ParallaxCameraControllerPlugin
    },
    N9C: function() {
        return ParallaxMappingPlugin
    },
    wAk: function() {
        return three_module.wAk
    },
    ubm: function() {
        return three_module.ubm
    },
    PG6: function() {
        return PickingPlugin
    },
    Zcv: function() {
        return three_module.Zcv
    },
    bdM: function() {
        return three_module.bdM
    },
    ZM4: function() {
        return three_module.ZM4
    },
    _EQ: function() {
        return PluginPresetGroup
    },
    HiM: function() {
        return three_module.HiM
    },
    RXx: function() {
        return PointLight2
    },
    F1l: function() {
        return three_module.F1l
    },
    W_W: function() {
        return Z$1
    },
    FnS: function() {
        return PointerLockControls2
    },
    oPt: function() {
        return PointerLockControlsPlugin
    },
    ONl: function() {
        return three_module.ONl
    },
    BH$: function() {
        return three_module.BH$
    },
    hzE: function() {
        return three_module.hzE
    },
    pFK: function() {
        return three_module.pFK
    },
    j9d: function() {
        return PopmotionPlugin
    },
    DeC: function() {
        return PosePlugin
    },
    xZx: function() {
        return three_module.xZx
    },
    ZaL: function() {
        return PresetGroup
    },
    UwN: function() {
        return PresetLibraryPlugin
    },
    hzf: function() {
        return ProgressivePlugin
    },
    Nwf: function() {
        return three_module.Nwf
    },
    N2s: function() {
        return three_module.N2s
    },
    dAo: function() {
        return three_module.dAo
    },
    CV9: function() {
        return three_module.CV9
    },
    PTz: function() {
        return three_module.PTz
    },
    MBL: function() {
        return three_module.MBL
    },
    GBG: function() {
        return three_module.GBG
    },
    HO_: function() {
        return three_module.HO_
    },
    Kef: function() {
        return three_module.Kef
    },
    sPf: function() {
        return three_module.sPf
    },
    N5j: function() {
        return three_module.N5j
    },
    GWd: function() {
        return three_module.GWd
    },
    c90: function() {
        return three_module.c90
    },
    y3Z: function() {
        return three_module.y3Z
    },
    uB5: function() {
        return three_module.uB5
    },
    lyL: function() {
        return three_module.lyL
    },
    bC7: function() {
        return three_module.bC7
    },
    ojs: function() {
        return three_module.ojs
    },
    S$4: function() {
        return three_module.S$4
    },
    qa3: function() {
        return three_module.qa3
    },
    B_h: function() {
        return three_module.B_h
    },
    czI: function() {
        return three_module.czI
    },
    rSH: function() {
        return three_module.rSH
    },
    Qrf: function() {
        return three_module.Qrf
    },
    psI: function() {
        return three_module.psI
    },
    a5J: function() {
        return three_module.a5J
    },
    _QJ: function() {
        return three_module._QJ
    },
    Fn: function() {
        return three_module.Fn
    },
    KDk: function() {
        return three_module.KDk
    },
    pBf: function() {
        return three_module.pBf
    },
    HXV: function() {
        return three_module.HXV
    },
    Nz6: function() {
        return three_module.Nz6
    },
    jR7: function() {
        return three_module.jR7
    },
    BXX: function() {
        return three_module.BXX
    },
    DAr: function() {
        return three_module.DAr
    },
    uC4: function() {
        return RGBM16ColorSpace_
    },
    H23: function() {
        return three_module.H23
    },
    W9U: function() {
        return three_module.W9U
    },
    CVz: function() {
        return three_module.CVz
    },
    Riy: function() {
        return three_module.Riy
    },
    kTp: function() {
        return three_module.kTp
    },
    k6Q: function() {
        return three_module.k6Q
    },
    IE4: function() {
        return three_module.IE4
    },
    paN: function() {
        return three_module.paN
    },
    TkQ: function() {
        return three_module.TkQ
    },
    qa1: function() {
        return RainbowDiamondPlugin
    },
    EZL: function() {
        return RandomizedDirectionalLight
    },
    fMJ: function() {
        return RandomizedDirectionalLightPlugin
    },
    D$Q: function() {
        return three_module.D$Q
    },
    RlV: function() {
        return three_module.RlV
    },
    tBo: function() {
        return three_module.tBo
    },
    z5: function() {
        return three_module.z5
    },
    ure: function() {
        return three_module.ure
    },
    VT0: function() {
        return three_module.VT0
    },
    ZQM: function() {
        return three_module.ZQM
    },
    TyI: function() {
        return Reflector2
    },
    Mjd: function() {
        return three_module.Mjd
    },
    O0B: function() {
        return three_module.O0B
    },
    FZz: function() {
        return RendererUiPlugin
    },
    GJx: function() {
        return three_module.GJx
    },
    kG0: function() {
        return three_module.kG0
    },
    nST: function() {
        return three_module.nST
    },
    AUf: function() {
        return Rhino3dmLoadPlugin
    },
    oXQ: function() {
        return Rhino3dmLoader2
    },
    rKP: function() {
        return three_module.rKP
    },
    vMJ: function() {
        return RootScene
    },
    CWW: function() {
        return three_module.CWW
    },
    XG_: function() {
        return three_module.XG_
    },
    er$: function() {
        return three_module.er$
    },
    KLL: function() {
        return three_module.KLL
    },
    ye: function() {
        return SSAOPlugin
    },
    czS: function() {
        return SSBevelPass
    },
    UG9: function() {
        return SSBevelPlugin
    },
    aJo: function() {
        return SSContactShadows
    },
    uC9: function() {
        return SSGIPlugin
    },
    k9M: function() {
        return SSRPlugin
    },
    fRH: function() {
        return STLLoadPlugin
    },
    Z58: function() {
        return three_module.Z58
    },
    _I4: function() {
        return SceneCamerasUiPlugin
    },
    Sr: function() {
        return SceneLoopPlugin
    },
    zx2: function() {
        return ScrollableCameraViewPlugin
    },
    r1V: function() {
        return ScrollableCameraViewPreviewPlugin
    },
    tI0: function() {
        return SelectionWidget
    },
    vxI: function() {
        return three_module.vxI
    },
    zkh: function() {
        return three_module.zkh
    },
    BKk: function() {
        return three_module.BKk
    },
    rNP: function() {
        return ShaderMaterial2
    },
    DkA: function() {
        return ShaderMaterialEncodingSupport
    },
    rpH: function() {
        return ShaderPass2
    },
    Q4F: function() {
        return ShadowMapBaker
    },
    q2: function() {
        return three_module.q2
    },
    ypk: function() {
        return three_module.ypk
    },
    MSw: function() {
        return three_module.MSw
    },
    Ld9: function() {
        return three_module.Ld9
    },
    YOp: function() {
        return ShapeTubeExtrudePlugin
    },
    xJ6: function() {
        return three_module.xJ6
    },
    fBL: function() {
        return three_module.fBL
    },
    XTN: function() {
        return SimpleAssetList
    },
    ZXl: function() {
        return SimpleBackgroundEnvUiPlugin
    },
    O9e: function() {
        return SimpleDataSource
    },
    ILd: function() {
        return I$2
    },
    SQN: function() {
        return SimpleJSONExporter
    },
    GDD: function() {
        return SimpleJSONLoader
    },
    HVh: function() {
        return SimpleTextExporter
    },
    X46: function() {
        return SimpleTextPlugin
    },
    hdr: function() {
        return SimpleViewerUi
    },
    CSJ: function() {
        return SimplifyModifierPlugin
    },
    EAD: function() {
        return three_module.EAD
    },
    _xc: function() {
        return three_module._xc
    },
    I46: function() {
        return three_module.I46
    },
    CSm: function() {
        return SnowFallPlugin
    },
    kLi: function() {
        return three_module.kLi
    },
    iyt: function() {
        return three_module.iyt
    },
    Gu$: function() {
        return three_module.Gu$
    },
    s6s: function() {
        return SphereSelectionWidget
    },
    YHV: function() {
        return three_module.YHV
    },
    xOk: function() {
        return three_module.xOk
    },
    xfg: function() {
        return three_module.xfg
    },
    nCl: function() {
        return three_module.nCl
    },
    Hs2: function() {
        return SpotLight2
    },
    Fpm: function() {
        return three_module.Fpm
    },
    kxk: function() {
        return three_module.kxk
    },
    RoJ: function() {
        return three_module.RoJ
    },
    ie2: function() {
        return three_module.ie2
    },
    hgQ: function() {
        return three_module.hgQ
    },
    f4X: function() {
        return three_module.f4X
    },
    Hrq: function() {
        return three_module.Hrq
    },
    agE: function() {
        return three_module.agE
    },
    uXQ: function() {
        return three_module.uXQ
    },
    keZ: function() {
        return three_module.keZ
    },
    rOG: function() {
        return three_module.rOG
    },
    Ktl: function() {
        return three_module.Ktl
    },
    uov: function() {
        return three_module.uov
    },
    hZF: function() {
        return three_module.hZF
    },
    FXf: function() {
        return three_module.FXf
    },
    Kwu: function() {
        return three_module.Kwu
    },
    hv1: function() {
        return SwitchNodeBasePlugin
    },
    AqU: function() {
        return SwitchNodePlugin
    },
    wtR: function() {
        return three_module.wtR
    },
    cGs: function() {
        return R$2
    },
    bI3: function() {
        return three_module.bI3
    },
    afA: function() {
        return TemporalAAPlugin
    },
    Zpd: function() {
        return three_module.Zpd
    },
    gO_: function() {
        return TextSVGOptions
    },
    gPd: function() {
        return three_module.gPd
    },
    Tap: function() {
        return three_module.Tap
    },
    k4W: function() {
        return ThinFilmLayerPlugin
    },
    ndu: function() {
        return ThreeMaterialLoader
    },
    el_: function() {
        return TonemapPlugin
    },
    O3Y: function() {
        return three_module.O3Y
    },
    UPV: function() {
        return three_module.UPV
    },
    iu6: function() {
        return TrackballControlsPlugin
    },
    Ijk: function() {
        return TransformAnimationPlugin
    },
    ZU6: function() {
        return TransformControls
    },
    XXP: function() {
        return TransformControls2
    },
    RQH: function() {
        return TransformControlsGizmo
    },
    tUF: function() {
        return TransformControlsPlane
    },
    Tww: function() {
        return TransfrSharePlugin
    },
    lMl: function() {
        return three_module.lMl
    },
    rYR: function() {
        return three_module.rYR
    },
    O49: function() {
        return three_module.O49
    },
    RJ4: function() {
        return three_module.RJ4
    },
    CXS: function() {
        return TriplanarUVMappingPlugin
    },
    j6: function() {
        return three_module.j6
    },
    G8g: function() {
        return TubeShapeGeometry
    },
    SOP: function() {
        return TweakpaneUiPlugin
    },
    e2_: function() {
        return TweakpaneWrapper
    },
    GTy: function() {
        return three_module.GTy
    },
    cOZ: function() {
        return UChartOptions
    },
    XxD: function() {
        return UPackOptions
    },
    UTZ: function() {
        return three_module.UTZ
    },
    A$4: function() {
        return three_module.A$4
    },
    MW4: function() {
        return three_module.MW4
    },
    baL: function() {
        return three_module.baL
    },
    fc6: function() {
        return three_module.fc6
    },
    t7h: function() {
        return Uncharted2Tonemapping
    },
    nc$: function() {
        return three_module.nc$
    },
    dzP: function() {
        return three_module.dzP
    },
    fCn: function() {
        return three_module.fCn
    },
    LlO: function() {
        return three_module.LlO
    },
    OUM: function() {
        return three_module.OUM
    },
    V3x: function() {
        return three_module.V3x
    },
    bkx: function() {
        return three_module.bkx
    },
    Wew: function() {
        return three_module.Wew
    },
    gJ2: function() {
        return three_module.gJ2
    },
    cHt: function() {
        return three_module.cHt
    },
    HJp: function() {
        return Unzip
    },
    mMi: function() {
        return UnzipInflate
    },
    XLH: function() {
        return UnzipPassThrough
    },
    TWi: function() {
        return Unzlib
    },
    DcJ: function() {
        return VJSONPresetGroup
    },
    Kmx: function() {
        return VRPluginBasic
    },
    RyA: function() {
        return three_module.RyA
    },
    NPD: function() {
        return VariationConfiguratorEditorUiPlugin
    },
    Gpr: function() {
        return VariationConfiguratorGridUiPlugin
    },
    mKI: function() {
        return VariationConfiguratorPlugin
    },
    I9Y: function() {
        return three_module.I9Y
    },
    Pq0: function() {
        return three_module.Pq0
    },
    IUQ: function() {
        return three_module.IUQ
    },
    RiT: function() {
        return three_module.RiT
    },
    Xkr: function() {
        return VelocityBufferPlugin
    },
    Nv2: function() {
        return three_module.Nv2
    },
    EW5: function() {
        return ViewerApp
    },
    oJ0: function() {
        return ViewerState
    },
    Q1b: function() {
        return VignettePlugin
    },
    jK_: function() {
        return VirtualCamerasPlugin
    },
    gTm: function() {
        return WaveGroundPlugin
    },
    S3G: function() {
        return three_module.S3G
    },
    ALV: function() {
        return three_module.ALV
    },
    y9J: function() {
        return three_module.y9J
    },
    TdN: function() {
        return three_module.TdN
    },
    o6l: function() {
        return three_module.o6l
    },
    AT1: function() {
        return three_module.AT1
    },
    nWS: function() {
        return three_module.nWS
    },
    JeP: function() {
        return three_module.JeP
    },
    hfX: function() {
        return three_module.hfX
    },
    i7u: function() {
        return three_module.i7u
    },
    b5D: function() {
        return WebGiViewerElement
    },
    Z1R: function() {
        return WindowiseDialogPlugin
    },
    pWZ: function() {
        return Wireframe
    },
    XJ7: function() {
        return three_module.XJ7
    },
    r3D: function() {
        return WireframeGeometry2
    },
    dhZ: function() {
        return three_module.dhZ
    },
    $Tl: function() {
        return XAtlasPlugin
    },
    rQf: function() {
        return three_module.rQf
    },
    ojh: function() {
        return three_module.ojh
    },
    h2z: function() {
        return three_module.h2z
    },
    kqe: function() {
        return three_module.kqe
    },
    qQr: function() {
        return Zip
    },
    D8L: function() {
        return ZipDeflate
    },
    p9O: function() {
        return ZipLoader
    },
    uZB: function() {
        return ZipPassThrough
    },
    KK: function() {
        return Zlib
    },
    Ua6: function() {
        return three_module.Ua6
    },
    TYE: function() {
        return et
    },
    rQr: function() {
        return addBasePlugins
    },
    $00: function() {
        return addBloomData
    },
    ued: function() {
        return addDracoLoader
    },
    p$A: function() {
        return addEditorPlugins
    },
    m2A: function() {
        return addGLTFExporter
    },
    MqB: function() {
        return addGLTFLoader
    },
    Dv6: function() {
        return addLUTData
    },
    f9i: function() {
        return addRGBELoader
    },
    qHA: function() {
        return addSSBevel
    },
    sQz: function() {
        return Pe$1
    },
    G52: function() {
        return Te$1
    },
    EP1: function() {
        return afterMain
    },
    v5N: function() {
        return afterRead
    },
    SET: function() {
        return afterWrite
    },
    g7h: function() {
        return angle
    },
    i0Z: function() {
        return animate
    },
    GcL: function() {
        return animateAsync
    },
    z67: function() {
        return animateObject
    },
    im4: function() {
        return animateSet
    },
    $bx: function() {
        return animateTarget$1
    },
    btx: function() {
        return anticipate$1
    },
    M7c: function() {
        return applyOffset
    },
    ZMO: function() {
        return modifiers_applyStyles
    },
    YiG: function() {
        return ie$1
    },
    UE8: function() {
        return modifiers_arrow
    },
    uHr: function() {
        return attract
    },
    YYK: function() {
        return attractExpo
    },
    qZL: function() {
        return auto$1
    },
    XMb: function() {
        return autoCenterObject3D
    },
    utC: function() {
        return autoGPUInstanceMeshes
    },
    uO_: function() {
        return autoScaleObject3D
    },
    dgX: function() {
        return backIn$1
    },
    ZZ5: function() {
        return backInOut$1
    },
    Szj: function() {
        return backOut$1
    },
    Ms4: function() {
        return re$1
    },
    OMj: function() {
        return basePlacements
    },
    D7g: function() {
        return basicMaterialPropList
    },
    LG_: function() {
        return beforeMain
    },
    cis: function() {
        return beforeRead
    },
    pAB: function() {
        return beforeWrite
    },
    y80: function() {
        return q$2
    },
    sQg: function() {
        return bottom
    },
    ipZ: function() {
        return bounceIn
    },
    wmn: function() {
        return bounceInOut
    },
    Tel: function() {
        return bounceOut
    },
    Q5: function() {
        return buildCSGMeshBSP
    },
    b1j: function() {
        return buildCSGMeshBVH
    },
    wzf: function() {
        return cLinearToRGBM
    },
    Cq_: function() {
        return cRGBMToLinear
    },
    poN: function() {
        return circIn$1
    },
    tnX: function() {
        return circInOut$1
    },
    yT: function() {
        return circOut$1
    },
    qE8: function() {
        return clamp$1
    },
    WYS: function() {
        return clippingParents
    },
    Cp1: function() {
        return be$1
    },
    mz1: function() {
        return combineDofShader
    },
    Bc: function() {
        return gzip
    },
    oSR: function() {
        return gzipSync
    },
    KJu: function() {
        return computeAverageGeometryNormal
    },
    G1I: function() {
        return computeEigenVectors
    },
    dXm: function() {
        return computeGeometryCenter
    },
    lRj: function() {
        return computeGeometrySize
    },
    WL9: function() {
        return computeMikkTSpaceTangents
    },
    OkM: function() {
        return computeMorphedAttributes
    },
    kRU: function() {
        return computeOffsetMatrix
    },
    Xpo: function() {
        return computeScreenSpaceBoundingBox
    },
    KCp: function() {
        return modifiers_computeStyles
    },
    a17: function() {
        return copyMaterialUserData
    },
    prl: function() {
        return copyObject3DUserData
    },
    ij0: function() {
        return xe$1
    },
    MjE: function() {
        return copyTextureUserData
    },
    bhJ: function() {
        return createAnticipate
    },
    nMR: function() {
        return createAttractor
    },
    p4x: function() {
        return createBackIn
    },
    lPF: function() {
        return three_module.lPF
    },
    SwP: function() {
        return ee$1
    },
    U2C: function() {
        return createExpoIn
    },
    FOd: function() {
        return createGenericExtensionClass
    },
    WOM: function() {
        return createIFrameCSS3DObject
    },
    mFw: function() {
        return T$2
    },
    n4h: function() {
        return popper_createPopper
    },
    eRo: function() {
        return createPopper
    },
    LsR: function() {
        return popper_lite_createPopper
    },
    tJ: function() {
        return createRenderTargetKey
    },
    bES: function() {
        return te$1
    },
    rU: function() {
        return P$2
    },
    omb: function() {
        return csgOperations
    },
    AHW: function() {
        return $
    },
    AKs: function() {
        return cubicBezier$1
    },
    VxZ: function() {
        return dataTextureFromColor
    },
    GRd: function() {
        return dataTextureFromVec4
    },
    TVt: function() {
        return decay
    },
    mFv: function() {
        return decompress
    },
    RqU: function() {
        return decompressSync
    },
    UKN: function() {
        return Se$1
    },
    mmZ: function() {
        return deepCloneAttribute
    },
    Ikv: function() {
        return defaultPresets
    },
    Kcl: function() {
        return deflate
    },
    pdh: function() {
        return deflateSync
    },
    tRv: function() {
        return degreesToRadians
    },
    nNY: function() {
        return deinterleaveAttribute
    },
    LK7: function() {
        return deinterleaveGeometry
    },
    $q: function() {
        return deserializeObject
    },
    vem: function() {
        return deserializers
    },
    __B: function() {
        return detectOverflow
    },
    BF2: function() {
        return diamondMaterialPropList
    },
    IoC: function() {
        return distance$1
    },
    WNF: function() {
        return N$2
    },
    PE3: function() {
        return me$1
    },
    a6C: function() {
        return easeIn$1
    },
    am_: function() {
        return easeInOut$1
    },
    vTE: function() {
        return easeOut$1
    },
    VAT: function() {
        return Ze$1
    },
    _N2: function() {
        return end
    },
    oib: function() {
        return envMapBackground
    },
    NtM: function() {
        return F$1
    },
    ru_: function() {
        return estimateBytesUsed
    },
    GcD: function() {
        return eventListeners
    },
    pJG: function() {
        return extractAnimationKey
    },
    vxL: function() {
        return flattenUiConfig
    },
    UUz: function() {
        return modifiers_flip
    },
    mlk: function() {
        return fontFormatExtensionMap
    },
    SVi: function() {
        return generateUiConfig
    },
    QXJ: function() {
        return generateUiFolder
    },
    D01: function() {
        return Me$1
    },
    $7C: function() {
        return le$1
    },
    cdn: function() {
        return Ue$1
    },
    vGk: function() {
        return Re$1
    },
    GPz: function() {
        return Ee$1
    },
    NxN: function() {
        return H$2
    },
    o7j: function() {
        return getTexelDecoding
    },
    yqR: function() {
        return getTexelDecodingFunction
    },
    U_j: function() {
        return getTextureDataType
    },
    mB_: function() {
        return se$1
    },
    d6c: function() {
        return rt
    },
    zhG: function() {
        return glbEncryptionPreparser
    },
    HJb: function() {
        return fe$1
    },
    e5R: function() {
        return gltfExporterMaterialsVariantsExtensionExport
    },
    kdR: function() {
        return gunzip
    },
    D85: function() {
        return gunzipSync
    },
    ZIX: function() {
        return gzip
    },
    u3y: function() {
        return gzipSync
    },
    jDu: function() {
        return modifiers_hide
    },
    qyt: function() {
        return de$1
    },
    Dtr: function() {
        return Qe$1
    },
    WKP: function() {
        return je$1
    },
    fJV: function() {
        return z$2
    },
    tC7: function() {
        return iGeometryIgnoredUserData
    },
    Uan: function() {
        return iMaterialIgnoredUserData
    },
    Uct: function() {
        return iModelIgnoredUserData
    },
    K_U: function() {
        return iTextureIgnoredUserData
    },
    BFA: function() {
        return Ne$1
    },
    BHX: function() {
        return We$1
    },
    Pee: function() {
        return V$2
    },
    $If: function() {
        return He$1
    },
    RFY: function() {
        return Ce$1
    },
    Buv: function() {
        return inertia$1
    },
    UDz: function() {
        return inflate
    },
    HMP: function() {
        return inflateSync
    },
    Zg4: function() {
        return interleaveAttributes
    },
    GWP: function() {
        return interpolate$1
    },
    r58: function() {
        return isAnimatableType
    },
    fTC: function() {
        return isPoint
    },
    YWz: function() {
        return isPoint3D
    },
    eAs: function() {
        return W$2
    },
    i7C: function() {
        return keyframes$1
    },
    jFo: function() {
        return khrMaterialsVariantsGLTF
    },
    kbd: function() {
        return left
    },
    nU8: function() {
        return lerpAngle
    },
    NFx: function() {
        return lerpAngle2
    },
    sns: function() {
        return linear
    },
    S2G: function() {
        return he$1
    },
    iW4: function() {
        return main
    },
    Se$: function() {
        return Je$1
    },
    Sop: function() {
        return Ge$1
    },
    HNH: function() {
        return makeFilter
    },
    jGz: function() {
        return makeSamplerUi
    },
    ll7: function() {
        return makeSetterFor
    },
    SrG: function() {
        return Xe$1
    },
    UGD: function() {
        return matDefine
    },
    KVf: function() {
        return mergeAttributes
    },
    gDN: function() {
        return mergeBufferAttributes
    },
    h0o: function() {
        return mergeBufferGeometries
    },
    pPQ: function() {
        return mergeGeometries
    },
    hLo: function() {
        return mergeGroups
    },
    ecu: function() {
        return mergeVertices
    },
    mhB: function() {
        return mirrorEasing$1
    },
    jhA: function() {
        return mix$1
    },
    iou: function() {
        return mixColor$1
    },
    JL8: function() {
        return mixComplex$1
    },
    G8Z: function() {
        return we$1
    },
    GMB: function() {
        return modifierPhases
    },
    tB5: function() {
        return g
    },
    GnX: function() {
        return v$3
    },
    cYW: function() {
        return modifiers_offset
    },
    k9K: function() {
        return x$1
    },
    CTC: function() {
        return ze$1
    },
    JW6: function() {
        return Ae$1
    },
    p7C: function() {
        return ae$1
    },
    OId: function() {
        return patchShaderEncodingSupport
    },
    CN_: function() {
        return ot
    },
    uaX: function() {
        return physicalMaterialPropList
    },
    FsL: function() {
        return pipe$1
    },
    gtD: function() {
        return pivotToBBoxCenter
    },
    wbL: function() {
        return pivotToPoint
    },
    DDu: function() {
        return enums_placements
    },
    O$W: function() {
        return pointFromVector
    },
    xfb: function() {
        return popper
    },
    UD3: function() {
        return popperGenerator
    },
    ZoD: function() {
        return modifiers_popperOffsets
    },
    hQ_: function() {
        return pe$1
    },
    V7C: function() {
        return modifiers_preventOverflow
    },
    Sow: function() {
        return processViewer
    },
    qB0: function() {
        return progress$1
    },
    nv6: function() {
        return radiansToDegrees
    },
    LF4: function() {
        return enums_read
    },
    TAg: function() {
        return Fe$1
    },
    irg: function() {
        return reference
    },
    Ei4: function() {
        return ct
    },
    Grb: function() {
        return removeDuplicateGeometries
    },
    yhl: function() {
        return f$1
    },
    Gmo: function() {
        return reverseEasing$1
    },
    pGT: function() {
        return right
    },
    Gsh: function() {
        return rotateDuplicatedMesh
    },
    S2Q: function() {
        return three_module.S2Q
    },
    pUp: function() {
        return S$2
    },
    sU3: function() {
        return serializable
    },
    lKg: function() {
        return serialize
    },
    gwL: function() {
        return serializeObject
    },
    EBS: function() {
        return serializeTextureInExtras
    },
    YCG: function() {
        return serializers
    },
    gC: function() {
        return setMeshGeometry
    },
    R5k: function() {
        return setMeshMaterial
    },
    zB$: function() {
        return setThreeRendererMode
    },
    dGw: function() {
        return st
    },
    tNl: function() {
        return setupCoreWebGiViewer
    },
    AAd: function() {
        return setupIModel
    },
    YFt: function() {
        return setupModesStyles
    },
    IRk: function() {
        return setupModesUi
    },
    ZVX: function() {
        return setupObject3dModel
    },
    cTN: function() {
        return setupSandboxWebGiEditor
    },
    PlU: function() {
        return shaderReplaceString
    },
    Mi5: function() {
        return sign2
    },
    nuN: function() {
        return slerp
    },
    Jp2: function() {
        return smooth
    },
    oDA: function() {
        return smoothFrame
    },
    n$K: function() {
        return snap
    },
    w4b: function() {
        return snapObject
    },
    JVv: function() {
        return sphericalFromObject
    },
    ozl: function() {
        return spring$1
    },
    asH: function() {
        return standardMaterialPropList
    },
    niF: function() {
        return start
    },
    CiD: function() {
        return steps_steps
    },
    heq: function() {
        return strFromU8
    },
    _uk: function() {
        return strToU8
    },
    xrZ: function() {
        return supportsRequestStreams
    },
    aUi: function() {
        return L$2
    },
    Tmf: function() {
        return J$1
    },
    AYr: function() {
        return B$2
    },
    SVO: function() {
        return texImageToCanvas
    },
    mBH: function() {
        return textureDataToImageData
    },
    z73: function() {
        return textureToCanvas
    },
    cyN: function() {
        return textureToDataUrl
    },
    wRz: function() {
        return X$2
    },
    pbX: function() {
        return toCreasedNormals
    },
    nIf: function() {
        return toDecimal
    },
    RY5: function() {
        return toIndexedGeometry
    },
    SnO: function() {
        return oe$1
    },
    _cJ: function() {
        return toTrianglesDrawMode
    },
    Mny: function() {
        return enums_top
    },
    X0G: function() {
        return uiButton
    },
    mBY: function() {
        return uiColor
    },
    rpQ: function() {
        return uiConfig
    },
    exO: function() {
        return uiDropdown
    },
    rsv: function() {
        return uiFolder
    },
    gpt: function() {
        return uiImage
    },
    hEL: function() {
        return uiInput
    },
    LIx: function() {
        return uiMonitor
    },
    Z5F: function() {
        return uiPanel
    },
    Eiw: function() {
        return uiSlider
    },
    Jx6: function() {
        return uiToggle
    },
    q00: function() {
        return uiVector
    },
    PiW: function() {
        return uniform
    },
    $15: function() {
        return unzip
    },
    AOo: function() {
        return unzipSync
    },
    VTi: function() {
        return unzlib
    },
    a8Y: function() {
        return unzlibSync
    },
    QMY: function() {
        return ge$1
    },
    d5o: function() {
        return vLinearToRGBM
    },
    Fxe: function() {
        return vRGBMToLinear
    },
    Nan: function() {
        return valueToUiType
    },
    Ols: function() {
        return variationPlacements
    },
    Ovn: function() {
        return velocityPerFrame
    },
    fjO: function() {
        return velocityPerSecond$1
    },
    pZl: function() {
        return Be$1
    },
    R9T: function() {
        return viewport
    },
    LV7: function() {
        return wrap
    },
    M98: function() {
        return write
    },
    _h9: function() {
        return $e$1
    },
    yU6: function() {
        return zip
    },
    LaF: function() {
        return zipSync
    },
    w58: function() {
        return zlib
    },
    $ax: function() {
        return zlibSync
    }
}),
function(d) {
    d[d.Error = -2] = "Error",
    d[d.Destroyed = -1] = "Destroyed",
    d[d.None = 0] = "None",
    d[d.Running = 1] = "Running",
    d[d.Paused = 2] = "Paused"
}(ViewerState || (ViewerState = {}));
let I$2 = class {
    constructor() {
        this._eventListeners = {},
        this.dispatchEvent = this.dispatchEvent.bind(this),
        this.addEventListener = this.addEventListener.bind(this),
        this.removeEventListener = this.removeEventListener.bind(this),
        this.hasEventListener = this.hasEventListener.bind(this)
    }
    addEventListener(o, c) {
        const h = this._eventListeners;
        h[o] === void 0 && (h[o] = []),
        h[o].includes(c) || h[o].push(c)
    }
    hasEventListener(o, c) {
        const h = this._eventListeners;
        return h[o] !== void 0 && h[o].includes(c)
    }
    removeEventListener(o, c) {
        const h = this._eventListeners[o];
        if (h !== void 0) {
            const _ = h.indexOf(c);
            _ !== -1 && h.splice(_, 1)
        }
    }
    dispatchEvent(o) {
        const c = this._eventListeners[o.type];
        if (c !== void 0) {
            o.target = this;
            const h = c.slice(0);
            for (let _ = 0, b = h.length; _ < b; _++)
                h[_].call(this, o)
        }
    }
}
;
async function X$2(d) {
    return new Promise(o => setTimeout(o, Math.max(0, d)))
}
function g() {
    return (typeof performance > "u" ? Date : performance).now()
}
let Z$1 = class extends I$2 {
    constructor() {
        super(...arguments),
        this._onPointerDown = o => {
            if (o.button !== 0 || !this._element)
                return;
            this._pointerUp = void 0;
            const c = o.clientX / this._element.clientWidth * 2 - 1
              , h = -o.clientY / this._element.clientHeight * 2 + 1
              , _ = g();
            this._pointerDown = {
                x: c,
                y: h,
                time: _
            },
            this._pointer = this._pointerDown,
            this.dispatchEvent({
                type: "dragStart",
                pointer: this._pointerDown
            })
        }
        ,
        this._onPointerMove = o => {
            if (!this._pointerDown || !this._pointer || !this._element)
                return;
            const c = o.clientX / this._element.clientWidth * 2 - 1
              , h = -o.clientY / this._element.clientHeight * 2 + 1
              , _ = g();
            this.dispatchEvent({
                type: "drag",
                pointer: this._pointer,
                drag: {
                    x: c - this._pointerDown.x,
                    y: h - this._pointerDown.y,
                    time: _ - this._pointerDown.time
                },
                delta: {
                    x: c - this._pointer.x,
                    y: h - this._pointer.y,
                    time: _ - this._pointer.time
                }
            }),
            this._pointer = {
                x: c,
                y: h,
                time: g()
            },
            o.buttons % 2 == 0 && this._onPointerUp(o)
        }
        ,
        this._onPointerUp = o => {
            if (o.button !== 0 || !this._pointerDown || !this._element)
                return;
            const c = o.clientX / this._element.clientWidth * 2 - 1
              , h = -o.clientY / this._element.clientHeight * 2 + 1
              , _ = g();
            this._pointerUp = {
                x: c,
                y: h,
                time: _
            },
            this.dispatchEvent({
                type: "dragEnd",
                pointer: this._pointerUp,
                drag: {
                    x: this._pointerUp.x - this._pointerDown.x,
                    y: this._pointerUp.y - this._pointerDown.y,
                    time: this._pointerUp.time - this._pointerDown.time
                }
            }),
            this._pointerDown = void 0,
            this._pointer = void 0
        }
    }
    get element() {
        return this._element
    }
    set element(o) {
        this._element !== o && (this._element && this._removeElement(),
        this._element = o,
        this._element && this._addElement())
    }
    _removeElement() {
        var o, c, h, _, b;
        (o = this._element) == null || o.removeEventListener("pointerdown", this._onPointerDown),
        (c = this._element) == null || c.removeEventListener("pointermove", this._onPointerMove),
        (h = this._element) == null || h.removeEventListener("pointerup", this._onPointerUp),
        (_ = this._element) == null || _.removeEventListener("pointercancel", this._onPointerUp),
        (b = this._element) == null || b.removeEventListener("pointerout", this._onPointerUp)
    }
    _addElement() {
        var o, c, h, _, b;
        (o = this._element) == null || o.addEventListener("pointerdown", this._onPointerDown),
        (c = this._element) == null || c.addEventListener("pointermove", this._onPointerMove),
        (h = this._element) == null || h.addEventListener("pointerup", this._onPointerUp),
        (_ = this._element) == null || _.addEventListener("pointercancel", this._onPointerUp),
        (b = this._element) == null || b.addEventListener("pointerout", this._onPointerUp)
    }
    dispose() {
        this.element = void 0
    }
}
  , Q$2 = class {
    constructor(o) {
        this.options = {
            limit: 500,
            debug: !1,
            bindHotKeys: !1
        },
        this.enabled = !0,
        this.presets = {},
        this._keyDown = c => {
            if (!this.enabled)
                return;
            const h = c.ctrlKey || c.metaKey;
            c.code === "KeyZ" && h && !c.shiftKey ? this.undo() : (c.code === "KeyZ" && h && c.shiftKey || c.code === "KeyY" && c.ctrlKey) && this.redo()
        }
        ,
        Object.assign(this.options, o),
        this.limit = o.limit,
        this.options = o,
        this.reset(),
        o.bindHotKeys && this.bindHotKeys(),
        this.log(`Initialized with stack limit of ${this.limit} commands`)
    }
    bindHotKeys() {
        return this.log("Bound 'undo' and 'redo' actions to 'Ctrl/Cmd+Z', 'Ctrl+Y' & 'Ctrl/Cmd+Shift+Z' hot keys"),
        (this.options.hotKeyRoot ?? document).addEventListener("keydown", this._keyDown),
        this
    }
    dispose() {
        return (this.options.hotKeyRoot ?? document).removeEventListener("keydown", this._keyDown),
        this.reset()
    }
    record(o) {
        return this.enabled ? (this._record(o),
        this) : this
    }
    replaceLast(o) {
        const c = this.peek();
        if (c)
            return this.log("replace", c, "with", o),
            this.stack[this.sp] = o,
            this
    }
    execute(o) {
        if (!this.enabled)
            return;
        let c = this._rc(o)
          , h = c.redo;
        return this.record.apply(this, c),
        this.log("Executing function..."),
        h.apply(o),
        this
    }
    _rc(o) {
        if (o.type) {
            const c = this.presets[o.type];
            if (typeof c == "function")
                return c(o);
            throw console.error(o, c, this.presets),
            new Error("Preset command not found")
        }
        return o
    }
    _record(o) {
        this.enabled && (this.log("Recording command", o),
        this._rebase(),
        this.stack.push(o),
        this.sp++,
        this._keepLimit())
    }
    _rebase() {
        this.canRedo() && (this.stack.length = this.sp + 1)
    }
    _keepLimit() {
        if (this.stack.length <= this.limit)
            return;
        let o = this.stack.length - this.limit;
        this.log("Stack size reached its limit: ${this.limit} commands. Cutting off most old commands..."),
        o === 1 ? this.stack.shift() : this.stack.splice(0, o),
        this.sp -= o
    }
    undo() {
        if (!this.canUndo())
            return this;
        let o = this.stack[this.sp];
        return this.log("undo"),
        this.sp--,
        this._rc(o).undo(),
        this
    }
    canUndo() {
        return this.sp >= 0 && this.enabled
    }
    peek() {
        return this.canUndo() ? this.stack[this.sp] : null
    }
    redo() {
        if (!this.canRedo())
            return this;
        let o = this.stack[this.sp + 1];
        return this.log("redo"),
        this.sp++,
        this._rc(o).redo(),
        this
    }
    canRedo() {
        return this.sp < this.stack.length - 1 && this.enabled
    }
    peekForward() {
        return this.canRedo() ? this.stack[this.sp + 1] : null
    }
    setLimit(o) {
        let c = this.stack.length - this.sp - 1;
        if (o < 1 || typeof o != "number")
            throw new TypeError(`JSUndoManager.setLimit(): unexpected argument limit=${o}. Should be a positive number`);
        return o < c ? console.warn(`JSUndoManager.setLimit(): cannot set stack limit (${o}) less than the number of 'redoable' commands (${c})`) : (this.limit = Math.floor(o),
        this._keepLimit()),
        this
    }
    reset() {
        return this.log("reset"),
        this.stack = [],
        this.sp = -1,
        this
    }
    isEmpty() {
        return !this.stack.length
    }
    isFull() {
        return this.stack.length === this.limit
    }
    getSize() {
        return this.stack.length
    }
    log(o, ...c) {
        this.options.debug && console.log(`Command Manager: ${o}`, ...c)
    }
}
;
const p$3 = class Dy {
    constructor(o=Dy.DECAY_MILLISECONDS) {
        this.velocity = 0,
        this.naturalFrequency = 0,
        this.setDecayTime(o)
    }
    setDecayTime(o) {
        this.naturalFrequency = 1 / Math.max(Dy.MIN_DECAY_MILLISECONDS, o)
    }
    update(o, c, h, _) {
        const b = 2e-4 * this.naturalFrequency;
        if (o == null || _ === 0 || o === c && this.velocity === 0)
            return c;
        if (h < 0)
            return o;
        const _e = o - c
          , nt = this.velocity + this.naturalFrequency * _e
          , it = _e + h * nt
          , at = Math.exp(-this.naturalFrequency * h)
          , ut = (nt - this.naturalFrequency * it) * at
          , pt = -this.naturalFrequency * (ut + nt * at);
        return Math.abs(ut) < b * Math.abs(_) && pt * _e >= 0 ? (this.velocity = 0,
        c) : (this.velocity = ut,
        c + it * at)
    }
}
;
p$3.SETTLING_TIME = 1e4,
p$3.MIN_DECAY_MILLISECONDS = .001,
p$3.DECAY_MILLISECONDS = 50;
let k$1 = p$3;
function j() {
    const d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    return d.style.display = "block",
    d
}
function ee$1({innerHTML: d="", id: o, classList: c, addToBody: h=!0, elementTag: _="div"}) {
    const b = document.createElement(_);
    return o && (b.id = o),
    b.innerHTML = d,
    c && b.classList.add(...c),
    h && document.body.appendChild(b),
    b
}
async function T$2(d) {
    return new Promise( (o, c) => {
        const h = new Image;
        h.onload = () => o(h),
        h.onerror = c,
        h.crossOrigin = "anonymous",
        h.decoding = "sync",
        h.src = d
    }
    )
}
function P$2(d, o=document.head) {
    const c = document.createElement("style");
    return c.type = "text/css",
    c.innerText = d,
    o == null || o.appendChild(c),
    c
}
async function te$1(d, o=document.head) {
    return new Promise( (c, h) => {
        const _ = document.createElement("script");
        _.setAttribute("src", d),
        _.addEventListener("load", () => c(_)),
        _.addEventListener("error", h),
        o.appendChild(_)
    }
    )
}
function ie$1(d) {
    if (!window)
        return console.warn("window is required"),
        "";
    let o = "";
    const c = new Uint8Array(d)
      , h = c.byteLength;
    for (let _ = 0; _ < h; _++)
        o += String.fromCharCode(c[_]);
    return window.btoa(o)
}
function re$1(d) {
    if (!window)
        return console.warn("window is required"),
        new Uint8Array(0);
    const o = window.atob(d)
      , c = o.length
      , h = new Uint8Array(c);
    for (let _ = 0; _ < c; _++)
        h[_] = o.charCodeAt(_);
    return h.buffer
}
const R$2 = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};
function se$1(d, o) {
    return new R$2[d](o)
}
function oe$1(d) {
    return d.replace(/\w\S*/g, function(o) {
        return o.charAt(0).toUpperCase() + o.substr(1).toLowerCase()
    })
}
function ae$1(d) {
    if (!d || d === "" || d.match(/__MACOSX\/.*\._/))
        return "";
    const o = (d = d.replace(/\?.*$/, "")).split(/[\\/]/).pop() ?? ""
      , c = o.lastIndexOf(".");
    return o === "" || c < 1 ? "" : o.slice(c + 1)
}
function le$1(d) {
    return d.substring(d.lastIndexOf("/") + 1)
}
function F$1(d) {
    return d.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1")
}
function f$1(d, o, c) {
    return d.replace(new RegExp(F$1(o),"g"), c)
}
function he$1(d) {
    return d.sort(),
    d[0].split("").map( (o, c) => d[d.length - 1][c] === o ? o : "\0").join("").split("\0").at(0) || ""
}
const fe$1 = (d, ...o) => String.raw({
    raw: d
}, ...o)
  , $ = (d, ...o) => String.raw({
    raw: d
}, ...o)
  , de$1 = (d, ...o) => String.raw({
    raw: d
}, ...o)
  , B$2 = (d, ...o) => {
    let c = String.raw({
        raw: d
    }, ...o);
    return c = f$1(c, "%", "%25"),
    c = f$1(c, "> <", "><"),
    c = f$1(c, "; }", ";}"),
    c = f$1(c, "<", "%3c"),
    c = f$1(c, ">", "%3e"),
    c = f$1(c, '"', "'"),
    c = f$1(c, "#", "%23"),
    c = f$1(c, "{", "%7b"),
    c = f$1(c, "}", "%7d"),
    c = f$1(c, "|", "%7c"),
    c = f$1(c, "^", "%5e"),
    c = f$1(c, "`", "%60"),
    c = f$1(c, "@", "%40"),
    c = f$1(c, "&", "&amp;"),
    c = f$1(c, `
`, "%0A"),
    "data:image/svg+xml;charset=UTF-8," + c
}
;
function pe$1(d=document.head) {
    return P$2($`
      ::-webkit-scrollbar
      {
        width: 8px;  /* for vertical scrollbars */
        height: 8px; /* for horizontal scrollbars */
      }
      ::-webkit-scrollbar-track
      {
        background: rgba(64, 64, 64, 0.4);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-thumb
      {
        background: rgba(128, 128, 128, 0.2);
        border-radius: 6px;
      }
      ::-webkit-scrollbar-corner {background: rgba(0,0,0,0.5);}
    `, d)
}
function N$2(d, o) {
    const c = window.URL.createObjectURL(d)
      , h = document.createElement("a");
    h.style.display = "none",
    h.href = c,
    h.download = o,
    document.body.appendChild(h),
    h.click(),
    setTimeout( () => {
        document.body.removeChild(h),
        window.URL.revokeObjectURL(c)
    }
    , 1e3)
}
async function q$2(d) {
    return new Promise( (o, c) => {
        const h = new FileReader;
        h.onload = _ => o(h.result),
        h.onerror = _ => c(h.error),
        h.onabort = _ => c(new Error("Read aborted")),
        h.readAsDataURL(d)
    }
    )
}
function me$1(d, o) {
    return N$2(d, o ?? d.name)
}
async function ge$1(d=!1, o=!1, c) {
    const h = document.createElement("input");
    h.type = "file",
    h.multiple = d,
    h.accept = c || "*",
    h.webkitdirectory = o,
    h.style.display = "none",
    document.body.appendChild(h),
    h.click();
    const _ = await new Promise(b => {
        h.onchange = _e => {
            b(Array.from(h.files || []))
        }
    }
    );
    return document.body.removeChild(h),
    _
}
function we$1() {
    let d = !1;
    return function(o) {
        (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(o) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(o.substr(0, 4))) && (d = !0)
    }(navigator.userAgent || navigator.vendor || window.opera),
    d
}
function ve$1(d) {
    return d < .0031308 ? 12.92 * d : 1.055 * Math.pow(d, .41666) - .055
}
function be$1(d, o=1, c=1) {
    const h = document.createElement("canvas");
    h.width = o,
    h.height = c;
    const _ = h.getContext("2d");
    _.fillStyle = "#" + d,
    _.fillRect(0, 0, o, c);
    const b = h.toDataURL();
    return h.remove(),
    b
}
function H$2(d, o) {
    let c;
    do
        c = Object.getOwnPropertyDescriptor(d, o);
    while (!c && (d = Object.getPrototypeOf(d)));
    return c
}
function W$2(d, o, c=!0, h=!1) {
    const _ = H$2(d, o);
    return !(_ == null || !_.set) || c && (_ == null ? void 0 : _.writable) !== !1 && (_ == null ? void 0 : _.get) === void 0 || h && !_
}
function S$2(d, o, c, h=!0, _=!1) {
    return !(!d || !W$2(d, o, h, _) || (d[o] = c,
    0))
}
function Ee$1(d, ...o) {
    return typeof d == "function" && (d = d(...o)),
    d
}
function xe$1(d, o, c) {
    for (const h of c) {
        const _ = d[h];
        _ !== void 0 && S$2(o, h, _, !0)
    }
    return o
}
function Ce$1(d, o) {
    for (const c of o)
        if (!d.includes(c))
            return !1;
    return !0
}
function Se$1(d, o, c=!1) {
    for (typeof d == "string" && (d = d.split(".")); d.length > 0; ) {
        if (!o)
            return o;
        const h = d.splice(0, 1)[0];
        if (!(h.length < 1))
            if (Array.isArray(o))
                o = o[parseInt(h)];
            else {
                if (typeof o != "object" || !(h in o)) {
                    if (c)
                        throw new Error("invalid access, check " + h + " in " + o);
                    return
                }
                o = o[h]
            }
    }
    return o
}
function Ue$1(d, o) {
    return Object.keys(d).find(c => d[c] === o)
}
function v$3(d, o) {
    return Object.hasOwn ? Object.hasOwn(d, o) : d.hasOwnProperty(o)
}
const m$2 = class A0 {
    static callFunction(o, c, h=[]) {
        if (!c)
            return o(...h);
        if (o.name && c[o.name] === o)
            return o.call(c, ...h);
        A0.methodMap.has(c) || A0.methodMap.set(c, new WeakMap);
        const _ = A0.methodMap.get(c);
        if (!_.has(o)) {
            let b = c;
            for (; b; ) {
                const _e = Object.values(Object.getOwnPropertyDescriptors(b));
                for (let nt of _e)
                    if (nt.value === o)
                        return _.set(o, !0),
                        o.call(c, ...h);
                b = Object.getPrototypeOf(b)
            }
            _.set(o, !1)
        }
        return _.get(o) ? o.call(c, ...h) : o(...h)
    }
}
;
m$2.methodMap = new WeakMap;
let E$2 = m$2;
function x$1(d, o="param") {
    if (!d)
        throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return (c, h, _) => {
        const b = {
            get() {
                return this[`_oc_${h}`]
            },
            set(_e) {
                var nt;
                const it = this[`_oc_${h}`];
                if (it === _e)
                    return;
                this[`_oc_${h}`] = _e;
                const at = o === "param" ? [h, _e, it, this] : o === "object" ? [{
                    key: h,
                    value: _e,
                    oldValue: it,
                    target: this
                }] : [];
                typeof d == "string" ? (nt = this[d]) == null || nt.call(this, ...at) : typeof d == "function" && E$2.callFunction(d, this, at)
            }
        };
        if (_)
            return v$3(_, "value") && delete _.value,
            v$3(_, "writable") && delete _.writable,
            v$3(_, "initializer") && delete _.initializer,
            Object.assign(_, b);
        Object.defineProperty(c, h, b)
    }
}
function ze$1(d, o="void") {
    if (!d)
        throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return x$1(d, o)
}
function Ae$1(d, o="object") {
    if (!d)
        throw new Error("onChange: fnKey is undefined, make sure the function exists or provide a string");
    return x$1(d, o)
}
async function Te$1(d, o, c) {
    const h = typeof o == "string" ? new TextEncoder().encode(o) : o
      , _ = await crypto.subtle.digest("SHA-256", h)
      , b = crypto.getRandomValues(new Uint8Array(12))
      , _e = Array.from(b).map(St => String.fromCharCode(St)).join("")
      , nt = {
        name: "AES-GCM",
        iv: b
    }
      , it = await crypto.subtle.importKey("raw", _, nt, !1, ["encrypt"])
      , at = typeof d == "string" ? new TextEncoder().encode(d) : d
      , ut = await crypto.subtle.encrypt(nt, it, at)
      , pt = new Uint8Array(ut)
      , ht = Array.from(pt)
      , _t = ht.map(St => String.fromCharCode(St)).join("")
      , vt = c ? typeof c == "string" ? c : new TextDecoder().decode(c) : ""
      , bt = c ? typeof c == "string" ? new TextEncoder().encode(c) : Array.from(c) : [];
    return typeof d == "string" ? vt + _e + _t : new Uint8Array([...bt, ...b, ...ht])
}
async function Pe$1(d, o) {
    const c = typeof o == "string" ? new TextEncoder().encode(o) : o
      , h = await crypto.subtle.digest("SHA-256", c)
      , _ = d.slice(0, 12)
      , b = {
        name: "AES-GCM",
        iv: typeof _ == "string" ? new Uint8Array(Array.from(_).map(at => at.charCodeAt(0))) : _
    }
      , _e = await crypto.subtle.importKey("raw", h, b, !1, ["decrypt"])
      , nt = d.slice(12)
      , it = typeof nt == "string" ? new Uint8Array(Array.from(nt).map(at => at.charCodeAt(0))) : nt;
    try {
        const at = await crypto.subtle.decrypt(b, _e, it);
        return typeof d == "string" ? new TextDecoder().decode(at) : new Uint8Array(at)
    } catch {
        throw new Error("Decrypt failed")
    }
}
async function Me$1() {
    return "showOpenFilePicker"in window ? window.showOpenFilePicker().then(d => d[0]) : window.chooseFileSystemEntries()
}
function Re$1() {
    if ("showSaveFilePicker"in window) {
        const d = {
            types: [{
                description: "Text file",
                accept: {
                    "text/plain": [".txt"]
                }
            }]
        };
        return window.showSaveFilePicker(d)
    }
    return window.chooseFileSystemEntries({
        type: "save-file",
        accepts: [{
            description: "Text file",
            extensions: ["txt"],
            mimeTypes: ["text/plain"]
        }]
    })
}
function Fe$1(d) {
    return d.text ? d.text() : K$2(d)
}
function K$2(d) {
    return new Promise(o => {
        const c = new FileReader;
        c.addEventListener("loadend", h => {
            const _ = (h.srcElement || h.target).result;
            o(_)
        }
        ),
        c.readAsText(d)
    }
    )
}
async function $e$1(d, o) {
    if (d.createWriter) {
        const h = await d.createWriter();
        return await h.write(0, o),
        void await h.close()
    }
    const c = await d.createWritable();
    await c.write(o),
    await c.close()
}
async function Be$1(d, o) {
    const c = {};
    return o && (c.writable = !0,
    c.mode = "readwrite"),
    await d.queryPermission(c) === "granted" || await d.requestPermission(c) === "granted"
}
function U$2(d, o=8192, c=!1) {
    var h;
    if (!d.width || !d.height)
        throw new Error("Invalid bitmap");
    const _ = document.createElement("canvas");
    _.width = Math.min(o, d.width),
    _.height = Math.floor(1 + _.width * d.height / d.width);
    const b = d instanceof ImageBitmap
      , _e = b && c && Math.abs(_.width - d.width) < .5 ? _.getContext("bitmaprenderer") : void 0;
    return _e ? _e.transferFromImageBitmap(d) : (h = _.getContext("2d")) == null || h.drawImage(d, 0, 0, _.width, _.height),
    b && c && d.close(),
    _
}
function Ne$1(d, o=8192, c=!1, h="image/png") {
    if (!d.width || !d.height)
        return "";
    const _ = U$2(d, o, !1)
      , b = _.toDataURL(h);
    return _.remove(),
    c && d instanceof ImageBitmap && d.close(),
    b
}
async function He$1(d) {
    return new Promise( (o, c) => {
        const h = new Image;
        h.addEventListener("load", () => {
            const _ = document.createElement("canvas");
            _.width = h.width,
            _.height = h.height;
            const b = _.getContext("2d");
            if (!b)
                return void c(new Error("Could not get 2d context"));
            b.drawImage(h, 0, 0, _.width, _.height);
            const _e = b.getImageData(0, 0, _.width, _.height);
            o(_e),
            _.remove(),
            h.remove()
        }
        , !1),
        h.addEventListener("error", _ => {
            h.remove(),
            c(_)
        }
        , !1),
        h.src = d
    }
    )
}
function V$2(d, {backgroundColor: o="", scale: c=1, width: h=512, height: _=512}) {
    const b = document.createElement("canvas")
      , _e = b.getContext("2d")
      , nt = c
      , it = h
      , at = _;
    return b.width = it * nt,
    b.height = at * nt,
    b.style.width = `${it}`,
    b.style.height = `${at}`,
    (o == null ? void 0 : o.length) > 0 && (_e.fillStyle = o,
    _e.fillRect(0, 0, b.width, b.height)),
    _e.drawImage(d, 0, 0, b.width, b.height),
    b
}
function We$1(d) {
    const o = document.createElement("canvas");
    return o.width = d.width,
    o.height = d.height,
    o.getContext("2d").putImageData(d, 0, 0),
    o
}
function Ke$1(d) {
    const o = document.createElement("canvas");
    o.width = d.width,
    o.height = d.height;
    const c = o.getContext("2d");
    if (!c)
        throw new Error("Unable to get 2d context");
    return c.translate(0, d.height),
    c.scale(1, -1),
    c.drawImage(d, 0, 0),
    o
}
const Je$1 = d => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='16' height='16' fill='%23${d}'/%3E%3C/svg%3E%0A`
  , Ge$1 = d => `data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='8' cy='8' r='7' fill='%23${d}'/%3E%3C/svg%3E%0A`
  , Xe$1 = d => `data:image/svg+xml,%3Csvg viewBox='0 0 80 14' xmlns='http://www.w3.org/2000/svg'%3E%3Ctext style='font: 8px "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace; fill: white;' x='9' y='9'%3E${d}%3C/text%3E%3C/svg%3E%0A`
  , L$2 = async (d, o) => V$2(await T$2(d), o)
  , J$1 = async (d, o) => await L$2(d, o).then(c => c.toDataURL("image/png"))
  , G$2 = async d => q$2(await (await fetch(d)).blob());
async function Ze$1(d, o=G$2) {
    const c = d.match(/(((ftp|https?):\/\/)[\-\w@:%_\+.~#?,&\/\/=]+)/g);
    if (c)
        for (const h of c) {
            const _ = await o(h);
            d = d.replace(h, _)
        }
    return d
}
function z$2(d, o, {width: c, height: h}, _=!0) {
    const b = `
<svg viewBox="0 0 ${c} ${h}" xmlns="http://www.w3.org/2000/svg">
    <style>
    ${o}
    </style>
    <foreignObject x="0" y="0" width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml" style="height: 100%; width: 100%; position: absolute: top:0; left:0">
            ${d}
        </div>
    </foreignObject>
</svg>
    `;
    return _ ? B$2(b) : b
}
async function Qe$1(d, o, c) {
    const h = z$2(d, o, c);
    return await L$2(h, c)
}
async function je$1(d, o, c) {
    const h = z$2(d, o, c);
    return await J$1(h, c)
}
function et(d, o) {
    return Math.abs(d) > Math.abs(o) ? d : o
}
function rt(d, o=null) {
    return new URL(window.location.href).searchParams.get(d) ?? o
}
function st(d, o, c=!1) {
    const h = new URLSearchParams(location.search);
    o == null ? h.has(d) && h.delete(d) : h.set(d, o),
    c ? window.location.search = h.toString() : window.history.replaceState({}, "", "?" + h.toString())
}
function ot(d, o="/") {
    return d.join(o)
}
function ct(d, o) {
    const c = (o ? `var Module = { locateFile: function(s) { return "${o}"; } }; 
` : "") + `importScripts( "${d}" );`;
    return URL.createObjectURL(new Blob([c],{
        type: "text/javascript"
    }))
}
var three_module = __webpackgi_require__(848);
const CopyShader = {
    name: "CopyShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        opacity: {
            value: 1
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
};
class Pass {
    constructor() {
        this.isPass = !0,
        this.enabled = !0,
        this.needsSwap = !0,
        this.clear = !1,
        this.renderToScreen = !1
    }
    setSize() {}
    render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.")
    }
    dispose() {}
}
const _camera = new three_module.qUd(-1,1,1,-1,0,1)
  , _geometry = new three_module.LoY;
_geometry.setAttribute("position", new three_module.qtW([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
_geometry.setAttribute("uv", new three_module.qtW([0, 2, 0, 0, 2, 0],2));
class FullScreenQuad {
    constructor(o) {
        this._mesh = new three_module.eaF(_geometry,o)
    }
    dispose() {
        this._mesh.geometry.dispose()
    }
    render(o) {
        o.render(this._mesh, _camera)
    }
    get material() {
        return this._mesh.material
    }
    set material(o) {
        this._mesh.material = o
    }
}
class ShaderPass extends Pass {
    constructor(o, c) {
        super(),
        this.textureID = c !== void 0 ? c : "tDiffuse",
        o instanceof three_module.BKk ? (this.uniforms = o.uniforms,
        this.material = o) : o && (this.uniforms = three_module.LlO.clone(o.uniforms),
        this.material = new three_module.BKk({
            name: o.name !== void 0 ? o.name : "unspecified",
            defines: Object.assign({}, o.defines),
            uniforms: this.uniforms,
            vertexShader: o.vertexShader,
            fragmentShader: o.fragmentShader
        })),
        this.fsQuad = new FullScreenQuad(this.material),
        this.useExistingRenderTarget = !1
    }
    render(o, c, h) {
        this.uniforms[this.textureID] && h && (this.uniforms[this.textureID].value = h.texture),
        this.fsQuad.material = this.material,
        this.renderToScreen ? (o.setRenderTarget(null),
        this.fsQuad.render(o)) : (this.useExistingRenderTarget || o.setRenderTarget(c || null),
        this.clear && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil),
        this.fsQuad.render(o))
    }
    dispose() {
        this.material.dispose(),
        this.fsQuad.dispose()
    }
}
class MaskPass extends Pass {
    constructor(o, c) {
        super(),
        this.scene = o,
        this.camera = c,
        this.clear = !0,
        this.needsSwap = !1,
        this.inverse = !1
    }
    render(o, c, h) {
        const _ = o.getContext()
          , b = o.state;
        let _e, nt;
        b.buffers.color.setMask(!1),
        b.buffers.depth.setMask(!1),
        b.buffers.color.setLocked(!0),
        b.buffers.depth.setLocked(!0),
        this.inverse ? (_e = 0,
        nt = 1) : (_e = 1,
        nt = 0),
        b.buffers.stencil.setTest(!0),
        b.buffers.stencil.setOp(_.REPLACE, _.REPLACE, _.REPLACE),
        b.buffers.stencil.setFunc(_.ALWAYS, _e, 4294967295),
        b.buffers.stencil.setClear(nt),
        b.buffers.stencil.setLocked(!0),
        o.setRenderTarget(h),
        this.clear && o.clear(),
        o.render(this.scene, this.camera),
        o.setRenderTarget(c),
        this.clear && o.clear(),
        o.render(this.scene, this.camera),
        b.buffers.color.setLocked(!1),
        b.buffers.depth.setLocked(!1),
        b.buffers.color.setMask(!0),
        b.buffers.depth.setMask(!0),
        b.buffers.stencil.setLocked(!1),
        b.buffers.stencil.setFunc(_.EQUAL, 1, 4294967295),
        b.buffers.stencil.setOp(_.KEEP, _.KEEP, _.KEEP),
        b.buffers.stencil.setLocked(!0)
    }
}
class ClearMaskPass extends Pass {
    constructor() {
        super(),
        this.needsSwap = !1
    }
    render(o) {
        o.state.buffers.stencil.setLocked(!1),
        o.state.buffers.stencil.setTest(!1)
    }
}
class EffectComposer {
    constructor(o, c) {
        if (this.renderer = o,
        this._pixelRatio = o.getPixelRatio(),
        c === void 0) {
            const h = o.getSize(new three_module.I9Y);
            this._width = h.width,
            this._height = h.height,
            (c = new three_module.nWS(this._width * this._pixelRatio,this._height * this._pixelRatio,{
                type: three_module.ix0
            })).texture.name = "EffectComposer.rt1"
        } else
            this._width = c.width,
            this._height = c.height;
        this.renderTarget1 = c,
        this.renderTarget2 = c.clone(),
        this.renderTarget2.texture.name = "EffectComposer.rt2",
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2,
        this.renderToScreen = !0,
        this.passes = [],
        this.copyPass = new ShaderPass(CopyShader),
        this.copyPass.material.blending = three_module.XIg,
        this.clock = new three_module.zD7
    }
    swapBuffers() {
        const o = this.readBuffer;
        this.readBuffer = this.writeBuffer,
        this.writeBuffer = o
    }
    addPass(o) {
        this.passes.push(o),
        o.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    insertPass(o, c) {
        this.passes.splice(c, 0, o),
        o.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
    }
    removePass(o) {
        const c = this.passes.indexOf(o);
        c !== -1 && this.passes.splice(c, 1)
    }
    isLastEnabledPass(o) {
        for (let c = o + 1; c < this.passes.length; c++)
            if (this.passes[c].enabled)
                return !1;
        return !0
    }
    render(o) {
        o === void 0 && (o = this.clock.getDelta());
        const c = this.renderer.getRenderTarget();
        let h = !1;
        for (let _ = 0, b = this.passes.length; _ < b; _++) {
            const _e = this.passes[_];
            if (_e.enabled !== !1) {
                if (_e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(_),
                _e.render(this.renderer, this.writeBuffer, this.readBuffer, o, h),
                _e.needsSwap) {
                    if (h) {
                        const nt = this.renderer.getContext()
                          , it = this.renderer.state.buffers.stencil;
                        it.setFunc(nt.NOTEQUAL, 1, 4294967295),
                        this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, o),
                        it.setFunc(nt.EQUAL, 1, 4294967295)
                    }
                    this.swapBuffers()
                }
                MaskPass !== void 0 && (_e instanceof MaskPass ? h = !0 : _e instanceof ClearMaskPass && (h = !1))
            }
        }
        this.renderer.setRenderTarget(c)
    }
    reset(o) {
        if (o === void 0) {
            const c = this.renderer.getSize(new three_module.I9Y);
            this._pixelRatio = this.renderer.getPixelRatio(),
            this._width = c.width,
            this._height = c.height,
            (o = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        }
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.renderTarget1 = o,
        this.renderTarget2 = o.clone(),
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2
    }
    setSize(o, c) {
        this._width = o,
        this._height = c;
        const h = this._width * this._pixelRatio
          , _ = this._height * this._pixelRatio;
        this.renderTarget1.setSize(h, _),
        this.renderTarget2.setSize(h, _);
        for (let b = 0; b < this.passes.length; b++)
            this.passes[b].setSize(h, _)
    }
    setPixelRatio(o) {
        this._pixelRatio = o,
        this.setSize(this._width, this._height)
    }
    dispose() {
        this.renderTarget1.dispose(),
        this.renderTarget2.dispose(),
        this.copyPass.dispose()
    }
}
class EffectComposer2 extends EffectComposer {
    constructor(o, c) {
        super(o, c)
    }
    setPixelRatio(o, c=!0) {
        const h = this.setSize;
        c || (this.setSize = () => {}
        ),
        super.setPixelRatio(o),
        c || (this.setSize = h)
    }
}
class Box3B extends three_module.NRn {
    expandByObject(o, c=!1, h=!1, _) {
        var b;
        if (((b = o.userData) === null || b === void 0 ? void 0 : b.bboxVisible) === !1)
            return this;
        if (!o.visible && h)
            return this;
        if (_ && _(o))
            return this;
        if (o.updateWorldMatrix(!1, !1),
        o.boundingBox !== void 0)
            o.boundingBox === null && o.computeBoundingBox(),
            _box.copy(o.boundingBox),
            _box.applyMatrix4(o.matrixWorld),
            this.union(_box);
        else {
            const nt = o.geometry;
            if (nt !== void 0)
                if (c && nt.attributes != null && nt.attributes.position !== void 0) {
                    const it = nt.attributes.position;
                    for (let at = 0, ut = it.count; at < ut; at++)
                        _vector.fromBufferAttribute(it, at).applyMatrix4(o.matrixWorld),
                        this.expandByPoint(_vector)
                } else
                    nt.boundingBox === null && nt.computeBoundingBox(),
                    _box.copy(nt.boundingBox),
                    _box.applyMatrix4(o.matrixWorld),
                    this.union(_box)
        }
        const _e = o.children;
        for (let nt = 0, it = _e.length; nt < it; nt++)
            this.expandByObject(_e[nt], c, h, _);
        return this
    }
    expandByObjects(o, c=!1, h=!1, _) {
        for (let b = 0, _e = o.length; b < _e; b++)
            this.expandByObject(o[b], c, h, _);
        return this
    }
    getPoints() {
        return [new three_module.Pq0(this.min.x,this.min.y,this.min.z), new three_module.Pq0(this.min.x,this.min.y,this.max.z), new three_module.Pq0(this.min.x,this.max.y,this.min.z), new three_module.Pq0(this.min.x,this.max.y,this.max.z), new three_module.Pq0(this.max.x,this.min.y,this.min.z), new three_module.Pq0(this.max.x,this.min.y,this.max.z), new three_module.Pq0(this.max.x,this.max.y,this.min.z), new three_module.Pq0(this.max.x,this.max.y,this.max.z)]
    }
    getScreenSpaceBounds(o) {
        const c = this.getPoints()
          , h = new three_module.UtB;
        for (const _ of c) {
            const b = _.project(o);
            h.min.min(b),
            h.max.max(b)
        }
        return h
    }
}
const _box = new Box3B
  , _vector = new three_module.Pq0;
function computeMikkTSpaceTangents(d, o, c=!0) {
    if (!o || !o.isReady)
        throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
    if (!d.hasAttribute("position") || !d.hasAttribute("normal") || !d.hasAttribute("uv"))
        throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
    function h(_e) {
        if (_e.normalized || _e.isInterleavedBufferAttribute) {
            const nt = new Float32Array(_e.count * _e.itemSize);
            for (let it = 0, at = 0; it < _e.count; it++)
                nt[at++] = _e.getX(it),
                nt[at++] = _e.getY(it),
                _e.itemSize > 2 && (nt[at++] = _e.getZ(it));
            return nt
        }
        return _e.array instanceof Float32Array ? _e.array : new Float32Array(_e.array)
    }
    const _ = d.index ? d.toNonIndexed() : d
      , b = o.generateTangents(h(_.attributes.position), h(_.attributes.normal), h(_.attributes.uv));
    if (c)
        for (let _e = 3; _e < b.length; _e += 4)
            b[_e] *= -1;
    return _.setAttribute("tangent", new three_module.THS(b,4)),
    d !== _ && d.copy(_),
    d
}
function mergeGeometries(d, o=!1) {
    const c = d[0].index !== null
      , h = new Set(Object.keys(d[0].attributes))
      , _ = new Set(Object.keys(d[0].morphAttributes))
      , b = {}
      , _e = {}
      , nt = d[0].morphTargetsRelative
      , it = new three_module.LoY;
    let at = 0;
    for (let ut = 0; ut < d.length; ++ut) {
        const pt = d[ut];
        let ht = 0;
        if (c !== (pt.index !== null))
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + ut + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),
            null;
        for (const _t in pt.attributes) {
            if (!h.has(_t))
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + ut + '. All geometries must have compatible attributes; make sure "' + _t + '" attribute exists among all geometries, or in none of them.'),
                null;
            b[_t] === void 0 && (b[_t] = []),
            b[_t].push(pt.attributes[_t]),
            ht++
        }
        if (ht !== h.size)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + ut + ". Make sure all geometries have the same number of attributes."),
            null;
        if (nt !== pt.morphTargetsRelative)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + ut + ". .morphTargetsRelative must be consistent throughout all geometries."),
            null;
        for (const _t in pt.morphAttributes) {
            if (!_.has(_t))
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + ut + ".  .morphAttributes must be consistent throughout all geometries."),
                null;
            _e[_t] === void 0 && (_e[_t] = []),
            _e[_t].push(pt.morphAttributes[_t])
        }
        if (o) {
            let _t;
            if (c)
                _t = pt.index.count;
            else {
                if (pt.attributes.position === void 0)
                    return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + ut + ". The geometry must have either an index or a position attribute"),
                    null;
                _t = pt.attributes.position.count
            }
            it.addGroup(at, _t, ut),
            at += _t
        }
    }
    if (c) {
        let ut = 0;
        const pt = [];
        for (let ht = 0; ht < d.length; ++ht) {
            const _t = d[ht].index;
            for (let vt = 0; vt < _t.count; ++vt)
                pt.push(_t.getX(vt) + ut);
            ut += d[ht].attributes.position.count
        }
        it.setIndex(pt)
    }
    for (const ut in b) {
        const pt = mergeAttributes(b[ut]);
        if (!pt)
            return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + ut + " attribute."),
            null;
        it.setAttribute(ut, pt)
    }
    for (const ut in _e) {
        const pt = _e[ut][0].length;
        if (pt === 0)
            break;
        it.morphAttributes = it.morphAttributes || {},
        it.morphAttributes[ut] = [];
        for (let ht = 0; ht < pt; ++ht) {
            const _t = [];
            for (let bt = 0; bt < _e[ut].length; ++bt)
                _t.push(_e[ut][bt][ht]);
            const vt = mergeAttributes(_t);
            if (!vt)
                return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + ut + " morphAttribute."),
                null;
            it.morphAttributes[ut].push(vt)
        }
    }
    return it
}
function mergeAttributes(d) {
    let o, c, h, _ = -1, b = 0;
    for (let at = 0; at < d.length; ++at) {
        const ut = d[at];
        if (ut.isInterleavedBufferAttribute)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported."),
            null;
        if (o === void 0 && (o = ut.array.constructor),
        o !== ut.array.constructor)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),
            null;
        if (c === void 0 && (c = ut.itemSize),
        c !== ut.itemSize)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),
            null;
        if (h === void 0 && (h = ut.normalized),
        h !== ut.normalized)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),
            null;
        if (_ === -1 && (_ = ut.gpuType),
        _ !== ut.gpuType)
            return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),
            null;
        b += ut.array.length
    }
    const _e = new o(b);
    let nt = 0;
    for (let at = 0; at < d.length; ++at)
        _e.set(d[at].array, nt),
        nt += d[at].array.length;
    const it = new three_module.THS(_e,c,h);
    return _ !== void 0 && (it.gpuType = _),
    it
}
function deepCloneAttribute(d) {
    return d.isInstancedInterleavedBufferAttribute || d.isInterleavedBufferAttribute ? deinterleaveAttribute(d) : d.isInstancedBufferAttribute ? new three_module.uWO().copy(d) : new three_module.THS().copy(d)
}
function interleaveAttributes(d) {
    let o, c = 0, h = 0;
    for (let at = 0, ut = d.length; at < ut; ++at) {
        const pt = d[at];
        if (o === void 0 && (o = pt.array.constructor),
        o !== pt.array.constructor)
            return console.error("AttributeBuffers of different types cannot be interleaved"),
            null;
        c += pt.array.length,
        h += pt.itemSize
    }
    const _ = new three_module.eB$(new o(c),h);
    let b = 0;
    const _e = []
      , nt = ["getX", "getY", "getZ", "getW"]
      , it = ["setX", "setY", "setZ", "setW"];
    for (let at = 0, ut = d.length; at < ut; at++) {
        const pt = d[at]
          , ht = pt.itemSize
          , _t = pt.count
          , vt = new three_module.eHs(_,ht,b,pt.normalized);
        _e.push(vt),
        b += ht;
        for (let bt = 0; bt < _t; bt++)
            for (let St = 0; St < ht; St++)
                vt[it[St]](bt, pt[nt[St]](bt))
    }
    return _e
}
function deinterleaveAttribute(d) {
    const o = d.data.array.constructor
      , c = d.count
      , h = d.itemSize
      , _ = d.normalized
      , b = new o(c * h);
    let _e;
    _e = d.isInstancedInterleavedBufferAttribute ? new three_module.uWO(b,h,_,d.meshPerAttribute) : new three_module.THS(b,h,_);
    for (let nt = 0; nt < c; nt++)
        _e.setX(nt, d.getX(nt)),
        h >= 2 && _e.setY(nt, d.getY(nt)),
        h >= 3 && _e.setZ(nt, d.getZ(nt)),
        h >= 4 && _e.setW(nt, d.getW(nt));
    return _e
}
function deinterleaveGeometry(d) {
    const o = d.attributes
      , c = d.morphTargets
      , h = new Map;
    for (const _ in o) {
        const b = o[_];
        b.isInterleavedBufferAttribute && (h.has(b) || h.set(b, deinterleaveAttribute(b)),
        o[_] = h.get(b))
    }
    for (const _ in c) {
        const b = c[_];
        b.isInterleavedBufferAttribute && (h.has(b) || h.set(b, deinterleaveAttribute(b)),
        c[_] = h.get(b))
    }
}
function estimateBytesUsed(d) {
    let o = 0;
    for (const h in d.attributes) {
        const _ = d.getAttribute(h);
        o += _.count * _.itemSize * _.array.BYTES_PER_ELEMENT
    }
    const c = d.getIndex();
    return o += c ? c.count * c.itemSize * c.array.BYTES_PER_ELEMENT : 0,
    o
}
function mergeVertices(d, o=1e-4) {
    const c = o > 0;
    o = Math.max(o, Number.EPSILON);
    const h = {}
      , _ = d.getIndex()
      , b = d.getAttribute("position")
      , _e = _ ? _.count : b.count;
    let nt = 0;
    const it = Object.keys(d.attributes)
      , at = {}
      , ut = {}
      , pt = []
      , ht = ["getX", "getY", "getZ", "getW"]
      , _t = ["setX", "setY", "setZ", "setW"];
    for (let Pt = 0, It = it.length; Pt < It; Pt++) {
        const Dt = it[Pt]
          , Gt = d.attributes[Dt];
        at[Dt] = new three_module.THS(new Gt.array.constructor(Gt.count * Gt.itemSize),Gt.itemSize,Gt.normalized);
        const Bt = d.morphAttributes[Dt];
        Bt && (ut[Dt] = new three_module.THS(new Bt.array.constructor(Bt.count * Bt.itemSize),Bt.itemSize,Bt.normalized))
    }
    const vt = .5 * o
      , bt = Math.log10(1 / o)
      , St = Math.pow(10, bt)
      , At = vt * St;
    for (let Pt = 0; Pt < _e; Pt++) {
        const It = _ ? _.getX(Pt) : Pt;
        let Dt = "";
        for (let Gt = 0, Bt = it.length; Gt < Bt && c; Gt++) {
            const kt = it[Gt]
              , Ut = d.getAttribute(kt)
              , Ht = Ut.itemSize;
            for (let Kt = 0; Kt < Ht; Kt++)
                Dt += ~~(Ut[ht[Kt]](It) * St + At) + ","
        }
        if (c && Dt in h)
            pt.push(h[Dt]);
        else {
            for (let Gt = 0, Bt = it.length; Gt < Bt; Gt++) {
                const kt = it[Gt]
                  , Ut = d.getAttribute(kt)
                  , Ht = d.morphAttributes[kt]
                  , Kt = Ut.itemSize
                  , Jt = at[kt]
                  , or = ut[kt];
                for (let ir = 0; ir < Kt; ir++) {
                    const lr = ht[ir]
                      , ar = _t[ir];
                    if (Jt[ar](nt, Ut[lr](It)),
                    Ht)
                        for (let hr = 0, gr = Ht.length; hr < gr; hr++)
                            or[hr][ar](nt, Ht[hr][lr](It))
                }
            }
            c && (h[Dt] = nt),
            pt.push(nt),
            nt++
        }
    }
    const Et = d.clone();
    for (const Pt in d.attributes) {
        const It = at[Pt];
        if (Et.setAttribute(Pt, new three_module.THS(It.array.slice(0, nt * It.itemSize),It.itemSize,It.normalized)),
        Pt in ut)
            for (let Dt = 0; Dt < ut[Pt].length; Dt++) {
                const Gt = ut[Pt][Dt];
                Et.morphAttributes[Pt][Dt] = new three_module.THS(Gt.array.slice(0, nt * Gt.itemSize),Gt.itemSize,Gt.normalized)
            }
    }
    return Et.setIndex(pt),
    Et
}
function toTrianglesDrawMode(d, o) {
    if (o === three_module.RJ4)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        d;
    if (o === three_module.rYR || o === three_module.O49) {
        let c = d.getIndex();
        if (c === null) {
            const _e = []
              , nt = d.getAttribute("position");
            if (nt === void 0)
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                d;
            for (let it = 0; it < nt.count; it++)
                _e.push(it);
            d.setIndex(_e),
            c = d.getIndex()
        }
        const h = c.count - 2
          , _ = [];
        if (o === three_module.rYR)
            for (let _e = 1; _e <= h; _e++)
                _.push(c.getX(0)),
                _.push(c.getX(_e)),
                _.push(c.getX(_e + 1));
        else
            for (let _e = 0; _e < h; _e++)
                _e % 2 == 0 ? (_.push(c.getX(_e)),
                _.push(c.getX(_e + 1)),
                _.push(c.getX(_e + 2))) : (_.push(c.getX(_e + 2)),
                _.push(c.getX(_e + 1)),
                _.push(c.getX(_e)));
        _.length / 3 !== h && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const b = d.clone();
        return b.setIndex(_),
        b.clearGroups(),
        b
    }
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", o),
    d
}
function computeMorphedAttributes(d) {
    const o = new three_module.Pq0
      , c = new three_module.Pq0
      , h = new three_module.Pq0
      , _ = new three_module.Pq0
      , b = new three_module.Pq0
      , _e = new three_module.Pq0
      , nt = new three_module.Pq0
      , it = new three_module.Pq0
      , at = new three_module.Pq0;
    function ut(hr, gr, dr, cr, Ar, wr, Rr, Cr) {
        o.fromBufferAttribute(gr, Ar),
        c.fromBufferAttribute(gr, wr),
        h.fromBufferAttribute(gr, Rr);
        const tr = hr.morphTargetInfluences;
        if (dr && tr) {
            nt.set(0, 0, 0),
            it.set(0, 0, 0),
            at.set(0, 0, 0);
            for (let fr = 0, vr = dr.length; fr < vr; fr++) {
                const Zr = tr[fr]
                  , rn = dr[fr];
                Zr !== 0 && (_.fromBufferAttribute(rn, Ar),
                b.fromBufferAttribute(rn, wr),
                _e.fromBufferAttribute(rn, Rr),
                cr ? (nt.addScaledVector(_, Zr),
                it.addScaledVector(b, Zr),
                at.addScaledVector(_e, Zr)) : (nt.addScaledVector(_.sub(o), Zr),
                it.addScaledVector(b.sub(c), Zr),
                at.addScaledVector(_e.sub(h), Zr)))
            }
            o.add(nt),
            c.add(it),
            h.add(at)
        }
        hr.isSkinnedMesh && (hr.applyBoneTransform(Ar, o),
        hr.applyBoneTransform(wr, c),
        hr.applyBoneTransform(Rr, h)),
        Cr[3 * Ar + 0] = o.x,
        Cr[3 * Ar + 1] = o.y,
        Cr[3 * Ar + 2] = o.z,
        Cr[3 * wr + 0] = c.x,
        Cr[3 * wr + 1] = c.y,
        Cr[3 * wr + 2] = c.z,
        Cr[3 * Rr + 0] = h.x,
        Cr[3 * Rr + 1] = h.y,
        Cr[3 * Rr + 2] = h.z
    }
    const pt = d.geometry
      , ht = d.material;
    let _t, vt, bt;
    const St = pt.index
      , At = pt.attributes.position
      , Et = pt.morphAttributes.position
      , Pt = pt.morphTargetsRelative
      , It = pt.attributes.normal
      , Dt = pt.morphAttributes.position
      , Gt = pt.groups
      , Bt = pt.drawRange;
    let kt, Ut, Ht, Kt, Jt, or, ir;
    const lr = new Float32Array(At.count * At.itemSize)
      , ar = new Float32Array(It.count * It.itemSize);
    if (St !== null)
        if (Array.isArray(ht))
            for (kt = 0,
            Ht = Gt.length; kt < Ht; kt++)
                for (Jt = Gt[kt],
                or = Math.max(Jt.start, Bt.start),
                ir = Math.min(Jt.start + Jt.count, Bt.start + Bt.count),
                Ut = or,
                Kt = ir; Ut < Kt; Ut += 3)
                    _t = St.getX(Ut),
                    vt = St.getX(Ut + 1),
                    bt = St.getX(Ut + 2),
                    ut(d, At, Et, Pt, _t, vt, bt, lr),
                    ut(d, It, Dt, Pt, _t, vt, bt, ar);
        else
            for (or = Math.max(0, Bt.start),
            ir = Math.min(St.count, Bt.start + Bt.count),
            kt = or,
            Ht = ir; kt < Ht; kt += 3)
                _t = St.getX(kt),
                vt = St.getX(kt + 1),
                bt = St.getX(kt + 2),
                ut(d, At, Et, Pt, _t, vt, bt, lr),
                ut(d, It, Dt, Pt, _t, vt, bt, ar);
    else if (Array.isArray(ht))
        for (kt = 0,
        Ht = Gt.length; kt < Ht; kt++)
            for (Jt = Gt[kt],
            or = Math.max(Jt.start, Bt.start),
            ir = Math.min(Jt.start + Jt.count, Bt.start + Bt.count),
            Ut = or,
            Kt = ir; Ut < Kt; Ut += 3)
                _t = Ut,
                vt = Ut + 1,
                bt = Ut + 2,
                ut(d, At, Et, Pt, _t, vt, bt, lr),
                ut(d, It, Dt, Pt, _t, vt, bt, ar);
    else
        for (or = Math.max(0, Bt.start),
        ir = Math.min(At.count, Bt.start + Bt.count),
        kt = or,
        Ht = ir; kt < Ht; kt += 3)
            _t = kt,
            vt = kt + 1,
            bt = kt + 2,
            ut(d, At, Et, Pt, _t, vt, bt, lr),
            ut(d, It, Dt, Pt, _t, vt, bt, ar);
    return {
        positionAttribute: At,
        normalAttribute: It,
        morphedPositionAttribute: new three_module.qtW(lr,3),
        morphedNormalAttribute: new three_module.qtW(ar,3)
    }
}
function mergeGroups(d) {
    if (d.groups.length === 0)
        return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),
        d;
    let o = d.groups;
    if (o = o.sort( (_e, nt) => _e.materialIndex !== nt.materialIndex ? _e.materialIndex - nt.materialIndex : _e.start - nt.start),
    d.getIndex() === null) {
        const _e = d.getAttribute("position")
          , nt = [];
        for (let it = 0; it < _e.count; it += 3)
            nt.push(it, it + 1, it + 2);
        d.setIndex(nt)
    }
    const c = d.getIndex()
      , h = [];
    for (let _e = 0; _e < o.length; _e++) {
        const nt = o[_e]
          , it = nt.start
          , at = it + nt.count;
        for (let ut = it; ut < at; ut++)
            h.push(c.getX(ut))
    }
    d.dispose(),
    d.setIndex(h);
    let _ = 0;
    for (let _e = 0; _e < o.length; _e++) {
        const nt = o[_e];
        nt.start = _,
        _ += nt.count
    }
    let b = o[0];
    d.groups = [b];
    for (let _e = 1; _e < o.length; _e++) {
        const nt = o[_e];
        b.materialIndex === nt.materialIndex ? b.count += nt.count : (b = nt,
        d.groups.push(b))
    }
    return d
}
function toCreasedNormals(d, o=Math.PI / 3) {
    const c = Math.cos(o)
      , h = 100 * (1 + 1e-10)
      , _ = [new three_module.Pq0, new three_module.Pq0, new three_module.Pq0]
      , b = new three_module.Pq0
      , _e = new three_module.Pq0
      , nt = new three_module.Pq0
      , it = new three_module.Pq0;
    function at(bt) {
        return `${~~(bt.x * h)},${~~(bt.y * h)},${~~(bt.z * h)}`
    }
    const ut = d.index ? d.toNonIndexed() : d
      , pt = ut.attributes.position
      , ht = {};
    for (let bt = 0, St = pt.count / 3; bt < St; bt++) {
        const At = 3 * bt
          , Et = _[0].fromBufferAttribute(pt, At + 0)
          , Pt = _[1].fromBufferAttribute(pt, At + 1)
          , It = _[2].fromBufferAttribute(pt, At + 2);
        b.subVectors(It, Pt),
        _e.subVectors(Et, Pt);
        const Dt = new three_module.Pq0().crossVectors(b, _e).normalize();
        for (let Gt = 0; Gt < 3; Gt++) {
            const Bt = at(_[Gt]);
            Bt in ht || (ht[Bt] = []),
            ht[Bt].push(Dt)
        }
    }
    const _t = new Float32Array(3 * pt.count)
      , vt = new three_module.THS(_t,3,!1);
    for (let bt = 0, St = pt.count / 3; bt < St; bt++) {
        const At = 3 * bt
          , Et = _[0].fromBufferAttribute(pt, At + 0)
          , Pt = _[1].fromBufferAttribute(pt, At + 1)
          , It = _[2].fromBufferAttribute(pt, At + 2);
        b.subVectors(It, Pt),
        _e.subVectors(Et, Pt),
        nt.crossVectors(b, _e).normalize();
        for (let Dt = 0; Dt < 3; Dt++) {
            const Gt = ht[at(_[Dt])];
            it.set(0, 0, 0);
            for (let Bt = 0, kt = Gt.length; Bt < kt; Bt++) {
                const Ut = Gt[Bt];
                nt.dot(Ut) > c && it.add(Ut)
            }
            it.normalize(),
            vt.setXYZ(At + Dt, it.x, it.y, it.z)
        }
    }
    return ut.setAttribute("normal", vt),
    ut
}
function mergeBufferGeometries(d, o=!1) {
    return console.warn("THREE.BufferGeometryUtils: mergeBufferGeometries() has been renamed to mergeGeometries()."),
    mergeGeometries(d, o)
}
function mergeBufferAttributes(d) {
    return console.warn("THREE.BufferGeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."),
    mergeAttributes(d)
}
function computeScreenSpaceBoundingBox(d, o) {
    let c, h;
    if (Array.isArray(d))
        for (const b of d) {
            const _e = computeScreenSpaceBoundingBox(b, o);
            c === void 0 || h === void 0 ? (c = _e.min.clone(),
            h = _e.max.clone()) : (c.min(_e.min),
            h.max(_e.max))
        }
    const _ = d;
    if (_.geometry !== void 0) {
        const b = _.geometry.vertices;
        if (b === void 0 && _.geometry.attributes !== void 0 && "position"in _.geometry.attributes) {
            const _e = new three_module.Pq0
              , nt = _.geometry.attributes.position;
            for (let it = 0; it < nt.count * nt.itemSize; it += nt.itemSize) {
                _e.set(nt.array[it], nt.array[it + 1], nt.array[3]);
                const at = _e.applyMatrix4(d.matrixWorld).project(o)
                  , ut = new three_module.I9Y(at.x,at.y);
                c === void 0 || h === void 0 ? (c = ut.clone(),
                h = ut.clone()) : (c.min(ut),
                h.max(ut))
            }
        } else
            for (const _e of b) {
                const nt = _e.clone().applyMatrix4(d.matrixWorld).project(o)
                  , it = new three_module.I9Y(nt.x,nt.y);
                c === void 0 || h === void 0 ? (c = it.clone(),
                h = it.clone()) : (c.min(it),
                h.max(it))
            }
    }
    if (d.children !== void 0)
        for (const b of d.children) {
            const _e = computeScreenSpaceBoundingBox(b, o);
            c === void 0 || h === void 0 ? (c = _e.min.clone(),
            h = _e.max.clone()) : (c.min(_e.min),
            h.max(_e.max))
        }
    return new three_module.UtB(c,h)
}
const RGBM16ColorSpace_ = "rgbm-16";
function getTexelDecodingFunction(d, o) {
    let c;
    switch (o) {
    case three_module.jf0:
    case three_module.Zr2:
    case three_module.er$:
        c = "";
        break;
    case three_module.DAr:
        c = "RGBM16ToLinear";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported color space:", o),
        c = ""
    }
    return `#define ${d}( value ) ${c} ( value )`
}
function getTexelDecoding(d, o) {
    return getTexelDecodingFunction(d + "TexelToLinear", o ?? three_module.Zr2) + `
`
}
function uniform({uniforms: d, propKey: o, thisTarget: c=!1}={}) {
    const h = !!d
      , _ = !!o
      , b = c;
    return (_e, nt) => {
        const it = at => {
            const ut = b ? at : h ? d : at.uniforms || at._uniforms;
            let pt = _ ? o : nt;
            b && (pt = "_" + pt);
            let ht = ut[pt];
            return ht || (ht = {
                value: null
            },
            ut[pt] = ht),
            ht
        }
        ;
        Object.defineProperty(_e, nt, {
            get() {
                return it(this).value
            },
            set(at) {
                it(this).value = at,
                S$2(this, "uniformsNeedUpdate", !0, !0)
            }
        })
    }
}
function matDefine(d, o, c=!1, h) {
    const _ = !!o
      , b = !!d;
    return (_e, nt) => {
        const it = at => ({
            t: _ ? o : at.defines || at._defines,
            p: b ? d : nt
        });
        Object.defineProperty(_e, nt, {
            get() {
                const {t: at, p: ut} = it(c ? this : this.material);
                return at[ut]
            },
            set(at) {
                const {t: ut, p: pt} = it(c ? this : this.material);
                if (S$2(ut, pt, at, !0),
                typeof h == "function") {
                    const ht = [pt, at];
                    if (h.name) {
                        const _t = this[h.name];
                        _t === h ? h.call(this, ...ht) : _t.name === `bound ${h.name}` ? _t(...ht) : h(...ht)
                    } else
                        h(...ht)
                } else
                    S$2(c ? this : this.material, "needsUpdate", !0, !0)
            }
        })
    }
}
function dataTextureFromColor(d) {
    const o = new three_module.GYF(new Uint8Array([Math.floor(255 * d.r), Math.floor(255 * d.g), Math.floor(255 * d.b), 255]),1,1,three_module.GWd,three_module.OUM);
    return o.needsUpdate = !0,
    o.colorSpace = three_module.jf0,
    o
}
function dataTextureFromVec4(d) {
    const o = new three_module.GYF(new Uint8Array([Math.floor(255 * d.x), Math.floor(255 * d.y), Math.floor(255 * d.z), Math.floor(255 * d.w)]),1,1,three_module.GWd,three_module.OUM);
    return o.needsUpdate = !0,
    o
}
function setThreeRendererMode(d, o, c) {
    const h = d.userData
      , {backgroundRender: _, transparentRender: b, shadowMapRender: _e, mainRenderPass: nt, opaqueRender: it, transmissionRender: at, sceneRender: ut, screenSpaceRendering: pt} = h;
    o.backgroundRender !== void 0 && (h.backgroundRender = o.backgroundRender),
    o.transparentRender !== void 0 && (h.transparentRender = o.transparentRender),
    o.shadowMapRender !== void 0 && (h.shadowMapRender = o.shadowMapRender),
    o.mainRenderPass !== void 0 && (h.mainRenderPass = o.mainRenderPass),
    o.opaqueRender !== void 0 && (h.opaqueRender = o.opaqueRender),
    o.sceneRender !== void 0 && (h.sceneRender = o.sceneRender),
    o.transmissionRender !== void 0 && (h.transmissionRender = o.transmissionRender),
    o.screenSpaceRendering !== void 0 && (h.screenSpaceRendering = o.screenSpaceRendering),
    c(),
    h.backgroundRender = _,
    h.transparentRender = b,
    h.shadowMapRender = _e,
    h.mainRenderPass = nt,
    h.opaqueRender = it,
    h.sceneRender = ut,
    h.transmissionRender = at,
    h.screenSpaceRendering = pt
}
function autoCenterObject3D(d, o=!1) {
    if (o) {
        if (!d.userData.autoCentered || !d.userData._lastCenter)
            return d;
        d.position.add(d.userData._lastCenter),
        delete d.userData.autoCentered,
        delete d.userData.isCentered,
        delete d.userData._lastCenter
    } else {
        const c = new Box3B().expandByObject(d, !0, !0).getCenter(new three_module.Pq0);
        d.userData._lastCenter = c,
        d.position.sub(c),
        d.userData.autoCentered = !0,
        d.userData.isCentered = !0
    }
    return d.dispatchEvent({
        type: "objectUpdate",
        undo: o
    }),
    d
}
function pivotToBBoxCenter(d) {
    return pivotToPoint(d, new Box3B().expandByObject(d, !0, !0).getCenter(new three_module.Pq0))
}
function pivotToPoint(d, o) {
    var c;
    const h = new three_module.Pq0().copy(o)
      , _ = new three_module.Pq0().copy(h)
      , b = new three_module.kn4().copy(d.matrixWorld).invert()
      , _e = (c = d.parent) === null || c === void 0 ? void 0 : c.matrixWorld
      , nt = new three_module.kn4;
    _e !== void 0 && nt.copy(_e).invert(),
    h.applyMatrix4(nt);
    const it = d.position.clone();
    return d.position.copy(h),
    _.applyMatrix4(b).negate(),
    d.geometry && d.geometry.translate(_.x, _.y, _.z),
    d.children.forEach(at => {
        at.position.add(_)
    }
    ),
    d.dispatchEvent({
        type: "objectUpdate"
    }),
    () => {
        d.position.copy(it),
        d.geometry && d.geometry.translate(-_.x, -_.y, -_.z),
        d.children.forEach(at => {
            at.position.sub(_)
        }
        ),
        d.dispatchEvent({
            type: "objectUpdate",
            undo: !0
        })
    }
}
function autoScaleObject3D(d, o, c, h=!1) {
    let _ = 1;
    if (h) {
        if (!d.userData.autoScaled || !d.userData._lastScaleRadius)
            return d;
        const b = d.userData.autoScaleRadius || o || 1;
        if (_ = d.userData._lastScaleRadius / b,
        !isFinite(_))
            return d;
        d.userData.autoScaled = !0,
        d.userData.autoScaleRadius = o,
        delete d.userData._lastScaleRadius
    } else {
        const b = .5 * new Box3B().expandByObject(d, !0, !0).getSize(new three_module.Pq0).length();
        if (o === void 0 && (o = d.userData.autoScaleRadius || 1),
        _ = o / b,
        !isFinite(_))
            return d;
        d.userData.autoScaled = !0,
        d.userData.autoScaleRadius = o,
        d.userData._lastScaleRadius = b
    }
    return d.userData.pseudoCentered ? d.children.forEach(b => {
        b.scale.multiplyScalar(_)
    }
    ) : d.scale.multiplyScalar(_),
    (c || d.userData.isCentered) && d.position.multiplyScalar(_),
    d.traverse(b => {
        var _e, nt;
        b.isLight && (!((nt = (_e = b.shadow) === null || _e === void 0 ? void 0 : _e.camera) === null || nt === void 0) && nt.right) && (b.shadow.camera.right *= _,
        b.shadow.camera.left *= _,
        b.shadow.camera.top *= _,
        b.shadow.camera.bottom *= _),
        b.isCamera && b.right && (b.right *= _,
        b.left *= _,
        b.top *= _,
        b.bottom *= _)
    }
    ),
    d.dispatchEvent({
        type: "objectUpdate",
        undo: h
    }),
    d
}
function toIndexedGeometry(d, o=-1) {
    return mergeVertices(d, o)
}
function makeSamplerUi(d, o, c, h, _) {
    return _ = _ ?? ( () => d.setDirty && d.setDirty()),
    {
        type: "folder",
        label: c ?? o + " Sampler",
        hidden: () => !d[o] || h && h(),
        children: [ () => ({
            type: "vec2",
            label: "Repeat",
            bounds: [-100, 100],
            stepSize: .001,
            property: [d[o], "repeat"],
            onChange: _
        }), () => ({
            type: "vec2",
            label: "Offset",
            bounds: [-2, 2],
            stepSize: .001,
            property: [d[o], "offset"],
            onChange: _
        }), () => ({
            type: "vec2",
            label: "Center",
            bounds: [-2, 2],
            stepSize: .001,
            property: [d[o], "center"],
            onChange: _
        }), () => ({
            type: "input",
            label: "Rotation",
            stepSize: .001,
            bounds: [-Math.PI, Math.PI],
            property: [d[o], "rotation"],
            onChange: _
        }), () => ({
            type: "dropdown",
            label: "Color Space",
            property: [d[o], "colorSpace"],
            children: [["Linear", three_module.Zr2], ["sRGB", three_module.er$]].map(b => ({
                label: b[0],
                value: b[1]
            })),
            onChange: [ () => {
                const b = d[o];
                b && (b.needsUpdate = !0)
            }
            , _]
        }), () => ({
            type: "checkbox",
            label: "Flip Y",
            getValue: () => {
                var b, _e;
                return (_e = (b = d[o]) === null || b === void 0 ? void 0 : b.flipY) !== null && _e !== void 0 && _e
            }
            ,
            setValue: b => {
                const _e = d[o];
                if (_e && _e.flipY !== b)
                    if (_e.image && ImageBitmap && _e.image instanceof ImageBitmap) {
                        const nt = _e
                          , it = _e.source.data;
                        createImageBitmap(it, {
                            imageOrientation: "flipY"
                        }).then(at => {
                            it.close && it.close(),
                            nt.flipY = b,
                            nt.source.data = at,
                            nt.source.needsUpdate = !0,
                            nt.needsUpdate = !0,
                            _ && _()
                        }
                        )
                    } else
                        _e.flipY = b,
                        _e.needsUpdate = !0,
                        _ && _()
            }
        }), () => ({
            type: "dropdown",
            label: "Wrap S",
            property: [d[o], "wrapS"],
            children: [["ClampToEdge", three_module.ghU], ["MirroredRepeat", three_module.kTW], ["Repeat", three_module.GJx]].map(b => ({
                label: b[0],
                value: b[1]
            })),
            onChange: [ () => {
                d[o] && (d[o].needsUpdate = !0)
            }
            , _]
        }), () => ({
            type: "dropdown",
            label: "Wrap T",
            property: [d[o], "wrapT"],
            children: [["ClampToEdge", three_module.ghU], ["MirroredRepeat", three_module.kTW], ["Repeat", three_module.GJx]].map(b => ({
                label: b[0],
                value: b[1]
            })),
            onChange: [ () => {
                d[o] && (d[o].needsUpdate = !0)
            }
            , _]
        }), () => ({
            type: "input",
            label: "Anisotropy",
            bounds: [1, 6],
            stepSize: 1,
            property: [d[o], "anisotropy"],
            onChange: [ () => {
                d[o] && (d[o].needsUpdate = !0),
                d.needsUpdate = !0
            }
            , _]
        }), () => ({
            type: "dropdown",
            label: "Min Filter",
            property: [d[o], "minFilter"],
            children: [["Linear", three_module.k6q], ["Nearest", three_module.hxR], ["NearestMipmapNearest", three_module.pHI], ["NearestMipmapLinear", three_module.a$r], ["LinearMipmapNearest", three_module.kRr], ["LinearMipmapLinear", three_module.$_I]].map(b => ({
                label: b[0],
                value: b[1]
            })),
            onChange: [ () => {
                d[o] && (d[o].needsUpdate = !0)
            }
            , _]
        }), () => ({
            type: "dropdown",
            label: "Mag Filter",
            property: [d[o], "magFilter"],
            children: [["Linear", three_module.k6q], ["Nearest", three_module.hxR]].map(b => ({
                label: b[0],
                value: b[1]
            })),
            onChange: [ () => {
                d[o] && (d[o].needsUpdate = !0)
            }
            , _]
        })]
    }
}
const iMaterialIgnoredUserData = ["appliedMeshes", "imageLoadAwaiter", "inverseModelMatrix", "uvTransform", "uuid", "iMaterial"];
function copyMaterialUserData(d, o, c=!0) {
    if (!o)
        return d;
    for (const h of Object.keys(o)) {
        if (c && iMaterialIgnoredUserData.includes(h) || h.startsWith("__"))
            continue;
        const _ = o[h];
        if (typeof d[h] == "function" || typeof _ == "function")
            continue;
        const b = !_ || _.isTexture || _.isObject3D || _.isMaterial;
        b || typeof _.clone != "function" ? b || typeof _ != "object" && !Array.isArray(_) ? d[h] = _ : d[h] = copyMaterialUserData(Array.isArray(_) ? [] : {}, _, !1) : d[h] = _.clone()
    }
    return d
}
const iTextureIgnoredUserData = ["appliedMaterials", "uuid"];
function copyTextureUserData(d, o) {
    if (o)
        for (const c of Object.keys(o))
            iTextureIgnoredUserData.includes(c) || c.startsWith("__") || typeof d[c] != "function" && typeof o[c] != "function" && (d[c] = o[c]);
    return d
}
function textureDataToImageData(d, o, c) {
    var h;
    const _ = (h = c == null ? void 0 : c.data) !== null && h !== void 0 ? h : new Uint8ClampedArray(d.height * d.width * 4)
      , b = d.data instanceof Float32Array
      , _e = d.data instanceof Uint16Array;
    for (let nt = 0; nt < _.length; nt++)
        _[nt] = b ? 255 * d.data[nt] : _e ? 255 * three_module.GxU.fromHalfFloat(d.data[nt]) : d.data[nt],
        o === three_module.Zr2 && (_[nt] = 255 * ve$1(_[nt] / 255));
    return c ?? new ImageData(_,d.width,d.height)
}
function textureToCanvas(d, o, c=!1) {
    let h;
    return h = d.isDataTexture ? textureDataToImageData(d.image, d.colorSpace) : d.image,
    texImageToCanvas(h, o, c)
}
function texImageToCanvas(d, o, c=!1) {
    const h = document.createElement("canvas");
    h.width = Math.min(o, d.width),
    h.height = Math.floor(1 + h.width * d.height / d.width);
    const _ = h.getContext("2d");
    if (!_)
        return console.error("textureToDataUrl: could not get canvas context"),
        h;
    c === !0 && (_.translate(0, h.height),
    _.scale(1, -1));
    let b = !1;
    if (d.data !== void 0) {
        const _e = d;
        if (d.width !== h.width || d.height !== h.height) {
            const nt = document.createElement("canvas");
            nt.width = d.width,
            nt.height = d.height;
            const it = nt.getContext("2d");
            it ? (it.putImageData(_e, 0, 0),
            _.drawImage(nt, 0, 0, h.width, h.height)) : (console.error("textureToDataUrl: could not get temp canvas context"),
            _.putImageData(_e, 0, 0))
        } else
            _.putImageData(_e, 0, 0),
            c && (b = !0)
    } else
        _.drawImage(d, 0, 0, h.width, h.height);
    return b ? Ke$1(h) : h
}
function textureToDataUrl(d, o, c, h, _) {
    return textureToCanvas(d, o, c).toDataURL(h, _)
}
String.prototype.replaceAll || (String.prototype.replaceAll = function(d, o) {
    return Object.prototype.toString.call(d).toLowerCase() === "[object regexp]" ? this.replace(d, o) : this.replace(new RegExp(d,"g"), o)
}
);
const typeMap = new Map;
function serialize(d) {
    return (o, c) => {
        const h = o.constructor;
        if (h === Object)
            throw new Error("All properties in an object are serialized by default");
        typeMap.has(h) || typeMap.set(h, []),
        typeMap.get(h).push([d || c, c])
    }
}
const serializers = {
    obj: (d, o) => Object.fromEntries(Object.entries(d).map( ([c,h]) => [c, serializeObject(h, !1, o)])),
    vec4: d => ({
        x: d.x,
        y: d.y,
        z: d.z,
        w: d.w,
        isVector4: !0
    }),
    vec3: d => ({
        x: d.x,
        y: d.y,
        z: d.z,
        isVector3: !0
    }),
    vec2: d => ({
        x: d.x,
        y: d.y,
        isVector2: !0
    }),
    color: d => ({
        r: d.r,
        g: d.g,
        b: d.b,
        isColor: !0
    }),
    quat: d => ({
        x: d.x,
        y: d.y,
        z: d.z,
        w: d.w,
        isQuaternion: !0
    }),
    texture: (d, o) => {
        var c;
        if (!(d != null && d.isTexture))
            throw new Error("Expected a texture");
        if (o != null && o.textures[d.uuid])
            return {
                uuid: d.uuid,
                resource: "textures"
            };
        if (d.isRenderTargetTexture && !(!((c = d.userData) === null || c === void 0) && c.serializableRenderTarget))
            return;
        const h = d.source.data
          , _ = !d.isRenderTargetTexture && d.userData.rootPath;
        _ && d.source.data && (d.userData.__embedUrlImagePreviews ? d.source.data = textureToCanvas(d, 16, d.flipY) : d.source.data = null);
        const b = d.userData;
        d.userData = {};
        const _e = {
            images: {}
        };
        let nt = {};
        try {
            nt = d.toJSON(o || _e),
            !o && nt.image && (nt.image = _ && !d.userData.__embedUrlImagePreviews ? void 0 : _e.images[nt.image]),
            nt.userData = serializeObject(copyTextureUserData({}, b), !1, o)
        } catch (it) {
            console.error(it)
        }
        return d.userData = b,
        _ && (o && !d.userData.__embedUrlImagePreviews && delete o.images[d.source.uuid],
        d.source.data = h),
        o != null && o.textures && !nt.resource && (o.textures[nt.uuid] || (o.textures[nt.uuid] = nt),
        nt = {
            uuid: nt.uuid,
            resource: "textures"
        }),
        nt
    }
    ,
    material: (d, o) => {
        var c;
        if (!(d != null && d.isMaterial))
            throw new Error("Expected a material");
        if (!((c = o == null ? void 0 : o.materials) === null || c === void 0) && c[d.uuid])
            return {
                uuid: d.uuid,
                resource: "materials"
            };
        d.userData.rootPath && console.error("TODO: handle material with root path with material inheritance/hierarchy");
        const h = o ?? {
            textures: {},
            images: {}
        }
          , _ = {}
          , b = {};
        for (const [nt,it] of Object.entries(d))
            if (it != null && it.isTexture && !nt.startsWith("__")) {
                const at = serializers.texture(it, h);
                _[nt] = at,
                b[nt] = it,
                d[nt] = at ? {
                    isTexture: !0,
                    toJSON: () => at
                } : null
            }
        let _e = d.toJSON(o || h);
        for (const [nt,it] of Object.entries(b))
            d[nt] = it,
            delete b[nt];
        if (o) {
            for (const [nt,it] of Object.entries(_))
                it && (_e[nt] = it);
            o != null && o.materials && (o.materials[_e.uuid] || (o.materials[_e.uuid] = _e),
            _e = {
                uuid: _e.uuid,
                resource: "materials"
            })
        } else {
            for (const [nt,it] of Object.entries(_))
                it && (_e[nt] = it.uuid);
            _e.textures = Object.values(h.textures),
            _e.images = Object.values(h.images)
        }
        return _e
    }
}
  , copier = d => (o, c) => {
    var h, _;
    return (_ = (h = c == null ? void 0 : c.copy) === null || h === void 0 ? void 0 : h.call(c, o)) !== null && _ !== void 0 ? _ : new d().copy(o)
}
  , deserializers = {
    obj: (d, o, c) => Object.assign(o, Object.fromEntries(Object.entries(d).map( ([h,_]) => [h, deserializeObject(_, o == null ? void 0 : o[h], !1, c)]))),
    vec4: copier(three_module.IUQ),
    vec3: copier(three_module.Pq0),
    vec2: copier(three_module.I9Y),
    color: copier(three_module.Q1f),
    quat: copier(three_module.PTz)
};
function serializeObject(d, o, c) {
    var h, _;
    if (typeof d == "function")
        return;
    if (Array.isArray(d))
        return d.map(nt => serializeObject(nt, !1, c));
    if (typeof d != "object") {
        if (typeof d == "number") {
            if (d === 1 / 0)
                return "Infinity";
            if (d === -1 / 0)
                return "-Infinity";
            if (isNaN(d))
                return "NaN"
        }
        return d
    }
    if (!d)
        return d;
    let b = (h = d.constructor) !== null && h !== void 0 ? h : Object;
    if (b === Object)
        return serializers.obj(d, c);
    if (d.isVector2)
        return serializers.vec2(d);
    if (d.isVector3)
        return serializers.vec3(d);
    if (d.isVector4)
        return serializers.vec4(d);
    if (d.isColor)
        return serializers.color(d);
    if (d.isQuaternion)
        return serializers.quat(d);
    if (d.isTexture)
        return serializers.texture(d, c);
    if (d.isMaterial)
        return serializers.material(d, c);
    if (!o && typeof d.toJSON == "function") {
        const nt = d.toJSON(c);
        return d.serializableClassId && nt && (nt.serializableClassId = d.serializableClassId),
        nt
    }
    const _e = {};
    for (; b && b !== Object; )
        (_ = typeMap.get(b)) === null || _ === void 0 || _.forEach( ([nt,it]) => {
            const at = d[it];
            _e[nt] = serializeObject(at, !1, c)
        }
        ),
        b = Object.getPrototypeOf(b);
    return d.serializableClassId && (_e.serializableClassId = d.serializableClassId),
    _e
}
function deserializeObject(d, o, c, h={}) {
    var _, b, _e;
    let nt = o;
    if (d === void 0)
        return nt;
    if (typeof o == "number") {
        if (d === "Infinity")
            return 1 / 0;
        if (d === "-Infinity")
            return -1 / 0;
        if (d === "NaN")
            return NaN;
        if (typeof d == "number" || !d)
            return d
    }
    if (Array.isArray(d)) {
        const ut = d.length;
        Array.isArray(nt) || (nt = []);
        for (let pt = 0; pt < ut; pt++) {
            const ht = d[pt]
              , _t = nt.length > pt ? deserializeObject(ht, nt[pt], !1, h) : deserializeObject(ht, void 0, !1, h);
            nt.length <= pt ? nt.push(_t) : nt[pt] = _t
        }
        return nt
    }
    let it = !1;
    if (d && d.resource && typeof d.resource == "string" && (d = (_ = h[d.resource]) === null || _ === void 0 ? void 0 : _[d.uuid],
    it = !0),
    !nt && d && !it)
        if (d.serializableClassId) {
            const ut = serializableClasses.get(d.serializableClassId);
            ut && (nt = ut.DataInConstructor ? new ut(d) : new ut)
        } else
            typeof d != "object" || d.constructor && d.constructor !== Object || (nt = {});
    if (typeof nt == "function")
        return console.error("cannot deserialize over function", nt, d),
        nt;
    if (d && typeof d == "object" && !it) {
        if (d.isVector2)
            return deserializers.vec2(d, nt);
        if (d.isVector3)
            return deserializers.vec3(d, nt);
        if (d.isVector4)
            return deserializers.vec4(d, nt);
        if (d.isColor)
            return deserializers.color(d, nt);
        if (d.isQuaternion)
            return deserializers.quat(d, nt)
    }
    if (d == null || nt == null || typeof nt != "object" || nt.isTexture)
        return it && (d ? d.__useCount = d.__useCount ? d.__useCount + 1 : 1 : console.warn("probable error deserialize: resource not found.")),
        d;
    let at = (b = nt.constructor) !== null && b !== void 0 ? b : Object;
    if (at === Object)
        return deserializers.obj(d, nt, h);
    if (!c && typeof nt.fromJSON == "function")
        return nt.isMaterial && (Object.entries(d).forEach( ([ut,pt]) => {
            var ht;
            if (!pt || !pt.resource || typeof pt.resource != "string")
                return;
            const _t = (ht = h[pt.resource]) === null || ht === void 0 ? void 0 : ht[pt.uuid];
            d[ut] = _t || null
        }
        ),
        d.userData && (d.userData = deserializeObject(d.userData, void 0, !1, h))),
        nt.fromJSON(d, h),
        nt;
    for (; at && at !== Object; )
        (_e = typeMap.get(at)) === null || _e === void 0 || _e.forEach( ([ut,pt]) => {
            const ht = nt[pt]
              , _t = deserializeObject(d[ut], ht, !1, h);
            _t !== ht && S$2(nt, pt, _t, !0)
        }
        ),
        at = Object.getPrototypeOf(at);
    return nt
}
const serializableClasses = new Map;
function serializable(d) {
    return o => (o = class extends o {
        constructor() {
            super(...arguments),
            this.serializableClassId = d
        }
    }
    ,
    serializableClasses.set(d, o),
    o)
}
function serializeTextureInExtras(d, o, c, h) {
    var _, b, _e;
    if (o != null && o.extras[d.uuid])
        return {
            uuid: d.uuid,
            resource: "extras"
        };
    let nt = "";
    if (!((_ = d.source) === null || _ === void 0) && _._sourceImgBuffer || d.userData.__sourceBuffer) {
        const at = new Uint8Array(((b = d.source) === null || b === void 0 ? void 0 : b._sourceImgBuffer) || d.userData.__sourceBuffer)
          , ut = h || d.userData.mimeType || "";
        nt = {
            data: Array.from(at),
            type: at.constructor.name,
            path: ((_e = d.userData.__sourceBlob) === null || _e === void 0 ? void 0 : _e.name) || d.userData.rootPath || "file." + ut.split("/")[1]
        },
        ut && (nt.mimeType = ut)
    } else
        d.userData.rootPath ? nt = d.userData.rootPath : console.error("Unable to serialize LUT texture, not loaded through asset manager.");
    const it = {
        uuid: d.uuid,
        url: nt,
        userData: copyTextureUserData({}, d.userData),
        type: d.type,
        name: c || d.name
    };
    return o != null && o.extras ? (o.extras[d.uuid] = it,
    {
        uuid: d.uuid,
        resource: "extras"
    }) : it
}
var __decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let BaseRenderer = class extends I$2 {
    get composer() {
        return this._composer
    }
    get passes() {
        return this._passes
    }
    get isWebGL2() {
        return this._isWebGL2
    }
    get composerTarget() {
        return this._composerTarget
    }
    get renderSize() {
        return this._renderSize
    }
    get displayCanvasScaling() {
        return this._displayCanvasScaling
    }
    set displayCanvasScaling(d) {
        d !== this._displayCanvasScaling && (this._displayCanvasScaling = d,
        this.setSize(void 0, void 0, !0))
    }
    get frameCount() {
        return this._frameCount
    }
    get totalFrameCount() {
        return this._totalFrameCount
    }
    set pipeline(d) {
        this._pipeline = d,
        this._passesNeedsUpdate = !0
    }
    get pipeline() {
        return this._pipeline
    }
    refreshPipeline() {
        var d, o, c;
        const h = this._passes
          , _ = []
          , b = {};
        for (const _e of h) {
            if (_e.enabled === !1)
                continue;
            const nt = {
                after: (d = _e.after) !== null && d !== void 0 ? d : [],
                before: (o = _e.before) !== null && o !== void 0 ? o : [],
                dependencies: new Set((c = _e.required) !== null && c !== void 0 ? c : [])
            };
            b[_e.passId] = nt
        }
        for (const [_e,nt] of Object.entries(b)) {
            const it = new Set([...nt.after, ...nt.before]);
            nt.dependencies.forEach(at => it.has(at) && it.delete(at)),
            it.forEach(at => {
                const ut = b[at];
                if (ut) {
                    if (ut.dependencies.has(_e))
                        throw console.error("cyclic", _e, at),
                        "Cyclic dependency";
                    nt.dependencies.add(at)
                }
            }
            )
        }
        for (; ; ) {
            let _e = !1;
            const nt = [...Object.entries(b)];
            for (const [it,at] of nt)
                if (!_.includes(it) && Ce$1(_, at.dependencies.values())) {
                    const ut = Math.max(-1, ...at.after.map(ht => _.indexOf(ht)))
                      , pt = Math.min(_.length, ...at.before.map(ht => {
                        const _t = _.indexOf(ht);
                        return _t < 0 ? _.length : _t
                    }
                    ));
                    if (ut >= pt)
                        throw console.error(at, h, _, ut, pt),
                        "Not possible";
                    _.splice(at.after.length > 0 ? ut + 1 : pt, 0, it),
                    _e = !0,
                    delete b[it]
                }
            if (Object.keys(b).length < 1)
                break;
            if (!_e)
                throw console.error(nt, b, _),
                "Not possible 2"
        }
        return this.pipeline = _,
        this.pipeline
    }
    get context() {
        return this._context
    }
    get rendererObject() {
        return this._renderer
    }
    _animationLoop(d, o) {
        const c = d - this._lastTime;
        this._lastTime = d,
        this.frameWaitTime -= c,
        this.frameWaitTime > 0 || (this.frameWaitTime = 0,
        this.dispatchEvent({
            type: "animationLoop",
            deltaTime: c,
            time: d,
            renderer: this,
            xrFrame: o
        }))
    }
    get clock() {
        return this._composer.clock
    }
    registerPass(d, o=!0) {
        var c;
        if (o)
            for (const h of [...this._passes])
                d.passId === h.passId && this.unregisterPass(h);
        this._passes.push(d),
        (c = d.onRegister) === null || c === void 0 || c.call(d, this),
        this._passesNeedsUpdate = !0,
        this._updated()
    }
    unregisterPass(d) {
        var o;
        const c = this._passes.indexOf(d);
        c >= 0 && ((o = d.onUnregister) === null || o === void 0 || o.call(d, this),
        this._passes.splice(c, 1),
        this._passesNeedsUpdate = !0,
        this._updated())
    }
    constructor({animationLoop: d, canvas: o, alpha: c=!0, targetOptions: h, maxHDRIntensity: _}) {
        super(),
        this._isWebGL2 = !1,
        this._trackedTargets = [],
        this.dirty = !0,
        this._lastTime = 0,
        this.frameWaitTime = 0,
        this._passes = [],
        this._pipeline = [],
        this._passesNeedsUpdate = !0,
        this._displayCanvasScaling = 1,
        this._renderSize = new three_module.I9Y(512,512),
        this._frameCount = 0,
        this.defaultRenderToScreen = !0,
        this._tempTargets = {},
        this.maxTempPerKey = 5,
        this._totalFrameCount = 0,
        this.stableNoise = !1,
        this._animationLoop = this._animationLoop.bind(this),
        this._processNewTarget = this._processNewTarget.bind(this),
        this._processNewTempTarget = this._processNewTempTarget.bind(this),
        this.trackTarget = this.trackTarget.bind(this),
        this.disposeTarget = this.disposeTarget.bind(this),
        this.createTarget = this.createTarget.bind(this),
        this.createTargetCustom = this.createTargetCustom.bind(this),
        this.maxHDRIntensity = _ || 120,
        this._renderer = new three_module.JeP({
            canvas: o,
            antialias: !1,
            alpha: c,
            premultipliedAlpha: !0,
            preserveDrawingBuffer: !0,
            powerPreference: "high-performance"
        }),
        this._renderer.baseRenderer = this,
        this._renderer.setAnimationLoop(this._animationLoop),
        this._context = this._renderer.getContext(),
        this._isWebGL2 = this._renderer.capabilities.isWebGL2,
        this._isWebGL2 || console.error("WebGi BaseRenderer: WebGL1 is not supported anymore. Some features may not work"),
        this._renderer.onContextLost = b => {
            this.dispatchEvent({
                type: "contextLost",
                event: b
            })
        }
        ,
        this._renderer.onContextRestore = () => {
            this.dispatchEvent({
                type: "contextRestored"
            })
        }
        ,
        this._renderSize = new three_module.I9Y(o.clientWidth,o.clientHeight),
        this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1),
        this._renderer.setPixelRatio(this._displayCanvasScaling),
        this._renderer.toneMapping = three_module.y_p,
        this._renderer.toneMappingExposure = 1,
        this._renderer.outputColorSpace = three_module.jf0,
        this._renderer.shadowMap.enabled = !0,
        this._renderer.shadowMap.type = three_module.QP0,
        this._renderer.shadowMap.autoUpdate = !1,
        this.resetShadows(),
        this._composerTarget = this.createTarget(h, !1),
        this._composerTarget.texture.name = "EffectComposer.rt1",
        this._composer = new EffectComposer2(this._renderer,this._composerTarget),
        d && this.addEventListener("animationLoop", d)
    }
    setSize(d, o, c=!1) {
        !c && (d ? Math.abs(d - this._renderSize.width) : 0) + (o ? Math.abs(o - this._renderSize.height) : 0) < .1 || (d && (this._renderSize.width = d),
        o && (this._renderSize.height = o),
        this.rendererObject.xr.enabled && this.rendererObject.xr.isPresenting || (this._renderer.setSize(this._renderSize.width, this._renderSize.height, !1),
        this._renderer.setPixelRatio(this._displayCanvasScaling)),
        this._composer.setPixelRatio(this._displayCanvasScaling, !1),
        this._composer.setSize(this._renderSize.width, this._renderSize.height),
        this._trackedTargets.forEach(h => {
            const _ = h
              , b = _.sizeMultiplier;
            if (b) {
                const _e = this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * b);
                _.setSize(Math.floor(_e.width), Math.floor(_e.height))
            }
        }
        ),
        this.dispatchEvent({
            type: "resize"
        }),
        this._updated(),
        this.reset())
    }
    blit(d, o, {viewport: c, material: h, shader: _, pass: b, clear: _e=!0}={}) {
        const nt = this._composer.copyPass
          , {renderToScreen: it, material: at, uniforms: ut, clear: pt} = nt;
        h && (nt.material = h);
        const ht = this._renderer.getViewport(new three_module.IUQ)
          , _t = this._renderer.autoClear
          , vt = this._renderer.getRenderTarget();
        c && this._renderer.setViewport(new three_module.IUQ().fromArray(c)),
        this._renderer.autoClear = !1,
        nt.uniforms = nt.material.uniforms,
        nt.renderToScreen = !1,
        nt.clear = _e,
        setThreeRendererMode(this._renderer, {
            sceneRender: !0,
            opaqueRender: !0,
            shadowMapRender: !1,
            backgroundRender: !1,
            transparentRender: !0,
            transmissionRender: !1
        }, () => {
            nt.render(this._renderer, o ?? null, {
                texture: d
            }, 0, !1)
        }
        ),
        nt.renderToScreen = it,
        nt.clear = pt,
        nt.material = at,
        nt.uniforms = ut,
        this._renderer.autoClear = _t,
        c && this._renderer.setViewport(ht),
        this._renderer.setRenderTarget(vt)
    }
    clearColor({r: d, g: o, b: c, a: h, target: _, depth: b=!0, stencil: _e=!0}) {
        var nt;
        const it = this._renderer.getClearColor(new three_module.Q1f)
          , at = this._renderer.getClearAlpha();
        this._renderer.setClearColor(new three_module.Q1f(d ?? it.r,o ?? it.g,c ?? it.b), h ?? at);
        const ut = this._renderer.getRenderTarget()
          , pt = this._renderer.getActiveCubeFace()
          , ht = this._renderer.getActiveMipmapLevel();
        _ && typeof _.clear == "function" ? _.clear(this._renderer, !0, b, _e) : (this._renderer.setRenderTarget((nt = _) !== null && nt !== void 0 ? nt : null),
        this._renderer.clear(!0, b, _e)),
        this._renderer.setRenderTarget(ut, pt, ht),
        this._renderer.setClearColor(it, at)
    }
    renderModel(d, o) {
        this._renderer.render(d.modelObject, o.cameraObject)
    }
    renderScene(d) {
        const o = d.activeCamera;
        o && this.renderModel(d, o)
    }
    _updated() {
        this.dispatchEvent({
            type: "update"
        })
    }
    render(d) {
        var o;
        this._passesNeedsUpdate && this.refreshPasses();
        for (const c of this._passes)
            c.passObject.enabled && ((o = c.update) === null || o === void 0 || o.call(c));
        d = d ?? this.defaultRenderToScreen,
        this._composer.renderToScreen = d,
        this._composer.render(),
        this._composer.renderToScreen = !0,
        d && (this._frameCount += 1,
        this._totalFrameCount += 1),
        this.dirty = !1
    }
    updateDirty() {
        this.dirty = this.dirty || this._passes.findIndex(d => d.dirty) >= 0
    }
    reset() {
        this._frameCount = 0,
        this.dirty = !0
    }
    resetShadows() {
        this._renderer.shadowMap.needsUpdate = !0
    }
    refreshPasses() {
        if (!this._passesNeedsUpdate)
            return;
        this._passesNeedsUpdate = !1;
        const d = [];
        for (const o of this._pipeline) {
            const c = this._passes.find(h => h.passId === o);
            c ? d.push(c.passObject) : console.warn("WebGi BaseRenderer: Unable to find pass: ", o)
        }
        [...this._composer.passes].forEach(o => this._composer.removePass(o)),
        d.forEach(o => this._composer.addPass(o)),
        this._updated()
    }
    dispose() {
        this._trackedTargets.forEach(d => d.dispose()),
        this._trackedTargets = [],
        this._renderer.dispose()
    }
    trackTarget(d) {
        this._trackedTargets.push(d)
    }
    removeTrackedTarget(d) {
        const o = this._trackedTargets.indexOf(d);
        o >= 0 && this._trackedTargets.splice(o, 1)
    }
    createTarget({sizeMultiplier: d, samples: o=0, colorSpace: c=three_module.jf0, type: h=three_module.OUM, format: _=three_module.GWd, depthBuffer: b=!0, depthTexture: _e=!1, depthTextureType: nt=three_module.bkx, depthTextureFormat: it=three_module.zdS, size: at, textureCount: ut=1, ...pt}={}, ht=!0) {
        this.isWebGL2 || (o = 0),
        d !== void 0 && at !== void 0 && console.error("Both sizeMultiplier and size are defined. sizeMultiplier will be ignored."),
        (at = at || this._renderSize.clone().multiplyScalar(this._displayCanvasScaling * (d = d || 1))).width = Math.floor(at.width),
        at.height = Math.floor(at.height);
        const _t = _e ? new three_module.VCu(at.width,at.height,nt) : null;
        _t && (_t.format = it);
        const vt = this.createTargetCustom(ut > 1 ? {
            width: at.width,
            height: at.height,
            count: ut
        } : at, {
            samples: o,
            colorSpace: c,
            type: h,
            format: _,
            depthBuffer: b,
            depthTexture: _t
        }, ut > 1 ? three_module.AT1 : three_module.nWS);
        return this._processNewTarget(vt, d, ht),
        this._setTargetOptions(vt, pt),
        vt
    }
    _processNewTarget(d, o, c) {
        return o !== void 0 && (d.sizeMultiplier = o),
        c && this.trackTarget(d),
        d
    }
    disposeTarget(d) {
        if (d) {
            if (d.isTemporary)
                return this.releaseTempTarget(d);
            this.removeTrackedTarget(d),
            d.dispose()
        }
    }
    createTargetCustom({width: d, height: o, count: c}, h={}, _) {
        var b;
        const _e = this._processNewTarget
          , nt = this.renderTargetToDataUrl.bind(this);
        this.renderTargetToBuffer.bind(this);
        let it = [d, o];
        if (c && c > 1 && it.push(c),
        (_ == null ? void 0 : _.prototype) === three_module.o6l.prototype) {
            if (d !== o)
                throw "Width and height of cube render target must be equal";
            it = [d]
        }
        h = {
            format: three_module.GWd,
            minFilter: three_module.k6q,
            magFilter: three_module.k6q,
            generateMipmaps: !1,
            type: three_module.OUM,
            colorSpace: three_module.jf0,
            ...h
        };
        const at = [this, ...it, h];
        return new class extends ((b = _) !== null && b !== void 0 ? b : three_module.nWS) {
            constructor(ut, ...pt) {
                super(...pt),
                this.renderer = ut,
                this.assetType = "renderTarget",
                this.name = "RenderTarget",
                Array.isArray(this.texture) ? this.texture.forEach(ht => {
                    ht.__target = this,
                    ht.userData || (ht.userData = {}),
                    ht.colorSpace = h.colorSpace,
                    ht.toJSON = () => (console.warn("WebGi RenderTarget: Multiple render target texture.toJSON not supported yet."),
                    {})
                }
                ) : (this.texture.userData || (this.texture.userData = {}),
                this.texture.__toJSON = this.texture.toJSON,
                this.texture.__target = this,
                this.texture.toJSON = function(ht) {
                    console.warn("WebGi RenderTarget: Render target texture.toJSON might be buggy."),
                    this.source.data.url = nt(this.__target, "image/png", 90);
                    const _t = this.__toJSON.call(this, ht);
                    return delete this.source.data.url,
                    _t.isRenderTargetTexture = !0,
                    _t
                }
                )
            }
            setSize(ut, pt, ht) {
                super.setSize(Math.floor(ut), Math.floor(pt), ht)
            }
            clone(ut=!0) {
                if (this.isTemporary)
                    throw "Cloning temporary render targets not supported";
                if (Array.isArray(this.texture))
                    throw "Cloning multiple render targets not supported";
                const pt = super.clone();
                return pt.texture.isRenderTargetTexture = !0,
                _e(pt, this.sizeMultiplier || 1, ut)
            }
        }
        (...at)
    }
    getTempTarget(d={}) {
        var o;
        const c = createRenderTargetKey(d);
        let h;
        return !((o = this._tempTargets[c]) === null || o === void 0) && o.length && (h = this._tempTargets[c].pop()),
        h ? this._setTargetOptions(h, d) : (h = this.createTarget(d),
        this._processNewTempTarget(h, c)),
        h
    }
    _processNewTempTarget(d, o) {
        return d.isTemporary = !0,
        d.targetKey = o,
        this._tempTargets[o] === void 0 && (this._tempTargets[o] = []),
        d
    }
    releaseTempTarget(d) {
        const o = d.targetKey;
        if (!o || !d.isTemporary)
            throw "Not a temp target";
        this._tempTargets[o].length > this.maxTempPerKey ? (this.removeTrackedTarget(d),
        d.dispose()) : this._tempTargets[o].push(d)
    }
    updateShaderProperties(d) {
        return this.stableNoise ? d.uniforms.frameCount ? d.uniforms.frameCount.value = this._totalFrameCount : console.warn("WebGi BaseRenderer: no uniform: frameCount") : d.uniforms.frameCount ? d.uniforms.frameCount.value = this.frameCount : console.warn("WebGi BaseRenderer:  no uniform: frameCount"),
        d.uniforms.frameCount2 && (d.uniforms.frameCount2.value = this.frameCount),
        this
    }
    _setTargetOptions(d, o) {
        var c, h, _;
        d.texture.minFilter = (c = o.minFilter) !== null && c !== void 0 ? c : three_module.k6q,
        d.texture.magFilter = (h = o.magFilter) !== null && h !== void 0 ? h : three_module.k6q,
        d.texture.generateMipmaps = (_ = o.generateMipmaps) !== null && _ !== void 0 && _,
        d.texture.generateMipmaps && d.texture.minFilter === three_module.k6q && (d.texture.minFilter = three_module.NZq),
        d.texture.generateMipmaps || d.texture.minFilter !== three_module.NZq || (d.texture.minFilter = three_module.k6q)
    }
    renderTargetToDataUrl(d, o="image/png", c=90, h=0) {
        const _ = document.createElement("canvas");
        _.width = d.width,
        _.height = d.height;
        const b = _.getContext("2d");
        if (!b)
            throw new Error("Unable to get 2d context");
        const _e = Array.isArray(d.texture) ? d.texture[h] : d.texture
          , nt = b.createImageData(d.width, d.height, {
            colorSpace: ["display-p3", "srgb"].includes(_e.colorSpace) ? _e.colorSpace : void 0
        });
        if (_e.type === three_module.ix0) {
            const at = new Uint16Array(d.width * d.height * 4);
            this._renderer.readRenderTargetPixels(d, 0, 0, d.width, d.height, at, void 0, h),
            textureDataToImageData({
                data: at,
                width: d.width,
                height: d.height
            }, _e.colorSpace, nt)
        } else if (_e.type === three_module.RQf) {
            const at = new Float32Array(d.width * d.height * 4);
            this._renderer.readRenderTargetPixels(d, 0, 0, d.width, d.height, at, void 0, h),
            textureDataToImageData({
                data: at,
                width: d.width,
                height: d.height
            }, _e.colorSpace, nt)
        } else
            this._renderer.readRenderTargetPixels(d, 0, 0, d.width, d.height, nt.data, void 0, h);
        b.putImageData(nt, 0, 0);
        const it = _.toDataURL(o, c);
        return _.remove(),
        it
    }
    renderTargetToBuffer(d, o=0) {
        const c = (Array.isArray(d.texture) ? d.texture[o] : d.texture).type === three_module.ix0 ? new Uint16Array(d.width * d.height * 4) : new Uint8Array(d.width * d.height * 4);
        return this._renderer.readRenderTargetPixels(d, 0, 0, d.width, d.height, c, void 0, o),
        c
    }
    get useLegacyLights() {
        return this.rendererObject.useLegacyLights
    }
    set useLegacyLights(d) {
        this.rendererObject.useLegacyLights = d,
        this._updated(),
        this.resetShadows()
    }
    get useTotalFrameCount() {
        return console.warn("WebGi BaseRenderer: useTotalFrameCount is deprecated, use stableNoise instead"),
        this.stableNoise
    }
    set useTotalFrameCount(d) {
        console.warn("WebGi BaseRenderer: useTotalFrameCount is deprecated, use stableNoise instead"),
        this.stableNoise = d
    }
    get renderScale() {
        return this.displayCanvasScaling
    }
    set renderScale(d) {
        this.displayCanvasScaling = d
    }
}
;
function createRenderTargetKey(d={}) {
    var o, c;
    return [d.sizeMultiplier, d.samples, d.colorSpace, d.type, d.format, d.depthBuffer, d.depthTexture, (o = d.size) === null || o === void 0 ? void 0 : o.width, (c = d.size) === null || c === void 0 ? void 0 : c.height].join(";")
}
function autoGPUInstanceMeshes(d) {
    var o, c, h, _, b, _e, nt, it;
    if (!d.isMaterial && !d.isBufferGeometry)
        return;
    const at = Array.from(d.userData.__appliedMeshes).filter(_t => !_t.isInstancedMesh && !!_t.parent && _t.children.length === 0 && !Array.isArray(_t.material));
    if (at.length < 2)
        return;
    const ut = _t => {
        var vt;
        return _t.parent.uuid + "_" + _t.geometry.uuid + "_" + ((vt = _t.material) === null || vt === void 0 ? void 0 : vt.uuid)
    }
      , pt = new Map;
    for (const _t of at) {
        const vt = ut(_t);
        pt.has(vt) || pt.set(vt, []),
        pt.get(vt).push(_t),
        _t.updateMatrix()
    }
    const ht = pt.keys();
    for (const _t of ht) {
        const vt = pt.get(_t)
          , bt = vt[0];
        if (!bt || vt.length < 2)
            continue;
        const St = new three_module.ZLX(bt.geometry,bt.material,vt.length)
          , At = bt.userData;
        bt.userData = {},
        St.copy(bt),
        copyObject3DUserData(St.userData, At);
        const Et = bt.parent;
        St.position.set(0, 0, 0),
        St.rotation.set(0, 0, 0),
        St.scale.set(1, 1, 1),
        St.updateMatrix();
        const Pt = new Float32Array(3 * St.count)
          , It = new Float32Array(4 * St.count)
          , Dt = new Float32Array(3 * St.count);
        for (let Gt = 0; Gt < vt.length; Gt++) {
            const Bt = vt[Gt]
              , kt = Bt.matrix;
            kt.determinant() < 0 && (kt.elements[0] *= -1,
            kt.elements[1] *= -1,
            kt.elements[2] *= -1),
            St.setMatrixAt(Gt, kt),
            Bt.position.toArray(Pt, 3 * Gt),
            Bt.quaternion.toArray(It, 4 * Gt),
            Bt.scale.toArray(Dt, 3 * Gt),
            Bt.removeFromParent(),
            (h = (c = (o = Bt.material) === null || o === void 0 ? void 0 : o.userData) === null || c === void 0 ? void 0 : c.__appliedMeshes) === null || h === void 0 || h.delete(Bt),
            (_e = (b = (_ = Bt.geometry) === null || _ === void 0 ? void 0 : _.userData) === null || b === void 0 ? void 0 : b.__appliedMeshes) === null || _e === void 0 || _e.delete(Bt)
        }
        (it = (nt = St.material.userData) === null || nt === void 0 ? void 0 : nt.__appliedMeshes) === null || it === void 0 || it.add(St),
        St.geometry.userData.__appliedMeshes.add(St),
        St.sourceTrs = {
            TRANSLATION: new three_module.THS(Pt,3),
            ROTATION: new three_module.THS(It,4),
            SCALE: new three_module.THS(Dt,3)
        },
        St.instanceMatrix.needsUpdate = !0,
        Et.add(St),
        Et.setDirty(),
        console.log("autoGPUInstanceMeshes", _t, vt.length, bt, St)
    }
}
__decorate([serialize()], BaseRenderer.prototype, "stableNoise", void 0),
__decorate([serialize()], BaseRenderer.prototype, "useLegacyLights", null),
BaseRenderer = __decorate([serializable("RenderManager")], BaseRenderer);
class GLTFMeshGpuInstancingExporter {
    constructor(o) {
        this.writer = o,
        this.name = "EXT_mesh_gpu_instancing"
    }
    writeNode(o, c) {
        if (!o.isInstancedMesh)
            return;
        const h = this.writer
          , _ = o;
        let b = _.sourceTrs;
        if (!b) {
            const _e = new Float32Array(3 * _.count)
              , nt = new Float32Array(4 * _.count)
              , it = new Float32Array(3 * _.count)
              , at = new three_module.kn4
              , ut = new three_module.Pq0
              , pt = new three_module.PTz
              , ht = new three_module.Pq0;
            for (let _t = 0; _t < _.count; _t++)
                _.getMatrixAt(_t, at),
                at.decompose(ut, pt, ht),
                ut.toArray(_e, 3 * _t),
                pt.toArray(nt, 4 * _t),
                ht.toArray(it, 3 * _t);
            b = {
                TRANSLATION: new three_module.THS(_e,3),
                ROTATION: new three_module.THS(nt,4),
                SCALE: new three_module.THS(it,3)
            }
        }
        b = {
            TRANSLATION: h.processAccessor(b.TRANSLATION),
            ROTATION: h.processAccessor(b.ROTATION),
            SCALE: h.processAccessor(b.SCALE)
        },
        _.instanceColor && (b._COLOR_0 = h.processAccessor(_.instanceColor)),
        h.extensionsUsed[this.name] = !0,
        h.extensionsRequired[this.name] = !0,
        c.extensions = c.extensions || {},
        c.extensions[this.name] = {
            attributes: b
        }
    }
}
function makeObject3DUiConfig(d, o) {
    if (d.uiConfig)
        return d.uiConfig;
    const c = {
        type: "folder",
        label: () => d.name || "unnamed",
        expanded: !0,
        limitedUi: !0,
        children: [{
            type: "checkbox",
            label: "Visible",
            property: [d, "visible"],
            limitedUi: !0
        }, {
            type: "button",
            label: "Pick/Focus",
            value: () => {
                d.dispatchEvent({
                    type: "select",
                    ui: !0,
                    value: d,
                    focusCamera: !0
                })
            }
        }, {
            type: "button",
            label: "Pick Parent",
            hidden: () => !d.parent,
            value: () => {
                const _ = d.parent;
                _ && _.dispatchEvent({
                    type: "select",
                    ui: !0,
                    value: _
                })
            }
        }, {
            type: "input",
            label: "Name",
            property: [d, "name"],
            onChange: _ => {
                var b;
                _.last && ((b = d.setDirty) === null || b === void 0 || b.call(d, {
                    sceneUpdate: !0,
                    refreshUi: !0
                }))
            }
        }, {
            type: "checkbox",
            label: "Casts Shadow",
            hidden: () => !d.isMesh,
            property: [d, "castShadow"]
        }, {
            type: "checkbox",
            label: "Receive Shadow",
            hidden: () => !d.isMesh,
            property: [d, "receiveShadow"]
        }, {
            type: "checkbox",
            label: "Frustum culled",
            property: [d, "frustumCulled"]
        }, {
            type: "vec3",
            label: "Position",
            property: [d, "position"],
            limitedUi: !0
        }, {
            type: "vec3",
            label: "Rotation",
            property: [d, "rotation"],
            limitedUi: !0
        }, {
            type: "vec3",
            label: "Scale",
            property: [d, "scale"]
        }, {
            type: "input",
            label: "Render Order",
            property: [d, "renderOrder"]
        }, {
            type: "button",
            label: "Auto Scale",
            prompt: ["Auto Scale Radius: Object will be scaled to the given radius", d.userData.autoScaleRadius || "2", !0],
            value: _ => {
                if (!_)
                    return;
                const b = parseFloat(_);
                return Math.abs(b) > 0 ? (autoScaleObject3D(d, b),
                () => autoScaleObject3D(d, b, void 0, !0)) : void 0
            }
        }, {
            type: "button",
            label: "Auto Center",
            value: () => {
                if (confirm("Auto Center: Object will be centered, are you sure you want to proceed?"))
                    return autoCenterObject3D(d),
                    () => autoCenterObject3D(d, !0)
            }
        }, {
            type: "button",
            label: "Pivot to Node Center",
            value: () => {
                if (confirm("Pivot to Center: Adjust the pivot to bounding box center. The object will rotate around the new pivot, are you sure you want to proceed?"))
                    return pivotToBBoxCenter(d)
            }
        }, {
            type: "folder",
            label: "Rotate model",
            children: ["X +", "X -", "Y +", "Y -", "Z +", "Z -"].map(_ => ({
                type: "button",
                label: "Rotate " + _ + "90",
                value: () => {
                    var b;
                    d.rotateOnAxis(new three_module.Pq0(_.includes("X") ? 1 : 0,_.includes("Y") ? 1 : 0,_.includes("Z") ? 1 : 0), Math.PI / 2 * (_.includes("-") ? -1 : 1)),
                    (b = d.setDirty) === null || b === void 0 || b.call(d, {
                        sceneUpdate: !0,
                        refreshUi: !1
                    })
                }
            }))
        }, d.userData.license !== void 0 ? {
            type: "input",
            label: "License/Credits",
            property: [d.userData, "license"],
            limitedUi: !0
        } : {}]
    }
      , h = d;
    if (h != null && h.isMesh && o !== !1) {
        const _ = [ () => {
            const b = Object.entries(h.morphTargetDictionary || {});
            return b.length ? {
                label: "Morph Targets",
                type: "folder",
                children: b.map( ([_e,nt]) => ({
                    type: "slider",
                    label: _e,
                    bounds: [0, 1],
                    stepSize: 1e-4,
                    property: [h.morphTargetInfluences, nt],
                    onChange: it => {
                        var at;
                        (at = d.setDirty) === null || at === void 0 || at.call(d, {
                            sceneUpdate: it.last,
                            frameFade: !1,
                            refreshUi: !1
                        })
                    }
                }))
            } : void 0
        }
        , () => {
            var b;
            return (b = h.geometry) === null || b === void 0 ? void 0 : b.uiConfig
        }
        , () => {
            var b;
            return Array.isArray(h.material) ? h.material.length < 1 ? void 0 : {
                label: "Materials",
                type: "folder",
                children: h.material.map(_e => _e == null ? void 0 : _e.uiConfig).filter(_e => _e)
            } : (b = h.material) === null || b === void 0 ? void 0 : b.uiConfig
        }
        ];
        c.children.push(..._)
    }
    if (d != null && d.isCamera) {
        const _ = [{
            type: "button",
            label: "Set View",
            value: () => {
                var b;
                d.dispatchEvent({
                    type: "setView",
                    ui: !0,
                    camera: d
                }),
                (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0)
            }
        }, {
            type: "button",
            label: "Activate main",
            hidden: () => {
                var b;
                return (b = d.userData.iCamera) === null || b === void 0 ? void 0 : b.isActiveCamera
            }
            ,
            value: () => {
                var b;
                d.dispatchEvent({
                    type: "activateMain",
                    ui: !0,
                    camera: d
                }),
                (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0)
            }
        }, {
            type: "button",
            label: "Deactivate main",
            hidden: () => {
                var b;
                return !(!((b = d.userData.iCamera) === null || b === void 0) && b.isActiveCamera)
            }
            ,
            value: () => {
                var b;
                d.dispatchEvent({
                    type: "activateMain",
                    ui: !0,
                    camera: void 0
                }),
                (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0)
            }
        }, {
            type: "checkbox",
            label: "Auto LookAt Target",
            getValue: () => {
                var b;
                return (b = d.userData.autoLookAtTarget) !== null && b !== void 0 && b
            }
            ,
            setValue: b => {
                var _e;
                d.userData.autoLookAtTarget = b,
                (_e = c.uiRefresh) === null || _e === void 0 || _e.call(c, "postFrame", !0)
            }
        }];
        c.children.push(..._)
    }
    return d.uiConfig = c,
    c
}
function makeGeometryUiConfig(d) {
    return {
        label: "Geometry",
        type: "folder",
        children: [{
            type: "input",
            property: [d, "uuid"],
            disabled: !0
        }, {
            type: "input",
            property: [d, "name"]
        }, {
            type: "button",
            label: "Center Geometry",
            value: () => {
                d.center()
            }
        }, {
            type: "button",
            label: "Center Geometry (keep position)",
            value: () => {
                const o = new three_module.Pq0;
                d.center(o),
                o.negate();
                const c = d.userData.__appliedMeshes;
                for (const h of c)
                    h.updateMatrix(),
                    h.position.copy(o).applyMatrix4(h.matrix),
                    h.setDirty && h.setDirty()
            }
        }, {
            type: "button",
            label: "Compute vertex normals",
            value: () => {
                d.computeVertexNormals()
            }
        }, {
            type: "button",
            label: "Compute vertex tangents",
            value: () => {
                d.computeTangents()
            }
        }, {
            type: "button",
            label: "Normalize normals",
            value: () => {
                d.normalizeNormals()
            }
        }, {
            type: "button",
            label: "Convert to indexed",
            hidden: () => !!d.index,
            value: () => {
                var o;
                if (d.attributes.index)
                    return;
                const c = parseFloat((o = prompt("Tolerance", "-1")) !== null && o !== void 0 ? o : "-1");
                toIndexedGeometry(d, c)
            }
        }, {
            type: "button",
            label: "Convert to non-indexed",
            hidden: () => !d.index,
            value: () => {
                d.attributes.index && d.toNonIndexed()
            }
        }, {
            type: "button",
            label: "Create uv1 from uv",
            value: () => {
                d.hasAttribute("uv1") && !confirm("uv1 already exists, replace with uv data?") || d.setAttribute("uv1", d.getAttribute("uv"))
            }
        }, {
            type: "button",
            label: "Remove vertex color attribute",
            hidden: () => !d.hasAttribute("color"),
            value: () => {
                d.hasAttribute("color") ? confirm("Remove color attribute?") && d.deleteAttribute("color") : prompt("No color attribute found")
            }
        }, {
            type: "button",
            label: "Auto GPU Instances",
            hidden: () => !d.userData.__appliedMeshes || d.userData.__appliedMeshes.size < 2,
            value: () => {
                autoGPUInstanceMeshes(d)
            }
        }, {
            type: "input",
            label: "Mesh count",
            get value() {
                var o, c, h;
                return (h = (c = (o = d.userData) === null || o === void 0 ? void 0 : o.__appliedMeshes) === null || c === void 0 ? void 0 : c.size) !== null && h !== void 0 ? h : 0
            },
            set value(o) {},
            disabled: !0
        }]
    }
}
function setupIModel(d, o, c) {
    var h;
    if (!d)
        return void console.warn("WebGi: setupIModel: object is undefined");
    if (d.__disposed && (console.warn("WebGi: re-init/re-add disposed object, things might not work as intended", d),
    delete d.__disposed),
    d.userData || (d.userData = {}),
    d.userData.__iModelSetup && d.modelObject)
        return d;
    d.userData.__iModelSetup = !0;
    let _ = [];
    _.push( () => {
        [...d.children].forEach(pt => {
            var ht;
            (ht = pt == null ? void 0 : pt.dispose) === null || ht === void 0 || ht.call(pt),
            d.add(pt)
        }
        ),
        d.parent && d.removeFromParent()
    }
    ),
    d.isLight && !d.assetType ? (d.assetType = "light",
    d.lightObject = d) : d.isCamera ? (d.assetType = "camera",
    d.cameraObject = d) : d.assetType || (d.assetType = "model"),
    d.modelObject || (d.modelObject = d),
    d.setDirty || (d.setDirty = (pt={}) => {
        d.dispatchEvent({
            ...pt,
            type: "objectUpdate",
            object: d
        })
    }
    ,
    d.userData.setDirty && console.warn("WebGi: userData.setDirty already defined", d.userData.setDirty, d),
    d.userData.setDirty = pt => {
        var ht;
        console.warn("WebGi: userData.setDirty is deprecated, use setDirty directly"),
        (ht = d.setDirty) === null || ht === void 0 || ht.call(d, pt)
    }
    ),
    d.addEventListener("added", pt => {
        var ht, _t, vt;
        const bt = (_t = (ht = d.parent) === null || ht === void 0 ? void 0 : ht.userData.parentRoot) !== null && _t !== void 0 ? _t : d.parent;
        bt !== d.userData.parentRoot && d.traverse(St => {
            St.userData.parentRoot = bt
        }
        ),
        (vt = d.setDirty) === null || vt === void 0 || vt.call(d, {
            change: "addedToParent"
        })
    }
    ),
    d.addEventListener("removed", () => {
        var pt;
        (pt = d.setDirty) === null || pt === void 0 || pt.call(d, {
            change: "removedFromParent"
        }),
        d.userData.parentRoot !== void 0 && d.traverse(ht => {
            ht.userData.parentRoot = void 0
        }
        )
    }
    ),
    _.push( () => {}
    );
    const b = d.dispose;
    d.dispose = () => {
        d.dispatchEvent({
            type: "dispose"
        }),
        b == null || b.call(d)
    }
    ,
    d.userData.dispose && console.warn("WebGi: userData.dispose already defined"),
    d.userData.dispose = () => {
        var pt;
        console.warn("WebGi: userData.dispose is deprecated, use dispose directly"),
        (pt = d.dispose) === null || pt === void 0 || pt.call(d)
    }
    ;
    const _e = d;
    !_e.isMesh && !_e.isLine || _e.userData.__meshSetup || (_e.userData.__meshSetup = !0,
    _e.setMaterial || (_e.setMaterial = pt => setMeshMaterial(_e, pt)),
    _e.setGeometry || (_e.setGeometry = (pt, ht=!1) => setMeshGeometry(_e, pt, ht),
    _e.setGeometry(_e.geometry, !0)),
    d.userData.setMaterial && console.warn("WebGi: userData.setMaterial already defined"),
    d.userData.setMaterial = pt => {
        var ht;
        console.warn("WebGi: userData.setMaterial is deprecated, use setMaterial directly"),
        (ht = d.setMaterial) === null || ht === void 0 || ht.call(d, pt)
    }
    ,
    d.userData.setGeometry && console.warn("WebGi: userData.setGeometry already defined"),
    d.userData.setGeometry = (pt, ...ht) => {
        var _t;
        console.warn("WebGi: userData.setGeometry is deprecated, use setGeometry directly"),
        (_t = d.setGeometry) === null || _t === void 0 || _t.call(d, pt, ...ht)
    }
    ,
    d.userData.__keepShadowDef || (d.castShadow = !0,
    d.receiveShadow = !0,
    d.userData.__keepShadowDef = !0),
    _.push( () => {
        var pt, ht, _t, vt;
        const bt = ((pt = _e.setMaterial) === null || pt === void 0 ? void 0 : pt.call(_e, void 0)) || []
          , St = (ht = _e.setGeometry) === null || ht === void 0 ? void 0 : ht.call(_e, void 0);
        for (const At of bt)
            At && At.userData && At.userData.disposeOnIdle !== !1 && At.dispose();
        St && St.userData && St.userData.disposeOnIdle !== !1 && St.dispose(),
        (_t = _e.setMaterial) === null || _t === void 0 || _t.call(_e, bt),
        (vt = _e.setGeometry) === null || vt === void 0 || vt.call(_e, St)
    }
    )),
    d.uiConfig || d.assetType !== "model" && d.assetType !== "camera" || (makeObject3DUiConfig(d),
    _.push( () => {}
    )),
    d.addEventListener("objectUpdate", ({last: pt, refreshUi: ht}) => {
        var _t, vt;
        return pt !== !1 && ht !== !1 && ((vt = (_t = d.uiConfig) === null || _t === void 0 ? void 0 : _t.uiRefresh) === null || vt === void 0 ? void 0 : vt.call(_t, "postFrame", !0, 1))
    }
    ),
    d.userData.__autoParentDispatchEvents ? console.warn("WebGi: object.userData.__autoParentDispatchEvents already set") : (d.userData.__autoParentDispatchEvents = d.userData.__autoParentDispatchEvents || ["objectUpdate", "materialUpdate", "select", "materialChanged", "textureUpdate"],
    d.isCamera && d.userData.__autoParentDispatchEvents.push("activateMain", "setView")),
    o && (d.userData.parentRoot = o);
    const nt = d.dispatchEvent;
    d.dispatchEvent = pt => {
        var ht;
        !((ht = d.userData.__autoParentDispatchEvents) === null || ht === void 0) && ht.includes(pt.type) && (pt.parentDispatch = !0),
        pt.parentDispatch && (_t => {
            var vt;
            const bt = (vt = d.userData.parentRoot) !== null && vt !== void 0 ? vt : d.parent;
            bt != null && bt.modelObject && bt.dispatchEvent(_t)
        }
        )(pt),
        nt.call(d, pt)
    }
    ;
    const it = d.clone;
    d.clone = (...pt) => {
        const ht = d.userData;
        d.userData = {};
        let _t = it.call(d, ...pt);
        d.userData = ht,
        copyObject3DUserData(_t.userData, ht);
        const vt = d.userData.parentRoot;
        return vt && vt.assetType !== "model" && console.warn("WebGi: Cloning an object with a parent that is not an IModel is not supported"),
        _t = setupIModel(_t, vt, c),
        _t.userData.cloneParent = d.uuid,
        _t
    }
    ;
    const at = d.copy;
    d.copy = (pt, ...ht) => {
        const _t = pt.userData;
        pt.userData = {};
        const vt = at.call(d, pt, ...ht);
        return pt.userData = _t,
        copyObject3DUserData(d.userData, pt),
        vt
    }
    ;
    const ut = d.add;
    return d.add = (...pt) => (pt.forEach(ht => setupIModel(ht, d.userData.parentRoot || d, c)),
    ut.call(d, ...pt)),
    (d = (h = c == null ? void 0 : c(d)) !== null && h !== void 0 ? h : d).addEventListener("dispose", () => {
        _.forEach(pt => pt()),
        _ = []
    }
    ),
    [...d.children].forEach(pt => setupIModel(pt, d, c)),
    d
}
function setMeshMaterial(d, o) {
    var c, h, _, b, _e;
    const nt = (Array.isArray(o) ? o : [o]).map(ht => ht == null ? void 0 : ht.materialObject).filter(ht => ht);
    if (d.material == nt || nt.length === 1 && d.material === nt[0])
        return [];
    d.userData.__materialUpdater || (d.userData.__materialUpdater = () => {
        d.dispatchEvent({
            type: "materialUpdate"
        })
    }
    ),
    d.userData.__textureUpdater || (d.userData.__textureUpdater = () => {
        d.dispatchEvent({
            type: "textureUpdate"
        })
    }
    );
    let it = [];
    const at = []
      , ut = Array.isArray(d.material) ? [...d.material] : [d.material];
    for (const ht of ut)
        ht && it.push(ht);
    const pt = [];
    for (const ht of nt)
        ht.userData.__appliedMeshes || (ht.userData.__appliedMeshes = new Set),
        pt.push(ht),
        ht && (it.includes(ht) ? it = it.filter(_t => _t !== ht) : at.push(ht));
    d.material = pt.length !== 1 ? pt : (c = pt[0]) !== null && c !== void 0 ? c : void 0;
    for (const ht of it)
        ht.removeEventListener("materialUpdate", d.userData.__materialUpdater),
        ht.removeEventListener("textureUpdate", d.userData.__textureUpdater),
        (_ = (h = ht.userData) === null || h === void 0 ? void 0 : h.__appliedMeshes) === null || _ === void 0 || _.delete(d),
        ht.dispatchEvent({
            type: "removeFromMesh",
            mesh: d,
            object: d
        });
    for (const ht of at)
        ht.addEventListener("materialUpdate", d.userData.__materialUpdater),
        ht.addEventListener("textureUpdate", d.userData.__textureUpdater),
        ht.userData.__appliedMeshes.add(d),
        ht.dispatchEvent({
            type: "addToMesh",
            mesh: d,
            object: d
        });
    return d.dispatchEvent({
        type: "materialChanged",
        material: o ?? void 0,
        mesh: d
    }),
    (_e = (b = d.uiConfig) === null || b === void 0 ? void 0 : b.uiRefresh) === null || _e === void 0 || _e.call(b, "postFrame", !0),
    ut
}
function setMeshGeometry(d, o, c=!1) {
    var h, _, b, _e, nt, it, at;
    d.userData.__objectUpdater || (d.userData.__objectUpdater = ht => {
        d.dispatchEvent({
            ...ht,
            type: "objectUpdate"
        })
    }
    );
    let ut = d.geometry;
    const pt = ut;
    return (ut !== o || c) && (ut && (ut.removeEventListener("geometryUpdate", d.userData.__objectUpdater),
    (_ = (h = ut.userData) === null || h === void 0 ? void 0 : h.__appliedMeshes) === null || _ === void 0 || _.delete(d)),
    ut = o,
    ut && !ut.userData.__appliedMeshes && (ut.userData.__appliedMeshes = new Set),
    d.geometry = (b = ut) !== null && b !== void 0 ? b : void 0,
    ut && (d.updateMorphTargets(),
    ut.addEventListener("geometryUpdate", d.userData.__objectUpdater),
    (nt = (_e = ut.userData) === null || _e === void 0 ? void 0 : _e.__appliedMeshes) === null || nt === void 0 || nt.add(d))),
    o && !o.uiConfig && (o.uiConfig = makeGeometryUiConfig(d.geometry)),
    d.dispatchEvent({
        type: "geometryChanged",
        geometry: o ?? void 0
    }),
    (at = (it = d.uiConfig) === null || it === void 0 ? void 0 : it.uiRefresh) === null || at === void 0 || at.call(it, "postFrame", !0),
    pt === ut ? void 0 : pt || void 0
}
const iGeometryIgnoredUserData = ["appliedMeshes"]
  , iModelIgnoredUserData = ["parentRoot", "iCamera", "iModel"];
function copyObject3DUserData(d, o) {
    if (o)
        for (const c of Object.keys(o))
            iModelIgnoredUserData.includes(c) || c.startsWith("__") || typeof d[c] != "function" && typeof o[c] != "function" && (d[c] = o[c]);
    return d
}
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues && !(getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto)))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return getRandomValues(rnds8)
}
var regex = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(d) {
    return typeof d == "string" && regex.test(d)
}
for (var esm_browser_validate = validate, byteToHex = [], i = 0; i < 256; ++i)
    byteToHex.push((i + 256).toString(16).substr(1));
function stringify(d) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , c = (byteToHex[d[o + 0]] + byteToHex[d[o + 1]] + byteToHex[d[o + 2]] + byteToHex[d[o + 3]] + "-" + byteToHex[d[o + 4]] + byteToHex[d[o + 5]] + "-" + byteToHex[d[o + 6]] + byteToHex[d[o + 7]] + "-" + byteToHex[d[o + 8]] + byteToHex[d[o + 9]] + "-" + byteToHex[d[o + 10]] + byteToHex[d[o + 11]] + byteToHex[d[o + 12]] + byteToHex[d[o + 13]] + byteToHex[d[o + 14]] + byteToHex[d[o + 15]]).toLowerCase();
    if (!esm_browser_validate(c))
        throw TypeError("Stringified UUID is invalid");
    return c
}
var esm_browser_stringify = stringify;
function v4(d, o, c) {
    var h = (d = d || {}).random || (d.rng || rng)();
    if (h[6] = 15 & h[6] | 64,
    h[8] = 63 & h[8] | 128,
    o) {
        c = c || 0;
        for (var _ = 0; _ < 16; ++_)
            o[c + _] = h[_];
        return o
    }
    return esm_browser_stringify(h)
}
var esm_browser_v4 = v4;
const uiConfigDecorators_typeMap = new Map;
function uiConfig(d, o) {
    return (c, h) => {
        const _ = c.constructor;
        if (_ === Object)
            throw new Error("All properties in an object are serialized by default");
        uiConfigDecorators_typeMap.has(_) || uiConfigDecorators_typeMap.set(_, []);
        const b = uiConfigDecorators_typeMap.get(_);
        if (!(b.findIndex(_e => _e.propKey === h) < 0))
            throw new Error(`Property ${h} already has a uiConfig decorator`);
        b.push({
            params: o || {},
            propKey: h,
            uiType: d
        })
    }
}
function uiToggle(d, o) {
    return uiConfig("checkbox", {
        label: d,
        params: o
    })
}
function uiMonitor(d, o) {
    return uiConfig("monitor", {
        label: d,
        params: o
    })
}
function uiSlider(d, o, c, h) {
    return uiConfig("slider", {
        label: d,
        bounds: o,
        stepSize: c,
        params: h
    })
}
function uiVector(d, o, c, h) {
    return uiConfig("vec", {
        label: d,
        bounds: o,
        stepSize: c,
        params: h
    })
}
function uiDropdown(d, o, c) {
    return uiConfig("dropdown", {
        label: d,
        children: o,
        params: c
    })
}
function uiButton(d, o) {
    return uiConfig("button", {
        label: d,
        params: o
    })
}
function uiInput(d, o) {
    return uiConfig("input", {
        label: d,
        params: o
    })
}
function uiColor(d, o) {
    return uiConfig("color", {
        label: d,
        params: o
    })
}
function uiImage(d, o) {
    return uiConfig("image", {
        label: d,
        params: o
    })
}
function generateUiConfig(d) {
    let o = d == null ? void 0 : d.constructor;
    if (!d || !o)
        return [];
    const c = []
      , h = [];
    for (; o && o !== Object; )
        h.push(o),
        o = Object.getPrototypeOf(o);
    if (!h.length || Array.isArray(d)) {
        const _ = typeof d == "object" ? Object.keys(d) : Array.isArray(d) ? d.map( (b, _e) => _e) : [];
        for (const b of _) {
            const _e = d[b];
            if (_e == null)
                continue;
            const nt = _e == null ? void 0 : _e.uiConfig;
            if (nt)
                c.push(nt);
            else {
                const it = valueToUiType(_e);
                it === "folder" ? c.push(generateUiFolder(b + "", _e, void 0, "folder", !0)) : it && c.push({
                    type: it,
                    label: b + "",
                    property: [d, b]
                })
            }
        }
    }
    return h.reverse().forEach(_ => {
        var b;
        (b = uiConfigDecorators_typeMap.get(_)) === null || b === void 0 || b.forEach( ({params: _e, propKey: nt, uiType: it}) => {
            let at;
            if (!it) {
                const ut = d[nt];
                at = ut == null ? void 0 : ut.uiConfig,
                at ? c.push(at) : ut != null && ((it = valueToUiType(ut)) === "folder" ? at = generateUiFolder(nt + "", ut, void 0, "folder", !0) : it && (at = {
                    type: it,
                    label: nt + "",
                    property: [d, nt]
                }))
            }
            if (at || (at = {
                property: [d, nt],
                type: it || "input"
            }),
            _e) {
                const ut = typeof _e.params == "function" ? _e.params(d) : _e.params || {};
                delete _e.params,
                Object.assign(at, {
                    ..._e,
                    ...ut
                })
            }
            c.push(at)
        }
        )
    }
    ),
    c
}
function generateUiFolder(d, o, c={}, h="folder", _=!1) {
    return {
        type: h,
        label: d,
        children: _ ? [ () => generateUiConfig(Ee$1(o))] : generateUiConfig(Ee$1(o)),
        uuid: esm_browser_v4(),
        ...c
    }
}
function uiFolder(d, o, c="folder") {
    return h => class extends h {
        constructor() {
            super(...arguments),
            this.uiConfig = generateUiFolder(d, this, o || {}, c)
        }
    }
}
function uiPanel(d, o) {
    return uiFolder(d, o, "panel")
}
function valueToUiType(d) {
    return d == null ? null : Array.isArray(d) ? "folder" : typeof d == "boolean" ? "checkbox" : typeof d == "number" ? "number" : typeof d == "string" ? "input" : typeof d == "function" ? "button" : typeof d.x == "number" ? "vec" : typeof d.r == "number" ? "color" : d.isTexture ? "image" : typeof d == "object" ? "folder" : null
}
const _changeEvent = {
    type: "change"
}
  , _startEvent = {
    type: "start"
}
  , _endEvent = {
    type: "end"
}
  , _ray = new three_module.RlV
  , _plane = new three_module.Zcv
  , TILT_LIMIT = Math.cos(70 * three_module.cj9.DEG2RAD);
class OrbitControls extends three_module.Qev {
    constructor(o, c) {
        super(),
        this.object = o,
        this.domElement = c,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new three_module.Pq0,
        this.minDistance = 1e-5,
        this.maxDistance = 1 / 0,
        this.autoPushTarget = !0,
        this.autoPullTarget = !0,
        this.clampMax = new three_module.Pq0(1 / 0,1 / 0,1 / 0),
        this.clampMin = new three_module.Pq0(-1 / 0,-1 / 0,-1 / 0),
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.maxZoomSpeed = 1,
        this.maxZoomSpeed = 1,
        this.dollyZoom = !1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.zoomToCursor = !1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.throttleUpdate = 0,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: three_module.kBv.ROTATE,
            MIDDLE: three_module.kBv.DOLLY,
            RIGHT: three_module.kBv.PAN
        },
        this.touches = {
            ONE: three_module.wtR.ROTATE,
            TWO: three_module.wtR.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return nt.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return nt.theta
        }
        ,
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        this.listenToKeyEvents = function(Ur) {
            Ur.addEventListener("keydown", Nn),
            this._domElementKeyEvents = Ur
        }
        ,
        this.stopListenToKeyEvents = function() {
            this._domElementKeyEvents.removeEventListener("keydown", Nn),
            this._domElementKeyEvents = null
        }
        ,
        this.saveState = function() {
            h.target0.copy(h.target),
            h.position0.copy(h.object.position),
            h.zoom0 = h.object.zoom
        }
        ,
        this.reset = function() {
            h.target.copy(h.target0),
            h.object.position.copy(h.position0),
            h.object.zoom = h.zoom0,
            h.object.updateProjectionMatrix(),
            h.dispatchEvent(_changeEvent),
            h.update(),
            b = _.NONE
        }
        ,
        this.update = function() {
            const Ur = new three_module.Pq0
              , nn = new three_module.PTz().setFromUnitVectors(o.up, new three_module.Pq0(0,1,0))
              , xn = nn.clone().invert()
              , ur = new three_module.Pq0
              , pr = new three_module.PTz
              , Ir = new three_module.Pq0
              , jr = 2 * Math.PI;
            return function(Qr=null) {
                if (this.throttleUpdate && this.throttleUpdate >= 1 && Date.now() - 0 < 1e3 / this.throttleUpdate)
                    return;
                const Or = h.object.position;
                Ur.copy(Or).sub(h.target),
                Ur.applyQuaternion(nn),
                nt.setFromVector3(Ur),
                h.autoRotate && b === _.NONE && Ht(function(Cn) {
                    return Cn !== null ? 2 * Math.PI / 60 * h.autoRotateSpeed * Cn : 2 * Math.PI / 60 / 60 * h.autoRotateSpeed
                }(Qr)),
                h.enableDamping ? (nt.theta += it.theta * h.dampingFactor,
                nt.phi += it.phi * h.dampingFactor) : (nt.theta += it.theta,
                nt.phi += it.phi);
                let qr = h.minAzimuthAngle
                  , gn = h.maxAzimuthAngle;
                isFinite(qr) && isFinite(gn) && (qr < -Math.PI ? qr += jr : qr > Math.PI && (qr -= jr),
                gn < -Math.PI ? gn += jr : gn > Math.PI && (gn -= jr),
                nt.theta = qr <= gn ? Math.max(qr, Math.min(gn, nt.theta)) : nt.theta > (qr + gn) / 2 ? Math.max(qr, nt.theta) : Math.min(gn, nt.theta)),
                nt.phi = Math.max(h.minPolarAngle, Math.min(h.maxPolarAngle, nt.phi)),
                nt.makeSafe(),
                h.enableDamping === !0 ? h.target.addScaledVector(ut, h.dampingFactor) : h.target.add(ut);
                let Mn = 0;
                h.zoomToCursor && Gt || h.object.isOrthographicCamera || (Math.abs(it.radius) > 0 && (h.dollyZoom && (h.object.zoom = Math.max(Math.max(h.minZoom, .1), Math.min(Math.min(h.maxZoom, 20), h.object.zoom * (1 + it.radius * (h.enableDamping ? h.dampingFactor : 1)))),
                h.object.updateProjectionMatrix(),
                (h.object.zoom >= Math.min(h.maxZoom, 20) || h.object.zoom <= Math.max(h.minZoom, .1)) && (it.radius = 0)),
                nt.radius *= 1 + it.radius * (h.enableDamping ? h.dampingFactor : 1)),
                Math.abs(at - 1) > 1e-5 && (h.dollyZoom && (h.object.zoom = Math.max(Math.max(h.minZoom, .1), Math.min(Math.min(h.maxZoom, 20), h.object.zoom * at)),
                h.object.updateProjectionMatrix(),
                (h.object.zoom >= Math.min(h.maxZoom, 20) || h.object.zoom <= Math.max(h.minZoom, .1)) && (at = 1)),
                nt.radius *= at),
                h.autoPushTarget && nt.radius < h.minDistance && (Mn = h.minDistance - nt.radius),
                h.autoPullTarget && nt.radius > h.maxDistance && (Mn = h.maxDistance - nt.radius)),
                nt.radius = gr(nt.radius),
                Ur.setFromSpherical(nt),
                Ur.applyQuaternion(xn),
                Or.copy(h.target).add(Ur),
                h.target.add(Ur.normalize().multiplyScalar(-Mn)),
                Or.clamp(h.clampMin, h.clampMax),
                h.target.clamp(h.clampMin, h.clampMax),
                h.object.lookAt(h.target);
                let Tn = !1;
                h.enableDamping === !0 && Math.abs(it.theta) + Math.abs(it.phi) + Math.abs(it.radius) + ut.length() > .001 ? (it.theta *= 1 - h.dampingFactor,
                it.phi *= 1 - h.dampingFactor,
                it.radius *= 1 - h.dampingFactor,
                ut.multiplyScalar(1 - h.dampingFactor),
                Tn = !0) : (it.set(0, 0, 0),
                ut.set(0, 0, 0));
                let wn = !1;
                if (h.zoomToCursor && Gt) {
                    let Cn = null;
                    if (h.object.isPerspectiveCamera) {
                        const fn = nt.radius;
                        Cn = nt.radius * at,
                        Cn = gr(Cn);
                        const bn = fn - Cn;
                        h.object.position.addScaledVector(It, bn),
                        h.object.updateMatrixWorld()
                    } else if (h.object.isOrthographicCamera) {
                        const fn = new three_module.Pq0(Dt.x,Dt.y,0);
                        fn.unproject(h.object),
                        h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom / at)),
                        h.object.updateProjectionMatrix(),
                        wn = !0;
                        const bn = new three_module.Pq0(Dt.x,Dt.y,0);
                        bn.unproject(h.object),
                        h.object.position.sub(bn).add(fn),
                        h.object.updateMatrixWorld(),
                        Cn = nt.radius
                    } else
                        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                        h.zoomToCursor = !1;
                    Cn !== null && (this.screenSpacePanning ? h.target.set(0, 0, -1).transformDirection(h.object.matrix).multiplyScalar(Cn).add(h.object.position) : (_ray.origin.copy(h.object.position),
                    _ray.direction.set(0, 0, -1).transformDirection(h.object.matrix),
                    Math.abs(h.object.up.dot(_ray.direction)) < TILT_LIMIT ? o.lookAt(h.target) : (_plane.setFromNormalAndCoplanarPoint(h.object.up, h.target),
                    _ray.intersectPlane(_plane, h.target))))
                } else
                    h.object.isOrthographicCamera && (h.object.zoom = Math.max(h.minZoom, Math.min(h.maxZoom, h.object.zoom / at)),
                    h.object.updateProjectionMatrix(),
                    wn = !0);
                return at = 1,
                Gt = !1,
                !!(wn || Tn || ur.distanceToSquared(h.object.position) > _e || 8 * (1 - pr.dot(h.object.quaternion)) > _e || Ir.distanceToSquared(h.target) > 0) && (h.dispatchEvent(_changeEvent),
                ur.copy(h.object.position),
                pr.copy(h.object.quaternion),
                Ir.copy(h.target),
                wn = !1,
                !0)
            }
        }(),
        this.stopDamping = function() {
            it.set(0, 0, 0),
            ut.set(0, 0, 0)
        }
        ,
        this.dispose = function() {
            h.domElement.removeEventListener("contextmenu", Wn),
            h.domElement.removeEventListener("pointerdown", vr),
            h.domElement.removeEventListener("pointercancel", rn),
            h.domElement.removeEventListener("wheel", hn),
            h.domElement.removeEventListener("pointermove", Zr),
            h.domElement.removeEventListener("pointerup", rn),
            h._domElementKeyEvents !== null && (h._domElementKeyEvents.removeEventListener("keydown", Nn),
            h._domElementKeyEvents = null)
        }
        ;
        const h = this
          , _ = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let b = _.NONE;
        const _e = 1e-6
          , nt = new three_module.YHV
          , it = new three_module.YHV(0,0,0);
        let at = 1;
        const ut = new three_module.Pq0
          , pt = new three_module.I9Y
          , ht = new three_module.I9Y
          , _t = new three_module.I9Y
          , vt = new three_module.I9Y
          , bt = new three_module.I9Y
          , St = new three_module.I9Y
          , At = new three_module.I9Y
          , Et = new three_module.I9Y
          , Pt = new three_module.I9Y
          , It = new three_module.Pq0
          , Dt = new three_module.I9Y;
        let Gt = !1;
        const Bt = []
          , kt = {};
        function Ut() {
            return !h.enableDamping || h.zoomToCursor || h.object.isOrthographicCamera ? Math.pow(.95, h.zoomSpeed) : 1
        }
        function Ht(Ur) {
            it.theta -= Ur
        }
        function Kt(Ur) {
            it.phi -= Ur
        }
        this.rotateUp = Kt,
        this.rotateLeft = Ht;
        const Jt = function() {
            const Ur = new three_module.Pq0;
            return function(nn, xn) {
                Ur.setFromMatrixColumn(xn, 0),
                Ur.multiplyScalar(-nn),
                ut.add(Ur)
            }
        }()
          , or = function() {
            const Ur = new three_module.Pq0;
            return function(nn, xn) {
                h.screenSpacePanning === !0 ? Ur.setFromMatrixColumn(xn, 1) : (Ur.setFromMatrixColumn(xn, 0),
                Ur.crossVectors(h.object.up, Ur)),
                Ur.multiplyScalar(nn),
                ut.add(Ur)
            }
        }()
          , ir = function() {
            const Ur = new three_module.Pq0;
            return function(nn, xn) {
                const ur = h.domElement;
                if (h.object.isPerspectiveCamera) {
                    const pr = h.object.position;
                    Ur.copy(pr).sub(h.target);
                    let Ir = Ur.length();
                    Ir *= Math.tan(h.object.fov / 2 * Math.PI / 180),
                    Jt(2 * nn * Ir / ur.clientHeight, h.object.matrix),
                    or(2 * xn * Ir / ur.clientHeight, h.object.matrix)
                } else
                    h.object.isOrthographicCamera ? (Jt(nn * (h.object.right - h.object.left) / h.object.zoom / ur.clientWidth, h.object.matrix),
                    or(xn * (h.object.top - h.object.bottom) / h.object.zoom / ur.clientHeight, h.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    h.enablePan = !1)
            }
        }();
        function lr(Ur, nn=0) {
            h.object.isPerspectiveCamera || h.object.isOrthographicCamera ? (at /= Ur,
            it.radius = Math.max(-h.maxZoomSpeed, Math.min(h.maxZoomSpeed, it.radius - nn))) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            h.enableZoom = !1)
        }
        function ar(Ur, nn=0) {
            h.object.isPerspectiveCamera || h.object.isOrthographicCamera ? (at *= Ur,
            it.radius = Math.max(-h.maxZoomSpeed, Math.min(h.maxZoomSpeed, it.radius + nn))) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            h.enableZoom = !1)
        }
        function hr(Ur) {
            if (!h.zoomToCursor)
                return;
            Gt = !0;
            const nn = h.domElement.getBoundingClientRect()
              , xn = Ur.clientX - nn.left
              , ur = Ur.clientY - nn.top
              , pr = nn.width
              , Ir = nn.height;
            Dt.x = xn / pr * 2 - 1,
            Dt.y = -ur / Ir * 2 + 1,
            It.set(Dt.x, Dt.y, 1).unproject(h.object).sub(h.object.position).normalize()
        }
        function gr(Ur) {
            return Math.max(h.minDistance, Math.min(h.maxDistance, Ur))
        }
        function dr(Ur) {
            pt.set(Ur.clientX, Ur.clientY)
        }
        function cr(Ur) {
            vt.set(Ur.clientX, Ur.clientY)
        }
        function Ar() {
            if (Bt.length === 1)
                pt.set(Bt[0].pageX, Bt[0].pageY);
            else {
                const Ur = .5 * (Bt[0].pageX + Bt[1].pageX)
                  , nn = .5 * (Bt[0].pageY + Bt[1].pageY);
                pt.set(Ur, nn)
            }
        }
        function wr() {
            if (Bt.length === 1)
                vt.set(Bt[0].pageX, Bt[0].pageY);
            else {
                const Ur = .5 * (Bt[0].pageX + Bt[1].pageX)
                  , nn = .5 * (Bt[0].pageY + Bt[1].pageY);
                vt.set(Ur, nn)
            }
        }
        function Rr() {
            const Ur = Bt[0].pageX - Bt[1].pageX
              , nn = Bt[0].pageY - Bt[1].pageY
              , xn = Math.sqrt(Ur * Ur + nn * nn);
            At.set(0, xn)
        }
        function Cr(Ur) {
            if (Bt.length == 1)
                ht.set(Ur.pageX, Ur.pageY);
            else {
                const xn = mo(Ur)
                  , ur = .5 * (Ur.pageX + xn.x)
                  , pr = .5 * (Ur.pageY + xn.y);
                ht.set(ur, pr)
            }
            _t.subVectors(ht, pt).multiplyScalar(h.rotateSpeed);
            const nn = h.domElement;
            Ht(2 * Math.PI * _t.x / nn.clientHeight),
            Kt(2 * Math.PI * _t.y / nn.clientHeight),
            pt.copy(ht)
        }
        function tr(Ur) {
            if (Bt.length === 1)
                bt.set(Ur.pageX, Ur.pageY);
            else {
                const nn = mo(Ur)
                  , xn = .5 * (Ur.pageX + nn.x)
                  , ur = .5 * (Ur.pageY + nn.y);
                bt.set(xn, ur)
            }
            St.subVectors(bt, vt).multiplyScalar(h.panSpeed),
            ir(St.x, St.y),
            vt.copy(bt)
        }
        function fr(Ur) {
            const nn = mo(Ur)
              , xn = Ur.pageX - nn.x
              , ur = Ur.pageY - nn.y
              , pr = Math.sqrt(xn * xn + ur * ur);
            Et.set(0, pr),
            Pt.set(0, Math.pow(Et.y / At.y, 6 * h.zoomSpeed)),
            lr(Pt.y),
            At.copy(Et)
        }
        function vr(Ur) {
            h.enabled !== !1 && (Bt.length === 0 && (h.domElement.setPointerCapture(Ur.pointerId),
            h.domElement.addEventListener("pointermove", Zr),
            h.domElement.addEventListener("pointerup", rn)),
            function(nn) {
                Bt.push(nn)
            }(Ur),
            Ur.pointerType === "touch" ? function(nn) {
                switch (qn(nn),
                Bt.length) {
                case 1:
                    switch (h.touches.ONE) {
                    case three_module.wtR.ROTATE:
                        if (h.enableRotate === !1)
                            return;
                        Ar(),
                        b = _.TOUCH_ROTATE;
                        break;
                    case three_module.wtR.PAN:
                        if (h.enablePan === !1)
                            return;
                        wr(),
                        b = _.TOUCH_PAN;
                        break;
                    default:
                        b = _.NONE
                    }
                    break;
                case 2:
                    switch (h.touches.TWO) {
                    case three_module.wtR.DOLLY_PAN:
                        if (h.enableZoom === !1 && h.enablePan === !1)
                            return;
                        h.enableZoom && Rr(),
                        h.enablePan && wr(),
                        b = _.TOUCH_DOLLY_PAN;
                        break;
                    case three_module.wtR.DOLLY_ROTATE:
                        if (h.enableZoom === !1 && h.enableRotate === !1)
                            return;
                        h.enableZoom && Rr(),
                        h.enableRotate && Ar(),
                        b = _.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        b = _.NONE
                    }
                    break;
                default:
                    b = _.NONE
                }
                b !== _.NONE && h.dispatchEvent(_startEvent)
            }(Ur) : function(nn) {
                let xn;
                switch (nn.button) {
                case 0:
                    xn = h.mouseButtons.LEFT;
                    break;
                case 1:
                    xn = h.mouseButtons.MIDDLE;
                    break;
                case 2:
                    xn = h.mouseButtons.RIGHT;
                    break;
                default:
                    xn = -1
                }
                switch (xn) {
                case three_module.kBv.DOLLY:
                    if (h.enableZoom === !1)
                        return;
                    (function(ur) {
                        hr(ur),
                        At.set(ur.clientX, ur.clientY)
                    }
                    )(nn),
                    b = _.DOLLY;
                    break;
                case three_module.kBv.ROTATE:
                    if (nn.ctrlKey || nn.metaKey || nn.shiftKey) {
                        if (h.enablePan === !1)
                            return;
                        cr(nn),
                        b = _.PAN
                    } else {
                        if (h.enableRotate === !1)
                            return;
                        dr(nn),
                        b = _.ROTATE
                    }
                    break;
                case three_module.kBv.PAN:
                    if (nn.ctrlKey || nn.metaKey || nn.shiftKey) {
                        if (h.enableRotate === !1)
                            return;
                        dr(nn),
                        b = _.ROTATE
                    } else {
                        if (h.enablePan === !1)
                            return;
                        cr(nn),
                        b = _.PAN
                    }
                    break;
                default:
                    b = _.NONE
                }
                b !== _.NONE && h.dispatchEvent(_startEvent)
            }(Ur))
        }
        function Zr(Ur) {
            h.enabled !== !1 && (Ur.pointerType === "touch" ? function(nn) {
                switch (qn(nn),
                b) {
                case _.TOUCH_ROTATE:
                    if (h.enableRotate === !1)
                        return;
                    Cr(nn),
                    h.update();
                    break;
                case _.TOUCH_PAN:
                    if (h.enablePan === !1)
                        return;
                    tr(nn),
                    h.update();
                    break;
                case _.TOUCH_DOLLY_PAN:
                    if (h.enableZoom === !1 && h.enablePan === !1)
                        return;
                    (function(xn) {
                        h.enableZoom && fr(xn),
                        h.enablePan && tr(xn)
                    }
                    )(nn),
                    h.update();
                    break;
                case _.TOUCH_DOLLY_ROTATE:
                    if (h.enableZoom === !1 && h.enableRotate === !1)
                        return;
                    (function(xn) {
                        h.enableZoom && fr(xn),
                        h.enableRotate && Cr(xn)
                    }
                    )(nn),
                    h.update();
                    break;
                default:
                    b = _.NONE
                }
            }(Ur) : Ur.buttons ? function(nn) {
                switch (b) {
                case _.ROTATE:
                    if (h.enableRotate === !1)
                        return;
                    (function(xn) {
                        ht.set(xn.clientX, xn.clientY),
                        _t.subVectors(ht, pt).multiplyScalar(h.rotateSpeed);
                        const ur = h.domElement;
                        Ht(2 * Math.PI * _t.x / ur.clientHeight),
                        Kt(2 * Math.PI * _t.y / ur.clientHeight),
                        pt.copy(ht),
                        h.update()
                    }
                    )(nn);
                    break;
                case _.DOLLY:
                    if (h.enableZoom === !1)
                        return;
                    (function(xn) {
                        Et.set(xn.clientX, xn.clientY),
                        Pt.subVectors(Et, At),
                        Pt.y > 0 ? lr(Ut()) : Pt.y < 0 && ar(Ut()),
                        At.copy(Et),
                        h.update()
                    }
                    )(nn);
                    break;
                case _.PAN:
                    if (h.enablePan === !1)
                        return;
                    (function(xn) {
                        bt.set(xn.clientX, xn.clientY),
                        St.subVectors(bt, vt).multiplyScalar(h.panSpeed),
                        ir(St.x, St.y),
                        vt.copy(bt),
                        h.update()
                    }
                    )(nn)
                }
            }(Ur) : rn(Ur))
        }
        function rn(Ur) {
            (function(nn) {
                delete kt[nn.pointerId];
                for (let xn = 0; xn < Bt.length; xn++)
                    if (Bt[xn].pointerId == nn.pointerId)
                        return void Bt.splice(xn, 1)
            }
            )(Ur),
            Bt.length === 0 && (h.domElement.releasePointerCapture(Ur.pointerId),
            h.domElement.removeEventListener("pointermove", Zr),
            h.domElement.removeEventListener("pointerup", rn)),
            h.dispatchEvent(_endEvent),
            b = _.NONE
        }
        function hn(Ur) {
            h.enabled !== !1 && h.enableZoom !== !1 && b === _.NONE && (Ur.preventDefault(),
            h.dispatchEvent(_startEvent),
            function(nn) {
                hr(nn);
                let xn = 0;
                switch (nn.deltaMode) {
                case 2:
                    xn += 1 * nn.deltaY;
                    break;
                case 1:
                    xn += .4 * nn.deltaY;
                    break;
                default:
                    xn += .01 * nn.deltaY
                }
                nn.deltaY < 0 ? h.zoomToCursor || h.object.isOrthographicCamera ? ar(Ut()) : ar(1, xn * h.zoomSpeed) : nn.deltaY > 0 && (h.zoomToCursor || h.object.isOrthographicCamera ? lr(Ut()) : lr(1, -xn * h.zoomSpeed)),
                h.update()
            }(Ur),
            h.dispatchEvent(_endEvent))
        }
        function Nn(Ur) {
            h.enabled !== !1 && h.enablePan !== !1 && function(nn) {
                let xn = !1;
                switch (nn.code) {
                case h.keys.UP:
                    nn.ctrlKey || nn.metaKey || nn.shiftKey ? Kt(2 * Math.PI * h.rotateSpeed / h.domElement.clientHeight) : ir(0, h.keyPanSpeed),
                    xn = !0;
                    break;
                case h.keys.BOTTOM:
                    nn.ctrlKey || nn.metaKey || nn.shiftKey ? Kt(-2 * Math.PI * h.rotateSpeed / h.domElement.clientHeight) : ir(0, -h.keyPanSpeed),
                    xn = !0;
                    break;
                case h.keys.LEFT:
                    nn.ctrlKey || nn.metaKey || nn.shiftKey ? Ht(2 * Math.PI * h.rotateSpeed / h.domElement.clientHeight) : ir(h.keyPanSpeed, 0),
                    xn = !0;
                    break;
                case h.keys.RIGHT:
                    nn.ctrlKey || nn.metaKey || nn.shiftKey ? Ht(-2 * Math.PI * h.rotateSpeed / h.domElement.clientHeight) : ir(-h.keyPanSpeed, 0),
                    xn = !0
                }
                xn && (nn.preventDefault(),
                h.update())
            }(Ur)
        }
        function Wn(Ur) {
            h.enabled !== !1 && Ur.preventDefault()
        }
        function qn(Ur) {
            let nn = kt[Ur.pointerId];
            nn === void 0 && (nn = new three_module.I9Y,
            kt[Ur.pointerId] = nn),
            nn.set(Ur.pageX, Ur.pageY)
        }
        function mo(Ur) {
            const nn = Ur.pointerId === Bt[0].pointerId ? Bt[1] : Bt[0];
            return kt[nn.pointerId]
        }
        this.zoomIn = function(Ur) {
            lr(1, Ur * h.zoomSpeed)
        }
        ,
        this.zoomOut = function(Ur) {
            ar(1, Ur * h.zoomSpeed)
        }
        ,
        h.domElement.addEventListener("contextmenu", Wn),
        h.domElement.addEventListener("pointerdown", vr),
        h.domElement.addEventListener("pointercancel", rn),
        h.domElement.addEventListener("wheel", hn, {
            passive: !1
        }),
        this.update()
    }
}
var OrbitControls3_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let OrbitControls3 = class extends OrbitControls {
    constructor() {
        super(...arguments),
        this.type = "OrbitControls",
        this.enabled = !0,
        this.dollyZoom = !1,
        this.zoomToCursor = !1,
        this.enableDamping = !0,
        this.dampingFactor = .08,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.enableZoom = !0,
        this.zoomSpeed = .15,
        this.maxZoomSpeed = .2,
        this.enableRotate = !0,
        this.rotateSpeed = 2,
        this.enablePan = !0,
        this.panSpeed = 1,
        this._autoPushTarget = !1,
        this.autoPushTarget2 = !1,
        this.autoPullTarget = !1,
        this.minDistance = .35,
        this.maxDistance = 1e3,
        this.minZoom = .01,
        this.maxZoom = 1e3,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1e6,
        this.maxAzimuthAngle = 1e6,
        this.clampMin = new three_module.Pq0(-1e6,-1e6,-1e6),
        this.clampMax = new three_module.Pq0(1e6,1e6,1e6),
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.throttleUpdate = 60
    }
    get autoPushTarget() {
        return this._autoPushTarget || this.autoPushTarget2
    }
    set autoPushTarget(d) {
        this._autoPushTarget = d
    }
    zoomIn(d) {
        super.zoomIn(d)
    }
    zoomOut(d) {
        super.zoomOut(d)
    }
    dispatchEvent(d) {
        super.dispatchEvent(d)
    }
}
;
OrbitControls3_decorate([serialize()], OrbitControls3.prototype, "type", void 0),
OrbitControls3_decorate([uiToggle()], OrbitControls3.prototype, "enabled", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "dollyZoom", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "zoomToCursor", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "enableDamping", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "dampingFactor", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "autoRotate", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "autoRotateSpeed", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "enableZoom", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "zoomSpeed", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "maxZoomSpeed", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "enableRotate", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "rotateSpeed", void 0),
OrbitControls3_decorate([uiToggle(), serialize()], OrbitControls3.prototype, "enablePan", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "panSpeed", void 0),
OrbitControls3_decorate([uiInput(), serialize("autoPushTarget")], OrbitControls3.prototype, "_autoPushTarget", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "autoPullTarget", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "minDistance", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "maxDistance", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "minZoom", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "maxZoom", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "minPolarAngle", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "maxPolarAngle", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "minAzimuthAngle", void 0),
OrbitControls3_decorate([uiInput(), serialize()], OrbitControls3.prototype, "maxAzimuthAngle", void 0),
OrbitControls3_decorate([uiVector(), serialize()], OrbitControls3.prototype, "clampMin", void 0),
OrbitControls3_decorate([uiVector(), serialize()], OrbitControls3.prototype, "clampMax", void 0),
OrbitControls3_decorate([serialize()], OrbitControls3.prototype, "screenSpacePanning", void 0),
OrbitControls3_decorate([serialize()], OrbitControls3.prototype, "keyPanSpeed", void 0),
OrbitControls3 = OrbitControls3_decorate([uiPanel("Orbit Controls")], OrbitControls3);
var CameraController_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class CameraController extends three_module.Qev {
    get controls() {
        return this._controls
    }
    getControls() {
        return this._controls
    }
    get userData() {
        return this._camera.modelObject.userData
    }
    set userData(o) {
        this._camera.modelObject.userData = o
    }
    get isActiveCamera() {
        return this._isActiveCamera
    }
    get target() {
        return this._target
    }
    set target(o) {
        const c = this._target.sub(o).length() > 0;
        this._target.copy(o),
        c && this.targetUpdated()
    }
    get position() {
        return this._position
    }
    set position(o) {
        const c = this._position.sub(o).length() > 0;
        this._position.copy(o),
        c && this.positionUpdated()
    }
    get name() {
        return this._camera.name
    }
    set name(o) {
        this._camera.name = o
    }
    getCameraOptions() {
        return {
            ...this._options,
            position: this._position.toArray(),
            target: this._target.toArray()
        }
    }
    setCameraOptions(o, c=!0) {
        var h, _;
        const b = {
            ...o
        };
        !((h = b.position) === null || h === void 0) && h.isVector3 && (b.position = [b.position.x, b.position.y, b.position.z]),
        !((_ = b.target) === null || _ === void 0) && _.isVector3 && (b.target = [b.target.x, b.target.y, b.target.z]),
        Object.keys(b).forEach(_e => _e !== "frustumSize" && b[_e] === void 0 && delete b[_e]),
        Object.assign(this._options, b),
        this._refreshCameraOptions(!1),
        this.refreshCameraControls(!1),
        c && this.setDirty({
            optionsUpdate: !0
        })
    }
    _refreshCameraOptions(o=!0) {
        let c = this._camera.modelObject;
        if (this._options.type !== c.type) {
            const _ = this._options.type === "PerspectiveCamera" ? new three_module.ubm : new three_module.qUd;
            _.name = this._camera.name,
            _.near = this._camera.modelObject.near,
            _.far = this._camera.modelObject.far,
            _.zoom = this._camera.modelObject.zoom,
            _.scale.copy(this._camera.modelObject.scale);
            const b = this._isActiveCamera;
            b && this.deactivateMain(),
            this._camera = this._setCameraObject(_),
            c = this._camera.modelObject,
            b && this.activateMain(),
            this._camera.modelObject.updateProjectionMatrix()
        }
        let h = this._options.aspect;
        if (h === "auto" && (h = this._container.clientWidth / this._container.clientHeight,
        isFinite(h) || (h = 1)),
        this._options.position && (this.position.set(...this._options.position),
        delete this._options.position),
        this._options.target && (this.target.set(...this._options.target),
        delete this._options.target),
        this.positionUpdated(!1),
        this._options.type === "PerspectiveCamera" && (c.fov = this._options.fov,
        c.focus = this._options.focus,
        c.aspect = h),
        this._options.type === "OrthographicCamera") {
            const _ = this._options.frustumSize;
            _ !== void 0 ? (c.top = _ / 2,
            c.bottom = -_ / 2,
            c.left = h * _ / 2,
            c.right = -h * _ / 2) : (c.top = this._options.top,
            c.bottom = this._options.bottom,
            c.left = this._options.left,
            c.right = this._options.right)
        }
        c.zoom = this._options.zoom,
        this._nearFarChanged(),
        o && this.setDirty()
    }
    _setCameraObject(o) {
        return this._camera && this._camera.removeEventListener("objectUpdate", this._cameraObjectUpdate),
        this._camera = setupIModel(o),
        this._camera.addEventListener("objectUpdate", this._cameraObjectUpdate),
        this._camera
    }
    get interactionsEnabled() {
        return this._interactionsDisabledBy.size === 0 && this._isActiveCamera && this._options.controlsEnabled && this._options.controlsMode !== ""
    }
    set interactionsEnabled(o) {
        this.setInteractions(o, "_default")
    }
    setInteractions(o, c) {
        const h = this._interactionsDisabledBy.size;
        o ? this._interactionsDisabledBy.delete(c) : this._interactionsDisabledBy.add(c),
        h !== this._interactionsDisabledBy.size && this.refreshCameraControls(!0)
    }
    _nearFarChanged() {
        this._camera && (this._camera.modelObject.near = this.near,
        this._camera.modelObject.far = this.far,
        this._camera.modelObject.updateProjectionMatrix())
    }
    constructor(o, c, h) {
        super(),
        this._controlsMode = "",
        this._isActiveCamera = !1,
        this._cameraObjectUpdate = _e => {
            this.setDirty(_e)
        }
        ,
        this._interactionsDisabledBy = new Set,
        this.autoLookAtTarget = !1,
        this.near = .01,
        this.far = 50,
        this._options = {
            type: "PerspectiveCamera",
            aspect: "auto",
            focus: 10,
            fov: 25,
            zoom: 1,
            frustumSize: 1,
            top: 1,
            bottom: -1,
            left: -1,
            right: 1,
            controlsMode: "orbit",
            controlsEnabled: !0
        },
        this._position = new three_module.Pq0(0,0,10),
        this._target = new three_module.Pq0(0,0,0),
        this._controlsCtors = new Map([["orbit", (_e, nt) => {
            const it = new OrbitControls3(_e,nt.ownerDocument ? nt : nt.documentElement);
            return it.screenSpacePanning = !0,
            it
        }
        ]]),
        this._positionWorld = new three_module.Pq0,
        this._camUi = [{
            type: "vec3",
            label: "Position",
            property: [this, "position"],
            onChange: () => this.positionUpdated(!0)
        }, {
            type: "vec3",
            label: "Target",
            property: [this, "target"],
            onChange: () => this.targetUpdated(!0)
        }, {
            type: "slider",
            bounds: [1, 180],
            label: "Field Of View",
            hidden: () => !this._camera.modelObject.isPerspectiveCamera,
            property: [this._options, "fov"],
            onChange: () => this.refreshCameraOptions(),
            limitedUi: !0
        }, {
            type: "checkbox",
            label: "Auto Near far",
            getValue: () => {
                var _e;
                return (_e = this._camera.userData.autoNearFar) === null || _e === void 0 || _e
            }
            ,
            setValue: _e => this._camera.userData.autoNearFar = _e,
            onChange: () => this.setDirty()
        }, {
            type: "checkbox",
            label: "Dolly FoV",
            getValue: () => {
                var _e;
                return (_e = this._camera.userData.dollyFov) !== null && _e !== void 0 && _e
            }
            ,
            setValue: _e => this._camera.userData.dollyFov = _e,
            onChange: () => this.setDirty()
        }, {
            type: "input",
            label: () => {
                var _e;
                return (_e = this._camera.userData.autoNearFar) === null || _e === void 0 || _e ? "Min Near" : "Near"
            }
            ,
            getValue: () => {
                var _e;
                return (_e = this._camera.userData.minNearPlane) !== null && _e !== void 0 ? _e : .5
            }
            ,
            setValue: _e => this._camera.userData.minNearPlane = _e,
            onChange: () => this.setDirty()
        }, {
            type: "input",
            label: () => {
                var _e;
                return (_e = this._camera.userData.autoNearFar) === null || _e === void 0 || _e ? "Max Far" : "Far"
            }
            ,
            getValue: () => {
                var _e;
                return (_e = this._camera.userData.maxFarPlane) !== null && _e !== void 0 ? _e : 1e3
            }
            ,
            setValue: _e => this._camera.userData.maxFarPlane = _e,
            onChange: () => this.setDirty()
        }, () => ({
            type: "dropdown",
            label: "Controls Mode",
            property: [this._options, "controlsMode"],
            children: ["", "orbit", ...this._controlsCtors.keys()].map(_e => ({
                label: _e === "" ? "none" : _e,
                value: _e
            })),
            onChange: () => {
                this.refreshCameraOptions()
            }
        })],
        this.uiConfig = {
            type: "folder",
            label: "Camera",
            limitedUi: !0,
            children: [...this._camUi, () => {
                var _e;
                return !((_e = this._controls) === null || _e === void 0) && _e.zoomIn ? {
                    type: "button",
                    label: "Zoom in",
                    value: () => {
                        var nt;
                        (nt = this._controls) === null || nt === void 0 || nt.zoomIn(1)
                    }
                } : {}
            }
            , () => {
                var _e;
                return !((_e = this._controls) === null || _e === void 0) && _e.zoomOut ? {
                    type: "button",
                    label: "Zoom out",
                    value: () => {
                        var nt;
                        (nt = this._controls) === null || nt === void 0 || nt.zoomOut(1)
                    }
                } : {}
            }
            , () => {
                var _e;
                return (_e = this._controls) === null || _e === void 0 ? void 0 : _e.uiConfig
            }
            ]
        },
        this.assetType = "model",
        this.uuid = three_module.cj9.generateUUID(),
        this.setDirty = this.setDirty.bind(this),
        this.targetUpdated = this.targetUpdated.bind(this),
        this._refreshCameraOptions = this._refreshCameraOptions.bind(this),
        this._container = h ?? document.body;
        const _ = {
            ...c
        };
        this._camera = this._setCameraObject(o ?? (_.type === "OrthographicCamera" ? new three_module.qUd(-1,1,1,-1) : new three_module.ubm)),
        this._camera.modelObject.userData.iCamera = this;
        const b = o;
        o && (b.isPerspectiveCamera ? (_.fov = b.fov,
        _.focus = b.focus,
        _.aspect = b.aspect <= 0 || b.userData.autoAspect ? "auto" : b.aspect,
        _.zoom = b.zoom) : b.isOrthographicCamera && (_.left = b.left,
        _.right = b.right,
        _.top = b.top,
        _.bottom = b.bottom,
        _.zoom = b.zoom),
        this.near = b.near,
        this.far = b.far,
        this._position.copy(o.position),
        this.refreshTarget()),
        this.positionUpdated(!1),
        this.setCameraOptions(_)
    }
    refreshAspect(o=!0) {
        this._options.aspect === "auto" && this._refreshCameraOptions(o)
    }
    refreshTarget(o=4) {
        var c;
        !((c = this._controls) === null || c === void 0) && c.enabled && this._controls.target ? this._target.copy(this._controls.target) : this.cameraObject.getWorldDirection(this._target).multiplyScalar(o).add(this.cameraObject.getWorldPosition(new three_module.Pq0))
    }
    setControlsCtor(o, c, h=!1) {
        h || !this._controlsCtors.has(o) ? this._controlsCtors.set(o, c) : console.error(o + " already exists.")
    }
    removeControlsCtor(o) {
        this._controlsCtors.delete(o)
    }
    _initCameraControls() {
        var o, c, h;
        const _ = this._options.controlsMode;
        this._controls = (c = (o = this._controlsCtors.get(_)) === null || o === void 0 ? void 0 : o(this._camera.modelObject, this._container)) !== null && c !== void 0 ? c : void 0,
        this._controls || _ === "" || console.error("Unable to create controls with mode " + _ + ". Are you missing a plugin?"),
        (h = this._controls) === null || h === void 0 || h.addEventListener("change", this.setDirty),
        this._controlsMode = this._controls ? _ : ""
    }
    _disposeCameraControls() {
        var o, c;
        this._controlsMode,
        (o = this._controls) === null || o === void 0 || o.removeEventListener("change", this.setDirty),
        (c = this._controls) === null || c === void 0 || c.dispose(),
        this._controlsMode = "",
        this._controls = void 0
    }
    refreshCameraControls(o=!0) {
        var c, h;
        if (this._options.controlsEnabled) {
            const _ = this._options.controlsMode;
            this._controls ? this._controlsMode === _ && this._camera.modelObject === this._controls.object || (this._disposeCameraControls(),
            this._initCameraControls()) : this._initCameraControls(),
            this._controlsMode = _
        }
        if (this._controls) {
            const _ = this.interactionsEnabled;
            this._controls.enabled = _,
            _ && this._camera.modelObject.up.copy(three_module.B69.DEFAULT_UP)
        }
        o && this.setDirty(),
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
    }
    setDirty(o) {
        var c, h;
        this._position.copy(this._camera.modelObject.position),
        this._controls && this._controls.enabled && this._controls.target && this._target.copy(this._controls.target),
        this._camera.modelObject.fov !== void 0 && (this._options.fov = this._camera.modelObject.fov),
        this._camera.modelObject.focus !== void 0 && (this._options.focus = this._camera.modelObject.focus),
        this._camera.modelObject.zoom !== void 0 && (this._options.zoom = this._camera.modelObject.zoom),
        (h = (c = this.cameraObject).updateProjectionMatrix) === null || h === void 0 || h.call(c),
        this.cameraObject.getWorldPosition(this._positionWorld),
        this.dispatchEvent({
            ...o,
            type: "update"
        }),
        (o == null ? void 0 : o.last) !== !1 && this._camUi.forEach(_ => {
            var b;
            return (b = _ == null ? void 0 : _.uiRefresh) === null || b === void 0 ? void 0 : b.call(_, "postFrame", !1, 1)
        }
        )
    }
    activateMain(o=!0) {
        var c, h;
        this._isActiveCamera || (this._isActiveCamera = !0,
        this._camera.modelObject.userData.__lastScale = this._camera.modelObject.scale.clone(),
        this._camera.modelObject.scale.divide(this._camera.modelObject.getWorldScale(new three_module.Pq0)),
        o && (this.refreshCameraControls(!1),
        this._refreshCameraOptions(!0)),
        (h = (c = this._camera).setDirty) === null || h === void 0 || h.call(c, {
            change: "activateMain"
        }))
    }
    deactivateMain(o=!0) {
        this._isActiveCamera && (this._isActiveCamera = !1,
        this._camera.modelObject.userData.__lastScale && (this._camera.modelObject.scale.copy(this._camera.modelObject.userData.__lastScale),
        delete this._camera.modelObject.userData.__lastScale),
        o && this.refreshCameraControls(!0))
    }
    get cameraObject() {
        return this._camera.modelObject
    }
    get modelObject() {
        return this._camera.modelObject
    }
    dispose() {
        this._disposeCameraControls()
    }
    getFittingDistance(o) {
        const c = o.getSize(new three_module.Pq0);
        let h = this.cameraObject
          , _ = 1;
        if (h.isPerspectiveCamera && c.length() > 1e-4) {
            const b = isFinite(h.aspect) ? h.aspect : 1
              , _e = Math.max(1, h.fov) * (Math.PI / 180)
              , nt = 2 * Math.atan(Math.tan(_e / 2) * b)
              , it = c.z / 2 + Math.abs(c.x / 2 / Math.tan(nt / 2))
              , at = c.z / 2 + Math.abs(c.y / 2 / Math.tan(_e / 2));
            _ = Math.max(it, at)
        }
        return _
    }
    targetUpdated(o=!0) {
        var c, h;
        const _ = this.target;
        (h = (c = this._controls) === null || c === void 0 ? void 0 : c.target) === null || h === void 0 || h.set(_.x, _.y, _.z),
        this._controls && this._controls.enabled && this._controls.target ? o && this.setDirty() : this._camera && (this._camera.userData.autoLookAtTarget !== void 0 && (this.autoLookAtTarget = this._camera.userData.autoLookAtTarget),
        this.autoLookAtTarget && this._camera.modelObject.lookAt(_),
        o && this.setDirty())
    }
    positionUpdated(o=!0) {
        const c = this.position;
        this._camera.modelObject.position.set(c.x, c.y, c.z),
        this.targetUpdated(o)
    }
    positionTargetUpdated(o=!0) {
        this.positionUpdated(o)
    }
    copyFromCamera(o, c=4) {
        o.getWorldPosition(this._position),
        o.getWorldDirection(this._target).multiplyScalar(c).add(this._position),
        this.positionUpdated(!1),
        this.setCameraOptions({
            fov: o.fov,
            focus: o.focus,
            zoom: o.zoom,
            type: o.type
        }, !0)
    }
    updateShaderProperties(o) {
        var c, h, _, b;
        return (h = (c = o.uniforms.cameraPositionWorld) === null || c === void 0 ? void 0 : c.value) === null || h === void 0 || h.copy(this._positionWorld),
        (b = (_ = o.uniforms.cameraNearFar) === null || _ === void 0 ? void 0 : _.value) === null || b === void 0 || b.set(this._camera.modelObject.near, this._camera.modelObject.far),
        o.uniforms.projection && (o.uniforms.projection.value = this._camera.modelObject.projectionMatrix),
        o.defines.PERSPECTIVE_CAMERA = this._camera.modelObject.type === "PerspectiveCamera" ? "1" : "0",
        o.defines.ORTHOGRAPHIC_CAMERA = this._camera.modelObject.type === "OrthographicCamera" ? "1" : "0",
        this
    }
    toJSON(o) {
        const c = {};
        return copyObject3DUserData(c, this.userData),
        Object.assign({
            userData: c
        }, serializeObject(this, !0, o))
    }
    fromJSON(o, c) {
        return o.userData && (copyObject3DUserData(this.userData, o.userData),
        delete (o = {
            ...o
        }).userData),
        o.camOptions && (this.setCameraOptions(o.camOptions, !1),
        this.refreshCameraOptions(!1)),
        deserializeObject(o, this, !0, c),
        this.positionUpdated(!1),
        this.refreshCameraOptions(!1),
        this.setDirty({
            change: "deserialize"
        }),
        this
    }
    refreshCameraOptions(o=!0) {
        this.setCameraOptions(this._options, o)
    }
    get visible() {
        return !0
    }
    set visible(o) {
        console.error("Cannot set visible on camera", o)
    }
}
CameraController_decorate([serialize("camControls")], CameraController.prototype, "_controls", void 0),
CameraController_decorate([x$1(CameraController.prototype._nearFarChanged)], CameraController.prototype, "near", void 0),
CameraController_decorate([x$1(CameraController.prototype._nearFarChanged)], CameraController.prototype, "far", void 0),
CameraController_decorate([serialize("camOptions")], CameraController.prototype, "_options", void 0),
CameraController_decorate([serialize("position")], CameraController.prototype, "_position", void 0),
CameraController_decorate([serialize("target")], CameraController.prototype, "_target", void 0);
var RootScene_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class RootScene extends three_module.Z58 {
    get activeCamera() {
        return this._activeCamera >= 0 ? this._cameras[this._activeCamera] : this._dummyCam
    }
    set activeCamera(o) {
        const c = this.activeCamera;
        if (o || (o = this.defaultCamera),
        c !== o) {
            if (c && (c.deactivateMain(),
            c.removeEventListener("update", this._activeCameraUpdate)),
            o) {
                o.activateMain(),
                o.addEventListener("update", this._activeCameraUpdate);
                let h = this._cameras.indexOf(o);
                h < 0 && (this._cameras.push(o),
                h = this._cameras.length - 1),
                this._activeCamera = h
            } else
                this._activeCamera = -1;
            this.dispatchEvent({
                type: "activeCameraChange",
                lastCamera: c,
                camera: o
            }),
            this.setDirty()
        }
    }
    get renderCamera() {
        var o;
        return (o = this._renderCamera) !== null && o !== void 0 ? o : this.activeCamera
    }
    set renderCamera(o) {
        const c = this._renderCamera;
        this._renderCamera = o,
        this.dispatchEvent({
            type: "renderCameraChange",
            lastCamera: c,
            camera: o
        })
    }
    get modelObject() {
        return this
    }
    constructor(o) {
        super(),
        this.isRootScene = !0,
        this.assetType = "model",
        this._sceneBounds = new Box3B,
        this._modelBounds = new Box3B,
        this._sceneBoundingRadius = 0,
        this._cameras = [],
        this._activeCamera = -1,
        this.envMapIntensity = 1,
        this.fixedEnvMapDirection = !1,
        this.backgroundIntensity = 1,
        this._dummyCam = new CameraController(new three_module.ubm,{
            controlsMode: "",
            controlsEnabled: !1
        }),
        this.deleteImportedViewerConfigOnLoad = !0,
        this.autoDisposeSceneMaps = !0,
        this.environment = null,
        this.textureSlots = {},
        this.background = null,
        this.backgroundColor = null,
        this.setDirty = this.setDirty.bind(this),
        this.updateScene = this.updateScene.bind(this),
        this.refreshActiveCameraNearFar = this.refreshActiveCameraNearFar.bind(this),
        this._activeCameraUpdate = this._activeCameraUpdate.bind(this),
        this._optionsUpdate = this._optionsUpdate.bind(this),
        this._onSceneMaterialUpdate = this._onSceneMaterialUpdate.bind(this),
        this._onSceneUpdate = this._onSceneUpdate.bind(this),
        this.addEventListener("materialUpdate", this._onSceneMaterialUpdate),
        this.addEventListener("materialChanged", this._onSceneMaterialUpdate),
        this.addEventListener("objectUpdate", this._onSceneUpdate),
        this.defaultCamera = o,
        this.modelRoot = setupIModel(new three_module.YJl, void 0),
        this.modelRoot.userData.rootSceneModelRoot = !0,
        this.modelRoot.name = "Scene",
        this.modelRoot.addEventListener("update", this.setDirty),
        this.addSceneObject(this.modelRoot, {
            addToRoot: !0,
            autoScale: !1
        }),
        this.addSceneObject(this.defaultCamera, {
            addToRoot: !0
        }),
        this.activeCamera = this.defaultCamera,
        this.boxHelper = new three_module.BND(this.getBounds())
    }
    addModel(o, c={}) {
        return o.assetType !== "model" && console.error("Invalid asset type for ", o, ", adding anyway"),
        this.addSceneObject(o, c)
    }
    addWidget(o, c={}) {
        o.assetType !== "widget" && console.warn("Invalid asset type for ", o, ", adding anyway"),
        this.add(o.modelObject)
    }
    _addModel(o, c={}) {
        return this._addObject3D(o == null ? void 0 : o.modelObject, c)
    }
    addSceneObject(o, c) {
        var h;
        if (!o)
            return o;
        const _ = o.assetType;
        let b = !1;
        switch (_) {
        case "model":
            b = o.modelObject.isCamera,
            b && (c = {
                ...c,
                autoScale: !1
            }),
            this._addModel(o, c);
            break;
        case "material":
            break;
        case "texture":
            this.dispatchEvent({
                type: "textureAdded",
                texture: o
            });
            break;
        case "light":
            this._addLight(o, c);
            break;
        default:
            console.warn("WebGi RootScene: Unknown asset imported", o, _)
        }
        return this.dispatchEvent({
            type: "addSceneObject",
            object: o,
            options: c
        }),
        this.deleteImportedViewerConfigOnLoad && (o.__importedViewerConfig || !((h = o.modelObject) === null || h === void 0) && h.__importedViewerConfig) && X$2(2e3).then( () => {
            delete o.__importedViewerConfig,
            o.modelObject && delete o.modelObject.__importedViewerConfig
        }
        ),
        o
    }
    _addObject3D(o, {autoScale: c=!0, autoScaleRadius: h=2, addToRoot: _=!1}={}) {
        const b = o;
        b ? (c && !b.userData.autoScaled && autoScaleObject3D(b, b.userData.autoScaleRadius || h),
        b.traverse(_e => {
            _e.isMesh && !_e.userData.__keepShadowDef && (_e.castShadow = !0,
            _e.receiveShadow = !0,
            _e.userData.__keepShadowDef = !0)
        }
        ),
        _ ? this.modelObject.add(b) : this.modelRoot.add(b),
        this.setDirty()) : console.error("Invalid Model, cannot add.")
    }
    removeSceneModels() {
        this.modelRoot.clear(),
        this.modelRoot.children = [],
        this.setDirty({
            sceneUpdate: !0
        })
    }
    disposeSceneModels() {
        [...this.modelRoot.children].forEach(o => {
            var c, h;
            ((c = o.dispose) !== null && c !== void 0 ? c : (h = o.modelObject) === null || h === void 0 ? void 0 : h.removeFromParent)()
        }
        ),
        this.setDirty({
            sceneUpdate: !0
        })
    }
    _onEnvironmentChange() {
        var o;
        ((o = this.environment) === null || o === void 0 ? void 0 : o.mapping) === three_module.UTZ && (this.environment.mapping = three_module.wfO,
        this.environment.needsUpdate = !0),
        this.dispatchEvent({
            type: "environmentChanged",
            environment: this.environment
        }),
        this._onSceneUpdate({
            geometryChanged: !1
        })
    }
    _onBackgroundChange() {
        this.dispatchEvent({
            type: "backgroundChanged",
            background: this.background,
            backgroundColor: this.backgroundColor
        }),
        this._onSceneUpdate({
            geometryChanged: !1
        })
    }
    add(...o) {
        return super.add(...o.map(c => setupIModel(c))),
        this._onSceneUpdate(),
        this
    }
    setEnvironment(o) {
        const c = this.environment;
        if (c === o)
            return;
        if (this.autoDisposeSceneMaps && (c == null || c.dispose()),
        !o)
            return void (this.environment = null);
        if (!o.isTexture)
            return void console.error("Unknown Environment type", o);
        o.assetType !== "texture" && console.warn("Environment asset not processed", o);
        const h = o.textureObject || o;
        this.environment = h
    }
    getEnvironment() {
        return this.environment
    }
    setBackground(o) {
        let c;
        const h = this.background;
        if (h !== o) {
            if (this.autoDisposeSceneMaps && h instanceof three_module.gPd && h.dispose(),
            !o || o.assetType === "texture" || o.isTexture || o.isColor || o === "environment")
                c = ((o == null ? void 0 : o.assetType) === "texture" || o.isTexture) && o.textureObject || o;
            else {
                if (typeof o != "string" && typeof o != "number")
                    return void console.error("Unknown Background type", o);
                c = new three_module.Q1f(o)
            }
            this.background = c
        }
    }
    setBackgroundColor(o) {
        this.backgroundColor = o ? new three_module.Q1f(o) : null
    }
    getBackground() {
        return this.background
    }
    setDirty(o) {
        return o != null && o.sceneUpdate || o != null && o.refreshScene ? this._onSceneUpdate(o) : this.dispatchEvent({
            type: "update"
        }),
        this
    }
    updateScene(o) {
        return this._onSceneUpdate(o)
    }
    _activeCameraUpdate(o) {
        o.optionsUpdate && this._optionsUpdate(o),
        this.setDirty(),
        this.refreshActiveCameraNearFar(),
        this.dispatchEvent({
            ...o,
            type: "activeCameraUpdate"
        })
    }
    _optionsUpdate(o) {
        if (!this.activeCamera.userData.dollyFov)
            return;
        const c = new Box3B().expandByObject(this.modelRoot.modelObject, !1, !0)
          , h = this.activeCamera.cameraObject
          , _ = 1.5 * this.activeCamera.getFittingDistance(c)
          , b = this.activeCamera.target
          , _e = new three_module.Pq0().subVectors(b, h.position).normalize();
        this.activeCamera.position = _e.multiplyScalar(-_).add(b)
    }
    _onSceneUpdate(o={}) {
        var c, h, _, b;
        return o.sceneUpdate === !1 && o.refreshScene === !1 || !((c = o.object) === null || c === void 0) && c.isCamera ? this.setDirty(o) : (this.refreshActiveCameraNearFar(),
        this._sceneBounds = this.getBounds(!1, !0),
        (b = (_ = (h = this.boxHelper) === null || h === void 0 ? void 0 : h.box) === null || _ === void 0 ? void 0 : _.copy) === null || b === void 0 || b.call(_, this._sceneBounds),
        this._modelBounds = this.getModelBounds(!1, !0),
        this._sceneBoundingRadius = this._modelBounds.getSize(new three_module.Pq0).length() / 2,
        this.dispatchEvent({
            ...o,
            type: "sceneUpdate",
            hierarchyChanged: ["addedToParent", "removedFromParent"].includes(o.change || "")
        }),
        this)
    }
    _onSceneMaterialUpdate(o) {
        this.dispatchEvent({
            ...o,
            type: "sceneMaterialUpdate"
        })
    }
    dispose() {
        var o;
        this.disposeSceneModels(),
        this.clear(),
        (o = this.environment) === null || o === void 0 || o.dispose()
    }
    findObjectsByName(o, c) {
        const h = [];
        return (c ?? this.modelObject).traverse(_ => {
            _.name === o && h.push(_)
        }
        ),
        h
    }
    addLight(o, c={}) {
        this.addSceneObject(o, c)
    }
    _addLight(o, {addToRoot: c=!1}={}) {
        var h;
        const _ = o.lightObject;
        _ && ((h = _.children) === null || h === void 0 || h.length,
        c ? this.add(_) : this.modelRoot.add(_))
    }
    getBounds(o=!1, c=!0, h=!0, _) {
        return new Box3B().expandByObject(this.modelObject, o, c, b => {
            var _e;
            return !(!h || b.assetType !== "widget") || (_e = _ == null ? void 0 : _(b)) !== null && _e !== void 0 && _e
        }
        )
    }
    getModelBounds(o=!1, c=!0, h=!0, _) {
        return this.modelRoot == null ? new Box3B : new Box3B().expandByObject(this.modelRoot, o, c, b => {
            var _e;
            return !(!h || b.assetType !== "widget") || (_e = _ == null ? void 0 : _(b)) !== null && _e !== void 0 && _e
        }
        )
    }
    refreshActiveCameraNearFar() {
        var o, c, h, _;
        const b = this.activeCamera;
        if (!b)
            return;
        if (b.cameraObject.userData.autoNearFar === !1)
            return b.near = (o = b.cameraObject.userData.minNearPlane) !== null && o !== void 0 ? o : .5,
            void (b.far = (c = b.cameraObject.userData.maxFarPlane) !== null && c !== void 0 ? c : 1e3);
        const _e = this.getBounds(!1)
          , nt = b.cameraObject.getWorldPosition(new three_module.Pq0).sub(_e.getCenter(new three_module.Pq0))
          , it = 1.5 * _e.getSize(new three_module.Pq0).length() / 2
          , at = Math.max(.1, -nt.clone().normalize().dot(b.cameraObject.getWorldDirection(new three_module.Pq0)))
          , ut = nt.length()
          , pt = Math.max(Math.max((h = b.cameraObject.userData.minNearPlane) !== null && h !== void 0 ? h : .5, .001), at * (ut - it))
          , ht = Math.min(Math.max(pt + it, at * (ut + it)), (_ = b.cameraObject.userData.maxFarPlane) !== null && _ !== void 0 ? _ : 1e3);
        b.near = pt,
        b.far = ht
    }
    updateShaderProperties(o) {
        return o.uniforms.sceneBoundingRadius ? o.uniforms.sceneBoundingRadius.value = this._sceneBoundingRadius : console.warn("BaseRenderer: no uniform: frameCount"),
        this
    }
    toJSON(o) {
        return serializeObject(this, !0, o)
    }
    fromJSON(o, c) {
        const h = o.environment;
        return h !== void 0 && (this.setEnvironment(deserializeObject(h, this.getEnvironment(), !1, c)),
        delete o.environment),
        deserializeObject(o, this, !0, c),
        o.environment = h,
        this
    }
    get minNearDistance() {
        var o;
        return console.error("minNearDistance is deprecated. Use camera.userData.minNearPlane instead"),
        (o = this.activeCamera.userData.minNearPlane) !== null && o !== void 0 ? o : .5
    }
    set minNearDistance(o) {
        console.error("minNearDistance is deprecated. Use camera.userData.minNearPlane instead"),
        this.activeCamera && (this.activeCamera.userData.minNearPlane = o)
    }
}
RootScene_decorate([serialize()], RootScene.prototype, "defaultCamera", void 0),
RootScene_decorate([ze$1(RootScene.prototype.setDirty), serialize()], RootScene.prototype, "envMapIntensity", void 0),
RootScene_decorate([ze$1(RootScene.prototype.setDirty), serialize()], RootScene.prototype, "fixedEnvMapDirection", void 0),
RootScene_decorate([ze$1(RootScene.prototype.setDirty), serialize()], RootScene.prototype, "backgroundIntensity", void 0),
RootScene_decorate([serialize(), x$1(RootScene.prototype._onEnvironmentChange.name)], RootScene.prototype, "environment", void 0),
RootScene_decorate([serialize()], RootScene.prototype, "textureSlots", void 0),
RootScene_decorate([serialize(), x$1(RootScene.prototype._onBackgroundChange)], RootScene.prototype, "background", void 0),
RootScene_decorate([serialize(), x$1(RootScene.prototype._onBackgroundChange)], RootScene.prototype, "backgroundColor", void 0);
function shaderReplaceString(d, o, c, {replaceAll: h=!1, prepend: _=!1, append: b=!1}={}) {
    if (!d.includes(o))
        return console.error(`${o} not found in shader`),
        d;
    let _e = c;
    return _ ? _e = c + o : b && (_e = o + c),
    h ? d.replaceAll(o, _e) : d.replace(o, _e)
}
class MaterialExtender {
    static ApplyMaterialExtensions(o, c, h, _) {
        for (const b of h)
            this.ApplyMaterialExtension(o, c, b, _)
    }
    static ApplyMaterialExtension(o, c, h, _) {
        var b, _e;
        let nt = (b = Ee$1(h.parsFragmentSnippet, _, o)) !== null && b !== void 0 ? b : "";
        nt.length && (c.fragmentShader = shaderReplaceString(c.fragmentShader, this.VoidMain, `
` + nt + `
`, {
            prepend: !0
        })),
        nt = (_e = Ee$1(h.parsVertexSnippet, _, o)) !== null && _e !== void 0 ? _e : "",
        nt.length && (c.vertexShader = shaderReplaceString(c.vertexShader, this.VoidMain, `
` + nt + `
`, {
            prepend: !0
        })),
        h.extraUniforms && (c.uniforms = Object.assign(c.uniforms, h.extraUniforms)),
        h.extraDefines && updateMaterialDefines(h.extraDefines, o),
        h.shaderExtender && h.shaderExtender(c, o, _),
        o.lastShader = c
    }
    static CacheKeyForExtensions(o, c) {
        let h = "";
        for (const _ of c)
            h += this.CacheKeyForExtension(o, _);
        return h
    }
    static CacheKeyForExtension(o, c) {
        let h = "";
        return c.customCacheKey && (h += c.customCacheKey),
        c.computeCacheKey && (h += c.computeCacheKey(o)),
        c.extraDefines && Object.values(c.extraDefines).forEach(_ => h += _),
        h
    }
    static RegisterExtensions(o, c) {
        const h = [];
        if (c)
            for (const _ of c)
                _.isCompatible && _.isCompatible(o) && (h.push(_),
                _.uuid || (_.uuid = esm_browser_v4()),
                _.__setDirty || (_.__setDirty = () => {
                    _.updateVersion || (_.updateVersion = 0),
                    _.updateVersion++
                }
                ),
                _.setDirty || (_.setDirty = _.__setDirty));
        o.materialExtensions = h,
        o.__ext_beforeRenderListen || (o.__ext_beforeRenderListen = !0,
        o.addEventListener("beforeRender", _ => materialBeforeRender(o, _))),
        o.__ext_afterRenderListen || (o.__ext_afterRenderListen = !0,
        o.addEventListener("afterRender", _ => materialAfterRender(o, _))),
        o.__ext_addToMeshListen || (o.__ext_addToMeshListen = !0,
        o.addEventListener("addToMesh", _ => {
            var b, _e;
            if (o.materialExtensions)
                for (const nt of o.materialExtensions)
                    (b = nt.onAddToMesh) === null || b === void 0 || b.call(nt, (_e = _.mesh) !== null && _e !== void 0 ? _e : _.object, o)
        }
        )),
        o.__ext_removeFromMeshListen || (o.__ext_removeFromMeshListen = !0,
        o.addEventListener("removeFromMesh", _ => {
            var b, _e;
            if (o.materialExtensions)
                for (const nt of o.materialExtensions)
                    (b = nt.onRemoveFromMesh) === null || b === void 0 || b.call(nt, (_e = _.mesh) !== null && _e !== void 0 ? _e : _.object, o)
        }
        )),
        o.__ext_materialUpdateListen || (o.__ext_materialUpdateListen = !0,
        o.addEventListener("materialUpdate", _ => {
            var b;
            if (o.materialExtensions)
                for (const _e of o.materialExtensions)
                    (b = _e.onMaterialUpdate) === null || b === void 0 || b.call(_e, o)
        }
        ));
        for (const _ of h)
            _.onRegister && _.onRegister(o);
        return h
    }
}
function updateMaterialDefines(d, o) {
    let c = !1;
    o.materialObject && o.materialObject.defines === void 0 && (o.materialObject.defines = {});
    const h = Object.entries(d);
    for (const [_,b] of h)
        b === void 0 ? o.materialObject.defines[_] !== void 0 && (delete o.materialObject.defines[_],
        c = !0) : o.materialObject.defines[_] !== b && (o.materialObject.defines[_] = b,
        c = !0);
    c && (o.materialObject.needsUpdate = !0)
}
function materialBeforeRender(d, {object: o, renderer: c}) {
    var h;
    if (d.materialExtensions)
        for (const _ of d.materialExtensions) {
            if ((h = _.onObjectRender) === null || h === void 0 || h.call(_, o, d, c),
            d.lastShader) {
                const b = Ee$1(_.updaters) || [];
                for (const _e of b)
                    _e && _e.updateShaderProperties(d.lastShader)
            }
            _.updateVersion !== d.materialObject.userData["_" + _.uuid + "_version"] && (d.materialObject.userData["_" + _.uuid + "_version"] = _.updateVersion,
            d.materialObject.needsUpdate = !0)
        }
}
function materialAfterRender(d, {object: o, renderer: c}) {
    var h;
    if (d.materialExtensions)
        for (const _ of d.materialExtensions)
            (h = _.onAfterRender) === null || h === void 0 || h.call(_, o, d, c)
}
MaterialExtender.VoidMain = "void main()";
var ShaderPass2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class AShaderMaterial2 extends three_module.BKk {
    constructor(o, c=!1) {
        var h;
        super(o),
        this.typeSlug = "shaderMat",
        this.assetType = "material",
        this.materialObject = this,
        this.materialExtensions = [],
        this.isRawShaderMaterial = !1,
        this.extraUniformsToUpload = {},
        c && (this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"),
        this.materialExtensions = MaterialExtender.RegisterExtensions(this, (h = o == null ? void 0 : o.customMaterialExtensions) !== null && h !== void 0 ? h : [])
    }
    registerMaterialExtensions(o) {
        this.materialExtensions = [...this.materialExtensions, ...MaterialExtender.RegisterExtensions(this, o)]
    }
    unregisterMaterialExtensions(o) {}
    onBeforeCompile(o, c) {
        MaterialExtender.ApplyMaterialExtensions(this, o, this.materialExtensions, c),
        this.dispatchEvent({
            type: "beforeCompile",
            shader: o,
            renderer: c
        }),
        o.fragmentShader = o.fragmentShader.replaceAll("#glMarker", "// "),
        super.onBeforeCompile(o, c)
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + MaterialExtender.CacheKeyForExtensions(this, this.materialExtensions)
    }
    onBeforeRender(o, c, h, _, b) {
        super.onBeforeRender(o, c, h, _, b),
        this.dispatchEvent({
            type: "beforeRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    onAfterRender(o, c, h, _, b) {
        super.onAfterRender(o, c, h, _, b),
        this.dispatchEvent({
            type: "afterRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    setDirty(o) {
        this.needsUpdate = !0,
        this.dispatchEvent({
            ...o,
            type: "materialUpdate"
        })
    }
}
class ShaderMaterial2 extends AShaderMaterial2 {
    constructor() {
        super(...arguments),
        this.typeSlug = "shaderMat"
    }
    toJSON(o) {
        throw new Error("Method not supported for this material.")
    }
    fromJSON(o, c) {
        throw new Error("Method not supported for this material.")
    }
    copyProps(o) {
        throw new Error("Method not supported for this material.")
    }
}
class ShaderMaterialEncodingSupport extends ShaderMaterial2 {
    constructor(o, c) {
        super(o),
        this.typeSlug = "shaderMat",
        this.textures = [],
        this.setTextureIds(c)
    }
    setTextureIds(o) {
        this.textures.map(c => c.id).join(";") !== o.join(";") && (this.textures = o.map(c => ({
            id: c,
            colorSpace: three_module.jf0
        })),
        this.setDirty())
    }
    _setUniformTexSize(o, c) {
        var h, _, b, _e;
        if (!c || !o)
            return;
        const nt = (_ = (h = c.image) === null || h === void 0 ? void 0 : h.width) !== null && _ !== void 0 ? _ : 512
          , it = (_e = (b = c.image) === null || b === void 0 ? void 0 : b.height) !== null && _e !== void 0 ? _e : 512
          , at = o.value;
        at.isVector2 || console.warn("uniform is not a Vector2"),
        at && Math.abs(at.x - nt) + Math.abs(at.y - it) > .1 && (at.x = nt,
        at.y = it,
        this.uniformsNeedUpdate = !0)
    }
    onBeforeRender(o, c, h, _, b) {
        var _e, nt;
        this._setUniformTexSize(this.uniforms.screenSize, (_e = o.getRenderTarget()) === null || _e === void 0 ? void 0 : _e.texture);
        for (const it of this.textures) {
            const at = it.id
              , ut = (nt = this.uniforms[at]) === null || nt === void 0 ? void 0 : nt.value;
            ut && (this._setUniformTexSize(this.uniforms[at + "Size"], ut),
            ut.colorSpace !== it.colorSpace && (it.colorSpace = ut.colorSpace,
            this.needsUpdate = !0))
        }
        super.onBeforeRender(o, c, h, _, b)
    }
    onBeforeCompile(o, c) {
        o.fragmentShader = this.textures.map(h => {
            var _, b;
            return `uniform sampler2D ${h.id}; 
` + getTexelDecoding((_ = h.id) !== null && _ !== void 0 ? _ : "input", (b = h.colorSpace) !== null && b !== void 0 ? b : three_module.jf0)
        }
        ).join(`
`) + o.fragmentShader,
        super.onBeforeCompile(o, c)
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + this.textures.map(o => o.id + o.colorSpace).join(";")
    }
}
function patchShaderEncodingSupport(d, ...o) {
    const c = d.fragmentShader;
    return new ShaderMaterialEncodingSupport({
        defines: Object.assign({}, d.defines),
        uniforms: d.uniforms,
        vertexShader: d.vertexShader,
        fragmentShader: c
    },o)
}
class ShaderPass2 extends ShaderPass {
    constructor(o, ...c) {
        super(o.isMaterial ? o : patchShaderEncodingSupport(o, ...c), c.length < 1 ? ShaderPass2.DEFAULT_TEX_ID : c[0]),
        this.onDirty = [],
        this.isShaderPass2 = !0,
        this.enabled = !0,
        this.setDirty = this.setDirty.bind(this)
    }
    dispose() {
        var o, c, h, _;
        (c = (o = this.material) === null || o === void 0 ? void 0 : o.dispose) === null || c === void 0 || c.call(o),
        (_ = (h = this.fsQuad) === null || h === void 0 ? void 0 : h.dispose) === null || _ === void 0 || _.call(h),
        this.onDirty = []
    }
    setDirty() {
        this.onDirty.forEach(o => o())
    }
    updateShaderProperties(o) {
        o && (Array.isArray(o) || (o = [o]),
        o.forEach(c => c == null ? void 0 : c.updateShaderProperties(this.material)))
    }
    render(o, c, h, _, b) {
        this.enabled && super.render(o, c || null, h, _, b)
    }
}
ShaderPass2.DEFAULT_TEX_ID = "tDiffuse",
ShaderPass2_decorate([uiToggle("Enabled"), serialize()], ShaderPass2.prototype, "enabled", void 0);
class RenderPass extends Pass {
    constructor(o, c, h=null, _=null, b=null) {
        super(),
        this.scene = o,
        this.camera = c,
        this.overrideMaterial = h,
        this.clearColor = _,
        this.clearAlpha = b,
        this.clear = !0,
        this.clearDepth = !1,
        this.needsSwap = !1,
        this._oldClearColor = new three_module.Q1f
    }
    render(o, c, h, _, b, _e) {
        if (!this.scene || !this.camera)
            return;
        const nt = o.autoClear;
        let it, at;
        if (o.autoClear = !1,
        this.overrideMaterial !== null && (at = this.scene.overrideMaterial,
        this.scene.overrideMaterial = this.overrideMaterial),
        this.clearColor !== null && (o.getClearColor(this._oldClearColor),
        o.setClearColor(this.clearColor)),
        this.clearAlpha !== null && (it = o.getClearAlpha(),
        o.setClearAlpha(this.clearAlpha)),
        this.clearDepth == 1 && o.clearDepth(),
        o.setRenderTarget(this.renderToScreen ? null : h),
        _e) {
            const ut = o.getContext();
            ut.framebufferRenderbuffer(ut.FRAMEBUFFER, ut.DEPTH_ATTACHMENT, ut.RENDERBUFFER, _e)
        }
        if (this.clear === !0 && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil),
        o.render(this.scene, this.camera),
        _e) {
            const ut = o.getContext();
            ut.framebufferRenderbuffer(ut.FRAMEBUFFER, ut.DEPTH_ATTACHMENT, ut.RENDERBUFFER, null)
        }
        this.clearColor !== null && o.setClearColor(this._oldClearColor),
        this.clearAlpha !== null && o.setClearAlpha(it),
        this.overrideMaterial !== null && (this.scene.overrideMaterial = at),
        o.autoClear = nt
    }
}
class GenericBlendTexturePass extends ShaderPass2 {
    constructor(o, c="c = a + b;", h="", _, b=120) {
        super({
            vertexShader: CopyShader.vertexShader,
            fragmentShader: fe$1`
                varying vec2 vUv;
                
                ${h}
                
                void blend(in vec4 a, in vec4 b, inout vec4 c){
                
                ${c}
                
                }
                void main() {
                    vec4 texel = vec4(0);
                    blend(tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ), tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), texel);
                    texel = clamp(texel, vec4(0), vec4(MAX_INTENSITY));
                    gl_FragColor = texel;
                    #include <colorspace_fragment>
                }
            `,
            uniforms: {
                tDiffuse: {
                    value: null
                },
                tDiffuse2: {
                    value: _
                },
                ...o
            },
            defines: {
                MAX_INTENSITY: b
            }
        }, "tDiffuse", "tDiffuse2"),
        this.clear = !1,
        this.needsSwap = !0
    }
}
var depthNormalVert = `#define DEPTH_NORMAL 
#if IS_GLSL3 > 0
out vec3 vViewPosition;
#else
varying vec3 vViewPosition;
#endif
#ifdef USE_ALPHAMAP
#define USE_UV 
#endif
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main(){
#include <uv_vertex>
#include <beginnormal_vertex>
#include <morphnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;}`
  , depthNormalFrag = `#define DEPTH_NORMAL 
#if IS_GLSL3 > 0
in vec3 vViewPosition;
#else
varying vec3 vViewPosition;
#endif
#ifdef USE_ALPHAMAP
#define USE_UV 
#include <packing>
#endif
#if IS_GLSL3 > 0
#ifndef gl_FragColor 
layout(location=0)out vec4 A;layout(location=1)out vec4 B;
#endif
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
uniform vec2 cameraNearFar;uniform vec4 flags;vec2 pack16(float value){float f=clamp(value,0.,1.)*255.;float digitLow=fract(f);float digitHigh=floor(f)/255.;return vec2(digitHigh,digitLow);}vec2 packNormal(vec3 n){float p=sqrt(n.z*8.+8.);return vec2(n.xy/p+0.5);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float getSSCurvature(in vec3 normal){vec3 n=normalize(normal);vec3 dx=dFdx(n);vec3 dy=dFdy(n);vec3 xneg=n-dx;vec3 xpos=n+dx;vec3 yneg=n-dy;vec3 ypos=n+dy;float curvature=(cross(xneg,xpos).y-cross(yneg,ypos).x);return curvature;}void main(){
#glMarker mainStart
#include <clipping_planes_fragment>
vec4 diffuseColor=vec4(1.);
#include <map_fragment>
#ifdef USE_ALPHAMAP
float alphaMapValue=
#ifdef ALPHA_I_RGBA_PACKING
1.-unpackRGBAToDepth(texture2D(alphaMap,vAlphaMapUv));
#else
texture2D(alphaMap,vAlphaMapUv).g;
#endif
#if defined(INVERSE_ALPHAMAP) && INVERSE_ALPHAMAP >= 1
diffuseColor.a*=1.-alphaMapValue;
#else
diffuseColor.a*=alphaMapValue;
#endif
#endif
#include <alphatest_fragment>
#include <logdepthbuf_fragment>
#include <normal_fragment_begin>
#include <normal_fragment_maps>
#ifdef FORCED_LINEAR_DEPTH
float linearZ=float(FORCED_LINEAR_DEPTH);
#else
float linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);
#endif
vec2 packedZ=pack16(pow(max(0.,linearZ),0.5));vec2 packedNormal=packNormal(normal);
#if IS_GLSL3 > 0
#ifndef gl_FragColor 
A=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);B=flags;B.x=getSSCurvature(normal)*0.5+0.5;
#else
gl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);
#endif
#else
gl_FragColor=vec4(packedZ.x,packedZ.y,packedNormal.x,packedNormal.y);
#endif
}`;
class DepthNormalMaterial extends ShaderMaterial2 {
    constructor(o=!0) {
        super({
            vertexShader: depthNormalVert,
            fragmentShader: depthNormalFrag,
            uniforms: three_module.LlO.merge([three_module.fCn.common, three_module.fCn.bumpmap, three_module.fCn.normalmap, three_module.fCn.displacementmap, {
                cameraNearFar: {
                    value: new three_module.I9Y(.1,1e3)
                },
                flags: {
                    value: new three_module.IUQ(255,255,255,255)
                }
            }]),
            defines: {
                IS_GLSL3: o ? "1" : "0"
            },
            glslVersion: o ? three_module.Wdf : three_module.Wyr
        }),
        this.normalMapType = three_module.bI3,
        this.flatShading = !1,
        this._updaters = []
    }
    onBeforeRender(o, c, h, _, b) {
        var _e, nt, it, at, ut, pt, ht, _t, vt, bt, St, At, Et;
        super.onBeforeRender(o, c, h, _, b);
        let Pt = b.material;
        Array.isArray(Pt) && (Pt = Pt[0]),
        this.uniforms.map.value = (_e = Pt == null ? void 0 : Pt.map) !== null && _e !== void 0 ? _e : null,
        this.uniforms.map.value && o.materials.refreshTransformUniform(this.uniforms.map.value, this.uniforms.mapTransform),
        this.uniforms.alphaMap.value = (nt = Pt == null ? void 0 : Pt.alphaMap) !== null && nt !== void 0 ? nt : null,
        this.uniforms.alphaMap.value && o.materials.refreshTransformUniform(this.uniforms.alphaMap.value, this.uniforms.alphaMapTransform),
        this.alphaTest = !Pt || !Pt.alphaTest || Pt.alphaTest < 1e-7 ? .001 : Pt.alphaTest,
        this.uniforms.alphaTest.value = this.alphaTest,
        this.uniforms.displacementMap.value = (it = Pt == null ? void 0 : Pt.displacementMap) !== null && it !== void 0 ? it : null,
        this.uniforms.displacementMap.value && o.materials.refreshTransformUniform(this.uniforms.displacementMap.value, this.uniforms.displacementMapTransform),
        this.uniforms.displacementScale.value = (at = Pt == null ? void 0 : Pt.displacementScale) !== null && at !== void 0 ? at : 1,
        this.uniforms.displacementBias.value = (ut = Pt == null ? void 0 : Pt.displacementBias) !== null && ut !== void 0 ? ut : 0,
        this.uniforms.bumpMap.value = (pt = Pt == null ? void 0 : Pt.bumpMap) !== null && pt !== void 0 ? pt : null,
        this.uniforms.bumpMap.value && o.materials.refreshTransformUniform(this.uniforms.bumpMap.value, this.uniforms.bumpMapTransform),
        this.uniforms.bumpScale.value = (ht = Pt == null ? void 0 : Pt.bumpScale) !== null && ht !== void 0 ? ht : 1,
        this.uniforms.normalMap.value = (_t = Pt == null ? void 0 : Pt.normalMap) !== null && _t !== void 0 ? _t : null,
        this.uniforms.normalMap.value && o.materials.refreshTransformUniform(this.uniforms.normalMap.value, this.uniforms.normalMapTransform),
        this.uniforms.normalScale.value && this.uniforms.normalScale.value.copy((vt = Pt == null ? void 0 : Pt.normalScale) !== null && vt !== void 0 ? vt : new three_module.I9Y(1,1)),
        this.normalMapType = (bt = Pt == null ? void 0 : Pt.normalMapType) !== null && bt !== void 0 ? bt : three_module.bI3,
        this.flatShading = (St = Pt == null ? void 0 : Pt.flatShading) !== null && St !== void 0 && St,
        this.uniforms.flags.value.set(255, 255, 255, 255),
        this.uniforms.flags.value.z = (Pt != null && Pt.userData.matId ? Pt == null ? void 0 : Pt.userData.matId : 0) / 255,
        this._updaters.forEach(Dt => {
            Dt(b, this.uniforms.flags.value)
        }
        ),
        this.uniforms.flags.value.y /= 255,
        this.uniforms.flags.value.w /= 255,
        this.uniformsNeedUpdate = !0;
        let It = this.uniforms.alphaMap.value ? 1 : void 0;
        It !== this.defines.USE_ALPHAMAP && (It === void 0 ? (delete this.defines.USE_ALPHAMAP,
        delete this.defines.ALPHAMAP_UV) : (this.defines.USE_ALPHAMAP = It,
        this.defines.ALPHAMAP_UV = "uv"),
        this.needsUpdate = !0),
        It = this.uniforms.map.value ? 1 : void 0,
        It !== this.defines.USE_MAP && (It === void 0 ? (delete this.defines.USE_MAP,
        delete this.defines.MAP_UV) : (this.defines.USE_MAP = It,
        this.defines.MAP_UV = "uv"),
        this.needsUpdate = !0),
        It = this.uniforms.bumpMap.value ? 1 : void 0,
        It !== this.defines.USE_BUMPMAP && (It === void 0 ? (delete this.defines.USE_BUMPMAP,
        delete this.defines.BUMPMAP_UV) : (this.defines.USE_BUMPMAP = It,
        this.defines.BUMPMAP_UV = "uv"),
        this.needsUpdate = !0),
        It = this.uniforms.normalMap.value ? 1 : void 0,
        It !== this.defines.USE_NORMALMAP && (It === void 0 ? (delete this.defines.USE_NORMALMAP,
        delete this.defines.NORMALMAP_UV) : (this.defines.USE_NORMALMAP = It,
        this.defines.NORMALMAP_UV = "uv"),
        this.needsUpdate = !0),
        It = this.uniforms.displacementMap.value ? 1 : void 0,
        It !== this.defines.USE_DISPLACEMENTMAP && (It === void 0 ? (delete this.defines.USE_DISPLACEMENTMAP,
        delete this.defines.DISPLACEMENTMAP_UV) : (this.defines.USE_DISPLACEMENTMAP = It,
        this.defines.DISPLACEMENTMAP_UV = "uv"),
        this.needsUpdate = !0),
        It = Pt.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0,
        It !== this.defines.ALPHA_I_RGBA_PACKING && (It === void 0 ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = It,
        this.needsUpdate = !0),
        It = (At = Pt.userData.forcedLinearDepth) !== null && At !== void 0 ? At : void 0,
        It !== this.defines.FORCED_LINEAR_DEPTH && (It === void 0 ? delete this.defines.FORCED_LINEAR_DEPTH : this.defines.FORCED_LINEAR_DEPTH = It,
        this.needsUpdate = !0),
        this.side = (Et = Pt.side) !== null && Et !== void 0 ? Et : three_module.$EB
    }
    addGBufferUpdater(o) {
        this._updaters.push(o)
    }
    removeGBufferUpdater(o) {
        const c = this._updaters.indexOf(o);
        c !== -1 && this._updaters.splice(c, 1)
    }
}
var unpackGbuffer = `#ifndef UNPACK_GBUFFER_SNIPPET
#define UNPACK_GBUFFER_SNIPPET 
uniform sampler2D tNormalDepth;float unpack16(vec2 value){return value.x+value.y/255.;}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}float unpackDepth(vec2 uncodedDepth){float x=unpack16(uncodedDepth.xy);return x*x;}float getDepth(vec2 uv){vec4 uncodedDepth=texture2D(tNormalDepth,uv);return unpackDepth(uncodedDepth.xy);}void getDepthNormal(const in vec2 uv,out float depth,out vec3 normal){vec4 uncodedDepth=texture2D(tNormalDepth,uv);depth=unpackDepth(uncodedDepth.xy);normal=unpackNormal(uncodedDepth.zw);}vec3 getViewNormal(const in vec2 uv){return unpackNormal(texture2D(tNormalDepth,uv).zw);}
#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1
uniform sampler2D tGBufferFlags;
#endif
ivec4 getGBufferFlags(const in vec2 uv){
#if defined(GBUFFER_HAS_FLAGS) && GBUFFER_HAS_FLAGS == 1
return ivec4(texture2D(tGBufferFlags,uv)*255.);
#else
return ivec4(1);
#endif
}
#endif
`;
class AViewerPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this._dirty = !1
    }
    get dirty() {
        return this.enabled && this._dirty
    }
    set dirty(o) {
        this._dirty = o
    }
    get viewer() {
        return this._viewer
    }
    async onAdded(o) {
        this._viewer = o
    }
    async onDispose(o) {}
    async onRemove(o) {
        this._viewer !== o && console.error("Wrong viewer"),
        this._viewer = void 0
    }
    toJSON(o) {
        const c = serializeObject(this, !0, o);
        return c.type = this.constructor.PluginType,
        this.dispatchEvent({
            type: "serialize",
            data: c
        }),
        c
    }
    fromJSON(o, c) {
        return o.type !== this.constructor.PluginType ? null : (deserializeObject(o, this, !0, c),
        this.dispatchEvent({
            type: "deserialize",
            data: o,
            meta: c
        }),
        this)
    }
    _storeKey(o) {
        return (o ?? "webgi") + "_" + (this.constructor.PluginType || this.constructor.name)
    }
    exportState() {
        var o, c, h, _;
        return (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("AssetManager")) === null || c === void 0 ? void 0 : c.exportPluginPreset(this)) !== null && h !== void 0 ? h : (_ = this.toJSON) === null || _ === void 0 ? void 0 : _.call(this)
    }
    async importState(o) {
        var c, h;
        const _ = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("AssetManager");
        _ ? await _.importPluginPreset(o, this) : (h = this.fromJSON) === null || h === void 0 || h.call(this, o)
    }
    storeState(o, c, h) {
        (c = c || (window ? window.localStorage : void 0)) ? (h === void 0 && (h = this.exportState()),
        h && c.setItem(this._storeKey(o), JSON.stringify(h))) : console.warn("Unable to store state")
    }
    async loadState(o, c) {
        if (!(c = c || (window ? window.localStorage : void 0)))
            return void console.warn("Unable to load state");
        const h = c.getItem(this._storeKey(o));
        h && await this.importState(JSON.parse(h))
    }
}
function makeFilter(d, o, c) {
    return {
        ...o,
        get dirty() {
            return o.dirty || !1
        },
        set dirty(h) {
            S$2(o, "dirty", h, !0)
        },
        update() {
            var h, _, b;
            this.passObject.enabled && ((_ = (h = this.passObject).updateShaderProperties) === null || _ === void 0 || _.call(h, Ee$1(c)),
            (b = o.update) === null || b === void 0 || b.call(this))
        },
        onRegister(h) {
            var _, b, _e;
            this.passObject.materialExtension && ((b = (_ = d.getPluginByType("AssetManager")) === null || _ === void 0 ? void 0 : _.materials) === null || b === void 0 || b.registerMaterialExtension(this.passObject.materialExtension)),
            (_e = o.onRegister) === null || _e === void 0 || _e.call(this, h)
        },
        onUnregister(h) {
            var _, b, _e;
            this.passObject.materialExtension && ((b = (_ = d.getPluginByType("AssetManager")) === null || _ === void 0 ? void 0 : _.materials) === null || b === void 0 || b.unregisterMaterialExtension(this.passObject.materialExtension)),
            (_e = o.onUnregister) === null || _e === void 0 || _e.call(this, h)
        },
        dispose() {
            var h, _, b;
            (_ = (h = this.passObject).dispose) === null || _ === void 0 || _.call(h),
            (b = o.dispose) === null || b === void 0 || b.call(this)
        }
    }
}
var GenericFilterPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class GenericFilterPlugin extends AViewerPlugin {
    _update(o) {
        var c;
        return ((c = this._pass) === null || c === void 0 ? void 0 : c.enabled) && this.enabled || !1
    }
    get enabled() {
        var o, c, h;
        return (h = (c = (o = this._pass) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.enabled) !== null && h !== void 0 ? h : this._enabledTemp
    }
    set enabled(o) {
        var c;
        !((c = this._pass) === null || c === void 0) && c.passObject && (this._pass.passObject.enabled = o),
        this._enabledTemp = o
    }
    constructor() {
        super(),
        this._enabledTemp = !0
    }
    async onAdded(o) {
        await super.onAdded(o);
        const c = {
            enabled: !0,
            passId: this.passId,
            passObject: this.passCtor(o),
            after: this._afterFilters,
            before: this._beforeFilters,
            required: this._requiredFilters,
            set dirty(h) {
                h && o.setDirty()
            },
            get dirty() {
                return !1
            },
            update: () => this._update(o)
        };
        this._pass = makeFilter(o, c),
        c.passObject.onDirty !== void 0 && c.passObject.onDirty.push( () => c.dirty = !0),
        o.renderer.registerPass(this._pass),
        this.enabled = this._enabledTemp
    }
    async onRemove(o) {
        var c, h;
        this._pass && o.renderer.unregisterPass(this._pass),
        (h = (c = this._pass) === null || c === void 0 ? void 0 : c.dispose) === null || h === void 0 || h.call(c),
        this._pass = void 0,
        await super.onRemove(o)
    }
    get pass() {
        return this._pass
    }
    toJSON(o) {
        var c;
        const h = super.toJSON(o);
        if (!h.type)
            return h;
        const _ = this.pass;
        return _ && (h.pass = serializeObject((c = _ == null ? void 0 : _.passObject) !== null && c !== void 0 ? c : _, !1, o)),
        h
    }
    fromJSON(o, c) {
        var h;
        if (!super.fromJSON(o, c))
            return null;
        if (o.pass) {
            const _ = this.pass;
            _ && deserializeObject(o.pass, (h = _ == null ? void 0 : _.passObject) !== null && h !== void 0 ? h : _, !1, c)
        }
        return this
    }
}
GenericFilterPlugin_decorate([serialize()], GenericFilterPlugin.prototype, "enabled", null);
class GBufferRenderPass extends RenderPass {
    constructor(o, c, h=new three_module.Q1f(1,1,1), _=1) {
        super(void 0, void 0, c, h, _),
        this.target = o,
        this._transparentMats = new Set,
        this._transmissiveMats = new Set
    }
    render(o, c, h, _, b) {
        var _e;
        const nt = o.getRenderTarget()
          , it = o.getActiveCubeFace()
          , at = o.getActiveMipmapLevel();
        (_e = this.scene) === null || _e === void 0 || _e.traverse( ({material: ut}) => {
            ut && ((ut.transparent && ut.userData.renderToDepth || !ut.transparent && ut.transmission === 0 && ut.userData.renderToDepth === !1) && (this._transparentMats.add(ut),
            ut.transparent = !ut.transparent),
            Math.abs(ut.transmission || 0) > 0 && ut.userData.renderToDepth && (this._transmissiveMats.add([ut, ut.transmission]),
            ut.transmission = 0))
        }
        ),
        setThreeRendererMode(o, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !0,
            transparentRender: !1,
            transmissionRender: !1,
            mainRenderPass: !1
        }, () => super.render(o, c, this.target, _, b)),
        this._transparentMats.forEach(ut => ut.transparent = !ut.transparent),
        this._transparentMats.clear(),
        this._transmissiveMats.forEach( ([ut,pt]) => ut.transmission = pt),
        this._transmissiveMats.clear(),
        o.setRenderTarget(nt, it, at)
    }
}
class GBufferPlugin extends GenericFilterPlugin {
    get material() {
        return this._material
    }
    passCtor(o) {
        var c, h, _;
        const b = ((c = this._viewer) === null || c === void 0 ? void 0 : c.renderer.isWebGL2) && this.renderFlagsBuffer
          , _e = o.renderer.createTarget({
            depthBuffer: !0,
            samples: ((h = this._viewer) === null || h === void 0 ? void 0 : h.useGBufferDepth) && ((_ = this._viewer) === null || _ === void 0 ? void 0 : _.renderer.composerTarget.samples) || 0,
            type: three_module.OUM,
            textureCount: b ? 2 : 1,
            depthTexture: this.renderDepthTexture,
            depthTextureType: this.depthTextureType
        });
        return Array.isArray(_e.texture) ? (_e.texture[0].name = "gbufferDepthNormal",
        _e.texture[1].name = "gbufferFlags",
        this._gbufferTextures = _e.texture) : (_e.texture.name = "gbufferDepthNormal",
        this._gbufferTextures.push(_e.texture)),
        this._gbufferTarget = _e,
        this._material = new DepthNormalMaterial(b),
        this._material.userData.isGBufferMaterial = !0,
        new GBufferRenderPass(_e,this._material)
    }
    _update(o) {
        if (!super._update(o))
            return !1;
        const c = this.pass.passObject;
        return c.scene = o.scene.modelObject,
        o.scene.renderCamera.updateShaderProperties(c.overrideMaterial),
        c.camera = o.scene.renderCamera.cameraObject,
        !0
    }
    constructor(o=!0, c=!1, h=three_module.bkx) {
        super(),
        this.renderFlagsBuffer = o,
        this.renderDepthTexture = c,
        this.depthTextureType = h,
        this.passId = "gbuffer",
        this._beforeFilters = ["render"],
        this._afterFilters = [],
        this._requiredFilters = ["render"],
        this._gbufferTextures = []
    }
    getDepthNormal() {
        return this._gbufferTextures.length > 0 ? this._gbufferTextures[0] : void 0
    }
    getFlagsTexture() {
        return this._gbufferTextures.length > 1 ? this._gbufferTextures[1] : void 0
    }
    async onDispose(o) {}
    async onRemove(o) {
        return this._gbufferTarget && (o.renderer.disposeTarget(this._gbufferTarget),
        this._gbufferTarget = void 0),
        super.onRemove(o)
    }
    getTarget() {
        return this._gbufferTarget
    }
    getDepthTexture() {
        var o;
        return (o = this._gbufferTarget) === null || o === void 0 ? void 0 : o.depthTexture
    }
    getUnpackSnippet() {
        return unpackGbuffer
    }
    updateShaderProperties(o) {
        var c, h, _;
        if (o.uniforms.tNormalDepth ? o.uniforms.tNormalDepth.value = (c = this.getDepthNormal()) !== null && c !== void 0 ? c : void 0 : (h = this._viewer) === null || h === void 0 || h.console.warn("BaseRenderer: no uniform: tNormalDepth"),
        o.uniforms.tGBufferFlags) {
            o.uniforms.tGBufferFlags.value = (_ = this.getFlagsTexture()) !== null && _ !== void 0 ? _ : void 0;
            const b = o.uniforms.tGBufferFlags.value ? 1 : 0;
            b !== o.defines.GBUFFER_HAS_FLAGS && (o.defines.GBUFFER_HAS_FLAGS = b,
            o.needsUpdate = !0)
        }
        return this
    }
    registerGBufferUpdater(o) {
        this._material && this._material.addGBufferUpdater(o)
    }
}
GBufferPlugin.PluginType = "GBuffer";
class RenderPass2 extends RenderPass {
    get transparentTarget() {
        return this._transparentTarget || (this._transparentTarget = this._viewer.renderer.getTempTarget({
            sizeMultiplier: 1,
            samples: this._viewer.renderer.composerTarget.samples || 0,
            colorSpace: three_module.jf0,
            type: this._viewer.renderer.rendererObject.extensions.has("EXT_color_buffer_half_float") ? three_module.ix0 : three_module.OUM,
            format: three_module.GWd,
            minFilter: three_module.k6q,
            magFilter: three_module.k6q,
            depthBuffer: !1
        })),
        this._transparentTarget
    }
    _releaseTransparentTarget() {
        this._transparentTarget && this._viewer.renderer.releaseTempTarget(this._transparentTarget),
        this._transparentTarget = void 0
    }
    constructor(o, c=!0) {
        super(),
        this.blurTransmissionTarget = !0,
        this.preserveTransparentTarget = !1,
        this._viewer = o,
        this._doTransmissionFix = c,
        this.clear = !0,
        this.clearColor = new three_module.Q1f(0,0,0),
        this.clearAlpha = 0,
        this.clearDepth = !1,
        this._blendPass = new GenericBlendTexturePass({},"c = vec4(a.rgb * (1. - b.a) + b.rgb * b.a, 1.);",void 0,void 0,o.renderer.maxHDRIntensity)
    }
    render(o, c, h, _, b) {
        var _e;
        let nt = !1;
        if (o.userData.mainRenderPass = !0,
        !this._doTransmissionFix)
            return super.render(o, c, h, _, b),
            this.needsSwap = nt,
            void (o.userData.mainRenderPass = void 0);
        const it = o.userData;
        it || console.error("threejs is not patched?");
        const at = this._viewer.useGBufferDepth;
        let ut;
        if (at) {
            const ht = (_e = this._viewer.getPlugin(GBufferPlugin)) === null || _e === void 0 ? void 0 : _e.getTarget();
            if (ht) {
                const _t = o.properties.get(ht);
                ut = _t.__webglDepthRenderbuffer || _t.__webglDepthbuffer
            } else
                console.warn("No Gbuffer present for depth prepass.")
        }
        let pt = (ht=!1) => {
            super.render(o, void 0, h, _, b, ut)
        }
        ;
        if (this._viewer.useRgbm) {
            if (this._viewer.useRgbm) {
                if (nt = !1,
                o.info && !o.info.autoReset)
                    throw "renderer.info.autoReset must be true";
                {
                    const ht = o.autoClearDepth;
                    o.autoClearDepth = !at,
                    setThreeRendererMode(o, {
                        shadowMapRender: !0,
                        backgroundRender: !0,
                        opaqueRender: !0,
                        transparentRender: !1,
                        transmissionRender: !1
                    }, pt),
                    o.autoClearDepth = ht
                }
                if (!at) {
                    const ht = o.properties.get(h);
                    ut = ht.__webglDepthRenderbuffer || ht.__webglDepthbuffer
                }
                pt = () => {
                    super.render(o, void 0, this.transparentTarget, _, b, ut)
                }
                ;
                {
                    const ht = this.clear
                      , _t = o.autoClearDepth;
                    o.autoClearDepth = !1,
                    this.clear = !0,
                    setThreeRendererMode(o, {
                        shadowMapRender: !1,
                        backgroundRender: !1,
                        opaqueRender: !1,
                        transparentRender: !0,
                        transmissionRender: !1
                    }, pt),
                    this.clear = ht,
                    o.autoClearDepth = _t
                }
                (!o.info || o.info.render.calls > 0) && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture,
                this._blendPass.render(o, c, h, _, b),
                nt = !0);
                {
                    const ht = this.clear;
                    this.clear = !1,
                    it.transmissionRenderTarget = nt ? c : h,
                    it.blurTransmissionTarget = this.blurTransmissionTarget && it.transmissionRenderTarget.samples === 0,
                    setThreeRendererMode(o, {
                        shadowMapRender: !1,
                        backgroundRender: !1,
                        opaqueRender: !1,
                        transparentRender: !1,
                        transmissionRender: !0
                    }, pt),
                    it.blurTransmissionTarget = void 0,
                    it.transmissionRenderTarget = void 0,
                    this.clear = ht
                }
                (!o.info || o.info.render.calls > 0) && (this._blendPass.uniforms.tDiffuse2.value = this.transparentTarget.texture,
                this._blendPass.render(o, c, h, _, b),
                nt = !0)
            }
        } else {
            {
                const ht = this.clear
                  , _t = o.autoClearDepth;
                o.autoClearDepth = !at,
                this.clear = !0,
                setThreeRendererMode(o, {
                    shadowMapRender: !0,
                    backgroundRender: !0,
                    opaqueRender: !0,
                    transparentRender: !0,
                    transmissionRender: !1
                }, pt),
                this.clear = ht,
                o.autoClearDepth = _t
            }
            {
                this._viewer.renderer.blit(h.texture, c, {
                    clear: !0
                });
                const ht = this.clear;
                this.clear = !1,
                it.transmissionRenderTarget = c,
                it.blurTransmissionTarget = this.blurTransmissionTarget,
                setThreeRendererMode(o, {
                    shadowMapRender: !1,
                    backgroundRender: !1,
                    opaqueRender: !1,
                    transparentRender: !1,
                    transmissionRender: !0
                }, pt),
                it.blurTransmissionTarget = void 0,
                it.transmissionRenderTarget = void 0,
                this.clear = ht
            }
            nt = !1
        }
        this.preserveTransparentTarget || this._releaseTransparentTarget(),
        this.needsSwap = nt,
        o.userData.mainRenderPass = void 0
    }
    dispose() {
        this._releaseTransparentTarget(),
        super.dispose()
    }
}
function vRGBMToLinear(d, o) {
    return d.multiplyScalar(d.w * o),
    d.w = 1,
    d
}
function cRGBMToLinear(d, o) {
    return vRGBMToLinear(d, o),
    new three_module.Q1f(d.x,d.y,d.z)
}
function vLinearToRGBM(d, o) {
    const c = Math.max(d.x, Math.max(d.y, d.z));
    let h = Math.max(Math.min(c / o, 1), 0);
    return h = Math.ceil(255 * h) / 255,
    d.divideScalar(h * o),
    d.w = h,
    d
}
function cLinearToRGBM(d, o) {
    return vLinearToRGBM(new three_module.IUQ(d.r,d.g,d.b,1), o)
}
const threeMaterialPropList = {
    name: "",
    blending: three_module.NTi,
    side: three_module.hB5,
    vertexColors: !1,
    opacity: 1,
    transparent: !1,
    blendSrc: three_module.ie2,
    blendDst: three_module.OuU,
    blendEquation: three_module.gO9,
    blendSrcAlpha: null,
    blendDstAlpha: null,
    blendEquationAlpha: null,
    depthFunc: three_module.xSv,
    depthTest: !0,
    depthWrite: !0,
    stencilWriteMask: 255,
    stencilFunc: three_module.sKt,
    stencilRef: 0,
    stencilFuncMask: 255,
    stencilFail: three_module.VVr,
    stencilZFail: three_module.VVr,
    stencilZPass: three_module.VVr,
    stencilWrite: !1,
    clippingPlanes: null,
    clipIntersection: !1,
    clipShadows: !1,
    shadowSide: null,
    colorWrite: !0,
    precision: null,
    polygonOffset: !1,
    polygonOffsetFactor: 0,
    polygonOffsetUnits: 0,
    dithering: !1,
    alphaToCoverage: !1,
    premultipliedAlpha: !1,
    forceSinglePass: !1,
    visible: !0,
    toneMapped: !0,
    userData: {},
    alphaTest: 0,
    alphaHash: !1
}
  , standardMaterialPropList = {
    ...threeMaterialPropList,
    color: "#ffffff",
    roughness: 1,
    metalness: 0,
    map: null,
    lightMap: null,
    lightMapIntensity: 1,
    aoMap: null,
    aoMapIntensity: 1,
    emissive: "#000000",
    emissiveIntensity: 1,
    emissiveMap: null,
    bumpMap: null,
    bumpScale: 1,
    normalMap: null,
    normalMapType: three_module.bI3,
    normalScale: new three_module.I9Y(1,1),
    displacementMap: null,
    displacementScale: 1,
    displacementBias: 0,
    roughnessMap: null,
    metalnessMap: null,
    alphaMap: null,
    envMap: null,
    envMapIntensity: 1,
    wireframe: !1,
    wireframeLinewidth: 1,
    wireframeLinecap: "round",
    wireframeLinejoin: "round",
    flatShading: !1,
    fog: !0
}
  , physicalMaterialPropList = {
    ...standardMaterialPropList,
    clearcoat: 0,
    clearcoatMap: null,
    clearcoatRoughness: 0,
    clearcoatRoughnessMap: null,
    clearcoatNormalScale: new three_module.I9Y(1,1),
    clearcoatNormalMap: null,
    reflectivity: .5,
    iridescence: 0,
    iridescenceMap: null,
    iridescenceIOR: 1.3,
    iridescenceThicknessRange: [100, 400],
    iridescenceThicknessMap: null,
    sheen: 0,
    sheenColor: new three_module.Q1f(0),
    sheenColorMap: null,
    sheenRoughness: 1,
    sheenRoughnessMap: null,
    transmission: 0,
    transmissionMap: null,
    thickness: 0,
    thicknessMap: null,
    attenuationDistance: 1 / 0,
    attenuationColor: new three_module.Q1f(1,1,1),
    specularIntensity: 1,
    specularIntensityMap: null,
    specularColor: new three_module.Q1f(1,1,1),
    specularColorMap: null
};
class MeshStandardMaterial2 extends three_module.uSd {
    constructor(o) {
        var c;
        super(o),
        this.typeSlug = MeshStandardMaterial2.TypeSlug,
        this.assetType = "material",
        this.materialObject = this,
        this.isMeshStandardMaterial2 = !0,
        this.extraUniformsToUpload = {},
        this.setDirty = this.setDirty.bind(this),
        this.userData.setDirty = h => {
            console.warn("userData.setDirty is deprecated. Use setDirty instead."),
            this.setDirty(h)
        }
        ,
        this.fog = !1,
        this.attenuationDistance = 0,
        this.materialExtensions = MaterialExtender.RegisterExtensions(this, (c = o == null ? void 0 : o.customMaterialExtensions) !== null && c !== void 0 ? c : [])
    }
    setDirty(o) {
        var c, h;
        this.needsUpdate = !0,
        this.dispatchEvent({
            ...o,
            type: "materialUpdate"
        }),
        (o == null ? void 0 : o.last) !== !1 && ((h = (c = this._uiConfig) === null || c === void 0 ? void 0 : c.uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0, 1))
    }
    registerMaterialExtensions(o) {
        this.materialExtensions = [...this.materialExtensions, ...MaterialExtender.RegisterExtensions(this, o)]
    }
    unregisterMaterialExtensions(o) {}
    get uiConfig() {
        return this._uiConfigChildren || (this._uiConfigChildren = [{
            type: "input",
            property: [this, "name"]
        }, {
            type: "checkbox",
            property: [this, "wireframe"]
        }, {
            type: "checkbox",
            property: [this, "vertexColors"]
        }, {
            type: "color",
            property: [this, "color"],
            limitedUi: !0
        }, {
            type: "image",
            property: [this, "map"]
        }, makeSamplerUi(this, "map"), {
            type: "folder",
            label: "Rough/Metal",
            limitedUi: !0,
            children: [{
                type: "slider",
                bounds: [0, 1],
                property: [this, "roughness"],
                limitedUi: !0
            }, {
                type: "slider",
                bounds: [0, 1],
                property: [this, "metalness"],
                limitedUi: !0
            }, {
                type: "image",
                property: [this, "roughnessMap"]
            }, makeSamplerUi(this, "roughnessMap"), {
                type: "image",
                property: [this, "metalnessMap"]
            }, makeSamplerUi(this, "metalnessMap")]
        }, {
            type: "folder",
            label: "Bump/Normal",
            limitedUi: !0,
            children: [{
                type: "slider",
                bounds: [-.1, .2],
                stepSize: .001,
                property: [this, "bumpScale"],
                hidden: () => !this.bumpMap
            }, {
                type: "image",
                property: [this, "bumpMap"]
            }, makeSamplerUi(this, "bumpMap"), {
                type: "image",
                property: [this, "normalMap"]
            }, {
                type: "vec2",
                property: [this, "normalScale"],
                hidden: () => !this.normalMap
            }, {
                type: "dropdown",
                hidden: () => !this.normalMap,
                property: [this, "normalMapType"],
                children: [["TangentSpace", three_module.bI3], ["ObjectSpace", three_module.vyJ]].map(o => ({
                    label: o[0],
                    value: o[1]
                }))
            }, makeSamplerUi(this, "normalMap"), {
                type: "input",
                property: [this, "displacementScale"],
                hidden: () => !this.displacementMap
            }, {
                type: "image",
                property: [this, "displacementMap"]
            }, makeSamplerUi(this, "displacementMap")]
        }, {
            type: "folder",
            label: "Sheen",
            children: [{
                type: "slider",
                bounds: [0, 1],
                property: [this, "sheen"]
            }, {
                type: "color",
                hidden: () => this.sheen < .001,
                property: [this, "sheenColor"]
            }, {
                type: "image",
                property: [this, "sheenColorMap"]
            }, makeSamplerUi(this, "sheenColorMap"), {
                type: "slider",
                bounds: [0, 1],
                property: [this, "sheenRoughness"]
            }, {
                type: "image",
                property: [this, "sheenRoughnessMap"]
            }, makeSamplerUi(this, "sheenRoughnessMap")]
        }, {
            type: "folder",
            label: "Clearcoat",
            children: [{
                type: "slider",
                bounds: [0, 1],
                property: [this, "clearcoat"]
            }, {
                type: "slider",
                bounds: [0, 1],
                hidden: () => this.clearcoat < .001,
                property: [this, "clearcoatRoughness"]
            }, {
                type: "image",
                property: [this, "clearcoatMap"]
            }, makeSamplerUi(this, "clearcoatMap"), {
                type: "slider",
                bounds: [0, 1],
                property: [this, "clearcoatRoughness"]
            }, {
                type: "image",
                property: [this, "clearcoatRoughnessMap"]
            }, makeSamplerUi(this, "clearcoatRoughnessMap"), {
                type: "image",
                property: [this, "clearcoatNormalMap"]
            }, {
                type: "vec2",
                property: [this, "clearcoatNormalScale"],
                hidden: () => !this.clearcoatNormalMap
            }, makeSamplerUi(this, "clearcoatNormalMap")]
        }, {
            type: "folder",
            label: "Emission",
            children: [{
                type: "color",
                property: [this, "emissive"]
            }, {
                type: "slider",
                bounds: [0, 10],
                property: [this, "emissiveIntensity"]
            }, {
                type: "image",
                property: [this, "emissiveMap"]
            }, makeSamplerUi(this, "emissiveMap")]
        }, {
            type: "folder",
            label: "Refraction",
            children: [{
                type: "slider",
                bounds: [0, 4],
                property: [this, "ior"]
            }, {
                type: "slider",
                bounds: [0, 1],
                property: [this, "transmission"],
                limitedUi: !0
            }, {
                type: "slider",
                bounds: [0, 1],
                stepSize: .001,
                property: [this, "thickness"]
            }, {
                type: "image",
                property: [this, "transmissionMap"]
            }, makeSamplerUi(this, "transmissionMap"), {
                type: "image",
                property: [this, "thicknessMap"]
            }, makeSamplerUi(this, "thicknessMap"), {
                type: "input",
                property: [this, "attenuationDistance"]
            }, {
                type: "color",
                property: [this, "attenuationColor"]
            }]
        }, {
            type: "folder",
            label: "Blending",
            children: [{
                type: "slider",
                bounds: [0, 1],
                property: [this, "opacity"]
            }, {
                type: "checkbox",
                property: [this, "transparent"],
                onChange: this.setDirty
            }, {
                type: "dropdown",
                property: [this, "depthFunc"],
                children: [["Never", three_module.eHc], ["Always", three_module.lGu], ["Less", three_module.brA], ["LessEqual", three_module.xSv], ["Equal", three_module.U3G], ["GreaterEqual", three_module.Gwm], ["Greater", three_module.K52], ["NotEqual", three_module.bw0]].map(o => ({
                    label: o[0],
                    value: o[1]
                }))
            }, {
                type: "checkbox",
                property: [this, "depthTest"],
                onChange: this.setDirty
            }, {
                type: "checkbox",
                property: [this, "depthWrite"],
                onChange: this.setDirty
            }, {
                type: "checkbox",
                property: [this, "colorWrite"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 1],
                stepSize: .001,
                property: [this, "alphaTest"]
            }, {
                type: "checkbox",
                property: [this, "alphaHash"]
            }, {
                type: "checkbox",
                property: [this, "dithering"]
            }, {
                type: "dropdown",
                label: "Blending",
                property: [this, "blending"],
                children: [["None", three_module.XIg], ["Normal", three_module.NTi], ["Additive", three_module.EZo], ["Subtractive", three_module.Kwu], ["Multiply", three_module.EdD]].map(o => ({
                    label: o[0],
                    value: o[1]
                }))
            }, {
                type: "image",
                property: [this, "alphaMap"]
            }, makeSamplerUi(this, "alphaMap"), {
                type: "checkbox",
                label: "Render to Depth",
                getValue: () => this.userData.renderToDepth === !0,
                setValue: o => {
                    this.userData.renderToDepth = o || void 0,
                    this.setDirty()
                }
            }, {
                type: "checkbox",
                label: "Inverse AlphaMap",
                hidden: () => !this.transparent,
                getValue: () => this.userData.inverseAlphaMap === !0,
                setValue: o => {
                    this.userData.inverseAlphaMap = o || void 0,
                    this.setDirty()
                }
            }, {
                type: "checkbox",
                label: "Polygon Offset",
                property: [this, "polygonOffset"]
            }, {
                type: "slider",
                label: "Polygon Offset Factor",
                bounds: [-10, 10],
                property: [this, "polygonOffsetFactor"]
            }, {
                type: "slider",
                label: "Polygon Offset Units",
                bounds: [-10, 10],
                property: [this, "polygonOffsetUnits"]
            }]
        }, {
            type: "folder",
            label: "AO/Lightmap",
            children: [{
                type: "slider",
                bounds: [0, 2],
                property: [this, "aoMapIntensity"]
            }, {
                type: "image",
                property: [this, "aoMap"]
            }, makeSamplerUi(this, "aoMap"), {
                type: "slider",
                bounds: [0, 2],
                property: [this, "lightMapIntensity"]
            }, {
                type: "image",
                property: [this, "lightMap"]
            }, makeSamplerUi(this, "lightMap")]
        }, {
            type: "folder",
            label: "Iridescence",
            children: [{
                type: "slider",
                bounds: [0, 3],
                label: "Intensity",
                property: [this, "iridescence"]
            }, {
                type: "slider",
                bounds: [0, 3],
                label: "IOR",
                property: [this, "iridescenceIOR"]
            }, {
                type: "slider",
                bounds: [0, 500],
                label: "Thickness0",
                property: [this.iridescenceThicknessRange, "0"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 500],
                label: "Thickness1",
                property: [this.iridescenceThicknessRange, "1"],
                onChange: this.setDirty
            }, {
                type: "image",
                property: [this, "iridescenceMap"]
            }, makeSamplerUi(this, "iridescenceMap"), {
                type: "image",
                property: [this, "iridescenceThicknessMap"]
            }, makeSamplerUi(this, "iridescenceThicknessMap")]
        }, {
            type: "folder",
            label: "Environment",
            children: [{
                type: "checkbox",
                label: "Override Environment",
                getValue: () => this.userData.separateEnvMapIntensity === !0,
                setValue: o => {
                    this.userData.separateEnvMapIntensity = o,
                    o || delete this.userData.separateEnvMapIntensity
                }
                ,
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 10],
                hidden: () => !this.userData.separateEnvMapIntensity,
                label: "Environment Intensity",
                property: [this, "envMapIntensity"]
            }, {
                type: "dropdown",
                hidden: () => !this.userData.separateEnvMapIntensity && !this.userData.envMapSlotKey,
                label: "Environment Map",
                children: ["", "environment1", "environment2"].map(o => ({
                    label: o || "default",
                    value: o
                })),
                getValue: () => this.userData.envMapSlotKey || "",
                setValue: o => {
                    this.userData.envMapSlotKey = o,
                    o || delete this.userData.envMapSlotKey,
                    this.setDirty()
                }
            }]
        }, {
            type: "dropdown",
            label: "Side",
            property: [this, "side"],
            children: [["Front", three_module.hB5], ["Back", three_module.hsX], ["Double", three_module.$EB]].map(o => ({
                label: o[0],
                value: o[1]
            }))
        }, {
            type: "checkbox",
            property: [this, "flatShading"]
        }, {
            type: "input",
            label: "Mesh count",
            getValue: () => {
                var o, c, h;
                return (h = (c = (o = this.userData) === null || o === void 0 ? void 0 : o.__appliedMeshes) === null || c === void 0 ? void 0 : c.size) !== null && h !== void 0 ? h : 0
            }
            ,
            setValue: o => {}
            ,
            disabled: !0
        }, {
            type: "button",
            label: `Download ${this.typeSlug}`,
            value: () => {
                N$2(new Blob([JSON.stringify(serializeObject(this, !1), null, 2)],{
                    type: "application/json"
                }), `physical-material.${this.typeSlug}`)
            }
        }]),
        this._uiConfig || (this._uiConfig = {
            type: "folder",
            label: "Physical Material",
            expanded: !0,
            children: this._uiConfigChildren,
            uuid: "MSM2_" + this.uuid,
            limitedUi: !0
        }),
        this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(o => {
            var c;
            return (c = o.getUiConfig) === null || c === void 0 ? void 0 : c.call(o, this)
        }
        )].filter(o => o),
        this._uiConfig
    }
    onBeforeCompile(o, c) {
        const h = [["vec3 totalDiffuse = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["#include <lights_physical_fragment>", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]]
          , _ = [["#include <uv_vertex>", "mainStart"]];
        for (const b of _)
            o.vertexShader = shaderReplaceString(o.vertexShader, b[0], "#glMarker " + b[1] + `
` + b[0]);
        for (const b of h)
            o.fragmentShader = shaderReplaceString(o.fragmentShader, b[0], "#glMarker " + b[1] + `
` + b[0]);
        MaterialExtender.ApplyMaterialExtensions(this, o, this.materialExtensions, c),
        o.fragmentShader = o.fragmentShader.replaceAll("#glMarker", "// "),
        o.vertexShader = o.vertexShader.replaceAll("#glMarker", "// "),
        o.defines.INVERSE_ALPHAMAP = this.userData.inverseAlphaMap ? 1 : 0,
        super.onBeforeCompile(o, c)
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + MaterialExtender.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap
    }
    onBeforeRender(o, c, h, _, b) {
        super.onBeforeRender(o, c, h, _, b),
        this.envMapIntensity === void 0 || this.userData.separateEnvMapIntensity || c.envMapIntensity === void 0 || (this.userData.__envIntensity = this.envMapIntensity,
        this.envMapIntensity = c.envMapIntensity),
        this.envMap !== void 0 && c.fixedEnvMapDirection !== void 0 && (c.fixedEnvMapDirection ? this.defines.FIX_ENV_DIRECTION || (this.defines.FIX_ENV_DIRECTION = "1",
        this.needsUpdate = !0) : this.defines.FIX_ENV_DIRECTION !== void 0 && (delete this.defines.FIX_ENV_DIRECTION,
        this.needsUpdate = !0)),
        this.dispatchEvent({
            type: "beforeRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        });
        const _e = this.userData.inverseAlphaMap ? 1 : 0;
        _e !== this.defines.INVERSE_ALPHAMAP && (this.defines.INVERSE_ALPHAMAP = _e,
        this.needsUpdate = !0)
    }
    onAfterRender(o, c, h, _, b) {
        super.onAfterRender(o, c, h, _, b),
        this.userData.__envIntensity !== void 0 && (this.envMapIntensity = this.userData.__envIntensity,
        delete this.userData.__envIntensity),
        this.dispatchEvent({
            type: "afterRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    copyProps(o, c=!1, h=!0) {
        if (!c && !["MeshStandardMaterial", MeshStandardMaterial2.TYPE, "MeshPhysicalMaterial"].includes(o.type))
            return console.error("Material type is not supported:", o.type),
            this;
        const _ = {};
        xe$1(o, _, Array.from(Object.keys(physicalMaterialPropList)));
        const b = _.userData;
        delete _.userData;
        for (const _e of Object.keys(_))
            _[_e] === void 0 && delete _[_e];
        if (this.setValues(_),
        h)
            for (const _e of iMaterialIgnoredUserData)
                this.userData[_e] !== void 0 && this.userData[_e];
        return b && copyMaterialUserData(this.userData, b),
        isFinite(this.attenuationDistance) || (this.attenuationDistance = 0),
        this.setDirty(),
        this
    }
    toJSON(o) {
        var c, h;
        const _ = this.userData;
        this.userData = {};
        const b = super.toJSON(o);
        this.userData = _,
        b.userData = {},
        copyMaterialUserData(b.userData, _),
        b.userData.uuid = this.userData.uuid;
        const _e = o || {
            textures: Object.fromEntries(((c = b.textures) === null || c === void 0 ? void 0 : c.map(nt => [nt.uuid, nt])) || []),
            images: Object.fromEntries(((h = b.images) === null || h === void 0 ? void 0 : h.map(nt => [nt.uuid, nt])) || [])
        };
        b.userData = serializeObject(b.userData, !1, _e),
        o || (Object.keys(_e.textures).length > 0 && (b.textures = Object.values(_e.textures)),
        Object.keys(_e.images).length > 0 && (b.images = Object.values(_e.images))),
        b.type = MeshStandardMaterial2.TYPE;
        for (const nt of Object.keys(b))
            b[nt] === void 0 && delete b[nt];
        return b
    }
    fromJSON(o, c, h=!1) {
        return this.copyProps(o, h)
    }
    clone() {
        return super.clone()
    }
}
MeshStandardMaterial2.TypeSlug = "pmat",
MeshStandardMaterial2.TYPE = "MeshStandardMaterial2";
const basicMaterialPropList = {
    ...threeMaterialPropList,
    color: "#ffffff",
    map: null,
    lightMap: null,
    lightMapIntensity: 1,
    aoMap: null,
    aoMapIntensity: 1,
    specularMap: null,
    alphaMap: null,
    envMap: null,
    combine: three_module.caT,
    reflectivity: 1,
    refractionRatio: .98,
    wireframe: !1,
    wireframeLinewidth: 1,
    wireframeLinecap: "round",
    wireframeLinejoin: "round",
    skinning: !1,
    fog: !0
};
class MeshBasicMaterial2 extends three_module.V9B {
    constructor(o) {
        var c;
        super(o),
        this.typeSlug = MeshBasicMaterial2.TypeSlug,
        this.assetType = "material",
        this.materialObject = this,
        this.isMeshBasicMaterial2 = !0,
        this.extraUniformsToUpload = {},
        !this.defines && (this.defines = {}),
        this.fog = !1,
        this.setDirty = this.setDirty.bind(this),
        this.userData.setDirty = h => {
            console.warn("WebGi: userData.setDirty is deprecated. Use setDirty instead."),
            this.setDirty(h)
        }
        ,
        this.materialExtensions = MaterialExtender.RegisterExtensions(this, (c = o == null ? void 0 : o.customMaterialExtensions) !== null && c !== void 0 ? c : [])
    }
    setDirty(o) {
        var c, h;
        this.needsUpdate = !0,
        this.dispatchEvent({
            ...o,
            type: "materialUpdate"
        }),
        (o == null ? void 0 : o.last) !== !1 && ((h = (c = this._uiConfig) === null || c === void 0 ? void 0 : c.uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0, 1))
    }
    registerMaterialExtensions(o) {
        this.materialExtensions = [...this.materialExtensions, ...MaterialExtender.RegisterExtensions(this, o)]
    }
    unregisterMaterialExtensions(o) {}
    get uiConfig() {
        return this._uiConfigChildren || (this._uiConfigChildren = [{
            type: "input",
            property: [this, "name"]
        }, {
            type: "checkbox",
            property: [this, "wireframe"]
        }, {
            type: "color",
            property: [this, "color"],
            limitedUi: !0
        }, {
            type: "image",
            property: [this, "map"]
        }, makeSamplerUi(this, "map"), {
            type: "folder",
            label: "Blending",
            children: [{
                type: "slider",
                bounds: [0, 1],
                property: [this, "opacity"]
            }, {
                type: "checkbox",
                property: [this, "transparent"],
                onChange: this.setDirty
            }, {
                type: "checkbox",
                property: [this, "depthWrite"],
                onChange: this.setDirty
            }, {
                type: "checkbox",
                property: [this, "colorWrite"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 1],
                property: [this, "alphaTest"]
            }, {
                type: "checkbox",
                property: [this, "alphaHash"]
            }, {
                type: "checkbox",
                property: [this, "dithering"]
            }, {
                type: "dropdown",
                label: "Blending",
                property: [this, "blending"],
                children: [["None", three_module.XIg], ["Normal", three_module.NTi], ["Additive", three_module.EZo], ["Subtractive", three_module.Kwu], ["Multiply", three_module.EdD]].map(o => ({
                    label: o[0],
                    value: o[1]
                }))
            }, {
                type: "image",
                property: [this, "alphaMap"]
            }, makeSamplerUi(this, "alphaMap"), {
                type: "checkbox",
                label: "Render to Depth",
                getValue: () => this.userData.renderToDepth === !0,
                setValue: o => {
                    this.userData.renderToDepth = o || void 0,
                    this.setDirty()
                }
            }]
        }, {
            type: "folder",
            label: "AO/Lightmap",
            children: [{
                type: "slider",
                bounds: [0, 2],
                property: [this, "aoMapIntensity"]
            }, {
                type: "image",
                property: [this, "aoMap"]
            }, makeSamplerUi(this, "aoMap"), {
                type: "slider",
                bounds: [0, 2],
                property: [this, "lightMapIntensity"]
            }, {
                type: "image",
                property: [this, "lightMap"]
            }, makeSamplerUi(this, "lightMap")]
        }, {
            type: "dropdown",
            label: "Side",
            property: [this, "side"],
            children: [["Front", three_module.hB5], ["Back", three_module.hsX], ["Double", three_module.$EB]].map(o => ({
                label: o[0],
                value: o[1]
            }))
        }, {
            type: "input",
            label: "Mesh count",
            getValue: () => {
                var o, c, h;
                return (h = (c = (o = this.userData) === null || o === void 0 ? void 0 : o.__appliedMeshes) === null || c === void 0 ? void 0 : c.size) !== null && h !== void 0 ? h : 0
            }
            ,
            setValue: o => {}
            ,
            disabled: !0
        }, {
            type: "button",
            label: `Download ${this.typeSlug}`,
            value: () => {
                N$2(new Blob([JSON.stringify(serializeObject(this, !1), null, 2)],{
                    type: "application/json"
                }), `unlit-material.${this.typeSlug}`)
            }
        }]),
        this._uiConfig || (this._uiConfig = {
            type: "folder",
            label: "Unlit Material",
            expanded: !0,
            children: this._uiConfigChildren,
            uuid: "MBM2_" + this.uuid,
            limitedUi: !0
        }),
        this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(o => {
            var c;
            return (c = o.getUiConfig) === null || c === void 0 ? void 0 : c.call(o, this)
        }
        )].filter(o => o),
        this._uiConfig
    }
    onBeforeCompile(o, c) {
        const h = [["vec3 outgoingLight = ", "afterModulation"], ["#include <aomap_fragment>", "beforeModulation"], ["ReflectedLight reflectedLight = ", "beforeAccumulation"], ["#include <clipping_planes_fragment>", "mainStart"]]
          , _ = [["#include <uv_vertex>", "mainStart"]];
        for (const b of _)
            o.vertexShader = shaderReplaceString(o.vertexShader, b[0], "#glMarker " + b[1] + `
` + b[0]);
        for (const b of h)
            o.fragmentShader = shaderReplaceString(o.fragmentShader, b[0], "#glMarker " + b[1] + `
` + b[0]);
        MaterialExtender.ApplyMaterialExtensions(this, o, this.materialExtensions, c),
        this.dispatchEvent({
            type: "beforeCompile",
            shader: o,
            renderer: c
        }),
        o.fragmentShader = o.fragmentShader.replaceAll("#glMarker", "// "),
        o.vertexShader = o.vertexShader.replaceAll("#glMarker", "// "),
        super.onBeforeCompile(o, c)
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + MaterialExtender.CacheKeyForExtensions(this, this.materialExtensions) + this.userData.inverseAlphaMap
    }
    onBeforeRender(o, c, h, _, b) {
        super.onBeforeRender(o, c, h, _, b),
        this.dispatchEvent({
            type: "beforeRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    onAfterRender(o, c, h, _, b) {
        super.onAfterRender(o, c, h, _, b),
        this.dispatchEvent({
            type: "afterRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    copyProps(o, c=!1) {
        if (!c && !["MeshBasicMaterial", MeshBasicMaterial2.TYPE].includes(o.type))
            return console.error("Material type is not supported:", o.type),
            this;
        const h = {};
        xe$1(o, h, Array.from(Object.keys(basicMaterialPropList)));
        const _ = h.userData;
        delete h.userData;
        for (const b of Object.keys(h))
            h[b] === void 0 && delete h[b];
        return this.setValues(h),
        _ && copyMaterialUserData(this.userData, _),
        this.setDirty(),
        this
    }
    toJSON(o) {
        var c, h;
        const _ = this.userData;
        this.userData = {};
        const b = super.toJSON(o);
        this.userData = _,
        b.userData = {},
        copyMaterialUserData(b.userData, _),
        b.userData.uuid = this.userData.uuid;
        const _e = o || {
            textures: Object.fromEntries(((c = b.textures) === null || c === void 0 ? void 0 : c.map(nt => [nt.uuid, nt])) || []),
            images: Object.fromEntries(((h = b.images) === null || h === void 0 ? void 0 : h.map(nt => [nt.uuid, nt])) || [])
        };
        b.userData = serializeObject(b.userData, !1, _e),
        o || (Object.keys(_e.textures).length > 0 && (b.textures = Object.values(_e.textures)),
        Object.keys(_e.images).length > 0 && (b.images = Object.values(_e.images))),
        b.type = MeshBasicMaterial2.TYPE;
        for (const nt of Object.keys(b))
            b[nt] === void 0 && delete b[nt];
        return b
    }
    fromJSON(o, c, h=!1) {
        return this.copyProps(o, h)
    }
    clone() {
        return super.clone()
    }
}
MeshBasicMaterial2.TypeSlug = "bmat",
MeshBasicMaterial2.TYPE = "MeshBasicMaterial2";
const standardMaterialTemplate = {
    materialType: MeshStandardMaterial2.TYPE,
    name: "standard",
    color: "#ffffff"
}
  , basicMaterialTemplate = {
    materialType: MeshBasicMaterial2.TYPE,
    name: "basic",
    color: "#ffffff"
}
  , typeTemplateNameMap = {
    [MeshStandardMaterial2.TYPE]: standardMaterialTemplate.name,
    MeshStandardMaterial: standardMaterialTemplate.name,
    MeshPhysicalMaterial: standardMaterialTemplate.name,
    [MeshBasicMaterial2.TYPE]: basicMaterialTemplate.name,
    MeshBasicMaterial: basicMaterialTemplate.name
};
class AMaterialManager extends I$2 {
    constructor() {
        super(),
        this._templates = [standardMaterialTemplate, basicMaterialTemplate],
        this._materials = [],
        this._disposeMaterial = o => {
            const c = o.target;
            if (!c || c.assetType !== "material")
                return;
            this._refreshTextureRefs();
            const h = this._getMapsForMaterial(c)
              , _ = [];
            h.forEach(b => {
                const _e = b.userData.__appliedMaterials;
                _e == null || _e.delete(c),
                _e && b.userData.disposeOnIdle !== !1 && _e.size === 0 && _.push(b)
            }
            ),
            _.forEach(b => {
                b.dispose()
            }
            )
        }
        ,
        this._materialExtensions = [],
        this.processModel = this.processModel.bind(this),
        this.processMaterial = this.processMaterial.bind(this)
    }
    findOrCreate(o, c) {
        let h = this.findMaterial(o);
        return h || (h = this.generateFromTemplate(o, c)),
        h
    }
    generateFromTemplate(o, c) {
        const h = this.findTemplate(o);
        if (h)
            return this._generateFromTemplate(h, c ?? {})
    }
    generateFromTemplateType(o, c) {
        const h = this._templates.find(_ => _.materialType === o);
        if (h)
            return this._generateFromTemplate(h, c ?? {})
    }
    findTemplate(o) {
        return this._templates.find(c => c.name === o)
    }
    _refreshTextureRefs(o) {
        (o || this.getAllMaterials()).forEach(c => {
            this._getMapsForMaterial(c).forEach(h => {
                let _ = h.userData.__appliedMaterials;
                _ || (h.userData.__appliedMaterials = _ = new Set),
                h.addEventListener("update", () => c.dispatchEvent({
                    type: "textureUpdate",
                    texture: h
                })),
                _.add(c)
            }
            )
        }
        )
    }
    _getMapsForMaterial(o) {
        var c;
        const h = new Set;
        for (const _ of Object.values(o))
            _ && _.isTexture && h.add(_);
        for (const _ of Object.values((c = o.userData) !== null && c !== void 0 ? c : {}))
            _ && _.isTexture && h.add(_);
        return h
    }
    registerMaterial(o) {
        if (this._materials.includes(o))
            return;
        const c = this.findMaterial(o.uuid);
        c ? console.warn("WebGi MaterialManager: Material UUID already exists", o, c) : (o.addEventListener("dispose", this._disposeMaterial),
        this._materials.push(o),
        this._refreshTextureRefs([o]))
    }
    registerMaterialObject(o) {
        const c = o.materialObject ? o : Object.assign(o, {
            assetType: "material",
            materialObject: o
        });
        return this.registerMaterial(c),
        c
    }
    unregisterMaterial(o) {
        this._materials = this._materials.filter(c => c.uuid !== o.uuid),
        o.removeEventListener("dispose", this._disposeMaterial)
    }
    registerMaterialTemplate(o) {
        o.templateUUID || (o.templateUUID = esm_browser_v4());
        const c = this._templates.find(h => h.templateUUID === o.templateUUID);
        c ? console.warn("WebGi Material Manager: MaterialTemplate already exists", o, c) : this._templates.push(o)
    }
    unregisterMaterialTemplate(o) {
        this._templates = this._templates.filter(c => c.templateUUID !== o.templateUUID)
    }
    dispose(o=!0) {
        const c = this._materials;
        this._materials = [];
        for (const h of c)
            o || !h.userData.runtimeMaterial ? h.dispose() : this._materials.push(h)
    }
    findMaterial(o) {
        return o ? this._materials.find(c => c.uuid === o) : void 0
    }
    findMaterialsByName(o, c=!1) {
        return this._materials.filter(h => typeof o != "string" || c ? h.name.match(typeof o == "string" ? "^" + o + "$" : o) !== null : h.name === o)
    }
    getMaterialsOfType(o) {
        return o ? this._materials.filter(c => c.typeSlug === o) : []
    }
    getAllMaterials() {
        return [...this._materials]
    }
    processModel(o, c) {
        return S$2(o, "modelObject", this._processModel(o, c)),
        o
    }
    _processMaterial(o, c) {
        var h, _;
        if (!o)
            return;
        if (!((h = o.materialObject) === null || h === void 0) && h.isMaterial)
            return o;
        let b = o.mmMaterial;
        if (!b) {
            const _e = ((_ = o.userData) === null || _ === void 0 ? void 0 : _.uuid) || o.uuid;
            if (b = this.findMaterial(_e),
            b)
                b.copyProps(o);
            else {
                const nt = c.useSourceMaterial === !1 || !o.isMaterial
                  , it = c.materialTemplate || (nt ? "standard" : typeTemplateNameMap[o.type] || "standard");
                b = this.generateFromTemplate(it, nt ? {} : o)
            }
            o.mmMaterial = b
        }
        return b
    }
    processMaterial(o, c) {
        return o.materialObject || (o = this._processMaterial(o, {
            ...c,
            register: !1
        })),
        c.register !== !1 && this.registerMaterial(o),
        o
    }
    registerMaterialExtension(o) {
        this._materialExtensions.includes(o) || this._materialExtensions.push(o)
    }
    unregisterMaterialExtension(o) {
        const c = this._materialExtensions.indexOf(o);
        c >= 0 && this._materialExtensions.splice(c, 1)
    }
    exportMaterial(o, c, h=!0, _=!1) {
        const b = serializeObject(o, !1)
          , _e = JSON.stringify(b, null, h ? 0 : 2)
          , nt = (c || o.name || "physical_material") + "." + o.typeSlug
          , it = new File([_e],nt,{
            type: "application/json"
        });
        return _ && me$1(it),
        it
    }
    applyMaterial(o, c, h=!0) {
        let _ = this.findMaterialsByName(c, h);
        (!_ || _.length < 1) && (_ = [this.findMaterial(c)]);
        let b = !1;
        for (const _e of _)
            _e && (_e.userData.__isVariation || _e !== o && this.copyMaterialProps(_e, o) && (b = !0));
        return b
    }
    copyMaterialProps(o, c) {
        var h;
        let _ = !1;
        const b = Object.getPrototypeOf(c).constructor.TYPE;
        if (Object.getPrototypeOf(o).constructor.TYPE === b) {
            const _e = o.name;
            o.copyProps(c),
            o.name = _e,
            _ = !0
        } else {
            const _e = o["__" + b] || this.generateFromTemplateType(b);
            if (_e) {
                const nt = o.name;
                _e.copyProps(c),
                _e.name = nt;
                const it = o.userData.__appliedMeshes;
                for (const at of [...it ?? []])
                    (h = at == null ? void 0 : at.setMaterial) === null || h === void 0 || h.call(at, _e),
                    at && (_ = !0);
                o["__" + b] = _e
            }
        }
        return _
    }
}
class MaterialManager extends AMaterialManager {
    _generateFromTemplate(o, c) {
        var h, _, b, _e, nt, it;
        let at;
        const ut = {
            ...o
        };
        ut.customMaterialExtensions = [...(h = ut.customMaterialExtensions) !== null && h !== void 0 ? h : [], ...this._materialExtensions];
        const pt = (c == null ? void 0 : c.metadata) && (c == null ? void 0 : c.metadata.version) <= 4.5;
        pt && (three_module.ppV.enabled = !1);
        let ht = {};
        switch (o.materialType) {
        case "MeshStandardMaterial2":
        case "standard":
            c && xe$1(c, ut, Array.from(Object.keys(physicalMaterialPropList))),
            (c == null ? void 0 : c.type) === "MeshBasicMaterial" && (ut.roughness = .9,
            ut.metalness = 0,
            !((_ = ut.userData) === null || _ === void 0) && _.uuid && delete ut.userData.uuid),
            ht = (b = ut.userData) === null || b === void 0 ? void 0 : b.uuid,
            ht && delete ut.userData.uuid,
            at = new MeshStandardMaterial2({
                customMaterialExtensions: ut.customMaterialExtensions
            }).fromJSON(ut, void 0, !0),
            ht && (at.uuid = ht),
            at.userData.uuid = at.uuid,
            at.setDirty(),
            c != null && c.isMaterial && c.userData !== void 0 && (c.userData.iMaterial = at);
            break;
        case "MeshBasicMaterial2":
        case "basic":
        case "unlit":
            c && xe$1(c, ut, Array.from(Object.keys(basicMaterialPropList))),
            ht = (_e = ut.userData) === null || _e === void 0 ? void 0 : _e.uuid,
            ht && delete ut.userData.uuid,
            at = new MeshBasicMaterial2({
                customMaterialExtensions: ut.customMaterialExtensions
            }).fromJSON(ut, void 0, !0),
            ht && (at.uuid = ht,
            ut.userData.uuid = ht),
            at.userData.uuid = at.uuid,
            at.setDirty();
            break;
        case "shadow":
            throw "TODO: Not implemented shadow material";
        default:
            ht = null,
            c && c.userData && (ht = c.userData,
            delete c.userData),
            at = ((nt = o.generator) === null || nt === void 0 ? void 0 : nt.call(o, ut, c)) || void 0,
            c && ht && (c.userData = ht),
            ht && at && (copyMaterialUserData(at.userData, ht),
            ht != null && ht.uuid && (at.uuid = ht.uuid),
            ht = null),
            at && (at.userData.uuid = at.uuid)
        }
        if (at) {
            c.runtimeMaterial && (at.userData.runtimeMaterial = !0);
            const _t = at;
            if (at.clone = () => {
                _t.userData.cloneId || (_t.userData.cloneId = "0"),
                _t.userData.cloneCount || (_t.userData.cloneCount = 0),
                _t.userData.cloneCount += 1;
                const vt = this.generateFromTemplate(o.name);
                return vt && (vt.copyProps(_t),
                vt.userData.cloneId = vt.userData.cloneId + "_" + _t.userData.cloneCount,
                vt.userData.cloneCount = 0,
                vt.name = vt.name + "_" + vt.userData.cloneId,
                vt.userData.uuid = vt.uuid),
                vt == null ? void 0 : vt.materialObject
            }
            ,
            c) {
                let vt = this.findMaterial(c == null ? void 0 : c.uuid);
                vt && this.unregisterMaterial(vt),
                vt = this.findMaterial((it = c == null ? void 0 : c.materialObject) === null || it === void 0 ? void 0 : it.uuid),
                vt && this.unregisterMaterial(vt)
            }
        }
        return pt && (three_module.ppV.enabled = !0),
        at ? this.registerMaterialObject(at) : void 0
    }
    _processModel(o, c) {
        if (!o.modelObject)
            return console.error("MaterialManager: No modelObject found for ", o),
            o;
        let h = o.material;
        if (!h && o.geometry && (this._defaultMaterial || (this._defaultMaterial = this.generateFromTemplate("standard")),
        h = this._defaultMaterial,
        o.material = h),
        h) {
            let _ = !0;
            Array.isArray(h) || (h = [h],
            _ = !1);
            const b = [];
            for (const _e of h) {
                const nt = this._processMaterial(_e, c);
                b.push(nt == null ? void 0 : nt.materialObject)
            }
            o.setMaterial && (o.modelObject.material = null,
            o.setMaterial(_ ? b : b[0]))
        }
        if (c.recursive !== !1)
            for (let _ = 0; _ < o.modelObject.children.length; _++)
                o.modelObject.children[_] = this._processModel(o.modelObject.children[_], c);
        return o
    }
}
class Importer {
    ctor(o) {
        const c = this.cls && new this.cls(o.loadingManager);
        return typeof this.onCtor == "function" ? this.onCtor(c, o) : c
    }
    constructor(o, c, h, _) {
        this.cls = o,
        this.ext = c,
        this.root = h,
        this.onCtor = _
    }
}
class Object3DModel {
    get visible() {
        return this._modelObject.visible
    }
    set visible(o) {
        this._modelObject.visible = o
    }
    get uuid() {
        return this._modelObject.uuid
    }
    get modelObject() {
        return this._modelObject
    }
    get name() {
        return this._modelObject.name
    }
    set name(o) {
        this._modelObject.name = o
    }
    constructor(o, {pseudoCenter: c=!1, autoCenter: h=!1, autoScale: _=!1, autoScaleRadius: b=2, license: _e=""}={}) {
        if (this.assetType = "model",
        this._modelObject = setupIModel(new three_module.B69),
        this.setDirty = this.setDirty.bind(this),
        this.updateBounds = this.updateBounds.bind(this),
        o || (o = this._modelObject),
        !c || o.userData.pseudoCentered || o.userData.isCentered)
            !h || o.userData.autoCentered || o.userData.isCentered || o.userData.pseudoCentered ? c || h || (o.userData.isCentered = !0) : autoCenterObject3D(o),
            this._modelObject = o;
        else {
            h && console.error("cannot use pseudoCenter and autoCenter at the same time");
            const nt = new Box3B().expandByObject(o, !0, !0).getCenter(new three_module.Pq0);
            this._modelObject.position.copy(nt).negate(),
            this._modelObject.updateMatrix(),
            this._modelObject.add(o),
            this._modelObject.name = o.name + "-centered",
            this._modelObject.userData.pseudoCentered = !0,
            this._modelObject.userData.isCentered = !0,
            o.userData.iModel = this
        }
        _ && !this._modelObject.userData.autoScaled ? autoScaleObject3D(this._modelObject, o.userData.autoScaleRadius || b) : this._modelObject.userData.autoScaled = !0,
        this._modelObject.addEventListener("dispose", () => {
            this.__disposed = !0
        }
        ),
        this._modelObject.userData.iModel = this,
        this.license = _e
    }
    get license() {
        return this._modelObject.userData.license
    }
    set license(o) {
        this._modelObject.userData.license = o
    }
    addEventListener(o, c) {
        this._modelObject.addEventListener(o, c)
    }
    dispatchEvent(o) {
        this._modelObject.dispatchEvent(o)
    }
    hasEventListener(o, c) {
        return this._modelObject.hasEventListener(o, c)
    }
    removeEventListener(o, c) {
        this._modelObject.removeEventListener(o, c)
    }
    traverse(o) {
        this._modelObject.traverse(o)
    }
    dispose() {
        const o = this._modelObject.dispose;
        o && typeof o == "function" ? o() : (console.warn("WebGi Object3DModel: no dispose in modelObject"),
        this._modelObject.removeFromParent())
    }
    setDirty(o) {
        var c, h, _, b;
        (h = (c = this._modelObject) === null || c === void 0 ? void 0 : c.setDirty) === null || h === void 0 || h.call(c, o),
        (b = (_ = this._uiConfig) === null || _ === void 0 ? void 0 : _.uiRefresh) === null || b === void 0 || b.call(_, "postFrame", !0)
    }
    setMaterial(o) {
        var c, h;
        return this._modelObject.isMesh ? ((h = (c = this._modelObject).setMaterial) === null || h === void 0 ? void 0 : h.call(c, o)) || [] : (console.error("setMaterial only works on meshes"),
        [])
    }
    get material() {
        return this._modelObject.material
    }
    get geometry() {
        return this._modelObject.geometry
    }
    setGeometry(o, c=!1) {
        var h, _;
        if (this._modelObject.isMesh)
            return (_ = (h = this._modelObject).setGeometry) === null || _ === void 0 ? void 0 : _.call(h, o, c);
        console.error("setGeometry only works on meshes")
    }
    get userData() {
        return this._modelObject.userData
    }
    set userData(o) {
        this._modelObject.userData = o
    }
    updateBounds() {
        console.warn("WebGi Object3DModel: updateBounds: NOT IMPLEMENTED, don't use"),
        this.setDirty()
    }
    get uiConfig() {
        return this._uiConfig || (this._uiConfig = makeObject3DUiConfig(this._modelObject, !1)),
        this._uiConfig
    }
    clone() {
        return new Object3DModel(this._modelObject.clone(),{
            pseudoCenter: !1,
            autoScale: !1,
            autoCenter: !1,
            license: this.license
        })
    }
}
function setupObject3dModel(d, o) {
    return [d.modelObject, ...d.modelObject.children].forEach(c => {
        setupIModel(c, c !== d.modelObject ? d : void 0, o)
    }
    ),
    d
}
class ObjectProcessorMap {
    constructor() {
        this._processors = new Map
    }
    add(o, c) {
        var h;
        this._processors.has(o) || this._processors.set(o, []),
        (h = this._processors.get(o)) === null || h === void 0 || h.push(c)
    }
    remove(o, c) {
        const h = this._processors.get(o)
          , _ = (h == null ? void 0 : h.indexOf(c)) || (h == null ? void 0 : h.findIndex(b => b.process && b.process === c.process || b.processAsync && b.processAsync === c.processAsync));
        !h || !_ || _ < 0 || h.splice(_, 1)
    }
    get(o) {
        var c;
        return (c = this._processors.get(o)) !== null && c !== void 0 ? c : []
    }
    async process(o, c, h) {
        var _, b, _e, nt;
        const it = this.get(o)
          , at = c.assetType;
        for (const ut of it)
            ut.forAssetType === at && (c = (b = (_ = ut.process) === null || _ === void 0 ? void 0 : _.call(ut, c, h)) !== null && b !== void 0 ? b : c,
            c = (nt = await ((_e = ut.processAsync) === null || _e === void 0 ? void 0 : _e.call(ut, c, h))) !== null && nt !== void 0 ? nt : c);
        return c
    }
    dispose() {
        this._processors.clear()
    }
}
class SimpleJSONLoader extends three_module.Y9S {
    load(o, c, h, _) {
        return super.load(o, b => {
            try {
                if (typeof b != "string")
                    throw new Error("Invalid JSON");
                c == null || c(JSON.parse(b))
            } catch (_e) {
                _ == null || _(_e)
            }
        }
        , h, _)
    }
}
class RGBELoader extends three_module.BRH {
    constructor(o) {
        super(o),
        this.type = three_module.ix0
    }
    parse(o) {
        const c = function(vt, bt) {
            switch (vt) {
            case 1:
                throw new Error("THREE.RGBELoader: Read Error: " + (bt || ""));
            case 2:
                throw new Error("THREE.RGBELoader: Write Error: " + (bt || ""));
            case 3:
                throw new Error("THREE.RGBELoader: Bad File Format: " + (bt || ""));
            default:
                throw new Error("THREE.RGBELoader: Memory Error: " + (bt || ""))
            }
        }
          , h = function(vt, bt, St) {
            bt = bt || 1024;
            let At = vt.pos
              , Et = -1
              , Pt = 0
              , It = ""
              , Dt = String.fromCharCode.apply(null, new Uint16Array(vt.subarray(At, At + 128)));
            for (; 0 > (Et = Dt.indexOf(`
`)) && Pt < bt && At < vt.byteLength; )
                It += Dt,
                Pt += Dt.length,
                At += 128,
                Dt += String.fromCharCode.apply(null, new Uint16Array(vt.subarray(At, At + 128)));
            return -1 < Et && (vt.pos += Pt + Et + 1,
            It + Dt.slice(0, Et))
        }
          , _ = function(vt, bt, St, At) {
            const Et = vt[bt + 3]
              , Pt = Math.pow(2, Et - 128) / 255;
            St[At + 0] = vt[bt + 0] * Pt,
            St[At + 1] = vt[bt + 1] * Pt,
            St[At + 2] = vt[bt + 2] * Pt,
            St[At + 3] = 1
        }
          , b = function(vt, bt, St, At) {
            const Et = vt[bt + 3]
              , Pt = Math.pow(2, Et - 128) / 255;
            St[At + 0] = three_module.GxU.toHalfFloat(Math.min(vt[bt + 0] * Pt, 65504)),
            St[At + 1] = three_module.GxU.toHalfFloat(Math.min(vt[bt + 1] * Pt, 65504)),
            St[At + 2] = three_module.GxU.toHalfFloat(Math.min(vt[bt + 2] * Pt, 65504)),
            St[At + 3] = three_module.GxU.toHalfFloat(1)
        }
          , _e = new Uint8Array(o);
        _e.pos = 0;
        const nt = function(vt) {
            const bt = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , St = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , At = /^\s*FORMAT=(\S+)\s*$/
              , Et = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , Pt = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let It, Dt;
            for ((vt.pos >= vt.byteLength || !(It = h(vt))) && c(1, "no header found"),
            (Dt = It.match(/^#\?(\S+)/)) || c(3, "bad initial token"),
            Pt.valid |= 1,
            Pt.programtype = Dt[1],
            Pt.string += It + `
`; It = h(vt),
            It !== !1; )
                if (Pt.string += It + `
`,
                It.charAt(0) !== "#") {
                    if ((Dt = It.match(bt)) && (Pt.gamma = parseFloat(Dt[1])),
                    (Dt = It.match(St)) && (Pt.exposure = parseFloat(Dt[1])),
                    (Dt = It.match(At)) && (Pt.valid |= 2,
                    Pt.format = Dt[1]),
                    (Dt = It.match(Et)) && (Pt.valid |= 4,
                    Pt.height = parseInt(Dt[1], 10),
                    Pt.width = parseInt(Dt[2], 10)),
                    2 & Pt.valid && 4 & Pt.valid)
                        break
                } else
                    Pt.comments += It + `
`;
            return 2 & Pt.valid || c(3, "missing format specifier"),
            4 & Pt.valid || c(3, "missing image size specifier"),
            Pt
        }(_e)
          , it = nt.width
          , at = nt.height
          , ut = function(vt, bt, St) {
            const At = bt;
            if (At < 8 || At > 32767 || vt[0] !== 2 || vt[1] !== 2 || 128 & vt[2])
                return new Uint8Array(vt);
            At !== (vt[2] << 8 | vt[3]) && c(3, "wrong scanline width");
            const Et = new Uint8Array(4 * bt * St);
            Et.length || c(4, "unable to allocate buffer space");
            let Pt = 0
              , It = 0;
            const Dt = 4 * At
              , Gt = new Uint8Array(4)
              , Bt = new Uint8Array(Dt);
            let kt = St;
            for (; kt > 0 && It < vt.byteLength; ) {
                It + 4 > vt.byteLength && c(1),
                Gt[0] = vt[It++],
                Gt[1] = vt[It++],
                Gt[2] = vt[It++],
                Gt[3] = vt[It++],
                Gt[0] == 2 && Gt[1] == 2 && (Gt[2] << 8 | Gt[3]) == At || c(3, "bad rgbe scanline format");
                let Ut, Ht = 0;
                for (; Ht < Dt && It < vt.byteLength; ) {
                    Ut = vt[It++];
                    const Jt = Ut > 128;
                    if (Jt && (Ut -= 128),
                    (Ut === 0 || Ht + Ut > Dt) && c(3, "bad scanline data"),
                    Jt) {
                        const or = vt[It++];
                        for (let ir = 0; ir < Ut; ir++)
                            Bt[Ht++] = or
                    } else
                        Bt.set(vt.subarray(It, It + Ut), Ht),
                        Ht += Ut,
                        It += Ut
                }
                const Kt = At;
                for (let Jt = 0; Jt < Kt; Jt++) {
                    let or = 0;
                    Et[Pt] = Bt[Jt + or],
                    or += At,
                    Et[Pt + 1] = Bt[Jt + or],
                    or += At,
                    Et[Pt + 2] = Bt[Jt + or],
                    or += At,
                    Et[Pt + 3] = Bt[Jt + or],
                    Pt += 4
                }
                kt--
            }
            return Et
        }(_e.subarray(_e.pos), it, at);
        let pt, ht, _t;
        switch (this.type) {
        case three_module.RQf:
            _t = ut.length / 4;
            const vt = new Float32Array(4 * _t);
            for (let St = 0; St < _t; St++)
                _(ut, 4 * St, vt, 4 * St);
            pt = vt,
            ht = three_module.RQf;
            break;
        case three_module.ix0:
            _t = ut.length / 4;
            const bt = new Uint16Array(4 * _t);
            for (let St = 0; St < _t; St++)
                b(ut, 4 * St, bt, 4 * St);
            pt = bt,
            ht = three_module.ix0;
            break;
        default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: it,
            height: at,
            data: pt,
            header: nt.string,
            gamma: nt.gamma,
            exposure: nt.exposure,
            type: ht
        }
    }
    setDataType(o) {
        return this.type = o,
        this
    }
    load(o, c, h, _) {
        return super.load(o, function(b, _e) {
            switch (b.type) {
            case three_module.RQf:
            case three_module.ix0:
                b.colorSpace = three_module.Zr2,
                b.minFilter = three_module.k6q,
                b.magFilter = three_module.k6q,
                b.generateMipmaps = !1,
                b.flipY = !0
            }
            c && c(b, _e)
        }, h, _)
    }
}
function addRGBELoader(d) {
    return new Importer(class extends RGBELoader {
        constructor(o) {
            super(o),
            this.setDataType(getTextureDataType(d.renderer.rendererObject))
        }
    }
    ,["hdr"],!1)
}
class GLTFLoader extends three_module.aHM {
    constructor(o) {
        super(o),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(c) {
            return new GLTFMaterialsClearcoatExtension(c)
        }),
        this.register(function(c) {
            return new GLTFTextureBasisUExtension(c)
        }),
        this.register(function(c) {
            return new GLTFTextureWebPExtension(c)
        }),
        this.register(function(c) {
            return new GLTFTextureAVIFExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsSheenExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsTransmissionExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsVolumeExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsIorExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsEmissiveStrengthExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsSpecularExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsIridescenceExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMaterialsAnisotropyExtension(c)
        }),
        this.register(function(c) {
            return new GLTFLightsExtension(c)
        }),
        this.register(function(c) {
            return new GLTFMeshoptCompression(c)
        }),
        this.register(function(c) {
            return new GLTFMeshGpuInstancing(c)
        })
    }
    load(o, c, h, _) {
        const b = this;
        let _e;
        _e = this.resourcePath !== "" ? this.resourcePath : this.path !== "" ? this.path : three_module.r6x.extractUrlBase(o),
        this.manager.itemStart(o);
        const nt = function(at) {
            _ ? _(at) : console.error(at),
            b.manager.itemError(o),
            b.manager.itemEnd(o)
        }
          , it = new three_module.Y9S(this.manager);
        it.setPath(this.path),
        it.setResponseType("arraybuffer"),
        it.setRequestHeader(this.requestHeader),
        it.setWithCredentials(this.withCredentials),
        it.load(o, function(at) {
            try {
                b.parse(at, _e, function(ut) {
                    c(ut),
                    b.manager.itemEnd(o)
                }, nt, o)
            } catch (ut) {
                nt(ut)
            }
        }, h, nt)
    }
    setDRACOLoader(o) {
        return this.dracoLoader = o,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(o) {
        return this.ktx2Loader = o,
        this
    }
    setMeshoptDecoder(o) {
        return this.meshoptDecoder = o,
        this
    }
    register(o) {
        return this.pluginCallbacks.indexOf(o) === -1 && this.pluginCallbacks.push(o),
        this
    }
    unregister(o) {
        return this.pluginCallbacks.indexOf(o) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(o), 1),
        this
    }
    parse(o, c, h, _, b) {
        let _e;
        const nt = {}
          , it = {}
          , at = new TextDecoder;
        if (typeof o == "string")
            _e = JSON.parse(o);
        else if (o instanceof ArrayBuffer)
            if (at.decode(new Uint8Array(o,0,4)) === BINARY_EXTENSION_HEADER_MAGIC) {
                try {
                    nt[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(o)
                } catch (pt) {
                    return void (_ && _(pt))
                }
                _e = JSON.parse(nt[EXTENSIONS.KHR_BINARY_GLTF].content)
            } else
                _e = JSON.parse(at.decode(o));
        else
            _e = o;
        if (_e.asset === void 0 || _e.asset.version[0] < 2)
            return void (_ && _(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const ut = new GLTFParser(_e,{
            path: c || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        ut.fileLoader.setRequestHeader(this.requestHeader);
        for (let pt = 0; pt < this.pluginCallbacks.length; pt++) {
            const ht = this.pluginCallbacks[pt](ut);
            it[ht.name] = ht,
            nt[ht.name] = !0
        }
        if (_e.extensionsUsed)
            for (let pt = 0; pt < _e.extensionsUsed.length; ++pt) {
                const ht = _e.extensionsUsed[pt]
                  , _t = _e.extensionsRequired || [];
                switch (ht) {
                case EXTENSIONS.KHR_MATERIALS_UNLIT:
                    nt[ht] = new GLTFMaterialsUnlitExtension;
                    break;
                case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                    nt[ht] = new GLTFDracoMeshCompressionExtension(_e,this.dracoLoader);
                    break;
                case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                    nt[ht] = new GLTFTextureTransformExtension;
                    break;
                case EXTENSIONS.KHR_MESH_QUANTIZATION:
                    nt[ht] = new GLTFMeshQuantizationExtension;
                    break;
                default:
                    _t.indexOf(ht) >= 0 && it[ht] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + ht + '".')
                }
            }
        ut.setExtensions(nt),
        ut.setPlugins(it),
        ut.parse(h, _)
    }
    parseAsync(o, c) {
        const h = this;
        return new Promise(function(_, b) {
            h.parse(o, c, _, b)
        }
        )
    }
}
function GLTFRegistry() {
    let d = {};
    return {
        get: function(o) {
            return d[o]
        },
        add: function(o, c) {
            d[o] = c
        },
        remove: function(o) {
            delete d[o]
        },
        removeAll: function() {
            d = {}
        }
    }
}
GLTFLoader.ObjectConstructors = {
    DirectionalLight: three_module.ZyN,
    PointLight: three_module.HiM,
    SpotLight: three_module.nCl,
    MeshStandardMaterial: three_module._4j,
    MeshBasicMaterial: three_module.V9B,
    MeshPhysicalMaterial: three_module.uSd,
    LineBasicMaterial: three_module.mrM,
    PointsMaterial: three_module.BH$,
    PerspectiveCamera: three_module.ubm,
    OrthographicCamera: three_module.qUd
};
const EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class GLTFLightsExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const o = this.parser
          , c = this.parser.json.nodes || [];
        for (let h = 0, _ = c.length; h < _; h++) {
            const b = c[h];
            b.extensions && b.extensions[this.name] && b.extensions[this.name].light !== void 0 && o._addNodeRef(this.cache, b.extensions[this.name].light)
        }
    }
    _loadLight(o) {
        const c = this.parser
          , h = "light:" + o;
        let _ = c.cache.get(h);
        if (_)
            return _;
        const b = c.json
          , _e = ((b.extensions && b.extensions[this.name] || {}).lights || [])[o];
        let nt;
        const it = new three_module.Q1f(16777215);
        _e.color !== void 0 && it.setRGB(_e.color[0], _e.color[1], _e.color[2], three_module.Zr2);
        const at = _e.range !== void 0 ? _e.range : 0;
        switch (_e.type) {
        case "directional":
            nt = new GLTFLoader.ObjectConstructors.DirectionalLight(it),
            nt.target.position.set(0, 0, -1),
            nt.add(nt.target);
            break;
        case "point":
            nt = new GLTFLoader.ObjectConstructors.PointLight(it),
            nt.distance = at;
            break;
        case "spot":
            nt = new GLTFLoader.ObjectConstructors.SpotLight(it),
            nt.distance = at,
            _e.spot = _e.spot || {},
            _e.spot.innerConeAngle = _e.spot.innerConeAngle !== void 0 ? _e.spot.innerConeAngle : 0,
            _e.spot.outerConeAngle = _e.spot.outerConeAngle !== void 0 ? _e.spot.outerConeAngle : Math.PI / 4,
            nt.angle = _e.spot.outerConeAngle,
            nt.penumbra = 1 - _e.spot.innerConeAngle / _e.spot.outerConeAngle,
            nt.target.position.set(0, 0, -1),
            nt.add(nt.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + _e.type)
        }
        return nt.position.set(0, 0, 0),
        nt.decay = 2,
        assignExtrasToUserData(nt, _e),
        _e.intensity !== void 0 && (nt.intensity = _e.intensity),
        nt.name = c.createUniqueName(_e.name || "light_" + o),
        _ = Promise.resolve(nt),
        c.cache.add(h, _),
        _
    }
    getDependency(o, c) {
        if (o === "light")
            return this._loadLight(c)
    }
    createNodeAttachment(o) {
        const c = this
          , h = this.parser
          , _ = h.json.nodes[o]
          , b = (_.extensions && _.extensions[this.name] || {}).light;
        return b === void 0 ? null : this._loadLight(b).then(function(_e) {
            return h._getNodeRef(c.cache, b, _e)
        })
    }
}
class GLTFMaterialsUnlitExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return GLTFLoader.ObjectConstructors.MeshBasicMaterial
    }
    extendParams(o, c, h) {
        const _ = [];
        o.color = new three_module.Q1f(1,1,1),
        o.opacity = 1;
        const b = c.pbrMetallicRoughness;
        if (b) {
            if (Array.isArray(b.baseColorFactor)) {
                const _e = b.baseColorFactor;
                o.color.setRGB(_e[0], _e[1], _e[2], three_module.Zr2),
                o.opacity = _e[3]
            }
            b.baseColorTexture !== void 0 && _.push(h.assignTexture(o, "map", b.baseColorTexture, three_module.er$))
        }
        return Promise.all(_)
    }
}
class GLTFMaterialsEmissiveStrengthExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name].emissiveStrength;
        return _ !== void 0 && (c.emissiveIntensity = _),
        Promise.resolve()
    }
}
class GLTFMaterialsClearcoatExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        if (_e.clearcoatFactor !== void 0 && (c.clearcoat = _e.clearcoatFactor),
        _e.clearcoatTexture !== void 0 && b.push(h.assignTexture(c, "clearcoatMap", _e.clearcoatTexture)),
        _e.clearcoatRoughnessFactor !== void 0 && (c.clearcoatRoughness = _e.clearcoatRoughnessFactor),
        _e.clearcoatRoughnessTexture !== void 0 && b.push(h.assignTexture(c, "clearcoatRoughnessMap", _e.clearcoatRoughnessTexture)),
        _e.clearcoatNormalTexture !== void 0 && (b.push(h.assignTexture(c, "clearcoatNormalMap", _e.clearcoatNormalTexture)),
        _e.clearcoatNormalTexture.scale !== void 0)) {
            const nt = _e.clearcoatNormalTexture.scale;
            c.clearcoatNormalScale = new three_module.I9Y(nt,nt)
        }
        return Promise.all(b)
    }
}
class GLTFMaterialsIridescenceExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.iridescenceFactor !== void 0 && (c.iridescence = _e.iridescenceFactor),
        _e.iridescenceTexture !== void 0 && b.push(h.assignTexture(c, "iridescenceMap", _e.iridescenceTexture)),
        _e.iridescenceIor !== void 0 && (c.iridescenceIOR = _e.iridescenceIor),
        c.iridescenceThicknessRange === void 0 && (c.iridescenceThicknessRange = [100, 400]),
        _e.iridescenceThicknessMinimum !== void 0 && (c.iridescenceThicknessRange[0] = _e.iridescenceThicknessMinimum),
        _e.iridescenceThicknessMaximum !== void 0 && (c.iridescenceThicknessRange[1] = _e.iridescenceThicknessMaximum),
        _e.iridescenceThicknessTexture !== void 0 && b.push(h.assignTexture(c, "iridescenceThicknessMap", _e.iridescenceThicknessTexture)),
        Promise.all(b)
    }
}
class GLTFMaterialsSheenExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = [];
        c.sheenColor = new three_module.Q1f(0,0,0),
        c.sheenRoughness = 0,
        c.sheen = 1;
        const _e = _.extensions[this.name];
        if (_e.sheenColorFactor !== void 0) {
            const nt = _e.sheenColorFactor;
            c.sheenColor.setRGB(nt[0], nt[1], nt[2], three_module.Zr2)
        }
        return _e.sheenRoughnessFactor !== void 0 && (c.sheenRoughness = _e.sheenRoughnessFactor),
        _e.sheenColorTexture !== void 0 && b.push(h.assignTexture(c, "sheenColorMap", _e.sheenColorTexture, three_module.er$)),
        _e.sheenRoughnessTexture !== void 0 && b.push(h.assignTexture(c, "sheenRoughnessMap", _e.sheenRoughnessTexture)),
        _.extras && _.extras.sheenFactor !== void 0 && (c.sheen = _.extras.sheenFactor,
        delete _.extras.sheenFactor),
        Promise.all(b)
    }
}
class GLTFMaterialsTransmissionExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.transmissionFactor !== void 0 && (c.transmission = _e.transmissionFactor),
        _e.transmissionTexture !== void 0 && b.push(h.assignTexture(c, "transmissionMap", _e.transmissionTexture)),
        Promise.all(b)
    }
}
class GLTFMaterialsVolumeExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        c.thickness = _e.thicknessFactor !== void 0 ? _e.thicknessFactor : 0,
        _e.thicknessTexture !== void 0 && b.push(h.assignTexture(c, "thicknessMap", _e.thicknessTexture)),
        c.attenuationDistance = _e.attenuationDistance || 1 / 0;
        const nt = _e.attenuationColor || [1, 1, 1];
        return c.attenuationColor = new three_module.Q1f().setRGB(nt[0], nt[1], nt[2], three_module.Zr2),
        Promise.all(b)
    }
}
class GLTFMaterialsIorExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_IOR
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        return c.ior = _.ior !== void 0 ? _.ior : 1.5,
        Promise.resolve()
    }
}
class GLTFMaterialsSpecularExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? GLTFLoader.ObjectConstructors.MeshPhysicalMaterial : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        c.specularIntensity = _e.specularFactor !== void 0 ? _e.specularFactor : 1,
        _e.specularTexture !== void 0 && b.push(h.assignTexture(c, "specularIntensityMap", _e.specularTexture));
        const nt = _e.specularColorFactor || [1, 1, 1];
        return c.specularColor = new three_module.Q1f().setRGB(nt[0], nt[1], nt[2], three_module.Zr2),
        _e.specularColorTexture !== void 0 && b.push(h.assignTexture(c, "specularColorMap", _e.specularColorTexture, three_module.er$)),
        Promise.all(b)
    }
}
class GLTFMaterialsAnisotropyExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(o) {
        const c = this.parser.json.materials[o];
        return c.extensions && c.extensions[this.name] ? three_module.uSd : null
    }
    extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.anisotropyStrength !== void 0 && (c.anisotropy = _e.anisotropyStrength),
        _e.anisotropyRotation !== void 0 && (c.anisotropyRotation = _e.anisotropyRotation),
        _e.anisotropyTexture !== void 0 && b.push(h.assignTexture(c, "anisotropyMap", _e.anisotropyTexture)),
        Promise.all(b)
    }
}
class GLTFTextureBasisUExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.KHR_TEXTURE_BASISU
    }
    loadTexture(o) {
        const c = this.parser
          , h = c.json
          , _ = h.textures[o];
        if (!_.extensions || !_.extensions[this.name])
            return null;
        const b = _.extensions[this.name]
          , _e = c.options.ktx2Loader;
        if (!_e) {
            if (h.extensionsRequired && h.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return c.loadTextureImage(o, b.source, _e)
    }
}
class GLTFTextureWebPExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(o) {
        const c = this.name
          , h = this.parser
          , _ = h.json
          , b = _.textures[o];
        if (!b.extensions || !b.extensions[c])
            return null;
        const _e = b.extensions[c]
          , nt = _.images[_e.source];
        let it = h.textureLoader;
        if (nt.uri) {
            const at = h.options.manager.getHandler(nt.uri);
            at !== null && (it = at)
        }
        return this.detectSupport().then(function(at) {
            if (at)
                return h.loadTextureImage(o, _e.source, it);
            if (_.extensionsRequired && _.extensionsRequired.indexOf(c) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return h.loadTexture(o)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(o) {
            const c = new Image;
            c.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            c.onload = c.onerror = function() {
                o(c.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class GLTFTextureAVIFExtension {
    constructor(o) {
        this.parser = o,
        this.name = EXTENSIONS.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(o) {
        const c = this.name
          , h = this.parser
          , _ = h.json
          , b = _.textures[o];
        if (!b.extensions || !b.extensions[c])
            return null;
        const _e = b.extensions[c]
          , nt = _.images[_e.source];
        let it = h.textureLoader;
        if (nt.uri) {
            const at = h.options.manager.getHandler(nt.uri);
            at !== null && (it = at)
        }
        return this.detectSupport().then(function(at) {
            if (at)
                return h.loadTextureImage(o, _e.source, it);
            if (_.extensionsRequired && _.extensionsRequired.indexOf(c) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return h.loadTexture(o)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(o) {
            const c = new Image;
            c.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            c.onload = c.onerror = function() {
                o(c.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class GLTFMeshoptCompression {
    constructor(o) {
        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION,
        this.parser = o
    }
    loadBufferView(o) {
        const c = this.parser.json
          , h = c.bufferViews[o];
        if (h.extensions && h.extensions[this.name]) {
            const _ = h.extensions[this.name]
              , b = this.parser.getDependency("buffer", _.buffer)
              , _e = this.parser.options.meshoptDecoder;
            if (!_e || !_e.supported) {
                if (c.extensionsRequired && c.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return b.then(function(nt) {
                const it = _.byteOffset || 0
                  , at = _.byteLength || 0
                  , ut = _.count
                  , pt = _.byteStride
                  , ht = new Uint8Array(nt,it,at);
                return _e.decodeGltfBufferAsync ? _e.decodeGltfBufferAsync(ut, pt, ht, _.mode, _.filter).then(function(_t) {
                    return _t.buffer
                }) : _e.ready.then(function() {
                    const _t = new ArrayBuffer(ut * pt);
                    return _e.decodeGltfBuffer(new Uint8Array(_t), ut, pt, ht, _.mode, _.filter),
                    _t
                })
            })
        }
        return null
    }
}
class GLTFMeshGpuInstancing {
    constructor(o) {
        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING,
        this.parser = o
    }
    createNodeMesh(o) {
        const c = this.parser.json
          , h = c.nodes[o];
        if (!h.extensions || !h.extensions[this.name] || h.mesh === void 0)
            return null;
        const _ = c.meshes[h.mesh];
        for (const it of _.primitives)
            if (it.mode !== WEBGL_CONSTANTS.TRIANGLES && it.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && it.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && it.mode !== void 0)
                return null;
        const b = h.extensions[this.name].attributes
          , _e = []
          , nt = {};
        for (const it in b)
            _e.push(this.parser.getDependency("accessor", b[it]).then(at => (nt[it] = at,
            nt[it])));
        return _e.length < 1 ? null : (_e.push(this.parser.createNodeMesh(o)),
        Promise.all(_e).then(it => {
            const at = it.pop()
              , ut = at.isGroup ? at.children : [at]
              , pt = it[0].count
              , ht = [];
            for (const _t of ut) {
                const vt = new three_module.kn4
                  , bt = new three_module.Pq0
                  , St = new three_module.PTz
                  , At = new three_module.Pq0(1,1,1)
                  , Et = new three_module.ZLX(_t.geometry,_t.material,pt);
                for (let Pt = 0; Pt < pt; Pt++)
                    nt.TRANSLATION && bt.fromBufferAttribute(nt.TRANSLATION, Pt),
                    nt.ROTATION && St.fromBufferAttribute(nt.ROTATION, Pt),
                    nt.SCALE && At.fromBufferAttribute(nt.SCALE, Pt),
                    Et.setMatrixAt(Pt, vt.compose(bt, St, At));
                Et.sourceTrs = nt;
                for (const Pt in nt)
                    Pt !== "TRANSLATION" && Pt !== "ROTATION" && Pt !== "SCALE" && _t.geometry.setAttribute(Pt, nt[Pt]);
                three_module.B69.prototype.copy.call(Et, _t),
                this.parser.assignFinalMaterial(Et),
                ht.push(Et)
            }
            return at.isGroup ? (at.clear(),
            at.add(...ht),
            at) : ht[0]
        }
        ))
    }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF"
  , BINARY_EXTENSION_HEADER_LENGTH = 12
  , BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 1313821514,
    BIN: 5130562
};
class GLTFBinaryExtension {
    constructor(o) {
        this.name = EXTENSIONS.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const c = new DataView(o,0,BINARY_EXTENSION_HEADER_LENGTH)
          , h = new TextDecoder;
        if (this.header = {
            magic: h.decode(new Uint8Array(o.slice(0, 4))),
            version: c.getUint32(4, !0),
            length: c.getUint32(8, !0)
        },
        this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const _ = this.header.length - BINARY_EXTENSION_HEADER_LENGTH
          , b = new DataView(o,BINARY_EXTENSION_HEADER_LENGTH);
        let _e = 0;
        for (; _e < _; ) {
            const nt = b.getUint32(_e, !0);
            _e += 4;
            const it = b.getUint32(_e, !0);
            if (_e += 4,
            it === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                const at = new Uint8Array(o,BINARY_EXTENSION_HEADER_LENGTH + _e,nt);
                this.content = h.decode(at)
            } else if (it === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                const at = BINARY_EXTENSION_HEADER_LENGTH + _e;
                this.body = o.slice(at, at + nt)
            }
            _e += nt
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class GLTFDracoMeshCompressionExtension {
    constructor(o, c) {
        if (!c)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,
        this.json = o,
        this.dracoLoader = c,
        this.dracoLoader.preload()
    }
    decodePrimitive(o, c) {
        const h = this.json
          , _ = this.dracoLoader
          , b = o.extensions[this.name].bufferView
          , _e = o.extensions[this.name].attributes
          , nt = {}
          , it = {}
          , at = {};
        for (const ut in _e) {
            const pt = ATTRIBUTES[ut] || ut.toLowerCase();
            nt[pt] = _e[ut]
        }
        for (const ut in o.attributes) {
            const pt = ATTRIBUTES[ut] || ut.toLowerCase();
            if (_e[ut] !== void 0) {
                const ht = h.accessors[o.attributes[ut]]
                  , _t = WEBGL_COMPONENT_TYPES[ht.componentType];
                at[pt] = _t.name,
                it[pt] = ht.normalized === !0
            }
        }
        return c.getDependency("bufferView", b).then(function(ut) {
            return new Promise(function(pt) {
                _.decodeDracoFile(ut, function(ht) {
                    for (const _t in ht.attributes) {
                        const vt = ht.attributes[_t]
                          , bt = it[_t];
                        bt !== void 0 && (vt.normalized = bt)
                    }
                    pt(ht)
                }, nt, at)
            }
            )
        })
    }
}
class GLTFTextureTransformExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(o, c) {
        return (c.texCoord !== void 0 && c.texCoord !== o.channel || c.offset !== void 0 || c.rotation !== void 0 || c.scale !== void 0) && (o.__hasGLTFUuid || (o = o.clone()),
        c.texCoord !== void 0 && (o.channel = c.texCoord),
        c.offset !== void 0 && o.offset.fromArray(c.offset),
        c.rotation !== void 0 && (o.rotation = c.rotation),
        c.scale !== void 0 && o.repeat.fromArray(c.scale),
        o.needsUpdate = !0),
        o
    }
}
class GLTFMeshQuantizationExtension {
    constructor() {
        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
    }
}
class GLTFCubicSplineInterpolant extends three_module.lGw {
    constructor(o, c, h, _) {
        super(o, c, h, _)
    }
    copySampleValue_(o) {
        const c = this.resultBuffer
          , h = this.sampleValues
          , _ = this.valueSize
          , b = o * _ * 3 + _;
        for (let _e = 0; _e !== _; _e++)
            c[_e] = h[b + _e];
        return c
    }
    interpolate_(o, c, h, _) {
        const b = this.resultBuffer
          , _e = this.sampleValues
          , nt = this.valueSize
          , it = 2 * nt
          , at = 3 * nt
          , ut = _ - c
          , pt = (h - c) / ut
          , ht = pt * pt
          , _t = ht * pt
          , vt = o * at
          , bt = vt - at
          , St = -2 * _t + 3 * ht
          , At = _t - ht
          , Et = 1 - St
          , Pt = At - ht + pt;
        for (let It = 0; It !== nt; It++) {
            const Dt = _e[bt + It + nt]
              , Gt = _e[bt + It + it] * ut
              , Bt = _e[vt + It + nt]
              , kt = _e[vt + It] * ut;
            b[It] = Et * Dt + Pt * Gt + St * Bt + At * kt
        }
        return b
    }
}
const _q = new three_module.PTz;
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
    interpolate_(o, c, h, _) {
        const b = super.interpolate_(o, c, h, _);
        return _q.fromArray(b).normalize().toArray(b),
        b
    }
}
const WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , WEBGL_FILTERS = {
    9728: three_module.hxR,
    9729: three_module.k6q,
    9984: three_module.pHI,
    9985: three_module.kRr,
    9986: three_module.Cfg,
    9987: three_module.$_I
}
  , WEBGL_WRAPPINGS = {
    33071: three_module.ghU,
    33648: three_module.kTW,
    10497: three_module.GJx
}
  , WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: three_module.PJ3,
    STEP: three_module.ljd
}
  , ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function createDefaultMaterial(d) {
    return d.DefaultMaterial === void 0 && (d.DefaultMaterial = new GLTFLoader.ObjectConstructors.MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: three_module.hB5
    })),
    d.DefaultMaterial
}
function addUnknownExtensionsToUserData(d, o, c) {
    for (const h in c.extensions)
        d[h] === void 0 && (o.userData.gltfExtensions = o.userData.gltfExtensions || {},
        o.userData.gltfExtensions[h] = c.extensions[h])
}
function assignExtrasToUserData(d, o) {
    o.extras !== void 0 && (typeof o.extras == "object" ? Object.assign(d.userData, o.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + o.extras))
}
function addMorphTargets(d, o, c) {
    let h = !1
      , _ = !1
      , b = !1;
    for (let at = 0, ut = o.length; at < ut; at++) {
        const pt = o[at];
        if (pt.POSITION !== void 0 && (h = !0),
        pt.NORMAL !== void 0 && (_ = !0),
        pt.COLOR_0 !== void 0 && (b = !0),
        h && _ && b)
            break
    }
    if (!h && !_ && !b)
        return Promise.resolve(d);
    const _e = []
      , nt = []
      , it = [];
    for (let at = 0, ut = o.length; at < ut; at++) {
        const pt = o[at];
        if (h) {
            const ht = pt.POSITION !== void 0 ? c.getDependency("accessor", pt.POSITION) : d.attributes.position;
            _e.push(ht)
        }
        if (_) {
            const ht = pt.NORMAL !== void 0 ? c.getDependency("accessor", pt.NORMAL) : d.attributes.normal;
            nt.push(ht)
        }
        if (b) {
            const ht = pt.COLOR_0 !== void 0 ? c.getDependency("accessor", pt.COLOR_0) : d.attributes.color;
            it.push(ht)
        }
    }
    return Promise.all([Promise.all(_e), Promise.all(nt), Promise.all(it)]).then(function(at) {
        const ut = at[0]
          , pt = at[1]
          , ht = at[2];
        return h && (d.morphAttributes.position = ut),
        _ && (d.morphAttributes.normal = pt),
        b && (d.morphAttributes.color = ht),
        d.morphTargetsRelative = !0,
        d
    })
}
function updateMorphTargets(d, o) {
    if (d.updateMorphTargets(),
    o.weights !== void 0)
        for (let c = 0, h = o.weights.length; c < h; c++)
            d.morphTargetInfluences[c] = o.weights[c];
    if (o.extras && Array.isArray(o.extras.targetNames)) {
        const c = o.extras.targetNames;
        if (d.morphTargetInfluences.length === c.length) {
            d.morphTargetDictionary = {};
            for (let h = 0, _ = c.length; h < _; h++)
                d.morphTargetDictionary[c[h]] = h
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function createPrimitiveKey(d) {
    let o;
    const c = d.extensions && d.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    if (o = c ? "draco:" + c.bufferView + ":" + c.indices + ":" + createAttributesKey(c.attributes) : d.indices + ":" + createAttributesKey(d.attributes) + ":" + d.mode,
    d.targets !== void 0)
        for (let h = 0, _ = d.targets.length; h < _; h++)
            o += ":" + createAttributesKey(d.targets[h]);
    return o
}
function createAttributesKey(d) {
    let o = "";
    const c = Object.keys(d).sort();
    for (let h = 0, _ = c.length; h < _; h++)
        o += c[h] + ":" + d[c[h]] + ";";
    return o
}
function getNormalizedComponentScale(d) {
    switch (d) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function getImageURIMimeType(d) {
    return d.search(/\.jpe?g($|\?)/i) > 0 || d.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : d.search(/\.webp($|\?)/i) > 0 || d.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const _identityMatrix = new three_module.kn4;
class GLTFParser {
    constructor(o={}, c={}) {
        this.json = o,
        this.extensions = {},
        this.plugins = {},
        this.options = c,
        this.cache = new GLTFRegistry,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let h = !1
          , _ = !1
          , b = -1;
        typeof navigator < "u" && (h = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
        _ = navigator.userAgent.indexOf("Firefox") > -1,
        b = _ ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1),
        typeof createImageBitmap > "u" || h || _ && b < 98 ? this.textureLoader = new three_module.Tap(this.options.manager) : this.textureLoader = new three_module.Kzg(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new three_module.Y9S(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(o) {
        this.extensions = o
    }
    setPlugins(o) {
        this.plugins = o
    }
    parse(o, c) {
        const h = this
          , _ = this.json
          , b = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(_e) {
            return _e._markDefs && _e._markDefs()
        }),
        Promise.all(this._invokeAll(function(_e) {
            return _e.beforeRoot && _e.beforeRoot()
        })).then(function() {
            return Promise.all([h.getDependencies("scene"), h.getDependencies("animation"), h.getDependencies("camera")])
        }).then(function(_e) {
            const nt = {
                scene: _e[0][_.scene || 0],
                scenes: _e[0],
                animations: _e[1],
                cameras: _e[2],
                asset: _.asset,
                parser: h,
                userData: {}
            };
            return addUnknownExtensionsToUserData(b, nt, _),
            assignExtrasToUserData(nt, _),
            Promise.all(h._invokeAll(function(it) {
                return it.afterRoot && it.afterRoot(nt)
            })).then(function() {
                o(nt)
            })
        }).catch(c)
    }
    _markDefs() {
        const o = this.json.nodes || []
          , c = this.json.skins || []
          , h = this.json.meshes || [];
        for (let _ = 0, b = c.length; _ < b; _++) {
            const _e = c[_].joints;
            for (let nt = 0, it = _e.length; nt < it; nt++)
                o[_e[nt]].isBone = !0
        }
        for (let _ = 0, b = o.length; _ < b; _++) {
            const _e = o[_];
            _e.mesh !== void 0 && (this._addNodeRef(this.meshCache, _e.mesh),
            _e.skin !== void 0 && (h[_e.mesh].isSkinnedMesh = !0)),
            _e.camera !== void 0 && this._addNodeRef(this.cameraCache, _e.camera)
        }
    }
    _addNodeRef(o, c) {
        c !== void 0 && (o.refs[c] === void 0 && (o.refs[c] = o.uses[c] = 0),
        o.refs[c]++)
    }
    _getNodeRef(o, c, h) {
        if (o.refs[c] <= 1)
            return h;
        const _ = h.clone()
          , b = (_e, nt) => {
            const it = this.associations.get(_e);
            it != null && this.associations.set(nt, it);
            for (const [at,ut] of _e.children.entries())
                b(ut, nt.children[at])
        }
        ;
        return b(h, _),
        _.name += "_instance_" + o.uses[c]++,
        _
    }
    _invokeOne(o) {
        const c = Object.values(this.plugins);
        c.push(this);
        for (let h = 0; h < c.length; h++) {
            const _ = o(c[h]);
            if (_)
                return _
        }
        return null
    }
    _invokeAll(o) {
        const c = Object.values(this.plugins);
        c.unshift(this);
        const h = [];
        for (let _ = 0; _ < c.length; _++) {
            const b = o(c[_]);
            b && h.push(b)
        }
        return h
    }
    getDependency(o, c) {
        const h = o + ":" + c;
        let _ = this.cache.get(h);
        if (!_) {
            switch (o) {
            case "scene":
                _ = this.loadScene(c);
                break;
            case "node":
                _ = this._invokeOne(function(b) {
                    return b.loadNode && b.loadNode(c)
                });
                break;
            case "mesh":
                _ = this._invokeOne(function(b) {
                    return b.loadMesh && b.loadMesh(c)
                });
                break;
            case "accessor":
                _ = this.loadAccessor(c);
                break;
            case "bufferView":
                _ = this._invokeOne(function(b) {
                    return b.loadBufferView && b.loadBufferView(c)
                });
                break;
            case "buffer":
                _ = this.loadBuffer(c);
                break;
            case "material":
                _ = this._invokeOne(function(b) {
                    return b.loadMaterial && b.loadMaterial(c)
                });
                break;
            case "texture":
                _ = this._invokeOne(function(b) {
                    return b.loadTexture && b.loadTexture(c)
                });
                break;
            case "skin":
                _ = this.loadSkin(c);
                break;
            case "animation":
                _ = this._invokeOne(function(b) {
                    return b.loadAnimation && b.loadAnimation(c)
                });
                break;
            case "camera":
                _ = this.loadCamera(c);
                break;
            default:
                if (_ = this._invokeOne(function(b) {
                    return b != this && b.getDependency && b.getDependency(o, c)
                }),
                !_)
                    throw new Error("Unknown type: " + o)
            }
            this.cache.add(h, _)
        }
        return _
    }
    getDependencies(o) {
        let c = this.cache.get(o);
        if (!c) {
            const h = this
              , _ = this.json[o + (o === "mesh" ? "es" : "s")] || [];
            c = Promise.all(_.map(function(b, _e) {
                return h.getDependency(o, _e)
            })),
            this.cache.add(o, c)
        }
        return c
    }
    loadBuffer(o) {
        const c = this.json.buffers[o]
          , h = this.fileLoader;
        if (c.type && c.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + c.type + " buffer type is not supported.");
        if (c.uri === void 0 && o === 0)
            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
        const _ = this.options;
        return new Promise(function(b, _e) {
            h.load(three_module.r6x.resolveURL(c.uri, _.path), b, void 0, function() {
                _e(new Error('THREE.GLTFLoader: Failed to load buffer "' + c.uri + '".'))
            })
        }
        )
    }
    loadBufferView(o) {
        const c = this.json.bufferViews[o];
        return this.getDependency("buffer", c.buffer).then(function(h) {
            const _ = c.byteLength || 0
              , b = c.byteOffset || 0;
            return h.slice(b, b + _)
        })
    }
    loadAccessor(o) {
        const c = this
          , h = this.json
          , _ = this.json.accessors[o];
        if (_.bufferView === void 0 && _.sparse === void 0) {
            const _e = WEBGL_TYPE_SIZES[_.type]
              , nt = WEBGL_COMPONENT_TYPES[_.componentType]
              , it = _.normalized === !0
              , at = new nt(_.count * _e);
            return Promise.resolve(new three_module.THS(at,_e,it))
        }
        const b = [];
        return _.bufferView !== void 0 ? b.push(this.getDependency("bufferView", _.bufferView)) : b.push(null),
        _.sparse !== void 0 && (b.push(this.getDependency("bufferView", _.sparse.indices.bufferView)),
        b.push(this.getDependency("bufferView", _.sparse.values.bufferView))),
        Promise.all(b).then(function(_e) {
            const nt = _e[0]
              , it = WEBGL_TYPE_SIZES[_.type]
              , at = WEBGL_COMPONENT_TYPES[_.componentType]
              , ut = at.BYTES_PER_ELEMENT
              , pt = ut * it
              , ht = _.byteOffset || 0
              , _t = _.bufferView !== void 0 ? h.bufferViews[_.bufferView].byteStride : void 0
              , vt = _.normalized === !0;
            let bt, St;
            if (_t && _t !== pt) {
                const At = Math.floor(ht / _t)
                  , Et = "InterleavedBuffer:" + _.bufferView + ":" + _.componentType + ":" + At + ":" + _.count;
                let Pt = c.cache.get(Et);
                Pt || (bt = new at(nt,At * _t,_.count * _t / ut),
                Pt = new three_module.eB$(bt,_t / ut),
                c.cache.add(Et, Pt)),
                St = new three_module.eHs(Pt,it,ht % _t / ut,vt)
            } else
                bt = nt === null ? new at(_.count * it) : new at(nt,ht,_.count * it),
                St = new three_module.THS(bt,it,vt);
            if (_.sparse !== void 0) {
                const At = WEBGL_TYPE_SIZES.SCALAR
                  , Et = WEBGL_COMPONENT_TYPES[_.sparse.indices.componentType]
                  , Pt = _.sparse.indices.byteOffset || 0
                  , It = _.sparse.values.byteOffset || 0
                  , Dt = new Et(_e[1],Pt,_.sparse.count * At)
                  , Gt = new at(_e[2],It,_.sparse.count * it);
                nt !== null && (St = new three_module.THS(St.array.slice(),St.itemSize,St.normalized));
                for (let Bt = 0, kt = Dt.length; Bt < kt; Bt++) {
                    const Ut = Dt[Bt];
                    if (St.setX(Ut, Gt[Bt * it]),
                    it >= 2 && St.setY(Ut, Gt[Bt * it + 1]),
                    it >= 3 && St.setZ(Ut, Gt[Bt * it + 2]),
                    it >= 4 && St.setW(Ut, Gt[Bt * it + 3]),
                    it >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return St
        })
    }
    loadTexture(o) {
        const c = this.json
          , h = this.options;
        if (o < 0 || o >= c.textures.length)
            return console.warn("THREE.GLTFLoader: Invalid texture index:", o),
            null;
        const _ = c.textures[o].source;
        if (_ < 0 || _ >= c.images.length)
            return console.warn("THREE.GLTFLoader: Invalid source index:", _),
            null;
        const b = c.images[_];
        let _e = this.textureLoader;
        if (b.uri) {
            const nt = h.manager.getHandler(b.uri);
            nt !== null && (_e = nt)
        }
        return this.loadTextureImage(o, _, _e)
    }
    loadTextureImage(o, c, h) {
        const _ = this
          , b = this.json
          , _e = b.textures[o]
          , nt = b.images[c]
          , it = (nt.uri || nt.bufferView) + ":" + _e.sampler;
        if (this.textureCache[it])
            return this.textureCache[it];
        const at = this.loadImageSource(c, h).then(function(ut) {
            ut.name = _e.name || nt.name || "",
            ut.name === "" && typeof nt.uri == "string" && nt.uri.startsWith("data:image/") === !1 && (ut.name = nt.uri);
            const pt = (b.samplers || {})[_e.sampler] || {};
            return ut.magFilter = WEBGL_FILTERS[pt.magFilter] || three_module.k6q,
            ut.minFilter = WEBGL_FILTERS[pt.minFilter] || three_module.$_I,
            ut.wrapS = WEBGL_WRAPPINGS[pt.wrapS] || three_module.GJx,
            ut.wrapT = WEBGL_WRAPPINGS[pt.wrapT] || three_module.GJx,
            pt.extras && pt.extras.uuid !== void 0 && (ut.uuid = pt.extras.uuid,
            ut.__hasGLTFUuid = !0),
            _.associations.set(ut, {
                textures: o
            }),
            ut
        }).catch(function() {
            return null
        });
        return this.textureCache[it] = at,
        at
    }
    loadImageSource(o, c, h=!1, _=!1) {
        const b = this
          , _e = this.json
          , nt = this.options;
        if (!_ && this.sourceCache[o] !== void 0)
            return this.sourceCache[o].then(vt => vt.clone());
        const it = _e.images[o]
          , at = self.URL || self.webkitURL;
        it.uri === void 0 && it.extras && it.extras.uri && (it.uri = it.extras.uri);
        let ut = it.uri || ""
          , pt = !1
          , ht = null;
        if (it.bufferView === void 0 || h && ut) {
            if (it.uri === void 0)
                throw new Error("THREE.GLTFLoader: Image " + o + " is missing URI and bufferView")
        } else
            ut = b.getDependency("bufferView", it.bufferView).then(function(vt) {
                pt = !0;
                const bt = new Blob([vt],{
                    type: it.mimeType
                });
                return ut = at.createObjectURL(bt),
                ht = bt,
                ut
            });
        const _t = Promise.resolve(ut).then(function(vt) {
            return new Promise(function(bt, St) {
                let At = bt;
                c.isImageBitmapLoader === !0 && (At = function(Et) {
                    const Pt = new three_module.gPd(Et);
                    Pt.needsUpdate = !0,
                    bt(Pt)
                }
                ),
                c.load(three_module.r6x.resolveURL(vt, nt.path), At, void 0, function(Et) {
                    c.isImageBitmapLoader === !0 ? (c = new three_module.Tap(b.options.manager),
                    At = bt,
                    c.setCrossOrigin(b.options.crossOrigin),
                    c.setRequestHeader(b.options.requestHeader),
                    c.load(three_module.r6x.resolveURL(vt, nt.path), At, void 0, St)) : St(Et)
                })
            }
            )
        }).then(function(vt) {
            if (pt === !0 && at.revokeObjectURL(ut),
            vt.userData.mimeType = it.mimeType || getImageURIMimeType(it.uri),
            vt.flipY = !1,
            it.extras) {
                if (it.extras.flipY !== void 0) {
                    if (c.isImageBitmapLoader === !0 && typeof createImageBitmap !== void 0) {
                        let bt = vt;
                        const St = it.extras.flipY && !bt.flipY;
                        createImageBitmap(bt.source.data, {
                            imageOrientation: St ? "flipY" : "none"
                        }).then(function(At) {
                            bt._newTex && (bt = bt._newTex),
                            bt.source.data.close && bt.source.data.close(),
                            bt.source.data = At,
                            bt.source.needsUpdate = !0,
                            bt.needsUpdate = !0
                        })
                    }
                    vt.flipY = it.extras.flipY,
                    vt.needsUpdate = !0,
                    delete it.extras.flipY
                }
                it.extras.uuid !== void 0 && (vt.source.uuid = it.extras.uuid),
                it.extras.t_uuid !== void 0 && (vt.uuid = it.extras.t_uuid,
                vt.__hasGLTFUuid = !0)
            }
            return it.uri && typeof it.uri == "string" && pt === !1 && !it.uri.startsWith("/") && (vt.userData.rootPath = three_module.r6x.resolveURL(it.uri, nt.path)),
            ht && (vt.userData.__sourceBlob = ht),
            !h && it.uri && it.uri !== ut && b.loadImageSource(o, c, !0, !0).then(function(bt) {
                vt.source.data && vt.source.data.close && vt.source.data.close(),
                vt.dispose(),
                vt.source = bt.source,
                vt.source.needsUpdate = !0,
                vt.needsUpdate = !0,
                vt.uuid = bt.uuid,
                bt.__hasGLTFUuid && (vt.__hasGLTFUuid = !0),
                vt.flipY = bt.flipY,
                vt.userData = bt.userData,
                vt.setDirty && vt.setDirty(),
                bt._newTex = vt
            }),
            vt
        }).catch(function(vt) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", ut),
            vt
        });
        return this.sourceCache[o] = _t,
        _t
    }
    assignTexture(o, c, h, _) {
        const b = this;
        return this.getDependency("texture", h.index).then(function(_e) {
            if (!_e)
                return null;
            if (h.texCoord !== void 0 && h.texCoord > 0 && ((_e = _e.clone()).channel = h.texCoord),
            b.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                const nt = h.extensions !== void 0 ? h.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
                if (nt) {
                    const it = b.associations.get(_e);
                    _e = b.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(_e, nt),
                    b.associations.set(_e, it)
                }
            }
            return _ !== void 0 && (_e.colorSpace = _),
            o[c] = _e,
            _e
        })
    }
    assignFinalMaterial(o) {
        const c = o.geometry;
        let h = o.material;
        const _ = c.attributes.tangent === void 0
          , b = c.attributes.color !== void 0
          , _e = c.attributes.normal === void 0;
        if (o.isPoints) {
            const it = "PointsMaterial:" + h.uuid;
            let at = this.cache.get(it);
            at || (at = new GLTFLoader.ObjectConstructors.PointsMaterial,
            three_module.imn.prototype.copy.call(at, h),
            at.color.copy(h.color),
            at.map = h.map,
            at.sizeAttenuation = !1,
            this.cache.add(it, at)),
            h = at
        } else if (o.isLine) {
            const it = "LineBasicMaterial:" + h.uuid;
            let at = this.cache.get(it);
            at || (at = new GLTFLoader.ObjectConstructors.LineBasicMaterial,
            three_module.imn.prototype.copy.call(at, h),
            at.color.copy(h.color),
            at.map = h.map,
            this.cache.add(it, at)),
            h = at
        }
        const nt = !(!h.userData || !h.userData.gltfExtensions || !h.userData.gltfExtensions.WEBGI_material_extras);
        if ((_ || b || _e) && !nt) {
            let it = "ClonedMaterial:" + h.uuid + ":";
            _ && (it += "derivative-tangents:"),
            b && (it += "vertex-colors:"),
            _e && (it += "flat-shading:");
            let at = this.cache.get(it);
            at || (at = h.clone(),
            b && (at.vertexColors = !0),
            _e && (at.flatShading = !0),
            _ && (at.normalScale && (at.normalScale.y *= -1),
            at.clearcoatNormalScale && (at.clearcoatNormalScale.y *= -1)),
            this.cache.add(it, at),
            this.associations.set(at, this.associations.get(h))),
            h = at
        }
        o.material = h
    }
    getMaterialType() {
        return GLTFLoader.ObjectConstructors.MeshStandardMaterial
    }
    loadMaterial(o) {
        const c = this
          , h = this.json
          , _ = this.extensions
          , b = h.materials[o];
        let _e;
        const nt = {}
          , it = [];
        if ((b.extensions || {})[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
            const ut = _[EXTENSIONS.KHR_MATERIALS_UNLIT];
            _e = ut.getMaterialType(),
            it.push(ut.extendParams(nt, b, c))
        } else {
            const ut = b.pbrMetallicRoughness || {};
            if (nt.color = new three_module.Q1f(1,1,1),
            nt.opacity = 1,
            Array.isArray(ut.baseColorFactor)) {
                const pt = ut.baseColorFactor;
                nt.color.setRGB(pt[0], pt[1], pt[2], three_module.Zr2),
                nt.opacity = pt[3]
            }
            ut.baseColorTexture !== void 0 && it.push(c.assignTexture(nt, "map", ut.baseColorTexture, three_module.er$)),
            nt.metalness = ut.metallicFactor !== void 0 ? ut.metallicFactor : 1,
            nt.roughness = ut.roughnessFactor !== void 0 ? ut.roughnessFactor : 1,
            ut.metallicRoughnessTexture !== void 0 && (it.push(c.assignTexture(nt, "metalnessMap", ut.metallicRoughnessTexture)),
            it.push(c.assignTexture(nt, "roughnessMap", ut.metallicRoughnessTexture))),
            _e = this._invokeOne(function(pt) {
                return pt.getMaterialType && pt.getMaterialType(o)
            }),
            it.push(Promise.all(this._invokeAll(function(pt) {
                return pt.extendMaterialParams && pt.extendMaterialParams(o, nt)
            })))
        }
        b.doubleSided === !0 && (nt.side = three_module.$EB);
        const at = b.alphaMode || ALPHA_MODES.OPAQUE;
        if (at === ALPHA_MODES.BLEND ? (nt.transparent = !0,
        nt.depthWrite = !1) : (nt.transparent = !1,
        at === ALPHA_MODES.MASK && (nt.alphaTest = b.alphaCutoff !== void 0 ? b.alphaCutoff : .5)),
        b.normalTexture !== void 0 && _e !== GLTFLoader.ObjectConstructors.MeshBasicMaterial && (it.push(c.assignTexture(nt, "normalMap", b.normalTexture)),
        nt.normalScale = new three_module.I9Y(1,1),
        b.normalTexture.scale !== void 0)) {
            const ut = b.normalTexture.scale;
            nt.normalScale.set(ut, ut)
        }
        if (b.occlusionTexture !== void 0 && _e !== GLTFLoader.ObjectConstructors.MeshBasicMaterial && (it.push(c.assignTexture(nt, "aoMap", b.occlusionTexture)),
        b.occlusionTexture.strength !== void 0 && (nt.aoMapIntensity = b.occlusionTexture.strength)),
        b.emissiveFactor !== void 0 && _e !== GLTFLoader.ObjectConstructors.MeshBasicMaterial) {
            const ut = b.emissiveFactor;
            nt.emissive = new three_module.Q1f().setRGB(ut[0], ut[1], ut[2], three_module.Zr2)
        }
        return b.emissiveTexture !== void 0 && _e !== GLTFLoader.ObjectConstructors.MeshBasicMaterial && it.push(c.assignTexture(nt, "emissiveMap", b.emissiveTexture, three_module.er$)),
        Promise.all(it).then(function() {
            const ut = new _e(nt);
            return b.extras && b.extras.uuid && (ut.uuid = b.extras.uuid),
            b.name && (ut.name = b.name),
            assignExtrasToUserData(ut, b),
            c.associations.set(ut, {
                materials: o
            }),
            b.extensions && addUnknownExtensionsToUserData(_, ut, b),
            ut
        })
    }
    createUniqueName(o) {
        const c = three_module.Nwf.sanitizeNodeName(o || "");
        return c in this.nodeNamesUsed ? c + "_" + ++this.nodeNamesUsed[c] : (this.nodeNamesUsed[c] = 0,
        c)
    }
    loadGeometries(o) {
        const c = this
          , h = this.extensions
          , _ = this.primitiveCache;
        function b(nt) {
            return h[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(nt, c).then(function(it) {
                return addPrimitiveAttributes(it, nt, c)
            })
        }
        const _e = [];
        for (let nt = 0, it = o.length; nt < it; nt++) {
            const at = o[nt]
              , ut = createPrimitiveKey(at)
              , pt = _[ut];
            if (pt)
                _e.push(pt.promise);
            else {
                let ht;
                ht = at.extensions && at.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] ? b(at) : addPrimitiveAttributes(new three_module.LoY, at, c),
                _[ut] = {
                    primitive: at,
                    promise: ht
                },
                _e.push(ht)
            }
        }
        return Promise.all(_e)
    }
    loadMesh(o) {
        const c = this
          , h = this.json
          , _ = this.extensions
          , b = h.meshes[o]
          , _e = b.primitives
          , nt = [];
        for (let it = 0, at = _e.length; it < at; it++) {
            const ut = _e[it].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", _e[it].material);
            nt.push(ut)
        }
        return nt.push(c.loadGeometries(_e)),
        Promise.all(nt).then(function(it) {
            const at = it.slice(0, it.length - 1)
              , ut = it[it.length - 1]
              , pt = [];
            for (let _t = 0, vt = ut.length; _t < vt; _t++) {
                const bt = ut[_t]
                  , St = _e[_t];
                let At;
                const Et = at[_t];
                if (St.mode === WEBGL_CONSTANTS.TRIANGLES || St.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || St.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || St.mode === void 0)
                    At = b.isSkinnedMesh === !0 ? new three_module.I46(bt,Et) : new three_module.eaF(bt,Et),
                    At.isSkinnedMesh === !0 && At.normalizeSkinWeights(),
                    St.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ? At.geometry = toTrianglesDrawMode(At.geometry, three_module.O49) : St.mode === WEBGL_CONSTANTS.TRIANGLE_FAN && (At.geometry = toTrianglesDrawMode(At.geometry, three_module.rYR));
                else if (St.mode === WEBGL_CONSTANTS.LINES)
                    At = new three_module.DXC(bt,Et);
                else if (St.mode === WEBGL_CONSTANTS.LINE_STRIP)
                    At = new three_module.N1A(bt,Et);
                else if (St.mode === WEBGL_CONSTANTS.LINE_LOOP)
                    At = new three_module.FCc(bt,Et);
                else {
                    if (St.mode !== WEBGL_CONSTANTS.POINTS)
                        throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + St.mode);
                    At = new three_module.ONl(bt,Et)
                }
                Object.keys(At.geometry.morphAttributes).length > 0 && updateMorphTargets(At, b),
                At.name = c.createUniqueName(b.name || "mesh_" + o),
                At.geometry && b.extras && b.extras.isGeometryUserData ? (assignExtrasToUserData(At.geometry, b),
                St.extensions && addUnknownExtensionsToUserData(_, At.geometry, St)) : (assignExtrasToUserData(At, b),
                St.extensions && addUnknownExtensionsToUserData(_, At, St)),
                c.assignFinalMaterial(At),
                pt.push(At)
            }
            b.extensions && pt.forEach(_t => addUnknownExtensionsToUserData(_, _t, b));
            for (let _t = 0, vt = pt.length; _t < vt; _t++)
                c.associations.set(pt[_t], {
                    meshes: o,
                    primitives: _t
                });
            if (pt.length === 1)
                return b.extensions && addUnknownExtensionsToUserData(_, pt[0], b),
                pt[0];
            const ht = new three_module.YJl;
            b.extensions && addUnknownExtensionsToUserData(_, ht, b),
            c.associations.set(ht, {
                meshes: o
            });
            for (let _t = 0, vt = pt.length; _t < vt; _t++)
                ht.add(pt[_t]);
            return ht
        })
    }
    loadCamera(o) {
        let c;
        const h = this.json.cameras[o]
          , _ = h[h.type];
        if (_)
            return h.type === "perspective" ? c = new GLTFLoader.ObjectConstructors.PerspectiveCamera(three_module.cj9.radToDeg(_.yfov),_.aspectRatio || 1,_.znear || 1,_.zfar || 2e6) : h.type === "orthographic" && (c = new GLTFLoader.ObjectConstructors.OrthographicCamera(-_.xmag,_.xmag,_.ymag,-_.ymag,_.znear,_.zfar)),
            h.name && (c.name = this.createUniqueName(h.name)),
            assignExtrasToUserData(c, h),
            Promise.resolve(c);
        console.warn("THREE.GLTFLoader: Missing camera parameters.")
    }
    loadSkin(o) {
        const c = this.json.skins[o]
          , h = [];
        for (let _ = 0, b = c.joints.length; _ < b; _++)
            h.push(this._loadNodeShallow(c.joints[_]));
        return c.inverseBindMatrices !== void 0 ? h.push(this.getDependency("accessor", c.inverseBindMatrices)) : h.push(null),
        Promise.all(h).then(function(_) {
            const b = _.pop()
              , _e = _
              , nt = []
              , it = [];
            for (let at = 0, ut = _e.length; at < ut; at++) {
                const pt = _e[at];
                if (pt) {
                    nt.push(pt);
                    const ht = new three_module.kn4;
                    b !== null && ht.fromArray(b.array, 16 * at),
                    it.push(ht)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', c.joints[at])
            }
            return new three_module.EAD(nt,it)
        })
    }
    loadAnimation(o) {
        const c = this.json
          , h = this
          , _ = c.animations[o]
          , b = _.name ? _.name : "animation_" + o
          , _e = []
          , nt = []
          , it = []
          , at = []
          , ut = [];
        for (let pt = 0, ht = _.channels.length; pt < ht; pt++) {
            const _t = _.channels[pt]
              , vt = _.samplers[_t.sampler]
              , bt = _t.target
              , St = bt.node
              , At = _.parameters !== void 0 ? _.parameters[vt.input] : vt.input
              , Et = _.parameters !== void 0 ? _.parameters[vt.output] : vt.output;
            bt.node !== void 0 && (_e.push(this.getDependency("node", St)),
            nt.push(this.getDependency("accessor", At)),
            it.push(this.getDependency("accessor", Et)),
            at.push(vt),
            ut.push(bt))
        }
        return Promise.all([Promise.all(_e), Promise.all(nt), Promise.all(it), Promise.all(at), Promise.all(ut)]).then(function(pt) {
            const ht = pt[0]
              , _t = pt[1]
              , vt = pt[2]
              , bt = pt[3]
              , St = pt[4]
              , At = [];
            for (let Et = 0, Pt = ht.length; Et < Pt; Et++) {
                const It = ht[Et]
                  , Dt = _t[Et]
                  , Gt = vt[Et]
                  , Bt = bt[Et]
                  , kt = St[Et];
                if (It === void 0)
                    continue;
                It.updateMatrix && It.updateMatrix();
                const Ut = h._createAnimationTracks(It, Dt, Gt, Bt, kt);
                if (Ut)
                    for (let Ht = 0; Ht < Ut.length; Ht++)
                        At.push(Ut[Ht])
            }
            return new three_module.tz3(b,void 0,At)
        })
    }
    createNodeMesh(o) {
        const c = this.json
          , h = this
          , _ = c.nodes[o];
        return _.mesh === void 0 ? null : h.getDependency("mesh", _.mesh).then(function(b) {
            const _e = h._getNodeRef(h.meshCache, _.mesh, b);
            return _.weights !== void 0 && _e.traverse(function(nt) {
                if (nt.isMesh)
                    for (let it = 0, at = _.weights.length; it < at; it++)
                        nt.morphTargetInfluences[it] = _.weights[it]
            }),
            _e
        })
    }
    loadNode(o) {
        const c = this
          , h = this.json.nodes[o]
          , _ = c._loadNodeShallow(o)
          , b = []
          , _e = h.children || [];
        for (let it = 0, at = _e.length; it < at; it++)
            b.push(c.getDependency("node", _e[it]));
        const nt = h.skin === void 0 ? Promise.resolve(null) : c.getDependency("skin", h.skin);
        return Promise.all([_, Promise.all(b), nt]).then(function(it) {
            const at = it[0]
              , ut = it[1]
              , pt = it[2];
            pt !== null && at.traverse(function(ht) {
                ht.isSkinnedMesh && ht.bind(pt, _identityMatrix)
            });
            for (let ht = 0, _t = ut.length; ht < _t; ht++)
                at.add(ut[ht]);
            return at
        })
    }
    _loadNodeShallow(o) {
        const c = this.json
          , h = this.extensions
          , _ = this;
        if (this.nodeCache[o] !== void 0)
            return this.nodeCache[o];
        const b = c.nodes[o]
          , _e = b.name ? _.createUniqueName(b.name) : ""
          , nt = []
          , it = _._invokeOne(function(at) {
            return at.createNodeMesh && at.createNodeMesh(o)
        });
        return it && nt.push(it),
        b.camera !== void 0 && nt.push(_.getDependency("camera", b.camera).then(function(at) {
            return _._getNodeRef(_.cameraCache, b.camera, at)
        })),
        _._invokeAll(function(at) {
            return at.createNodeAttachment && at.createNodeAttachment(o)
        }).forEach(function(at) {
            nt.push(at)
        }),
        this.nodeCache[o] = Promise.all(nt).then(function(at) {
            let ut;
            if (ut = b.isBone === !0 ? new three_module.$Kf : at.length > 1 ? new three_module.YJl : at.length === 1 ? at[0] : new three_module.B69,
            ut !== at[0])
                for (let pt = 0, ht = at.length; pt < ht; pt++)
                    ut.add(at[pt]);
            if (b.name && (ut.userData.name = b.name,
            ut.name = _e),
            assignExtrasToUserData(ut, b),
            b.extensions && addUnknownExtensionsToUserData(h, ut, b),
            b.matrix !== void 0) {
                const pt = new three_module.kn4;
                pt.fromArray(b.matrix),
                ut.applyMatrix4(pt)
            } else
                b.translation !== void 0 && ut.position.fromArray(b.translation),
                b.rotation !== void 0 && ut.quaternion.fromArray(b.rotation),
                b.scale !== void 0 && ut.scale.fromArray(b.scale);
            return _.associations.has(ut) || _.associations.set(ut, {}),
            _.associations.get(ut).nodes = o,
            ut
        }),
        this.nodeCache[o]
    }
    loadScene(o) {
        const c = this.extensions
          , h = this.json.scenes[o]
          , _ = this
          , b = new three_module.YJl;
        h.name && (b.name = _.createUniqueName(h.name)),
        assignExtrasToUserData(b, h),
        h.extensions && addUnknownExtensionsToUserData(c, b, h);
        const _e = h.nodes || []
          , nt = [];
        for (let it = 0, at = _e.length; it < at; it++)
            nt.push(_.getDependency("node", _e[it]));
        return Promise.all(nt).then(function(it) {
            for (let at = 0, ut = it.length; at < ut; at++)
                b.add(it[at]);
            return _.associations = (at => {
                const ut = new Map;
                for (const [pt,ht] of _.associations)
                    (pt instanceof three_module.imn || pt instanceof three_module.gPd) && ut.set(pt, ht);
                return at.traverse(pt => {
                    const ht = _.associations.get(pt);
                    ht != null && ut.set(pt, ht)
                }
                ),
                ut
            }
            )(b),
            b
        })
    }
    _createAnimationTracks(o, c, h, _, b) {
        const _e = []
          , nt = o.name ? o.name : o.uuid
          , it = [];
        let at;
        switch (PATH_PROPERTIES[b.path] === PATH_PROPERTIES.weights ? o.traverse(function(ht) {
            ht.morphTargetInfluences && it.push(ht.name ? ht.name : ht.uuid)
        }) : it.push(nt),
        PATH_PROPERTIES[b.path]) {
        case PATH_PROPERTIES.weights:
            at = three_module.Hit;
            break;
        case PATH_PROPERTIES.rotation:
            at = three_module.MBL;
            break;
        case PATH_PROPERTIES.position:
        case PATH_PROPERTIES.scale:
            at = three_module.RiT;
            break;
        default:
            at = h.itemSize === 1 ? three_module.Hit : three_module.RiT
        }
        const ut = _.interpolation !== void 0 ? INTERPOLATION[_.interpolation] : three_module.PJ3
          , pt = this._getArrayFromAccessor(h);
        for (let ht = 0, _t = it.length; ht < _t; ht++) {
            const vt = new at(it[ht] + "." + PATH_PROPERTIES[b.path],c.array,pt,ut);
            _.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(vt),
            _e.push(vt)
        }
        return _e
    }
    _getArrayFromAccessor(o) {
        let c = o.array;
        if (o.normalized) {
            const h = getNormalizedComponentScale(c.constructor)
              , _ = new Float32Array(c.length);
            for (let b = 0, _e = c.length; b < _e; b++)
                _[b] = c[b] * h;
            c = _
        }
        return c
    }
    _createCubicSplineTrackInterpolant(o) {
        o.createInterpolant = function(c) {
            return new (this instanceof three_module.MBL ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant)(this.times,this.values,this.getValueSize() / 3,c)
        }
        ,
        o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function computeBounds(d, o, c) {
    const h = o.attributes
      , _ = new three_module.NRn;
    if (h.POSITION === void 0)
        return;
    {
        const nt = c.json.accessors[h.POSITION]
          , it = nt.min
          , at = nt.max;
        if (it === void 0 || at === void 0)
            return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        if (_.set(new three_module.Pq0(it[0],it[1],it[2]), new three_module.Pq0(at[0],at[1],at[2])),
        nt.normalized) {
            const ut = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[nt.componentType]);
            _.min.multiplyScalar(ut),
            _.max.multiplyScalar(ut)
        }
    }
    const b = o.targets;
    if (b !== void 0) {
        const nt = new three_module.Pq0
          , it = new three_module.Pq0;
        for (let at = 0, ut = b.length; at < ut; at++) {
            const pt = b[at];
            if (pt.POSITION !== void 0) {
                const ht = c.json.accessors[pt.POSITION]
                  , _t = ht.min
                  , vt = ht.max;
                if (_t !== void 0 && vt !== void 0) {
                    if (it.setX(Math.max(Math.abs(_t[0]), Math.abs(vt[0]))),
                    it.setY(Math.max(Math.abs(_t[1]), Math.abs(vt[1]))),
                    it.setZ(Math.max(Math.abs(_t[2]), Math.abs(vt[2]))),
                    ht.normalized) {
                        const bt = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[ht.componentType]);
                        it.multiplyScalar(bt)
                    }
                    nt.max(it)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        _.expandByVector(nt)
    }
    d.boundingBox = _;
    const _e = new three_module.iyt;
    _.getCenter(_e.center),
    _e.radius = _.min.distanceTo(_.max) / 2,
    d.boundingSphere = _e
}
function addPrimitiveAttributes(d, o, c) {
    const h = o.attributes
      , _ = [];
    function b(_e, nt) {
        return c.getDependency("accessor", _e).then(function(it) {
            d.setAttribute(nt, it)
        })
    }
    for (const _e in h) {
        const nt = ATTRIBUTES[_e] || _e.toLowerCase();
        nt in d.attributes || _.push(b(h[_e], nt))
    }
    if (o.indices !== void 0 && !d.index) {
        const _e = c.getDependency("accessor", o.indices).then(function(nt) {
            d.setIndex(nt)
        });
        _.push(_e)
    }
    return three_module.ppV.workingColorSpace !== three_module.Zr2 && "COLOR_0"in h && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${three_module.ppV.workingColorSpace}" not supported.`),
    assignExtrasToUserData(d, o),
    computeBounds(d, o, c),
    Promise.all(_).then(function() {
        return o.targets !== void 0 ? addMorphTargets(d, o.targets, c) : d
    })
}
class GLTFLoader2 extends GLTFLoader {
    constructor(o) {
        super(o),
        this.isGLTFLoader2 = !0,
        this.preparsers = [],
        this.preparsers.push(glbEncryptionPreparser)
    }
    async preparse(o, c) {
        for (const h of this.preparsers)
            o = await h.process(o, c);
        return o
    }
    parse(o, c, h, _, b) {
        this.preparse.call(this, o, b || c).then(_e => {
            const nt = three_module.gPd.DEFAULT_IMAGE;
            return three_module.gPd.DEFAULT_IMAGE || (three_module.gPd.DEFAULT_IMAGE = AssetImporter.WHITE_IMAGE_DATA),
            _e ? super.parse(_e, c, it => {
                three_module.gPd.DEFAULT_IMAGE = nt,
                h && h(it)
            }
            , _) : _ && _(new ErrorEvent("no data"))
        }
        ).catch(_e => {
            console.error(_e),
            _ && _(_e ?? new ErrorEvent("unknown error"))
        }
        )
    }
    transform(o, c) {
        const h = o ? o.scene || (o.scenes && o.scenes.length > 0 ? o.scenes[0] : void 0) : void 0;
        return h && o.animations.length > 0 && (h.animations = o.animations),
        h == null || h.traverse(_ => {
            _.userData.gltfUUID && (_.uuid = _.userData.gltfUUID,
            delete _.userData.gltfUUID)
        }
        ),
        h
    }
    register(o) {
        return super.register(o)
    }
}
const glbEncryptionPreparser = {
    key: (d, o, c) => d.key || window && window.prompt && window.prompt("GLTFEncryption: Please enter the password/key for the model: " + c) || "",
    async process(d, o) {
        var c;
        if (typeof d == "string" || !new TextDecoder().decode(new Uint8Array(d,0,100)).includes("WebGiGLBWrapper"))
            return d;
        const h = new GLTFBinaryExtension(d)
          , _ = JSON.parse(h.content || "{}");
        let b = h.body || d;
        const _e = (c = _.asset) === null || c === void 0 ? void 0 : c.encryption;
        if (!_e)
            return b;
        const nt = _e.type
          , it = _e.version;
        if (nt === "aesgcm" && it === 1) {
            const at = await Ee$1(this.key, _e, _, o) || "";
            try {
                b = (await Pe$1(new Uint8Array(b), at)).buffer
            } catch {
                throw new ErrorEvent("decryption error")
            }
        }
        return b
    }
};
class RGBEPNGLoader extends three_module.Y9S {
    constructor(o) {
        super(o),
        this.type = three_module.ix0
    }
    async loadAsync(o, c) {
        const h = await this.parseAsync(o, c, !1)
          , _ = new three_module.GYF(h.data,h.width,h.height,three_module.GWd,this.type);
        return _.needsUpdate = !0,
        _.flipY = !0,
        _.colorSpace = three_module.er$,
        _.minFilter = three_module.k6q,
        _.magFilter = three_module.k6q,
        _.source.data.complete = !0,
        _
    }
    async parseAsync(o, c, h=!1) {
        let _ = !1;
        if (!o.startsWith("data:") && !o.startsWith("blob:")) {
            this.responseType = "blob";
            const nt = await super.loadAsync(o, c);
            o = URL.createObjectURL(nt),
            _ = !0
        }
        const b = await He$1(o);
        _ && URL.revokeObjectURL(o);
        let _e = Uint8Array;
        return this.type === three_module.ix0 ? _e = Uint16Array : this.type === three_module.RQf && (_e = Uint32Array),
        {
            data: rgbeToHalfFloat(b.data, 4, _e, h),
            width: b.width,
            height: b.height
        }
    }
    setDataType(o) {
        return this.type = o,
        this
    }
}
function rgbeToHalfFloat(d, o=3, c=Uint16Array, h=!1) {
    let _;
    const b = d.byteLength >> 2
      , _e = new c(b * o);
    for (let nt = 0; nt < b; nt++)
        _ = Math.pow(2, d[4 * nt + 3] - 136),
        h ? (_e[nt * o] = Math.min(d[4 * nt] * _, 65504),
        _e[nt * o + 1] = Math.min(d[4 * nt + 1] * _, 65504),
        _e[nt * o + 2] = Math.min(d[4 * nt + 2] * _, 65504)) : (_e[nt * o] = three_module.GxU.toHalfFloat(Math.min(d[4 * nt] * _, 65504)),
        _e[nt * o + 1] = three_module.GxU.toHalfFloat(Math.min(d[4 * nt + 1] * _, 65504)),
        _e[nt * o + 2] = three_module.GxU.toHalfFloat(Math.min(d[4 * nt + 2] * _, 65504))),
        o === 4 && (_e[nt * o + 3] = three_module.GxU.toHalfFloat(1));
    return _e
}
class ObjectLoader2 extends three_module.XTe {
    constructor(o) {
        super(o),
        this._imageLoader = new three_module.$NF(o)
    }
    static async LoadRootPathTextures(o, c, h, _=!0) {
        var b;
        const _e = [];
        for (const nt of Array.isArray(o) ? o : Object.values(o ?? {})) {
            const it = (b = nt == null ? void 0 : nt.userData) === null || b === void 0 ? void 0 : b.rootPath
              , at = _ && nt.image && c[nt.image];
            if (!it)
                continue;
            const ut = h.importPath(it, {
                processImported: !1
            }).then(pt => {
                const ht = pt == null ? void 0 : pt[0]
                  , _t = ht == null ? void 0 : ht.source;
                if (!ht || !_t)
                    return null;
                const vt = new three_module.kLi(_t.data);
                return nt.image && (vt.uuid = nt.image),
                nt.image = vt.uuid,
                at || (c[vt.uuid] = vt),
                ht.dispose(),
                vt
            }
            ).catch(pt => (console.error(pt),
            delete nt.userData.rootPath,
            null));
            at ? nt.rootPathPromise = ut : _e.push(ut)
        }
        await Promise.allSettled(_e)
    }
    parseTextures2(o, c, h) {
        var _, b;
        for (const it of o) {
            const at = (_ = it == null ? void 0 : it.userData) === null || _ === void 0 ? void 0 : _.rootPath;
            if (at && (!it.image || !c[it.image])) {
                const ut = new three_module.kLi(this._imageLoader.load(at, h));
                if (!ut)
                    continue;
                it.image && (ut.uuid = it.image),
                c[ut.uuid] = ut,
                it.image = ut.uuid
            }
            it.userData = deserializeObject(it.userData, void 0, !1, {
                images: c
            })
        }
        const _e = super.parseTextures(o, c)
          , nt = {
            ..._e
        };
        for (const it of o)
            (b = it.rootPathPromise) === null || b === void 0 || b.then(at => {
                if (!at)
                    return;
                const ut = nt[it.uuid];
                ut.dispose(),
                ut.source = at,
                ut.source.needsUpdate = !0,
                ut.needsUpdate = !0
            }
            );
        return _e
    }
    parseMaterials2(o, c, h) {
        const _ = {};
        return o.forEach(b => {
            if (!b)
                return;
            const _e = {
                ...b
            }
              , nt = Object.keys(_e);
            for (const at of nt)
                if (at === "map" || at.endsWith("Map")) {
                    const ut = _e[at];
                    typeof ut == "string" && (c[ut] ? _e[at] = c[ut] : (console.warn(`Texture ${ut} not found`),
                    delete _e[at]))
                }
            _e.userData && (_e.userData = deserializeObject(_e.userData, void 0, !1, {
                textures: c
            }),
            _e.userData.cloneId && _e.userData.uuid !== b.uuid && (_e.userData.uuid = b.uuid));
            const it = h.generateFromTemplateType(_e.type, _e);
            it && (_[b.uuid] = it)
        }
        ),
        _
    }
}
const viewerGLTFExtension = "WEBGI_viewer"
  , webgiLightExtrasExtension = "WEBGI_light_extras"
  , webgiObject3DExtrasExtension = "WEBGI_object3d_extras"
  , webgiMaterialExtrasExtension = "WEBGI_material_extras"
  , GLTFMaterialsBumpMapExtensionName = "WEBGI_materials_bumpmap"
  , GLTFMaterialsDisplacementMapExtensionName = "WEBGI_materials_displacementmap"
  , GLTFMaterialsAlphaMapExtensionName = "WEBGI_materials_alphamap"
  , GLTFMaterialsLightMapExtensionName = "WEBGI_materials_lightmap"
  , supportedEmbeddedFiles = ["hdr", "exr", "webp", "avif", "ktx", "hdrpng", "svg", "cube"];
function addGLTFLoader(d) {
    return new Importer(GLTFLoader2,["gltf", "glb", "data:model/gltf"],!0, (o, c) => {
        if (!o)
            return o;
        const h = o
          , _ = new ObjectLoader2(c.loadingManager);
        return h.register(gltfMaterialExtrasParser(_, d)),
        h.register(gltfObject3DExtrasParser()),
        h.register(gltfLightExtrasParser(_)),
        h.register(b => new GLTFMaterialsBumpMapExtension(b)),
        h.register(b => new GLTFMaterialsDisplacementMapExtension(b)),
        h.register(b => new GLTFMaterialsLightMapExtension(b)),
        h.register(b => new GLTFMaterialsAlphaMapExtension(b)),
        h.register(b => {
            var _e, nt, it, at, ut, pt, ht, _t, vt;
            const bt = b.getDependency;
            b.getDependency = async (Dt, Gt) => {
                const Bt = await bt.call(b, Dt, Gt);
                if (Bt && Bt.userData) {
                    const kt = Bt.userData.gltfExtensions;
                    delete Bt.userData.gltfExtensions,
                    Bt.userData = deserializeObject(Bt.userData, {}, !1, {}),
                    Bt.userData.gltfExtensions = kt
                }
                return Bt
            }
            ;
            const St = esm_browser_v4() + ".drc"
              , At = esm_browser_v4() + ".ktx2"
              , Et = (it = (nt = (_e = b.json) === null || _e === void 0 ? void 0 : _e.extensionsRequired) === null || nt === void 0 ? void 0 : nt.includes) === null || it === void 0 ? void 0 : it.call(nt, "KHR_draco_mesh_compression");
            if (Et) {
                const Dt = c.registerFile(St);
                Dt && h.setDRACOLoader(Dt)
            }
            !((pt = (ut = (at = b.json) === null || at === void 0 ? void 0 : at.extensionsUsed) === null || ut === void 0 ? void 0 : ut.includes) === null || pt === void 0) && pt.call(ut, "EXT_meshopt_compression") && (window.MeshoptDecoder ? (h.setMeshoptDecoder(window.MeshoptDecoder),
            b.options.meshoptDecoder = window.MeshoptDecoder) : console.error("Add GLTFMeshOptPlugin to viewer to enable EXT_meshopt_compression decode"));
            const Pt = c.registerFile(At)
              , It = supportedEmbeddedFiles.map(Dt => esm_browser_v4() + "." + Dt);
            return It.forEach(Dt => c.registerFile(Dt)),
            !((vt = (_t = (ht = b.json) === null || ht === void 0 ? void 0 : ht.extensionsUsed) === null || _t === void 0 ? void 0 : _t.includes) === null || vt === void 0) && vt.call(_t, "KHR_texture_basisu") && Pt && (h.setKTX2Loader(Pt),
            b.options.ktx2Loader = Pt),
            {
                name: "GLTF2_HELPER_PLUGIN",
                afterRoot: async Dt => {
                    Et && c.unregisterFile(St),
                    Pt && c.unregisterFile(At),
                    It.forEach(Bt => c.unregisterFile(Bt));
                    const Gt = await importViewer(b, d, _);
                    Dt.scene && (Dt.scene.__importedViewerConfig = Gt)
                }
            }
        }
        ),
        h
    }
    )
}
const gltfObject3DExtrasParser = d => o => ({
    name: "__" + webgiObject3DExtrasExtension,
    afterRoot: async c => {
        (c.scenes || (c.scene ? [c.scene] : [])).forEach(h => {
            h.traverse(_ => {
                var b, _e;
                if (!_ || !_.isObject3D)
                    return;
                const nt = (_e = (b = _.userData) === null || b === void 0 ? void 0 : b.gltfExtensions) === null || _e === void 0 ? void 0 : _e[webgiObject3DExtrasExtension];
                if (!nt)
                    return void (_.isLight && !_.isAmbientLight && (_.castShadow = !0));
                const it = nt.castShadow !== void 0 || nt.receiveShadow !== void 0;
                nt.castShadow !== void 0 && (_.castShadow = nt.castShadow),
                nt.receiveShadow !== void 0 && (_.receiveShadow = nt.receiveShadow),
                nt.visible !== void 0 && (_.visible = nt.visible),
                nt.frustumCulled !== void 0 && (_.frustumCulled = nt.frustumCulled),
                nt.renderOrder !== void 0 && (_.renderOrder = nt.renderOrder),
                nt.layers !== void 0 && (_.layers.mask = nt.layers),
                it && (_.userData.__keepShadowDef = !0),
                delete _.userData.gltfExtensions[webgiObject3DExtrasExtension]
            }
            )
        }
        )
    }
})
  , gltfMaterialExtrasParser = (d, o) => c => ({
    name: "__" + webgiMaterialExtrasExtension,
    afterRoot: async h => {
        var _, b, _e;
        const nt = h.scenes || (h.scene ? [h.scene] : []);
        for (const it of nt) {
            const at = (b = (_ = it.userData) === null || _ === void 0 ? void 0 : _.gltfExtensions) === null || b === void 0 ? void 0 : b[webgiMaterialExtrasExtension]
              , ut = at && await ((_e = o.getPlugin(AssetManagerPlugin)) === null || _e === void 0 ? void 0 : _e.importConfigResources(at.resources || {})) || {};
            it.traverse(pt => {
                var ht, _t;
                const vt = pt == null ? void 0 : pt.material;
                if (!(vt != null && vt.isMaterial))
                    return;
                const bt = (_t = (ht = vt.userData) === null || ht === void 0 ? void 0 : ht.gltfExtensions) === null || _t === void 0 ? void 0 : _t[webgiMaterialExtrasExtension];
                bt && (bt.emissiveIntensity !== void 0 && (vt.emissiveIntensity = bt.emissiveIntensity),
                bt.fog !== void 0 && (vt.fog = bt.fog),
                bt.flatShading !== void 0 && (vt.flatShading = bt.flatShading),
                bt.blending !== void 0 && (vt.blending = bt.blending),
                bt.side !== void 0 && (vt.side = bt.side),
                bt.shadowSide !== void 0 && (vt.shadowSide = bt.shadowSide),
                bt.depthFunc !== void 0 && (vt.depthFunc = bt.depthFunc),
                bt.depthTest !== void 0 && (vt.depthTest = bt.depthTest),
                bt.depthWrite !== void 0 && (vt.depthWrite = bt.depthWrite),
                bt.colorWrite !== void 0 && (vt.colorWrite = bt.colorWrite),
                bt.vertexColors !== void 0 && (vt.vertexColors = bt.vertexColors),
                bt.alphaTest !== void 0 && (vt.alphaTest = bt.alphaTest),
                bt.alphaHash !== void 0 && (vt.alphaHash = bt.alphaHash),
                bt.envMapIntensity !== void 0 && (vt.envMapIntensity = bt.envMapIntensity),
                bt.wireframe !== void 0 && (vt.wireframe = bt.wireframe),
                bt.wireframeLinewidth !== void 0 && (vt.wireframeLinewidth = bt.wireframeLinewidth),
                bt.wireframeLinecap !== void 0 && (vt.wireframeLinecap = bt.wireframeLinecap),
                bt.wireframeLinejoin !== void 0 && (vt.wireframeLinejoin = bt.wireframeLinejoin),
                bt.rotation !== void 0 && (vt.rotation = bt.rotation),
                bt.polygonOffset !== void 0 && (vt.polygonOffset = bt.polygonOffset),
                bt.polygonOffsetFactor !== void 0 && (vt.polygonOffsetFactor = bt.polygonOffsetFactor),
                bt.polygonOffsetUnits !== void 0 && (vt.polygonOffsetUnits = bt.polygonOffsetUnits),
                bt.dithering !== void 0 && (vt.dithering = bt.dithering),
                bt.alphaToCoverage !== void 0 && (vt.alphaToCoverage = bt.alphaToCoverage),
                bt.premultipliedAlpha !== void 0 && (vt.premultipliedAlpha = bt.premultipliedAlpha),
                bt.toneMapped !== void 0 && (vt.toneMapped = bt.toneMapped),
                bt.normalScale !== void 0 && vt.normalScale !== void 0 && (Array.isArray(bt.normalScale) ? vt.normalScale.fromArray(bt.normalScale) : typeof bt.normalScale == "number" ? vt.normalScale.set(bt.normalScale, bt.normalScale) : o.console.warn("normalScale is not an array or number", bt.normalScale)),
                bt.reflectivity !== void 0 && (vt.reflectivity = bt.reflectivity),
                Object.entries(bt).forEach( ([St,At]) => {
                    St.startsWith("_") || At && At.resource && typeof At.resource == "string" && (vt[St] = deserializeObject(At, vt[St], !1, ut))
                }
                ),
                delete vt.userData.gltfExtensions[webgiMaterialExtrasExtension])
            }
            ),
            at && delete it.userData.gltfExtensions[webgiMaterialExtrasExtension]
        }
    }
})
  , gltfLightExtrasParser = d => o => ({
    name: "__" + webgiLightExtrasExtension,
    afterRoot: async c => {
        (c.scenes || (c.scene ? [c.scene] : [])).forEach(h => {
            h.traverse(_ => {
                var b, _e;
                if (!_.isLight)
                    return;
                const nt = (_e = (b = _.userData) === null || b === void 0 ? void 0 : b.gltfExtensions) === null || _e === void 0 ? void 0 : _e[webgiLightExtrasExtension];
                nt && (!_.shadow && nt.shadow && console.error("Light has no shadow, cannot import", _, nt),
                nt.shadow && _.shadow && (nt.shadow.bias !== void 0 && (_.shadow.bias = nt.shadow.bias),
                nt.shadow.normalBias !== void 0 && (_.shadow.normalBias = nt.shadow.normalBias),
                nt.shadow.radius !== void 0 && (_.shadow.radius = nt.shadow.radius),
                nt.shadow.mapSize !== void 0 && _.shadow.mapSize.fromArray(nt.shadow.mapSize),
                nt.shadow.camera !== void 0 && (_.shadow.camera = d.parseObject(nt.shadow.camera))),
                delete _.userData.gltfExtensions[webgiLightExtrasExtension])
            }
            )
        }
        )
    }
});
async function importViewer(d, o, c, h) {
    var _, b, _e;
    if (!h) {
        const pt = d.json.scenes || [];
        if (pt.length !== 1) {
            for (const ht of pt)
                await importViewer(d, o, c, ht);
            return
        }
        h = pt[0]
    }
    const nt = (_ = h.extensions) === null || _ === void 0 ? void 0 : _[viewerGLTFExtension];
    if (!nt)
        return;
    const it = [];
    Object.values(nt.resources).forEach(pt => {
        Object.values(pt).forEach(ht => {
            ht.url && (ht.url.type === "Uint16Array" && ht.url.data && it.push(ht.url),
            ht.url.type === "Uint8Array" && ht.url.data && it.push(ht.url))
        }
        )
    }
    );
    for (const pt of it) {
        const ht = pt.data.image
          , _t = d.json.images[ht]
          , vt = await d.getDependency("bufferView", _t.bufferView);
        if (_t.mimeType.startsWith("image/") && pt.type === "Uint16Array" && pt.encoding === "rgbe") {
            const bt = new Blob([vt]);
            let St = URL.createObjectURL(bt);
            (pt.encodingVersion || 1) < 2 && (St = "data:image/png;base64," + btoa(await bt.text())),
            pt.data = (await new RGBEPNGLoader().parseAsync(St, void 0, !0)).data,
            URL.revokeObjectURL(St),
            delete pt.encoding,
            delete pt.encodingVersion
        } else
            pt.data = vt
    }
    const at = {
        textures: {},
        materials: {}
    }
      , ut = nt.resources;
    if (ut.textures && d.json.textures)
        for (const [pt,ht] of [...Object.entries(ut.textures)]) {
            if (ht.uuid || !pt)
                continue;
            delete ut.textures[pt];
            const _t = d.json.textures.findIndex(vt => {
                var bt, St, At, Et, Pt, It, Dt;
                return ((bt = vt.extras) === null || bt === void 0 ? void 0 : bt.uuid) === pt || ((Et = (At = (St = d.json.samplers) === null || St === void 0 ? void 0 : St[vt.sampler]) === null || At === void 0 ? void 0 : At.extras) === null || Et === void 0 ? void 0 : Et.uuid) === pt || ((Dt = (It = (Pt = d.json.images) === null || Pt === void 0 ? void 0 : Pt[vt.source]) === null || It === void 0 ? void 0 : It.extras) === null || Dt === void 0 ? void 0 : Dt.t_uuid) === pt
            }
            );
            _t >= 0 && (at.textures[pt] = await d.getDependency("texture", _t))
        }
    if (ut.materials && d.json.materials)
        for (const [pt,ht] of [...Object.entries(ut.materials)]) {
            if (ht.uuid || !pt)
                continue;
            delete ut.materials[pt];
            const _t = d.json.materials.findIndex(vt => {
                var bt;
                return ((bt = vt.extras) === null || bt === void 0 ? void 0 : bt.uuid) === pt
            }
            );
            _t >= 0 && (at.materials[pt] = await d.getDependency("material", _t),
            at.materials[pt] = (_e = (b = o.getPlugin(AssetManagerPlugin)) === null || b === void 0 ? void 0 : b.materials) === null || _e === void 0 ? void 0 : _e.processMaterial(at.materials[pt], {}))
        }
    return nt.resources = await o.getPlugin(AssetManagerPlugin).importConfigResources(ut || {}, c, at),
    nt
}
class GLTFMaterialsBumpMapExtension {
    constructor(o) {
        this.parser = o,
        this.name = GLTFMaterialsBumpMapExtensionName
    }
    async extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.bumpScale !== void 0 && (c.bumpScale = _e.bumpScale),
        _e.bumpTexture !== void 0 && b.push(h.assignTexture(c, "bumpMap", _e.bumpTexture)),
        Promise.all(b)
    }
}
class GLTFMaterialsDisplacementMapExtension {
    constructor(o) {
        this.parser = o,
        this.name = GLTFMaterialsDisplacementMapExtensionName
    }
    async extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.displacementScale !== void 0 && (c.displacementScale = _e.displacementScale),
        _e.displacementBias !== void 0 && (c.displacementBias = _e.displacementBias),
        _e.displacementTexture !== void 0 && b.push(h.assignTexture(c, "displacementMap", _e.displacementTexture)),
        Promise.all(b)
    }
}
class GLTFMaterialsLightMapExtension {
    constructor(o) {
        this.parser = o,
        this.name = GLTFMaterialsLightMapExtensionName
    }
    async extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.lightMapIntensity !== void 0 && (c.lightMapIntensity = _e.lightMapIntensity),
        _e.lightMapTexture !== void 0 && b.push(h.assignTexture(c, "lightMap", _e.lightMapTexture)),
        Promise.all(b)
    }
}
class GLTFMaterialsAlphaMapExtension {
    constructor(o) {
        this.parser = o,
        this.name = GLTFMaterialsAlphaMapExtensionName
    }
    async extendMaterialParams(o, c) {
        const h = this.parser
          , _ = h.json.materials[o];
        if (!_.extensions || !_.extensions[this.name])
            return Promise.resolve();
        const b = []
          , _e = _.extensions[this.name];
        return _e.alphaTexture !== void 0 && b.push(h.assignTexture(c, "alphaMap", _e.alphaTexture)),
        Promise.all(b)
    }
}
var DRACOLoader2 = __webpackgi_require__(957);
function addDracoLoader() {
    return new Importer(DRACOLoader2.Z,["drc"],!0)
}
class DirectionalLight2 extends three_module.ZyN {
    get lightObject() {
        return this
    }
    get modelObject() {
        return this
    }
    constructor(o, c) {
        super(),
        this.assetType = "light",
        this.isDirectionalLight2 = !0,
        this.color = new three_module.Q1f(o),
        this.intensity = c || 1,
        this.target.position.set(0, 0, -1),
        this.add(this.target)
    }
    copy(o, c) {
        const h = this.target
          , _ = o.userData;
        return o.userData = {},
        super.copy(o, c),
        copyObject3DUserData(this.userData, _),
        h.position.copy(this.target.position),
        h.updateMatrixWorld(),
        this.target = h,
        this
    }
    get uiConfig() {
        return this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "folder",
            label: "Directional Light",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "visible"]
            }, {
                type: "color",
                label: "Color",
                property: [this, "color"]
            }, {
                type: "slider",
                label: "Intensity",
                bounds: [0, 40],
                property: [this, "intensity"]
            }, {
                type: "vec3",
                label: "Rotation",
                property: [this, "rotation"]
            }, {
                type: "vec3",
                label: "Position",
                property: [this, "position"]
            }, {
                type: "checkbox",
                label: "Shadow Enabled",
                property: [this, "castShadow"]
            }, {
                type: "vec2",
                label: "Shadow Map Size",
                property: [this == null ? void 0 : this.shadow, "mapSize"],
                onChange: () => {
                    var o, c;
                    (o = this.shadow.map) === null || o === void 0 || o.dispose(),
                    (c = this.shadow.mapPass) === null || c === void 0 || c.dispose(),
                    this.shadow.map = null,
                    this.shadow.mapPass = null
                }
            }, {
                type: "slider",
                bounds: [-.001, .001],
                stepSize: 2e-5,
                label: "Shadow Bias",
                property: [this == null ? void 0 : this.shadow, "bias"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [-.1, .1],
                stepSize: .005,
                label: "Shadow Normal Bias",
                property: [this == null ? void 0 : this.shadow, "normalBias"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 5],
                label: "Shadow radius",
                property: [this == null ? void 0 : this.shadow, "radius"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [.1, 50],
                label: "Shadow frustum",
                getValue: () => 2 * this.shadow.camera.right,
                setValue: o => {
                    this.shadow.camera.left = -o / 2,
                    this.shadow.camera.right = o / 2,
                    this.shadow.camera.top = o / 2,
                    this.shadow.camera.bottom = -o / 2
                }
                ,
                onChange: this.setDirty
            }]
        }
    }
    toJSON(o) {
        const {userData: c, children: h} = this;
        this.userData = {},
        this.children = [];
        const _ = super.toJSON(o);
        return _.userData = serializeObject(copyObject3DUserData({}, c), !1),
        this.userData = c,
        this.children = h,
        _.type = "DirectionalLight2",
        _.target = this.target.position.toArray(),
        Object.assign(_, serializeObject(this, !0, o))
    }
    fromJSON(o, c) {
        if (o.type !== "DirectionalLight2")
            return null;
        const h = o.target
          , _ = o.object;
        return o.target && (this.target.position.fromArray(o.target),
        this.target.updateMatrixWorld(),
        delete o.target),
        o.object && delete o.object,
        deserializeObject(o, this, !0, c),
        h && (o.target = h),
        _ && (_.color !== void 0 && this.color.set(_.color),
        _.intensity !== void 0 && (this.intensity = _.intensity),
        o.object = _),
        this
    }
}
class SpotLight2 extends three_module.nCl {
    get lightObject() {
        return this
    }
    get modelObject() {
        return this
    }
    constructor(o, c, h, _, b, _e) {
        super(o, c, h, _, b, _e),
        this.assetType = "light",
        this.target.position.set(0, 0, -1),
        this.add(this.target)
    }
    copy(o, c) {
        const h = this.target
          , _ = o.userData;
        return o.userData = {},
        super.copy(o, c),
        copyObject3DUserData(this.userData, _),
        h.position.copy(this.target.position),
        h.updateMatrixWorld(),
        this.target = h,
        this
    }
    get uiConfig() {
        return this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "folder",
            label: "Spot Light",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "visible"]
            }, {
                type: "color",
                label: "Color",
                property: [this, "color"]
            }, {
                type: "slider",
                label: "Intensity",
                bounds: [0, 30],
                property: [this, "intensity"]
            }, {
                type: "slider",
                bounds: [0, 2],
                property: [this, "angle"]
            }, {
                type: "slider",
                bounds: [0, .9999],
                property: [this, "penumbra"]
            }, {
                type: "vec3",
                label: "Rotation",
                property: [this, "rotation"]
            }, {
                type: "vec3",
                label: "Position",
                property: [this, "position"]
            }, {
                type: "checkbox",
                label: "Shadow Enabled",
                property: [this, "castShadow"]
            }, {
                type: "vec2",
                label: "Shadow Map Size",
                property: [this == null ? void 0 : this.shadow, "mapSize"],
                onChange: () => {
                    var o, c;
                    (o = this.shadow.map) === null || o === void 0 || o.dispose(),
                    (c = this.shadow.mapPass) === null || c === void 0 || c.dispose(),
                    this.shadow.map = null,
                    this.shadow.mapPass = null
                }
            }, {
                type: "slider",
                bounds: [-.001, .001],
                stepSize: 2e-5,
                label: "Shadow Bias",
                property: [this == null ? void 0 : this.shadow, "bias"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 5],
                label: "Shadow radius",
                property: [this == null ? void 0 : this.shadow, "radius"],
                onChange: this.setDirty
            }]
        }
    }
    toJSON(o) {
        const {userData: c, children: h} = this;
        this.userData = {},
        this.children = [];
        const _ = super.toJSON(o);
        return _.userData = serializeObject(copyObject3DUserData({}, c), !1),
        this.userData = c,
        this.children = h,
        _.type = "SpotLight2",
        _.target = this.target.position.toArray(),
        Object.assign(_, serializeObject(this, !0, o))
    }
    fromJSON(o, c) {
        return o.type !== "SpotLight2" ? null : (o.target && (this.target.position.fromArray(o.target),
        this.target.updateMatrixWorld()),
        o.object ? (o.object.color !== void 0 && this.color.set(o.object.color),
        o.object.intensity !== void 0 && (this.intensity = o.object.intensity),
        o.object.distance !== void 0 && (this.distance = o.object.distance),
        o.object.angle !== void 0 && (this.angle = o.object.angle),
        o.object.decay !== void 0 && (this.decay = o.object.decay),
        o.object.penumbra !== void 0 && (this.penumbra = o.object.penumbra),
        deserializeObject(o, this, !0, c),
        this) : this)
    }
}
class PointLight2 extends three_module.HiM {
    get lightObject() {
        return this
    }
    get modelObject() {
        return this
    }
    constructor(o, c, h, _) {
        super(o, c, h, _),
        this.assetType = "light"
    }
    copy(o, c) {
        const h = o.userData;
        return o.userData = {},
        super.copy(o, c),
        copyObject3DUserData(this.userData, h),
        this
    }
    get uiConfig() {
        return this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "folder",
            label: "Point Light",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "visible"]
            }, {
                type: "color",
                label: "Color",
                property: [this, "color"]
            }, {
                type: "slider",
                label: "Intensity",
                bounds: [0, 20],
                property: [this, "intensity"]
            }, {
                type: "input",
                label: "Distance",
                property: [this, "distance"]
            }, {
                type: "input",
                property: [this, "decay"]
            }, {
                type: "vec3",
                label: "Position",
                property: [this, "position"]
            }, {
                type: "checkbox",
                label: "Shadow Enabled",
                property: [this, "castShadow"]
            }, {
                type: "vec2",
                label: "Shadow Map Size",
                property: [this == null ? void 0 : this.shadow, "mapSize"],
                onChange: () => {
                    var o, c;
                    (o = this.shadow.map) === null || o === void 0 || o.dispose(),
                    (c = this.shadow.mapPass) === null || c === void 0 || c.dispose(),
                    this.shadow.map = null,
                    this.shadow.mapPass = null
                }
            }, {
                type: "slider",
                bounds: [-.001, .001],
                stepSize: 2e-5,
                label: "Shadow Bias",
                property: [this == null ? void 0 : this.shadow, "bias"],
                onChange: this.setDirty
            }, {
                type: "slider",
                bounds: [0, 5],
                label: "Shadow radius",
                property: [this == null ? void 0 : this.shadow, "radius"],
                onChange: this.setDirty
            }]
        }
    }
    toJSON(o) {
        const {userData: c} = this;
        this.userData = {};
        const h = super.toJSON(o);
        return h.userData = serializeObject(copyObject3DUserData({}, c), !1),
        this.userData = c,
        h.type = "PointLight2",
        Object.assign(h, serializeObject(this, !0, o))
    }
    fromJSON(o, c) {
        return o.type !== "PointLight2" ? null : o.object ? (o.object.color !== void 0 && this.color.set(o.object.color),
        o.object.intensity !== void 0 && (this.intensity = o.object.intensity),
        o.object.distance !== void 0 && (this.distance = o.object.distance),
        o.object.decay !== void 0 && (this.decay = o.object.decay),
        deserializeObject(o, this, !0, c),
        this) : this
    }
}
class AmbientLight2 extends three_module.$p8 {
    get lightObject() {
        return this
    }
    get modelObject() {
        return this
    }
    constructor(o, c) {
        super(o, c),
        this.assetType = "light"
    }
    copy(o, c) {
        const h = o.userData;
        return o.userData = {},
        super.copy(o, c),
        copyObject3DUserData(this.userData, h),
        this
    }
    get uiConfig() {
        return this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "folder",
            label: "Ambient Light",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "visible"]
            }, {
                type: "color",
                label: "Color",
                property: [this, "color"]
            }, {
                type: "slider",
                label: "Intensity",
                bounds: [0, 20],
                property: [this, "intensity"]
            }]
        }
    }
    toJSON(o) {
        const {userData: c} = this;
        this.userData = {};
        const h = super.toJSON(o);
        return h.userData = serializeObject(copyObject3DUserData({}, c), !1),
        this.userData = c,
        h.type = "AmbientLight2",
        Object.assign(h, serializeObject(this, !0, o))
    }
    fromJSON(o, c) {
        return o.type !== "AmbientLight2" ? null : o.object ? (o.object.color !== void 0 && this.color.set(o.object.color),
        o.object.intensity !== void 0 && (this.intensity = o.object.intensity),
        deserializeObject(o, this, !0, c),
        this) : this
    }
}
class LUTCubeLoader extends three_module.aHM {
    load(o, c, h, _) {
        const b = new three_module.Y9S(this.manager);
        b.setPath(this.path),
        b.setResponseType("text"),
        b.load(o, _e => {
            try {
                c(this.parse(_e))
            } catch (nt) {
                _ ? _(nt) : console.error(nt),
                this.manager.itemError(o)
            }
        }
        , h, _)
    }
    parse(o) {
        o = o.replace(/^#.*?(\n|\r)/gm, "").replace(/^\s*?(\n|\r)/gm, "").trim();
        let c = null
          , h = null;
        const _ = new three_module.Pq0(0,0,0)
          , b = new three_module.Pq0(1,1,1)
          , _e = o.split(/[\n\r]+/g);
        let nt = null
          , it = 0;
        for (let pt = 0, ht = _e.length; pt < ht; pt++) {
            const _t = _e[pt].trim()
              , vt = _t.split(/\s/g);
            switch (vt[0]) {
            case "TITLE":
                c = _t.substring(7, _t.length - 1);
                break;
            case "LUT_3D_SIZE":
                const bt = vt[1];
                h = parseFloat(bt),
                nt = new Uint8Array(h * h * h * 4);
                break;
            case "DOMAIN_MIN":
                _.x = parseFloat(vt[1]),
                _.y = parseFloat(vt[2]),
                _.z = parseFloat(vt[3]);
                break;
            case "DOMAIN_MAX":
                b.x = parseFloat(vt[1]),
                b.y = parseFloat(vt[2]),
                b.z = parseFloat(vt[3]);
                break;
            default:
                const St = parseFloat(vt[0])
                  , At = parseFloat(vt[1])
                  , Et = parseFloat(vt[2]);
                if (St > 1 || St < 0 || At > 1 || At < 0 || Et > 1 || Et < 0)
                    throw new Error("LUTCubeLoader : Non normalized values not supported.");
                nt[it + 0] = 255 * St,
                nt[it + 1] = 255 * At,
                nt[it + 2] = 255 * Et,
                nt[it + 3] = 255,
                it += 4
            }
        }
        const at = new three_module.GYF;
        at.image.data = nt,
        at.image.width = h,
        at.image.height = h * h,
        at.type = three_module.OUM,
        at.magFilter = three_module.k6q,
        at.minFilter = three_module.k6q,
        at.wrapS = three_module.ghU,
        at.wrapT = three_module.ghU,
        at.generateMipmaps = !1,
        at.needsUpdate = !0;
        const ut = new three_module.dYF;
        return ut.image.data = nt,
        ut.image.width = h,
        ut.image.height = h,
        ut.image.depth = h,
        ut.type = three_module.OUM,
        ut.magFilter = three_module.k6q,
        ut.minFilter = three_module.k6q,
        ut.wrapS = three_module.ghU,
        ut.wrapT = three_module.ghU,
        ut.wrapR = three_module.ghU,
        ut.generateMipmaps = !1,
        ut.needsUpdate = !0,
        {
            title: c,
            size: h,
            domainMin: _,
            domainMax: b,
            texture: at,
            texture3D: ut
        }
    }
}
var LUTCubeLoader2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let LUTCubeTextureWrapper = class {
    constructor({domainMax: d, domainMin: o, size: c, texture: h, texture3D: _, title: b}) {
        this.userData = {},
        this.type = "LUTCubeTextureWrapper",
        this.assetType = "lutTexture",
        this.domainMax = d,
        this.domainMin = o,
        this.size = c,
        this.texture = h,
        this.texture3D = _,
        this.title = b,
        this.uuid = three_module.cj9.generateUUID(),
        this.userData.__needsSourceBuffer = !0
    }
    fromJSON(d, o) {
        return d.type !== this.type && console.warn("WebGi LUTCubeLoader2: type mismatch while import", d, this),
        console.error("not supported"),
        this
    }
    toJSON(d) {
        return serializeTextureInExtras(this, d, this.texture.name)
    }
}
;
LUTCubeTextureWrapper = LUTCubeLoader2_decorate([serializable("LUTCubeTextureWrapper")], LUTCubeTextureWrapper);
class LUTCubeLoader2 extends LUTCubeLoader {
    parse(o) {
        const c = super.parse(o);
        return new LUTCubeTextureWrapper(c)
    }
}
var ch2 = {}
  , wk$1 = function(d, o, c, h, _) {
    var b = new Worker(ch2[o] || (ch2[o] = URL.createObjectURL(new Blob([d],{
        type: "text/javascript"
    }))));
    return b.onerror = function(_e) {
        return _(_e.error, null)
    }
    ,
    b.onmessage = function(_e) {
        return _(null, _e.data)
    }
    ,
    b.postMessage(c, h),
    b
}
  , u8 = Uint8Array
  , u16 = Uint16Array
  , u32 = Uint32Array
  , fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , freb = function(d, o) {
    for (var c = new u16(31), h = 0; h < 31; ++h)
        c[h] = o += 1 << d[h - 1];
    var _ = new u32(c[30]);
    for (h = 1; h < 30; ++h)
        for (var b = c[h]; b < c[h + 1]; ++b)
            _[b] = b - c[h] << 5 | h;
    return [c, _]
}
  , _a = freb(fleb, 2)
  , fl$1 = _a[0]
  , revfl = _a[1];
fl$1[28] = 258,
revfl[258] = 28;
for (var _b = freb(fdeb, 0), fd$1 = _b[0], revfd = _b[1], rev = new u16(32768), browser_i = 0; browser_i < 32768; ++browser_i) {
    var browser_x = (43690 & browser_i) >>> 1 | (21845 & browser_i) << 1;
    browser_x = (52428 & browser_x) >>> 2 | (13107 & browser_x) << 2,
    browser_x = (61680 & browser_x) >>> 4 | (3855 & browser_x) << 4,
    rev[browser_i] = ((65280 & browser_x) >>> 8 | (255 & browser_x) << 8) >>> 1
}
for (var hMap = function(o, c, h) {
    for (var _ = o.length, b = 0, _e = new u16(c); b < _; ++b)
        ++_e[o[b] - 1];
    var nt, it = new u16(c);
    for (b = 0; b < c; ++b)
        it[b] = it[b - 1] + _e[b - 1] << 1;
    if (h) {
        nt = new u16(1 << c);
        var at = 15 - c;
        for (b = 0; b < _; ++b)
            if (o[b])
                for (var ut = b << 4 | o[b], pt = c - o[b], ht = it[o[b] - 1]++ << pt, _t = ht | (1 << pt) - 1; ht <= _t; ++ht)
                    nt[rev[ht] >>> at] = ut
    } else
        for (nt = new u16(_),
        b = 0; b < _; ++b)
            o[b] && (nt[b] = rev[it[o[b] - 1]++] >>> 15 - o[b]);
    return nt
}, flt = new u8(288), browser_i = 0; browser_i < 144; ++browser_i)
    flt[browser_i] = 8;
for (var browser_i = 144; browser_i < 256; ++browser_i)
    flt[browser_i] = 9;
for (var browser_i = 256; browser_i < 280; ++browser_i)
    flt[browser_i] = 7;
for (var browser_i = 280; browser_i < 288; ++browser_i)
    flt[browser_i] = 8;
for (var fdt = new u8(32), browser_i = 0; browser_i < 32; ++browser_i)
    fdt[browser_i] = 5;
var flm = hMap(flt, 9, 0)
  , flrm = hMap(flt, 9, 1)
  , fdm = hMap(fdt, 5, 0)
  , fdrm = hMap(fdt, 5, 1)
  , max = function(d) {
    for (var o = d[0], c = 1; c < d.length; ++c)
        d[c] > o && (o = d[c]);
    return o
}
  , bits = function(d, o, c) {
    var h = o / 8 | 0;
    return (d[h] | d[h + 1] << 8) >> (7 & o) & c
}
  , bits16 = function(d, o) {
    var c = o / 8 | 0;
    return (d[c] | d[c + 1] << 8 | d[c + 2] << 16) >> (7 & o)
}
  , shft = function(d) {
    return (d / 8 | 0) + (7 & d && 1)
}
  , slc = function(d, o, c) {
    (o == null || o < 0) && (o = 0),
    (c == null || c > d.length) && (c = d.length);
    var h = new (d instanceof u16 ? u16 : d instanceof u32 ? u32 : u8)(c - o);
    return h.set(d.subarray(o, c)),
    h
}
  , inflt = function(d, o, c) {
    var h = d.length;
    if (!h || c && !c.l && h < 5)
        return o || new u8(0);
    var _ = !o || c
      , b = !c || c.i;
    c || (c = {}),
    o || (o = new u8(3 * h));
    var _e = function(fr) {
        var vr = o.length;
        if (fr > vr) {
            var Zr = new u8(Math.max(2 * vr, fr));
            Zr.set(o),
            o = Zr
        }
    }
      , nt = c.f || 0
      , it = c.p || 0
      , at = c.b || 0
      , ut = c.l
      , pt = c.d
      , ht = c.m
      , _t = c.n
      , vt = 8 * h;
    do {
        if (!ut) {
            c.f = nt = bits(d, it, 1);
            var bt = bits(d, it + 1, 3);
            if (it += 3,
            !bt) {
                var St = d[(Kt = shft(it) + 4) - 4] | d[Kt - 3] << 8
                  , At = Kt + St;
                if (At > h) {
                    if (b)
                        throw "unexpected EOF";
                    break
                }
                _ && _e(at + St),
                o.set(d.subarray(Kt, At), at),
                c.b = at += St,
                c.p = it = 8 * At;
                continue
            }
            if (bt == 1)
                ut = flrm,
                pt = fdrm,
                ht = 9,
                _t = 5;
            else {
                if (bt != 2)
                    throw "invalid block type";
                var Et = bits(d, it, 31) + 257
                  , Pt = bits(d, it + 10, 15) + 4
                  , It = Et + bits(d, it + 5, 31) + 1;
                it += 14;
                for (var Dt = new u8(It), Gt = new u8(19), Bt = 0; Bt < Pt; ++Bt)
                    Gt[clim[Bt]] = bits(d, it + 3 * Bt, 7);
                it += 3 * Pt;
                var kt = max(Gt)
                  , Ut = (1 << kt) - 1
                  , Ht = hMap(Gt, kt, 1);
                for (Bt = 0; Bt < It; ) {
                    var Kt, Jt = Ht[bits(d, it, Ut)];
                    if (it += 15 & Jt,
                    (Kt = Jt >>> 4) < 16)
                        Dt[Bt++] = Kt;
                    else {
                        var or = 0
                          , ir = 0;
                        for (Kt == 16 ? (ir = 3 + bits(d, it, 3),
                        it += 2,
                        or = Dt[Bt - 1]) : Kt == 17 ? (ir = 3 + bits(d, it, 7),
                        it += 3) : Kt == 18 && (ir = 11 + bits(d, it, 127),
                        it += 7); ir--; )
                            Dt[Bt++] = or
                    }
                }
                var lr = Dt.subarray(0, Et)
                  , ar = Dt.subarray(Et);
                ht = max(lr),
                _t = max(ar),
                ut = hMap(lr, ht, 1),
                pt = hMap(ar, _t, 1)
            }
            if (it > vt) {
                if (b)
                    throw "unexpected EOF";
                break
            }
        }
        _ && _e(at + 131072);
        for (var hr = (1 << ht) - 1, gr = (1 << _t) - 1, dr = it; ; dr = it) {
            var cr = (or = ut[bits16(d, it) & hr]) >>> 4;
            if ((it += 15 & or) > vt) {
                if (b)
                    throw "unexpected EOF";
                break
            }
            if (!or)
                throw "invalid length/literal";
            if (cr < 256)
                o[at++] = cr;
            else {
                if (cr == 256) {
                    dr = it,
                    ut = null;
                    break
                }
                var Ar = cr - 254;
                if (cr > 264) {
                    var wr = fleb[Bt = cr - 257];
                    Ar = bits(d, it, (1 << wr) - 1) + fl$1[Bt],
                    it += wr
                }
                var Rr = pt[bits16(d, it) & gr]
                  , Cr = Rr >>> 4;
                if (!Rr)
                    throw "invalid distance";
                if (it += 15 & Rr,
                ar = fd$1[Cr],
                Cr > 3 && (wr = fdeb[Cr],
                ar += bits16(d, it) & (1 << wr) - 1,
                it += wr),
                it > vt) {
                    if (b)
                        throw "unexpected EOF";
                    break
                }
                _ && _e(at + 131072);
                for (var tr = at + Ar; at < tr; at += 4)
                    o[at] = o[at - ar],
                    o[at + 1] = o[at + 1 - ar],
                    o[at + 2] = o[at + 2 - ar],
                    o[at + 3] = o[at + 3 - ar];
                at = tr
            }
        }
        c.l = ut,
        c.p = dr,
        c.b = at,
        ut && (nt = 1,
        c.m = ht,
        c.d = pt,
        c.n = _t)
    } while (!nt);
    return at == o.length ? o : slc(o, 0, at)
}
  , wbits = function(d, o, c) {
    c <<= 7 & o;
    var h = o / 8 | 0;
    d[h] |= c,
    d[h + 1] |= c >>> 8
}
  , wbits16 = function(d, o, c) {
    c <<= 7 & o;
    var h = o / 8 | 0;
    d[h] |= c,
    d[h + 1] |= c >>> 8,
    d[h + 2] |= c >>> 16
}
  , hTree = function(d, o) {
    for (var c = [], h = 0; h < d.length; ++h)
        d[h] && c.push({
            s: h,
            f: d[h]
        });
    var _ = c.length
      , b = c.slice();
    if (!_)
        return [browser_et, 0];
    if (_ == 1) {
        var _e = new u8(c[0].s + 1);
        return _e[c[0].s] = 1,
        [_e, 1]
    }
    c.sort(function(Dt, Gt) {
        return Dt.f - Gt.f
    }),
    c.push({
        s: -1,
        f: 25001
    });
    var nt = c[0]
      , it = c[1]
      , at = 0
      , ut = 1
      , pt = 2;
    for (c[0] = {
        s: -1,
        f: nt.f + it.f,
        l: nt,
        r: it
    }; ut != _ - 1; )
        nt = c[c[at].f < c[pt].f ? at++ : pt++],
        it = c[at != ut && c[at].f < c[pt].f ? at++ : pt++],
        c[ut++] = {
            s: -1,
            f: nt.f + it.f,
            l: nt,
            r: it
        };
    var ht = b[0].s;
    for (h = 1; h < _; ++h)
        b[h].s > ht && (ht = b[h].s);
    var _t = new u16(ht + 1)
      , vt = ln(c[ut - 1], _t, 0);
    if (vt > o) {
        h = 0;
        var bt = 0
          , St = vt - o
          , At = 1 << St;
        for (b.sort(function(Dt, Gt) {
            return _t[Gt.s] - _t[Dt.s] || Dt.f - Gt.f
        }); h < _; ++h) {
            var Et = b[h].s;
            if (!(_t[Et] > o))
                break;
            bt += At - (1 << vt - _t[Et]),
            _t[Et] = o
        }
        for (bt >>>= St; bt > 0; ) {
            var Pt = b[h].s;
            _t[Pt] < o ? bt -= 1 << o - _t[Pt]++ - 1 : ++h
        }
        for (; h >= 0 && bt; --h) {
            var It = b[h].s;
            _t[It] == o && (--_t[It],
            ++bt)
        }
        vt = o
    }
    return [new u8(_t), vt]
}
  , ln = function(d, o, c) {
    return d.s == -1 ? Math.max(ln(d.l, o, c + 1), ln(d.r, o, c + 1)) : o[d.s] = c
}
  , lc$1 = function(d) {
    for (var o = d.length; o && !d[--o]; )
        ;
    for (var c = new u16(++o), h = 0, _ = d[0], b = 1, _e = function(it) {
        c[h++] = it
    }, nt = 1; nt <= o; ++nt)
        if (d[nt] == _ && nt != o)
            ++b;
        else {
            if (!_ && b > 2) {
                for (; b > 138; b -= 138)
                    _e(32754);
                b > 2 && (_e(b > 10 ? b - 11 << 5 | 28690 : b - 3 << 5 | 12305),
                b = 0)
            } else if (b > 3) {
                for (_e(_),
                --b; b > 6; b -= 6)
                    _e(8304);
                b > 2 && (_e(b - 3 << 5 | 8208),
                b = 0)
            }
            for (; b--; )
                _e(_);
            b = 1,
            _ = d[nt]
        }
    return [c.subarray(0, h), o]
}
  , clen = function(d, o) {
    for (var c = 0, h = 0; h < o.length; ++h)
        c += d[h] * o[h];
    return c
}
  , wfblk = function(d, o, c) {
    var h = c.length
      , _ = shft(o + 2);
    d[_] = 255 & h,
    d[_ + 1] = h >>> 8,
    d[_ + 2] = 255 ^ d[_],
    d[_ + 3] = 255 ^ d[_ + 1];
    for (var b = 0; b < h; ++b)
        d[_ + b + 4] = c[b];
    return 8 * (_ + 4 + h)
}
  , wblk = function(d, o, c, h, _, b, _e, nt, it, at, ut) {
    wbits(o, ut++, c),
    ++_[256];
    for (var pt = hTree(_, 15), ht = pt[0], _t = pt[1], vt = hTree(b, 15), bt = vt[0], St = vt[1], At = lc$1(ht), Et = At[0], Pt = At[1], It = lc$1(bt), Dt = It[0], Gt = It[1], Bt = new u16(19), kt = 0; kt < Et.length; ++kt)
        Bt[31 & Et[kt]]++;
    for (kt = 0; kt < Dt.length; ++kt)
        Bt[31 & Dt[kt]]++;
    for (var Ut = hTree(Bt, 7), Ht = Ut[0], Kt = Ut[1], Jt = 19; Jt > 4 && !Ht[clim[Jt - 1]]; --Jt)
        ;
    var or, ir, lr, ar, hr = at + 5 << 3, gr = clen(_, flt) + clen(b, fdt) + _e, dr = clen(_, ht) + clen(b, bt) + _e + 14 + 3 * Jt + clen(Bt, Ht) + (2 * Bt[16] + 3 * Bt[17] + 7 * Bt[18]);
    if (hr <= gr && hr <= dr)
        return wfblk(o, ut, d.subarray(it, it + at));
    if (wbits(o, ut, 1 + (dr < gr)),
    ut += 2,
    dr < gr) {
        or = hMap(ht, _t, 0),
        ir = ht,
        lr = hMap(bt, St, 0),
        ar = bt;
        var cr = hMap(Ht, Kt, 0);
        for (wbits(o, ut, Pt - 257),
        wbits(o, ut + 5, Gt - 1),
        wbits(o, ut + 10, Jt - 4),
        ut += 14,
        kt = 0; kt < Jt; ++kt)
            wbits(o, ut + 3 * kt, Ht[clim[kt]]);
        ut += 3 * Jt;
        for (var Ar = [Et, Dt], wr = 0; wr < 2; ++wr) {
            var Rr = Ar[wr];
            for (kt = 0; kt < Rr.length; ++kt) {
                var Cr = 31 & Rr[kt];
                wbits(o, ut, cr[Cr]),
                ut += Ht[Cr],
                Cr > 15 && (wbits(o, ut, Rr[kt] >>> 5 & 127),
                ut += Rr[kt] >>> 12)
            }
        }
    } else
        or = flm,
        ir = flt,
        lr = fdm,
        ar = fdt;
    for (kt = 0; kt < nt; ++kt)
        if (h[kt] > 255) {
            Cr = h[kt] >>> 18 & 31,
            wbits16(o, ut, or[Cr + 257]),
            ut += ir[Cr + 257],
            Cr > 7 && (wbits(o, ut, h[kt] >>> 23 & 31),
            ut += fleb[Cr]);
            var tr = 31 & h[kt];
            wbits16(o, ut, lr[tr]),
            ut += ar[tr],
            tr > 3 && (wbits16(o, ut, h[kt] >>> 5 & 8191),
            ut += fdeb[tr])
        } else
            wbits16(o, ut, or[h[kt]]),
            ut += ir[h[kt]];
    return wbits16(o, ut, or[256]),
    ut + ir[256]
}
  , deo = new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
  , browser_et = new u8(0)
  , dflt = function(d, o, c, h, _, b) {
    var _e = d.length
      , nt = new u8(h + _e + 5 * (1 + Math.ceil(_e / 7e3)) + _)
      , it = nt.subarray(h, nt.length - _)
      , at = 0;
    if (!o || _e < 8)
        for (var ut = 0; ut <= _e; ut += 65535) {
            var pt = ut + 65535;
            pt < _e ? at = wfblk(it, at, d.subarray(ut, pt)) : (it[ut] = b,
            at = wfblk(it, at, d.subarray(ut, _e)))
        }
    else {
        for (var ht = deo[o - 1], _t = ht >>> 13, vt = 8191 & ht, bt = (1 << c) - 1, St = new u16(32768), At = new u16(bt + 1), Et = Math.ceil(c / 3), Pt = 2 * Et, It = function(Wn) {
            return (d[Wn] ^ d[Wn + 1] << Et ^ d[Wn + 2] << Pt) & bt
        }, Dt = new u32(25e3), Gt = new u16(288), Bt = new u16(32), kt = 0, Ut = 0, Ht = (ut = 0,
        0), Kt = 0, Jt = 0; ut < _e; ++ut) {
            var or = It(ut)
              , ir = 32767 & ut
              , lr = At[or];
            if (St[ir] = lr,
            At[or] = ir,
            Kt <= ut) {
                var ar = _e - ut;
                if ((kt > 7e3 || Ht > 24576) && ar > 423) {
                    at = wblk(d, it, 0, Dt, Gt, Bt, Ut, Ht, Jt, ut - Jt, at),
                    Ht = kt = Ut = 0,
                    Jt = ut;
                    for (var hr = 0; hr < 286; ++hr)
                        Gt[hr] = 0;
                    for (hr = 0; hr < 30; ++hr)
                        Bt[hr] = 0
                }
                var gr = 2
                  , dr = 0
                  , cr = vt
                  , Ar = ir - lr & 32767;
                if (ar > 2 && or == It(ut - Ar))
                    for (var wr = Math.min(_t, ar) - 1, Rr = Math.min(32767, ut), Cr = Math.min(258, ar); Ar <= Rr && --cr && ir != lr; ) {
                        if (d[ut + gr] == d[ut + gr - Ar]) {
                            for (var tr = 0; tr < Cr && d[ut + tr] == d[ut + tr - Ar]; ++tr)
                                ;
                            if (tr > gr) {
                                if (gr = tr,
                                dr = Ar,
                                tr > wr)
                                    break;
                                var fr = Math.min(Ar, tr - 2)
                                  , vr = 0;
                                for (hr = 0; hr < fr; ++hr) {
                                    var Zr = ut - Ar + hr + 32768 & 32767
                                      , rn = Zr - St[Zr] + 32768 & 32767;
                                    rn > vr && (vr = rn,
                                    lr = Zr)
                                }
                            }
                        }
                        Ar += (ir = lr) - (lr = St[ir]) + 32768 & 32767
                    }
                if (dr) {
                    Dt[Ht++] = 268435456 | revfl[gr] << 18 | revfd[dr];
                    var hn = 31 & revfl[gr]
                      , Nn = 31 & revfd[dr];
                    Ut += fleb[hn] + fdeb[Nn],
                    ++Gt[257 + hn],
                    ++Bt[Nn],
                    Kt = ut + gr,
                    ++kt
                } else
                    Dt[Ht++] = d[ut],
                    ++Gt[d[ut]]
            }
        }
        at = wblk(d, it, b, Dt, Gt, Bt, Ut, Ht, Jt, ut - Jt, at),
        !b && 7 & at && (at = wfblk(it, at + 1, browser_et))
    }
    return slc(nt, 0, h + shft(at) + _)
}
  , crct = function() {
    for (var d = new Int32Array(256), o = 0; o < 256; ++o) {
        for (var c = o, h = 9; --h; )
            c = (1 & c && -306674912) ^ c >>> 1;
        d[o] = c
    }
    return d
}()
  , crc = function() {
    var d = -1;
    return {
        p: function(o) {
            for (var c = d, h = 0; h < o.length; ++h)
                c = crct[255 & c ^ o[h]] ^ c >>> 8;
            d = c
        },
        d: function() {
            return ~d
        }
    }
}
  , adler = function() {
    var d = 1
      , o = 0;
    return {
        p: function(c) {
            for (var h = d, _ = o, b = c.length, _e = 0; _e != b; ) {
                for (var nt = Math.min(_e + 2655, b); _e < nt; ++_e)
                    _ += h += c[_e];
                h = (65535 & h) + 15 * (h >> 16),
                _ = (65535 & _) + 15 * (_ >> 16)
            }
            d = h,
            o = _
        },
        d: function() {
            return (255 & (d %= 65521)) << 24 | d >>> 8 << 16 | (255 & (o %= 65521)) << 8 | o >>> 8
        }
    }
}
  , dopt = function(d, o, c, h, _) {
    return dflt(d, o.level == null ? 6 : o.level, o.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(d.length)))) : 12 + o.mem, c, h, !_)
}
  , mrg = function(d, o) {
    var c = {};
    for (var h in d)
        c[h] = d[h];
    for (var h in o)
        c[h] = o[h];
    return c
}
  , wcln = function(d, o, c) {
    for (var h = d(), _ = d.toString(), b = _.slice(_.indexOf("[") + 1, _.lastIndexOf("]")).replace(/ /g, "").split(","), _e = 0; _e < h.length; ++_e) {
        var nt = h[_e]
          , it = b[_e];
        if (typeof nt == "function") {
            o += ";" + it + "=";
            var at = nt.toString();
            if (nt.prototype)
                if (at.indexOf("[native code]") != -1) {
                    var ut = at.indexOf(" ", 8) + 1;
                    o += at.slice(ut, at.indexOf("(", ut))
                } else
                    for (var pt in o += at,
                    nt.prototype)
                        o += ";" + it + ".prototype." + pt + "=" + nt.prototype[pt].toString();
            else
                o += at
        } else
            c[it] = nt
    }
    return [o, c]
}
  , ch$1 = []
  , cbfs = function(d) {
    var o = [];
    for (var c in d)
        (d[c]instanceof u8 || d[c]instanceof u16 || d[c]instanceof u32) && o.push((d[c] = new d[c].constructor(d[c])).buffer);
    return o
}
  , wrkr = function(d, o, c, h) {
    var _;
    if (!ch$1[c]) {
        for (var b = "", _e = {}, nt = d.length - 1, it = 0; it < nt; ++it)
            b = (_ = wcln(d[it], b, _e))[0],
            _e = _[1];
        ch$1[c] = wcln(d[nt], b, _e)
    }
    var at = mrg({}, ch$1[c][1]);
    return wk$1(ch$1[c][0] + ";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=" + o.toString() + "}", c, at, cbfs(at), h)
}
  , bInflt = function() {
    return [u8, u16, u32, fleb, fdeb, clim, fl$1, fd$1, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]
}
  , bDflt = function() {
    return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, browser_et, hMap, wbits, wbits16, hTree, ln, lc$1, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]
}
  , gze = function() {
    return [gzh, gzhl, wbytes, crc, crct]
}
  , guze = function() {
    return [gzs, gzl]
}
  , zle = function() {
    return [zlh, wbytes, adler]
}
  , zule = function() {
    return [zlv]
}
  , pbf = function(d) {
    return postMessage(d, [d.buffer])
}
  , gu8 = function(d) {
    return d && d.size && new u8(d.size)
}
  , cbify = function(d, o, c, h, _, b) {
    var _e = wrkr(c, h, _, function(nt, it) {
        _e.terminate(),
        b(nt, it)
    });
    return _e.postMessage([d, o], o.consume ? [d.buffer] : []),
    function() {
        _e.terminate()
    }
}
  , astrm = function(d) {
    return d.ondata = function(o, c) {
        return postMessage([o, c], [o.buffer])
    }
    ,
    function(o) {
        return d.push(o.data[0], o.data[1])
    }
}
  , astrmify = function(d, o, c, h, _) {
    var b, _e = wrkr(d, h, _, function(nt, it) {
        nt ? (_e.terminate(),
        o.ondata.call(o, nt)) : (it[1] && _e.terminate(),
        o.ondata.call(o, nt, it[0], it[1]))
    });
    _e.postMessage(c),
    o.push = function(nt, it) {
        if (b)
            throw "stream finished";
        if (!o.ondata)
            throw "no stream handler";
        _e.postMessage([nt, b = it], [nt.buffer])
    }
    ,
    o.terminate = function() {
        _e.terminate()
    }
}
  , b2 = function(d, o) {
    return d[o] | d[o + 1] << 8
}
  , b4 = function(d, o) {
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16 | d[o + 3] << 24) >>> 0
}
  , b8 = function(d, o) {
    return b4(d, o) + 4294967296 * b4(d, o + 4)
}
  , wbytes = function(d, o, c) {
    for (; c; ++o)
        d[o] = c,
        c >>>= 8
}
  , gzh = function(d, o) {
    var c = o.filename;
    if (d[0] = 31,
    d[1] = 139,
    d[2] = 8,
    d[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0,
    d[9] = 3,
    o.mtime != 0 && wbytes(d, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3)),
    c) {
        d[3] = 8;
        for (var h = 0; h <= c.length; ++h)
            d[h + 10] = c.charCodeAt(h)
    }
}
  , gzs = function(d) {
    if (d[0] != 31 || d[1] != 139 || d[2] != 8)
        throw "invalid gzip data";
    var o = d[3]
      , c = 10;
    4 & o && (c += d[10] | 2 + (d[11] << 8));
    for (var h = (o >> 3 & 1) + (o >> 4 & 1); h > 0; h -= !d[c++])
        ;
    return c + (2 & o)
}
  , gzl = function(d) {
    var o = d.length;
    return (d[o - 4] | d[o - 3] << 8 | d[o - 2] << 16 | d[o - 1] << 24) >>> 0
}
  , gzhl = function(d) {
    return 10 + (d.filename && d.filename.length + 1 || 0)
}
  , zlh = function(d, o) {
    var c = o.level
      , h = c == 0 ? 0 : c < 6 ? 1 : c == 9 ? 3 : 2;
    d[0] = 120,
    d[1] = h << 6 | (h ? 32 - 2 * h : 1)
}
  , zlv = function(d) {
    if ((15 & d[0]) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        throw "invalid zlib data";
    if (32 & d[1])
        throw "invalid zlib data: preset dictionaries not supported"
};
function AsyncCmpStrm(d, o) {
    return o || typeof d != "function" || (o = d,
    d = {}),
    this.ondata = o,
    d
}
var Deflate = function() {
    function d(o, c) {
        c || typeof o != "function" || (c = o,
        o = {}),
        this.ondata = c,
        this.o = o || {}
    }
    return d.prototype.p = function(o, c) {
        this.ondata(dopt(o, this.o, 0, 0, !c), c)
    }
    ,
    d.prototype.push = function(o, c) {
        if (this.d)
            throw "stream finished";
        if (!this.ondata)
            throw "no stream handler";
        this.d = c,
        this.p(o, c || !1)
    }
    ,
    d
}()
  , AsyncDeflate = function() {
    return function(d, o) {
        astrmify([bDflt, function() {
            return [astrm, Deflate]
        }
        ], this, AsyncCmpStrm.call(this, d, o), function(c) {
            var h = new Deflate(c.data);
            onmessage = astrm(h)
        }, 6)
    }
}();
function deflate(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return cbify(d, o, [bDflt], function(h) {
        return pbf(deflateSync(h.data[0], h.data[1]))
    }, 0, c)
}
function deflateSync(d, o) {
    return dopt(d, o || {}, 0, 0)
}
var Inflate = function() {
    function d(o) {
        this.s = {},
        this.p = new u8(0),
        this.ondata = o
    }
    return d.prototype.e = function(o) {
        if (this.d)
            throw "stream finished";
        if (!this.ondata)
            throw "no stream handler";
        var c = this.p.length
          , h = new u8(c + o.length);
        h.set(this.p),
        h.set(o, c),
        this.p = h
    }
    ,
    d.prototype.c = function(o) {
        this.d = this.s.i = o || !1;
        var c = this.s.b
          , h = inflt(this.p, this.o, this.s);
        this.ondata(slc(h, c, this.s.b), this.d),
        this.o = slc(h, this.s.b - 32768),
        this.s.b = this.o.length,
        this.p = slc(this.p, this.s.p / 8 | 0),
        this.s.p &= 7
    }
    ,
    d.prototype.push = function(o, c) {
        this.e(o),
        this.c(c)
    }
    ,
    d
}()
  , AsyncInflate = function() {
    return function(d) {
        this.ondata = d,
        astrmify([bInflt, function() {
            return [astrm, Inflate]
        }
        ], this, 0, function() {
            var o = new Inflate;
            onmessage = astrm(o)
        }, 7)
    }
}();
function inflate(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return cbify(d, o, [bInflt], function(h) {
        return pbf(inflateSync(h.data[0], gu8(h.data[1])))
    }, 1, c)
}
function inflateSync(d, o) {
    return inflt(d, o)
}
var Gzip = function() {
    function d(o, c) {
        this.c = crc(),
        this.l = 0,
        this.v = 1,
        Deflate.call(this, o, c)
    }
    return d.prototype.push = function(o, c) {
        Deflate.prototype.push.call(this, o, c)
    }
    ,
    d.prototype.p = function(o, c) {
        this.c.p(o),
        this.l += o.length;
        var h = dopt(o, this.o, this.v && gzhl(this.o), c && 8, !c);
        this.v && (gzh(h, this.o),
        this.v = 0),
        c && (wbytes(h, h.length - 8, this.c.d()),
        wbytes(h, h.length - 4, this.l)),
        this.ondata(h, c)
    }
    ,
    d
}()
  , AsyncGzip = function() {
    return function(d, o) {
        astrmify([bDflt, gze, function() {
            return [astrm, Deflate, Gzip]
        }
        ], this, AsyncCmpStrm.call(this, d, o), function(c) {
            var h = new Gzip(c.data);
            onmessage = astrm(h)
        }, 8)
    }
}();
function gzip(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return cbify(d, o, [bDflt, gze, function() {
        return [gzipSync]
    }
    ], function(h) {
        return pbf(gzipSync(h.data[0], h.data[1]))
    }, 2, c)
}
function gzipSync(d, o) {
    o || (o = {});
    var c = crc()
      , h = d.length;
    c.p(d);
    var _ = dopt(d, o, gzhl(o), 8)
      , b = _.length;
    return gzh(_, o),
    wbytes(_, b - 8, c.d()),
    wbytes(_, b - 4, h),
    _
}
var Gunzip = function() {
    function d(o) {
        this.v = 1,
        Inflate.call(this, o)
    }
    return d.prototype.push = function(o, c) {
        if (Inflate.prototype.e.call(this, o),
        this.v) {
            var h = this.p.length > 3 ? gzs(this.p) : 4;
            if (h >= this.p.length && !c)
                return;
            this.p = this.p.subarray(h),
            this.v = 0
        }
        if (c) {
            if (this.p.length < 8)
                throw "invalid gzip stream";
            this.p = this.p.subarray(0, -8)
        }
        Inflate.prototype.c.call(this, c)
    }
    ,
    d
}()
  , AsyncGunzip = function() {
    return function(d) {
        this.ondata = d,
        astrmify([bInflt, guze, function() {
            return [astrm, Inflate, Gunzip]
        }
        ], this, 0, function() {
            var o = new Gunzip;
            onmessage = astrm(o)
        }, 9)
    }
}();
function gunzip(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return cbify(d, o, [bInflt, guze, function() {
        return [gunzipSync]
    }
    ], function(h) {
        return pbf(gunzipSync(h.data[0]))
    }, 3, c)
}
function gunzipSync(d, o) {
    return inflt(d.subarray(gzs(d), -8), o || new u8(gzl(d)))
}
var Zlib = function() {
    function d(o, c) {
        this.c = adler(),
        this.v = 1,
        Deflate.call(this, o, c)
    }
    return d.prototype.push = function(o, c) {
        Deflate.prototype.push.call(this, o, c)
    }
    ,
    d.prototype.p = function(o, c) {
        this.c.p(o);
        var h = dopt(o, this.o, this.v && 2, c && 4, !c);
        this.v && (zlh(h, this.o),
        this.v = 0),
        c && wbytes(h, h.length - 4, this.c.d()),
        this.ondata(h, c)
    }
    ,
    d
}()
  , AsyncZlib = function() {
    return function(d, o) {
        astrmify([bDflt, zle, function() {
            return [astrm, Deflate, Zlib]
        }
        ], this, AsyncCmpStrm.call(this, d, o), function(c) {
            var h = new Zlib(c.data);
            onmessage = astrm(h)
        }, 10)
    }
}();
function zlib(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return cbify(d, o, [bDflt, zle, function() {
        return [zlibSync]
    }
    ], function(h) {
        return pbf(zlibSync(h.data[0], h.data[1]))
    }, 4, c)
}
function zlibSync(d, o) {
    o || (o = {});
    var c = adler();
    c.p(d);
    var h = dopt(d, o, 2, 4);
    return zlh(h, o),
    wbytes(h, h.length - 4, c.d()),
    h
}
var Unzlib = function() {
    function d(o) {
        this.v = 1,
        Inflate.call(this, o)
    }
    return d.prototype.push = function(o, c) {
        if (Inflate.prototype.e.call(this, o),
        this.v) {
            if (this.p.length < 2 && !c)
                return;
            this.p = this.p.subarray(2),
            this.v = 0
        }
        if (c) {
            if (this.p.length < 4)
                throw "invalid zlib stream";
            this.p = this.p.subarray(0, -4)
        }
        Inflate.prototype.c.call(this, c)
    }
    ,
    d
}()
  , AsyncUnzlib = function() {
    return function(d) {
        this.ondata = d,
        astrmify([bInflt, zule, function() {
            return [astrm, Inflate, Unzlib]
        }
        ], this, 0, function() {
            var o = new Unzlib;
            onmessage = astrm(o)
        }, 11)
    }
}();
function unzlib(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return cbify(d, o, [bInflt, zule, function() {
        return [unzlibSync]
    }
    ], function(h) {
        return pbf(unzlibSync(h.data[0], gu8(h.data[1])))
    }, 5, c)
}
function unzlibSync(d, o) {
    return inflt((zlv(d),
    d.subarray(2, -4)), o)
}
var Decompress = function() {
    function d(o) {
        this.G = Gunzip,
        this.I = Inflate,
        this.Z = Unzlib,
        this.ondata = o
    }
    return d.prototype.push = function(o, c) {
        if (!this.ondata)
            throw "no stream handler";
        if (this.s)
            this.s.push(o, c);
        else {
            if (this.p && this.p.length) {
                var h = new u8(this.p.length + o.length);
                h.set(this.p),
                h.set(o, this.p.length)
            } else
                this.p = o;
            if (this.p.length > 2) {
                var _ = this
                  , b = function() {
                    _.ondata.apply(_, arguments)
                };
                this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(b) : (15 & this.p[0]) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(b) : new this.Z(b),
                this.s.push(this.p, c),
                this.p = null
            }
        }
    }
    ,
    d
}()
  , AsyncDecompress = function() {
    function d(o) {
        this.G = AsyncGunzip,
        this.I = AsyncInflate,
        this.Z = AsyncUnzlib,
        this.ondata = o
    }
    return d.prototype.push = function(o, c) {
        Decompress.prototype.push.call(this, o, c)
    }
    ,
    d
}();
function decompress(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    return d[0] == 31 && d[1] == 139 && d[2] == 8 ? gunzip(d, o, c) : (15 & d[0]) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31 ? inflate(d, o, c) : unzlib(d, o, c)
}
function decompressSync(d, o) {
    return d[0] == 31 && d[1] == 139 && d[2] == 8 ? gunzipSync(d, o) : (15 & d[0]) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31 ? inflateSync(d, o) : unzlibSync(d, o)
}
var fltn = function(d, o, c, h) {
    for (var _ in d) {
        var b = d[_]
          , _e = o + _;
        b instanceof u8 ? c[_e] = [b, h] : Array.isArray(b) ? c[_e] = [b[0], mrg(h, b[1])] : fltn(b, _e + "/", c, h)
    }
}
  , browser_te = typeof TextEncoder < "u" && new TextEncoder
  , td$1 = typeof TextDecoder < "u" && new TextDecoder
  , tds = 0;
try {
    td$1.decode(browser_et, {
        stream: !0
    }),
    tds = 1
} catch (d) {}
var dutf8 = function(d) {
    for (var o = "", c = 0; ; ) {
        var h = d[c++]
          , _ = (h > 127) + (h > 223) + (h > 239);
        if (c + _ > d.length)
            return [o, slc(d, c - 1)];
        _ ? _ == 3 ? (h = ((15 & h) << 18 | (63 & d[c++]) << 12 | (63 & d[c++]) << 6 | 63 & d[c++]) - 65536,
        o += String.fromCharCode(55296 | h >> 10, 56320 | 1023 & h)) : o += 1 & _ ? String.fromCharCode((31 & h) << 6 | 63 & d[c++]) : String.fromCharCode((15 & h) << 12 | (63 & d[c++]) << 6 | 63 & d[c++]) : o += String.fromCharCode(h)
    }
}
  , DecodeUTF8 = function() {
    function d(o) {
        this.ondata = o,
        tds ? this.t = new TextDecoder : this.p = browser_et
    }
    return d.prototype.push = function(o, c) {
        if (!this.ondata)
            throw "no callback";
        if (c = !!c,
        this.t) {
            if (this.ondata(this.t.decode(o, {
                stream: !0
            }), c),
            c) {
                if (this.t.decode().length)
                    throw "invalid utf-8 data";
                this.t = null
            }
        } else {
            if (!this.p)
                throw "stream finished";
            var h = new u8(this.p.length + o.length);
            h.set(this.p),
            h.set(o, this.p.length);
            var _ = dutf8(h)
              , b = _[0]
              , _e = _[1];
            if (c) {
                if (_e.length)
                    throw "invalid utf-8 data";
                this.p = null
            } else
                this.p = _e;
            this.ondata(b, c)
        }
    }
    ,
    d
}()
  , EncodeUTF8 = function() {
    function d(o) {
        this.ondata = o
    }
    return d.prototype.push = function(o, c) {
        if (!this.ondata)
            throw "no callback";
        if (this.d)
            throw "stream finished";
        this.ondata(strToU8(o), this.d = c || !1)
    }
    ,
    d
}();
function strToU8(d, o) {
    if (o) {
        for (var c = new u8(d.length), h = 0; h < d.length; ++h)
            c[h] = d.charCodeAt(h);
        return c
    }
    if (browser_te)
        return browser_te.encode(d);
    var _ = d.length
      , b = new u8(d.length + (d.length >> 1))
      , _e = 0
      , nt = function(ut) {
        b[_e++] = ut
    };
    for (h = 0; h < _; ++h) {
        if (_e + 5 > b.length) {
            var it = new u8(_e + 8 + (_ - h << 1));
            it.set(b),
            b = it
        }
        var at = d.charCodeAt(h);
        at < 128 || o ? nt(at) : at < 2048 ? (nt(192 | at >> 6),
        nt(128 | 63 & at)) : at > 55295 && at < 57344 ? (nt(240 | (at = 65536 + (1047552 & at) | 1023 & d.charCodeAt(++h)) >> 18),
        nt(128 | at >> 12 & 63),
        nt(128 | at >> 6 & 63),
        nt(128 | 63 & at)) : (nt(224 | at >> 12),
        nt(128 | at >> 6 & 63),
        nt(128 | 63 & at))
    }
    return slc(b, 0, _e)
}
function strFromU8(d, o) {
    if (o) {
        for (var c = "", h = 0; h < d.length; h += 16384)
            c += String.fromCharCode.apply(null, d.subarray(h, h + 16384));
        return c
    }
    if (td$1)
        return td$1.decode(d);
    var _ = dutf8(d)
      , b = _[0];
    if (_[1].length)
        throw "invalid utf-8 data";
    return b
}
var dbf = function(d) {
    return d == 1 ? 3 : d < 6 ? 2 : d == 9 ? 1 : 0
}
  , slzh = function(d, o) {
    return o + 30 + b2(d, o + 26) + b2(d, o + 28)
}
  , zh$1 = function(d, o, c) {
    var h = b2(d, o + 28)
      , _ = strFromU8(d.subarray(o + 46, o + 46 + h), !(2048 & b2(d, o + 8)))
      , b = o + 46 + h
      , _e = b4(d, o + 20)
      , nt = c && _e == 4294967295 ? z64e(d, b) : [_e, b4(d, o + 24), b4(d, o + 42)]
      , it = nt[0]
      , at = nt[1]
      , ut = nt[2];
    return [b2(d, o + 10), it, at, _, b + b2(d, o + 30) + b2(d, o + 32), ut]
}
  , z64e = function(d, o) {
    for (; b2(d, o) != 1; o += 4 + b2(d, o + 2))
        ;
    return [b8(d, o + 12), b8(d, o + 4), b8(d, o + 20)]
}
  , exfl = function(d) {
    var o = 0;
    if (d)
        for (var c in d) {
            var h = d[c].length;
            if (h > 65535)
                throw "extra field too long";
            o += h + 4
        }
    return o
}
  , wzh = function(d, o, c, h, _, b, _e, nt) {
    var it = h.length
      , at = c.extra
      , ut = nt && nt.length
      , pt = exfl(at);
    wbytes(d, o, _e != null ? 33639248 : 67324752),
    o += 4,
    _e != null && (d[o++] = 20,
    d[o++] = c.os),
    d[o] = 20,
    o += 2,
    d[o++] = c.flag << 1 | (b == null && 8),
    d[o++] = _ && 8,
    d[o++] = 255 & c.compression,
    d[o++] = c.compression >> 8;
    var ht = new Date(c.mtime == null ? Date.now() : c.mtime)
      , _t = ht.getFullYear() - 1980;
    if (_t < 0 || _t > 119)
        throw "date not in range 1980-2099";
    if (wbytes(d, o, _t << 25 | ht.getMonth() + 1 << 21 | ht.getDate() << 16 | ht.getHours() << 11 | ht.getMinutes() << 5 | ht.getSeconds() >>> 1),
    o += 4,
    b != null && (wbytes(d, o, c.crc),
    wbytes(d, o + 4, b),
    wbytes(d, o + 8, c.size)),
    wbytes(d, o + 12, it),
    wbytes(d, o + 14, pt),
    o += 16,
    _e != null && (wbytes(d, o, ut),
    wbytes(d, o + 6, c.attrs),
    wbytes(d, o + 10, _e),
    o += 14),
    d.set(h, o),
    o += it,
    pt)
        for (var vt in at) {
            var bt = at[vt]
              , St = bt.length;
            wbytes(d, o, +vt),
            wbytes(d, o + 2, St),
            d.set(bt, o + 4),
            o += 4 + St
        }
    return ut && (d.set(nt, o),
    o += ut),
    o
}
  , wzf = function(d, o, c, h, _) {
    wbytes(d, o, 101010256),
    wbytes(d, o + 8, c),
    wbytes(d, o + 10, c),
    wbytes(d, o + 12, h),
    wbytes(d, o + 16, _)
}
  , ZipPassThrough = function() {
    function d(o) {
        this.filename = o,
        this.c = crc(),
        this.size = 0,
        this.compression = 0
    }
    return d.prototype.process = function(o, c) {
        this.ondata(null, o, c)
    }
    ,
    d.prototype.push = function(o, c) {
        if (!this.ondata)
            throw "no callback - add to ZIP archive before pushing";
        this.c.p(o),
        this.size += o.length,
        c && (this.crc = this.c.d()),
        this.process(o, c || !1)
    }
    ,
    d
}()
  , ZipDeflate = function() {
    function d(o, c) {
        var h = this;
        c || (c = {}),
        ZipPassThrough.call(this, o),
        this.d = new Deflate(c,function(_, b) {
            h.ondata(null, _, b)
        }
        ),
        this.compression = 8,
        this.flag = dbf(c.level)
    }
    return d.prototype.process = function(o, c) {
        try {
            this.d.push(o, c)
        } catch (h) {
            this.ondata(h, null, c)
        }
    }
    ,
    d.prototype.push = function(o, c) {
        ZipPassThrough.prototype.push.call(this, o, c)
    }
    ,
    d
}()
  , AsyncZipDeflate = function() {
    function d(o, c) {
        var h = this;
        c || (c = {}),
        ZipPassThrough.call(this, o),
        this.d = new AsyncDeflate(c,function(_, b, _e) {
            h.ondata(_, b, _e)
        }
        ),
        this.compression = 8,
        this.flag = dbf(c.level),
        this.terminate = this.d.terminate
    }
    return d.prototype.process = function(o, c) {
        this.d.push(o, c)
    }
    ,
    d.prototype.push = function(o, c) {
        ZipPassThrough.prototype.push.call(this, o, c)
    }
    ,
    d
}()
  , Zip = function() {
    function d(o) {
        this.ondata = o,
        this.u = [],
        this.d = 1
    }
    return d.prototype.add = function(o) {
        var c = this;
        if (2 & this.d)
            throw "stream finished";
        var h = strToU8(o.filename)
          , _ = h.length
          , b = o.comment
          , _e = b && strToU8(b)
          , nt = _ != o.filename.length || _e && b.length != _e.length
          , it = _ + exfl(o.extra) + 30;
        if (_ > 65535)
            throw "filename too long";
        var at = new u8(it);
        wzh(at, 0, o, h, nt);
        var ut = [at]
          , pt = function() {
            for (var St = 0, At = ut; St < At.length; St++) {
                var Et = At[St];
                c.ondata(null, Et, !1)
            }
            ut = []
        }
          , ht = this.d;
        this.d = 0;
        var _t = this.u.length
          , vt = mrg(o, {
            f: h,
            u: nt,
            o: _e,
            t: function() {
                o.terminate && o.terminate()
            },
            r: function() {
                if (pt(),
                ht) {
                    var St = c.u[_t + 1];
                    St ? St.r() : c.d = 1
                }
                ht = 1
            }
        })
          , bt = 0;
        o.ondata = function(St, At, Et) {
            if (St)
                c.ondata(St, At, Et),
                c.terminate();
            else if (bt += At.length,
            ut.push(At),
            Et) {
                var Pt = new u8(16);
                wbytes(Pt, 0, 134695760),
                wbytes(Pt, 4, o.crc),
                wbytes(Pt, 8, bt),
                wbytes(Pt, 12, o.size),
                ut.push(Pt),
                vt.c = bt,
                vt.b = it + bt + 16,
                vt.crc = o.crc,
                vt.size = o.size,
                ht && vt.r(),
                ht = 1
            } else
                ht && pt()
        }
        ,
        this.u.push(vt)
    }
    ,
    d.prototype.end = function() {
        var o = this;
        if (2 & this.d)
            throw 1 & this.d ? "stream finishing" : "stream finished";
        this.d ? this.e() : this.u.push({
            r: function() {
                1 & o.d && (o.u.splice(-1, 1),
                o.e())
            },
            t: function() {}
        }),
        this.d = 3
    }
    ,
    d.prototype.e = function() {
        for (var o = 0, c = 0, h = 0, _ = 0, b = this.u; _ < b.length; _++)
            h += 46 + (at = b[_]).f.length + exfl(at.extra) + (at.o ? at.o.length : 0);
        for (var _e = new u8(h + 22), nt = 0, it = this.u; nt < it.length; nt++) {
            var at = it[nt];
            wzh(_e, o, at, at.f, at.u, at.c, c, at.o),
            o += 46 + at.f.length + exfl(at.extra) + (at.o ? at.o.length : 0),
            c += at.b
        }
        wzf(_e, o, this.u.length, h, c),
        this.ondata(null, _e, !0),
        this.d = 2
    }
    ,
    d.prototype.terminate = function() {
        for (var o = 0, c = this.u; o < c.length; o++)
            c[o].t();
        this.d = 2
    }
    ,
    d
}();
function zip(d, o, c) {
    if (c || (c = o,
    o = {}),
    typeof c != "function")
        throw "no callback";
    var h = {};
    fltn(d, "", h, o);
    var _ = Object.keys(h)
      , b = _.length
      , _e = 0
      , nt = 0
      , it = b
      , at = new Array(b)
      , ut = []
      , pt = function() {
        for (var bt = 0; bt < ut.length; ++bt)
            ut[bt]()
    }
      , ht = function() {
        var bt = new u8(nt + 22)
          , St = _e
          , At = nt - _e;
        nt = 0;
        for (var Et = 0; Et < it; ++Et) {
            var Pt = at[Et];
            try {
                var It = Pt.c.length;
                wzh(bt, nt, Pt, Pt.f, Pt.u, It);
                var Dt = 30 + Pt.f.length + exfl(Pt.extra)
                  , Gt = nt + Dt;
                bt.set(Pt.c, Gt),
                wzh(bt, _e, Pt, Pt.f, Pt.u, It, nt, Pt.m),
                _e += 16 + Dt + (Pt.m ? Pt.m.length : 0),
                nt = Gt + It
            } catch (Bt) {
                return c(Bt, null)
            }
        }
        wzf(bt, _e, at.length, At, St),
        c(null, bt)
    };
    b || ht();
    for (var _t = function(bt) {
        var St = _[bt]
          , At = h[St]
          , Et = At[0]
          , Pt = At[1]
          , It = crc()
          , Dt = Et.length;
        It.p(Et);
        var Gt = strToU8(St)
          , Bt = Gt.length
          , kt = Pt.comment
          , Ut = kt && strToU8(kt)
          , Ht = Ut && Ut.length
          , Kt = exfl(Pt.extra)
          , Jt = Pt.level == 0 ? 0 : 8
          , or = function(ir, lr) {
            if (ir)
                pt(),
                c(ir, null);
            else {
                var ar = lr.length;
                at[bt] = mrg(Pt, {
                    size: Dt,
                    crc: It.d(),
                    c: lr,
                    f: Gt,
                    m: Ut,
                    u: Bt != St.length || Ut && kt.length != Ht,
                    compression: Jt
                }),
                _e += 30 + Bt + Kt + ar,
                nt += 76 + 2 * (Bt + Kt) + (Ht || 0) + ar,
                --b || ht()
            }
        };
        if (Bt > 65535 && or("filename too long", null),
        Jt)
            if (Dt < 16e4)
                try {
                    or(null, deflateSync(Et, Pt))
                } catch (ir) {
                    or(ir, null)
                }
            else
                ut.push(deflate(Et, Pt, or));
        else
            or(null, Et)
    }, vt = 0; vt < it; ++vt)
        _t(vt);
    return pt
}
function zipSync(d, o) {
    o || (o = {});
    var c = {}
      , h = [];
    fltn(d, "", c, o);
    var _ = 0
      , b = 0;
    for (var _e in c) {
        var nt = c[_e]
          , it = nt[0]
          , at = nt[1]
          , ut = at.level == 0 ? 0 : 8
          , pt = (Bt = strToU8(_e)).length
          , ht = at.comment
          , _t = ht && strToU8(ht)
          , vt = _t && _t.length
          , bt = exfl(at.extra);
        if (pt > 65535)
            throw "filename too long";
        var St = ut ? deflateSync(it, at) : it
          , At = St.length
          , Et = crc();
        Et.p(it),
        h.push(mrg(at, {
            size: it.length,
            crc: Et.d(),
            c: St,
            f: Bt,
            m: _t,
            u: pt != _e.length || _t && ht.length != vt,
            o: _,
            compression: ut
        })),
        _ += 30 + pt + bt + At,
        b += 76 + 2 * (pt + bt) + (vt || 0) + At
    }
    for (var Pt = new u8(b + 22), It = _, Dt = b - _, Gt = 0; Gt < h.length; ++Gt) {
        var Bt = h[Gt];
        wzh(Pt, Bt.o, Bt, Bt.f, Bt.u, Bt.c.length);
        var kt = 30 + Bt.f.length + exfl(Bt.extra);
        Pt.set(Bt.c, Bt.o + kt),
        wzh(Pt, _, Bt, Bt.f, Bt.u, Bt.c.length, Bt.o, Bt.m),
        _ += 16 + kt + (Bt.m ? Bt.m.length : 0)
    }
    return wzf(Pt, _, h.length, Dt, It),
    Pt
}
var UnzipPassThrough = function() {
    function d() {}
    return d.prototype.push = function(o, c) {
        this.ondata(null, o, c)
    }
    ,
    d.compression = 0,
    d
}()
  , UnzipInflate = function() {
    function d() {
        var o = this;
        this.i = new Inflate(function(c, h) {
            o.ondata(null, c, h)
        }
        )
    }
    return d.prototype.push = function(o, c) {
        try {
            this.i.push(o, c)
        } catch (h) {
            this.ondata(h, o, c)
        }
    }
    ,
    d.compression = 8,
    d
}()
  , AsyncUnzipInflate = function() {
    function d(o, c) {
        var h = this;
        c < 32e4 ? this.i = new Inflate(function(_, b) {
            h.ondata(null, _, b)
        }
        ) : (this.i = new AsyncInflate(function(_, b, _e) {
            h.ondata(_, b, _e)
        }
        ),
        this.terminate = this.i.terminate)
    }
    return d.prototype.push = function(o, c) {
        this.i.terminate && (o = slc(o, 0)),
        this.i.push(o, c)
    }
    ,
    d.compression = 8,
    d
}()
  , Unzip = function() {
    function d(o) {
        this.onfile = o,
        this.k = [],
        this.o = {
            0: UnzipPassThrough
        },
        this.p = browser_et
    }
    return d.prototype.push = function(o, c) {
        var h = this;
        if (!this.onfile)
            throw "no callback";
        if (!this.p)
            throw "stream finished";
        if (this.c > 0) {
            var _ = Math.min(this.c, o.length)
              , b = o.subarray(0, _);
            if (this.c -= _,
            this.d ? this.d.push(b, !this.c) : this.k[0].push(b),
            (o = o.subarray(_)).length)
                return this.push(o, c)
        } else {
            var _e = 0
              , nt = 0
              , it = void 0
              , at = void 0;
            this.p.length ? o.length ? ((at = new u8(this.p.length + o.length)).set(this.p),
            at.set(o, this.p.length)) : at = this.p : at = o;
            for (var ut = at.length, pt = this.c, ht = pt && this.d, _t = function() {
                var St, At = b4(at, nt);
                if (At == 67324752) {
                    _e = 1,
                    it = nt,
                    vt.d = null,
                    vt.c = 0;
                    var Et = b2(at, nt + 6)
                      , Pt = b2(at, nt + 8)
                      , It = 2048 & Et
                      , Dt = 8 & Et
                      , Gt = b2(at, nt + 26)
                      , Bt = b2(at, nt + 28);
                    if (ut > nt + 30 + Gt + Bt) {
                        var kt = [];
                        vt.k.unshift(kt),
                        _e = 2;
                        var Ut, Ht = b4(at, nt + 18), Kt = b4(at, nt + 22), Jt = strFromU8(at.subarray(nt + 30, nt += 30 + Gt), !It);
                        Ht == 4294967295 ? (St = Dt ? [-2] : z64e(at, nt),
                        Ht = St[0],
                        Kt = St[1]) : Dt && (Ht = -1),
                        nt += Bt,
                        vt.c = Ht;
                        var or = {
                            name: Jt,
                            compression: Pt,
                            start: function() {
                                if (!or.ondata)
                                    throw "no callback";
                                if (Ht) {
                                    var ir = h.o[Pt];
                                    if (!ir)
                                        throw "unknown compression type " + Pt;
                                    (Ut = Ht < 0 ? new ir(Jt) : new ir(Jt,Ht,Kt)).ondata = function(gr, dr, cr) {
                                        or.ondata(gr, dr, cr)
                                    }
                                    ;
                                    for (var lr = 0, ar = kt; lr < ar.length; lr++) {
                                        var hr = ar[lr];
                                        Ut.push(hr, !1)
                                    }
                                    h.k[0] == kt && h.c ? h.d = Ut : Ut.push(browser_et, !0)
                                } else
                                    or.ondata(null, browser_et, !0)
                            },
                            terminate: function() {
                                Ut && Ut.terminate && Ut.terminate()
                            }
                        };
                        Ht >= 0 && (or.size = Ht,
                        or.originalSize = Kt),
                        vt.onfile(or)
                    }
                    return "break"
                }
                if (pt) {
                    if (At == 134695760)
                        return it = nt += 12 + (pt == -2 && 8),
                        _e = 3,
                        vt.c = 0,
                        "break";
                    if (At == 33639248)
                        return it = nt -= 4,
                        _e = 3,
                        vt.c = 0,
                        "break"
                }
            }, vt = this; nt < ut - 4 && _t() !== "break"; ++nt)
                ;
            if (this.p = browser_et,
            pt < 0) {
                var bt = _e ? at.subarray(0, it - 12 - (pt == -2 && 8) - (b4(at, it - 16) == 134695760 && 4)) : at.subarray(0, nt);
                ht ? ht.push(bt, !!_e) : this.k[+(_e == 2)].push(bt)
            }
            if (2 & _e)
                return this.push(at.subarray(nt), c);
            this.p = at.subarray(nt)
        }
        if (c) {
            if (this.c)
                throw "invalid zip file";
            this.p = null
        }
    }
    ,
    d.prototype.register = function(o) {
        this.o[o.compression] = o
    }
    ,
    d
}();
function unzip(d, o) {
    if (typeof o != "function")
        throw "no callback";
    for (var c = [], h = function() {
        for (var ht = 0; ht < c.length; ++ht)
            c[ht]()
    }, _ = {}, b = d.length - 22; b4(d, b) != 101010256; --b)
        if (!b || d.length - b > 65558)
            return void o("invalid zip file", null);
    var _e = b2(d, b + 8);
    _e || o(null, {});
    var nt = _e
      , it = b4(d, b + 16)
      , at = it == 4294967295;
    if (at) {
        if (b = b4(d, b - 12),
        b4(d, b) != 101075792)
            return void o("invalid zip file", null);
        nt = _e = b4(d, b + 32),
        it = b4(d, b + 48)
    }
    for (var ut = function(ht) {
        var _t = zh$1(d, it, at)
          , vt = _t[0]
          , bt = _t[1]
          , St = _t[2]
          , At = _t[3]
          , Et = _t[4]
          , Pt = _t[5]
          , It = slzh(d, Pt);
        it = Et;
        var Dt = function(Bt, kt) {
            Bt ? (h(),
            o(Bt, null)) : (_[At] = kt,
            --_e || o(null, _))
        };
        if (vt)
            if (vt == 8) {
                var Gt = d.subarray(It, It + bt);
                if (bt < 32e4)
                    try {
                        Dt(null, inflateSync(Gt, new u8(St)))
                    } catch (Bt) {
                        Dt(Bt, null)
                    }
                else
                    c.push(inflate(Gt, {
                        size: St
                    }, Dt))
            } else
                Dt("unknown compression type " + vt, null);
        else
            Dt(null, slc(d, It, It + bt))
    }, pt = 0; pt < nt; ++pt)
        ut();
    return h
}
function unzipSync(d) {
    for (var o = {}, c = d.length - 22; b4(d, c) != 101010256; --c)
        if (!c || d.length - c > 65558)
            throw "invalid zip file";
    var h = b2(d, c + 8);
    if (!h)
        return {};
    var _ = b4(d, c + 16)
      , b = _ == 4294967295;
    if (b) {
        if (c = b4(d, c - 12),
        b4(d, c) != 101075792)
            throw "invalid zip file";
        h = b4(d, c + 32),
        _ = b4(d, c + 48)
    }
    for (var _e = 0; _e < h; ++_e) {
        var nt = zh$1(d, _, b)
          , it = nt[0]
          , at = nt[1]
          , ut = nt[2]
          , pt = nt[3]
          , ht = nt[4]
          , _t = nt[5]
          , vt = slzh(d, _t);
        if (_ = ht,
        it) {
            if (it != 8)
                throw "unknown compression type " + it;
            o[pt] = inflateSync(d.subarray(vt, vt + at), new u8(ut))
        } else
            o[pt] = slc(d, vt, vt + at)
    }
    return o
}
class ZipLoader extends three_module.Y9S {
    load(o, c, h, _) {
        return this.setResponseType("arraybuffer"),
        super.load(o, b => {
            const _e = unzipSync(new Uint8Array(b))
              , nt = new Map(Object.entries(_e).map( ([it,at]) => [it, new File([at],it)]));
            c == null || c(nt)
        }
        , h, _)
    }
}
class SVGTextureLoader extends three_module.aHM {
    constructor(o) {
        super(o)
    }
    load(o, c, h, _) {
        const b = SVGTextureLoader.USE_CANVAS_TEXTURE ? document.createElement("canvas") : void 0
          , _e = SVGTextureLoader.USE_CANVAS_TEXTURE ? new three_module.GOR(b) : new three_module.gPd
          , nt = new three_module.$NF(this.manager);
        return nt.setCrossOrigin(this.crossOrigin),
        nt.setPath(this.path),
        nt.load(o, function(it) {
            b ? SVGTextureLoader.CopyImageToCanvas(b, it) : _e.image = it,
            _e.needsUpdate = !0,
            c !== void 0 && c(_e)
        }, h, _),
        _e
    }
    static CopyImageToCanvas(o, c) {
        o.width = c.naturalWidth || c.width || 512,
        o.height = c.naturalHeight || c.height || 512;
        const h = o.getContext("2d");
        h ? (h.clearRect(0, 0, o.width, o.height),
        h.drawImage(c, 0, 0, o.width, o.height)) : console.error("SVGTextureLoader: Failed to get canvas context.")
    }
}
SVGTextureLoader.USE_CANVAS_TEXTURE = rt("svg-load-disable-canvas") !== "true";
class AssetImporter extends I$2 {
    get cachedAssets() {
        return this._cachedAssets
    }
    get processors() {
        return this._processors
    }
    get loadingManager() {
        return this._loadingManager
    }
    constructor(o, c=!1) {
        super(),
        this._processors = new ObjectProcessorMap,
        this._logger = console.log,
        this.Importers = [new Importer(SimpleJSONLoader,["json"],!1), new Importer(three_module.Y9S,["txt"],!1), new Importer(RGBEPNGLoader,["rgbe.png", "hdr.png", "hdrpng"],!1), new Importer(SVGTextureLoader,["svg", "data:image/svg"],!1), new Importer(three_module.Tap,["webp", "png", "jpeg", "jpg", "data:image"],!1), new Importer(LUTCubeLoader2,["cube"],!1), new Importer(ZipLoader,["zip"],!0)],
        this._loaderCache = [],
        this._fileDatabase = new Map,
        this._cachedAssets = [],
        c || (this._logger = () => {}
        ),
        this._viewer = o,
        this._onLoad = this._onLoad.bind(this),
        this._onProgress = this._onProgress.bind(this),
        this._onError = this._onError.bind(this),
        this._onStart = this._onStart.bind(this),
        this._urlModifier = this._urlModifier.bind(this),
        this._loadingManager = new three_module.KPJ(this._onLoad,this._onProgress,this._onError),
        this._loadingManager.onStart = this._onStart,
        this._loadingManager.setURLModifier(this._urlModifier),
        this.Importers.push(addRGBELoader(o)),
        this.Importers.push(addGLTFLoader(o)),
        this.Importers.push(addDracoLoader())
    }
    _onLoad() {
        this.dispatchEvent({
            type: "onLoad"
        })
    }
    _onProgress(o, c, h) {
        this.dispatchEvent({
            type: "onProgress",
            url: o,
            loaded: c,
            total: h
        })
    }
    _onError(o) {
        this.dispatchEvent({
            type: "onError",
            url: o
        })
    }
    _onStart(o, c, h) {
        this.dispatchEvent({
            type: "onStart",
            url: o,
            loaded: c,
            total: h
        })
    }
    _urlModifier(o) {
        var c;
        let h = decodeURI(o);
        const _ = (c = this._rootContext) === null || c === void 0 ? void 0 : c.rootUrl;
        h.includes("://") || !_ || h.startsWith(_) || (h = _ + h),
        h = h.replace("./", ""),
        h = h.replace(/^(\/\/)/, "/"),
        h = h.replace(/\?.*$/, "");
        const b = this._fileDatabase.get(h);
        return b ? b.ext ? (b.objectUrl || (b.objectUrl = URL.createObjectURL(b) + "#" + h),
        b.objectUrl) : (console.error("Unable to determine file extension", b),
        o) : o
    }
    _createLoader(o) {
        const c = this._getImporter(o)
          , h = c == null ? void 0 : c.ctor(this);
        return h && (c == null || c.ext.forEach(_ => {
            const b = new RegExp(_.startsWith("data:") ? "^" + _ + "\\/" : "\\." + _ + "$","i");
            this._loadingManager.addHandler(b, h)
        }
        )),
        h && (this._loaderCache.push({
            loader: h,
            files: []
        }),
        this.dispatchEvent({
            type: "loaderCreate",
            loader: h
        })),
        h
    }
    addEventListener(o, c) {
        if (super.addEventListener(o, c),
        o === "loaderCreate")
            for (const h of this._loaderCache)
                this.dispatchEvent({
                    type: "loaderCreate",
                    loader: h.loader
                })
    }
    async importFiles(o, c={}) {
        const h = new Map;
        let {allowedExtensions: _} = c;
        if (_ && _.length < 1 && (_ = void 0),
        o.size === 0)
            return h;
        this.dispatchEvent({
            type: "importFiles",
            files: Object.keys(o),
            state: "start"
        });
        const b = []
          , _e = [];
        if (o.forEach( (nt, it) => {
            var at;
            this.registerFile(it, nt);
            const ut = nt.ext;
            ut && ((at = _ == null ? void 0 : _.includes(ut.toLowerCase())) === null || at === void 0 || at) && (this._isRootFileExtension(ut) ? b.push(it) : _e.push(it))
        }
        ),
        b.length > 0)
            for (const nt of b) {
                let it = await this._importFile(nt, void 0, c);
                it && (it = await this.processImported(it, c)),
                h.set(nt, it)
            }
        else
            for (const nt of _e) {
                let it = await this._importFile(nt, void 0, c);
                it && (it = await this.processImported(it, c)),
                h.set(nt, it)
            }
        return this.dispatchEvent({
            type: "importFiles",
            files: Object.keys(o),
            state: "end"
        }),
        o.forEach( (nt, it) => {
            this.unregisterFile(it)
        }
        ),
        h
    }
    registerFile(o, c) {
        var h, _, b;
        o = o.replace(/\?.*$/, "");
        const _e = (h = c == null ? void 0 : c.ext) !== null && h !== void 0 ? h : (b = ae$1((_ = c == null ? void 0 : c.name) !== null && _ !== void 0 ? _ : o.trim())) === null || b === void 0 ? void 0 : b.toLowerCase();
        c && (c.ext || (c.ext = _e),
        this._fileDatabase.set(o, c));
        let nt = this._getLoader(o);
        if (nt || (nt = this._createLoader(c ?? {
            name: o,
            ext: _e
        })),
        nt) {
            for (const it of this._loaderCache)
                if (it.loader === nt) {
                    it.files.push(o);
                    break
                }
        }
        return nt
    }
    unregisterFile(o) {
        o = o.replace(/\?.*$/, "");
        const c = this._fileDatabase.get(o);
        c != null && c.objectUrl && (URL.revokeObjectURL(c.objectUrl),
        c.objectUrl = void 0),
        c && this._fileDatabase.delete(o)
    }
    _isRootFileExtension(o) {
        return this.Importers.find(c => c.root && c.ext.includes(o.toLowerCase())) != null
    }
    resolveURL(o) {
        return this._loadingManager.resolveURL(o)
    }
    async _importFile(o, c, h={}, _) {
        var b, _e;
        if (c != null && c.__imported)
            return c.__imported;
        let nt;
        this.dispatchEvent({
            type: "importFile",
            path: o,
            state: "downloading",
            progress: 0
        });
        try {
            this.registerFile(o, c);
            const it = this.resolveURL(o)
              , at = o.replace(/\?.*$/, "").trim()
              , ut = (b = h.fileHandler) !== null && b !== void 0 ? b : await this._loadingManager.getHandler(at) || (c ? await this._loadingManager.getHandler(c.name || c.ext || "") : void 0);
            if (!ut)
                throw new Error("AssetImporter: Unable to find loader for " + o);
            this._rootContext = {
                path: o,
                url: it,
                rootUrl: three_module.r6x.extractUrlBase(o),
                baseUrl: three_module.r6x.extractUrlBase(it)
            },
            nt = await ut.loadAsync(o + (h.queryString ? (o.includes("?") ? "&" : "?") + h.queryString : ""), pt => {
                _ && _(pt),
                this.dispatchEvent({
                    type: "importFile",
                    path: o,
                    state: "downloading",
                    loadedBytes: pt.loaded || void 0,
                    totalBytes: pt.total || void 0,
                    progress: pt.total > 0 ? pt.loaded / pt.total : 1
                })
            }
            ),
            ut.transform && (nt = await ut.transform(nt, h)),
            this._rootContext = void 0,
            this.dispatchEvent({
                type: "importFile",
                path: o,
                state: "downloading",
                progress: 1
            }),
            this.dispatchEvent({
                type: "importFile",
                path: o,
                state: "adding"
            }),
            c ? this._logger("AssetImporter: loaded", o) : this._logger("AssetImporter: downloaded", o),
            c && this.unregisterFile(o)
        } catch (it) {
            return console.error("AssetImporter: Unable to import file", o, c),
            console.error(it),
            console.error(it == null ? void 0 : it.stack),
            this.dispatchEvent({
                type: "importFile",
                path: o,
                state: "error",
                error: it
            }),
            c && this.unregisterFile(o),
            []
        }
        if (this.dispatchEvent({
            type: "importFile",
            path: o,
            state: "done"
        }),
        c && nt) {
            c.__imported = nt;
            let it = [];
            Array.isArray(nt) ? it = nt : !((_e = nt.userData) === null || _e === void 0) && _e.rootSceneModelRoot ? it.push(...nt.children) : it.push(nt),
            it.forEach(at => {
                at.addEventListener && at.addEventListener("dispose", () => {
                    c.__imported = void 0
                }
                )
            }
            )
        }
        if (nt && typeof nt == "object") {
            nt.__rootPath = o;
            const it = c || this._fileDatabase.get(o);
            it && (nt.__rootBlob = it)
        }
        return nt
    }
    _getImporter(o, c=!1) {
        return this.Importers.find(h => {
            if (c && !h.root)
                return !1;
            const _ = h.ext.find(b => {
                var _e, nt, it;
                return o.ext && b === o.ext.toLowerCase() || ((nt = (_e = o.name) === null || _e === void 0 ? void 0 : _e.toLowerCase()) === null || nt === void 0 ? void 0 : nt.endsWith("." + b.toLowerCase())) || (b == null ? void 0 : b.startsWith("data:")) && ((it = o.name) === null || it === void 0 ? void 0 : it.startsWith(b))
            }
            );
            return !!_ && (o.ext = _,
            !0)
        }
        )
    }
    _getLoader(o) {
        var c;
        return (c = this._loadingManager.getHandler(o.trim())) !== null && c !== void 0 ? c : void 0
    }
    async importAsset(o, c={}, h) {
        var _, b, _e;
        if (!o)
            return [];
        if (!this._cachedAssets.includes(o)) {
            if (Object.entries(o).length === 1 && o.path) {
                const ut = this._cachedAssets.find(pt => pt.path === o.path);
                ut && Object.assign(o, ut)
            }
            const at = this._cachedAssets.findIndex(ut => ut.path === o.path);
            at >= 0 && this._cachedAssets.splice(at, 1),
            this._cachedAssets.push(o)
        }
        let nt;
        if (o != null && o.preImported && (nt = await o.preImported),
        !c.forceImport && nt) {
            const at = await this.processImported(nt, c);
            let ut = !1;
            for (const pt of at) {
                if (!((_ = pt.userData) === null || _ === void 0) && _.rootSceneModelRoot && [...pt.children, ...pt.__processedChildren || []].find(ht => ht.__disposed)) {
                    ut = !0;
                    break
                }
                if (pt.__disposed) {
                    ut = !0;
                    break
                }
            }
            if (!ut || c.reimportDisposed === !1)
                return at
        }
        const it = c.pathOverride || o.path;
        if (o.preImported = this._importFile(it, typeof ((b = o.file) === null || b === void 0 ? void 0 : b.arrayBuffer) == "function" ? o.file : void 0, c, h),
        nt = await o.preImported,
        nt && (this.dispatchEvent({
            type: "processFileStart",
            path: it,
            result: nt
        }),
        nt = await this.processImported(nt, c),
        this.dispatchEvent({
            type: "processFileEnd",
            path: it,
            result: nt
        })),
        nt) {
            const at = [];
            Array.isArray(nt) ? at.push(...nt) : !((_e = nt.userData) === null || _e === void 0) && _e.rootSceneModelRoot ? at.push(...nt.children) : at.push(nt),
            at.forEach(ut => {
                var pt;
                return (pt = ut.addEventListener) === null || pt === void 0 ? void 0 : pt.call(ut, "dispose", () => {
                    o != null && o.preImported && (o.preImported = void 0)
                }
                )
            }
            )
        }
        return nt
    }
    async importSingle(o, c={}) {
        var h;
        return typeof o == "string" ? await this.importSinglePath(o, c) : (h = await this.importAsset(o, c)) === null || h === void 0 ? void 0 : h[0]
    }
    async importSinglePath(o, c) {
        var h;
        return (h = await this.importPath(o, c)) === null || h === void 0 ? void 0 : h[0]
    }
    async importPath(o, c={}) {
        const h = {
            ...c
        };
        delete h.pathOverride,
        delete h.forceImport,
        delete h.reimportDisposed,
        delete h.fileHandler,
        delete h.importedFile;
        const _ = JSON.stringify(h)
          , b = this._cachedAssets.find(nt => nt.path === o && nt._options === _);
        let _e;
        return _e = b || {
            path: o
        },
        _e._options = _,
        c.importedFile && (_e.file = c.importedFile),
        await this.importAsset(_e, c)
    }
    async processImportedSingle(o, c={}) {
        return (await this.processImported(o, c))[0]
    }
    async processImported(o, c={}) {
        var h, _, b, _e, nt, it, at, ut;
        let pt = o;
        if (!pt)
            return [];
        if (c.processImported === !1)
            return [pt];
        if (Array.isArray(pt)) {
            const vt = [];
            for (const bt of pt)
                vt.push(...await this.processImported(bt, c));
            return vt
        }
        if (!((h = pt.userData) === null || h === void 0) && h.rootSceneModelRoot) {
            if (c._rootSceneImported = !0,
            pt.__processedChildren && !c.forceImporterReprocess)
                return pt.__processedChildren;
            if (!(pt.children.length < 1))
                return pt.animations && (pt.children[0].animations || (pt.children[0].animations = []),
                pt.children[0].animations.push(...pt.animations)),
                pt.__importedViewerConfig && (pt.children[0].__importedViewerConfig = pt.__importedViewerConfig),
                pt.userData.__importData && (pt.children[0].userData.__importData = pt.userData.__importData),
                pt.__processedChildren = await this.processImported([...pt.children], c),
                pt.__processedChildren;
            if (((_ = pt.animations) === null || _ === void 0 ? void 0 : _.length) > 0 && console.error("AssetImporter: animations in empty scene not supported yet. animations will be ignored", pt.animations),
            !pt.__importedViewerConfig)
                return [];
            pt = pt.__importedViewerConfig
        }
        if (!((b = pt.userData) === null || b === void 0) && b.iModel && (pt = pt.userData.iModel),
        !((_e = pt.userData) === null || _e === void 0) && _e.iMaterial && (pt = pt.userData.iMaterial),
        pt.assetImporterProcessed && !c.forceImporterReprocess)
            return [pt];
        const ht = pt.__rootPath
          , _t = pt.__rootBlob;
        if (!pt.assetType) {
            if (pt.isBufferGeometry && (pt = new three_module.eaF(pt,new three_module._4j)),
            pt.isObject3D)
                if (pt.isLight)
                    pt = upgradeThreejsLight(pt);
                else {
                    const vt = [];
                    pt.traverse(bt => {
                        bt !== pt && bt.isLight && vt.push(bt)
                    }
                    );
                    for (const bt of vt)
                        upgradeThreejsLight(bt);
                    pt = new Object3DModel(pt,c)
                }
            pt.isTexture && (pt.assetType = "texture",
            c._testDataTextureComplete && (pt.isDataTexture && (!((nt = pt.image) === null || nt === void 0) && nt.data) && (pt.image.complete = !0),
            !((it = pt.image) === null || it === void 0) && it.complete && (pt.needsUpdate = !0)),
            c.generateMipmaps !== void 0 && (pt.generateMipmaps = c.generateMipmaps),
            pt.generateMipmaps || pt.isRenderTargetTexture || (pt.minFilter = pt.minFilter === three_module.$_I ? three_module.k6q : pt.minFilter,
            pt.magFilter = pt.magFilter === three_module.$_I ? three_module.k6q : pt.magFilter)),
            pt.isMaterial && (pt.assetType = "material")
        }
        if (pt.assetType != null)
            return pt.userData && (pt.userData.rootPath || !ht || ht.startsWith("blob:") || ht.startsWith("/") || (pt.userData.rootPath = ht),
            _t && (pt.userData.__sourceBlob = _t,
            pt.userData.__needsSourceBuffer && (pt.userData.__sourceBuffer = await _t.arrayBuffer(),
            delete pt.userData.__needsSourceBuffer))),
            pt = await this._processors.process(pt.assetType, pt, {}),
            pt.assetImporterProcessed = !0,
            [pt];
        if (pt instanceof Map)
            return [...(await this.importFiles(pt, c)).values()].flat();
        if (pt.type && pt.type !== "ViewerApp" && pt.type !== "ThreeViewer") {
            const vt = this._viewer.getPluginByType(pt.type);
            if (vt) {
                let bt = pt._importedResources || {};
                return pt.resources && (bt = await ((at = this._viewer.getManager()) === null || at === void 0 ? void 0 : at.importConfigResources(pt.resources)),
                delete pt.resources,
                pt._importedResources = bt),
                typeof vt.fromJSON == "function" && (await Promise.resolve(vt.fromJSON(pt, bt)),
                pt.assetImporterProcessed = !1),
                []
            }
        }
        return pt.plugins || pt.type === "ViewerApp" || pt.type === "ThreeViewer" ? (pt.resources = await ((ut = this._viewer.getManager()) === null || ut === void 0 ? void 0 : ut.importConfigResources(pt.resources)),
        await this._viewer.getManager().importViewerConfig(pt),
        pt.assetImporterProcessed = !1,
        []) : (console.warn("WebGi AssetImporter: unknown/null asset type: ", pt, pt.plugins),
        [pt])
    }
    dispose() {
        var o;
        this.clearCache(),
        (o = this._processors) === null || o === void 0 || o.dispose()
    }
    clearLoaderCache() {
        this._loaderCache.forEach(o => {
            o.loader.dispose && o.loader.dispose()
        }
        ),
        this._loaderCache = []
    }
    clearCache() {
        this.clearLoaderCache(),
        this._cachedAssets = []
    }
}
function getTextureDataType(d) {
    if (!d)
        return three_module.OUM;
    const o = d.extensions.has("EXT_color_buffer_half_float") || d.capabilities.isWebGL2 && d.extensions.has("EXT_color_buffer_float")
      , c = d.capabilities.isWebGL2 || d.extensions.has("OES_texture_float") || d.extensions.has("WEBGL_color_buffer_float");
    return o ? three_module.ix0 : c ? three_module.RQf : three_module.OUM
}
function upgradeThreejsLight(d) {
    var o, c;
    if (!d.isLight || d.assetType === "light")
        return d;
    if (d.uiConfig)
        return console.warn("ui config already exists, not supported", d),
        d;
    let h;
    if (d.children.length,
    d.isDirectionalLight && (h = new DirectionalLight2),
    d.isAmbientLight && (h = new AmbientLight2),
    d.isSpotLight && (h = new SpotLight2),
    d.isPointLight && (h = new PointLight2),
    h) {
        (c = (o = h.lightObject).copy) === null || c === void 0 || c.call(o, d);
        const _ = d.parent;
        _ != null && _.isObject3D && (_.remove(d),
        d.dispose(),
        d.userData.iModel = h,
        _.add(h.lightObject),
        h.uuid = d.uuid),
        setupIModel(h.lightObject, _)
    } else
        console.warn("unknown light type: ", d);
    return h
}
AssetImporter.WHITE_IMAGE_DATA = new ImageData(new Uint8ClampedArray([255, 255, 255, 255]),1,1);
class ThreeMaterialLoader extends three_module.jut {
    constructor(o) {
        super(o)
    }
    async loadAsync(o, c) {
        var h, _;
        const b = new three_module.Y9S(this.manager);
        b.setPath(this.path),
        b.setRequestHeader(this.requestHeader),
        b.setWithCredentials(this.withCredentials);
        const _e = await b.loadAsync(o, c);
        try {
            const nt = JSON.parse(_e);
            if (this.importer) {
                const it = {};
                let at = (h = nt.images) !== null && h !== void 0 ? h : [];
                Array.isArray(at) || (at = Object.values(at));
                for (const ut of at) {
                    if (!ut.url || !ut.uuid)
                        continue;
                    const pt = (_ = await this.importer.importPath(ut.url, {
                        processImported: !1
                    })) === null || _ === void 0 ? void 0 : _[0]
                      , ht = pt == null ? void 0 : pt.source;
                    if (!pt || !ht)
                        continue;
                    const _t = new three_module.kLi(ht.data);
                    _t.uuid = ut.uuid,
                    it[_t.uuid] = _t,
                    pt.dispose()
                }
                return await ObjectLoader2.LoadRootPathTextures(nt.textures, it, this.importer),
                this.parse(nt, it)
            }
            return this.parse(nt)
        } catch (nt) {
            throw console.error(nt),
            this.manager.itemError(o),
            nt
        }
    }
    parse(o, c) {
        var h, _;
        let b;
        const _e = {
            p: new Promise(ut => {
                b = ut
            }
            )
        };
        if (o.images || o.textures) {
            const ut = new ObjectLoader2(this.manager);
            let pt = {};
            const ht = St => {
                b(),
                _e.p = void 0,
                Object.values(pt).forEach(At => {
                    var Et;
                    At.isTexture && (!((Et = At.image) === null || Et === void 0) && Et.complete) && (At.needsUpdate = !0)
                }
                )
            }
            ;
            let _t = o.images || [];
            Array.isArray(_t) || (_t = Object.values(_t));
            const vt = c || ut.parseImages(_t, ht);
            let bt = o.textures;
            Array.isArray(bt) || (bt = Object.values(bt)),
            pt = ut.parseTextures2(bt, vt, ht),
            this.setTextures(pt)
        }
        this.materials || console.warn("A Material Manager is not set to import three materials, trying standard materials");
        const nt = {
            ...o
        };
        if (Object.entries(nt).forEach( ([ut,pt]) => {
            pt && typeof pt == "string" && this.textures[pt] && (nt[ut] = this.textures[pt])
        }
        ),
        o.vertexColors !== void 0 && (typeof o.vertexColors == "number" ? nt.vertexColors = o.vertexColors > 0 : nt.vertexColors = o.vertexColors),
        o.normalScale !== void 0) {
            const ut = o.normalScale;
            Array.isArray(ut) === !1 && (nt.normalScale = [ut, ut])
        }
        let it = o.type;
        it !== "MeshPhysicalMaterial" && it !== "MeshStandardMaterial" && it !== "PhysicalMaterial" || (it = MeshStandardMaterial2.TYPE),
        nt.userData = deserializeObject(nt.userData, void 0, !1, this);
        const at = (_ = (h = this.materials) === null || h === void 0 ? void 0 : h.generateFromTemplateType(it, nt)) !== null && _ !== void 0 ? _ : super.parse(o);
        return this.setTextures({}),
        at.userData.imageLoadAwaiter = _e,
        at
    }
}
class AssetManagerPlugin extends I$2 {
    constructor(o, c, {simpleCache: h=!1, storage: _}={}) {
        if (super(),
        this._sceneUpdated = this._sceneUpdated.bind(this),
        this.addAsset = this.addAsset.bind(this),
        this.addProcessedAssets = this.addProcessedAssets.bind(this),
        this.addImported = this.addImported.bind(this),
        (h || _) && (h && (three_module.l2R.enabled = !0),
        _ && window.Cache && typeof window.Cache == "function" && _ instanceof window.Cache)) {
            const b = {
                ...three_module.l2R
            };
            three_module.l2R.get = (_e, nt, it) => nt ? _e.startsWith("data:") || _e.startsWith("blob") || _e.startsWith("chrome-extension") ? Promise.resolve(void 0) : _.match(_e).then(at => {
                if (at)
                    switch (nt) {
                    case "arraybuffer":
                        return at.arrayBuffer();
                    case "blob":
                        return at.blob();
                    case "document":
                        return at.text().then(ut => new DOMParser().parseFromString(ut, it ?? "text/html"));
                    case "json":
                        return at.json();
                    default:
                        if (it === void 0)
                            return at.text();
                        {
                            const ut = /charset="?([^;"\s]*)"?/i.exec(it)
                              , pt = ut && ut[1] ? ut[1].toLowerCase() : void 0
                              , ht = new TextDecoder(pt);
                            return at.arrayBuffer().then(_t => ht.decode(_t))
                        }
                    }
            }
            ) : b.get(_e),
            three_module.l2R.add = async (_e, nt, it) => {
                if (!it)
                    return b.add(_e, nt);
                _e.startsWith("data:") || _e.startsWith("blob") || _e.startsWith("chrome-extension") || (await _.match(_e) && await _.delete(_e),
                await _.put(_e, new Response(nt,{
                    status: 200
                })))
            }
            ,
            three_module.l2R.remove = (_e, nt) => {
                if (!nt)
                    return b.remove(_e);
                _.delete(_e)
            }
        }
        this.storage = _,
        this._importer = o,
        this._materials = c
    }
    async addAsset(o, c={}) {
        if (!this._importer || !this._viewer)
            return [];
        const h = await this._importer.importAsset(o, c);
        return h ? (this.addProcessedAssets(h, c),
        h) : (console.warn("WebGi AssetManager: Unable to import", o, h),
        [])
    }
    async addFromPath(o, c={}) {
        if (!this._importer || !this._viewer)
            return [];
        const h = await this._importer.importPath(o, c);
        return h ? (this.addProcessedAssets(h, c),
        h) : (o && !o.split("?")[0].endsWith(".vjson") && console.warn("WebGi AssetManager: Unable to import", o, h),
        [])
    }
    addProcessedAssets(o, c) {
        return o.map(h => {
            var _;
            return (_ = this._viewer) === null || _ === void 0 ? void 0 : _.scene.addSceneObject(h, {
                ...c,
                allImported: o
            })
        }
        )
    }
    async addAssetSingle(o, c={}) {
        var h;
        return o ? (h = await (typeof o == "string" ? this.addFromPath : this.addAsset).call(this, o, c)) === null || h === void 0 ? void 0 : h[0] : void 0
    }
    async addImported(o, c={}) {
        var h;
        return (h = this._importer) === null || h === void 0 ? void 0 : h.processImported(o, c).then(_ => (this.addProcessedAssets(_, c),
        _))
    }
    async addImportedSingle(o, c={}) {
        return this.addImported(o, c).then(h => h == null ? void 0 : h[0])
    }
    _sceneUpdated(o) {
        var c;
        if (o.type === "addSceneObject") {
            const h = o.object;
            h.assetType === "material" && ((c = this._materials) === null || c === void 0 || c.processMaterial(h, {}))
        } else
            console.error("Unexpected")
    }
    onAdded(o) {
        this._viewer = o,
        this._materials || (this._materials = new MaterialManager,
        this._viewer.scene.addEventListener("addSceneObject", this._sceneUpdated)),
        this._importer || (this._importer = new AssetImporter(o,!!o.getPluginByType("debug")),
        this._importer.processors.add("model", {
            forAssetType: "model",
            process: (h, _) => (setupObject3dModel(h, b => {
                var _e;
                return (_e = this._materials) === null || _e === void 0 ? void 0 : _e.processModel(b, {
                    recursive: !1
                })
            }
            ),
            h)
        }),
        this._importer.processors.add("model", {
            forAssetType: "model",
            process: this._materials.processModel
        }),
        this._importer.processors.add("material", {
            forAssetType: "material",
            process: (h, _) => {
                var b;
                return !((b = this.materials) === null || b === void 0) && b.findMaterial(h.uuid) && (console.warn("WebGi AssetManager: Material with same UUID already exists, creating new UUID"),
                h.uuid = three_module.cj9.generateUUID(),
                h.userData.uuid && (h.userData.uuid = h.uuid)),
                this._materials.processMaterial(h, _)
            }
        })),
        this._importer.Importers.push(new Importer(ThreeMaterialLoader,[MeshStandardMaterial2.TypeSlug],!1,h => (h && (h.materials = this._materials),
        h && (h.importer = this._importer),
        h)));
        const c = this.importViewerConfig.bind(this);
        this._importer.Importers.push(new Importer(class extends SimpleJSONLoader {
            async loadAsync(h, _) {
                return c(await super.loadAsync(h, _))
            }
        }
        ,[AssetManagerPlugin.ViewerTypeSlug],!0))
    }
    onRemove(o) {
        var c, h;
        o === this._viewer && ((c = this._importer) === null || c === void 0 || c.dispose(),
        this._importer = void 0,
        this._viewer.scene.removeEventListener("addSceneObject", this._sceneUpdated),
        (h = this._materials) === null || h === void 0 || h.dispose(),
        this._materials = void 0)
    }
    get importer() {
        return this._importer
    }
    get exporter() {
        var o, c;
        return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("AssetExporterPlugin")) === null || c === void 0 ? void 0 : c.exporter
    }
    get materials() {
        return this._materials
    }
    exportViewerConfig(o=!0, c) {
        if (!this._viewer)
            return {};
        const h = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            extras: {},
            ...c
        }
          , _ = this._viewer.toJSON(h);
        return o || Object.values(h).forEach(b => {
            b && Object.values(b).forEach(_e => {
                _e.url && (_e.url.data instanceof ArrayBuffer || Array.isArray(_e.url.data)) && (_e.url.type === "Uint16Array" ? (_e.url.data instanceof Uint16Array || (_e.url.data = new Uint16Array(_e.url.data)),
                _e.url.data = "data:application/octet-stream;base64," + ie$1(_e.url.data.buffer)) : _e.url.type === "Uint8Array" ? (_e.url.data instanceof Uint8Array || (_e.url.data = new Uint8Array(_e.url.data)),
                _e.url.data = "data:application/octet-stream;base64," + ie$1(_e.url.data.buffer)) : _e.url.data instanceof ArrayBuffer ? _e.url.data = "data:application/octet-stream;base64," + ie$1(_e.url.data.buffer) : console.warn("Unsupported buffer type", _e.url.type))
            }
            )
        }
        ),
        _.resources = h,
        _
    }
    exportPluginPresets(o) {
        var c;
        const h = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            extras: {}
        };
        return {
            plugins: (c = this._viewer) === null || c === void 0 ? void 0 : c.serializePlugins(h, o),
            resources: h
        }
    }
    exportPluginPreset(o) {
        if (!o.toJSON)
            return;
        const c = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            extras: {}
        }
          , h = o.toJSON(c);
        return h.resources = c,
        h
    }
    async importPluginPreset(o, c) {
        var h;
        const _ = o.type;
        if (!(c = c || ((h = this._viewer) === null || h === void 0 ? void 0 : h.getPluginByType(_))))
            return void console.warn(`WebGi: No plugin found for type ${_} to import preset`);
        if (!c.fromJSON)
            return void console.warn(`WebGi: Plugin ${_} does not support importing presets`);
        const b = o.resources || {};
        o.resources && delete o.resources;
        const _e = await this.importConfigResources(b);
        return await c.fromJSON(o, _e),
        _e && (o.resources = _e),
        c
    }
    async importViewerConfig(o, c) {
        if (!this._viewer || !this._importer)
            return void console.warn("WebGi: No viewer or importer");
        const h = await this.importConfigResources(o.resources || {}, c);
        this.applyViewerConfig(o, h)
    }
    applyViewerConfig(o, c) {
        var h;
        if (this._viewer && this._importer)
            if ((c = c || o.resources).__isLoadedResources) {
                this._viewer.fromJSON(o, c);
                for (const _ of Object.values(c.materials))
                    _.__useCount ? delete _.__useCount : (h = this._materials) === null || h === void 0 || h.unregisterMaterial(_);
                for (const _ of Object.values(c.textures))
                    _.__useCount && delete _.__useCount
            } else
                console.error("Cannot load viewer config: resources not loaded", o);
        else
            console.warn("WebGi: No viewer or importer")
    }
    async importConfigResources(o, c, h) {
        var _, b, _e;
        if (!this._importer)
            throw "Importer not initialized yet.";
        if (o.__isLoadedResources)
            return o;
        const nt = {};
        Object.values(o).forEach(at => {
            at && Object.values(at).forEach(ut => {
                if (!ut || !ut.url || typeof ut.url.data != "string")
                    return;
                const pt = ut.url.data.match(/^data:.*;base64,(.*)$/);
                pt != null && pt[1] ? ut.url.data = re$1(pt == null ? void 0 : pt[1]) : (ut.url.type !== "Uint8Array" && console.error("Unsupported buffer type string for ", ut.url.type, "use base64"),
                ut.url.data = new TextEncoder().encode(ut.url.data).buffer)
            }
            )
        }
        ),
        c = c ?? new ObjectLoader2(this._importer.loadingManager),
        nt.animations = o.animations ? c.parseAnimations(o.animations) : {},
        h && h.animations && (nt.animations = {
            ...nt.animations,
            ...h.animations
        }),
        nt.shapes = o.shapes ? c.parseShapes(o.shapes) : {},
        h && h.shapes && (nt.shapes = {
            ...nt.shapes,
            ...h.shapes
        }),
        nt.geometries = o.geometries ? c.parseGeometries(o.geometries, nt.shapes) : {},
        h && h.geometries && (nt.geometries = {
            ...nt.geometries,
            ...h.geometries
        }),
        nt.images = o.images ? await c.parseImagesAsync(Object.values(o.images)) : {},
        h && h.images && (nt.images = {
            ...nt.images,
            ...h.images
        }),
        await ObjectLoader2.LoadRootPathTextures(o.textures, nt.images, this._importer),
        nt.textures = o.textures ? c.parseTextures2(Object.values(o.textures), nt.images, () => {
            Object.values(nt.textures).forEach(at => {
                var ut;
                at.isTexture && (!((ut = at.image) === null || ut === void 0) && ut.complete) && (at.needsUpdate = !0)
            }
            )
        }
        ) : {};
        for (const at of Object.entries(nt.textures))
            at[1] = (_ = await this._importer.processImported(at[1], {})) === null || _ === void 0 ? void 0 : _[0],
            at[1] ? nt.textures[at[0]] = at[1] : delete nt.textures[at[0]];
        h && h.textures && (nt.textures = {
            ...nt.textures,
            ...h.textures
        });
        const it = o.materials ? Object.values(o.materials) : [];
        for (const at of it)
            Object.entries(at).forEach( ([ut,pt]) => {
                pt && pt.resource && pt.uuid && pt.resource === "textures" && (at[ut] = pt.uuid)
            }
            );
        if (nt.materials = c.parseMaterials2(it, nt.textures, this._materials),
        h && h.materials && (nt.materials = {
            ...nt.materials,
            ...h.materials
        }),
        o.object && (nt.object = c.parseObject(o.object, nt.geometries, nt.materials, nt.textures, nt.animations),
        o.skeletons && (nt.skeletons = c.parseSkeletons(o.skeletons, nt.object),
        c.bindSkeletons(nt.object, nt.skeletons))),
        o.extras) {
            nt.extras = o.extras;
            for (const at of Object.values(o.extras))
                if (at.uuid && at.url)
                    if (typeof at.url == "string") {
                        const ut = await ((b = this._importer) === null || b === void 0 ? void 0 : b.importPath(at.url));
                        (ut == null ? void 0 : ut.length) > 0 && (nt.extras[at.uuid] = ut[0])
                    } else if (at.url.data) {
                        const ut = new File([se$1(at.url.type, at.url.data)],at.url.path)
                          , pt = await ((_e = this._importer) === null || _e === void 0 ? void 0 : _e.importAsset({
                            path: ut.name,
                            file: ut
                        }));
                        (pt == null ? void 0 : pt.length) > 0 && (nt.extras[at.uuid] = pt[0])
                    } else
                        console.warn("WebGi: invalid URL type while loading extra resource")
        }
        return h && h.extras && (nt.extras = {
            ...nt.extras,
            ...h.extras
        }),
        nt.__isLoadedResources = !0,
        nt
    }
}
AssetManagerPlugin.PluginType = "AssetManager",
AssetManagerPlugin.ViewerTypeSlug = "vjson";
const VIEWER_VERSION = "0.11.1";
class Dropzone {
    get inputEl() {
        return this._inputEl
    }
    get el() {
        return this._el
    }
    constructor(o, c, h) {
        this._el = o,
        this._inputEl = c,
        this._listeners = {
            drop: [],
            dropstart: [],
            droperror: []
        },
        this._onDragover = this._onDragover.bind(this),
        this._onDrop = this._onDrop.bind(this),
        this._onSelect = this._onSelect.bind(this),
        o == null || o.addEventListener("dragover", this._onDragover, !1),
        o == null || o.addEventListener("drop", this._onDrop, !1),
        c == null || c.addEventListener("change", this._onSelect),
        h && Object.entries(h).forEach( ([_,b]) => b && this.on(_, b))
    }
    on(o, c) {
        return this._listeners[o].push(c),
        this
    }
    _emit(o, c) {
        return this._listeners[o].forEach(h => h(c)),
        this
    }
    destroy() {
        const o = this._el
          , c = this._inputEl;
        o == null || o.removeEventListener("dragover", this._onDragover),
        o == null || o.removeEventListener("drop", this._onDrop),
        c == null || c.removeEventListener("change", this._onSelect)
    }
    _onDrop(o) {
        var c, h;
        o.stopPropagation(),
        o.preventDefault(),
        this._emit("dropstart");
        const _ = Array.from(((c = o.dataTransfer) === null || c === void 0 ? void 0 : c.files) || [])
          , b = Array.from(((h = o.dataTransfer) === null || h === void 0 ? void 0 : h.items) || []);
        if (_.length !== 0 || b.length !== 0)
            if (b.length > 0) {
                const _e = b.map(nt => nt.webkitGetAsEntry());
                this._loadNextEntry(new Map, _e)
            } else
                this._emit("drop", {
                    files: new Map(_.map(_e => (_e.filePath = _e.name,
                    [_e.filePath, _e])))
                });
        else
            this._fail("Required drag-and-drop APIs are not supported in this browser.")
    }
    _onDragover(o) {
        o.stopPropagation(),
        o.preventDefault(),
        o.dataTransfer && (o.dataTransfer.dropEffect = "copy")
    }
    _onSelect(o) {
        var c;
        if (!this._inputEl)
            return void console.warn("Invalid Dropzone event ", o);
        this._emit("dropstart");
        const h = [].slice.call((c = this._inputEl.files) !== null && c !== void 0 ? c : new FileList)
          , _ = new Map;
        h.forEach(b => {
            b.filePath = b.webkitRelativePath || b.name,
            _.set(b.filePath, b)
        }
        ),
        this._emit("drop", {
            files: _
        })
    }
    _loadNextEntry(o, c) {
        const h = c.pop();
        if (h)
            if (h.isFile)
                h.file(_ => {
                    _.filePath = h.fullPath,
                    o.set(h.fullPath, _),
                    this._loadNextEntry(o, c)
                }
                , () => console.error("Could not load file: %s", h.fullPath));
            else if (h.isDirectory) {
                const _ = h.createReader()
                  , b = _e => {
                    _e.length ? (c = c.concat(_e),
                    _.readEntries(b)) : this._loadNextEntry(o, c)
                }
                ;
                _.readEntries(b)
            } else
                console.warn("Unknown asset type: " + h.fullPath),
                this._loadNextEntry(o, c);
        else
            this._emit("drop", {
                files: o
            })
    }
    _fail(o) {
        this._emit("droperror", {
            message: o
        })
    }
}
class DropzonePlugin extends I$2 {
    constructor(o) {
        super(),
        this._domElement = o,
        this._allowedExtensions = void 0,
        this.importerParams = {
            autoScale: !0,
            autoScaleRadius: 2,
            pseudoCenter: !1,
            autoCenter: !0,
            autoImport: !0,
            autoAdd: !0,
            centerOffset: new three_module.Pq0(.5,.5,3)
        },
        this.dependencies = [AssetManagerPlugin],
        this.uiConfig = {
            type: "folder",
            label: "Drop Options",
            expanded: !0,
            children: [{
                label: "Auto Center",
                type: "checkbox",
                property: [this.importerParams, "autoCenter"],
                limitedUi: !0
            }, {
                label: "Auto Scale",
                type: "checkbox",
                property: [this.importerParams, "autoScale"],
                limitedUi: !0
            }, {
                label: "Auto scale radius",
                type: "slider",
                bounds: [.5, 100],
                property: [this.importerParams, "autoScaleRadius"]
            }, {
                label: "Select local file",
                type: "button",
                value: () => this.promptForFile()
            }]
        }
    }
    onAdded(o) {
        this._inputEl = document.createElement("input"),
        this._viewer = o,
        this._inputEl.type = "file",
        this._dropzone = new Dropzone(this._domElement || o.canvas,this._inputEl,{
            drop: this._onFileDrop.bind(this)
        })
    }
    async _onFileDrop({files: o}) {
        var c, h, _, b, _e, nt;
        if (!o)
            return;
        const it = this._viewer;
        if (!it)
            return;
        if (this._allowedExtensions !== void 0)
            for (const pt of o.keys())
                this._allowedExtensions.includes((h = (c = pt.split(".").pop()) === null || c === void 0 ? void 0 : c.toLowerCase()) !== null && h !== void 0 ? h : "") || o.delete(pt);
        if (o.size < 1)
            return;
        const at = it.getPlugin(AssetManagerPlugin)
          , ut = {
            type: "drop",
            files: o
        };
        if (this.importerParams.autoImport) {
            const pt = {
                allowedExtensions: this.allowedExtensions,
                ...this.importerParams
            };
            if (ut.imported = await ((_ = at.importer) === null || _ === void 0 ? void 0 : _.importFiles(o, pt)),
            this.importerParams.autoAdd) {
                const ht = (nt = [...(_e = (b = ut.imported) === null || b === void 0 ? void 0 : b.values()) !== null && _e !== void 0 ? _e : []].flat(2).filter(_t => !!_t)) !== null && nt !== void 0 ? nt : [];
                if (ut.assets = at.addProcessedAssets(ht, {
                    ...this.importerParams
                }),
                !pt._rootSceneImported)
                    for (const _t of ut.assets)
                        _t.modelObject && _t.modelObject.dispatchEvent({
                            type: "select",
                            value: _t.modelObject
                        })
            }
        }
        this.dispatchEvent(ut)
    }
    promptForFile() {
        var o;
        (o = this._inputEl) === null || o === void 0 || o.click()
    }
    onRemove(o) {
        var c;
        (c = this._dropzone) === null || c === void 0 || c.destroy(),
        this._dropzone = void 0,
        this._viewer = void 0
    }
    get allowedExtensions() {
        return this._allowedExtensions
    }
    set allowedExtensions(o) {
        this._allowedExtensions = o,
        this._inputEl && (this._inputEl.accept = o ? o.map(c => "." + c).join(", ") : "")
    }
}
function legacySeparateMapSamplerUVFix(d, o) {
    const c = (d.version ? d.version : "0.0.0").split(".").map(_ => parseInt(_));
    if (d.type !== "ViewerApp" || c[0] !== 0 || !(c[1] < 7 || c[1] === 7 && c[2].toString()[0] < "6"))
        return;
    const h = new Set;
    o.forEach(_ => _.traverse(b => {
        b.material && h.add(b.material)
    }
    )),
    h.forEach(_ => {
        const b = _.map;
        if (!b)
            return;
        const _e = b.repeat
          , nt = b.offset
          , it = b.center
          , at = b.rotation;
        ["alphaMap", "aoMap", "bumpMap", "displacementMap", "emissiveMap", "lightMap", "metalnessMap", "normalMap", "roughnessMap", "transmissionMap"].forEach(ut => {
            const pt = _[ut];
            pt && (pt.repeat.copy(_e),
            pt.offset.copy(nt),
            pt.center.copy(it),
            pt.rotation = at,
            pt.needsUpdate = !0)
        }
        ),
        _.needsUpdate = !0
    }
    )
}
DropzonePlugin.PluginType = "Dropzone";
var ViewerApp_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
function getPluginType(d) {
    return Object.getPrototypeOf(d).constructor.PluginType
}
class ViewerApp extends I$2 {
    get useRgbm() {
        return this._useRgbm
    }
    get screenShader() {
        return this._screenShader
    }
    get useGBufferDepth() {
        return this._useGBufferDepth
    }
    get isAntialiased() {
        return this._isAntialiased
    }
    constructor({isAntialiased: o=!1, useRgbm: c=!0, useGBufferDepth: h=!1, screenShader: _="", maxHDRIntensity: b, ..._e}) {
        var nt, it;
        super(),
        this.console = console,
        this._state = ViewerState.None,
        this.plugins = {},
        this._needsResize = !1,
        this.resizeObserver = window.ResizeObserver ? new window.ResizeObserver(vt => this.resize()) : void 0,
        this._lastSize = new three_module.I9Y,
        this._onContextRestore = vt => {
            this.enabled = !0,
            this._canvas.width = this._lastSize.width,
            this._canvas.height = this._lastSize.height,
            this.resize(),
            this.scene.setDirty({
                sceneUpdate: !0,
                frameFade: !1
            })
        }
        ,
        this._onContextLost = vt => {
            this._lastSize.set(this._canvas.width, this._canvas.height),
            this._canvas.width = 2,
            this._canvas.height = 2,
            this.resize(),
            this.enabled = !1
        }
        ,
        this.resize = () => {
            this._needsResize = !0,
            this.setDirty()
        }
        ,
        this._needsReset = !0,
        this.enabled = !0,
        this.renderEnabled = !0,
        this._isRenderingFrame = !1,
        this.maxFramePerLoop = 1,
        this.rendersPerFrame = 1,
        this._rawBackground = null,
        this._sceneEnvironmentChanged = () => {
            this._rawBackground === envMapBackground && this.scene.setBackground(this.scene.getEnvironment())
        }
        ,
        this._addSceneObject = vt => {
            var bt, St;
            if (!vt || !vt.object || vt.options && vt.options.importConfig === !1)
                return;
            const At = vt.object.__importedViewerConfig || ((bt = vt.object.modelObject) === null || bt === void 0 ? void 0 : bt.__importedViewerConfig);
            if (!At)
                return;
            const Et = this.getManager();
            legacySeparateMapSamplerUVFix(At, !((St = vt.options) === null || St === void 0) && St.allImported ? vt.options.allImported : [vt.object]),
            Et ? Et.applyViewerConfig(At, At.resources) : this.fromJSON(At, At.resources)
        }
        ,
        this.serializePluginsIgnored = [],
        this.alert = async vt => alert(vt),
        this.confirm = async vt => confirm(vt),
        this.prompt = async (vt, bt, St=!0) => prompt(vt, bt),
        this._useRgbm = c,
        this._useGBufferDepth = h,
        this._screenShader = _,
        this._canvas = _e.canvas || j();
        let at = _e.container;
        if (at && !_e.canvas && at.appendChild(this._canvas),
        at || (at = (nt = this._canvas.parentElement) !== null && nt !== void 0 ? nt : void 0),
        !at)
            throw new Error("No container.");
        this._container = at,
        this._animationLoop = this._animationLoop.bind(this),
        this.setDirty = this.setDirty.bind(this),
        this._setActiveCameraView = this._setActiveCameraView.bind(this),
        window.webGiViewers || (window.webGiViewers = []),
        window.webGiViewers.push(this),
        checkVersion();
        const ut = new CameraController(void 0,void 0,this._canvas);
        ut.autoLookAtTarget = !0,
        this.addEventListener("postFrame", () => {
            var vt, bt;
            const St = ht.scene.activeCamera;
            if (St && St.interactionsEnabled) {
                const At = (vt = this.getPluginByType("Progressive")) === null || vt === void 0 ? void 0 : vt.postFrameConvergedRecordingDelta();
                if (At !== void 0 && At === 0)
                    return;
                (bt = St.controls) === null || bt === void 0 || bt.update()
            }
        }
        ),
        this.scene = new RootScene(ut),
        this.scene.addEventListener("environmentChanged", this._sceneEnvironmentChanged),
        this.scene.addEventListener("addSceneObject", this._addSceneObject),
        this.scene.addEventListener("setView", this._setActiveCameraView),
        this.scene.addEventListener("activateMain", this._setActiveCameraView),
        this.scene.modelRoot.modelObject.scale.setScalar((it = _e.modelRootScale) !== null && it !== void 0 ? it : 1),
        this._renderer = new BaseRenderer({
            canvas: this._canvas,
            animationLoop: this._animationLoop,
            targetOptions: {
                samples: o ? 4 : 0,
                colorSpace: c ? RGBM16ColorSpace_ : three_module.jf0,
                type: c ? three_module.OUM : three_module.ix0,
                depthBuffer: !h,
                generateMipmaps: !!o,
                minFilter: o ? three_module.NZq : three_module.k6q
            },
            maxHDRIntensity: b || (c ? 16 : 80)
        }),
        this._isAntialiased = o && this._renderer.isWebGL2;
        let pt = !0;
        this._renderer.rendererObject.userData || (pt = !1,
        this._renderer.rendererObject.userData = {}),
        this._renderer.rendererObject.userData.renderTransmissionPass = !pt;
        const ht = this;
        this.renderFilter = {
            passId: "render",
            passObject: new RenderPass2(this,pt),
            update() {
                const vt = this.passObject;
                vt.scene = ht.scene.modelObject,
                vt.camera = ht.scene.renderCamera.cameraObject
            }
        };
        const _t = {
            passId: "screen",
            after: ["render"],
            required: ["render"],
            passObject: buildScreenShader(_)
        };
        [this.renderFilter, _t].forEach(vt => this._renderer.registerPass(vt)),
        this._renderer.pipeline = ["render", "screen"],
        this.scene.addEventListener("textureUpdate", vt => this.setDirty(this.scene, vt)),
        this.scene.addEventListener("sceneMaterialUpdate", vt => this.setDirty(this.scene, vt)),
        this.scene.addEventListener("sceneUpdate", vt => {
            this.setDirty(this.scene, vt),
            vt.geometryChanged !== !1 && this.renderer.resetShadows()
        }
        ),
        this.scene.addEventListener("update", vt => this.setDirty(this.scene, vt)),
        this._renderer.addEventListener("update", vt => this.setDirty(this._renderer, vt)),
        this.resizeObserver && this.resizeObserver.observe(this._canvas),
        window && window.addEventListener("resize", this.resize),
        this._canvas.addEventListener("webglcontextrestored", this._onContextRestore, !1),
        this._canvas.addEventListener("webglcontextlost", this._onContextLost, !1),
        this.renderer.addEventListener("resize", () => {
            this.scene.activeCamera.refreshAspect()
        }
        ),
        this.scene.setBackgroundColor("#ffffff"),
        _e.assetManager && this.addPluginSync(new AssetManagerPlugin(void 0,void 0,typeof _e.assetManager == "boolean" ? {} : _e.assetManager)),
        _e.dropzone && this.addPluginSync(new DropzonePlugin),
        this.console.log("WebGi Viewer instance initialized, version: ", ViewerApp.VERSION)
    }
    setDirty(o, c) {
        this._needsReset = !0,
        o = o ?? this,
        this.dispatchEvent({
            ...c ?? {},
            type: "update",
            source: o
        })
    }
    get renderer() {
        return this._renderer
    }
    dispose() {
        var o;
        for (const c of [...Object.values(this.plugins)])
            this.removePlugin(c, !0);
        this.scene.dispose(),
        this.renderer.dispose(),
        this._canvas.removeEventListener("webglcontextrestored", this._onContextRestore, !1),
        this._canvas.removeEventListener("webglcontextlost", this._onContextLost, !1),
        (o = window.webGiViewers) === null || o === void 0 || o.splice(window.webGiViewers.indexOf(this), 1),
        this.resizeObserver ? this.resizeObserver.unobserve(this._canvas) : window.removeEventListener("resize", this.resize),
        this.dispatchEvent({
            type: "dispose"
        })
    }
    _renderEnabledChanged() {
        this.dispatchEvent({
            type: this.renderEnabled ? "renderEnabled" : "renderDisabled"
        })
    }
    _animationLoop({time: o, deltaTime: c, xrFrame: h}) {
        var _, b;
        if (this.enabled && this.renderEnabled)
            if (this._isRenderingFrame)
                this.console.warn("animation loop: frame skip");
            else {
                this._isRenderingFrame = !0;
                for (let _e = 0; _e < this.maxFramePerLoop; _e++) {
                    if (this._needsReset && (this._renderer.reset(),
                    this._needsReset = !1),
                    this._needsResize) {
                        const at = [this._canvas.clientWidth, this._canvas.clientHeight];
                        if (h) {
                            const ut = (b = (_ = this._renderer.rendererObject.xr.getCamera()) === null || _ === void 0 ? void 0 : _.cameras[0]) === null || b === void 0 ? void 0 : b.viewport;
                            ut ? (ut.x === 0 && ut.y === 0 || this.console.warn("x and y must be 0?"),
                            at[0] = ut.width,
                            at[1] = ut.height,
                            this.console.log("resize for xr", at)) : this._needsResize = !1
                        }
                        this._needsResize && (this._renderer.setSize(...at),
                        this._needsResize = !1)
                    }
                    this.dispatchEvent({
                        type: "preFrame",
                        target: this,
                        time: o,
                        deltaTime: c,
                        xrFrame: h
                    });
                    const nt = Object.values(this.plugins).filter(at => at.dirty);
                    nt.length > 0 && this.setDirty(nt),
                    this._needsReset && (this._renderer.reset(),
                    this._needsReset = !1),
                    this._renderer.updateDirty();
                    const it = this._renderer.dirty;
                    if (it)
                        for (let at = 0; at < this.rendersPerFrame; at++) {
                            this.dispatchEvent({
                                type: "preRender",
                                target: this
                            });
                            try {
                                this.scene.renderCamera = this.scene.activeCamera,
                                this._renderer.render(this._renderer.defaultRenderToScreen)
                            } catch (ut) {
                                this.console.error(ut),
                                this.enabled = !1
                            }
                            this.dispatchEvent({
                                type: "postRender",
                                target: this
                            })
                        }
                    if (this.dispatchEvent({
                        type: "postFrame",
                        target: this
                    }),
                    !it)
                        break
                }
                this._isRenderingFrame = !1
            }
    }
    get state() {
        return this._state
    }
    get container() {
        return this._canvas.parentElement !== this._container && this.console.error("ViewerApp: Canvas is not in the container, this might cause issues with some plugins."),
        this._container
    }
    get canvas() {
        return this._canvas
    }
    get canvasTexture() {
        if (!this._canvas)
            throw new Error("Canvas not found");
        return this._canvasTexture || (this._canvasTexture = new three_module.GOR(this._canvas),
        this._canvasTexture.flipY = !1,
        this._canvasTexture.needsUpdate = !0),
        this._canvasTexture
    }
    getPlugin(o) {
        return typeof o == "string" ? this.getPluginByType(o) : this.plugins[o.PluginType]
    }
    getPluginByType(o) {
        return this.plugins[o]
    }
    async getOrAddPlugin(o, ...c) {
        return this.getPlugin(o) || this.addPlugin(o, ...c)
    }
    getOrAddPluginSync(o, ...c) {
        return this.getPlugin(o) || this.addPluginSync(o, ...c)
    }
    async addPlugin(o, ...c) {
        let h;
        if (o.prototype) {
            const b = this.getPlugin(o);
            if (b)
                return console.error(`Plugin of type ${getPluginType(b)} already exists, no new plugin created`, b),
                b;
            h = new o(...c)
        } else
            h = o;
        const _ = getPluginType(h);
        if (!_)
            return this.console.error("PluginType is not defined for", h),
            h;
        for (const b of h.dependencies || [])
            await this.getOrAddPlugin(b);
        return this.plugins[_] && (this.console.error(`Plugin of type ${_} already exists, old plugin will be removed and disposed`, this.plugins[_], h),
        await this.removePlugin(this.plugins[_], !0)),
        this.plugins[_] = h,
        await h.onAdded(this),
        this.dispatchEvent({
            type: "addPlugin",
            target: this,
            plugin: h
        }),
        this.setDirty(h),
        h
    }
    addPluginSync(o, ...c) {
        let h;
        if (o.prototype) {
            const b = this.getPlugin(o);
            if (b)
                return console.error(`Plugin of type ${getPluginType(b)} already exists, no new plugin created`, b),
                b;
            h = new o(...c)
        } else
            h = o;
        const _ = getPluginType(h);
        if (!_)
            return this.console.error("PluginType is not defined for", h),
            h;
        for (const b of h.dependencies || [])
            this.getOrAddPluginSync(b);
        return this.plugins[_] && (this.console.error(`Plugin of type ${_} already exists, old plugin will be removed and disposed`, this.plugins[_], h),
        this.removePluginSync(this.plugins[_], !0)),
        this.plugins[_] = h,
        h.onAdded(this),
        this.dispatchEvent({
            type: "addPlugin",
            target: this,
            plugin: h
        }),
        this.setDirty(h),
        h
    }
    async addPlugins(o) {
        for (const c of o)
            await this.addPlugin(c)
    }
    async addPluginsSync(o) {
        for (const c of o)
            this.addPluginSync(c)
    }
    async removePlugin(o, c=!0) {
        const h = getPluginType(o);
        this.plugins[h] && (await o.onRemove(this),
        delete this.plugins[h],
        c && o.onDispose && await o.onDispose(this),
        this.setDirty(o))
    }
    removePluginSync(o, c=!0) {
        const h = getPluginType(o);
        this.plugins[h] && (o.onRemove(this),
        delete this.plugins[h],
        c && o.onDispose && o.onDispose(this),
        this.setDirty(o))
    }
    createCamera(o) {
        var c;
        const h = (c = o.userData.iCamera) !== null && c !== void 0 ? c : new CameraController(o,{
            controlsMode: "",
            aspect: "auto"
        },this._canvas);
        return o.userData.autoLookAtTarget === void 0 ? (h.autoLookAtTarget = !1,
        o.userData.autoLookAtTarget = !1) : h.autoLookAtTarget = o.userData.autoLookAtTarget,
        h
    }
    setSize(o) {
        this._canvas.style.width = o != null && o.width ? o.width + "px" : "100%",
        this._canvas.style.height = o != null && o.height ? o.height + "px" : "100%",
        this._canvas.offsetHeight,
        this.resize()
    }
    async doOnce(o, c) {
        return new Promise(h => {
            const _ = async (...b) => {
                this.removeEventListener(o, _),
                h(await (c == null ? void 0 : c(...b)))
            }
            ;
            this.addEventListener(o, _)
        }
        )
    }
    setBackgroundColor(o) {
        return console.warn("viewer.setBackground is deprecated, use viewer.scene.setBackgroundColor instead."),
        this.setBackgroundColor(o)
    }
    setBackground(o) {
        if (console.warn("viewer.setBackground is deprecated, use viewer.scene.setBackground instead."),
        this._rawBackground = o,
        o == null || typeof o != "string" && typeof o != "number" && !o.isColor)
            !o && this.useRgbm && this.console.error("Transparent background not supported with HDR RGBM rendering mode");
        else if (o === envMapBackground)
            return this.scene.setBackground("environment");
        !o || o != null && o.isTexture ? (this.scene.setBackground(o),
        o || this.scene.setBackgroundColor(o)) : this.scene.setBackgroundColor(o)
    }
    getBackground(o=!1) {
        var c;
        if (console.warn("viewer.getBackground is deprecated, use viewer.scene.background instead."),
        o)
            return this._rawBackground;
        let h = (c = this._rawBackground) !== null && c !== void 0 ? c : this.scene.getBackground();
        return h ? (h != null && h.isVector4 && (h = cRGBMToLinear(h, 7).getHexString()),
        h != null && h.isColor ? h.getHexString() : this._rawBackground === envMapBackground ? this.scene.getEnvironment() : h) : null
    }
    getManager() {
        return this.getPluginByType("AssetManager") || this.addPluginSync(AssetManagerPlugin)
    }
    resetCamera({rootObject: o, centerOffset: c=new three_module.Pq0(1,1,1), targetOffset: h=new three_module.Pq0(0,0,0), ..._}={}) {
        if (this.scene.activeCamera) {
            this.scene.matrixWorldNeedsUpdate = !0,
            this.scene.updateMatrixWorld(!0);
            const b = o ? new Box3B().expandByObject(o, !0, !0) : this.scene.getBounds(!0)
              , _e = b.getCenter(new three_module.Pq0)
              , nt = .5 * b.getSize(new three_module.Pq0).length();
            _e.add(h.clone().multiplyScalar(nt)),
            this.scene.activeCamera.position = new three_module.Pq0(_e.x + c.x * nt,_e.y + c.y * nt,_e.z + c.z * nt),
            this.scene.activeCamera.target = _e,
            this.setDirty()
        }
    }
    async fitToView(o, c=1.5, h, _) {
        var b, _e;
        const nt = this.getPluginByType("CameraViews");
        nt ? await (nt == null ? void 0 : nt.animateToFitObject(o, c, h, _, {
            min: ((_e = (b = this.scene.activeCamera.getControls()) === null || b === void 0 ? void 0 : b.minDistance) !== null && _e !== void 0 ? _e : .5) + .5,
            max: 1e3
        })) : this.console.error("CameraViews plugin is required for fitToView to work")
    }
    async createObject3D(o, c=!1) {
        var h;
        return (h = this.getManager()) === null || h === void 0 ? void 0 : h.addImportedSingle(o || new three_module.B69, {
            autoScale: !1,
            pseudoCenter: !1,
            addToRoot: c
        })
    }
    createPhysicalMaterial(o) {
        return this.createMaterial("standard", o)
    }
    createMaterial(o, c) {
        var h, _, b, _e;
        if (c != null && c.isMaterial) {
            const nt = (_ = (h = this.getManager()) === null || h === void 0 ? void 0 : h.materials) === null || _ === void 0 ? void 0 : _.findMaterial(c.uuid);
            if (nt)
                return nt
        }
        return (_e = (b = this.getManager()) === null || b === void 0 ? void 0 : b.materials) === null || _e === void 0 ? void 0 : _e.generateFromTemplate(o, c)
    }
    serializePlugins(o, c) {
        return Object.entries(this.plugins).map(h => {
            if ((!c || c.includes(h[1].constructor.PluginType)) && !this.serializePluginsIgnored.includes(h[1].constructor.PluginType))
                return h[1].serializeWithViewer !== !1 && typeof h[1].toJSON == "function" ? h[1].toJSON(o) : void 0
        }
        ).filter(h => !!h)
    }
    deserializePlugins(o, c) {
        return o.forEach(h => {
            if (!h.type)
                return void this.console.warn("Invalid plugin to import ", h);
            if (this.serializePluginsIgnored.includes(h.type))
                return;
            const _ = this.getPluginByType(h.type);
            _ && _.fromJSON && _.fromJSON(h, c)
        }
        ),
        this
    }
    traverseSceneObjects(o) {
        this.scene.modelRoot.modelObject.traverse(o)
    }
    toJSON(o, c) {
        const h = Object.assign({
            version: ViewerApp.VERSION,
            type: "ViewerApp",
            metadata: {
                generator: "WebGiViewerApp",
                version: 1
            },
            plugins: this.serializePlugins(o, c)
        }, serializeObject(this, !0, o));
        return h.backgroundIntensity = this.scene.backgroundIntensity,
        h.useLegacyLights = this.renderer.useLegacyLights,
        h.background = h.scene.background || h.scene.backgroundColor,
        h.background === "environment" && (h.background = "envMapBackground"),
        h
    }
    fromJSON(o, c) {
        var h, _, b, _e, nt;
        const it = {
            ...o
        };
        return it.backgroundIntensity !== void 0 && ((h = it.scene) === null || h === void 0 ? void 0 : h.backgroundIntensity) === void 0 && (this.console.warn("old file format, backgroundIntensity moved to RootScene"),
        this.scene.backgroundIntensity = it.backgroundIntensity,
        delete it.backgroundIntensity),
        it.useLegacyLights !== void 0 && ((_ = it.renderManager) === null || _ === void 0 ? void 0 : _.useLegacyLights) === void 0 && (this.console.warn("old file format, useLegacyLights moved to BaseRenderer"),
        this.renderer.useLegacyLights = it.useLegacyLights,
        delete it.useLegacyLights),
        it.background !== void 0 && ((b = it.scene) === null || b === void 0 ? void 0 : b.background) === void 0 && (this.console.warn("old file format, background moved to RootScene"),
        it.background === "envMapBackground" ? it.background = "environment" : typeof it.background == "number" ? it.background = new three_module.Q1f().setHex(it.background, three_module.Zr2) : typeof it.background == "string" ? it.background = new three_module.Q1f().setStyle(it.background, three_module.Zr2) : !((_e = it.background) === null || _e === void 0) && _e.isColor && (it.background = new three_module.Q1f(it.background)),
        !((nt = it.background) === null || nt === void 0) && nt.isColor ? (this.scene.backgroundColor = it.background,
        this.scene.background = null) : it.background ? (this.scene.backgroundColor = new three_module.Q1f("#ffffff"),
        it.scene.background = it.background) : (this.scene.backgroundColor = null,
        this.scene.background = null),
        delete it.background),
        deserializeObject(it, this, !0, c),
        Array.isArray(it.plugins) && this.deserializePlugins(it.plugins, c),
        this
    }
    get renderManager() {
        return this._renderer
    }
    get assetManager() {
        return this.getManager()
    }
    async load(o, c) {
        if (o)
            return await this.assetManager.addAssetSingle(o, c)
    }
    async setEnvironmentMap(o, {setBackground: c=!1, ...h}={}) {
        return this.scene.environment = o && !o.isTexture ? await this.assetManager.importer.importSingle(o, h) || null : o || null,
        c ? this.setBackgroundMap(this.scene.environment) : this.scene.environment
    }
    async setBackgroundMap(o, {setEnvironment: c=!1, ...h}={}) {
        return this.scene.background = o && !o.isTexture ? await this.assetManager.importer.importSingle(o, h) || null : o || null,
        c ? this.setEnvironmentMap(this.scene.background) : this.scene.background
    }
    _setActiveCameraView(o={}) {
        if (o.type === "setView") {
            if (!o.camera)
                return void this.console.warn("Cannot find camera", o);
            this.scene.activeCamera.copyFromCamera(o.camera)
        } else
            o.type === "activateMain" && (this.scene.activeCamera = o.camera ? this.createCamera(o.camera) : void 0)
    }
}
async function checkVersion() {
    var d;
    const o = window.location.href
      , c = "https://dev-sandbox.pixotronics.com/webgi/";
    if (!o.startsWith(c) || rt("noUpdate") !== null)
        return !0;
    const h = (d = o.match(/\/webgi\/([0-9.a-zA-Z-]+)/)) === null || d === void 0 ? void 0 : d[1]
      , _ = (await (await fetch(c + "version.txt")).text()).split(`
`)[0];
    if (h && h !== _) {
        if (confirm(`New version ${_} is available, do you want to open?`)) {
            const b = window.location.href.replace(h, _);
            return window.location.href = b,
            !1
        }
        window.location.href.includes("noUpdate") || (window.location.href += (window.location.href.includes("?") ? "&" : "?") + "noUpdate")
    }
    return !0
}
ViewerApp.VERSION = VIEWER_VERSION,
ViewerApp_decorate([serialize("renderManager")], ViewerApp.prototype, "_renderer", void 0),
ViewerApp_decorate([serialize()], ViewerApp.prototype, "scene", void 0),
ViewerApp_decorate([x$1(ViewerApp.prototype._renderEnabledChanged)], ViewerApp.prototype, "renderEnabled", void 0);
const envMapBackground = "envMapBackground";
function buildScreenShader(d) {
    return d != null && d.isShaderPass2 ? d : new ShaderPass2({
        ...CopyShader,
        fragmentShader: `
                       varying vec2 vUv;
                       
                       ${Array.isArray(d) ? d[0] : (d == null ? void 0 : d.pars) || ""}
                       
                       void main() {

                            gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                            
                            ${Array.isArray(d) ? d[1] : typeof d == "string" ? d : (d == null ? void 0 : d.main) || ""}
                            
                        }`,
        uniforms: {
            tDiffuse: {
                value: null
            }
        }
    },"tDiffuse")
}
var tonemapping = `int getToneMapBit(in int number){
#ifdef WebGL2Context
return(number/2)%2;
#else
return int(mod(floor(float(number)/2.),2.));
#endif
}vec3 TonemappingSaturation(vec3 rgb){const vec3 W=vec3(0.2125,0.7154,0.0721);vec3 intensity=vec3(dot(rgb,W));return mix(intensity,rgb,toneMappingSaturation);}vec3 TonemappingContrast(vec3 color){return(color-vec3(0.5))*toneMappingContrast+vec3(0.5);}vec4 ToneMapping(in vec4 color){vec4 outColor=opacity*color;
#if USE_DEPTH_TONEMAP > 0
bool doTonemap=getToneMapBit(getGBufferFlags(vUv).a)>0;float depth=getDepth(vUv);vec4 transparentCol=tTransparentTexelToLinear(texture2D(tTransparent,vUv));
#if TONEMAP_BACKGROUND < 1 || TRANSPARENT_BACKGROUND > 0
bool isBackground=depth>0.99&&transparentCol.a<0.001;if(isBackground)doTonemap=false;
#endif
if(doTonemap){
#endif
#if defined( TONE_MAPPING )
outColor.rgb=toneMapping(outColor.rgb);outColor.rgb=TonemappingContrast(outColor.rgb);outColor.rgb=TonemappingSaturation(outColor.rgb);
#endif
#if USE_DEPTH_TONEMAP > 0
}
#if TRANSPARENT_BACKGROUND > 0
if(isBackground)outColor.a=0.;if(depth>0.99&&transparentCol.a>=0.001)outColor.a=transparentCol.a;
#endif
if(depth<0.00001)outColor.a=0.;
#if defined(DEBUG_DEPTH) && DEBUG_DEPTH > 0
outColor.rgb=vec3(sRGBToLinear(vec4((1.-depth))).x);
#endif
#endif
return outColor;}`;
class CombinedPostPass extends ShaderPass2 {
    constructor(o) {
        super({
            vertexShader: CopyShader.vertexShader,
            uniforms: {
                tDiffuse: {
                    value: null
                },
                tNormalDepth: {
                    value: null
                },
                tGBufferFlags: {
                    value: null
                },
                tTransparent: {
                    value: null
                }
            },
            defines: {},
            fragmentShader: `
                varying vec2 vUv;
                ${o[0]}
                void main() {
                    gl_FragColor = tDiffuseTexelToLinear (texture2D(tDiffuse, vUv));
                    #glMarker
                    ${o[1]}
                    
                    gl_FragColor.rgb *= gl_FragColor.a; // premultiply alpha
                }
                `
        }, "tDiffuse", "tTransparent"),
        this.uiConfig = void 0,
        this.material.transparent = !1,
        this.material.side = three_module.hB5
    }
    render(o, c, h, _, b) {
        super.render(o, c, h, _, b),
        this._lastReadBuffer = h,
        this.needsSwap = !0
    }
    reRender(o, c, h, _) {
        this._lastReadBuffer && this.render(o, c, this._lastReadBuffer, h, _)
    }
    dispose() {
        this._lastReadBuffer = void 0,
        super.dispose()
    }
}
class CombinedPostPlugin extends GenericFilterPlugin {
    get renderToScreen() {
        return this._renderToScreen
    }
    constructor(o=!0, c=!0) {
        super(),
        this.depthTonemap = o,
        this.passId = "combinedPost",
        this.dependencies = [GBufferPlugin],
        this.toJSON = void 0,
        this._beforeFilters = [],
        this._afterFilters = ["render", "screen"],
        this._requiredFilters = ["render"],
        this._renderToScreen = !0,
        this._postFrame = () => {
            var h, _;
            this._needsReRender && this._renderToScreen && this._viewer && this.pass && (this._needsReRender = !1,
            (_ = (h = this.pass).update) === null || _ === void 0 || _.call(h),
            this.pass.passObject.reRender(this._viewer.renderer.rendererObject, null))
        }
        ,
        this._needsReRender = !1,
        this._setDirty = this._setDirty.bind(this),
        this._renderToScreen = c
    }
    async onAdded(o) {
        var c, h;
        return !((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.screenShader) === null || h === void 0) && h.isShaderPass2 && (this._renderToScreen = !1),
        this._renderToScreen && S$2(o.renderer.passes.find(_ => _.passId === "screen"), "enabled", !1, !0, !0),
        o.addEventListener("postFrame", this._postFrame),
        super.onAdded(o)
    }
    async onRemove(o) {
        return this._renderToScreen && S$2(o.renderer.passes.find(c => c.passId === "screen"), "enabled", !0, !0, !0),
        super.onRemove(o)
    }
    passCtor(o) {
        var c, h;
        const _ = o.screenShader
          , b = ["", ""];
        this._renderToScreen && !_.isShaderPass2 && (b[0] = Array.isArray(_) ? _[0] : (_ == null ? void 0 : _.pars) || "",
        b[1] = Array.isArray(_) ? _[1] : typeof _ == "string" ? _ : (_ == null ? void 0 : _.main) || "");
        const _e = new CombinedPostPass(b);
        return S$2((h = (c = _e.uiConfig) === null || c === void 0 ? void 0 : c.children) === null || h === void 0 ? void 0 : h.find(nt => (nt == null ? void 0 : nt.label) === "Enabled"), "hidden", !0, !0),
        _e
    }
    _update(o) {
        var c, h, _;
        return !!super._update(o) && (this._pass.passObject.updateShaderProperties((c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(GBufferPlugin)),
        this._pass.passObject.material.uniforms.tTransparent.value = ((_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.renderFilter.passObject.transparentTarget) === null || _ === void 0 ? void 0 : _.texture) || null,
        !0)
    }
    _setDirty() {
        this.pass && (this.pass.dirty = !0)
    }
    get uiConfig() {
        var o, c, h;
        return (h = (c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.uiConfig) !== null && h !== void 0 ? h : {}
    }
    addExtension(o) {
        this.pass.passObject.material.registerMaterialExtensions([o])
    }
    reRender() {
        this._renderToScreen ? this._needsReRender = !0 : this._setDirty()
    }
}
CombinedPostPlugin.PluginType = "CombinedPostPlugin";
var GenericExtensionPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class GenericExtensionPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.dependencies = [CombinedPostPlugin]
    }
    get uiConfig() {
        var o;
        return (o = this._extension) === null || o === void 0 ? void 0 : o.uiConfig
    }
    get config() {
        return this._extension
    }
    disposeExtension() {}
    async onAdded(o) {
        var c;
        await super.onAdded(o),
        this._extension = this.generateExtension(o),
        (c = o.getPlugin(CombinedPostPlugin)) === null || c === void 0 || c.addExtension(this._extension)
    }
    async onRemove(o) {
        this.disposeExtension(),
        this._extension = void 0,
        await super.onRemove(o)
    }
}
function updateBit(d, o, c) {
    return d & ~(1 << o) | (c ? 1 : 0) << o
}
function clearBit(d, o) {
    return d & ~(1 << o)
}
GenericExtensionPlugin_decorate([serialize("extension")], GenericExtensionPlugin.prototype, "_extension", void 0),
GenericExtensionPlugin_decorate([serialize()], GenericExtensionPlugin.prototype, "enabled", void 0);
var TonemapPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const Uncharted2Tonemapping = three_module.g7M;
let TonemapExtension = class {
    constructor(d, o=!0) {
        this.depthTonemap = o,
        this.toneMapping = three_module.FV,
        this.tonemapBackground = !0,
        this.clipBackground = !1,
        this.exposure = 1,
        this.saturation = 1,
        this.contrast = 1,
        this.renderDepth = !1,
        this.enabled = !0,
        this._rendererState = {},
        this.extraUniforms = {
            opacity: {
                value: 1
            },
            toneMappingContrast: {
                value: 1
            },
            toneMappingSaturation: {
                value: 1
            }
        },
        this.parsFragmentSnippet = (c, h) => this.enabled ? fe$1`
            ${this.depthTonemap ? unpackGbuffer : ""}
            #define USE_DEPTH_TONEMAP ${this.depthTonemap ? "1" : "0"}
            uniform float opacity;
            uniform float toneMappingContrast;
            uniform float toneMappingSaturation;
            ${tonemapping}
        ` : "",
        this._combinedPostPlugin = d.getPlugin(CombinedPostPlugin),
        this._setDirty = this._setDirty.bind(this),
        this.depthTonemap = o
    }
    shaderExtender(d, o, c) {
        this.enabled && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker", `
gl_FragColor = ToneMapping(gl_FragColor);
`, {
            prepend: !0
        }))
    }
    onObjectRender(d, o, c) {
        if (!this.enabled)
            return;
        const {toneMapping: h, toneMappingExposure: _, outputColorSpace: b} = c;
        this._rendererState.toneMapping = h,
        this._rendererState.toneMappingExposure = _,
        this._rendererState.outputColorSpace = b;
        let _e = this.tonemapBackground ? "1" : "0";
        o.materialObject.defines.TONEMAP_BACKGROUND !== _e && (o.materialObject.defines.TONEMAP_BACKGROUND = _e,
        o.materialObject.needsUpdate = !0),
        _e = this.clipBackground ? "1" : "0",
        o.materialObject.defines.TRANSPARENT_BACKGROUND !== _e && (o.materialObject.defines.TRANSPARENT_BACKGROUND = _e,
        o.materialObject.needsUpdate = !0),
        _e = this.renderDepth ? "1" : "0",
        o.materialObject.defines.DEBUG_DEPTH !== _e && (o.materialObject.defines.DEBUG_DEPTH = _e,
        o.materialObject.needsUpdate = !0),
        c.toneMapping = this.toneMapping,
        c.toneMappingExposure = this.exposure,
        c.outputColorSpace = three_module.er$,
        o.materialObject.toneMapped = !0,
        o.materialObject.needsUpdate = !0,
        this.extraUniforms.toneMappingContrast.value = this.contrast,
        this.extraUniforms.toneMappingSaturation.value = this.saturation
    }
    onAfterRender(d, o, c) {
        c.toneMapping = this._rendererState.toneMapping,
        c.toneMappingExposure = this._rendererState.toneMappingExposure,
        c.outputColorSpace = this._rendererState.outputColorSpace
    }
    getUiConfig() {
        return this.uiConfig
    }
    computeCacheKey(d) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(d) {
        return !0
    }
    _setDirty() {
        this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0)
    }
    setDirty() {
        var d;
        (d = this.__setDirty) === null || d === void 0 || d.call(this),
        this._setDirty()
    }
}
;
TonemapExtension.PluginType = "Tonemap",
TonemapPlugin_decorate([uiDropdown("Mode", [["Linear", three_module.kyO], ["Reinhard", three_module.Mjd], ["Cineon", three_module.nNL], ["ACESFilmic", three_module.FV], ["Uncharted2", Uncharted2Tonemapping]].map(d => ({
    label: d[0],
    value: d[1]
})), {
    limitedUi: !0
}), x$1(TonemapExtension.prototype._setDirty), serialize()], TonemapExtension.prototype, "toneMapping", void 0),
TonemapPlugin_decorate([x$1(TonemapExtension.prototype._setDirty), uiToggle("Tonemap Background", {
    limitedUi: !0
}), serialize()], TonemapExtension.prototype, "tonemapBackground", void 0),
TonemapPlugin_decorate([x$1(TonemapExtension.prototype._setDirty), uiToggle("Clip Background"), serialize()], TonemapExtension.prototype, "clipBackground", void 0),
TonemapPlugin_decorate([x$1(TonemapExtension.prototype._setDirty), uiSlider("Exposure", [0, 2 * Math.PI], .01, {
    limitedUi: !0
}), serialize()], TonemapExtension.prototype, "exposure", void 0),
TonemapPlugin_decorate([x$1(TonemapExtension.prototype._setDirty), uiSlider("Saturation", [0, 2], .01, {
    limitedUi: !0
}), serialize()], TonemapExtension.prototype, "saturation", void 0),
TonemapPlugin_decorate([x$1(TonemapExtension.prototype._setDirty), uiSlider("Contrast", [0, 2], .01, {
    limitedUi: !0
}), serialize()], TonemapExtension.prototype, "contrast", void 0),
TonemapPlugin_decorate([x$1(TonemapExtension.prototype._setDirty), uiToggle("Render Depth")], TonemapExtension.prototype, "renderDepth", void 0),
TonemapExtension = TonemapPlugin_decorate([uiFolder("Tonemapping")], TonemapExtension);
class TonemapPlugin extends GenericExtensionPlugin {
    constructor(o=!0) {
        super(),
        this.depthTonemap = o,
        this.depthTonemap = o,
        this.updateGBuffer = this.updateGBuffer.bind(this)
    }
    fromJSON(o, c) {
        return o.pass && ((o = {
            ...o
        }).extension = {
            ...o.pass
        },
        delete o.extension.enabled,
        delete o.pass),
        super.fromJSON(o, c)
    }
    async onAdded(o) {
        var c;
        await super.onAdded(o),
        (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 || c.registerGBufferUpdater(this.updateGBuffer)
    }
    generateExtension(o) {
        return new TonemapExtension(o,this.depthTonemap)
    }
    get exposure() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.exposure) !== null && c !== void 0 ? c : 1
    }
    set exposure(o) {
        this._extension && (this._extension.exposure = o,
        this._extension.setDirty())
    }
    get saturation() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.saturation) !== null && c !== void 0 ? c : 1
    }
    set saturation(o) {
        this._extension && (this._extension.saturation = o,
        this._extension.setDirty())
    }
    get contrast() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.contrast) !== null && c !== void 0 ? c : 1
    }
    set contrast(o) {
        this._extension && (this._extension.contrast = o,
        this._extension.setDirty())
    }
    get toneMapping() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.toneMapping) !== null && c !== void 0 ? c : three_module.kyO
    }
    set toneMapping(o) {
        this._extension && (this._extension.toneMapping = o,
        this._extension.setDirty())
    }
    updateGBuffer(o, c) {
        var h, _;
        if (o instanceof three_module.eaF && (!((h = o.material) === null || h === void 0) && h.userData)) {
            const b = ((_ = o.material) === null || _ === void 0 ? void 0 : _.userData.postTonemap) === !1 ? 0 : 1;
            c.w = updateBit(c.w, 1, b)
        }
    }
}
TonemapPlugin.PluginType = "Tonemap",
three_module.vxI.tonemapping_pars_fragment = three_module.vxI.tonemapping_pars_fragment.replace("vec3 CustomToneMapping( vec3 color ) { return color; }", `

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )
vec3 Uncharted2ToneMapping( vec3 color ) {

	// John Hable's filmic operator from Uncharted 2 video game
	color *= toneMappingExposure;
	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( 1.0 ) ) );

}

vec3 CustomToneMapping( vec3 color ) { return Uncharted2ToneMapping( color ); }

`);
var chromaticAberration = "vec4 chromaticAberration(){vec2 distFromCenter=vUv-0.5;vec2 aberrated=aberrationIntensity*pow(abs(distFromCenter),vec2(2.));vec4 color=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 outColor=vec4(tDiffuseTexelToLinear(texture2D(tDiffuse,vUv+aberrated)).r,color.g,tDiffuseTexelToLinear(texture2D(tDiffuse,vUv-aberrated)).b,color.a);return outColor;}"
  , ChromaticAberrationPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ChromaticAberrationExtension = class {
    constructor(d) {
        this.enabled = !1,
        this.aberrationIntensity = .01,
        this.extraUniforms = {
            aberrationIntensity: {
                value: 1
            }
        },
        this.parsFragmentSnippet = (o, c) => this.enabled ? fe$1`
            uniform float aberrationIntensity;
            ${chromaticAberration}
        ` : "",
        this._combinedPostPlugin = d.getPlugin(CombinedPostPlugin),
        this._setDirty = this._setDirty.bind(this)
    }
    shaderExtender(d, o, c) {
        this.enabled && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker", ` 
            gl_FragColor = chromaticAberration();
            #glMarker
        `))
    }
    onObjectRender(d, o, c) {
        this.enabled && (this.extraUniforms.aberrationIntensity.value = this.aberrationIntensity)
    }
    getUiConfig() {
        return this.uiConfig
    }
    computeCacheKey(d) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(d) {
        return !0
    }
    _setDirty() {
        this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0)
    }
    setDirty() {
        var d;
        (d = this.__setDirty) === null || d === void 0 || d.call(this),
        this._setDirty()
    }
}
;
ChromaticAberrationExtension.PluginType = "ChromaticAberration",
ChromaticAberrationPlugin_decorate([x$1(ChromaticAberrationExtension.prototype._setDirty), uiToggle("Enable"), serialize()], ChromaticAberrationExtension.prototype, "enabled", void 0),
ChromaticAberrationPlugin_decorate([x$1(ChromaticAberrationExtension.prototype._setDirty), uiSlider("Intensity", [0, .1], .001, {
    limitedUi: !0
}), serialize()], ChromaticAberrationExtension.prototype, "aberrationIntensity", void 0),
ChromaticAberrationExtension = ChromaticAberrationPlugin_decorate([uiFolder("ChromaticAberration")], ChromaticAberrationExtension);
class ChromaticAberrationPlugin extends GenericExtensionPlugin {
    constructor() {
        super()
    }
    generateExtension(o) {
        return new ChromaticAberrationExtension(o)
    }
    get intensity() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.aberrationIntensity) !== null && c !== void 0 ? c : 1
    }
    set intensity(o) {
        this._extension && (this._extension.aberrationIntensity = o,
        this._extension.setDirty())
    }
}
ChromaticAberrationPlugin.PluginType = "ChromaticAberration";
class MultiFilterPlugin extends AViewerPlugin {
    get passes() {
        if (!this._passes)
            throw "Plugin not yet added to the viewer";
        return this._passes
    }
    get pipeline() {
        return this._pipeline
    }
    set pipeline(o) {
        this._pipeline = o
    }
    constructor() {
        super(),
        this._pipeline = []
    }
    async onAdded(o) {
        await super.onAdded(o);
        const c = this.createPasses(o);
        this._passes = Object.fromEntries(c.map(h => (h.passId || (console.warn("no id found for pass", h),
        h.passId = esm_browser_v4()),
        o.renderer.registerPass(h, !0),
        [h.passId, h])))
    }
    async onRemove(o) {
        var c;
        if (this._passes) {
            for (const h of [...Object.values(this._passes)]) {
                const _ = h;
                o.renderer.unregisterPass(_),
                (c = _ == null ? void 0 : _.dispose) === null || c === void 0 || c.call(_)
            }
            this._passes = void 0
        }
        await super.onRemove(o)
    }
    toJSON(o) {
        var c;
        const h = super.toJSON(o);
        if (!h.type)
            return h;
        const _ = Object.entries(this.passes);
        h.passes = {};
        for (const [b,_e] of _)
            h.passes[b] = serializeObject((c = _e == null ? void 0 : _e.passObject) !== null && c !== void 0 ? c : _e, !1, o);
        return h
    }
    fromJSON(o, c) {
        var h;
        if (!super.fromJSON(o, c))
            return null;
        if (o.passes) {
            const _ = Object.entries(this.passes);
            for (const [b,_e] of _)
                deserializeObject(o.passes[b], (h = _e == null ? void 0 : _e.passObject) !== null && h !== void 0 ? h : _e, !1, c)
        }
        return this
    }
}
var ssaoBilateral = `uniform vec2 tDiffuseSize;uniform vec2 bilDirection;varying vec2 vUv;uniform bool smoothEnabled;uniform float edgeSharpness;vec4 bilaterialAO(){vec4 color=clamp((texture2D(tDiffuse,vUv.xy)).B_SRC_ACCESSOR,0.,5.);if(!smoothEnabled)return color;float depth;vec3 normal;getDepthNormal(vUv.xy,depth,normal);float gaussianWeights[4];gaussianWeights[0]=0.153170;gaussianWeights[1]=0.144893;gaussianWeights[2]=0.122649;gaussianWeights[3]=0.092902;float Z=gaussianWeights[0]+0.03;vec4 final_colour=Z*color;vec2 nuv;vec4 cc;float dp;vec3 nor;vec2 direction=bilDirection/tDiffuseSize.xy;
#pragma unroll_loop_start
for(int i=0;i<6;i++){direction*=-1.;nuv=vUv+2.*direction*float(UNROLLED_LOOP_INDEX/2+1);getDepthNormal(nuv,dp,nor);if(dp<0.999){float normalCloseness=dot(normal,nor);normalCloseness*=normalCloseness;float normalError=(1.-normalCloseness)*8.;float normalWeight=max((1.-normalError*edgeSharpness),0.00);float depthWeight=max(0.,1.-edgeSharpness*4000.*abs(depth-dp));float kernelWeight=gaussianWeights[UNROLLED_LOOP_INDEX/2]+0.03;float bilateralWeight=kernelWeight*depthWeight*normalWeight;Z+=bilateralWeight;cc=clamp((texture2D(tDiffuse,nuv)).B_SRC_ACCESSOR,0.,5.);final_colour+=bilateralWeight*cc;}}
#pragma unroll_loop_end
final_colour/=Z;return final_colour;}void main(){vec4 ao=clamp(bilaterialAO(),vec4(0.),vec4(1.));gl_FragColor=ao;}`
  , BilateralFilterPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class BilateralFilterPass extends ShaderPass2 {
    constructor(o, c, h="rgba") {
        super({
            vertexShader: CopyShader.vertexShader,
            fragmentShader: c + ssaoBilateral,
            uniforms: {
                bilDirection: {
                    value: new three_module.I9Y(1,0)
                },
                tNormalDepth: {
                    value: null
                },
                tDiffuse: {
                    value: o.texture
                },
                tDiffuseSize: {
                    value: new three_module.I9Y
                }
            },
            defines: {
                B_SRC_ACCESSOR: h
            }
        }, "tDiffuse"),
        this.smoothEnabled = !0,
        this.edgeSharpness = .1,
        this._target = o,
        this.clear = !1,
        this.needsSwap = !1
    }
    render(o, c, h, _, b) {
        var _e, nt, it, at;
        this.enabled && (this.uniforms.bilDirection.value.set(1, 0),
        this.uniforms.tDiffuse.value = this._target.texture,
        this.uniforms.tDiffuseSize.value.set(((_e = this.uniforms.tDiffuse.value) === null || _e === void 0 ? void 0 : _e.image.width) || 0, ((nt = this.uniforms.tDiffuse.value) === null || nt === void 0 ? void 0 : nt.image.height) || 0),
        super.render(o, c, this._target, _, b),
        this.uniforms.bilDirection.value.set(0, 1),
        this.uniforms.tDiffuse.value = c.texture,
        this.uniforms.tDiffuseSize.value.set(((it = this.uniforms.tDiffuse.value) === null || it === void 0 ? void 0 : it.image.width) || 0, ((at = this.uniforms.tDiffuse.value) === null || at === void 0 ? void 0 : at.image.height) || 0),
        super.render(o, this._target, c, _, b))
    }
}
BilateralFilterPass_decorate([serialize(), uniform()], BilateralFilterPass.prototype, "smoothEnabled", void 0),
BilateralFilterPass_decorate([serialize(), uniform()], BilateralFilterPass.prototype, "edgeSharpness", void 0);
var defaultVertex = "varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}"
  , randomHelpers = `#ifndef BASIC_RANDOM_HELPERS
#define BASIC_RANDOM_HELPERS 
uniform float frameCount;float random(float n){return fract(sin(n)*43758.5453123);}float random2(vec2 n,float x){n+=x;return fract(sin(dot(n.xy,vec2(12.9898,78.233)))*43758.5453);}float random3(vec3 v){v=fract(v*443.8975);v+=dot(v,v.yzx+19.19);return fract((v.x+v.y)*v.z);}float interleavedGradientNoise(const in vec2 fragCoord,const in float seed){vec3 magic=vec3(0.06711056,0.00583715,52.9829189);return fract(magic.z*fract(dot(fragCoord.xy+seed*vec2(2.083,4.867),magic.xy)));}vec3 hash3(vec2 p){vec3 q=vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9)));return fract(sin(q)*43758.5453);}
#endif
`
  , ssao = `#include <common>
#include <packing>
varying vec2 vUv;uniform vec2 cameraNearFar;uniform mat4 projection;uniform sampler2D tLastThis;uniform vec4 saoData;uniform vec4 saoBiasEpsilon;uniform vec2 screenSize;const float INV_NUM_SAMPLES=1./float(NUM_SAMPLES);int getSelectionBit(in int number){
#ifdef WebGL2Context
return(number/8)%2;
#else
return int(mod(floor(float(number)/4.),2.));
#endif
}float getViewZFromNDCZ(const in float depth){
#if PERSPECTIVE_CAMERA == 1
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}vec3 packFloatToRGB(const in float x){const vec3 code=vec3(1.,255.,65025.);vec3 pack=vec3(code*x);pack.gb=fract(pack.gb);pack.rg-=pack.gb*(1./256.);return pack;}vec3 getViewPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return vec3(xe,ye,viewDepth);}float decodeDepth(const in vec2 uv){vec4 uncodedDepth;
#if DEPTH_PACKING_MODE == 2
uncodedDepth=texture2D(tNormalDepth,uv);
#else
uncodedDepth=texture2D(tDepth,uv);
#endif
#if DEPTH_PACKING_MODE == 0
return uncodedDepth.x;
#elif DEPTH_PACKING_MODE == 1
#if LINEAR_DEPTH == 1
return pow2(unpackRGBAToDepth(uncodedDepth));
#else
return unpackRGBAToDepth(uncodedDepth);
#endif
#else
return pow2(unpack16(uncodedDepth.xy));
#endif
}vec3 getPositionFromOffset(const in vec2 uvOffset){float d=decodeDepth(uvOffset);
#if LINEAR_DEPTH == 0
float centerViewZ=getViewZFromNDCZ(d);return getViewPositionFromViewZ(uvOffset,centerViewZ);
#else
d=mix(-cameraNearFar.x,-cameraNearFar.y,d);return getViewPositionFromViewZ(uvOffset,d);
#endif
}float getCavityAO(){float cutoff=-0.65;float curvature=float(getGBufferFlags(vUv).r)/255.;curvature=2.*curvature-1.;curvature=curvature*4.;float smoothCurvature=smoothstep(0.,1.,curvature-cutoff);smoothCurvature+=saoData.x;smoothCurvature=clamp(smoothCurvature,0.,1.);return 1.-smoothCurvature;}float getOcclusion(const in vec2 uv,const in int id,const in float randomAngle,const in float occlusionSphereRadius,const in vec3 centerPosition,const in vec3 centerNormal){float screenSpaceRadius=(float(id)+mod(randomAngle,1.)+0.5)*INV_NUM_SAMPLES;float angle=screenSpaceRadius*(float(NUM_SPIRAL_TURNS)*6.28318)+randomAngle;screenSpaceRadius=(screenSpaceRadius*occlusionSphereRadius);vec2 uvOffset=uv+floor(screenSpaceRadius*vec2(cos(angle),sin(angle)))/screenSize;
#if CHECK_GBUFFER_FLAG == 1
if(getSelectionBit(getGBufferFlags(uvOffset.xy).a)<1)return 0.;
#endif
vec3 samplePosition=getPositionFromOffset(uvOffset);vec3 direction=samplePosition-centerPosition;float d2=dot(direction,direction)/(saoBiasEpsilon.w*saoBiasEpsilon.w);float ao=max((dot(centerNormal,direction)/saoBiasEpsilon.w-saoBiasEpsilon.x)/(saoBiasEpsilon.z*d2+saoBiasEpsilon.y),0.);return ao;}void main(){float centerDepth;vec3 centerNormal;getDepthNormal(vUv,centerDepth,centerNormal);
#if LINEAR_DEPTH == 0
float centerViewZ=getViewZFromNDCZ(centerDepth);
#else
float centerViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,centerDepth);
#endif
vec3 centerPosition=getViewPositionFromViewZ(vUv,centerViewZ);float occlusionSphereScreenRadius=0.09*saoData.z*saoBiasEpsilon.w/(-centerPosition.z);float randomAngle=6.2*random3(vec3(vUv,frameCount*0.1));float sum=0.;sum+=getOcclusion(vUv,0,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#if NUM_SAMPLES > 1
sum+=getOcclusion(vUv,1,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 2
sum+=getOcclusion(vUv,2,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 3
sum+=getOcclusion(vUv,3,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 4
sum+=getOcclusion(vUv,4,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 5
sum+=getOcclusion(vUv,5,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 6
sum+=getOcclusion(vUv,6,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 7
sum+=getOcclusion(vUv,7,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 8
sum+=getOcclusion(vUv,8,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 9
sum+=getOcclusion(vUv,9,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
#if NUM_SAMPLES > 10
sum+=getOcclusion(vUv,10,randomAngle,occlusionSphereScreenRadius,centerPosition,centerNormal);
#endif
float aoValue=sum*saoData.y*INV_NUM_SAMPLES;float cavityAO=getCavityAO();aoValue=saoData.w>0.?max(aoValue,cavityAO):aoValue;aoValue=clamp(1.-max(aoValue,0.),0.,1.);gl_FragColor.gba=packFloatToRGB(centerDepth);gl_FragColor.r=(vec4(aoValue)).r;}`
  , ssaoPatch = `#ifndef USE_TRANSMISSION
#if defined(SSAO_ENABLED) && SSAO_ENABLED > 0
float ambientOcclusion=tSSAOMapTexelToLinear(texture2D(tSSAOMap,viewToScreen(vViewPosition.xyz).xy)).r;reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined( USE_ENVMAP )
float dotNV=saturate(dot(geometryNormal,geometryViewDir));reflectedLight.indirectSpecular*=computeSpecularOcclusion(dotNV,ambientOcclusion,material.roughness);
#endif
#else
#include <aomap_fragment>
#endif
#endif
`
  , simpleCameraHelpers = `#ifndef SIMPLE_CAMERA_HELPERS
#define SIMPLE_CAMERA_HELPERS 
#ifndef USE_TRANSMISSION
uniform mat4 projectionMatrix;
#endif
vec3 viewToScreen(const in vec3 pos){vec4 projected=projectionMatrix*vec4(pos,1.);return vec3(0.5+0.5*projected.xy/projected.w,projected.w);}
#endif
`
  , SSAOPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class SSAOPass extends ShaderPass2 {
    constructor(o, c, h) {
        super({
            defines: {
                LINEAR_DEPTH: 1,
                NUM_SAMPLES: 11,
                NUM_SPIRAL_TURNS: 3,
                DEPTH_NORMAL_TEXTURE: 1,
                DEPTH_PACKING_MODE: 2,
                PERSPECTIVE_CAMERA: 1,
                CHECK_GBUFFER_FLAG: 0
            },
            uniforms: {
                tLastThis: {
                    value: null
                },
                tNormalDepth: {
                    value: null
                },
                tGBufferFlags: {
                    value: null
                },
                screenSize: {
                    value: new three_module.I9Y(512,512)
                },
                saoData: {
                    value: new three_module.IUQ
                },
                frameCount: {
                    value: 0
                },
                cameraNearFar: {
                    value: new three_module.I9Y(.1,1e3)
                },
                projection: {
                    value: new three_module.kn4
                },
                saoBiasEpsilon: {
                    value: new three_module.IUQ(1,1,1,1)
                },
                sceneBoundingRadius: {
                    value: 0
                }
            },
            vertexShader: defaultVertex,
            fragmentShader: `

${randomHelpers}

${h}

${ssao}

            `
        }, "tDiffuse"),
        this.parameters = {
            intensity: .25,
            occlusionWorldRadius: 1,
            bias: .001,
            falloff: 1.3,
            useSmallScaleAO: !1,
            intensitySmallAO: .2,
            autoRadius: !1,
            projScale: 1
        },
        this._smoothEnabled = !0,
        this.materialExtension = {
            shaderExtender: (_, b, _e) => {
                _.defines.SSAO_ENABLED && (_.fragmentShader = shaderReplaceString(_.fragmentShader, "#include <aomap_fragment>", ssaoPatch))
            }
            ,
            onObjectRender: (_, b, _e) => {
                var nt, it;
                this.materialExtension.extraUniforms.tSSAOMap.value = (nt = this._target) === null || nt === void 0 ? void 0 : nt.texture;
                const at = b.materialObject;
                let ut = this.enabled && _e.userData.screenSpaceRendering !== !1 && !(!((it = b.userData) === null || it === void 0) && it.ssaoDisabled) ? 1 : 0;
                at.defines.SSAO_ENABLED !== ut && (at.defines.SSAO_ENABLED = ut,
                at.needsUpdate = !0),
                ut = this._target.texture,
                this.materialExtension.extraUniforms.tSSAOMap.value !== ut && (this.materialExtension.extraUniforms.tSSAOMap.value = ut,
                at.needsUpdate = !0)
            }
            ,
            parsFragmentSnippet: _ => {
                var b, _e;
                return fe$1`
             uniform sampler2D tSSAOMap;
             ${getTexelDecoding("tSSAOMap", (_e = (b = this._target) === null || b === void 0 ? void 0 : b.texture) === null || _e === void 0 ? void 0 : _e.colorSpace)}
            ${simpleCameraHelpers}
        `
            }
            ,
            extraUniforms: {
                tSSAOMap: {
                    value: null
                }
            },
            computeCacheKey: _ => {
                var b, _e;
                return this.enabled ? "1" : "0" + ((_e = (b = this._target) === null || b === void 0 ? void 0 : b.texture) === null || _e === void 0 ? void 0 : _e.colorSpace)
            }
            ,
            isCompatible: _ => {
                var b;
                return !(!((b = _.materialObject.userData) === null || b === void 0) && b.ssaoDisabled) && _.isMeshStandardMaterial2
            }
        },
        this._renderer = o,
        this._target = c,
        this.needsSwap = !1,
        this.clear = !0,
        this.bilateralPass = new BilateralFilterPass(this._target,h,"rrrr")
    }
    get smoothEnabled() {
        return this._smoothEnabled
    }
    set smoothEnabled(o) {
        this._smoothEnabled = o,
        this.bilateralPass.enabled = o,
        this.bilateralPass.uniforms.smoothEnabled.value = o
    }
    render(o, c, h, _, b) {
        this.enabled && (this._updateParameters(),
        this._renderer.blit(this._target.texture, c, {}),
        this.uniforms.tLastThis.value = c.texture,
        super.render(o, this._target, h, _, b),
        this._smoothEnabled && this.bilateralPass.render(o, c, h, _, b))
    }
    _updateParameters() {
        const o = this.material.uniforms.saoData.value;
        o.x = this.parameters.intensitySmallAO,
        o.y = this.parameters.intensity,
        o.z = this.parameters.occlusionWorldRadius,
        o.w = this.parameters.useSmallScaleAO,
        o.z *= this.parameters.projScale;
        const c = this.material.uniforms.saoBiasEpsilon.value;
        if (c.x = this.parameters.bias,
        c.y = .001,
        c.z = this.parameters.falloff,
        this.parameters.autoRadius) {
            const h = this.material.uniforms.sceneBoundingRadius.value;
            c.w = h
        } else
            c.w = 1
    }
}
SSAOPass_decorate([serialize()], SSAOPass.prototype, "bilateralPass", void 0),
SSAOPass_decorate([serialize()], SSAOPass.prototype, "parameters", void 0);
class SSAOPlugin extends MultiFilterPlugin {
    get aoTarget() {
        return this._aoTarget
    }
    constructor() {
        super(),
        this.dependencies = [AssetManagerPlugin, GBufferPlugin],
        this.setDirty = this.setDirty.bind(this),
        this.updateGBuffer = this.updateGBuffer.bind(this)
    }
    async onAdded(o) {
        var c;
        return o.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSAOPlugin"),
        (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 || c.registerGBufferUpdater(this.updateGBuffer),
        super.onAdded(o)
    }
    updateGBuffer(o, c) {
        var h;
        if (o instanceof three_module.eaF && (!((h = o.material) === null || h === void 0) && h.userData)) {
            const _ = o.material.userData.ssaoCastDisabled || o.material.userData.pluginsDisabled
              , b = _ ? 0 : 1;
            c.w = updateBit(c.w, 3, b),
            _ && this.passes.ssao.passObject && this.passes.ssao.passObject.material.defines.CHECK_GBUFFER_FLAG !== 1 && (this.passes.ssao.passObject.material.defines.CHECK_GBUFFER_FLAG = 1,
            this.passes.ssao.passObject.material.needsUpdate = !0)
        }
    }
    createPasses(o) {
        var c, h;
        return this._aoTarget = o.renderer.createTarget({
            sizeMultiplier: 1
        }),
        [makeFilter(o, {
            passId: "ssao",
            after: ["gbuffer"],
            before: ["render"],
            required: ["render", "gbuffer"],
            passObject: new SSAOPass(o.renderer,this._aoTarget,(h = (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 ? void 0 : c.getUnpackSnippet()) !== null && h !== void 0 ? h : ""),
            update() {
                var _;
                const b = Math.max(1, (_ = (o == null ? void 0 : o.scene.activeCamera.modelObject).fov) !== null && _ !== void 0 ? _ : 1)
                  , _e = ((o == null ? void 0 : o.canvas.height) || 1) / (2 * Math.tan(.5 * b * three_module.cj9.DEG2RAD));
                this.passObject.parameters.projScale = _e,
                this.passObject.bilateralPass.updateShaderProperties([o.getPlugin(GBufferPlugin)])
            }
        }, () => [o.getPlugin(GBufferPlugin), o.scene.activeCamera, o.renderer, o.scene])]
    }
    async onRemove(o) {
        return o.renderer.disposeTarget(this._aoTarget),
        super.onRemove(o)
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    get enabled() {
        var o, c;
        return ((c = (o = this.passes.ssao) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.enabled) || !1
    }
    set enabled(o) {
        var c;
        !((c = this.passes.ssao) === null || c === void 0) && c.passObject && (this.passes.ssao.passObject.enabled = o)
    }
    get uiConfig() {
        var o;
        if (this._uiConfig)
            return this._uiConfig;
        const c = this
          , h = c.passes.ssao.passObject;
        return this._uiConfig = {
            type: "folder",
            label: "SS Ambient Occlusion",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [h, "enabled"],
                onChange: c.setDirty
            }, {
                type: "checkbox",
                label: "Enable Cavity",
                property: [h.parameters, "useSmallScaleAO"],
                onChange: c.setDirty
            }, {
                type: "slider",
                label: "Cavity Brightness",
                bounds: [0, .5],
                stepSize: .01,
                property: [h.parameters, "intensitySmallAO"],
                onChange: c.setDirty
            }, {
                type: "slider",
                label: "Intensity",
                bounds: [0, 5],
                property: [h.parameters, "intensity"],
                onChange: c.setDirty
            }, {
                type: "slider",
                label: "Radius",
                bounds: [.1, 20],
                property: [h.parameters, "occlusionWorldRadius"],
                onChange: c.setDirty
            }, {
                type: "slider",
                label: "Bias",
                bounds: [1e-5, .01],
                property: [h.parameters, "bias"],
                onChange: c.setDirty
            }, {
                type: "slider",
                label: "Falloff",
                bounds: [.01, 3],
                property: [h.parameters, "falloff"],
                onChange: c.setDirty
            }, {
                type: "slider",
                label: "Num samples",
                stepSize: 1,
                bounds: [1, 11],
                property: [(o = h.material) === null || o === void 0 ? void 0 : o.defines, "NUM_SAMPLES"],
                onChange: [ () => h.material.needsUpdate = !0, c.setDirty]
            }, {
                type: "checkbox",
                property: [h.bilateralPass, "smoothEnabled"],
                onChange: c.setDirty
            }, {
                type: "checkbox",
                property: [h.parameters, "autoRadius"],
                onChange: c.setDirty
            }, {
                type: "vec4",
                property: [h.bilateralPass, "edgeSharpness"],
                onChange: c.setDirty
            }]
        }
    }
}
SSAOPlugin.PluginType = "SSAO";
var hdrBloom = `uniform float intensity;uniform float opacity;uniform vec2 tDiffuseSize;varying vec2 vUv;uniform float weight;
#if PASS_STEP == 0
uniform vec4 prefilter;vec4 Prefilter(vec4 c){if(getDepth(vUv)>0.999){return vec4(0.);}float brightness=max(c.r,max(c.g,c.b));float soft=brightness+prefilter.x*(prefilter.y-1.);soft=clamp(soft,0.,prefilter.z);soft=soft*soft*prefilter.w;float contribution=max(soft,brightness-prefilter.x);contribution/=max(brightness,0.001);return vec4(c.rgb*contribution,c.a);}
#endif
vec4 Sample(vec2 uv){return min(vec4(MAX_INTENSITY,MAX_INTENSITY,MAX_INTENSITY,1.),tDiffuseTexelToLinear(texture2D(tDiffuse,uv)));}vec4 SampleBox(vec2 uv,float delta){vec4 o=vec2(-delta,delta).xxyy/tDiffuseSize.xyxy;vec4 s=Sample(uv+o.xy)+Sample(uv+o.zy)+Sample(uv+o.xw)+Sample(uv+o.zw);return s*0.25;}int getBloomBit(in int number){
#ifdef WebGL2Context
return(number/4)%2;
#else
return int(mod(floor(float(number)/4.),2.));
#endif
}void main(){
#if PASS_STEP == 0 
int doBloom=getBloomBit(getGBufferFlags(vUv).a);gl_FragColor=float(doBloom)*weight*Prefilter(SampleBox(vUv,1.));gl_FragColor.a=1.;
#elif PASS_STEP == 1 
gl_FragColor=weight*(SampleBox(vUv,1.));gl_FragColor.a=1.;
#elif PASS_STEP == 2 
gl_FragColor=(SampleBox(vUv,0.5));gl_FragColor.a=1.;
#elif PASS_STEP == 3 
vec4 texel=tSourceTexelToLinear(texture2D(tSource,vUv));vec4 bloom=intensity*SampleBox(vUv,0.5).rgba;float brightness=max(bloom.r,max(bloom.g,bloom.b));texel.rgb+=bloom.rgb;texel.a=min(1.,texel.a+brightness);gl_FragColor=texel;
#elif PASS_STEP == 4 
vec4 texel=vec4(0.);texel.rgb+=intensity*SampleBox(vUv,0.5).rgb;texel.a=1.;gl_FragColor=texel;
#endif
#include <colorspace_fragment>
}`
  , BloomPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let BloomPass = class extends ShaderPass2 {
    constructor(d=16) {
        super({
            vertexShader: CopyShader.vertexShader,
            defines: {
                PASS_STEP: 1,
                MAX_INTENSITY: Math.min(d, 16)
            },
            uniforms: {
                tSource: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                },
                tDiffuseSize: {
                    value: new three_module.I9Y
                },
                weight: {
                    value: 1
                },
                tNormalDepth: {
                    value: null
                },
                tGBufferFlags: {
                    value: null
                }
            },
            fragmentShader: unpackGbuffer + `
` + hdrBloom
        }, "tDiffuse", "tSource"),
        this.uiConfig = void 0,
        this.prefilter = new three_module.IUQ(2,.5,0,0),
        this.threshold = 2,
        this.softThreshold = .5,
        this.intensity = .2,
        this.bloomIterations = 4,
        this.radius = .6,
        this.power = 1,
        this.bloomDebug = !1,
        this._weights = [],
        this._updateWeights = this._updateWeights.bind(this),
        this._thresholdsUpdated = this._thresholdsUpdated.bind(this),
        this._updateWeights(),
        this._thresholdsUpdated(),
        this.clear = !0,
        this.userData = {
            setDirty: () => {
                this.setDirty()
            }
        }
    }
    _thresholdsUpdated() {
        this.prefilter.x = this.threshold,
        this.prefilter.y = this.softThreshold,
        this.prefilter.z = 2 * this.prefilter.x * this.prefilter.y,
        this.prefilter.w = .125 / (this.uniforms.prefilter.value.z + 1e-5)
    }
    render(d, o, c, h, _) {
        const b = d.baseRenderer;
        this.material.defines.PASS_STEP = 0,
        this.clear = !0;
        const _e = c;
        let nt = .5
          , it = _e.width * nt
          , at = _e.height * nt;
        const ut = [];
        let pt = b.getTempTarget({
            sizeMultiplier: 1,
            type: three_module.ix0
        });
        ut.push(pt);
        let ht = _e;
        this.material.needsUpdate = !0,
        this.material.uniforms.weight.value = this._weights[0],
        super.render(d, pt, ht, h, _),
        ht = pt;
        let _t = 1;
        for (; _t < this.bloomIterations && (it /= 2,
        at /= 2,
        nt /= 2,
        !(at < 2 || it < 2)); _t++) {
            pt = b.getTempTarget({
                sizeMultiplier: nt,
                type: three_module.ix0
            }),
            ut.push(pt),
            this.material.defines.PASS_STEP = 1;
            let bt = this._weights[_t];
            bt = this._weights[_t - 1] !== 0 ? this._weights[_t] / this._weights[_t - 1] : this._weights[_t],
            this.material.uniforms.weight.value = bt,
            this.material.needsUpdate = !0,
            super.render(d, pt, ht, h, _),
            ht = pt
        }
        this.clear = !1;
        const vt = d.autoClear;
        for (d.autoClear = !1,
        _t -= 2; _t >= 0; _t--)
            pt = ut[_t],
            ut[_t] = void 0,
            this.material.defines.PASS_STEP = 2,
            this.material.transparent = !0,
            this.material.blending = three_module.EZo,
            this.material.needsUpdate = !0,
            d.autoClear = !1,
            super.render(d, pt, ht, h, _),
            this.material.blending = three_module.XIg,
            b.releaseTempTarget(ht),
            ht = pt;
        this.clear = !0,
        d.autoClear = vt,
        d.autoClear = !0,
        this.bloomDebug ? (this.material.defines.PASS_STEP = 4,
        this.material.needsUpdate = !0,
        super.render(d, o, ht, h, _)) : (this.uniforms.tSource.value = _e.texture,
        this.material.defines.PASS_STEP = 3,
        this.material.needsUpdate = !0,
        super.render(d, o, ht, h, _),
        this.uniforms.tSource.value = null),
        b.releaseTempTarget(ht)
    }
    _updateWeights() {
        if (!this._weights)
            return;
        const d = Math.max(Math.min(this.radius, 1), 0)
          , o = 1 / (this.bloomIterations - 1);
        for (let c = 0; c < this.bloomIterations; c++) {
            let h = c * o + .1
              , _ = 1.2 - h;
            h = Math.pow(h, this.power),
            _ = Math.pow(_, this.power),
            this._weights[c] = _ * (1 - d) + h * d
        }
        this.setDirty()
    }
}
;
function addBloomData(d) {
    const o = d == null ? void 0 : d.userData;
    return !!o && (o[BloomPlugin.PluginType] || (o[BloomPlugin.PluginType] = {}),
    o[BloomPlugin.PluginType].enable = !0,
    d.isMaterial && (d.needsUpdate = !0),
    !0)
}
BloomPass_decorate([uniform()], BloomPass.prototype, "prefilter", void 0),
BloomPass_decorate([uiSlider("Threshold", [0, 2]), x$1(BloomPass.prototype._thresholdsUpdated), serialize()], BloomPass.prototype, "threshold", void 0),
BloomPass_decorate([uiSlider("Soft Threshold", [0, 1]), x$1(BloomPass.prototype._thresholdsUpdated), serialize()], BloomPass.prototype, "softThreshold", void 0),
BloomPass_decorate([uiSlider("Intensity", [0, 3]), serialize(), uniform()], BloomPass.prototype, "intensity", void 0),
BloomPass_decorate([uiSlider("Iterations", [0, 7], 1), x$1(BloomPass.prototype._updateWeights), serialize()], BloomPass.prototype, "bloomIterations", void 0),
BloomPass_decorate([uiSlider("Radius", [0, 1], .01), x$1(BloomPass.prototype._updateWeights), serialize()], BloomPass.prototype, "radius", void 0),
BloomPass_decorate([uiSlider("Power", [.2, 10], .01), x$1(BloomPass.prototype._updateWeights), serialize()], BloomPass.prototype, "power", void 0),
BloomPass_decorate([uiToggle("Debug")], BloomPass.prototype, "bloomDebug", void 0),
BloomPass = BloomPass_decorate([uiFolder("Bloom")], BloomPass);
class BloomPlugin extends GenericFilterPlugin {
    constructor() {
        super(...arguments),
        this.passId = "bloom",
        this._beforeFilters = ["combinedPost", "screen"],
        this._afterFilters = ["render", "progressive"],
        this._requiredFilters = ["render"],
        this.materialExtension = {
            uuid: esm_browser_v4(),
            getUiConfig: o => {
                if (o.__uiConfigs || (o.__uiConfigs = {}),
                o.__uiConfigs[this.materialExtension.uuid])
                    return o.__uiConfigs[this.materialExtension.uuid];
                const c = this._getUiConfig(o);
                return o.__uiConfigs[this.materialExtension.uuid] = c,
                c
            }
            ,
            isCompatible: o => !0
        }
    }
    setDirty() {
        this.pass.dirty = !0
    }
    _getUiConfig(o) {
        const c = {
            type: "folder",
            label: "Bloom",
            children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                    var h, _;
                    return (_ = (h = o.materialObject.userData[BloomPlugin.PluginType]) === null || h === void 0 ? void 0 : h.enable) === null || _ === void 0 || _
                },
                set value(h) {
                    var _;
                    const b = o.materialObject.userData[BloomPlugin.PluginType];
                    h !== (b == null ? void 0 : b.enable) && (b || addBloomData(o.materialObject),
                    o.materialObject.userData[BloomPlugin.PluginType].enable = h,
                    (_ = c.uiRefresh) === null || _ === void 0 || _.call(c, "postFrame", !0))
                },
                onChange: this.setDirty
            }]
        };
        return c
    }
    passCtor(o) {
        const c = new BloomPass(o.renderer.maxHDRIntensity);
        return this.updateGBuffer = this.updateGBuffer.bind(this),
        this.setDirty = this.setDirty.bind(this),
        c
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 || c.registerGBufferUpdater(this.updateGBuffer);
        const _ = o.getPlugin(AssetManagerPlugin);
        (h = _ == null ? void 0 : _.materials) === null || h === void 0 || h.registerMaterialExtension(this.materialExtension)
    }
    updateGBuffer(o, c) {
        var h, _, b, _e;
        if (o instanceof three_module.eaF && (!((h = o.material) === null || h === void 0) && h.userData)) {
            const nt = ((b = (_ = o.material) === null || _ === void 0 ? void 0 : _.userData[BloomPlugin.PluginType]) === null || b === void 0 ? void 0 : b.enable) === !1 || !((_e = o.material) === null || _e === void 0) && _e.userData.pluginsDisabled ? 0 : 1;
            c.w = updateBit(c.w, 2, nt)
        }
    }
    _update(o) {
        var c, h;
        return (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 || c.updateShaderProperties((h = this.pass) === null || h === void 0 ? void 0 : h.passObject.material),
        super._update(o)
    }
    get uiConfig() {
        var o;
        return (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.uiConfig
    }
}
BloomPlugin.PluginType = "Bloom";
var combineDepthOfField = `#include <common>
#include <packing>
varying vec2 vUv;uniform vec2 cocTextureSize;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;uniform vec2 crossCenter;uniform float crossRadius;uniform float crossAlpha;uniform vec3 crossColor;float smoothBoundary(float d,float smooothFactor){smooothFactor*=0.5;float value=smoothstep(-smooothFactor,smooothFactor,d);return value;}float circle(vec2 p,float r){return min((length(p)-r),-(length(p)-r-0.01));}float computeCoc(){float depth=getDepth(vUv);if(depth>1.-0.01)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){vec4 blur=blurTextureTexelToLinear(texture2D(blurTexture,vUv));float scale=0.5;blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(-1.,-1.)/cocTextureSize));blur+=blurTextureTexelToLinear(texture2D(blurTexture,vUv+scale*vec2(1.,-1.)/cocTextureSize));blur/=5.;vec2 uvNearest=(floor(vUv*cocTextureSize)+0.5)/cocTextureSize;float coc=abs(min(2.*cocTextureTexelToLinear(texture2D(cocTexture,uvNearest)).a-1.,computeCoc()));float cocLower=0.005;float cocHigher=0.3;vec4 outColor=vec4(mix(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,blur.rgb,smoothstep(cocLower,cocHigher,coc)),1.);vec2 d=vUv-crossCenter;if(length(d)>crossRadius+0.05){float dist=circle(d,crossRadius);gl_FragColor=outColor;}else{d.x*=cocTextureSize.x/cocTextureSize.y;float dist=circle(d,crossRadius);dist=smoothBoundary(dist,2.*fwidth(dist));vec4 color=outColor;vec3 dofCircleColor=mix(crossColor,color.rgb,1.-crossAlpha);gl_FragColor=vec4(mix(color.rgb,dofCircleColor,dist),color.a);}
#include <colorspace_fragment>
}`
  , computeCoCDoF = `#include <common>
#include <packing>
varying vec2 vUv;uniform vec2 nearFarBlurScale;uniform vec2 cameraNearFar;uniform vec2 focalDepthRange;float computeCoc(){float depth=getDepth(vUv);if(depth==1.)return max(nearFarBlurScale.x,nearFarBlurScale.y);depth=mix(cameraNearFar.x,cameraNearFar.y,depth);float coc=(depth-focalDepthRange.x)/focalDepthRange.y;coc=clamp(coc,-1.,1.);return(coc>0.?coc*nearFarBlurScale.y:coc*nearFarBlurScale.x);}void main(){gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*computeCoc()+0.5);
#include <colorspace_fragment>
}`
  , expandCoCDoF = `#include <common>
varying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;uniform vec2 nearFarBlurScale;const float MAXIMUM_BLUR_SIZE=4.;float expandNear(const in vec2 offset,const in bool isBackground){float coc=0.;vec2 sampleOffsets=MAXIMUM_BLUR_SIZE*offset/5.;float coc0=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv)).a-1.;float coc1=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-5.*sampleOffsets)).a-1.;float coc2=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-4.*sampleOffsets)).a-1.;float coc3=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-3.*sampleOffsets)).a-1.;float coc4=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-2.*sampleOffsets)).a-1.;float coc5=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv-1.*sampleOffsets)).a-1.;float coc6=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+1.*sampleOffsets)).a-1.;float coc7=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+2.*sampleOffsets)).a-1.;float coc8=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+3.*sampleOffsets)).a-1.;float coc9=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+4.*sampleOffsets)).a-1.;float coc10=2.*colorTextureTexelToLinear(texture2D(colorTexture,vUv+5.*sampleOffsets)).a-1.;if(isBackground){coc=abs(coc0)*0.095474+(abs(coc1)+abs(coc10))*0.084264+(abs(coc2)+abs(coc9))*0.088139+(abs(coc3)+abs(coc8))*0.091276+(abs(coc4)+abs(coc7))*0.093585+(abs(coc5)+abs(coc6))*0.094998;}else{coc=min(coc0,0.);coc=min(coc1*0.3,coc);coc=min(coc2*0.5,coc);coc=min(coc3*0.75,coc);coc=min(coc4*0.8,coc);coc=min(coc5*0.95,coc);coc=min(coc6*0.95,coc);coc=min(coc7*0.8,coc);coc=min(coc8*0.75,coc);coc=min(coc9*0.5,coc);coc=min(coc10*0.3,coc);if(abs(coc0)>abs(coc))coc=coc0;}return coc;}void main(){vec2 offset=2.*direction/colorTextureSize;bool isBackground=getDepth(vUv)>1.-0.001;float coc=expandNear(offset,isBackground);gl_FragColor=vec4(colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb,0.5*coc+0.5);
#include <colorspace_fragment>
}`
  , boxBlurDoF = `#include <common>
varying vec2 vUv;uniform vec2 colorTextureSize;uniform vec2 direction;const float MAXIMUM_BLUR_SIZE=16.;const float SIGMA=5.;const int NUM_SAMPLES=4;float normpdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}vec3 weightedBlur(){float cocIn=2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv)).a-1.;float kernelRadius=MAXIMUM_BLUR_SIZE*cocIn;vec2 invSize=1./colorTextureSize;cocIn*=cocIn*cocIn;float centerSpaceWeight=normpdf(0.,SIGMA)*abs(cocIn);float weightSum=centerSpaceWeight;vec3 centerSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv)).rgb;vec3 diffuseSum=centerSample*weightSum;vec2 delta=invSize*kernelRadius/float(NUM_SAMPLES);for(int i=1;i<=NUM_SAMPLES;i++){float spaceWeight=normpdf(float(i),SIGMA);vec2 texcoord=direction*delta*float(i);vec4 rightSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv+texcoord));vec4 leftSample=colorTextureTexelToLinear(texture2D(colorTexture,vUv-texcoord));float leftCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv-texcoord)).a-1.);float rightCocWeight=abs(2.*cocTextureTexelToLinear(texture2D(cocTexture,vUv+texcoord)).a-1.);leftCocWeight*=leftCocWeight*leftCocWeight;rightCocWeight*=rightCocWeight*rightCocWeight;diffuseSum+=((leftSample.rgb*leftCocWeight)+(rightSample.rgb*rightCocWeight))*spaceWeight;weightSum+=(spaceWeight*(leftCocWeight+rightCocWeight));}return diffuseSum/weightSum;}void main(){gl_FragColor=vec4(weightedBlur(),1.);
#include <colorspace_fragment>
}`
  , poissonBlurDoF = `#include <common>
varying vec2 vUv;uniform vec2 colorTextureSize;uniform float blurRadius;vec4 CircularBlur(){vec4 color=colorTextureTexelToLinear(texture2D(colorTexture,vUv));
#ifdef DOF_MODE
float blurDist=blurRadius*(2.*color.a-1.);
#else
float blurDist=blurRadius*color.a;
#endif
float rnd=PI2*random3(vec3(vUv,frameCount*0.1));float costheta=cos(rnd);float sintheta=sin(rnd);vec4 rotationMatrix=vec4(costheta,-sintheta,sintheta,costheta);vec3 colorSum=vec3(0.);float weightSum=0.001;vec2 ofs;vec4 sampleColor;setPds();
#pragma unroll_loop_start
for(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));sampleColor=colorTextureTexelToLinear(texture2D(colorTexture,vUv+blurDist*ofs/colorTextureSize.xy));
#ifdef DOF_MODE
sampleColor.a=abs(sampleColor.a*2.-1.);sampleColor.a*=sampleColor.a*sampleColor.a;
#endif
colorSum+=sampleColor.rgb*sampleColor.a;weightSum+=sampleColor.a;}
#pragma unroll_loop_end
colorSum/=weightSum;return vec4(min(vec3(72.),max(vec3(0.),colorSum)),1.);}void main(){gl_FragColor=CircularBlur();
#include <colorspace_fragment>
}`
  , poissonDiskSamples = "vec2 poisson_disk_samples[16];void setPds(){poisson_disk_samples[0]=vec2(-0.399691779231,0.728591545584);poisson_disk_samples[1]=vec2(-0.48622557676,-0.84016533712);poisson_disk_samples[2]=vec2(0.770309468987,-0.24906070432);poisson_disk_samples[3]=vec2(0.556596796154,0.820359876432);poisson_disk_samples[4]=vec2(-0.933902004071,0.0600539051593);poisson_disk_samples[5]=vec2(0.330144964342,0.207477293384);poisson_disk_samples[6]=vec2(0.289013230975,-0.686749271417);poisson_disk_samples[7]=vec2(-0.0832470893559,-0.187351643125);poisson_disk_samples[8]=vec2(-0.296314525615,0.254474834305);poisson_disk_samples[9]=vec2(-0.850977666059,0.484642744689);poisson_disk_samples[10]=vec2(0.829287915319,0.2345063545);poisson_disk_samples[11]=vec2(-0.773042143899,-0.543741521254);poisson_disk_samples[12]=vec2(0.0561133030864,0.928419742597);poisson_disk_samples[13]=vec2(-0.205799249508,-0.562072714492);poisson_disk_samples[14]=vec2(-0.526991665882,-0.193690188118);poisson_disk_samples[15]=vec2(-0.051789270667,-0.935374050821);}"
  , DepthOfFieldPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const combineDofShader = {
    uniforms: {
        colorTexture: {
            value: null
        },
        tNormalDepth: {
            value: null
        },
        blurTexture: {
            value: null
        },
        cocTexture: {
            value: null
        },
        cocTextureSize: {
            value: new three_module.I9Y
        },
        cameraNearFar: {
            value: new three_module.I9Y
        }
    },
    vertexShader: defaultVertex,
    fragmentShader: unpackGbuffer + `
` + combineDepthOfField
};
patchShaderEncodingSupport({
    uniforms: {
        cocTexture: {
            value: null
        },
        colorTexture: {
            value: null
        },
        colorTextureSize: {
            value: new three_module.I9Y
        },
        direction: {
            value: new three_module.I9Y
        }
    },
    vertexShader: defaultVertex,
    fragmentShader: boxBlurDoF
}, "colorTexture", "cocTexture");
const dofBlurMaterialPoisson = patchShaderEncodingSupport({
    uniforms: {
        colorTexture: {
            value: null
        },
        colorTextureSize: {
            value: new three_module.I9Y
        },
        direction: {
            value: new three_module.I9Y
        },
        frameCount: {
            value: 0
        },
        blurRadius: {
            value: 16
        }
    },
    vertexShader: defaultVertex,
    fragmentShader: randomHelpers + `
` + poissonDiskSamples + `
` + poissonBlurDoF,
    defines: {
        DOF_MODE: 1
    }
}, "colorTexture");
class DepthOfFieldPass extends ShaderPass2 {
    constructor() {
        super(combineDofShader, "colorTexture", "cocTexture", "blurTexture"),
        this.dofBlurMaterial = dofBlurMaterialPoisson,
        this.nearFarBlurScale = new three_module.I9Y(.25,.25),
        this.focalDepthRange = new three_module.I9Y(.5,1.5),
        this.crossCenter = new three_module.I9Y(.5,.5),
        this.crossRadius = .04,
        this.crossAlpha = 1,
        this.crossColor = new three_module.Q1f(16750848),
        this.uiConfig = {
            type: "folder",
            label: "Depth of Field",
            children: [{
                type: "checkbox",
                label: "Enabled",
                limitedUi: !0,
                property: [this, "enabled"]
            }, {
                type: "slider",
                label: "Depth Range",
                bounds: [.5, 3],
                property: [this.focalDepthRange, "y"]
            }, {
                type: "slider",
                label: "Near Blur scale",
                bounds: [0, 1],
                property: [this.nearFarBlurScale, "x"]
            }, {
                type: "slider",
                label: "Far Blur scale",
                bounds: [0, 1],
                property: [this.nearFarBlurScale, "y"]
            }]
        },
        this.material.extensions.derivatives = !0,
        this.computeCocMaterial = patchShaderEncodingSupport({
            uniforms: {
                colorTexture: {
                    value: null
                },
                tNormalDepth: this.uniforms.tNormalDepth,
                cameraNearFar: this.uniforms.cameraNearFar,
                nearFarBlurScale: this.uniforms.nearFarBlurScale,
                focalDepthRange: this.uniforms.focalDepthRange
            },
            vertexShader: defaultVertex,
            fragmentShader: unpackGbuffer + `
` + computeCoCDoF
        }, "colorTexture"),
        this.expandCocMaterial = patchShaderEncodingSupport({
            uniforms: {
                colorTexture: {
                    value: null
                },
                colorTextureSize: {
                    value: new three_module.I9Y
                },
                direction: {
                    value: new three_module.I9Y
                },
                tNormalDepth: this.uniforms.tNormalDepth,
                nearFarBlurScale: this.uniforms.nearFarBlurScale
            },
            vertexShader: defaultVertex,
            fragmentShader: unpackGbuffer + `
` + expandCoCDoF
        }, "colorTexture")
    }
    render(o, c, h, _, b) {
        if (!this.enabled)
            return;
        const _e = o.baseRenderer
          , nt = {
            minFilter: three_module.hxR,
            magFilter: three_module.hxR,
            type: three_module.ix0,
            colorSpace: three_module.Zr2,
            sizeMultiplier: .5,
            format: three_module.GWd,
            depthBuffer: !1,
            generateMipmaps: !1
        }
          , it = _e.getTempTarget(nt)
          , at = _e.getTempTarget(nt);
        if (this.computeCocMaterial.uniforms.colorTexture.value = h.texture,
        _e.blit(void 0, it, {
            material: this.computeCocMaterial
        }),
        this.expandCocMaterial.uniforms.colorTexture.value = it.texture,
        this.expandCocMaterial.uniforms.direction.value.set(1, 0),
        _e.blit(void 0, at, {
            material: this.expandCocMaterial
        }),
        this.expandCocMaterial.uniforms.colorTexture.value = at.texture,
        this.expandCocMaterial.uniforms.direction.value.set(0, 1),
        _e.blit(void 0, it, {
            material: this.expandCocMaterial
        }),
        this.dofBlurMaterial.uniforms.frameCount)
            this.dofBlurMaterial.uniforms.colorTexture.value = it.texture,
            _e.blit(void 0, at, {
                material: this.dofBlurMaterial
            });
        else {
            const ut = _e.getTempTarget(nt);
            this.dofBlurMaterial.uniforms.cocTexture.value = it.texture,
            this.dofBlurMaterial.uniforms.colorTexture.value = it.texture,
            this.dofBlurMaterial.uniforms.direction.value.set(1, 0),
            _e.blit(void 0, ut, {
                material: this.dofBlurMaterial
            }),
            this.dofBlurMaterial.uniforms.colorTexture.value = ut.texture,
            this.dofBlurMaterial.uniforms.direction.value.set(0, 1),
            _e.blit(void 0, at, {
                material: this.dofBlurMaterial
            }),
            _e.releaseTempTarget(ut)
        }
        this.material.uniforms.blurTexture.value = at.texture,
        this.material.uniforms.cocTexture.value = it.texture,
        super.render(o, c, h, _, b),
        _e.releaseTempTarget(it),
        _e.releaseTempTarget(at)
    }
}
DepthOfFieldPass_decorate([serialize(), uniform()], DepthOfFieldPass.prototype, "nearFarBlurScale", void 0),
DepthOfFieldPass_decorate([serialize(), uniform()], DepthOfFieldPass.prototype, "focalDepthRange", void 0),
DepthOfFieldPass_decorate([uniform()], DepthOfFieldPass.prototype, "crossCenter", void 0),
DepthOfFieldPass_decorate([uniform()], DepthOfFieldPass.prototype, "crossRadius", void 0),
DepthOfFieldPass_decorate([uniform()], DepthOfFieldPass.prototype, "crossAlpha", void 0),
DepthOfFieldPass_decorate([uniform()], DepthOfFieldPass.prototype, "crossColor", void 0);
class AddBlendPass extends ShaderPass2 {
    constructor(o, c=120) {
        super({
            vertexShader: CopyShader.vertexShader,
            fragmentShader: fe$1`
                uniform vec4 weight;
                uniform vec4 weight2;
                varying vec2 vUv;
                void main() {
                    vec4 texel = clamp(weight * tDiffuseTexelToLinear ( texture2D( tDiffuse, vUv ) ) + weight2 * tDiffuse2TexelToLinear ( texture2D( tDiffuse2, vUv ) ), vec4(0), vec4(MAX_INTENSITY));
                    gl_FragColor = texel;
                    #include <colorspace_fragment>
                }
            `,
            uniforms: {
                tDiffuse: {
                    value: null
                },
                tDiffuse2: {
                    value: o
                },
                weight: {
                    value: new three_module.IUQ(1,1,1,1)
                },
                weight2: {
                    value: new three_module.IUQ(1,1,1,1)
                }
            },
            defines: {
                MAX_INTENSITY: c
            }
        }, "tDiffuse", "tDiffuse2"),
        this.clear = !1,
        this.needsSwap = !0
    }
    set weights2(o) {
        this.uniforms.weight2.value.copy(o)
    }
    get weights2() {
        return this.uniforms.weight2.value
    }
    set weights1(o) {
        this.uniforms.weight.value.copy(o)
    }
    get weights1() {
        return this.uniforms.weight.value
    }
    set blendTexture(o) {
        this.uniforms.tDiffuse2.value = o
    }
}
var ProgressivePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const offsets = [{
    x: 0,
    y: 0
}, {
    x: -.5,
    y: 0
}, {
    x: -.375,
    y: -.25
}, {
    x: -.1875,
    y: -.125
}, {
    x: -.125,
    y: -.375
}, {
    x: .0625,
    y: -.0625
}, {
    x: .125,
    y: -.3125
}, {
    x: .375,
    y: -.4375
}, {
    x: .3125,
    y: -.1875
}, {
    x: .25,
    y: .0625
}, {
    x: .4375,
    y: .25
}, {
    x: .1875,
    y: .3125
}, {
    x: 0,
    y: .4375
}, {
    x: -.0625,
    y: .1875
}, {
    x: -.25,
    y: .375
}, {
    x: -.4375,
    y: .5
}, {
    x: -.3125,
    y: .125
}];
class ProgressivePlugin extends MultiFilterPlugin {
    constructor(o=2 * offsets.length) {
        super(),
        this._lastFrames = new Map,
        this.enabled = !0,
        this.jitter = !0,
        this._hasSetOffset = !1,
        this.trackedJitterCameras = new Set,
        this._addSceneObject = c => {
            const h = c.object;
            (h.modelObject || h.lightObject) && (h.modelObject || h.lightObject).traverse(_ => {
                var b;
                !((b = _ == null ? void 0 : _.shadow) === null || b === void 0) && b.camera && _.shadow.mapSize && this.trackedJitterCameras.add([_.shadow.camera, _.shadow.mapSize])
            }
            )
        }
        ,
        this._jitterCamera = c => {
            var h;
            const _ = c.target;
            if (this.jitter && _.renderer.frameCount > 1) {
                const b = (nt, it) => {
                    const at = {
                        ...offsets[_.renderer.frameCount % offsets.length]
                    };
                    nt.setViewOffset(it.width, it.height, at.x, at.y, it.width, it.height)
                }
                  , _e = _.scene.activeCamera.cameraObject;
                b(_e, {
                    width: _.canvas.clientWidth * _.renderer.displayCanvasScaling,
                    height: _.canvas.clientHeight * _.renderer.displayCanvasScaling
                }),
                this.trackedJitterCameras.forEach(nt => b(...nt)),
                this._hasSetOffset = !0,
                (h = this._viewer) === null || h === void 0 || h.renderer.resetShadows()
            }
        }
        ,
        this._resetCameraJitter = c => {
            const h = c.target;
            this._hasSetOffset && (h.scene.activeCamera.cameraObject.clearViewOffset(),
            this._hasSetOffset = !1)
        }
        ,
        this.uiConfig = generateUiFolder("Progressive", this),
        this.maxFrameCount = o
    }
    async onAdded(o) {
        return await super.onAdded(o)
    }
    async onRemove(o) {
        o.removeEventListener("preRender", this._jitterCamera),
        o.removeEventListener("postRender", this._resetCameraJitter),
        o.scene.removeEventListener("addSceneObject", this._addSceneObject),
        this._lastFrames.forEach(c => o.renderer.disposeTarget(c)),
        this._lastFrames.clear(),
        await super.onRemove(o)
    }
    get lastFrame() {
        var o;
        return this._lastFrames.get((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.renderCamera.cameraObject.uuid)
    }
    getLastFrame(o) {
        return o ? this._lastFrames.get(o.cameraObject.uuid) : this.lastFrame
    }
    createPasses(o) {
        o.addEventListener("preRender", this._jitterCamera),
        o.addEventListener("postRender", this._resetCameraJitter),
        o.scene.addEventListener("addSceneObject", this._addSceneObject);
        const c = this;
        return [makeFilter(o, {
            passId: "progressive",
            get dirty() {
                var _;
                return c.jitter && (((_ = c._viewer) === null || _ === void 0 ? void 0 : _.renderer.frameCount) || 0) < c.maxFrameCount
            },
            after: ["render"],
            before: ["combinedPost", "screen"],
            required: ["render"],
            passObject: new class extends AddBlendPass {
                render(_, b, _e, nt, it) {
                    if (c.lastFrame) {
                        if (o.renderer.frameCount < 1)
                            return this.needsSwap = !1,
                            void ((_e == null ? void 0 : _e.texture) && o.renderer.blit(_e.texture, c.lastFrame, {}));
                        this.needsSwap = !0,
                        super.render(_, b, _e, nt, it),
                        o.renderer.blit(b.texture, c.lastFrame, {})
                    } else
                        o.console.error("lastFrame render target undefined")
                }
            }
            (void 0,o.renderer.maxHDRIntensity || 120),
            update() {
                if (!c.lastFrame && o.scene.renderCamera && c._lastFrames.set(o.scene.renderCamera.cameraObject.uuid, o.renderer.composerTarget.clone(!0)),
                !c.lastFrame)
                    return void console.error("lastFrame render target undefined");
                let _ = 1 / (Math.max(o.renderer.frameCount, 0) + 1);
                this.passObject.weights1.set(_, _, _, _),
                _ = 1 - _,
                this.passObject.weights2.set(_, _, _, _),
                this.passObject.blendTexture = c.lastFrame.texture,
                this.passObject.material.uniformsNeedUpdate = !0
            }
        })]
    }
    isConverged(o=!1) {
        var c;
        return (((c = this._viewer) === null || c === void 0 ? void 0 : c.renderer.frameCount) || 0) >= this.maxFrameCount - 1 + (o ? 1 : 0)
    }
    updateShaderProperties(o) {
        var c, h;
        return o.uniforms.tLastFrame && (o.uniforms.tLastFrame.value = (h = (c = this.lastFrame) === null || c === void 0 ? void 0 : c.texture) !== null && h !== void 0 ? h : void 0),
        this
    }
    postFrameConvergedRecordingDelta(o="CanvasRecorder") {
        const c = this._viewer.getPluginByType(o);
        return c && c.isRecording() && c.convergeMode ? this.isConverged(!0) ? 1 / c.videoFrameRate : 0 : -1
    }
}
ProgressivePlugin.PluginType = "Progressive",
ProgressivePlugin_decorate([serialize(), uiInput("Frame count")], ProgressivePlugin.prototype, "maxFrameCount", void 0),
ProgressivePlugin_decorate([serialize(), uiToggle("Jitter")], ProgressivePlugin.prototype, "jitter", void 0);
class FrameFadePlugin extends GenericFilterPlugin {
    async startTransition(o) {
        this._viewer && this._pass && !this.isDisabled() && (this._target || (this._target = this._viewer.renderer.getTempTarget({
            sizeMultiplier: 1,
            minFilter: three_module.k6q,
            magFilter: three_module.k6q,
            colorSpace: this._viewer.renderer.composerTarget.texture.colorSpace
        })),
        this._fadeTimeState < 500 && (this._toSaveFrame = !0),
        this._fadeTimeState = Math.max(o, this._fadeTimeState),
        this._fadeTime = this._fadeTimeState,
        this.setDirty(),
        await X$2(o))
    }
    stopTransition() {
        this._fadeTimeState = 0
    }
    constructor() {
        super(),
        this.passId = "frameFade",
        this._fadeTime = 0,
        this._fadeTimeState = 0,
        this._toSaveFrame = !1,
        this._beforeFilters = ["progressive", "taa"],
        this._afterFilters = ["render"],
        this._requiredFilters = ["render", "progressive"],
        this.dependencies = [ProgressivePlugin],
        this.isEditor = !1,
        this.fadeOnActiveCameraChange = !0,
        this.fadeOnMaterialUpdate = !0,
        this.fadeOnSceneUpdate = !0,
        this.pointerEnabled = !0,
        this._fadeCam = o => o.frameFade !== !1 && !this.isEditor && this.fadeOnActiveCameraChange && this.startTransition(o.fadeDuration || 1e3),
        this._fadeMat = o => {
            o.frameFade !== !1 && !this.isEditor && this.fadeOnMaterialUpdate && this.startTransition(o.fadeDuration || 200)
        }
        ,
        this._fadeScene = o => {
            o.frameFade !== !1 && !this.isEditor && this.fadeOnSceneUpdate && this.startTransition(o.fadeDuration || 500)
        }
        ,
        this._onPointerMove = o => {
            var c;
            const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.canvas;
            if (!h)
                return void (this.pointerEnabled = !1);
            if (!o.buttons || o.target !== h)
                return void (this.pointerEnabled = !0);
            const _ = h.getBoundingClientRect()
              , b = (o.clientX - _.left) / _.width
              , _e = (o.clientY - _.top) / _.height;
            this.pointerEnabled = b < 0 || b > 1 || _e < 0 || _e > 1
        }
        ,
        this._disabledBy = [],
        this.startTransition = this.startTransition.bind(this),
        this.stopTransition = this.stopTransition.bind(this),
        this._fadeCam = this._fadeCam.bind(this),
        this._fadeMat = this._fadeMat.bind(this)
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("activeCameraChange", this._fadeCam),
        o.scene.addEventListener("activeCameraUpdate", this.stopTransition),
        o.scene.addEventListener("sceneMaterialUpdate", this._fadeMat),
        o.scene.addEventListener("sceneUpdate", this._fadeScene),
        window.addEventListener("pointermove", this._onPointerMove)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("activeCameraChange", this._fadeCam),
        o.scene.removeEventListener("activeCameraUpdate", this.stopTransition),
        o.scene.removeEventListener("sceneMaterialUpdate", this._fadeMat),
        o.scene.removeEventListener("sceneUpdate", this._fadeScene),
        window.removeEventListener("pointermove", this._onPointerMove),
        super.onRemove(o)
    }
    passCtor(o) {
        const c = this
          , h = o.getPlugin(ProgressivePlugin)
          , _ = new class extends AddBlendPass {
            constructor() {
                super(...arguments),
                this._lastTime = 0,
                this._saveNextFrame = !1,
                this.uiConfig = generateUiFolder("Frame Fade", this)
            }
            render(b, _e, nt, it, at) {
                this.needsSwap = !1;
                const ut = c._target;
                if (!ut || !c.pointerEnabled || !this.enabled || !c.dirty || c._fadeTimeState < .001 || o.scene.renderCamera !== o.scene.activeCamera)
                    return;
                c._toSaveFrame && (this._saveNextFrame = !0,
                c._toSaveFrame = !1),
                this._saveNextFrame && h.lastFrame && (o.renderer.blit(h.lastFrame.texture, ut),
                this._lastTime = 0,
                this._saveNextFrame = !1),
                this.blendTexture = ut == null ? void 0 : ut.texture;
                const pt = c._fadeTimeState / c._fadeTime;
                this.weights2.setScalar(pt),
                this.weights2.w = 1,
                this.weights1.setScalar(1 - pt),
                this.weights1.w = 1,
                super.render(b, _e, nt, it, at),
                this.needsSwap = !0;
                const ht = g();
                this._lastTime < 10 && (this._lastTime = ht - 10);
                const _t = ht - this._lastTime;
                this._lastTime = ht,
                c._fadeTimeState -= _t
            }
        }
        (void 0,o.renderer.maxHDRIntensity);
        return _.enabled = !0,
        _
    }
    setDirty() {
        var o;
        this.enabled && ((o = this._viewer) === null || o === void 0 || o.setDirty())
    }
    get dirty() {
        return this.enabled && this._fadeTimeState > 0
    }
    set dirty(o) {
        console.warn("FrameFadePlugin.dirty is readonly")
    }
    _update(o) {
        return !!super._update(o) && (this.isDisabled() && this.stopTransition(),
        this._fadeTimeState < 1 && (this._toSaveFrame = !1,
        this._target && this._viewer && (this._viewer.renderer.releaseTempTarget(this._target),
        this._target = void 0)),
        !0)
    }
    get uiConfig() {
        var o, c;
        return (c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.uiConfig
    }
    disable(o) {
        this._disabledBy.includes(o) || this._disabledBy.push(o)
    }
    enable(o) {
        const c = this._disabledBy.indexOf(o);
        c >= 0 && this._disabledBy.splice(c, 1)
    }
    isDisabled() {
        return !this.pointerEnabled || this._disabledBy.length > 0 || !this.enabled
    }
}
FrameFadePlugin.PluginType = "FrameFade";
var DepthOfFieldPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class DepthOfFieldPlugin extends GenericFilterPlugin {
    passCtor(o) {
        return new DepthOfFieldPass
    }
    constructor(o=!0, c=!1) {
        super(),
        this.passId = "depthOfField",
        this._beforeFilters = ["progressive", "tonemap", "screen"],
        this._afterFilters = ["render"],
        this._requiredFilters = ["render"],
        this.dependencies = [GBufferPlugin],
        this.enableEdit = !1,
        this._focalPointHit = new three_module.Pq0(0,0,0),
        this.crossFadeTime = 200,
        this._focalPointHitTime = 0,
        this._tempVec = new three_module.Pq0,
        this.enabled = o,
        this.enableEdit = c,
        this._onObjectHit = this._onObjectHit.bind(this),
        this.setDirty = this.setDirty.bind(this)
    }
    setFocalPoint(o, c=!0, h=!1) {
        var _, b;
        this._focalPointHit.copy(o),
        c && ((b = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getPlugin(FrameFadePlugin)) === null || b === void 0 || b.startTransition(this._frameFadeTime)),
        h && (this._focalPointHitTime = g()),
        this.setDirty()
    }
    getFocalPoint() {
        return this._focalPointHit
    }
    get depthRange() {
        var o, c;
        return (c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.focalDepthRange.y) !== null && c !== void 0 ? c : 0
    }
    set depthRange(o) {
        this.pass && (this.pass.passObject.focalDepthRange.y = o),
        this.setDirty()
    }
    get nearBlurScale() {
        var o, c;
        return (c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.nearFarBlurScale.x) !== null && c !== void 0 ? c : 0
    }
    set nearBlurScale(o) {
        this.pass && (this.pass.passObject.nearFarBlurScale.x = o),
        this.setDirty()
    }
    get farBlurScale() {
        var o, c;
        return (c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.nearFarBlurScale.y) !== null && c !== void 0 ? c : 0
    }
    set farBlurScale(o) {
        this.pass && (this.pass.passObject.nearFarBlurScale.y = o),
        this.setDirty()
    }
    get _frameFadeTime() {
        return 2.5 * this.crossFadeTime
    }
    _onObjectHit(o) {
        var c, h;
        this._pass && o.intersects.intersect && this.enabled && this.enableEdit && (this._focalPointHit.copy(o.intersects.intersect.point),
        this._focalPointHitTime = o.time,
        o.intersects.selectedObject = null,
        (h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(FrameFadePlugin)) === null || h === void 0 || h.startTransition(this._frameFadeTime),
        this.setDirty())
    }
    async onAdded(o) {
        var c;
        await super.onAdded(o),
        (c = o.getPluginByType("Picking")) === null || c === void 0 || c.addEventListener("hitObject", this._onObjectHit)
    }
    async onRemove(o) {
        var c;
        return (c = o.getPluginByType("Picking")) === null || c === void 0 || c.removeEventListener("hitObject", this._onObjectHit),
        super.onRemove(o)
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    _update(o) {
        var c, h;
        if (!super._update(o))
            return !1;
        const _ = (c = this.pass) === null || c === void 0 ? void 0 : c.passObject;
        if (!_)
            return !1;
        const b = o.getPlugin(GBufferPlugin);
        b == null || b.updateShaderProperties(_.material),
        _.dofBlurMaterial.uniforms.frameCount && ((h = o.renderer) === null || h === void 0 || h.updateShaderProperties(_.dofBlurMaterial));
        const _e = o.scene.renderCamera;
        if (!_e)
            return !1;
        _e.cameraObject.updateMatrixWorld(!0),
        _e.updateShaderProperties(_.material),
        _e.cameraObject.getWorldPosition(this._tempVec),
        this._tempVec.subVectors(this._focalPointHit, this._tempVec),
        _.focalDepthRange.x = this._tempVec.length(),
        _.focalDepthRange.x *= _e.cameraObject.getWorldDirection(new three_module.Pq0).dot(this._tempVec.normalize());
        let nt = (g() - this._focalPointHitTime) / this.crossFadeTime;
        if (nt = 1 - Math.min(1, Math.max(0, nt)),
        Math.abs(nt - _.crossAlpha) > .01 && (_.crossAlpha = nt,
        this.setDirty()),
        nt > 0) {
            const it = this._tempVec.copy(this._focalPointHit).project(_e.cameraObject).addScalar(1).divideScalar(2);
            _.crossCenter.set(it.x, it.y),
            _.computeCocMaterial.uniformsNeedUpdate = !0,
            _.expandCocMaterial.uniformsNeedUpdate = !0
        }
        return !0
    }
    get uiConfig() {
        var o, c, h, _, b;
        if (this._uiConfig)
            return this._uiConfig;
        const _e = (c = (o = this._pass) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.uiConfig;
        return _e ? ((_ = (h = _e.children) === null || h === void 0 ? void 0 : h.map(nt => Ee$1(nt))) === null || _ === void 0 || _.flat(2).forEach(nt => nt && (nt.onChange = this.setDirty)),
        (b = _e.children) === null || b === void 0 || b.push({
            type: "checkbox",
            label: "Enable Edit",
            limitedUi: !0,
            property: [this, "enableEdit"]
        }),
        this._uiConfig = _e,
        _e) : {}
    }
}
DepthOfFieldPlugin.PluginType = "DepthOfField",
DepthOfFieldPlugin_decorate([serialize()], DepthOfFieldPlugin.prototype, "enableEdit", void 0),
DepthOfFieldPlugin_decorate([serialize("focalPoint")], DepthOfFieldPlugin.prototype, "_focalPointHit", void 0),
DepthOfFieldPlugin_decorate([serialize()], DepthOfFieldPlugin.prototype, "crossFadeTime", void 0);
var voronoise = `#ifndef VORONOISE_HELPER
#define VORONOISE_HELPER 
float voronoise(in vec2 p,float u,float v){float k=1.+63.*pow(max(0.,1.-v),6.);vec2 i=floor(p);vec2 f=fract(p);vec2 a=vec2(0.,0.);for(int y=-2;y<=2;y++)for(int x=-2;x<=2;x++){vec2 g=vec2(x,y);vec3 o=hash3(i+g)*vec3(u,u,1.);vec2 d=g-f+o.xy;float w=pow(max(0.,1.-smoothstep(0.,1.414,length(d))),k);a+=vec2(o.z*w,w);}return a.x/a.y;}vec3 voronoise3(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),voronoise(p-vec2(0.83,0.45),u,v));}vec3 voronoiseNormal(vec2 p,float u,float v){return vec3(voronoise(p,u,v),voronoise(p+vec2(0.435,0.23),u,v),1.);}
#endif
`
  , thinFilmLayer = "vec3 incident=normalize(vViewPosition.xyz);float hWeight=1.-dot(normal,incident);vec3 noiseV=voronoise3(vUv.xy*thinColorNoiseParams.xy*60.,thinColorNoiseParams.z,thinColorNoiseParams.w);float hWeight2=1.-dot(normalize(noiseV),incident);vec3 film=hsv2rgb(vec3(fract(hWeight+thinBaseLayerFactors.x),thinBaseLayerFactors.y,thinBaseLayerFactors.z))*thinBaseLayerFactors.a;vec3 film2=hsv2rgb(vec3(fract(hWeight2+thinNoiseLayerFactors.x),thinNoiseLayerFactors.y,thinNoiseLayerFactors.z))*thinNoiseLayerFactors.a;film=(film+film2)/(thinBaseLayerFactors.a+thinNoiseLayerFactors.a);diffuseColor.rgb=mix(diffuseColor.rgb,film,thinFilmFactor);"
  , hsvHelpers = `#ifndef HSV_HELPERS
#define HSV_HELPERS 
vec3 hsv2rgb(vec3 c){vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=c.g<c.b?vec4(c.bg,K.wz):vec4(c.gb,K.xy);vec4 q=c.r<p.x?vec4(p.xyw,c.r):vec4(c.r,p.yzx);float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}
#endif 
`
  , ThinFilmLayerPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ThinFilmLayerPlugin = class extends AViewerPlugin {
    addThinFilmLayer(d) {
        return addThinFilmLayer(d.materialObject)
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsThinFilmLayerExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this._defines = {},
        this._uniforms = {
            thinBaseLayerFactors: {
                value: new three_module.IUQ
            },
            thinNoiseLayerFactors: {
                value: new three_module.IUQ
            },
            thinColorNoiseParams: {
                value: new three_module.IUQ
            },
            thinFilmFactor: {
                value: .8
            }
        },
        this.materialExtension = {
            parsFragmentSnippet: (d, o) => {
                var c;
                return this.enabled && (!((c = o == null ? void 0 : o.materialObject.userData._thinFilmLayer) === null || c === void 0) && c.hasThinFilm) ? randomHelpers + `
` + voronoise + `
` + hsvHelpers + `
uniform vec4 thinBaseLayerFactors;
uniform vec4 thinNoiseLayerFactors;
uniform vec4 thinColorNoiseParams;
uniform float thinFilmFactor;
        ` : ""
            }
            ,
            shaderExtender: (d, o, c) => {
                var h;
                if (!this.enabled || !(!((h = o.materialObject.userData._thinFilmLayer) === null || h === void 0) && h.hasThinFilm))
                    return;
                const _ = "#glMarker beforeAccumulation";
                d.fragmentShader = d.fragmentShader.replace(_, thinFilmLayer + _),
                d.defines.USE_UV = ""
            }
            ,
            onObjectRender: (d, o) => {
                var c;
                const h = (c = o.materialObject.userData) === null || c === void 0 ? void 0 : c._thinFilmLayer;
                if (!(h != null && h.hasThinFilm))
                    return;
                this._uniforms.thinBaseLayerFactors.value.fromArray(h.baseLayerFactors),
                this._uniforms.thinNoiseLayerFactors.value.fromArray(h.noiseLayerFactors),
                this._uniforms.thinColorNoiseParams.value.fromArray(h.colorNoiseParams),
                this._uniforms.thinFilmFactor.value = h.filmFactor;
                const _ = this.enabled ? 1 : 0;
                o.materialObject.defines.THIN_FILM_LAYER_ENABLED !== _ && (o.materialObject.defines.THIN_FILM_LAYER_ENABLED = _,
                o.materialObject.needsUpdate = !0)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c;
                return (this.enabled ? "1" : "0") + (!((c = (o = d.materialObject.userData) === null || o === void 0 ? void 0 : o._thinFilmLayer) === null || c === void 0) && c.hasThinFilm ? "1" : "0")
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2 || d.isDiamondMaterial,
            updaters: () => [],
            getUiConfig: d => {
                const o = this._viewer
                  , c = {
                    type: "folder",
                    label: "ThinFilmLayer",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            var h;
                            return ((h = d.materialObject.userData._thinFilmLayer) === null || h === void 0 ? void 0 : h.hasThinFilm) || !1
                        },
                        set value(h) {
                            var _, b;
                            h !== ((_ = d.materialObject.userData._thinFilmLayer) === null || _ === void 0 ? void 0 : _.hasThinFilm) && (h ? addThinFilmLayer(d.materialObject) || o.alert("Cannot add thin film.") : d.materialObject.userData._thinFilmLayer && (d.materialObject.userData._thinFilmLayer.hasThinFilm = !1,
                            d.materialObject.needsUpdate = !0),
                            (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, () => ({
                        type: "slider",
                        bounds: [0, 1],
                        label: "Intensity",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._thinFilmLayer) === null || h === void 0) && h.hasThinFilm)
                        }
                        ,
                        property: [d.materialObject.userData._thinFilmLayer, "filmFactor"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "vec4",
                        label: "Base Layer",
                        bounds: [0, 1],
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._thinFilmLayer) === null || h === void 0) && h.hasThinFilm)
                        }
                        ,
                        property: [d.materialObject.userData._thinFilmLayer, "baseLayerFactors"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "vec4",
                        label: "Noise Layer",
                        bounds: [0, 1],
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._thinFilmLayer) === null || h === void 0) && h.hasThinFilm)
                        }
                        ,
                        property: [d.materialObject.userData._thinFilmLayer, "noiseLayerFactors"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "vec4",
                        label: "Noise Params",
                        bounds: [0, 1],
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._thinFilmLayer) === null || h === void 0) && h.hasThinFilm)
                        }
                        ,
                        property: [d.materialObject.userData._thinFilmLayer, "colorNoiseParams"],
                        onChange: this.setDirty
                    })]
                };
                return c
            }
        },
        this.setDirty = () => {
            var d;
            (d = this._viewer) === null || d === void 0 || d.setDirty()
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsThinFilmLayerExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
function addThinFilmLayer(d) {
    const o = d == null ? void 0 : d.userData;
    if (!o)
        return !1;
    o._thinFilmLayer || (o._thinFilmLayer = {});
    const c = o._thinFilmLayer;
    return c.hasThinFilm = !0,
    c.baseLayerFactors === void 0 && (c.baseLayerFactors = [.3, .6, 1, .9]),
    c.noiseLayerFactors === void 0 && (c.noiseLayerFactors = [.7, .5, .9, .7]),
    c.colorNoiseParams === void 0 && (c.colorNoiseParams = [.5, .5, .5, .7]),
    c.filmFactor === void 0 && (c.filmFactor = .3),
    d.isMaterial && (d.needsUpdate = !0),
    !0
}
ThinFilmLayerPlugin.PluginType = "ThinFilmLayerPlugin",
ThinFilmLayerPlugin.THIN_FILM_LAYER_GLTF_EXTENSION = "WEBGI_materials_thin_film_layer",
ThinFilmLayerPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], ThinFilmLayerPlugin.prototype, "enabled", void 0),
ThinFilmLayerPlugin = ThinFilmLayerPlugin_decorate([uiFolder("ThinFilmLayer Materials")], ThinFilmLayerPlugin);
class GLTFMaterialsThinFilmLayerExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = ThinFilmLayerPlugin.THIN_FILM_LAYER_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        return c.userData || (c.userData = {}),
        addThinFilmLayer(c),
        c.userData._thinFilmLayer = deserializeObject(_, c.userData._thinFilmLayer, !1, {}),
        Promise.resolve()
    }
}
const glTFMaterialsThinFilmLayerExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._thinFilmLayer || !o.userData._thinFilmLayer.hasThinFilm)
            return;
        c.extensions = c.extensions || {};
        const h = serializeObject(o.userData._thinFilmLayer, !1);
        c.extensions[ThinFilmLayerPlugin.THIN_FILM_LAYER_GLTF_EXTENSION] = h,
        d.extensionsUsed[ThinFilmLayerPlugin.THIN_FILM_LAYER_GLTF_EXTENSION] = !0
    }
});
function match(d, o) {
    const c = typeof d == "string" ? d : d.path;
    return c === (typeof o == "string" ? o : o.path) && c || typeof d != "string" && typeof o != "string" && d.id && d.id === o.id
}
class PresetGroup {
    async apply(o, c, h) {
        var _, b, _e, nt;
        if (!c)
            return void (this.selected = void 0);
        let it = this.presets.find(at => match(at, c));
        return it || (this.presets.push(c),
        it = c),
        this.selected = it,
        typeof it != "string" ? (b = (_ = o.getManager()) === null || _ === void 0 ? void 0 : _.importer) === null || b === void 0 ? void 0 : b.importAsset(it, h) : (nt = (_e = o.getManager()) === null || _e === void 0 ? void 0 : _e.importer) === null || nt === void 0 ? void 0 : nt.importPath(it, h)
    }
    addPresets(o) {
        this.presets.push(...o.filter(c => {
            const h = this.presets.find(_ => match(_, c));
            return !h || (typeof h == "string" ? (this.presets = this.presets.filter(_ => _ !== h),
            !0) : (typeof c == "string" || Object.assign(h, c),
            !1))
        }
        ))
    }
    clear() {
        this.selected = void 0
    }
    constructor(o) {
        this.presets = [],
        this.name = "",
        this.selected = void 0,
        o && (this.name = o)
    }
}
class BackgroundPresetGroup extends PresetGroup {
    constructor() {
        super(...arguments),
        this.name = "Background"
    }
    async apply(o, c) {
        const h = await super.apply(o, c)
          , _ = h == null ? void 0 : h[0];
        return _ && (_.colorSpace = three_module.er$,
        o.scene.background = _,
        o.scene.backgroundColor = new three_module.Q1f(1,1,1)),
        _
    }
}
class EnvironmentPresetGroup extends PresetGroup {
    constructor() {
        super(...arguments),
        this.name = "Environment"
    }
    async apply(o, c) {
        const h = await super.apply(o, c)
          , _ = h == null ? void 0 : h[0];
        return _ && (o.scene.environment = _),
        _
    }
}
class GemEnvironmentPresetGroup extends PresetGroup {
    constructor(o="envMap") {
        super(),
        this.key = o,
        this.name = "GemEnvironment",
        this.name += o.split("Map")[1]
    }
    async apply(o, c) {
        const h = await super.apply(o, c)
          , _ = h == null ? void 0 : h[0];
        return S$2(o.getPluginByType("Diamond"), this.key, _),
        _
    }
}
class PluginPresetGroup extends PresetGroup {
    async apply(o, c) {
        var h, _;
        const b = await super.apply(o, c, {
            processImported: !1
        });
        return b ? (_ = (h = o.getManager()) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 ? void 0 : _.processImported(b) : void 0
    }
}
class ModelStagePresetGroup extends PresetGroup {
    constructor() {
        super(...arguments),
        this.name = "ModelStage"
    }
    async apply(o, c) {
        var h;
        const _ = typeof c == "string" ? c : c.path;
        let b = !1;
        try {
            b = new URL(_.includes("://") ? _ : "https://example.com/" + _).pathname.endsWith(".json")
        } catch {
            b = _.endsWith(".json")
        }
        if (b)
            return super.apply(o, c);
        {
            const _e = o.getPluginByType("ModelStagePlugin");
            return _e == null ? void 0 : _e.setModel((h = c.file) !== null && h !== void 0 ? h : _)
        }
    }
}
class MaterialLibPresetGroupPresetGroup extends PluginPresetGroup {
    constructor() {
        super(...arguments),
        this.name = "MaterialLibraries"
    }
    async apply(o, c) {
        const h = await super.apply(o, c);
        return h && await o.alert("Material Library successfully imported."),
        h
    }
}
class VJSONPresetGroup extends PresetGroup {
    constructor() {
        super(...arguments),
        this.name = "VJSON",
        this.usePresetCamera = !1,
        this.usePresetLoadingPlugin = !1,
        this.usePresetInteractionPlugin = !1,
        this.usePresetParallaxMappingPlugin = !1,
        this.usePresetRendererUiPlugin = !1,
        this.usePresetCameraViewPlugin = !1,
        this.usePresetMaterialConfiguratorPlugin = !1,
        this.usePresetSwitchNodePlugin = !1
    }
    async apply(o, c) {
        const h = o.scene.activeCamera.toJSON()
          , _ = o.serializePluginsIgnored;
        o.serializePluginsIgnored = [..._, this.usePresetLoadingPlugin ? null : "LoadingScreenPlugin", this.usePresetInteractionPlugin ? null : "InteractionPromptPlugin", this.usePresetParallaxMappingPlugin ? null : "ReliefParallaxMapping", this.usePresetRendererUiPlugin ? null : "RendererParamsUiPlugin", this.usePresetCameraViewPlugin ? null : "CameraViews", this.usePresetMaterialConfiguratorPlugin ? null : "MaterialConfiguratorPlugin", this.usePresetSwitchNodePlugin ? null : "SwitchNodePlugin", "FrameFade", "GLTFAnimationPlugin", "ModelStagePlugin", "AssetExporterPlugin"].filter(_e => _e);
        const b = await super.apply(o, c);
        return o.serializePluginsIgnored = _,
        this.usePresetCamera || o.scene.activeCamera.fromJSON(h),
        b
    }
}
class PresetLibraryPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.toJSON = null,
        this.enabled = !0,
        this.presetGroups = [],
        this.uiConfig = {
            type: "folder",
            label: "Presets",
            expanded: !0,
            limitedUi: !0,
            children: [ () => this.presetGroups.map(o => ({
                type: "dropdown",
                label: o.name,
                limitedUi: !0,
                children: [{
                    value: "",
                    label: "none"
                }, ...o.presets.map(c => {
                    var h;
                    return {
                        label: ((h = tPresetToString(c)) === null || h === void 0 ? void 0 : h.split("/").pop()) || "",
                        value: tPresetToString(c)
                    }
                }
                )],
                getValue: () => tPresetToString(o.selected) || "",
                setValue: c => {
                    o.apply(this._viewer, o.presets.find(h => tPresetToString(h) === c))
                }
            })), {
                type: "button",
                label: "Download Selection",
                limitedUi: !0,
                value: () => {
                    const o = this.exportPresets();
                    me$1(new File([JSON.stringify(o, null, 2)],"preset.template.json",{
                        type: "application/json"
                    }))
                }
            }, {
                type: "button",
                label: "Export Preset Groups",
                limitedUi: !1,
                value: () => {
                    const o = this.exportPresetGroups();
                    me$1(new File([JSON.stringify(o, null, 2)],"presetGroups.json",{
                        type: "application/json"
                    }))
                }
            }]
        }
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        this.presetGroups.push(new BackgroundPresetGroup),
        this.presetGroups.push(new EnvironmentPresetGroup),
        this.presetGroups.push(new GemEnvironmentPresetGroup),
        this.presetGroups.push(new GemEnvironmentPresetGroup("envMap2")),
        this.presetGroups.push(new GemEnvironmentPresetGroup("envMap3")),
        this.presetGroups.push(new PluginPresetGroup("Ground")),
        this.presetGroups.push(new PluginPresetGroup("CameraViews")),
        this.presetGroups.push(new PluginPresetGroup("MaterialConfiguration")),
        this.presetGroups.push(new ModelStagePresetGroup),
        this.presetGroups.push(new MaterialLibPresetGroupPresetGroup),
        this.presetGroups.push(new VJSONPresetGroup),
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
    }
    exportPresets() {
        const o = Object.fromEntries(this.presetGroups.map(c => [c.name, c.selected ? cleanAsset(c.selected) : void 0]).filter( ([,c]) => c));
        return o.type = PresetLibraryPlugin.PluginType,
        o
    }
    async fromJSON(o, c) {
        var h, _;
        if (!super.fromJSON(o, c))
            return null;
        const b = {
            ...o
        };
        if (delete b.type,
        b.VJSON && this._viewer) {
            const nt = this.presetGroups.find(at => at.name === "VJSON")
              , it = nt == null ? void 0 : nt.presets;
            nt && it && await nt.apply(this._viewer, b.VJSON),
            delete b.VJSON
        }
        const _e = [];
        for (const [nt,it] of Object.entries(b)) {
            const at = this.presetGroups.find(ht => ht.name === nt)
              , ut = at == null ? void 0 : at.presets;
            if (!at || !ut)
                continue;
            const pt = it;
            _e.push(at.apply(this._viewer, pt))
        }
        return await Promise.all(_e),
        (_ = (h = this.uiConfig).uiRefresh) === null || _ === void 0 || _.call(h, "postFrame", !0),
        this
    }
    async loadPresetGroups(o) {
        typeof o == "string" && o.startsWith("http") && (o = await fetch(o).then(async c => c.json()));
        for (const [c,h] of Object.entries(o)) {
            const _ = this.presetGroups.find(b => b.name === c);
            _ == null || _.addPresets(h)
        }
    }
    exportPresetGroups() {
        return Object.fromEntries(this.presetGroups.map(o => [o.name, o.presets.map(cleanAsset)]).filter( ([,o]) => o.length > 0))
    }
    clear() {
        this.presetGroups.forEach(o => {
            o.clear()
        }
        )
    }
}
function tPresetToString(d) {
    return d && typeof d != "string" ? d.path || d.id : d
}
PresetLibraryPlugin.PluginType = "PresetLibraryPlugin";
const cleanAsset = d => (d.preImported && delete (d = {
    ...d
}).preImported,
d);
var grain = "vec4 grain(in vec4 color){float x=(vUv.x+4.)*(vUv.y+4.)*(10.);vec4 grain=vec4(mod((mod(x,13.)+1.)*(mod(x,123.)+1.),0.01)-0.005)*grainIntensity;vec4 outColor=color;if(grainMultiply){grain=1.-grain;outColor.rgb=color.rgb*vec3(grain);}else{outColor.rgb=color.rgb+vec3(grain);}return outColor;}"
  , FilmicGrainPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let FilmicGrainExtension = class {
    constructor(d) {
        this.enabled = !1,
        this.grainMultiply = !1,
        this.grainIntensity = 10,
        this.extraUniforms = {
            grainIntensity: {
                value: 1
            },
            grainMultiply: {
                value: 1
            }
        },
        this.parsFragmentSnippet = (o, c) => this.enabled ? fe$1`
            uniform float grainIntensity;
            uniform bool grainMultiply;
            ${grain}
        ` : "",
        this._combinedPostPlugin = d.getPlugin(CombinedPostPlugin),
        this._setDirty = this._setDirty.bind(this)
    }
    shaderExtender(d, o, c) {
        this.enabled && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker", ` 
            gl_FragColor = grain(gl_FragColor);
            #glMarker
        `))
    }
    onObjectRender(d, o, c) {
        this.enabled && (this.extraUniforms.grainIntensity.value = this.grainIntensity,
        this.extraUniforms.grainMultiply.value = this.grainMultiply)
    }
    getUiConfig() {
        return this.uiConfig
    }
    computeCacheKey(d) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(d) {
        return !0
    }
    _setDirty() {
        this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0)
    }
    setDirty() {
        var d;
        (d = this.__setDirty) === null || d === void 0 || d.call(this),
        this._setDirty()
    }
}
;
FilmicGrainPlugin_decorate([x$1(FilmicGrainExtension.prototype._setDirty), uiToggle("Enable"), serialize()], FilmicGrainExtension.prototype, "enabled", void 0),
FilmicGrainPlugin_decorate([x$1(FilmicGrainExtension.prototype._setDirty), uiToggle("Multiply"), serialize()], FilmicGrainExtension.prototype, "grainMultiply", void 0),
FilmicGrainPlugin_decorate([x$1(FilmicGrainExtension.prototype._setDirty), uiSlider("Intensity", [0, 20], .01, {
    limitedUi: !0
}), serialize()], FilmicGrainExtension.prototype, "grainIntensity", void 0),
FilmicGrainExtension = FilmicGrainPlugin_decorate([uiFolder("FilmicGrain")], FilmicGrainExtension);
class FilmicGrainPlugin extends GenericExtensionPlugin {
    constructor() {
        super()
    }
    generateExtension(o) {
        return new FilmicGrainExtension(o)
    }
    get intensity() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.grainIntensity) !== null && c !== void 0 ? c : 1
    }
    set intensity(o) {
        this._extension && (this._extension.grainIntensity = o,
        this._extension.setDirty())
    }
    get multiply() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.grainMultiply) !== null && c !== void 0 && c
    }
    set multiply(o) {
        this._extension && (this._extension.grainMultiply = o,
        this._extension.setDirty())
    }
}
FilmicGrainPlugin.PluginType = "FilmicGrain";
class ObjectPicker extends I$2 {
    get scene() {
        return this._scene
    }
    set scene(o) {
        var c;
        (c = this._scene) === null || c === void 0 || c.removeEventListener("activeCameraChange", this._activeCameraChange),
        this._scene = o,
        this._scene.addEventListener("activeCameraChange", this._activeCameraChange)
    }
    constructor(o, c, h, _) {
        super(),
        this.hoverEnabled = !1,
        this._mouseDownPos = new three_module.I9Y,
        this._scene = o,
        this._camera = h ?? this._scene.activeCamera,
        this.domElement = c,
        this._time = this.time,
        this._mouseDownTime = 0,
        this._mouseUpTime = 1,
        this.selectionCondition = _ ?? (b => b.userData.userSelectable !== !1 && b.userData.bboxVisible !== !1 && b.material != null && b.material.type !== "ShadowMaterial"),
        this.raycaster = new three_module.tBo,
        this.mouse = new three_module.I9Y,
        this._selected = [],
        this._hovering = [],
        this.cursorStyles = {
            default: "grab",
            down: "grabbing"
        },
        this._activeCameraChange = this._activeCameraChange.bind(this),
        this._scene.addEventListener("activeCameraChange", this._activeCameraChange),
        this.domElement.style.touchAction = "none",
        this.domElement.style.cursor = this.cursorStyles.default,
        this.domElement.addEventListener("pointermove", b => this.onPointerMove(b)),
        this.domElement.addEventListener("pointerleave", b => this.onPointerLeave(b)),
        this.domElement.addEventListener("pointerout", b => this.onPointerLeave(b)),
        this.domElement.addEventListener("pointercancel", b => this.onPointerCancel(b)),
        this.domElement.addEventListener("pointerenter", b => this.onPointerEnter(b)),
        this.domElement.addEventListener("pointerdown", b => this.onPointerDown(b)),
        this.domElement.addEventListener("pointerup", b => this.onPointerUp(b))
    }
    _activeCameraChange() {
        this.camera = this._scene.activeCamera
    }
    get camera() {
        return this._camera
    }
    set camera(o) {
        this._camera = o
    }
    get selectedObject() {
        return this._selected.length > 0 ? this._selected[0] : null
    }
    set selectedObject(o) {
        this._selected.length === 1 && this._selected[0] === o || (this._selected = o ? Array.isArray(o) ? [...o] : [o] : [],
        this.dispatchEvent({
            type: "selectedObjectChanged",
            object: this.selectedObject
        }))
    }
    get hoverObject() {
        return this._hovering.length > 0 ? this._hovering[0] : null
    }
    set hoverObject(o) {
        this._hovering = o ? Array.isArray(o) ? [...o] : [o] : [],
        this.dispatchEvent({
            type: "hoverObjectChanged",
            object: this.hoverObject
        })
    }
    get time() {
        return this._time = g(),
        this._time
    }
    get isMouseDown() {
        return this.mouseDownDeltaTime < 0
    }
    get mouseDownDeltaTime() {
        return this._mouseUpTime - this._mouseDownTime
    }
    onPointerMove(o) {
        var c, h;
        o.isPrimary !== !1 && (this.updateMouseFromEvent(o),
        this.hoverEnabled && (this.hoverObject = (h = (c = this.checkIntersection()) === null || c === void 0 ? void 0 : c.intersects[0].object) !== null && h !== void 0 ? h : null))
    }
    onPointerLeave(o) {
        o.isPrimary !== !1 && (this.domElement.style.cursor = this.cursorStyles.default,
        (this.hoverEnabled || this.hoverObject) && (this.hoverObject = null))
    }
    onPointerEnter(o) {}
    onPointerCancel(o) {}
    updateMouseFromEvent(o) {
        const c = this.domElement.getBoundingClientRect();
        this.mouse.x = (o.clientX - c.x) / c.width * 2 - 1,
        this.mouse.y = -(o.clientY - c.y) / c.height * 2 + 1
    }
    onPointerDown(o) {
        o.isPrimary !== !1 && (this.domElement.style.cursor = this.cursorStyles.down,
        this._mouseDownTime = this.time,
        this._mouseDownPos.copy(this.mouse))
    }
    onDoubleClick(o) {
        console.log("double click")
    }
    onPointerUp(o) {
        if (o.isPrimary === !1)
            return;
        this.domElement.style.cursor = this.cursorStyles.default,
        this._mouseUpTime = this.time;
        const c = this.mouseDownDeltaTime
          , h = this._mouseDownPos.distanceTo(this.mouse);
        c < ObjectPicker.PointerClickMaxTime && h < ObjectPicker.PointerClickMaxDistance && this.onPointerClick(o)
    }
    onPointerClick(o) {
        if (o.isPrimary === !1)
            return;
        this.updateMouseFromEvent(o);
        const c = this.checkIntersection();
        c && this.dispatchEvent({
            type: "hitObject",
            time: this._mouseUpTime,
            intersects: c
        }),
        this.selectedObject = (c == null ? void 0 : c.selectedObject) || null
    }
    addPasses() {}
    checkIntersection() {
        var o;
        const c = (o = this._camera) === null || o === void 0 ? void 0 : o.cameraObject;
        if (!c)
            return null;
        this.raycaster.setFromCamera(this.mouse, c);
        let h = this.raycaster.intersectObject(this._scene.modelRoot.modelObject, !0);
        const _ = [];
        h = h.filter(at => !_.includes(at.object.id) && (_.push(at.object.id),
        !0));
        let _e, nt = null;
        const it = [];
        for (const at of h) {
            for (nt = at.object,
            _e = at; !(nt == null || nt.visible && this.selectionCondition(nt)); )
                nt = nt.parent;
            nt != null && it.push(at)
        }
        if (h = it,
        h.length > 0) {
            if (nt = h[0].object,
            _e = h[0],
            this._firstHit && nt.id !== this._firstHit.id)
                nt = _e.object;
            else
                for (let at = 0; at < h.length; at++)
                    if (this.selectedObject && this.selectedObject.id === h[at].object.id) {
                        const ut = at + 1;
                        if (!(ut < h.length))
                            return null;
                        _e = h[ut],
                        nt = _e.object
                    }
            this._firstHit = h[0].object
        }
        return nt && _e && nt ? {
            selectedObject: nt,
            intersect: _e,
            intersects: h,
            mouse: this.mouse.toArray()
        } : null
    }
    isHovering() {
        return this.hoverObject != null
    }
    isSelected() {
        return this.selectedObject != null
    }
}
ObjectPicker.PointerClickMaxTime = 200,
ObjectPicker.PointerClickMaxDistance = .1;
const LineSegmentsGeometry_box = new three_module.NRn
  , LineSegmentsGeometry_vector = new three_module.Pq0;
class LineSegmentsGeometry extends three_module.CmU {
    constructor() {
        super(),
        this.isLineSegmentsGeometry = !0,
        this.type = "LineSegmentsGeometry",
        this.setIndex([0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]),
        this.setAttribute("position", new three_module.qtW([-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0],3)),
        this.setAttribute("uv", new three_module.qtW([-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],2))
    }
    applyMatrix4(o) {
        const c = this.attributes.instanceStart
          , h = this.attributes.instanceEnd;
        return c !== void 0 && (c.applyMatrix4(o),
        h.applyMatrix4(o),
        c.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    setPositions(o) {
        let c;
        o instanceof Float32Array ? c = o : Array.isArray(o) && (c = new Float32Array(o));
        const h = new three_module.LuO(c,6,1);
        return this.setAttribute("instanceStart", new three_module.eHs(h,3,0)),
        this.setAttribute("instanceEnd", new three_module.eHs(h,3,3)),
        this.computeBoundingBox(),
        this.computeBoundingSphere(),
        this
    }
    setColors(o) {
        let c;
        o instanceof Float32Array ? c = o : Array.isArray(o) && (c = new Float32Array(o));
        const h = new three_module.LuO(c,6,1);
        return this.setAttribute("instanceColorStart", new three_module.eHs(h,3,0)),
        this.setAttribute("instanceColorEnd", new three_module.eHs(h,3,3)),
        this
    }
    fromWireframeGeometry(o) {
        return this.setPositions(o.attributes.position.array),
        this
    }
    fromEdgesGeometry(o) {
        return this.setPositions(o.attributes.position.array),
        this
    }
    fromMesh(o) {
        return this.fromWireframeGeometry(new three_module.XJ7(o.geometry)),
        this
    }
    fromLineSegments(o) {
        const c = o.geometry;
        return this.setPositions(c.attributes.position.array),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new three_module.NRn);
        const o = this.attributes.instanceStart
          , c = this.attributes.instanceEnd;
        o !== void 0 && c !== void 0 && (this.boundingBox.setFromBufferAttribute(o),
        LineSegmentsGeometry_box.setFromBufferAttribute(c),
        this.boundingBox.union(LineSegmentsGeometry_box))
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new three_module.iyt),
        this.boundingBox === null && this.computeBoundingBox();
        const o = this.attributes.instanceStart
          , c = this.attributes.instanceEnd;
        if (o !== void 0 && c !== void 0) {
            const h = this.boundingSphere.center;
            this.boundingBox.getCenter(h);
            let _ = 0;
            for (let b = 0, _e = o.count; b < _e; b++)
                LineSegmentsGeometry_vector.fromBufferAttribute(o, b),
                _ = Math.max(_, h.distanceToSquared(LineSegmentsGeometry_vector)),
                LineSegmentsGeometry_vector.fromBufferAttribute(c, b),
                _ = Math.max(_, h.distanceToSquared(LineSegmentsGeometry_vector));
            this.boundingSphere.radius = Math.sqrt(_),
            isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this)
        }
    }
    toJSON() {}
    applyMatrix(o) {
        return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),
        this.applyMatrix4(o)
    }
}
class WireframeGeometry2 extends LineSegmentsGeometry {
    constructor(o) {
        super(),
        this.isWireframeGeometry2 = !0,
        this.type = "WireframeGeometry2",
        this.fromWireframeGeometry(new three_module.XJ7(o))
    }
}
three_module.fCn.line = {
    worldUnits: {
        value: 1
    },
    linewidth: {
        value: 1
    },
    resolution: {
        value: new three_module.I9Y(1,1)
    },
    dashOffset: {
        value: 0
    },
    dashScale: {
        value: 1
    },
    dashSize: {
        value: 1
    },
    gapSize: {
        value: 1
    }
},
three_module.zkh.line = {
    uniforms: three_module.LlO.merge([three_module.fCn.common, three_module.fCn.fog, three_module.fCn.line]),
    vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
    fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};
class LineMaterial extends three_module.BKk {
    constructor(o) {
        super({
            type: "LineMaterial",
            uniforms: three_module.LlO.clone(three_module.zkh.line.uniforms),
            vertexShader: three_module.zkh.line.vertexShader,
            fragmentShader: three_module.zkh.line.fragmentShader,
            clipping: !0
        }),
        this.isLineMaterial = !0,
        this.setValues(o)
    }
    get color() {
        return this.uniforms.diffuse.value
    }
    set color(o) {
        this.uniforms.diffuse.value = o
    }
    get worldUnits() {
        return "WORLD_UNITS"in this.defines
    }
    set worldUnits(o) {
        o === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS
    }
    get linewidth() {
        return this.uniforms.linewidth.value
    }
    set linewidth(o) {
        this.uniforms.linewidth && (this.uniforms.linewidth.value = o)
    }
    get dashed() {
        return "USE_DASH"in this.defines
    }
    set dashed(o) {
        o === !0 !== this.dashed && (this.needsUpdate = !0),
        o === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH
    }
    get dashScale() {
        return this.uniforms.dashScale.value
    }
    set dashScale(o) {
        this.uniforms.dashScale.value = o
    }
    get dashSize() {
        return this.uniforms.dashSize.value
    }
    set dashSize(o) {
        this.uniforms.dashSize.value = o
    }
    get dashOffset() {
        return this.uniforms.dashOffset.value
    }
    set dashOffset(o) {
        this.uniforms.dashOffset.value = o
    }
    get gapSize() {
        return this.uniforms.gapSize.value
    }
    set gapSize(o) {
        this.uniforms.gapSize.value = o
    }
    get opacity() {
        return this.uniforms.opacity.value
    }
    set opacity(o) {
        this.uniforms && (this.uniforms.opacity.value = o)
    }
    get resolution() {
        return this.uniforms.resolution.value
    }
    set resolution(o) {
        this.uniforms.resolution.value.copy(o)
    }
    get alphaToCoverage() {
        return "USE_ALPHA_TO_COVERAGE"in this.defines
    }
    set alphaToCoverage(o) {
        this.defines && (o === !0 !== this.alphaToCoverage && (this.needsUpdate = !0),
        o === !0 ? (this.defines.USE_ALPHA_TO_COVERAGE = "",
        this.extensions.derivatives = !0) : (delete this.defines.USE_ALPHA_TO_COVERAGE,
        this.extensions.derivatives = !1))
    }
}
const _start = new three_module.Pq0
  , _end = new three_module.Pq0;
class Wireframe extends three_module.eaF {
    constructor(o=new LineSegmentsGeometry, c=new LineMaterial({
        color: 16777215 * Math.random()
    })) {
        super(o, c),
        this.isWireframe = !0,
        this.type = "Wireframe"
    }
    computeLineDistances() {
        const o = this.geometry
          , c = o.attributes.instanceStart
          , h = o.attributes.instanceEnd
          , _ = new Float32Array(2 * c.count);
        for (let _e = 0, nt = 0, it = c.count; _e < it; _e++,
        nt += 2)
            _start.fromBufferAttribute(c, _e),
            _end.fromBufferAttribute(h, _e),
            _[nt] = nt === 0 ? 0 : _[nt - 1],
            _[nt + 1] = _[nt] + _start.distanceTo(_end);
        const b = new three_module.LuO(_,2,1);
        return o.setAttribute("instanceDistanceStart", new three_module.eHs(b,1,0)),
        o.setAttribute("instanceDistanceEnd", new three_module.eHs(b,1,1)),
        this
    }
}
class SelectionWidget extends three_module.YJl {
    _updater() {
        const o = this._object;
        if (o) {
            const c = new Box3B().expandByObject(o, !1);
            c.getCenter(this.position);
            const h = c.getBoundingSphere(new three_module.iyt).radius;
            this.scale.setScalar(h * this.boundingScaleMultiplier),
            this.setVisible(!0)
        } else
            this.setVisible(!1)
    }
    constructor() {
        super(),
        this.assetType = "widget",
        this.modelObject = this,
        this._object = null,
        this.boundingScaleMultiplier = 1,
        this.position.set(0, 0, 0),
        this.visible = !1,
        this.renderOrder = 1,
        this.userData.bboxVisible = !1,
        this._updater = this._updater.bind(this)
    }
    _initGeometry(o) {
        if (this._geometry)
            return;
        const c = new WireframeGeometry2(o);
        this._geometry = c;
        const h = new LineMaterial({
            color: "#ff2222",
            transparent: !0,
            opacity: .9,
            linewidth: 5,
            resolution: new three_module.I9Y(1024,1024),
            dashed: !1,
            toneMapped: !1
        })
          , _ = new Wireframe(c,h);
        _.computeLineDistances(),
        _.scale.set(1, 1, 1),
        _.visible = !0,
        this.add(_)
    }
    setVisible(o) {
        var c;
        o !== this.visible && (this.visible = o,
        (c = this.setDirty) === null || c === void 0 || c.call(this, {
            sceneUpdate: !1
        }))
    }
    attach(o) {
        return this.detach(),
        o ? (this._object = o,
        this._object.addEventListener("objectUpdate", this._updater),
        this._updater(),
        this) : this
    }
    detach() {
        var o;
        return this._object ? ((o = this._object) === null || o === void 0 || o.removeEventListener("objectUpdate", this._updater),
        this._object = null,
        this._updater(),
        this) : this
    }
    get object() {
        return this._object
    }
}
class BoxSelectionWidget extends SelectionWidget {
    constructor() {
        super(),
        this.boundingScaleMultiplier = 1 / 1.7,
        this._initGeometry(new three_module.iNn(2,2,2,1,1,1))
    }
    _updater() {
        super._updater();
        const o = this.object;
        o && (new Box3B().expandByObject(o, !1).getSize(this.scale).multiplyScalar(this.boundingScaleMultiplier).clampScalar(.1, 100),
        this.setVisible(!0))
    }
}
var PickingPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class PickingPlugin extends AViewerPlugin {
    get widgetEnabled() {
        return this._enableWidget
    }
    get picker() {
        return this._picker
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    constructor(o=BoxSelectionWidget, c=!1, h=!0, _=!1) {
        super(),
        this.enabled = !0,
        this._enableWidget = !0,
        this.autoFocus = !1,
        this._onObjectHit = b => {
            this._viewer && (this.enabled ? this.dispatchEvent(b) : b.intersects.selectedObject = null)
        }
        ,
        this._uiConfigChildren = [{
            label: "Enabled",
            type: "checkbox",
            property: [this, "enabled"]
        }, {
            label: "AutoFocus",
            type: "checkbox",
            property: [this, "autoFocus"],
            onChange: () => {
                const b = this.getSelectedObject();
                this.autoFocus && b && this.setSelectedObject(b, !0)
            }
        }],
        o && (this._widget = new o),
        c && console.error("PickingPlugin - controls removed. Use the new TransformControlsPlugin"),
        this._pickUi = h,
        this.autoFocus = _
    }
    getSelectedObject() {
        var o;
        if (this.enabled)
            return ((o = this._picker) === null || o === void 0 ? void 0 : o.selectedObject) || void 0
    }
    setSelectedObject(o, c=!1) {
        if (!this.enabled || !this._picker)
            return;
        const h = this.autoFocus;
        this.autoFocus = !1,
        this._picker.selectedObject = o || null,
        this.autoFocus = h,
        (h || c) && this.focusObject(o)
    }
    async onAdded(o) {
        await super.onAdded(o),
        this._picker = new ObjectPicker(o.scene,o.canvas,void 0,c => {
            var h, _;
            if (!c.material)
                return !1;
            let b = c
              , _e = !1;
            for (; b; ) {
                if (!b.visible || (((h = b.userData.iModel) !== null && h !== void 0 ? h : b).assetType === "model" && (_e = !0),
                ((_ = b.userData.iModel) !== null && _ !== void 0 ? _ : b).assetType === "widget") || b.userData.userSelectable === !1 || b.userData.bboxVisible === !1)
                    return !1;
                b = b.parent
            }
            return _e
        }
        ),
        this._widget && o.scene.addWidget(this._widget),
        this._picker.addEventListener("selectedObjectChanged", c => {
            var h, _;
            this.dispatchEvent(c);
            const b = ((h = this._picker) === null || h === void 0 ? void 0 : h.selectedObject) || void 0;
            if (this._pickUi) {
                const nt = b == null ? void 0 : b.uiConfig
                  , it = this.uiConfig;
                it.children = [...this._uiConfigChildren],
                nt && it.children.push(nt),
                (_ = it.uiRefresh) === null || _ === void 0 || _.call(it)
            }
            const _e = this._widget;
            _e && this._enableWidget && (b ? _e.attach(b) : _e.detach()),
            o.setDirty(),
            this.autoFocus && this.focusObject(b)
        }
        ),
        this._picker.addEventListener("hoverObjectChanged", this.dispatchEvent),
        this._picker.addEventListener("hitObject", this._onObjectHit),
        o.scene.addEventListener("select", c => {
            c.value === void 0 ? console.warn("WebGi: e.value must be set for picking, can be null to unselect") : c.value.isObject3D && this.setSelectedObject(c.value, this.autoFocus || c.focusCamera)
        }
        ),
        o.scene.addEventListener("addSceneObject", async c => {
            var h, _, b;
            const _e = c.object
              , nt = this.getSelectedObject();
            if (nt && (_e == null ? void 0 : _e.assetType) === "material" && typeof (nt == null ? void 0 : nt.setMaterial) == "function" && (!((h = nt == null ? void 0 : nt.modelObject) === null || h === void 0) && h.isMesh) && await o.confirm("Applying material: Apply material to the selected object?")) {
                const it = nt.material;
                if (Array.isArray(it))
                    console.warn("WebGi: Dropping on material array not yet fully supported."),
                    nt.setMaterial(_e);
                else {
                    let at = Array.from((_ = it == null ? void 0 : it.userData.__appliedMeshes) !== null && _ !== void 0 ? _ : []);
                    (at.length > 1 ? !await o.confirm("Applying material: Apply to all objects using this material?") : at.length < 1) && (at = [nt]);
                    for (const ut of at)
                        ut && ((b = ut.setMaterial) === null || b === void 0 || b.call(ut, _e))
                }
            }
        }
        ),
        o.scene.addEventListener("sceneUpdate", c => {
            if (!c.hierarchyChanged)
                return;
            const h = this.getSelectedObject();
            let _ = !1;
            h == null || h.traverseAncestors(b => {
                b === o.scene.modelObject && (_ = !0)
            }
            ),
            _ || this.setSelectedObject(void 0)
        }
        )
    }
    async focusObject(o) {
        var c, h, _, b;
        const _e = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("CameraViews");
        await (_e == null ? void 0 : _e.animateToFitObject(o, 1.25, 1e3, "easeOut", {
            min: ((b = (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.scene.activeCamera.getControls()) === null || _ === void 0 ? void 0 : _.minDistance) !== null && b !== void 0 ? b : .5) + .5,
            max: 50
        }))
    }
    enableWidget(o) {
        var c, h, _;
        if (this._enableWidget = o,
        o) {
            const b = ((c = this._picker) === null || c === void 0 ? void 0 : c.selectedObject) || void 0;
            b && ((h = this._widget) === null || h === void 0 || h.attach(b))
        } else
            (_ = this._widget) === null || _ === void 0 || _.detach()
    }
    get uiConfig() {
        return this._pickUi ? this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "panel",
            label: "Picker",
            expanded: !0,
            children: [...this._uiConfigChildren]
        } : {}
    }
    get widget() {
        return this._widget
    }
}
PickingPlugin.PluginType = "Picking",
PickingPlugin_decorate([serialize()], PickingPlugin.prototype, "enabled", void 0),
PickingPlugin_decorate([serialize()], PickingPlugin.prototype, "autoFocus", void 0);
var customBumpMat = `#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
#if CUSTOM_BUMP_MAP_BICUBIC > 0  
vec4 cubic_cb(float v){vec4 n=vec4(1.,2.,3.,4.)-v;vec4 s=n*n*n;float x=s.x;float y=s.y-4.*s.x;float z=s.z-4.*s.y+6.*s.x;float w=6.-x-y-z;return vec4(x,y,z,w)*(1./6.);}vec4 textureBicubic_cb(sampler2D sampler,vec2 texCoords){vec2 texSize=vec2(textureSize(sampler,0));vec2 invTexSize=1./texSize;texCoords=texCoords*texSize-0.5;vec2 fxy=fract(texCoords);texCoords-=fxy;vec4 xcubic=cubic_cb(fxy.x);vec4 ycubic=cubic_cb(fxy.y);vec4 c=texCoords.xxyy+vec2(-0.5,+1.5).xyxy;vec4 s=vec4(xcubic.xz+xcubic.yw,ycubic.xz+ycubic.yw);vec4 offset=c+vec4(xcubic.yw,ycubic.yw)/s;offset*=invTexSize.xxyy;vec4 sample0=texture(sampler,offset.xz);vec4 sample1=texture(sampler,offset.yz);vec4 sample2=texture(sampler,offset.xw);vec4 sample3=texture(sampler,offset.yw);float sx=s.x/(s.x+s.y);float sy=s.z/(s.z+s.w);return mix(mix(sample3,sample2,sx),mix(sample1,sample0,sx),sy);}
#endif
varying vec2 vCustomBumpUv;uniform sampler2D customBumpMap;uniform float customBumpScale;vec2 dHdxy_fwd_cb(){vec2 dSTdx=dFdx(vCustomBumpUv);vec2 dSTdy=dFdy(vCustomBumpUv);
#if CUSTOM_BUMP_MAP_BICUBIC > 0
float Hll=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*textureBicubic_cb(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;
#else
float Hll=customBumpScale*texture2D(customBumpMap,vCustomBumpUv).x;float dBx=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdx).x-Hll;float dBy=customBumpScale*texture2D(customBumpMap,vCustomBumpUv+dSTdy).x-Hll;
#endif
return vec2(dBx,dBy);}
#ifndef USE_BUMPMAP
vec3 perturbNormalArb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}
#endif
#endif
`
  , CustomBumpMapPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let CustomBumpMapPlugin = class extends AViewerPlugin {
    enableCustomBump(d, o, c) {
        var h, _;
        const b = (h = d.materialObject) === null || h === void 0 ? void 0 : h.userData;
        if (!b)
            return !1;
        if (b._hasCustomBump === void 0) {
            const _e = b.__appliedMeshes;
            let nt = !0;
            if (_e)
                for (const {geometry: it} of _e)
                    !it || it.attributes.position && it.attributes.normal && it.attributes.uv || (nt = !1);
            if (!nt)
                return !1
        }
        return b._hasCustomBump = !0,
        b._customBumpScale = (_ = c ?? b._customBumpScale) !== null && _ !== void 0 ? _ : .001,
        b._customBumpMap = o ?? b._customBumpMap,
        d.materialObject.needsUpdate = !0,
        !0
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsCustomBumpMapExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this.bicubicFiltering = !0,
        this._defines = {
            CUSTOM_BUMP_MAP_DEBUG: !1,
            CUSTOM_BUMP_MAP_BICUBIC: !0
        },
        this._uniforms = {
            customBumpUvTransform: {
                value: new three_module.dwI
            },
            customBumpScale: {
                value: .001
            },
            customBumpMap: {
                value: null
            }
        },
        this.materialExtension = {
            parsFragmentSnippet: (d, o) => this.enabled && (o != null && o.materialObject.userData._hasCustomBump) ? customBumpMat : "",
            shaderExtender: (d, o, c) => {
                var h;
                this.enabled && o.materialObject.userData._hasCustomBump && (!((h = o.materialObject.userData) === null || h === void 0) && h._customBumpMap) && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker beforeAccumulation", `
#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
    normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd_cb(), faceDirection );
#endif
                `, {
                    prepend: !0
                }),
                d.vertexShader = shaderReplaceString(d.vertexShader, "#include <uv_pars_vertex>", `
#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
                varying vec2 vCustomBumpUv;
                uniform mat3 customBumpUvTransform;
#endif
                `, {
                    prepend: !0
                }),
                d.vertexShader = shaderReplaceString(d.vertexShader, "#include <uv_vertex>", `
#if defined(CUSTOM_BUMP_MAP_ENABLED) && CUSTOM_BUMP_MAP_ENABLED > 0
                vCustomBumpUv = ( customBumpUvTransform * vec3( uv, 1 ) ).xy;
#endif
                `, {
                    prepend: !0
                }),
                d.defines.USE_UV = "")
            }
            ,
            onObjectRender: (d, o) => {
                var c;
                const h = o.materialObject.userData;
                if (!(h != null && h._hasCustomBump))
                    return;
                const _ = d;
                if (!_.isMesh || !_.geometry)
                    return;
                const b = !((c = h._customBumpMap) === null || c === void 0) && c.isTexture ? h._customBumpMap : null;
                this._uniforms.customBumpMap.value = b,
                this._uniforms.customBumpScale.value = b ? h._customBumpScale : 0,
                b && (b.updateMatrix(),
                this._uniforms.customBumpUvTransform.value.copy(b.matrix));
                let _e = this.enabled && b ? 1 : 0;
                o.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED !== _e && (o.materialObject.defines.CUSTOM_BUMP_MAP_ENABLED = _e,
                o.materialObject.needsUpdate = !0),
                _e = +this._defines.CUSTOM_BUMP_MAP_DEBUG,
                o.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG !== _e && (o.materialObject.defines.CUSTOM_BUMP_MAP_DEBUG = _e,
                o.materialObject.needsUpdate = !0),
                _e = +this._defines.CUSTOM_BUMP_MAP_BICUBIC,
                o.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC !== _e && (o.materialObject.defines.CUSTOM_BUMP_MAP_BICUBIC = _e,
                o.materialObject.needsUpdate = !0)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c, h;
                return (this.enabled ? "1" : "0") + (!((o = d.materialObject.userData) === null || o === void 0) && o._hasCustomBump ? "1" : "0") + ((h = (c = d.materialObject.userData) === null || c === void 0 ? void 0 : c._customBumpMap) === null || h === void 0 ? void 0 : h.uuid)
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2,
            updaters: () => [],
            getUiConfig: d => {
                const o = this._viewer
                  , c = this.enableCustomBump
                  , h = {
                    type: "folder",
                    label: "CustomBumpMap",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            return d.materialObject.userData._hasCustomBump || !1
                        },
                        set value(_) {
                            var b;
                            _ !== d.materialObject.userData._hasCustomBump && (_ ? c(d) || o.alert("One or more geometries cannot be made anisotropic.") : (d.materialObject.userData._hasCustomBump = !1,
                            d.materialObject.needsUpdate = !0),
                            (b = h.uiRefresh) === null || b === void 0 || b.call(h, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, {
                        type: "slider",
                        label: "Bump Scale",
                        bounds: [-1, 1],
                        hidden: () => !d.materialObject.userData._hasCustomBump,
                        property: [d.materialObject.userData, "_customBumpScale"],
                        onChange: this.setDirty
                    }, {
                        type: "image",
                        label: "Bump Map",
                        hidden: () => !d.materialObject.userData._hasCustomBump,
                        property: [d.materialObject.userData, "_customBumpMap"],
                        onChange: () => {
                            d.materialObject.needsUpdate = !0,
                            this.setDirty()
                        }
                    }, makeSamplerUi(d.materialObject.userData, "_customBumpMap")]
                };
                return h
            }
        },
        this.setDirty = () => {
            var d, o, c;
            (o = (d = this.materialExtension).setDirty) === null || o === void 0 || o.call(d),
            (c = this._viewer) === null || c === void 0 || c.setDirty()
        }
        ,
        this.enableCustomBumpSelected = () => {
            var d, o, c;
            const h = (c = (o = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPlugin(PickingPlugin)) === null || o === void 0 ? void 0 : o.getSelectedObject()) === null || c === void 0 ? void 0 : c.material;
            return (h == null ? void 0 : h.assetType) === "material" && this.enableCustomBump(h)
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsCustomBumpMapExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _, b, _e, nt, it, at, ut, pt, ht;
        (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate);
        const _t = (it = (nt = (_e = (b = d.getPlugin(AssetManagerPlugin)) === null || b === void 0 ? void 0 : b.exporter) === null || _e === void 0 ? void 0 : _e.getExporter("gltf", "glb")) === null || nt === void 0 ? void 0 : nt.extensions) === null || it === void 0 ? void 0 : it.indexOf(glTFMaterialsCustomBumpMapExtensionExport);
        return _t !== void 0 && _t !== -1 && ((ht = (pt = (ut = (at = d.getPlugin(AssetManagerPlugin)) === null || at === void 0 ? void 0 : at.exporter) === null || ut === void 0 ? void 0 : ut.getExporter("gltf", "glb")) === null || pt === void 0 ? void 0 : pt.extensions) === null || ht === void 0 || ht.splice(_t, 1)),
        super.onRemove(d)
    }
}
;
CustomBumpMapPlugin.PluginType = "CustomBumpMapPlugin",
CustomBumpMapPlugin.CUSTOM_BUMP_MAP_GLTF_EXTENSION = "WEBGI_materials_custom_bump_map",
CustomBumpMapPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], CustomBumpMapPlugin.prototype, "enabled", void 0),
CustomBumpMapPlugin_decorate([uiToggle("Bicubic", d => ({
    onChange: d.setDirty
})), matDefine("CUSTOM_BUMP_MAP_BICUBIC", void 0, !0, CustomBumpMapPlugin.prototype.setDirty), serialize()], CustomBumpMapPlugin.prototype, "bicubicFiltering", void 0),
CustomBumpMapPlugin_decorate([uiButton("Enable CustomBumpMap", d => ({
    hidden: () => {
        var o;
        return !(!((o = d._viewer) === null || o === void 0) && o.getPlugin(PickingPlugin))
    }
}))], CustomBumpMapPlugin.prototype, "enableCustomBumpSelected", void 0),
CustomBumpMapPlugin = CustomBumpMapPlugin_decorate([uiFolder("CustomBumpMap Materials")], CustomBumpMapPlugin);
class GLTFMaterialsCustomBumpMapExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = CustomBumpMapPlugin.CUSTOM_BUMP_MAP_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        var h;
        const _ = this.parser
          , b = _.json.materials[o];
        if (!b.extensions || !b.extensions[this.name])
            return Promise.resolve();
        const _e = []
          , nt = b.extensions[this.name];
        c.userData || (c.userData = {}),
        c.userData._hasCustomBump = !0,
        c.userData._customBumpScale = (h = nt.customBumpScale) !== null && h !== void 0 ? h : 0;
        const it = nt.customBumpMap;
        return it && _e.push(_.assignTexture(c.userData, "_customBumpMap", it).then(at => {
            at.colorSpace = three_module.er$
        }
        )),
        Promise.all(_e)
    }
}
const glTFMaterialsCustomBumpMapExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._hasCustomBump || (o.userData._customBumpScale || 0) < .001)
            return;
        c.extensions = c.extensions || {};
        const h = {};
        if (h.customBumpScale = o.userData._customBumpScale || 1,
        d.checkEmptyMap(o.userData._customBumpMap)) {
            const _ = {
                index: d.processTexture(o.userData._customBumpMap)
            };
            d.applyTextureTransform(_, o.userData._customBumpMap),
            h.customBumpMap = _
        }
        c.extensions[CustomBumpMapPlugin.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = h,
        d.extensionsUsed[CustomBumpMapPlugin.CUSTOM_BUMP_MAP_GLTF_EXTENSION] = !0
    }
});
var GLTFAnimationPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, GLTFAnimationPlugin_1;
let GLTFAnimationPlugin = GLTFAnimationPlugin_1 = class extends AViewerPlugin {
    get animationState() {
        return this._animationState
    }
    get animationTime() {
        return this._animationTime
    }
    get animationDuration() {
        return this._animationDuration
    }
    setTime(d) {
        this._animationTime = Math.max(0, Math.min(d, this._animationDuration))
    }
    _wheel({deltaY: d}) {
        this.enabled && Math.abs(d) > .001 && (this._scrollAnimationState = -1 * Math.sign(d))
    }
    _drag(d) {
        this.enabled && this._viewer && (this.dragAxis === "x" ? this._dragAnimationState = d.delta.x * this._viewer.canvas.width / 4 : this._dragAnimationState = d.delta.y * this._viewer.canvas.height / 4)
    }
    _postFrame() {
        var d, o;
        if (!this._viewer)
            return;
        const c = this._viewer
          , h = this.animateOnScroll
          , _ = this.animateOnDrag;
        if (!this.enabled || this.animations.length < 1 || this._animationState !== "playing" && !h && !_)
            return this._lastFrameTime = 0,
            void (this._fadeDisabled && ((d = this._viewer.getPluginByType("FrameFade")) === null || d === void 0 || d.enable(GLTFAnimationPlugin_1.PluginType),
            this._fadeDisabled = !1));
        if (this._animationTime < 1e-4 && this.dispatchEvent({
            type: "checkpointBegin"
        }),
        this.autoIncrementTime) {
            const nt = g() / 1e3;
            this._lastFrameTime < 1 && (this._lastFrameTime = nt - 1 / 30);
            let it = nt - this._lastFrameTime;
            if (it *= this.animationSpeed,
            this._lastFrameTime = nt,
            h && _ ? it *= et(this._scrollAnimationState, this._dragAnimationState) : h ? it *= this._scrollAnimationState : _ && (it *= this._dragAnimationState),
            Math.abs(it) < 1e-4)
                return;
            const at = (o = this._viewer.getPluginByType("Progressive")) === null || o === void 0 ? void 0 : o.postFrameConvergedRecordingDelta();
            if (at && at > 0 && (it = at),
            at === 0)
                return;
            const ut = Math.abs(this.timeScale);
            this._animationTime += it * (ut > 0 ? ut : 1)
        }
        const b = this._animationTime - this._lastAnimationTime;
        this._lastAnimationTime = this._animationTime;
        const _e = this.timeScale < 0 ? (isFinite(this._animationDuration) ? this._animationDuration : 0) - this._animationTime : this._animationTime;
        if (this.animations.map(nt => {
            nt.mixer.setTime(_e)
        }
        ),
        !(Math.abs(b) < 1e-5)) {
            if (Math.abs(this._scrollAnimationState) < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping,
            Math.abs(this._dragAnimationState) < .001 ? this._dragAnimationState = 0 : this._dragAnimationState *= 1 - this.dragAnimationDamping,
            this.dispatchEvent({
                type: "animationStep",
                delta: b,
                time: _e
            }),
            c.scene.activeCamera.cameraObject.userData.__animatingCamera && c.scene.activeCamera.setDirty(),
            c.scene.refreshActiveCameraNearFar(),
            c.renderer.resetShadows(),
            c.setDirty(),
            !this._fadeDisabled) {
                const nt = this._viewer.getPluginByType("FrameFade");
                nt && (nt.disable(GLTFAnimationPlugin_1.PluginType),
                this._fadeDisabled = !0)
            }
            this._animationTime >= this._animationDuration && this.dispatchEvent({
                type: "checkpointEnd"
            })
        }
    }
    constructor() {
        super(),
        this.enabled = !0,
        this._lastAnimationTime = 0,
        this.autoIncrementTime = !0,
        this.animations = [],
        this.loopAnimations = !0,
        this.loopRepetitions = 1 / 0,
        this.timeScale = 1,
        this.animationSpeed = 1,
        this.animateOnScroll = !1,
        this._scrollAnimationState = 0,
        this.scrollAnimationDamping = .1,
        this.animateOnDrag = !1,
        this.dragAxis = "y",
        this.autoplayOnLoad = !1,
        this.syncMaxDuration = !1,
        this._dragAnimationState = 0,
        this.dragAnimationDamping = .3,
        this.dependencies = [AssetManagerPlugin],
        this._pointerDragHelper = new Z$1,
        this._lastFrameTime = 0,
        this._fadeDisabled = !1,
        this._objectAdded = d => {
            var o;
            const c = d.object;
            if (c.assetType !== "model" || !c.modelObject || !this._viewer)
                return;
            let h = !1;
            const _ = (o = d.options) === null || o === void 0 ? void 0 : o.addToRoot;
            c.modelObject.traverse(b => {
                var _e;
                const nt = b.animations;
                if (nt.length < 1)
                    return;
                const it = Math.max(...nt.map(pt => pt.duration));
                ((_e = c.modelObject.userData.gltfAnim_SyncMaxDuration) !== null && _e !== void 0 ? _e : this.syncMaxDuration) && (nt.forEach(pt => pt.duration = it),
                c.modelObject.userData.gltfAnim_SyncMaxDuration = !0);
                const at = new three_module.Iw4(_ ? this._viewer.scene.modelObject : this._viewer.scene.modelRoot.modelObject)
                  , ut = nt.map(pt => at.clipAction(pt).setLoop(this.loopAnimations ? three_module.aMy : three_module.G3T, this.loopRepetitions));
                ut.forEach(pt => pt.clampWhenFinished = !0),
                this.animations.push({
                    mixer: at,
                    clips: nt,
                    actions: ut,
                    duration: it
                }),
                h = !0
            }
            ),
            h && (this._onPropertyChange(!this.autoplayOnLoad),
            this.autoplayOnLoad && this.playAnimation())
        }
        ,
        this._animationTime = 0,
        this._animationDuration = 0,
        this._animationState = "none",
        this.uiConfig = void 0,
        this._lastAnimId = "",
        this.timelineMarkers = [],
        this._postFrame = this._postFrame.bind(this),
        this._wheel = this._wheel.bind(this),
        this.playClips = this.playClips.bind(this),
        this.playClip = this.playClip.bind(this),
        this.playAnimation = this.playAnimation.bind(this),
        this.playPauseAnimation = this.playPauseAnimation.bind(this),
        this.pauseAnimation = this.pauseAnimation.bind(this),
        this.stopAnimation = this.stopAnimation.bind(this),
        this.resetAnimation = this.resetAnimation.bind(this),
        this._onPropertyChange = this._onPropertyChange.bind(this),
        this._loaderCreate = this._loaderCreate.bind(this),
        this._pointerDragHelper.addEventListener("drag", this._drag.bind(this))
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFTimelineMarkersExtensionImport(o,this))
    }
    async onAdded(d) {
        var o, c, h, _, b, _e;
        (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        d.scene.addEventListener("addSceneObject", this._objectAdded),
        (_e = (b = (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.exporter) === null || _ === void 0 ? void 0 : _.getExporter("gltf", "glb")) === null || b === void 0 ? void 0 : b.extensions) === null || _e === void 0 || _e.push(glTFTimelineMarkersExtensionExport),
        d.addEventListener("postFrame", this._postFrame),
        window.addEventListener("wheel", this._wheel),
        this._pointerDragHelper.element = d.canvas;
        let nt = -1;
        return Object.defineProperty(d.scene.modelRoot, "currentTimelineMarker", {
            get: () => nt,
            set: it => d.scene.modelRoot.dispatchEvent({
                type: "animationTimelineMarker",
                marker: this.timelineMarkers[nt = it]
            })
        }),
        d.scene.modelRoot.addEventListener("animationTimelineMarker", ({marker: it}) => {
            var at;
            if (!this._viewer)
                return;
            if (!it)
                return this._viewer.scene.activeCamera = (at = this._viewer) === null || at === void 0 ? void 0 : at.scene.defaultCamera,
                void this._viewer.setDirty();
            const ut = it.camera;
            ut && (ut.userData.__animatingCamera = !0,
            this._viewer.scene.activeCamera = this._viewer.createCamera(ut))
        }
        ),
        super.onAdded(d)
    }
    async onRemove(d) {
        for (var o, c; this.animations.length; )
            this.animations.pop();
        return d.scene.removeEventListener("addSceneObject", this._objectAdded),
        (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        d.removeEventListener("postFrame", this._postFrame),
        window.removeEventListener("wheel", this._wheel),
        this._pointerDragHelper.element = void 0,
        super.onRemove(d)
    }
    _onPropertyChange(d=!0) {
        this._animationDuration = Math.max(...this.animations.map( ({duration: o}) => o)) * (this.loopAnimations ? this.loopRepetitions : 1),
        this._animationState === "playing" && d && this.playAnimation()
    }
    onStateChange() {
        var d, o;
        (o = (d = this.uiConfig) === null || d === void 0 ? void 0 : d.children) === null || o === void 0 || o.map(c => c && Ee$1(c)).flat(2).forEach(c => {
            var h;
            return (h = c == null ? void 0 : c.uiRefresh) === null || h === void 0 ? void 0 : h.call(c)
        }
        )
    }
    playPauseAnimation() {
        this._animationState === "playing" ? this.pauseAnimation() : this.playAnimation()
    }
    async playClip(d, o=!1) {
        return this.playClips([d], o)
    }
    async playClips(d, o=!1) {
        const c = [];
        return this.animations.forEach( ({actions: h}) => {
            h.forEach(_ => {
                d.includes(_.getClip().name) && c.push(_)
            }
            )
        }
        ),
        this.playAnimation(o, c)
    }
    async playAnimation(d=!1, o) {
        var c;
        if (!this.enabled)
            return;
        let h = !1;
        this._animationState === "playing" && (this.stopAnimation(!1),
        h = !0);
        let _ = 0;
        const b = !o;
        o || (o = [],
        this.animations.forEach( ({mixer: nt, actions: it, clips: at}) => {
            o.push(...it)
        }
        )),
        h ? this.resetAnimation() : this.animationState !== "paused" && (o.forEach(nt => {
            nt.reset()
        }
        ),
        this._animationTime = 0);
        const _e = esm_browser_v4();
        this._lastAnimId = _e;
        for (const nt of o)
            nt.setLoop(this.loopAnimations ? three_module.aMy : three_module.G3T, this.loopRepetitions),
            nt.play(),
            _ = Math.max(_, nt.getClip().duration / Math.abs(nt.timeScale));
        if (this._animationState = "playing",
        (c = this._viewer) === null || c === void 0 || c.setDirty(),
        b) {
            if (!isFinite(this._animationDuration))
                return;
            await new Promise( (nt, it) => {
                const at = () => {
                    this.removeEventListener("checkpointEnd", at),
                    nt()
                }
                ;
                this.addEventListener("checkpointEnd", at)
            }
            )
        } else {
            const nt = this.loopAnimations ? this.loopRepetitions : 1;
            if (_ *= nt,
            !isFinite(_))
                return;
            await new Promise( (it, at) => {
                const ut = pt => {
                    pt.time >= _ && (this.removeEventListener("animationStep", ut),
                    it())
                }
                ;
                this.addEventListener("animationStep", ut)
            }
            )
        }
        _e === this._lastAnimId && this.stopAnimation(d)
    }
    pauseAnimation() {
        var d;
        this._animationState === "playing" ? (this._animationState = "paused",
        (d = this._viewer) === null || d === void 0 || d.setDirty()) : console.warn("pauseAnimation called when animation was not playing.")
    }
    resumeAnimation() {
        var d;
        this._animationState === "paused" ? (this._animationState = "playing",
        (d = this._viewer) === null || d === void 0 || d.setDirty()) : console.warn("resumeAnimation called when animation was not paused.")
    }
    stopAnimation(d=!1) {
        var o, c;
        this._animationState = "stopped",
        d ? this.resetAnimation() : (o = this._viewer) === null || o === void 0 || o.setDirty(),
        this._lastAnimId = "",
        this._viewer && this._fadeDisabled && ((c = this._viewer.getPluginByType("FrameFade")) === null || c === void 0 || c.enable(GLTFAnimationPlugin_1.PluginType),
        this._fadeDisabled = !1)
    }
    resetAnimation() {
        var d;
        this._animationState === "stopped" || this._animationState === "none" ? (this.animations.forEach( ({mixer: o, actions: c, clips: h}) => {
            o.stopAllAction(),
            o.setTime(0)
        }
        ),
        this._animationTime = 0,
        (d = this._viewer) === null || d === void 0 || d.setDirty()) : this.stopAnimation(!0)
    }
}
;
GLTFAnimationPlugin.PluginType = "GLTFAnimation",
GLTFAnimationPlugin.AnimationMarkersExtension = "WEBGI_animation_markers",
GLTFAnimationPlugin_decorate([serialize()], GLTFAnimationPlugin.prototype, "autoIncrementTime", void 0),
GLTFAnimationPlugin_decorate([uiMonitor()], GLTFAnimationPlugin.prototype, "animationState", null),
GLTFAnimationPlugin_decorate([uiMonitor()], GLTFAnimationPlugin.prototype, "animationTime", null),
GLTFAnimationPlugin_decorate([uiMonitor()], GLTFAnimationPlugin.prototype, "animationDuration", null),
GLTFAnimationPlugin_decorate([ze$1(GLTFAnimationPlugin.prototype._onPropertyChange), uiToggle("Loop", {
    limitedUi: !0
}), serialize()], GLTFAnimationPlugin.prototype, "loopAnimations", void 0),
GLTFAnimationPlugin_decorate([ze$1(GLTFAnimationPlugin.prototype._onPropertyChange), serialize()], GLTFAnimationPlugin.prototype, "loopRepetitions", void 0),
GLTFAnimationPlugin_decorate([uiSlider("Timescale", [-2, 2], .01), serialize()], GLTFAnimationPlugin.prototype, "timeScale", void 0),
GLTFAnimationPlugin_decorate([uiSlider("Speed", [.1, 4], .1, {
    limitedUi: !0
}), serialize()], GLTFAnimationPlugin.prototype, "animationSpeed", void 0),
GLTFAnimationPlugin_decorate([uiToggle(), serialize()], GLTFAnimationPlugin.prototype, "animateOnScroll", void 0),
GLTFAnimationPlugin_decorate([uiToggle(), serialize()], GLTFAnimationPlugin.prototype, "animateOnDrag", void 0),
GLTFAnimationPlugin_decorate([uiDropdown("Drag Axis", [{
    label: "x"
}, {
    label: "y"
}]), serialize()], GLTFAnimationPlugin.prototype, "dragAxis", void 0),
GLTFAnimationPlugin_decorate([uiToggle(), serialize()], GLTFAnimationPlugin.prototype, "autoplayOnLoad", void 0),
GLTFAnimationPlugin_decorate([uiToggle("syncMaxDuration(dev)"), serialize()], GLTFAnimationPlugin.prototype, "syncMaxDuration", void 0),
GLTFAnimationPlugin_decorate([x$1(GLTFAnimationPlugin.prototype.onStateChange)], GLTFAnimationPlugin.prototype, "_animationState", void 0),
GLTFAnimationPlugin_decorate([uiButton("Play/Pause", d => ({
    label: () => d.animationState === "playing" ? "Pause" : "Play",
    limitedUi: !0
}))], GLTFAnimationPlugin.prototype, "playPauseAnimation", null),
GLTFAnimationPlugin_decorate([uiButton("Stop", {
    limitedUi: !0
})], GLTFAnimationPlugin.prototype, "stopAnimation", null),
GLTFAnimationPlugin_decorate([uiButton("Reset", {
    limitedUi: !0
})], GLTFAnimationPlugin.prototype, "resetAnimation", null),
GLTFAnimationPlugin = GLTFAnimationPlugin_1 = GLTFAnimationPlugin_decorate([uiFolder("GLTF Animations")], GLTFAnimationPlugin);
class GLTFTimelineMarkersExtensionImport {
    constructor(o, c) {
        this.parser = o,
        this.name = GLTFAnimationPlugin.AnimationMarkersExtension,
        this.plugin = c
    }
    async afterRoot(o) {
        var c;
        let h = [];
        for (const ht of this.parser.json.scenes || []) {
            if (!ht.extensions)
                continue;
            const _t = ht.extensions[this.name];
            for (const vt of (_t == null ? void 0 : _t.markers) || []) {
                const bt = vt.camera !== void 0 ? await this.parser.getDependency("camera", vt.camera) : void 0;
                vt.time === void 0 && (vt.time = vt.frame / 30,
                console.error("Update timeline markers plugin for correct times.")),
                h.push({
                    name: vt.name,
                    frame: vt.frame,
                    time: vt.time,
                    camera: bt
                })
            }
        }
        if (h.length < 1)
            return;
        h = h.sort( (ht, _t) => ht.frame - _t.frame);
        const _ = (c = o.scene) !== null && c !== void 0 ? c : o.scenes[0];
        if (!_)
            return;
        _.userData.__markers = h;
        const b = this.plugin.timelineMarkers
          , _e = h.map(ht => ht.time);
        let nt = b.length;
        const it = h.map(ht => nt++)
          , at = Math.max(..._e) + .01;
        b.push(...h);
        const ut = new three_module.Hit(".currentTimelineMarker",_e,it,three_module.ljd)
          , pt = new three_module.tz3("animationTimelineMarker",at,[ut]);
        pt.__gltfExport = !1,
        o.animations.push(pt)
    }
}
const glTFTimelineMarkersExtensionExport = d => ({
    afterParse(o) {
        const c = d.json.scenes[d.json.scene || 0];
        c.extensions = c.extensions || {};
        const h = {
            markers: []
        }
          , _ = [];
        if ((Array.isArray(o) ? o : [o]).forEach(b => b.traverse(_e => {
            _e.userData.__markers && _.push(..._e.userData.__markers)
        }
        )),
        _.sort( (b, _e) => b.frame - _e.frame),
        !(_.length < 1)) {
            for (const b of _) {
                const _e = b.camera;
                if (_e) {
                    const nt = d.nodeMap.get(_e);
                    if (nt === void 0) {
                        console.warn("Camera not found in gltf export", _e, d.nodeMap);
                        continue
                    }
                    const it = d.json.nodes[nt].camera;
                    b.camera = it,
                    h.markers.push(b)
                }
            }
            c.extensions[GLTFAnimationPlugin.AnimationMarkersExtension] = h,
            d.extensionsUsed[GLTFAnimationPlugin.AnimationMarkersExtension] = !0
        }
    }
});
var giPatch = `#if defined(SSRTAO_ENABLED) && SSRTAO_ENABLED > 0
vec4 ssgi=tSSGIMapTexelToLinear(texture2D(tSSGIMap,viewToScreen(vViewPosition.xyz).xy));float ambientOcclusion=1.-ssgi.a;ambientOcclusion=max(0.,ambientOcclusion);ambientOcclusion=pow(ambientOcclusion,ssaoPower);ambientOcclusion=min(1.,ambientOcclusion);reflectedLight.indirectDiffuse*=ambientOcclusion;
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
vec3 ssgiColor=ssgi.rgb*ssgiIntensity;reflectedLight.indirectDiffuse+=ssgiColor*(material.diffuseColor.rgb);
#endif
#if defined( USE_ENVMAP )
float dotNV=saturate(dot(geometryNormal,geometryViewDir));float specularOcclusion=saturate(pow(dotNV+ambientOcclusion,exp2(-16.*material.roughness-1.))-1.+ambientOcclusion);reflectedLight.indirectSpecular*=specularOcclusion;
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
#if !defined(SSR_ENABLED) || SSR_ENABLED < 1
reflectedLight.indirectSpecular+=ssgiColor*material.specularColor;
#endif
#endif
#endif
#endif
`
  , cameraHelpers = `#ifndef BASIC_CAMERA_HELPERS
#define BASIC_CAMERA_HELPERS 
uniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;uniform mat4 projection;
#ifndef THREE_PACKING_INCLUDED
#define THREE_PACKING_INCLUDED 
#include <packing>
#endif
float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}float depthToViewZ(const in float depth){return(depth>0.999)?-cameraNearFar.y*1000.:-mix(cameraNearFar.x,cameraNearFar.y,depth);}float viewZToDepth(const in float viewZ){return linstep(-cameraNearFar.x,-cameraNearFar.y,viewZ);}vec4 viewToScreen3(const in vec3 pos){vec4 projected=projection*vec4(pos,1.);projected.z=pos.z;projected.w=1./projected.w;projected.xyz*=projected.w;projected.xy=0.5+0.5*projected.xy;return projected;}vec3 screenToView(const in vec2 uv,const in float viewZ){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewZ/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewZ/projection[1][1];return vec3(xe,ye,viewZ);}
#endif
`
  , samplePointHelpers = `#define PI  3.141592653589793
mat3 GetTangentBasis(vec3 TangentZ){vec3 up=vec3(0.,0.,1.);vec3 TangentX=normalize(cross(dot(TangentZ,up)<0.8?up:vec3(1.,0.,0.),TangentZ));vec3 TangentY=cross(TangentZ,TangentX);return mat3(TangentX,TangentY,TangentZ);}vec4 CosineSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=sqrt(E.y);float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=CosTheta*(1./PI);return vec4(H,PDF);}vec4 UniformSampleHemisphere(vec2 E){float Phi=2.*PI*E.x;float CosTheta=E.y;float SinTheta=sqrt(1.-CosTheta*CosTheta);vec3 H;H.x=SinTheta*cos(Phi);H.y=SinTheta*sin(Phi);H.z=CosTheta;float PDF=1./(2.*PI);return vec4(H,PDF);}vec2 UniformSampleDiskConcentric(vec2 E){vec2 p=2.*E-1.;float Radius;float Phi;if(abs(p.x)>abs(p.y)){Radius=p.x;Phi=(PI/4.)*(p.y/p.x);}else{Radius=p.y;Phi=(PI/2.)-(PI/4.)*(p.x/p.y);}return vec2(Radius*cos(Phi),Radius*sin(Phi));}vec2 UniformSampleDiskConcentricApprox(vec2 E){vec2 sf=E*sqrt(2.)-sqrt(0.5);vec2 sq=sf*sf;float root=sqrt(2.*max(sq.x,sq.y)-min(sq.x,sq.y));if(sq.x>sq.y){sf.x=sf.x>0.?root:-root;}else{sf.y=sf.y>0.?root:-root;}return sf;}`
  , ssrt = `#ifndef SSRT_PARS_SNIP
#define SSRT_PARS_SNIP 
#define pow2(a)a*a
float getDepth2(const in vec2 uv,const in float lod){float viewDepth=getDepth(uv);return depthToViewZ(viewDepth);}
#define LOD_DEPTH  1.0
#define LOD_COLOR  5.0
void _traceRay(in vec4 ray_origin,in vec4 ray_dir,in float tolerance,inout vec3 state,in int loopMax,in float iStepCount){vec4 sample_uv;float d,hit;float dLod=0.;
#pragma unroll_loop_start
for(int i=0;i<8;i++){if(UNROLLED_LOOP_INDEX<loopMax){sample_uv=ray_origin+ray_dir*state.y;d=getDepth2(sample_uv.xy,dLod);d=sample_uv.z/sample_uv.w-d;if(abs(d+tolerance)<tolerance){hit=clamp(state.x/(state.x-d),0.,1.)-1.;hit=(state.y+hit*iStepCount);state.z=min(state.z,hit);}state.x=d;state.y+=1.*iStepCount;}}
#pragma unroll_loop_end
}vec3 traceRay(in vec3 ray_origin_view,in vec3 ray_dir_view,in float tolerance,inout vec3 state,in int _STEP_COUNT){vec4 sample_uv;vec4 ray_origin=viewToScreen3(ray_origin_view);vec3 ray_end_view=ray_origin_view+ray_dir_view;vec4 ray_dir=viewToScreen3(ray_end_view);vec2 clamp_end=clamp(ray_dir.xy,vec2(0.),vec2(1.));vec2 correction=abs(ray_dir.xy-clamp_end);correction=(step(0.01,correction)*correction/(abs(clamp_end-ray_origin.xy)+0.01))+1.;correction.x=1./min(max(correction.y,correction.x),10.);ray_dir=ray_dir-ray_origin;ray_dir.xyw*=correction.x;float iStepCount=1./float(_STEP_COUNT);tolerance*=0.125;_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT,iStepCount);if(_STEP_COUNT>8&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-8,iStepCount);if(_STEP_COUNT>15&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);if(_STEP_COUNT>23&&state.z>0.98)_traceRay(ray_origin,ray_dir,tolerance,state,_STEP_COUNT-16,iStepCount);sample_uv=ray_origin+ray_dir*state.z;sample_uv.z/=sample_uv.w;state.z=state.z<0.999?state.z:9999999.;return sample_uv.xyz;}
#endif
`
  , basicHelpers = `#ifndef BASIC_HELPERS
#define BASIC_HELPERS 
float saturate2(float v,float mx){return max(0.,min(mx,v));}vec3 saturate2(vec3 v){return max(vec3(0.),min(vec3(1.),v));}
#endif
`
  , ssrtao = `varying vec2 vUv;uniform float frameCount2;uniform float intensity;uniform float objectRadius;uniform float rayCount;uniform float power;uniform float bias;uniform float falloff;uniform float tolerance;uniform bool autoRadius;uniform vec2 screenSize;vec3 ComputeUniformL(vec3 N,vec2 E){vec3 L;L.xy=E;L.z=interleavedGradientNoise(gl_FragCoord.xy,frameCount2*5.);L=L*2.-1.;return L;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=random3(vec3(gl_FragCoord.xy,frameCount2+seed));rand_e.y=random3(vec3(gl_FragCoord.yx,rand_e.x+(frameCount2)*7.));return rand_e;}vec4 calculateGI(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeUniformL(normal,E);L=normalize(L);L*=sign(dot(L,normal));float cameraDist=length(cameraPositionWorld);float rayLen=autoRadius?length(viewPos-screenToView(screenPos.xy+objectRadius/10.,screenPos.z)):mix((cameraNearFar.y)+viewPos.z,-viewPos.z-cameraNearFar.x,L.z*0.5+0.5)*objectRadius;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount2*14.+seed)+0.05;rayLen=max(rayLen,0.001);vec3 state=vec3(1.,(r+0.5)/float(RTAO_STEP_COUNT),2.);viewPos+=normal*max(-0.01*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,RTAO_STEP_COUNT);vec3 viewHitP=screenToView(screenHitP.xy,screenHitP.z);vec3 LRes=viewHitP-viewPos;if(state.z>1.)LRes=vec3(9999999.);float dist=length(LRes)*falloff;float EPS=0.01;float zBias=(viewPos.z)*bias;float ao=(max(dot(normal,L)+zBias,0.))/(dist*dist+EPS);
#if defined(SSGI_ENABLED) && SSGI_ENABLED > 0
vec3 hitColor=tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy)).rgb;vec3 hitNormal=getViewNormal(screenHitP.xy);float giWeight=1.;giWeight=saturate2(giWeight/(dist+EPS),1.);giWeight*=saturate2((dot(normal,L)),1.);giWeight*=saturate2((dot(hitNormal,-L)),1.);return vec4(hitColor*giWeight,ao);
#endif
return vec4(0,0,0,ao);}float normpdf(in float x,in float sigma){return exp(-0.5*x*x/(sigma*sigma));}vec4 getLastThis(sampler2D tex,float depth,vec3 normal){vec2 direction=vec2(1,1);vec4 color=clamp(tLastThisTexelToLinear(texture2D(tex,vUv.xy)),0.,5.);return color;}void main(){float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>0.99){discard;gl_FragColor=getLastThis(tLastThis,depth,normal);return;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec4 gi=vec4(0.);gi+=calculateGI(8.,screenPos,normal,1.);if(rayCount>1.5)gi=max(gi,calculateGI(2.,screenPos,normal,0.4));if(rayCount>2.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.5));if(rayCount>3.5)gi=max(gi,calculateGI(1.,screenPos,normal,0.6));if(rayCount>4.5)gi=max(gi,calculateGI(3.,screenPos,normal,1.));gi.a=min(1.,gi.a);gi.a=max(0.,gi.a);gi.rgb=min(vec3(3.),gi.rgb);gi.rgb=max(vec3(0.),gi.rgb);if(frameCount2<3.){gl_FragColor=gi;return;}gl_FragColor=(texture2D(tLastThis,vUv));gl_FragColor=((gi+(gl_FragColor)*frameCount2)/(frameCount2+1.));}`
  , SSRTAOPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class SSRTAOPass extends ShaderPass2 {
    get ssgiEnabled() {
        return parseInt(this.material.defines.SSGI_ENABLED) > .5
    }
    set ssgiEnabled(o) {
        o = o && this._giActivated,
        this.material.defines.SSGI_ENABLED = o ? 1 : 0,
        this.material.needsUpdate = !0
    }
    constructor(o, c, h, _=!1) {
        super({
            vertexShader: defaultVertex,
            fragmentShader: `

${basicHelpers}
${cameraHelpers}
${randomHelpers}
${samplePointHelpers}
${h}

${ssrt}

${ssrtao}

            `,
            uniforms: {
                tLastThis: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                tNormalDepth: {
                    value: null
                },
                tLastFrame: {
                    value: null
                },
                opacity: {
                    value: 1
                },
                intensity: {
                    value: 2.14
                },
                rayCount: {
                    value: .1
                },
                objectRadius: {
                    value: 1
                },
                autoRadius: {
                    value: !_
                },
                power: {
                    value: 1.1
                },
                bias: {
                    value: .015
                },
                falloff: {
                    value: .7
                },
                tolerance: {
                    value: 1.5
                },
                frameCount: {
                    value: 0
                },
                frameCount2: {
                    value: 0
                },
                projection: {
                    value: new three_module.kn4
                },
                screenSize: {
                    value: new three_module.I9Y
                },
                cameraPositionWorld: {
                    value: new three_module.Pq0
                },
                cameraNearFar: {
                    value: new three_module.I9Y(.1,1e3)
                }
            },
            defines: {
                PERSPECTIVE_CAMERA: 1,
                SSGI_ENABLED: _ ? 1 : 0
            }
        }, "tDiffuse", "tLastFrame", "tLastThis"),
        this.materialExtension = {
            shaderExtender: (b, _e, nt) => {
                var it;
                if (!b.defines.SSRTAO_ENABLED)
                    return;
                this.materialExtension.extraUniforms.tSSGIMap.value = (it = this._target) === null || it === void 0 ? void 0 : it.texture;
                const at = _e.materialObject;
                let ut = this.material.defines.SSGI_ENABLED;
                at.defines.SSGI_ENABLED !== ut && (at.defines.SSGI_ENABLED = ut,
                at.needsUpdate = !0),
                ut = this._target.texture,
                this.materialExtension.extraUniforms.tSSGIMap.value !== ut && (this.materialExtension.extraUniforms.tSSGIMap.value = ut,
                at.needsUpdate = !0);
                const pt = "vec3 totalDiffuse ="
                  , ht = `
            
            ${giPatch}
            
            // reflectedLight.directDiffuse = vec3(0.);
            // reflectedLight.indirectDiffuse = vec3(0.);
            // reflectedLight.directSpecular = vec3(0.);
            // reflectedLight.indirectSpecular = vec3(0.);
            
            `;
                b.fragmentShader = b.fragmentShader.replace(pt, `
${ht}
${pt}`),
                b.fragmentShader = b.fragmentShader.replace("#include <aomap_fragment>", ""),
                b.defines.USE_UV = ""
            }
            ,
            onObjectRender: (b, _e, nt) => {
                var it, at, ut;
                const pt = _e.materialObject
                  , ht = !pt.transparent && pt.transmission < .001
                  , _t = this.enabled && ht && (this.renderWithCamera || this._renderer.frameCount > 1) && nt.userData.screenSpaceRendering !== !1 && !(!((it = pt.userData) === null || it === void 0) && it.ssrtaoDisabled) && !(!((at = pt.userData) === null || at === void 0) && at.ssaoDisabled) && !(!((ut = pt.userData) === null || ut === void 0) && ut.pluginsDisabled) ? 1 : 0;
                pt.defines.SSRTAO_ENABLED !== _t && (pt.defines.SSRTAO_ENABLED = _t,
                pt.needsUpdate = !0)
            }
            ,
            parsFragmentSnippet: b => {
                var _e;
                return fe$1`
            uniform float ssaoPower;
            uniform float ssgiIntensity;
            uniform sampler2D tSSGIMap;
            ${getTexelDecoding("tSSGIMap", (_e = this._target) === null || _e === void 0 ? void 0 : _e.texture.colorSpace)}

            ${simpleCameraHelpers}

        `
            }
            ,
            extraUniforms: {
                tSSGIMap: {
                    value: null
                },
                ssaoPower: this.material.uniforms.power,
                ssgiIntensity: this.material.uniforms.intensity
            },
            computeCacheKey: b => {
                var _e, nt, it, at;
                return this.enabled ? "1" : "0" + ((nt = (_e = this._target) === null || _e === void 0 ? void 0 : _e.texture) === null || nt === void 0 ? void 0 : nt.colorSpace) + ((at = (it = this._target) === null || it === void 0 ? void 0 : it.texture) === null || at === void 0 ? void 0 : at.uuid) + this.material.defines.SSGI_ENABLED
            }
            ,
            isCompatible: b => {
                var _e;
                return !(!((_e = b.materialObject.userData) === null || _e === void 0) && _e.ssaoDisabled) && b.isMeshStandardMaterial2
            }
        },
        this.intensity = 2,
        this.power = 1.1,
        this.autoRadius = !0,
        this.objectRadius = 2,
        this.tolerance = 1,
        this.bias = .15,
        this.falloff = .7,
        this.rayCount = 2,
        this.stepCount = 4,
        this.smoothEnabled = !0,
        this.renderWithCamera = !0,
        this.uiConfig = {
            type: "folder",
            label: "SS Global illumination (Dev)",
            children: [...generateUiConfig(this), {
                type: "checkbox",
                label: "GI Enabled",
                hidden: () => !this._giActivated,
                property: [this, "ssgiEnabled"]
            }]
        },
        this._renderer = o,
        this._target = c,
        this.needsSwap = !0,
        this._giActivated = _,
        this.ssgiEnabled = _,
        this.bilateralPass = new BilateralFilterPass(this._target,h,"rgba")
    }
    render(o, c, h, _, b) {
        this.needsSwap = !1,
        !this.renderWithCamera && this._renderer.frameCount < 2 || (this._renderer.blit(this._target.texture, c),
        this.uniforms.tLastThis.value = c.texture,
        super.render(o, this._target, h, _, b),
        this.smoothEnabled && this.bilateralPass.render(o, c, h, _, b))
    }
}
SSRTAOPass_decorate([serialize()], SSRTAOPass.prototype, "bilateralPass", void 0),
SSRTAOPass_decorate([uiSlider("Intensity", [0, 4]), serialize(), uniform()], SSRTAOPass.prototype, "intensity", void 0),
SSRTAOPass_decorate([uiSlider("Power", [0, 3]), serialize(), uniform()], SSRTAOPass.prototype, "power", void 0),
SSRTAOPass_decorate([uiToggle("Auto radius"), serialize(), uniform()], SSRTAOPass.prototype, "autoRadius", void 0),
SSRTAOPass_decorate([uiSlider("Object Radius", [.01, 10]), serialize(), uniform()], SSRTAOPass.prototype, "objectRadius", void 0),
SSRTAOPass_decorate([uiSlider("Tolerance", [.1, 5]), serialize(), uniform()], SSRTAOPass.prototype, "tolerance", void 0),
SSRTAOPass_decorate([uiSlider("Bias", [-.3, .3]), serialize(), uniform()], SSRTAOPass.prototype, "bias", void 0),
SSRTAOPass_decorate([uiSlider("Falloff", [1e-4, 4]), serialize(), uniform()], SSRTAOPass.prototype, "falloff", void 0),
SSRTAOPass_decorate([uiSlider("Ray Count", [1, 5], 1), serialize(), uniform()], SSRTAOPass.prototype, "rayCount", void 0),
SSRTAOPass_decorate([uiSlider("Step count", [1, 16], 1), serialize(), matDefine("RTAO_STEP_COUNT")], SSRTAOPass.prototype, "stepCount", void 0),
SSRTAOPass_decorate([uiToggle("Smooth Enabled"), serialize()], SSRTAOPass.prototype, "smoothEnabled", void 0),
SSRTAOPass_decorate([uiToggle("Render with Camera")], SSRTAOPass.prototype, "renderWithCamera", void 0);
class SSGIPlugin extends MultiFilterPlugin {
    get rtgiTarget() {
        return this._rtgiTarget
    }
    constructor(o=!0) {
        super(),
        this.dependencies = [AssetManagerPlugin, GBufferPlugin, ProgressivePlugin],
        this._initEnabled = !1,
        this.setDirty = this.setDirty.bind(this),
        this._initEnabled = o
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        this.enabled = this._initEnabled,
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
    }
    get enabled() {
        var o, c;
        return ((c = (o = this.passes.ssrtgi) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.enabled) || !1
    }
    set enabled(o) {
        var c;
        !((c = this.passes.ssrtgi) === null || c === void 0) && c.passObject && (this.passes.ssrtgi.passObject.enabled = o)
    }
    createPasses(o) {
        var c, h, _;
        return this._rtgiTarget = o.renderer.createTarget({
            sizeMultiplier: 1
        }),
        (c = this._viewer) === null || c === void 0 || c.getPluginByType("debug"),
        [makeFilter(o, {
            passId: "ssrtgi",
            after: ["gbuffer"],
            before: ["render"],
            required: ["render", "gbuffer", "progressive"],
            passObject: new SSRTAOPass(o.renderer,this._rtgiTarget,(_ = (h = o.getPlugin(GBufferPlugin)) === null || h === void 0 ? void 0 : h.getUnpackSnippet()) !== null && _ !== void 0 ? _ : "",!0),
            update: () => {
                var b;
                const _e = this.enabled;
                if (_e) {
                    const nt = (b = this._viewer) === null || b === void 0 ? void 0 : b.getPluginByType("SSAO");
                    nt != null && nt.enabled && (nt.enabled = !1)
                }
                _e && this.passes.ssrtgi.passObject.bilateralPass.updateShaderProperties([o.getPlugin(GBufferPlugin)])
            }
        }, () => [o.getPlugin(GBufferPlugin), o.getPlugin(ProgressivePlugin), o.scene.activeCamera, o.renderer])]
    }
    async onRemove(o) {
        return o.renderer.disposeTarget(this._rtgiTarget),
        super.onRemove(o)
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    get uiConfig() {
        var o, c, h, _, b;
        const _e = (h = (c = (o = this.passes.ssrtgi) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.uiConfig) !== null && h !== void 0 ? h : {};
        return (b = (_ = _e.children) === null || _ === void 0 ? void 0 : _.map(nt => Ee$1(nt))) === null || b === void 0 || b.flat(2).forEach(nt => nt && (nt.onChange = this.setDirty)),
        _e
    }
}
SSGIPlugin.PluginType = "SSGI";
var NormalRenderPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let NormalRenderPass = class extends RenderPass {
    constructor(d, o, c) {
        super(d, o, c ?? new NormalMaterial, new three_module.Q1f(0,0,0), 1),
        this.enabled = !0,
        this._firstCall = !0
    }
    render(d, o, c, h, _) {
        this.enabled && super.render(d, o, c, h, _)
    }
}
;
NormalRenderPass = NormalRenderPass_decorate([uiFolder("High Precision Normal Buffer")], NormalRenderPass);
class NormalMaterial extends three_module.qBx {
    constructor() {
        super()
    }
    onBeforeRender(o, c, h, _, b) {
        var _e, nt, it;
        let at = b.material;
        Array.isArray(at) && (at = at[0]),
        this.normalMap = (_e = at == null ? void 0 : at.normalMap) !== null && _e !== void 0 ? _e : null,
        this.bumpMap = (nt = at == null ? void 0 : at.bumpMap) !== null && nt !== void 0 ? nt : null,
        this.bumpScale = at == null ? void 0 : at.bumpScale,
        at != null && at.normalScale && this.normalScale.copy(at == null ? void 0 : at.normalScale),
        this.needsUpdate = !0,
        this.side = (it = at.side) !== null && it !== void 0 ? it : three_module.$EB
    }
}
class NormalBufferPlugin extends GenericFilterPlugin {
    passCtor(o) {
        this._normalTarget = o.renderer.createTarget({
            depthBuffer: !0,
            type: three_module.ix0,
            minFilter: three_module.hxR,
            magFilter: three_module.hxR,
            generateMipmaps: !1
        }),
        this._normalTarget.texture.name = "normalBuffer",
        this._normalTarget.texture.generateMipmaps = !1;
        const c = this._normalTarget
          , h = new Set
          , _ = new Set;
        return new class extends NormalRenderPass {
            render(b, _e, nt, it, at) {
                const ut = b.getRenderTarget()
                  , pt = b.getActiveCubeFace()
                  , ht = b.getActiveMipmapLevel();
                this.scene && (this.scene.traverse( ({material: _t}) => {
                    _t && ((_t.transparent && _t.userData.renderToDepth || !_t.transparent && _t.transmission === 0 && _t.userData.renderToDepth === !1) && (h.add(_t),
                    _t.transparent = !_t.transparent),
                    Math.abs(_t.transmission || 0) > 0 && _t.userData.renderToDepth && (_.add([_t, _t.transmission]),
                    _t.transmission = 0))
                }
                ),
                setThreeRendererMode(b, {
                    shadowMapRender: !1,
                    backgroundRender: !1,
                    opaqueRender: !0,
                    transparentRender: !1,
                    transmissionRender: !1,
                    mainRenderPass: !1
                }, () => super.render(b, _e, c, it, at)),
                h.forEach(_t => _t.transparent = !_t.transparent),
                h.clear(),
                _.forEach( ([_t,vt]) => _t.transmission = vt),
                _.clear(),
                b.setRenderTarget(ut, pt, ht))
            }
        }
    }
    _update(o) {
        if (!super._update(o))
            return !1;
        const c = this.pass.passObject;
        return c.scene = o.scene.modelObject,
        c.camera = o.scene.activeCamera.cameraObject,
        !0
    }
    constructor(o=!0) {
        super(),
        this.passId = "normalBuffer",
        this._beforeFilters = ["render"],
        this._afterFilters = [],
        this._requiredFilters = ["render"],
        this.enabled = o
    }
    getNormalBuffer() {
        return this._normalTarget
    }
    async onDispose(o) {}
    async onRemove(o) {
        var c, h;
        return o.renderer.disposeTarget((h = (c = this._normalTarget) === null || c === void 0 ? void 0 : c.dispose) === null || h === void 0 ? void 0 : h.call(c)),
        super.onRemove(o)
    }
    updateShaderProperties(o) {
        var c, h;
        return o.uniforms.tNormalBuffer ? o.uniforms.tNormalBuffer.value = this.enabled && (h = (c = this.getNormalBuffer()) === null || c === void 0 ? void 0 : c.texture) !== null && h !== void 0 ? h : null : console.warn("BaseRenderer: no uniform: tNormalBuffer"),
        this
    }
    get uiConfig() {
        var o;
        return (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.uiConfig
    }
}
NormalBufferPlugin.PluginType = "NormalBufferPlugin";
class e {
    static _xfnv1a(o) {
        let c = 2166136261;
        for (let h = 0; h < o.length; h++)
            c = Math.imul(c ^ o.charCodeAt(h), 16777619);
        return () => (c += c << 13,
        c ^= c >>> 7,
        c += c << 3,
        c ^= c >>> 17,
        (c += c << 5) >>> 0)
    }
}
let t$1 = class xw extends e {
    constructor(o) {
        super(),
        Object.defineProperty(this, "a", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.a = xw._xfnv1a(o)()
    }
    next() {
        let o = this.a += 1831565813;
        return o = Math.imul(o ^ o >>> 15, 1 | o),
        o ^= o + Math.imul(o ^ o >>> 7, 61 | o),
        ((o ^ o >>> 14) >>> 0) / 4294967296
    }
}
;
class es_i extends e {
    constructor(o) {
        super(),
        Object.defineProperty(this, "a", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "b", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "c", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "d", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        });
        const c = es_i._xfnv1a(o);
        this.a = c(),
        this.b = c(),
        this.c = c(),
        this.d = c()
    }
    next() {
        this.a >>>= 0,
        this.b >>>= 0,
        this.c >>>= 0,
        this.d >>>= 0;
        let o = this.a + this.b | 0;
        return this.a = this.b ^ this.b >>> 9,
        this.b = this.c + (this.c << 3) | 0,
        this.c = this.c << 21 | this.c >>> 11,
        this.d = this.d + 1 | 0,
        o = o + this.d | 0,
        this.c = this.c + o | 0,
        (o >>> 0) / 4294967296
    }
}
let r$1 = class bw extends e {
    constructor(o) {
        super(),
        Object.defineProperty(this, "a", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "b", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "c", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "d", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        });
        const c = bw._xfnv1a(o);
        this.a = c(),
        this.b = c(),
        this.c = c(),
        this.d = c()
    }
    next() {
        const o = this.b << 9;
        let c = 5 * this.b;
        return c = 9 * (c << 7 | c >>> 25),
        this.c ^= this.a,
        this.d ^= this.b,
        this.b ^= this.c,
        this.a ^= this.d,
        this.c ^= o,
        this.d = this.d << 11 | this.d >>> 21,
        (c >>> 0) / 4294967296
    }
}
;
var s;
(function(d) {
    d.sfc32 = "sfc32",
    d.mulberry32 = "mulberry32",
    d.xoshiro128ss = "xoshiro128ss"
}
)(s || (s = {}));
class a {
    constructor(o, c=s.sfc32) {
        Object.defineProperty(this, "str", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "prng", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        Object.defineProperty(this, "generator", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: void 0
        }),
        this.str = o,
        this.prng = c,
        this.generator = this._initializeGenerator()
    }
    next() {
        return this.generator.next()
    }
    _initializeGenerator() {
        if ((c => c === null)(o = this.str) || (c => c === void 0)(o))
            return this.wrap();
        var o;
        switch (this.prng) {
        case "sfc32":
            return new es_i(this.str);
        case "mulberry32":
            return new t$1(this.str);
        case "xoshiro128ss":
            return new r$1(this.str);
        default:
            return this.wrap()
        }
    }
    wrap() {
        return {
            next: () => Math.random()
        }
    }
}
var RandomizedDirectionalLight_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class RandomizedDirectionalLight extends DirectionalLight2 {
    constructor(o, c, h, _) {
        super(o, c),
        this._shadowParams = {
            enabled: !0,
            radius: 2,
            width: 1024,
            height: 1024,
            bias: -.001,
            normalBias: 0,
            near: 1.5,
            far: 4,
            frustumSize: 4
        },
        this._randomParams = {
            focus: 1,
            spread: .01,
            distanceScale: 50,
            minDistanceScale: new three_module.Pq0(10,10,10),
            normalDirection: new three_module.Pq0(.01,.98,.01).normalize(),
            direction: new three_module.Pq0(-.9,.5,-1)
        },
        this.isRandomizedDirectionalLight = !0,
        this.shadowParams = h ?? {},
        this.randomParams = _ ?? {},
        this.updateShadowParams = this.updateShadowParams.bind(this)
    }
    get shadowParams() {
        return this._shadowParams
    }
    set shadowParams(o) {
        Object.keys(o).forEach(c => o[c] === void 0 && delete o[c]),
        this._shadowParams = {
            ...this._shadowParams,
            ...o
        },
        this.updateShadowParams()
    }
    get randomParams() {
        return this._randomParams
    }
    set randomParams(o) {
        Object.keys(o).forEach(c => o[c] === void 0 && delete o[c]),
        Object.assign(this._randomParams, o)
    }
    updateShadowParams() {
        this.castShadow = this._shadowParams.enabled,
        this.shadow.mapSize.x = this._shadowParams.width,
        this.shadow.mapSize.y = this._shadowParams.height,
        this.shadow.bias = this._shadowParams.bias,
        this.shadow.normalBias = this._shadowParams.normalBias,
        this.refreshShadowCamNearFar(),
        this.shadow.radius = this._shadowParams.radius,
        this.shadow.camera.right = this._shadowParams.frustumSize / 2,
        this.shadow.camera.left = -this._shadowParams.frustumSize / 2,
        this.shadow.camera.top = this._shadowParams.frustumSize / 2,
        this.shadow.camera.bottom = -this._shadowParams.frustumSize / 2,
        this.shadow.camera.updateProjectionMatrix(),
        this.matrixWorldNeedsUpdate = !0
    }
    randomizePosition(o, c=null, h=null) {
        const _ = new a(o.toString())
          , b = new three_module.I9Y(_.next() * Math.PI * 2,Math.asin(2 * _.next() - 1));
        let _e = new three_module.Pq0(Math.cos(b.x) * Math.cos(b.y),Math.sin(b.y),Math.sin(b.x) * Math.cos(b.y));
        const nt = new three_module.I9Y;
        for (let it = 0; it < 5; it++) {
            nt.set(_.next(), _.next()),
            _e = getSample(nt, this._randomParams.normalDirection, .4),
            _.next() < Math.sqrt(c ?? this._randomParams.focus) && (nt.set(_.next(), _.next()),
            _e = getSample(nt, this._randomParams.direction, Math.pow((h ?? this._randomParams.spread) / 2, 2)));
            const at = _e.dot(this._randomParams.normalDirection);
            if (at > 0 && at < .4)
                break
        }
        _e.normalize(),
        _e.multiplyScalar(this._randomParams.distanceScale),
        this.position.set(0, 0, 0),
        this.target.position.copy(_e.normalize().negate()),
        this.target.updateMatrixWorld(),
        this.refreshShadowCamNearFar(),
        this.updateMatrixWorld()
    }
    refreshShadowCamNearFar() {
        const o = new three_module.Pq0().subVectors(this.target.position, this.shadow.camera.position).length();
        this.shadow.camera.near = o - this._shadowParams.near * this._shadowParams.frustumSize / 2,
        this.shadow.camera.far = o + this._shadowParams.far * this._shadowParams.frustumSize / 2
    }
    dispose() {}
    get uiConfig() {
        if (this._uiConfig)
            return this._uiConfig
    }
    fromJSON(o, c) {
        return super.fromJSON(o, c) ? (this.updateShadowParams(),
        this) : null
    }
}
function getSample(d, o, c) {
    o = o.clone().normalize();
    const h = new three_module.Pq0(0,-o.z,o.y).normalize()
      , _ = new three_module.Pq0().crossVectors(o, h).normalize()
      , b = d;
    b.x = 2 * b.x * Math.PI,
    b.y = 1 - b.y * c;
    const _e = Math.sqrt(1 - b.y * b.y);
    return h.multiplyScalar(Math.cos(b.x) * _e).add(_.multiplyScalar(Math.sin(b.x) * _e)).add(o.multiplyScalar(b.y))
}
RandomizedDirectionalLight_decorate([serialize("shadowParams")], RandomizedDirectionalLight.prototype, "_shadowParams", void 0),
RandomizedDirectionalLight_decorate([serialize("randomParams")], RandomizedDirectionalLight.prototype, "_randomParams", void 0);
var RandomizedDirectionalLightPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class RandomizedDirectionalLightPlugin extends AViewerPlugin {
    get cameraHelper() {
        return this._cameraHelper
    }
    constructor(o=!0) {
        super(),
        this.enabled = !0,
        this.light = new RandomizedDirectionalLight("#cceeff",1),
        this.lightLayers = 1,
        this._preRender = () => {
            var c, h, _;
            if (!this.enabled)
                return void (this.light.layers.mask = 0);
            const b = (h = (c = this._viewer) === null || c === void 0 ? void 0 : c.renderer.frameCount) !== null && h !== void 0 ? h : 0;
            this.light.randomizePosition(b < 5 ? 0 : b),
            this.light.layers.mask = this.lightLayers,
            this.light.updateShadowParams(),
            (_ = this._cameraHelper) === null || _ === void 0 || _.update()
        }
        ,
        this._setDirty = this._setDirty.bind(this),
        this.enabled = o
    }
    async onAdded(o) {
        await super.onAdded(o),
        this._cameraHelper = new three_module.WTh(this.light.shadow.camera),
        this._cameraHelper.visible = !1,
        this._cameraHelper.userData.bboxVisible = !1,
        o.scene.add(this._cameraHelper),
        o.scene.addLight(this.light, {
            addToRoot: !0
        }),
        o.addEventListener("preRender", this._preRender)
    }
    async onRemove(o) {
        return o.removeEventListener("preRender", this._preRender),
        this.light.removeFromParent(),
        super.onRemove(o)
    }
    _setDirty(o=!1) {
        var c, h;
        o ? (c = this._viewer) === null || c === void 0 || c.scene.setDirty() : (h = this._viewer) === null || h === void 0 || h.setDirty()
    }
    get uiConfig() {
        return this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "folder",
            label: "Progressive Shadow",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "enabled"],
                onChange: this._setDirty
            }, {
                type: "folder",
                label: "Directional Light",
                children: [{
                    type: "checkbox",
                    label: "Visible",
                    property: [this.light, "visible"],
                    onChange: this._setDirty
                }, {
                    type: "slider",
                    label: "Intensity",
                    bounds: [0, 50],
                    property: [this.light, "intensity"],
                    onChange: this._setDirty
                }, {
                    type: "color",
                    label: "Color",
                    property: [this.light, "color"],
                    onChange: this._setDirty
                }, {
                    type: "checkbox",
                    label: "Shadow Enabled",
                    property: [this.light.shadowParams, "enabled"],
                    onChange: [this.light.updateShadowParams, this._setDirty]
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this.light.randomParams, "focus"],
                    onChange: this._setDirty
                }, {
                    type: "slider",
                    bounds: [0, 1],
                    property: [this.light.randomParams, "spread"],
                    onChange: this._setDirty
                }, {
                    type: "slider",
                    bounds: [.01, 60],
                    property: [this.light.randomParams, "distanceScale"],
                    onChange: this._setDirty
                }, {
                    type: "vec3",
                    bounds: [-5, 5],
                    property: [this.light.randomParams, "direction"],
                    onChange: this._setDirty
                }, {
                    type: "slider",
                    bounds: [.01, 10],
                    property: [this.light.shadowParams, "radius"],
                    onChange: [this.light.updateShadowParams, this._setDirty]
                }, {
                    type: "slider",
                    bounds: [.01, 30],
                    property: [this.light.shadowParams, "frustumSize"],
                    onChange: [this.light.updateShadowParams, this._setDirty]
                }, {
                    type: "slider",
                    bounds: [-.01, .01],
                    property: [this.light.shadowParams, "bias"],
                    onChange: [this.light.updateShadowParams, this._setDirty]
                }, {
                    type: "slider",
                    bounds: [-.05, .05],
                    property: [this.light.shadowParams, "normalBias"],
                    onChange: [this.light.updateShadowParams, this._setDirty]
                }]
            }]
        }
    }
}
RandomizedDirectionalLightPlugin.PluginType = "RandomizedDirectionalLight",
RandomizedDirectionalLightPlugin_decorate([serialize()], RandomizedDirectionalLightPlugin.prototype, "enabled", void 0),
RandomizedDirectionalLightPlugin_decorate([serialize("rdLight")], RandomizedDirectionalLightPlugin.prototype, "light", void 0),
RandomizedDirectionalLightPlugin_decorate([serialize()], RandomizedDirectionalLightPlugin.prototype, "lightLayers", void 0);
var ssrPatch = `#if defined(SSR_ENABLED) && SSR_ENABLED > 0
vec3 screenPos=viewToScreen(geometryPosition);vec4 ssrColor=vec4(0,0,0,0);float alphaModifier=1.-clamp(material.roughness*.3,0.,1.);alphaModifier*=ssrIntensity;
#if defined(SSR_MASK_FRONT_RAYS) && SSR_MASK_FRONT_RAYS > 0
alphaModifier*=clamp(-4.*dot(geometryViewDir,normal)+(4.+ssrMaskFrontFactor),0.,1.);
#endif
#ifdef USE_TRANSMISSION
alphaModifier*=1.-transmission;
#endif
float vignette=1.;if(true){float fadeStrength=0.1;float dist=max(0.,min(min(1.-screenPos.x,1.-screenPos.y),min(screenPos.x,screenPos.y)));float fade=dist*dist/(fadeStrength+0.001);fade=clamp(fade,0.,1.);fade=pow(fade,0.3);vignette=fade;}alphaModifier*=vignette;vec3 specularColor=EnvironmentBRDF(geometryNormal,geometryViewDir,material.specularColor.rgb,material.specularF90,material.roughness);if(length(specularColor.rgb)*alphaModifier>0.01&&roughnessFactor<0.9){
#if defined(SSR_INLINE) && SSR_INLINE > 0
ssrColor=calculateSSR(8.,vec3(screenPos.xy,geometryPosition.z),geometryNormal,1.,material.roughness);
#else
ssrColor=tSSRMapTexelToLinear(texture2D(tSSRMap,screenPos.xy));
#endif 
}ssrColor.rgb*=ssrBoost;ssrColor.a*=alphaModifier;ssrColor.a=min(ssrColor.a,1.);
#if defined(SSR_NON_PHYSICAL) && SSR_NON_PHYSICAL > 0
diffuseColor.a=max(ssrColor.a,diffuseColor.a*diffuseColor.a);reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(diffuseColor.rgb*ssrColor.rgb),1.);reflectedLight.indirectDiffuse=diffuseColor.rgb*(1.-ssrColor.a);reflectedLight.directDiffuse=vec3(0.);reflectedLight.directSpecular=vec3(0.);
#else
reflectedLight.indirectSpecular=mix(reflectedLight.indirectSpecular,saturate(specularColor.rgb*ssrColor.rgb),ssrColor.a);
#endif
#endif
`
  , ssreflection = `uniform float objectRadius;uniform float radius;uniform float tolerance;uniform bool autoRadius;
#ifndef D_sceneBoundingRadius
#define D_sceneBoundingRadius 
uniform float sceneBoundingRadius;
#endif
vec3 ComputeReflectionL(vec3 N,vec2 E,vec3 V,float rough){float rough4=rough*rough*rough*rough;float phi=2.*PI*E.x;float cos_theta=pow(max(E.y,0.000001),rough4/(2.-rough4));float sin_theta=sqrt(max(0.,1.-cos_theta*cos_theta));vec3 half_vec=vec3(sin_theta*cos(phi),sin_theta*sin(phi),cos_theta);vec3 tangentX=normalize(cross(abs(N.z)<0.999?vec3(0.,0.,1.):vec3(1.,0.,0.),N));vec3 tangentY=cross(N,tangentX);half_vec=half_vec.x*tangentX+half_vec.y*tangentY+half_vec.z*N;vec3 ray_dir=(2.*dot(V,half_vec))*half_vec-V;return ray_dir;}vec2 GetRandomE(float seed){vec2 rand_e;rand_e.x=interleavedGradientNoise(gl_FragCoord.xy,frameCount*117.);rand_e.y=fract(rand_e.x*38.65435);rand_e.y=mix(rand_e.y,1.,0.7);return rand_e;}vec4 calculateSSR(in float seed,in vec3 screenPos,in vec3 normal,in float radiusFactor,in float roughness){vec3 viewPos=screenToView(screenPos.xy,screenPos.z);normal=normalize(normal);vec2 E=GetRandomE(seed);vec3 L=ComputeReflectionL(normal,E,-normalize(viewPos),roughness);L=normalize(L);float cameraDist=length(cameraPositionWorld);float rayLen=objectRadius*sceneBoundingRadius;rayLen=autoRadius?min(max(mix(max(0.,(cameraDist+rayLen)+viewPos.z),max(0.,-viewPos.z-max(0.,cameraDist-rayLen)),L.z*0.5+0.5),rayLen*0.1),rayLen*5.):rayLen;rayLen*=radiusFactor;float r=interleavedGradientNoise(gl_FragCoord.xy,frameCount+seed);rayLen=max(rayLen,0.001);int steps=SSR_STEP_COUNT/(frameCount<float(SSR_LOW_QUALITY_FRAMES)?2:1);vec3 state=vec3(0.,(r+0.5)/float(steps),2.);viewPos+=normal*max(-0.0001*viewPos.z,0.001);vec3 screenHitP=traceRay(viewPos,L*rayLen,tolerance*rayLen,state,steps);if(state.z<0.9999){vec3 hitColor=(tLastFrameTexelToLinear(texture2D(tLastFrame,screenHitP.xy))).rgb;float ssrWeight=1.;return vec4(hitColor*ssrWeight,1.);}return vec4(0.);}`
  , ssreflectionMain = `uniform sampler2D tLastThis;void main(){vec4 texel=tDiffuseTexelToLinear(texture2D(tDiffuse,vUv));vec4 lastAO=tLastThisTexelToLinear(texture2D(tLastThis,vUv));float depth;vec3 normal;getDepthNormal(vUv,depth,normal);if(depth>=0.999){discard;}float viewZ=depthToViewZ(depth);vec3 screenPos=vec3(vUv.x,vUv.y,viewZ);vec3 viewPos=screenToView(screenPos.xy,screenPos.z);viewPos.z=viewZ/viewPos.z;vec4 ao=vec4(0.);ao+=calculateSSR(8.,screenPos,normal,1.,0.1);ao.rgb=min(vec3(3.),ao.rgb);ao.rgb=max(vec3(0.),ao.rgb);if(frameCount<1.){gl_FragColor=ao;return;}if(ao.a<0.01){gl_FragColor.rgb=lastAO.rgb;gl_FragColor.a=(((lastAO.a)*frameCount)/(frameCount+1.));}else{gl_FragColor=((ao+(lastAO)*frameCount)/(frameCount+1.));}
#include <colorspace_fragment>
}`
  , SSRPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let SSRPass = class extends ShaderPass2 {
    constructor(d, o, c, h=!0) {
        super({
            vertexShader: defaultVertex,
            fragmentShader: `

varying vec2 vUv;

${basicHelpers}
${cameraHelpers}
${randomHelpers}
${samplePointHelpers}
${c}

${ssrt}

${ssreflection}

${ssreflectionMain}


            `,
            uniforms: {
                tLastThis: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                tNormalDepth: {
                    value: null
                },
                tLastFrame: {
                    value: null
                },
                opacity: {
                    value: 1
                },
                intensity: {
                    value: 0
                },
                boost: {
                    value: new three_module.Pq0(0,0,0)
                },
                objectRadius: {
                    value: 0
                },
                autoRadius: {
                    value: !1
                },
                power: {
                    value: 0
                },
                maskFrontFactor: {
                    value: -.1
                },
                tolerance: {
                    value: 0
                },
                frameCount: {
                    value: 0
                },
                projection: {
                    value: new three_module.kn4
                },
                cameraPositionWorld: {
                    value: new three_module.Pq0
                },
                cameraNearFar: {
                    value: new three_module.I9Y(.1,1e3)
                },
                sceneBoundingRadius: {
                    value: 0
                }
            },
            defines: {
                PERSPECTIVE_CAMERA: 1,
                SSR_STEP_COUNT: 16,
                SSR_LOW_QUALITY_FRAMES: 2,
                SSR_MASK_FRONT_RAYS: !0,
                SSR_INLINE: h ? "1" : "0",
                SSR_NON_PHYSICAL: "0"
            }
        }, "tDiffuse", "tLastThis", "tLastFrame"),
        this.uiConfig = void 0,
        this.materialExtension = {
            shaderExtender: (_, b, _e) => {
                var nt, it, at, ut, pt;
                let ht = !this.enabled || _e.userData.screenSpaceRendering === !1 || !((nt = b.materialObject.userData) === null || nt === void 0) && nt.pluginsDisabled || !((it = b.materialObject.userData) === null || it === void 0) && it.ssreflDisabled ? 0 : 1;
                if (b.materialObject.defines.SSR_ENABLED !== ht && (b.materialObject.defines.SSR_ENABLED = ht,
                b.materialObject.needsUpdate = !0),
                !_.defines.SSR_ENABLED)
                    return;
                ht = this.material.defines.SSR_STEP_COUNT,
                b.materialObject.defines.SSR_STEP_COUNT !== ht && (b.materialObject.defines.SSR_STEP_COUNT = ht,
                b.materialObject.needsUpdate = !0),
                ht = this.material.defines.SSR_LOW_QUALITY_FRAMES,
                b.materialObject.defines.SSR_LOW_QUALITY_FRAMES !== ht && (b.materialObject.defines.SSR_LOW_QUALITY_FRAMES = ht,
                b.materialObject.needsUpdate = !0),
                ht = this.material.defines.PERSPECTIVE_CAMERA,
                b.materialObject.defines.PERSPECTIVE_CAMERA !== ht && (b.materialObject.defines.PERSPECTIVE_CAMERA = ht,
                b.materialObject.needsUpdate = !0),
                ht = this.material.defines.SSR_INLINE,
                b.materialObject.defines.SSR_INLINE !== ht && (b.materialObject.defines.SSR_INLINE = ht,
                b.materialObject.needsUpdate = !0),
                ht = this.material.defines.SSR_MASK_FRONT_RAYS ? 1 : 0,
                b.materialObject.defines.SSR_MASK_FRONT_RAYS !== ht && (b.materialObject.defines.SSR_MASK_FRONT_RAYS = ht,
                b.materialObject.needsUpdate = !0),
                ht = !((at = b.materialObject.userData) === null || at === void 0) && at.ssreflNonPhysical ? "1" : "0",
                b.materialObject.defines.SSR_NON_PHYSICAL !== ht && (b.materialObject.defines.SSR_NON_PHYSICAL = ht,
                b.materialObject.needsUpdate = !0),
                ht = (pt = (ut = this._target) === null || ut === void 0 ? void 0 : ut.texture) !== null && pt !== void 0 ? pt : null,
                this.materialExtension.extraUniforms.tSSRMap.value !== ht && (this.materialExtension.extraUniforms.tSSRMap.value = ht,
                b.materialObject.needsUpdate = !0);
                const _t = "#glMarker beforeModulation"
                  , vt = `
            
            ${ssrPatch}
            
            // reflectedLight.directDiffuse = vec3(0.);
            // reflectedLight.indirectDiffuse = vec3(0.);
            // reflectedLight.directSpecular = vec3(0.);
            // reflectedLight.indirectSpecular = vec3(0.);
            
            `;
                _.fragmentShader = _.fragmentShader.replace(_t, `
${vt}
${_t}`)
            }
            ,
            onObjectRender: (_, b, _e) => {
                var nt, it;
                const at = !this.enabled || _e.userData.screenSpaceRendering === !1 || !((nt = b.materialObject.userData) === null || nt === void 0) && nt.pluginsDisabled || !((it = b.materialObject.userData) === null || it === void 0) && it.ssreflDisabled ? 0 : 1;
                b.materialObject.defines.SSR_ENABLED !== at && (b.materialObject.defines.SSR_ENABLED = at,
                b.materialObject.needsUpdate = !0)
            }
            ,
            parsFragmentSnippet: (_, b) => {
                var _e, nt, it, at;
                return !this.enabled || _.userData.screenSpaceRendering === !1 || !((_e = b == null ? void 0 : b.materialObject.userData) === null || _e === void 0) && _e.ssreflDisabled || !((nt = b == null ? void 0 : b.materialObject.userData) === null || nt === void 0) && nt.pluginsDisabled ? "" : `
uniform float ssrPower;
uniform float ssrIntensity;
uniform float ssrMaskFrontFactor;
uniform vec3 ssrBoost;
uniform sampler2D tSSRMap;
uniform sampler2D tLastFrame;
` + getTexelDecoding("tSSRMap", (it = this._target) === null || it === void 0 ? void 0 : it.texture.colorSpace) + getTexelDecoding("tLastFrame", (at = this.materialExtension.extraUniforms.tLastFrame.value) === null || at === void 0 ? void 0 : at.colorSpace) + (this._inline ? `
#if 1
// #if SSR_INLINE
    ${basicHelpers}
    
    #define THREE_PACKING_INCLUDED
    ${cameraHelpers}
    
    ${randomHelpers}
    ${samplePointHelpers}
    ${unpackGbuffer}
    
    ${ssrt}
    
    ${ssreflection}
// #endif // SSR_INLINE
#endif
` : "") + `
${simpleCameraHelpers}
        `
            }
            ,
            extraUniforms: {
                tSSRMap: {
                    value: null
                },
                ssrPower: this.material.uniforms.power,
                ssrIntensity: this.material.uniforms.intensity,
                ssrMaskFrontFactor: this.material.uniforms.maskFrontFactor,
                ssrBoost: this.material.uniforms.boost,
                tNormalDepth: this.material.uniforms.tNormalDepth,
                tLastFrame: this.material.uniforms.tLastFrame,
                objectRadius: this.material.uniforms.objectRadius,
                autoRadius: this.material.uniforms.autoRadius,
                tolerance: this.material.uniforms.tolerance,
                frameCount: this.material.uniforms.frameCount,
                projection: this.material.uniforms.projection,
                cameraPositionWorld: this.material.uniforms.cameraPositionWorld,
                cameraNearFar: this.material.uniforms.cameraNearFar,
                sceneBoundingRadius: this.material.uniforms.sceneBoundingRadius
            },
            computeCacheKey: _ => {
                var b, _e, nt;
                return this.enabled ? "1" : "0" + ((_e = (b = this._target) === null || b === void 0 ? void 0 : b.texture) === null || _e === void 0 ? void 0 : _e.colorSpace) + (this.enabled && !(!((nt = _.materialObject.userData) === null || nt === void 0) && nt.ssreflDisabled) ? 1 : 0) + Object.values(this.material.defines).map(it => it + "").join(",")
            }
            ,
            isCompatible: _ => {
                var b;
                return !(!((b = _.materialObject.userData) === null || b === void 0) && b.ssreflDisabled) && _.isMeshStandardMaterial2
            }
        },
        this.intensity = 1,
        this.boost = new three_module.Pq0(1,1,1),
        this.objectRadius = 1,
        this.autoRadius = !0,
        this.power = 1.1,
        this.tolerance = .5,
        this.stepCount = 16,
        this.lowQualityFrames = 0,
        this.maskFrontRays = !0,
        this.maskFrontFactor = -.2,
        this._renderer = d,
        this._target = o,
        this.needsSwap = !1,
        this._inline = h
    }
    render(d, o, c, h, _) {
        if (this._inline)
            this.needsSwap = !1;
        else {
            if (!this._target)
                throw "Target must be set when inline = false";
            this._renderer.blit(this._target.texture, o, {}),
            this.uniforms.tLastThis.value = o.texture,
            super.render(d, this._target, c, h, _),
            this.needsSwap = !1
        }
    }
}
;
SSRPass_decorate([uiSlider("Intensity", [0, 4]), serialize(), uniform()], SSRPass.prototype, "intensity", void 0),
SSRPass_decorate([uiVector("Boost"), serialize(), uniform()], SSRPass.prototype, "boost", void 0),
SSRPass_decorate([uiSlider("Object Radius", [.01, 2]), serialize(), uniform()], SSRPass.prototype, "objectRadius", void 0),
SSRPass_decorate([uiToggle("Auto radius"), serialize(), uniform()], SSRPass.prototype, "autoRadius", void 0),
SSRPass_decorate([uiSlider("Power", [0, 3]), serialize(), uniform()], SSRPass.prototype, "power", void 0),
SSRPass_decorate([uiSlider("Tolerance", [.1, 5]), serialize(), uniform()], SSRPass.prototype, "tolerance", void 0),
SSRPass_decorate([uiSlider("Step count", [1, 32], 1), serialize(), matDefine("SSR_STEP_COUNT")], SSRPass.prototype, "stepCount", void 0),
SSRPass_decorate([uiSlider("Low Quality Frames", [0, 4], 1), serialize(), matDefine("SSR_LOW_QUALITY_FRAMES")], SSRPass.prototype, "lowQualityFrames", void 0),
SSRPass_decorate([uiToggle("Ignore front rays"), serialize(), matDefine("SSR_MASK_FRONT_RAYS")], SSRPass.prototype, "maskFrontRays", void 0),
SSRPass_decorate([uiSlider("Mask front rays factor", [-1, 1], .01, d => ({
    hidden: () => !d.maskFrontRays
})), serialize(), uniform()], SSRPass.prototype, "maskFrontFactor", void 0),
SSRPass = SSRPass_decorate([uiFolder("Screen Space Reflections")], SSRPass);
class SSRPlugin extends MultiFilterPlugin {
    get ssrTarget() {
        return this._ssrTarget
    }
    constructor() {
        super(),
        this.dependencies = [AssetManagerPlugin, GBufferPlugin, ProgressivePlugin],
        this.inlineSSR = !0,
        this.setDirty = this.setDirty.bind(this)
    }
    get enabled() {
        var o, c;
        return ((c = (o = this.passes.ssr) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.enabled) || !1
    }
    set enabled(o) {
        var c;
        !((c = this.passes.ssr) === null || c === void 0) && c.passObject && (this.passes.ssr.passObject.enabled = o)
    }
    async onAdded(o) {
        var c, h;
        o.getPluginByType("Ground") && console.error("GroundPlugin must be added after SSRPlugin"),
        await super.onAdded(o),
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
    }
    createPasses(o) {
        var c, h;
        return this._ssrTarget = this.inlineSSR ? void 0 : o.renderer.createTarget({
            sizeMultiplier: 1
        }),
        [makeFilter(o, {
            passId: "ssr",
            after: ["gbuffer"],
            before: ["render"],
            required: ["render", "gbuffer", "progressive"],
            passObject: new SSRPass(o.renderer,this._ssrTarget,(h = (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 ? void 0 : c.getUnpackSnippet()) !== null && h !== void 0 ? h : "",this.inlineSSR)
        }, () => [o.getPlugin(GBufferPlugin), o.getPlugin(ProgressivePlugin), o.scene.activeCamera, o.renderer, o.scene])]
    }
    async onRemove(o) {
        return this._ssrTarget && o.renderer.disposeTarget(this._ssrTarget),
        super.onRemove(o)
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    get uiConfig() {
        var o, c, h, _, b;
        const _e = (h = (c = (o = this.passes.ssr) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.uiConfig) !== null && h !== void 0 ? h : {};
        return (b = (_ = _e.children) === null || _ === void 0 ? void 0 : _.map(nt => Ee$1(nt))) === null || b === void 0 || b.flat(2).forEach(nt => nt && (nt.onChange = this.setDirty)),
        _e
    }
}
SSRPlugin.PluginType = "SSReflection";
var anisotropyBsdf = `uniform float anisotropyFactor;uniform float anisotropyNoise;
#if ANISOTROPY_TEX_MODE == 0
uniform float anisotropyDirection;
#else
uniform sampler2D anisotropyDirectionMap;varying vec2 vAnisotropy2MapUv;
#endif
const float MIN_ROUGHNESS=0.05;vec3 indirectAnisotropyBentNormal(const in vec3 normal,const in vec3 viewDir,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){vec3 aDirection=anisotropyFactor>=0.?anisotropicB:anisotropicT;vec3 aTangent=cross(aDirection,viewDir);vec3 aNormal=cross(aTangent,aDirection);float bendFactor=abs(anisotropyFactor)*saturate(5.*max(roughness,MIN_ROUGHNESS));return normalize(mix(normal,aNormal,bendFactor));}vec3 BRDF_GGX_Anisotropy(const in vec3 lightDir,const in vec3 viewDir,const in vec3 normal,const in vec3 f0,const in float f90,const in float roughness,const in vec3 anisotropicT,const in vec3 anisotropicB){float alpha=pow2(roughness);vec3 halfDir=normalize(lightDir+viewDir);float dotNL=saturate(dot(normal,lightDir));float dotNV=saturate(dot(normal,viewDir));float dotNH=saturate(dot(normal,halfDir));float dotVH=saturate(dot(viewDir,halfDir));float dotTV=dot(anisotropicT,viewDir);float dotBV=dot(anisotropicB,viewDir);float dotTL=dot(anisotropicT,lightDir);float dotBL=dot(anisotropicB,lightDir);float dotTH=dot(anisotropicT,halfDir);float dotBH=dot(anisotropicB,halfDir);float aspect=sqrt(1.-min(1.-MIN_ROUGHNESS,abs(anisotropyFactor)*0.9));if(anisotropyFactor>0.)aspect=1./aspect;float at=roughness*aspect;float ab=roughness/aspect;vec3 F=F_Schlick(f0,f90,dotVH);float V=V_GGX_SmithCorrelated_Anisotropic(at,ab,dotTV,dotBV,dotTL,dotBL,dotNV,dotNL);float D=D_GGX_Anisotropic(at,ab,dotTH,dotBH,dotNH);return F*(V*D);}`
  , anisotropyTBN = `float rnd=(random2(vUv.xy,frameCount)-0.5)*anisotropyNoise*material.roughness;
#if ANISOTROPY_TEX_MODE < 2
#if ANISOTROPY_TEX_MODE == 0 
float rot=saturate(anisotropyDirection);
#else 
float rot=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vAnisotropy2MapUv)).r);
#endif
rot=rot*2.*PI+rnd;vec2 rot2=vec2(sin(rot),cos(rot));
#else 
vec2 rot2=(anisotropyDirectionMapTexelToLinear(texture2D(anisotropyDirectionMap,vAnisotropy2MapUv)).rg*2.-1.)+vec2(rnd,rnd);rot2=normalize(rot2);const float anisoSpecMultiplier=0.25;float matSpecAniso=(length(material.specularColor.rgb))*2.*PI;rot2=mix(rot2,vec2(sin(matSpecAniso),cos(matSpecAniso)),anisoSpecMultiplier);rot2=normalize(rot2);
#endif
vec3 anisotropicT=(tbn[0]*rot2.x+tbn[1]*rot2.y);anisotropicT=normalize(anisotropicT-normal*dot(anisotropicT,normal));vec3 anisotropicB=normalize(cross(normal,anisotropicT));`
  , AnisotropyPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let AnisotropyPlugin = class extends AViewerPlugin {
    makeAnisotropic(d) {
        var o;
        const c = (o = d.materialObject) === null || o === void 0 ? void 0 : o.userData;
        if (!c)
            return !1;
        if (c._isAnisotropic === void 0) {
            const h = c.__appliedMeshes;
            let _ = !0;
            if (h)
                for (const {geometry: b} of h)
                    !b || b.index && b.attributes.position && b.attributes.normal && b.attributes.uv || (_ = !1),
                    _ && !b.attributes.tangent && b.computeTangents();
            if (!_)
                return !1
        }
        return c._isAnisotropic = !0,
        c._anisotropyFactor === void 0 && (c._anisotropyFactor = 1),
        c._anisotropyNoise === void 0 && (c._anisotropyNoise = 0),
        c._anisotropyDirectionMode === void 0 && (c._anisotropyDirectionMode = "DIRECTION"),
        d.materialObject.needsUpdate = !0,
        !0
    }
    tryComputeTangents(d, o) {
        if (d.geometry && !d.geometry.attributes.tangent) {
            let c = !0;
            d.geometry.index && d.geometry.attributes.position && d.geometry.attributes.normal && d.geometry.attributes.uv || (c = !1),
            c ? d.geometry.computeTangents() : o.map(h => {
                var _;
                !((_ = h == null ? void 0 : h.userData) === null || _ === void 0) && _._isAnisotropic && (h.userData._isAnisotropic = !1)
            }
            )
        }
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsAnisotropyExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this._defines = {
            ANISOTROPY_DEBUG: !1
        },
        this._uniforms = {
            anisotropyFactor: {
                value: 1
            },
            anisotropyNoise: {
                value: 1
            },
            anisotropyDirection: {
                value: 1
            },
            anisotropyDirectionMap: {
                value: null
            },
            anisotropy2MapUvTransform: {
                value: new three_module.dwI
            },
            frameCount: {
                value: 0
            }
        },
        this.materialExtension = {
            shaderExtender: (d, o, c) => {
                var h;
                if (!this.enabled || !o.materialObject.userData._isAnisotropic)
                    return;
                const _ = (h = o.materialObject.userData) === null || h === void 0 ? void 0 : h._anisotropyDirectionMap
                  , b = fe$1`
                //#if ANISOTROPY_ENABLED
                ${randomHelpers}
            ` + (_ ? getTexelDecoding("anisotropyDirectionMap", _.colorSpace) : "") + `
`;
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <common>", b, {
                    append: !0
                }),
                d.fragmentShader = d.fragmentShader.replace("#include <lights_fragment_begin>", three_module.vxI.lights_fragment_begin),
                d.fragmentShader = shaderReplaceString(shaderReplaceString(d.fragmentShader, "IncidentLight directLight;", anisotropyTBN, {
                    prepend: !0
                }), "RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight )", "RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight, anisotropicT, anisotropicB )", {
                    replaceAll: !0
                });
                let _e = shaderReplaceString(three_module.vxI.lights_physical_pars_fragment, "void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {", "void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, const in vec3 anisotropicT, const in vec3 anisotropicB ) {");
                _e = shaderReplaceString(_e, "vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {", anisotropyBsdf + `
`, {
                    prepend: !0
                }),
                _e = shaderReplaceString(_e, "BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material )", "BRDF_GGX_Anisotropy( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularF90, material.roughness, anisotropicT, anisotropicB )"),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <lights_physical_pars_fragment>", _e),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <normal_fragment_begin>", three_module.vxI.normal_fragment_begin),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )", "#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) || defined( USE_TANGENT )");
                let nt = fe$1`
                #if defined( USE_ENVMAP )
                vec3 anisotropyBentNormal = indirectAnisotropyBentNormal(geometryNormal, geometryViewDir, material.roughness, anisotropicT, anisotropicB);
                #endif
            ` + three_module.vxI.lights_fragment_maps;
                nt = shaderReplaceString(nt, "getIBLIrradiance( geometryNormal )", "getIBLIrradiance( anisotropyBentNormal )"),
                nt = shaderReplaceString(nt, "getIBLRadiance( geometryViewDir, geometryNormal, material.roughness )", "getIBLRadiance( geometryViewDir, anisotropyBentNormal, material.roughness )"),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <lights_fragment_maps>", nt),
                d.vertexShader = shaderReplaceString(d.vertexShader, "#include <uv_pars_vertex>", `
#if defined(ANISOTROPY_ENABLED) && ANISOTROPY_ENABLED > 0
    varying vec2 vAnisotropy2MapUv;
    uniform mat3 anisotropy2MapUvTransform;
#endif
                `, {
                    prepend: !0
                }),
                d.vertexShader = shaderReplaceString(d.vertexShader, "#include <uv_vertex>", `
#if defined(ANISOTROPY_ENABLED) && ANISOTROPY_ENABLED > 0
    vAnisotropy2MapUv = ( anisotropy2MapUvTransform * vec3( uv, 1 ) ).xy;
#endif
                `, {
                    prepend: !0
                }),
                d.defines.USE_ANISOTROPY_BRDF = "",
                d.defines.USE_UV = "",
                d.vertexTangents = !0
            }
            ,
            onObjectRender: (d, o) => {
                var c;
                const h = o.materialObject.userData;
                if (!(h != null && h._isAnisotropic))
                    return;
                const _ = d;
                if (!_.isMesh || !_.geometry)
                    return;
                _.geometry.attributes.tangent ? _.geometry.userData.__forceUseTangent = !0 : console.error("WebGi AnisotropyPlugin - No tangents on the geometry, cannot use anisotropy. Make sure the tangents are computed before rendering the model. The model will render as black.", _),
                this._uniforms.anisotropyFactor.value = h._anisotropyFactor,
                this._uniforms.anisotropyNoise.value = h._anisotropyNoise,
                this._uniforms.anisotropyDirection.value = h._anisotropyDirection;
                const b = !((c = h._anisotropyDirectionMap) === null || c === void 0) && c.isTexture ? h._anisotropyDirectionMap : null;
                this._uniforms.anisotropyDirectionMap.value = b,
                b && (b.updateMatrix(),
                this._uniforms.anisotropy2MapUvTransform.value.copy(b.matrix));
                let _e = this.enabled ? 1 : 0;
                o.materialObject.defines.ANISOTROPY_ENABLED !== _e && (o.materialObject.defines.ANISOTROPY_ENABLED = _e,
                o.materialObject.needsUpdate = !0),
                _e = +this._defines.ANISOTROPY_DEBUG,
                o.materialObject.defines.ANISOTROPY_DEBUG !== _e && (o.materialObject.defines.ANISOTROPY_DEBUG = _e,
                o.materialObject.needsUpdate = !0),
                _e = h._anisotropyDirectionMode,
                this._uniforms.anisotropyDirectionMap.value || (_e = "CONSTANT"),
                _e = _e === "DIRECTION" ? 2 : _e === "ROTATION" ? 1 : 0,
                o.materialObject.defines.ANISOTROPY_TEX_MODE !== _e && (o.materialObject.defines.ANISOTROPY_TEX_MODE = _e,
                o.materialObject.needsUpdate = !0)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c, h;
                return (this.enabled ? "1" : "0") + (!((o = d.materialObject.userData) === null || o === void 0) && o._isAnisotropic ? "1" : "0") + ((h = (c = d.materialObject.userData) === null || c === void 0 ? void 0 : c._anisotropyDirectionMap) === null || h === void 0 ? void 0 : h.uuid)
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2,
            updaters: () => {
                var d;
                return [(d = this._viewer) === null || d === void 0 ? void 0 : d.renderer]
            }
            ,
            getUiConfig: d => {
                const o = this._viewer
                  , c = this.makeAnisotropic
                  , h = {
                    type: "folder",
                    label: "Anisotropy",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            return d.materialObject.userData._isAnisotropic || !1
                        },
                        set value(_) {
                            var b;
                            _ !== d.materialObject.userData._isAnisotropic && (_ ? c(d) || o.alert("One or more geometries cannot be made anisotropic.") : (d.materialObject.userData._isAnisotropic = !1,
                            d.materialObject.needsUpdate = !0),
                            (b = h.uiRefresh) === null || b === void 0 || b.call(h, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, {
                        type: "slider",
                        label: "Factor",
                        bounds: [-2, 2],
                        hidden: () => !d.materialObject.userData._isAnisotropic,
                        property: [d.materialObject.userData, "_anisotropyFactor"],
                        onChange: this.setDirty
                    }, {
                        type: "slider",
                        label: "Noise",
                        bounds: [0, 2],
                        hidden: () => !d.materialObject.userData._isAnisotropic,
                        property: [d.materialObject.userData, "_anisotropyNoise"],
                        onChange: this.setDirty
                    }, {
                        type: "image",
                        label: "Texture",
                        hidden: () => !d.materialObject.userData._isAnisotropic,
                        property: [d.materialObject.userData, "_anisotropyDirectionMap"],
                        onChange: () => {
                            d.materialObject.needsUpdate = !0,
                            this.setDirty()
                        }
                    }, makeSamplerUi(d.materialObject.userData, "_anisotropyDirectionMap", "Sampler", () => !d.materialObject.userData._isAnisotropic || d.materialObject.userData._anisotropyDirectionMode === "CONSTANT", () => d.setDirty && d.setDirty()), {
                        type: "dropdown",
                        label: "Mode",
                        hidden: () => !d.materialObject.userData._isAnisotropic,
                        property: [d.materialObject.userData, "_anisotropyDirectionMode"],
                        children: ["CONSTANT", "ROTATION", "DIRECTION"].map(_ => ({
                            label: _
                        })),
                        onChange: () => {
                            d.materialObject.needsUpdate = !0,
                            this.setDirty()
                        }
                    }]
                };
                return h
            }
            ,
            onMaterialUpdate: d => {
                var o, c;
                !((o = d.userData) === null || o === void 0) && o._isAnisotropic && ((c = d.userData.__appliedMeshes) === null || c === void 0 || c.forEach(h => this.tryComputeTangents(h, [d])))
            }
            ,
            onRegister: d => {
                var o, c;
                !((o = d.userData) === null || o === void 0) && o._isAnisotropic && ((c = d.userData.__appliedMeshes) === null || c === void 0 || c.forEach(h => this.tryComputeTangents(h, [d])))
            }
            ,
            onAddToMesh: d => {
                const o = d
                  , c = Array.isArray(o.material) ? o.material : [o.material];
                c.find(h => {
                    var _;
                    return (_ = h == null ? void 0 : h.userData) === null || _ === void 0 ? void 0 : _._isAnisotropic
                }
                ) && this.tryComputeTangents(o, c)
            }
        },
        this.setDirty = () => {
            var d, o, c;
            (o = (d = this.materialExtension).setDirty) === null || o === void 0 || o.call(d),
            (c = this._viewer) === null || c === void 0 || c.setDirty()
        }
        ,
        this.makeSelectedAnisotropic = () => {
            var d, o, c;
            const h = (c = (o = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPlugin(PickingPlugin)) === null || o === void 0 ? void 0 : o.getSelectedObject()) === null || c === void 0 ? void 0 : c.material;
            return (h == null ? void 0 : h.assetType) === "material" && this.makeAnisotropic(h)
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsAnisotropyExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
AnisotropyPlugin.PluginType = "AnisotropyPlugin",
AnisotropyPlugin.ANISOTROPY_GLTF_EXTENSION = "WEBGI_materials_anisotropy",
AnisotropyPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], AnisotropyPlugin.prototype, "enabled", void 0),
AnisotropyPlugin_decorate([uiButton("Make Anisotropy", d => ({
    hidden: () => {
        var o;
        return !(!((o = d._viewer) === null || o === void 0) && o.getPlugin(PickingPlugin))
    }
}))], AnisotropyPlugin.prototype, "makeSelectedAnisotropic", void 0),
AnisotropyPlugin = AnisotropyPlugin_decorate([uiFolder("Anisotropy Materials")], AnisotropyPlugin);
class GLTFMaterialsAnisotropyExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = AnisotropyPlugin.ANISOTROPY_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        var h, _, b;
        const _e = this.parser
          , nt = _e.json.materials[o];
        if (!nt.extensions || !nt.extensions[this.name])
            return Promise.resolve();
        const it = []
          , at = nt.extensions[this.name];
        c.userData || (c.userData = {}),
        c.userData._isAnisotropic = !0,
        c.userData._anisotropyFactor = (h = at.anisotropyFactor) !== null && h !== void 0 ? h : 0,
        c.userData._anisotropyNoise = (b = (_ = at.anisotropyNoiseFactor) !== null && _ !== void 0 ? _ : at.anisotropyNoise) !== null && b !== void 0 ? b : 0;
        let {anisotropyDirectionMode: ut, anisotropyDirection: pt} = at;
        return ut || (ut = at.anisotropyTextureMode),
        pt || (pt = at.anisotropyRotation),
        c.userData._anisotropyDirectionMode = ut && typeof (pt == null ? void 0 : pt.index) == "number" ? ut : "CONSTANT",
        ut === "ROTATION" || ut === "DIRECTION" ? it.push(_e.assignTexture(c.userData, "_anisotropyDirectionMap", pt).then(ht => {
            ht.colorSpace = three_module.er$
        }
        )) : c.userData._anisotropyDirection = pt ?? 0,
        Promise.all(it)
    }
    afterRoot(o) {
        var c;
        return (c = o.scene) === null || c === void 0 || c.traverse(h => {
            var _, b;
            if (!(!((b = (_ = h.material) === null || _ === void 0 ? void 0 : _.userData) === null || b === void 0) && b._isAnisotropic))
                return;
            const _e = h.geometry;
            _e.attributes.tangent || (_e.computeTangents(),
            _e.attributes.tangent.needsUpdate = !0)
        }
        ),
        null
    }
}
const glTFMaterialsAnisotropyExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._isAnisotropic || (o.userData._anisotropyFactor || 0) < .001)
            return;
        c.extensions = c.extensions || {};
        const h = {};
        if (h.anisotropyFactor = o.userData._anisotropyFactor || 1,
        h.anisotropyNoiseFactor = o.userData._anisotropyNoise || 0,
        h.anisotropyDirectionMode = o.userData._anisotropyDirectionMode || "CONSTANT",
        d.checkEmptyMap(o.userData._anisotropyDirectionMap) && h.anisotropyDirectionMode !== "CONSTANT") {
            const _ = {
                index: d.processTexture(o.userData._anisotropyDirectionMap)
            };
            d.applyTextureTransform(_, o.userData._anisotropyDirectionMap),
            h.anisotropyDirection = _
        } else
            h.anisotropyDirectionMode = "CONSTANT",
            h.anisotropyDirection = o.userData._anisotropyDirection || 0;
        c.extensions[AnisotropyPlugin.ANISOTROPY_GLTF_EXTENSION] = h,
        d.extensionsUsed[AnisotropyPlugin.ANISOTROPY_GLTF_EXTENSION] = !0
    }
});
var FragmentClippingExtensionPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, FragmentClippingExtensionPlugin_1;
let FragmentClippingExtensionPlugin = FragmentClippingExtensionPlugin_1 = class extends AViewerPlugin {
    static AddFragmentClipping(d, o, c, h, _) {
        var b, _e, nt;
        const it = (b = d.materialObject) === null || b === void 0 ? void 0 : b.userData;
        if (!it)
            return !1;
        it._fragmentClippingExt || (it._fragmentClippingExt = {});
        const at = it._fragmentClippingExt;
        return at.clipEnabled = !0,
        at.clipPosition === void 0 && (at.clipPosition = (_e = o == null ? void 0 : o.toArray()) !== null && _e !== void 0 ? _e : [0, 0, 0, 0]),
        at.clipParams === void 0 && (at.clipParams = (nt = c == null ? void 0 : c.toArray()) !== null && nt !== void 0 ? nt : [1, 0, 0, 0]),
        at.clipMode === void 0 && (at.clipMode = h ?? FragmentClippingMode.Circle),
        at.clipInvert === void 0 && (at.clipInvert = _ != null && _),
        d.materialObject.isMaterial && (d.needsUpdate = !0),
        !0
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsFragmentClippingExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin, GBufferPlugin],
        this._plane = new three_module.Zcv,
        this._viewNormalMatrix = new three_module.dwI,
        this._defines = {
            FRAG_CLIPPING_DEBUG: !1
        },
        this._uniforms = {
            fragClippingPosition: {
                value: new three_module.IUQ
            },
            fragClippingParams: {
                value: new three_module.IUQ
            },
            fragClippingCamAspect: {
                value: 1
            }
        },
        this.materialExtension = {
            parsFragmentSnippet: (d, o) => {
                var c;
                return this.enabled && (!((c = o == null ? void 0 : o.materialObject.userData._fragmentClippingExt) === null || c === void 0) && c.clipEnabled) ? simpleCameraHelpers + fe$1`
uniform vec4 fragClippingPosition;
uniform vec4 fragClippingParams;
uniform float fragClippingCamAspect;
#if FRAG_CLIPPING_MODE == ${FragmentClippingMode.Circle}
float fragClippingCircle(){
    vec2 pos = viewToScreen(vViewPosition.xyz).xy;
    float radius = fragClippingParams.x;
    vec2 center = fragClippingPosition.xy;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    return length(pos - center) - radius;
}
#elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Ellipse}
float fragClippingEllipse(){
    vec2 pos = viewToScreen(vViewPosition.xyz).xy;
    vec2 radius = fragClippingParams.xy;
    vec2 center = fragClippingPosition.xy;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    return length((pos - center) / radius) - 1.0;
}
#elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Rectangle}
float fragClippingRectangle(){
    vec2 pos = viewToScreen(vViewPosition.xyz).xy;
    vec2 radius = fragClippingParams.xy;
    vec2 center = fragClippingPosition.xy;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    vec2 d = abs(pos - center) - radius;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
}
#elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Plane}
float fragClippingPlane(){
    vec3 pos = vViewPosition.xyz;
    vec3 normal = fragClippingParams.xyz;
    float d = dot(pos, normal) - fragClippingParams.w;
    return d;
}
#elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Sphere}
float fragClippingSphere(){
    vec3 pos = vViewPosition.xyz;
    vec3 center = fragClippingPosition.xyz;
    float radius = fragClippingParams.x;
    pos.y /= fragClippingCamAspect;
    center.y /= fragClippingCamAspect;
    return length(pos - center) - radius;
}
#endif
        ` : ""
            }
            ,
            shaderExtender: (d, o, c) => {
                var h;
                this.enabled && (!((h = o.materialObject.userData._fragmentClippingExt) === null || h === void 0) && h.clipEnabled) && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker mainStart", fe$1`
    float fragClippingDist = 0.0;
    #if FRAG_CLIPPING_MODE == ${FragmentClippingMode.Circle}
    fragClippingDist = fragClippingCircle();
    #elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Ellipse}
    fragClippingDist = fragClippingEllipse();
    #elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Rectangle}
    fragClippingDist = fragClippingRectangle();
    #elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Plane}
    fragClippingDist = fragClippingPlane();
    #elif FRAG_CLIPPING_MODE == ${FragmentClippingMode.Sphere}
    fragClippingDist = fragClippingSphere();
    #endif
    #if FRAG_CLIPPING_DEBUG
    gl_FragColor = vec4(max(fragClippingDist, 0.0), 0.0, 0.0, 1.0); 
//    gl_FragColor = vec4(vViewPosition.xyz, 1.0);
    #include <colorspace_fragment>
    return;
    #endif
    
    #if FRAG_CLIPPING_INVERSE == 1
    if (fragClippingDist > 0.0) discard;
    #else
    if (fragClippingDist < 0.0) discard;
    #endif
            `, {
                    append: !0
                }))
            }
            ,
            onObjectRender: (d, o) => {
                var c, h, _, b, _e, nt;
                let it = (c = o.materialObject.userData) === null || c === void 0 ? void 0 : c._fragmentClippingExt;
                if (o.materialObject.userData.isGBufferMaterial && d && (it = (_ = (h = d.material) === null || h === void 0 ? void 0 : h.userData) === null || _ === void 0 ? void 0 : _._fragmentClippingExt),
                !(it != null && it.clipEnabled))
                    return;
                if (this._uniforms.fragClippingPosition.value.fromArray(it.clipPosition),
                it.clipMode === FragmentClippingMode.Plane) {
                    const ut = (b = this._viewer) === null || b === void 0 ? void 0 : b.scene.activeCamera.cameraObject.matrixWorldInverse;
                    this._plane.normal.set(it.clipParams[0], it.clipParams[1], it.clipParams[2]),
                    this._plane.constant = it.clipParams[3],
                    this._viewNormalMatrix.getNormalMatrix(ut),
                    this._plane.applyMatrix4(ut, this._viewNormalMatrix),
                    this._uniforms.fragClippingParams.value.set(this._plane.normal.x, this._plane.normal.y, this._plane.normal.z, this._plane.constant)
                } else
                    this._uniforms.fragClippingParams.value.fromArray(it.clipParams);
                ((_e = this._viewer) === null || _e === void 0 ? void 0 : _e.scene.activeCamera.cameraObject)instanceof three_module.ubm ? this._uniforms.fragClippingCamAspect.value = (nt = this._viewer) === null || nt === void 0 ? void 0 : nt.scene.activeCamera.cameraObject.aspect : this._uniforms.fragClippingCamAspect.value = 1;
                let at = this.enabled ? 1 : 0;
                at = +this._defines.FRAG_CLIPPING_DEBUG,
                o.materialObject.defines.FRAG_CLIPPING_DEBUG !== at && (o.materialObject.defines.FRAG_CLIPPING_DEBUG = at,
                o.materialObject.needsUpdate = !0),
                at = +it.clipMode,
                o.materialObject.defines.FRAG_CLIPPING_MODE !== at && (o.materialObject.defines.FRAG_CLIPPING_MODE = at,
                o.materialObject.needsUpdate = !0),
                at = +it.clipInvert,
                o.materialObject.defines.FRAG_CLIPPING_INVERSE !== at && (o.materialObject.defines.FRAG_CLIPPING_INVERSE = at,
                o.materialObject.needsUpdate = !0)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c;
                return (this.enabled ? "1" : "0") + (!((c = (o = d.materialObject.userData) === null || o === void 0 ? void 0 : o._fragmentClippingExt) === null || c === void 0) && c.clipEnabled ? "1" : "0")
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2 || d.userData.isGBufferMaterial,
            updaters: () => [],
            getUiConfig: d => {
                const o = this._viewer
                  , c = {
                    type: "folder",
                    label: "FragmentClipping",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        getValue: () => {
                            var h;
                            return ((h = d.materialObject.userData._fragmentClippingExt) === null || h === void 0 ? void 0 : h.clipEnabled) || !1
                        }
                        ,
                        setValue: h => {
                            var _, b;
                            h !== ((_ = d.materialObject.userData._fragmentClippingExt) === null || _ === void 0 ? void 0 : _.clipEnabled) && (h ? FragmentClippingExtensionPlugin_1.AddFragmentClipping(d.materialObject) || o.alert("Cannot add fragment clipping extension.") : d.materialObject.userData._fragmentClippingExt && (d.materialObject.userData._fragmentClippingExt.clipEnabled = !1,
                            d.materialObject.needsUpdate = !0),
                            (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0))
                        }
                        ,
                        onChange: this.setDirty
                    }, () => ({
                        type: "dropdown",
                        label: "Mode",
                        children: Object.entries(FragmentClippingMode).map(h => ({
                            label: h[0],
                            value: h[1]
                        })),
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._fragmentClippingExt) === null || h === void 0) && h.clipEnabled)
                        }
                        ,
                        property: [d.materialObject.userData._fragmentClippingExt, "clipMode"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "vec4",
                        label: "Position",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._fragmentClippingExt) === null || h === void 0) && h.clipEnabled)
                        }
                        ,
                        property: [d.materialObject.userData._fragmentClippingExt, "clipPosition"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "vec4",
                        label: "Params",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._fragmentClippingExt) === null || h === void 0) && h.clipEnabled)
                        }
                        ,
                        property: [d.materialObject.userData._fragmentClippingExt, "clipParams"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "toggle",
                        label: "Invert",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._fragmentClippingExt) === null || h === void 0) && h.clipEnabled)
                        }
                        ,
                        property: [d.materialObject.userData._fragmentClippingExt, "clipInvert"],
                        onChange: this.setDirty
                    })]
                };
                return c
            }
        },
        this.setDirty = () => {
            var d, o, c;
            (o = (d = this.materialExtension).setDirty) === null || o === void 0 || o.call(d),
            (c = this._viewer) === null || c === void 0 || c.setDirty()
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b, _e, nt;
        await super.onAdded(d);
        const it = d.getPlugin(AssetManagerPlugin);
        (o = it == null ? void 0 : it.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = it == null ? void 0 : it.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = it == null ? void 0 : it.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsFragmentClippingExtensionExport),
        (nt = (_e = d.getPlugin(GBufferPlugin)) === null || _e === void 0 ? void 0 : _e.material) === null || nt === void 0 || nt.registerMaterialExtensions([this.materialExtension])
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
var FragmentClippingMode;
FragmentClippingExtensionPlugin.PluginType = "FragmentClippingExtensionPlugin1",
FragmentClippingExtensionPlugin.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION = "WEBGI_materials_fragment_clipping_extension",
FragmentClippingExtensionPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], FragmentClippingExtensionPlugin.prototype, "enabled", void 0),
FragmentClippingExtensionPlugin = FragmentClippingExtensionPlugin_1 = FragmentClippingExtensionPlugin_decorate([uiFolder("FragmentClipping Materials")], FragmentClippingExtensionPlugin),
function(d) {
    d[d.Circle = 0] = "Circle",
    d[d.Ellipse = 1] = "Ellipse",
    d[d.Rectangle = 2] = "Rectangle",
    d[d.Plane = 3] = "Plane",
    d[d.Sphere = 4] = "Sphere"
}(FragmentClippingMode || (FragmentClippingMode = {}));
class GLTFMaterialsFragmentClippingExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = FragmentClippingExtensionPlugin.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        return c.userData || (c.userData = {}),
        FragmentClippingExtensionPlugin.AddFragmentClipping(c),
        c.userData._fragmentClippingExt = deserializeObject(_, c.userData._fragmentClippingExt, !1, {}),
        Promise.resolve()
    }
}
const glTFMaterialsFragmentClippingExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._fragmentClippingExt || !o.userData._fragmentClippingExt.clipEnabled)
            return;
        c.extensions = c.extensions || {};
        const h = serializeObject(o.userData._fragmentClippingExt, !1);
        c.extensions[FragmentClippingExtensionPlugin.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION] = h,
        d.extensionsUsed[FragmentClippingExtensionPlugin.FRAGMENT_CLIPPING_EXTENSION_GLTF_EXTENSION] = !0
    }
});
var hdriGroundProj = `#ifdef HDRi_GROUND_PROJ
float intersectPlane1(const in vec3 r0,const in vec3 rd,const in vec3 n,const in vec3 p0){float t=dot(p0-r0,n)/(dot(n,rd)+1e-6);return t<0.?1000.:t;}float intersectSphere1(in vec3 ro,in vec3 rd,in vec3 sph,in float rad){vec3 oc=ro-sph;float b=dot(oc,rd);float c=dot(oc,oc)-rad*rad;float t=b*b-c;return t<0.?t:-b+sqrt(t);}
#define PI_HALF  1.5707963267948966
uniform float worldRadius;uniform float tripodHeight;uniform vec3 originPosition;vec3 hdriProject(){vec3 p=normalize(vWorldDirection);vec3 camPos=cameraPosition;camPos.y-=tripodHeight;float t=intersectSphere1(camPos,p,originPosition,worldRadius);if(t>0.){float t2=intersectPlane1(camPos,p,vec3(0,-1,0),originPosition+vec3(0.,-tripodHeight,0.));p=(camPos+min(t,t2)*p)/worldRadius;}else p=vec3(0.,1.,0.);return p;}
#endif
`
  , HDRiGroundPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let HDRiGroundPlugin = class extends AViewerPlugin {
    constructor(d=!1) {
        super(),
        this.enabled = !1,
        this.worldRadius = 100,
        this.tripodHeight = 10,
        this.originPosition = new three_module.Pq0(0,0,0),
        this._paramsChanged = this._paramsChanged.bind(this),
        this.enabled = d,
        this.addEventListener("deserialize", this._paramsChanged)
    }
    _paramsChanged() {
        var d, o, c, h;
        if (!this._viewer)
            return;
        const _ = this._viewer.scene.background;
        if (this.enabled && _ !== this._viewer.scene.environment && _ !== "environment")
            if (_ && _.isDataTexture)
                _.mapping = three_module.wfO;
            else if (confirm("Background must be same as environment, do you want to change it?")) {
                const nt = this._viewer.getPluginByType("SimpleBackgroundEnvUiPlugin1");
                nt ? (nt.envmapBg = !0,
                (o = (d = nt.uiConfig).uiRefresh) === null || o === void 0 || o.call(d, "postFrame", !0)) : this._viewer.scene.setBackground("environment")
            } else
                this.enabled = !1;
        const b = (c = this._viewer.renderer.rendererObject.background.getBoxMesh2()) === null || c === void 0 ? void 0 : c.material
          , _e = (h = b == null ? void 0 : b.uniforms) !== null && h !== void 0 ? h : three_module.zkh.backgroundCube.uniforms;
        _e.tripodHeight || (_e.tripodHeight = {
            value: 1
        }),
        _e.worldRadius || (_e.worldRadius = {
            value: 1
        }),
        _e.originPosition || (_e.originPosition = {
            value: new three_module.Pq0
        }),
        _e.tripodHeight.value = this.tripodHeight,
        _e.worldRadius.value = this.worldRadius,
        _e.originPosition.value.copy(this.originPosition),
        b && (!this.enabled && b.defines.HDRi_GROUND_PROJ ? delete b.defines.HDRi_GROUND_PROJ : this.enabled && (b.defines.HDRi_GROUND_PROJ = "1"),
        b.needsUpdate = !0),
        this._viewer.setDirty()
    }
    async onAdded(d) {
        var o, c, h;
        await super.onAdded(d),
        !((h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.renderer) === null || c === void 0 ? void 0 : c.rendererObject) === null || h === void 0) && h.background.getBoxMesh() && d.console.error("HDRi Ground Plugin must be added before setting any cube or env map"),
        three_module.zkh.backgroundCube.fragmentShader.includes("#ifdef HDRi_GROUND_PROJ") || (three_module.zkh.backgroundCube.fragmentShader = shaderReplaceString(three_module.zkh.backgroundCube.fragmentShader, "void main() {", hdriGroundProj, {
            prepend: !0
        }),
        three_module.zkh.backgroundCube.fragmentShader = shaderReplaceString(three_module.zkh.backgroundCube.fragmentShader, "vec3 vReflect = vWorldDirection;", `
vec3 vReflect = 
#ifdef HDRi_GROUND_PROJ
hdriProject()
#else
vWorldDirection
#endif
;
`)),
        d.scene.addEventListener("environmentChanged", this._paramsChanged)
    }
}
;
HDRiGroundPlugin.PluginType = "HDRiGroundPlugin",
HDRiGroundPlugin_decorate([serialize(), x$1(HDRiGroundPlugin.prototype._paramsChanged), uiToggle("Enabled")], HDRiGroundPlugin.prototype, "enabled", void 0),
HDRiGroundPlugin_decorate([serialize(), x$1(HDRiGroundPlugin.prototype._paramsChanged), uiSlider("World Radius", [1, 1e3], .01)], HDRiGroundPlugin.prototype, "worldRadius", void 0),
HDRiGroundPlugin_decorate([serialize(), x$1(HDRiGroundPlugin.prototype._paramsChanged), uiSlider("Tripod height", [0, 50], .01)], HDRiGroundPlugin.prototype, "tripodHeight", void 0),
HDRiGroundPlugin_decorate([serialize(), x$1(HDRiGroundPlugin.prototype._paramsChanged), uiVector("Origin Position", void 0, .001, d => ({
    onChange: d._paramsChanged
}))], HDRiGroundPlugin.prototype, "originPosition", void 0),
HDRiGroundPlugin = HDRiGroundPlugin_decorate([uiFolder("HDRi Ground")], HDRiGroundPlugin);
var SSContactShadows_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, SSContactShadows_1;
let SSContactShadows = SSContactShadows_1 = class extends AViewerPlugin {
    constructor(d=!0) {
        super(),
        this.enabled = !0,
        this.radius = .015,
        this.intensity = 1,
        this.tolerance = 1.5,
        this._defines = {},
        this.onlySSCSDebug = !1,
        this.stepCount = 2,
        this.dependencies = [GBufferPlugin, AssetManagerPlugin],
        this.materialExtension = {
            shaderExtender: (o, c, h) => {
                if (!o.defines.SSCS_ENABLED)
                    return;
                const _ = fe$1`
                #ifndef D_sceneBoundingRadius
                #define D_sceneBoundingRadius
                uniform float sceneBoundingRadius;
                #endif
                float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, vec3 lightDirection ) {
                    vec3 ray_origin_view = -vViewPosition;
                    float rnd = interleavedGradientNoise(gl_FragCoord.xy, frameCount+34.);
                    float cameraDist = length(cameraPositionWorld);
//                    float radius = mix((cameraNearFar.y) + ray_origin_view.z, -ray_origin_view.z - cameraNearFar.x, rnd * 0.5 + 0.5)*sscsRadius;
                    float radius = mix((cameraDist + sceneBoundingRadius) + ray_origin_view.z, -ray_origin_view.z - max(0.0, cameraDist - sceneBoundingRadius), rnd * 0.5 + 0.5)*sscsRadius;
                    vec3 state = vec3(1.,(rnd+0.5)/float(SSCS_STEP_COUNT),2.);
                    traceRay(ray_origin_view, normalize(lightDirection) * radius, sscsTolerance * radius * 2., state, SSCS_STEP_COUNT);
                    state.z = state.z > 0.99 ? 1. : max(0.,min(state.z * state.z * (1.-sscsIntensity), 1.));
                    
                #if defined(SSCS_DEBUG) && SSCS_DEBUG > 0
                    return state.z;
                #endif
            `
                  , b = `
#if SSCS_ENABLED

    uniform float sscsIntensity;
    uniform float sscsRadius;
    uniform float sscsTolerance;

    ${basicHelpers}
    
    #define THREE_PACKING_INCLUDED
    ${cameraHelpers}
    
    ${unpackGbuffer}
    ${randomHelpers}
    
    ${ssrt}

#endif
            
            ` + three_module.vxI.shadowmap_pars_fragment.replace("float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {", `${_}
`).replace("return shadow;", "return min(shadow, state.z);");
                o.fragmentShader = o.fragmentShader.replace("#include <shadowmap_pars_fragment>", b),
                o.fragmentShader = o.fragmentShader.replace("#include <lights_fragment_begin>", three_module.vxI.lights_fragment_begin),
                o.fragmentShader = shaderReplaceString(o.fragmentShader, "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;", "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ], directLight.direction ) : 1.0;"),
                o.fragmentShader = shaderReplaceString(o.fragmentShader, "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;", "directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ], directLight.direction ) : 1.0;")
            }
            ,
            onObjectRender: (o, c, h) => {
                var _, b;
                const _e = c.materialObject;
                let nt = !this.enabled || h.userData.screenSpaceRendering === !1 || !((_ = _e.userData) === null || _ === void 0) && _.sscsDisabled || !((b = _e.userData) === null || b === void 0) && b.pluginsDisabled ? 0 : 1;
                _e.defines.SSCS_ENABLED !== nt && (_e.defines.SSCS_ENABLED = nt,
                _e.needsUpdate = !0),
                nt = this._defines.SSCS_STEP_COUNT,
                _e.defines.SSCS_STEP_COUNT !== nt && (_e.defines.SSCS_STEP_COUNT = nt,
                _e.needsUpdate = !0),
                nt = +this._defines.SSCS_DEBUG,
                _e.defines.SSCS_DEBUG !== nt && (_e.defines.SSCS_DEBUG = nt,
                _e.needsUpdate = !0)
            }
            ,
            parsFragmentSnippet: () => `
`,
            extraUniforms: {
                ...SSContactShadows_1._uniforms
            },
            computeCacheKey: o => this.enabled ? "1" : "0",
            isCompatible: o => o.isMeshStandardMaterial2,
            updaters: () => {
                var o, c, h, _, b;
                return [(o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(GBufferPlugin), (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(ProgressivePlugin), (h = this._viewer) === null || h === void 0 ? void 0 : h.scene.renderCamera, (_ = this._viewer) === null || _ === void 0 ? void 0 : _.renderer, (b = this._viewer) === null || b === void 0 ? void 0 : b.scene]
            }
        },
        this.enabled = d,
        this.userData = {
            setDirty: () => {
                var o;
                (o = this._viewer) === null || o === void 0 || o.setDirty()
            }
        }
    }
    async onAdded(d) {
        var o, c;
        await super.onAdded(d),
        (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.registerMaterialExtension(this.materialExtension)
    }
    async onRemove(d) {
        var o, c;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        super.onRemove(d)
    }
}
;
SSContactShadows.PluginType = "SSContactShadows",
SSContactShadows._uniforms = {
    tNormalDepth: {
        value: null
    },
    frameCount: {
        value: 0
    },
    projection: {
        value: new three_module.kn4
    },
    cameraPositionWorld: {
        value: new three_module.Pq0
    },
    cameraNearFar: {
        value: new three_module.I9Y(.1,1e3)
    },
    sceneBoundingRadius: {
        value: 0
    }
},
SSContactShadows_decorate([uiToggle("Enabled"), serialize()], SSContactShadows.prototype, "enabled", void 0),
SSContactShadows_decorate([uniform({
    uniforms: SSContactShadows._uniforms,
    propKey: "sscsRadius"
}), uiSlider("Radius", [1e-4, .1], 1e-4), serialize()], SSContactShadows.prototype, "radius", void 0),
SSContactShadows_decorate([uniform({
    uniforms: SSContactShadows._uniforms,
    propKey: "sscsIntensity"
}), uiSlider("Intensity", [1e-4, 1], 1e-4), serialize()], SSContactShadows.prototype, "intensity", void 0),
SSContactShadows_decorate([uniform({
    uniforms: SSContactShadows._uniforms,
    propKey: "sscsTolerance"
}), uiSlider("Tolerance", [.1, 5]), serialize()], SSContactShadows.prototype, "tolerance", void 0),
SSContactShadows_decorate([matDefine("SSCS_DEBUG", void 0, !0), uiToggle("Debug only SSCS"), serialize()], SSContactShadows.prototype, "onlySSCSDebug", void 0),
SSContactShadows_decorate([matDefine("SSCS_STEP_COUNT", void 0, !0), uiSlider("Step count", [1, 8], 1), serialize()], SSContactShadows.prototype, "stepCount", void 0),
SSContactShadows = SSContactShadows_1 = SSContactShadows_decorate([uiFolder("Screen Space Contact Shadows")], SSContactShadows);
var cubeNormalVert = `varying vec3 vNormal;varying vec3 vecPosition;uniform mat4 offsetMatrixInv;uniform vec3 offsetCenter;
#include <morphtarget_pars_vertex>
void main(){vNormal=normalize((offsetMatrixInv*vec4(normal,0.)).xyz);
#include <begin_vertex>
transformed-=offsetCenter;
#include <morphtarget_vertex>
vec4 offsetPos=offsetMatrixInv*vec4(transformed,1.);vecPosition=(modelMatrix*offsetPos).xyz;gl_Position=projectionMatrix*modelViewMatrix*offsetPos;}`
  , cubeNormalFrag = "varying vec3 vNormal;varying vec3 vecPosition;uniform float radius;void main(){vec3 color=normalize(vNormal);color=color*0.5+0.5;gl_FragColor=vec4(color.x,color.y,color.z,length(vecPosition)/radius);}";
class CubeNormalsCaptureHelper {
    constructor(o) {
        this._normalsCache = {},
        this._renderer = o,
        this._scene = new three_module.Z58,
        this._mesh = new three_module.eaF,
        this._mesh.frustumCulled = !1,
        this._scene.add(this._mesh),
        this._mesh.position.set(0, 0, 0),
        this._mesh.material = new NormalCaptureMaterial
    }
    dispose() {
        var o;
        (o = this._mesh.geometry) === null || o === void 0 || o.dispose(),
        this._mesh.material.dispose(),
        this.disposeAllTargets()
    }
    disposeTarget(o) {
        o.split(";").forEach(c => {
            var h;
            return (h = this._normalsCache[c]) === null || h === void 0 ? void 0 : h.dispose()
        }
        )
    }
    disposeAllTargets() {
        Object.values(this._normalsCache).forEach(o => o.dispose()),
        this._normalsCache = {}
    }
    hasCapturedNormalMap(o) {
        return !!o.userData._normalsCaptureMap
    }
    _getPrecisionType(o) {
        return o === "low" ? three_module.OUM : o === "medium" ? three_module.ix0 : o === "high" ? three_module.RQf : three_module.ix0
    }
    captureNormalMap(o, c, h=512, _="medium", b) {
        if (!o)
            throw "No geometry";
        if (this.hasCapturedNormalMap(o))
            return !1;
        const _e = c == null ? void 0 : c.split(";").find(at => this._normalsCache[at]);
        if (_e) {
            const at = this._normalsCache[_e];
            return c == null || c.split(";").forEach(ut => ut !== _e && (this._normalsCache[ut] = at)),
            at.width !== h && console.warn("last cacheKey normalMapRes mismatch, check model", h),
            o.userData._normalsCaptureMap = at,
            !1
        }
        const nt = this._renderer.createTargetCustom({
            width: h,
            height: h
        }, {
            minFilter: three_module.hxR,
            magFilter: three_module.hxR,
            generateMipmaps: !1,
            type: this._getPrecisionType(_)
        }, three_module.o6l);
        if (nt.attachedGeometries = [],
        nt.autoDispose = CubeNormalsCaptureHelper.AutoDisposeTargets,
        !nt)
            throw "Unable to create render target";
        const it = () => {
            var at;
            const ut = new three_module.F1T(1e-4,100,nt);
            this._scene.add(ut);
            const pt = o.userData.normalsCaptureOffsets;
            pt.center !== void 0 && this._mesh.material.uniforms.offsetCenter.value.fromArray(pt.center),
            pt.offsetMatrixInv !== void 0 && this._mesh.material.uniforms.offsetMatrixInv.value.fromArray(pt.offsetMatrixInv),
            pt.radius !== void 0 && (this._mesh.material.uniforms.radius.value = pt.radius),
            this._mesh.geometry = o,
            b != null && b.morphTargetInfluences && (!((at = o.morphAttributes) === null || at === void 0) && at.position) && (this._mesh.morphTargetInfluences = b.morphTargetInfluences,
            this._mesh.morphTargetDictionary = b.morphTargetDictionary);
            const ht = this._renderer.rendererObject.getClearColor(new three_module.Q1f)
              , _t = this._renderer.rendererObject.getClearAlpha();
            this._renderer.rendererObject.setClearColor(new three_module.Q1f(0,0,0), 1),
            ut.update(this._renderer.rendererObject, this._scene),
            this._renderer.rendererObject.setClearColor(ht, _t),
            this._mesh.morphTargetInfluences = void 0,
            this._mesh.morphTargetDictionary = void 0,
            this._scene.remove(ut),
            this._mesh.geometry = void 0,
            o.userData._normalsCaptureMap = nt
        }
        ;
        return it(),
        this._renderer.addEventListener("contextRestored", it),
        nt.attachedGeometries.push(o),
        o.addEventListener("dispose", () => {
            var at, ut;
            nt.attachedGeometries = (ut = (at = nt.attachedGeometries) === null || at === void 0 ? void 0 : at.filter(pt => pt !== o)) !== null && ut !== void 0 ? ut : [],
            delete o.userData._normalsCaptureMap,
            this._renderer.removeEventListener("contextRestored", it),
            nt.autoDispose && !nt.attachedGeometries.length && nt.dispose()
        }
        ),
        c == null || c.split(";").forEach(at => this._normalsCache[at] = nt),
        nt.addEventListener("dispose", () => {
            var at;
            c == null || c.split(";").forEach(ut => delete this._normalsCache[ut]),
            this._renderer.removeEventListener("contextRestored", it),
            (at = nt.attachedGeometries) === null || at === void 0 || at.forEach(ut => delete ut.userData._normalsCaptureMap)
        }
        ),
        !0
    }
    removeNormalMap(o) {
        o.userData._normalsCaptureMap && (o.userData._normalsCaptureMap.dispose(),
        delete o.userData._normalsCaptureMap)
    }
}
CubeNormalsCaptureHelper.AutoDisposeTargets = !0;
class NormalCaptureMaterial extends three_module.BKk {
    constructor() {
        super({
            vertexShader: cubeNormalVert,
            fragmentShader: cubeNormalFrag,
            side: three_module.$EB,
            clipping: !1,
            uniforms: {
                radius: {
                    value: 1
                },
                offsetMatrixInv: {
                    value: new three_module.kn4().identity()
                },
                offsetCenter: {
                    value: new three_module.Pq0
                }
            }
        })
    }
}
var diamond_frag = `varying vec3 vWorldNormal;varying vec3 vWorldPosition;varying vec3 vViewPosition;varying vec3 vNormal;varying vec2 vUv;uniform float radius;uniform vec3 centerOffset;
#ifdef USE_INSTANCING
varying mat4 vModelInstanceOffsetMatrix;varying mat4 vModelInstanceOffsetMatrixInv;
#define MODEL_OFFSET_MATRIX  vModelInstanceOffsetMatrix
#define INV_MODEL_OFFSET_MATRIX  vModelInstanceOffsetMatrixInv
#else
uniform mat4 modelOffsetMatrixInv;uniform mat4 modelOffsetMatrix;
#define MODEL_OFFSET_MATRIX  modelOffsetMatrix
#define INV_MODEL_OFFSET_MATRIX  modelOffsetMatrixInv
#endif
#ifdef USE_MORPHTARGETS
varying vec3 vCenterOffset;
#define CENTER_OFFSET  (centerOffset + vCenterOffset)
#else
#define CENTER_OFFSET  (centerOffset) 
#endif
uniform mat4 projectionMatrix;uniform samplerCube tCubeMapNormals;
#if ENV_MAP_TYPE == 0
uniform samplerCube envMap;
#elif ENV_MAP_TYPE == 1
uniform sampler2D envMap;
#endif
uniform float envMapIntensity;uniform float transmission;uniform vec2 transmissionSamplerSize;uniform sampler2D transmissionSamplerMap;uniform float refractiveIndex;uniform float rIndexDelta;uniform float squashFactor;uniform float geometryFactor;uniform vec3 color;uniform vec3 colorCorrection;uniform vec3 boostFactors;uniform float gammaFactor;uniform float absorptionFactor;uniform float envMapRotation;uniform vec4 envMapRotationQuat;uniform float reflectivity;vec3 BRDF_Specular_GGX_Environment(const in vec3 viewDir,const in vec3 normal,const in vec3 specularColor,const in float roughness){float dotNV=abs(dot(normal,viewDir));const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);const vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*dotNV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec2 cartesianToPolar(vec3 n){vec2 uv;uv.x=atan(n.z,n.x)/(PI*2.)+0.5;uv.y=asin(n.y)/PI+0.5;return uv;}vec4 sampleEnvMap(vec3 direction){
#if !defined(USE_ENVMAP)
return vec4(direction,1);
#else
float cs=cos(envMapRotation);float sn=sin(envMapRotation);float temp=cs*direction.x+sn*direction.z;direction.z=-sn*direction.x+cs*direction.z;direction.x=temp;direction.x*=-1.;direction.y*=-1.;direction.z*=-1.;vec3 t=2.*cross(envMapRotationQuat.xyz,direction);direction+=envMapRotationQuat.w*t+cross(envMapRotationQuat.xyz,t);
#if ENV_MAP_TYPE == 0
return(textureCube(envMap,direction));
#elif ENV_MAP_TYPE == 1
return(texture2D(envMap,cartesianToPolar(direction)));
#endif
return vec4(1,0,1,1);
#endif
}vec4 SampleSpecularReflection(vec3 direction){
#if defined(FIX_ENV_DIRECTION)
direction=(viewMatrix*vec4(direction,0.)).xyz;
#endif
return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContribution(vec3 direction){
#if DIA_ORIENT_ENVMAP < 1
direction=mat3(MODEL_OFFSET_MATRIX)*direction;
#endif
#if defined(FIX_ENV_DIRECTION)
direction=(viewMatrix*vec4(direction,0.)).xyz;
#endif
direction=normalize(direction);direction.x*=-1.;direction.z*=-1.;return envMapIntensity*(sampleEnvMap(direction));}vec4 SampleSpecularContributionRef(vec3 origin,int i){vec4 ndcPos=projectionMatrix*viewMatrix*vec4(origin,1.);vec2 refractionCoords=ndcPos.xy/ndcPos.w;refractionCoords+=1.;refractionCoords/=2.;return transmissionSamplerMapTexelToLinear(texture2D(transmissionSamplerMap,refractionCoords));}vec3 intersectSphere(vec3 origin,vec3 direction){origin-=CENTER_OFFSET;direction.y/=squashFactor;float A=dot(direction,direction);float B=2.*dot(origin,direction);float C=dot(origin,origin)-radius*radius;float disc=B*B-4.*A*C;if(disc>0.){disc=sqrt(disc);float t1=(-B+disc)*geometryFactor/A;float t2=(-B-disc)*geometryFactor/A;float t=(t1>t2)?t1:t2;direction.y*=squashFactor;return vec3(origin+CENTER_OFFSET+direction*t);}return vec3(0.);}vec3 linePlaneIntersect(in vec3 pointOnLine,in vec3 lineDirection,in vec3 pointOnPlane,in vec3 planeNormal){return lineDirection*(dot(planeNormal,pointOnPlane-pointOnLine)/dot(planeNormal,lineDirection))+pointOnLine;}vec4 getNormalDistance(vec3 d){return textureCube(tCubeMapNormals,d);}vec3 getSurfaceNormal(vec4 surfaceInfos){vec3 surfaceNormal=surfaceInfos.rgb;surfaceNormal=surfaceNormal*2.-1.;return-normalize(surfaceNormal);}vec3 intersect(vec3 rayOrigin,vec3 rayDirection){vec3 sphereHitPoint=intersectSphere(rayOrigin,rayDirection);vec3 direction1=normalize(sphereHitPoint-CENTER_OFFSET);vec4 normalDistanceData1=getNormalDistance(direction1);float distance1=normalDistanceData1.a*radius;vec3 pointOnPlane1=CENTER_OFFSET+direction1*distance1;vec3 planeNormal1=getSurfaceNormal(normalDistanceData1);vec3 hitPoint1=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane1,planeNormal1);vec3 direction2=normalize(hitPoint1-CENTER_OFFSET);vec4 normalDistanceData2=getNormalDistance(direction2);float distance2=normalDistanceData2.a*radius;vec3 pointOnPlane2=CENTER_OFFSET+direction2*distance2;vec3 hitPoint=hitPoint1;vec3 planeNormal2=getSurfaceNormal(normalDistanceData2);hitPoint=linePlaneIntersect(rayOrigin,rayDirection,pointOnPlane2,planeNormal2);return hitPoint;}vec3 debugBounces(int count){vec3 color=vec3(1.,1.,1.);if(count==1)color=vec3(0.,1.,0.);else if(count==2)color=vec3(0.,0.,1.);else if(count==3)color=vec3(1.,1.,0.);else if(count==4)color=vec3(0.,1.,1.);else color=vec3(0.,1.,0.);if(count==0)color=vec3(1.,0.,0.);return color;}vec3 getRefractionColor(vec3 origin,vec3 direction,vec3 normal){vec3 outColor=vec3(0.);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 newDirection=refract(direction,normal,n1/refractiveIndex);vec3 brdfRefracted=BRDF_Specular_GGX_Environment(newDirection,-normal,vec3(f0),0.);attenuationFactor*=(vec3(1.)-brdfRefracted);int count=0;mat4 invModelOffsetMatrix=INV_MODEL_OFFSET_MATRIX;newDirection=normalize((invModelOffsetMatrix*vec4(newDirection,0.)).xyz);origin=(invModelOffsetMatrix*vec4(origin,1.)).xyz;for(int i=0;i<RAY_BOUNCES;i++){vec3 intersectedPos=intersect(origin,newDirection);vec3 dist=intersectedPos-origin;vec3 d=normalize(intersectedPos-CENTER_OFFSET);vec3 mappedNormal=getNormalDistance(d).rgb;mappedNormal=2.*mappedNormal-1.;mappedNormal=-normalize(mappedNormal);float r=length(dist)/radius*absorptionFactor;attenuationFactor*=exp(-r*(1.-color));origin=intersectedPos;vec3 origin2=(MODEL_OFFSET_MATRIX*vec4(intersectedPos,1)).xyz;vec3 oldDir=newDirection;newDirection=refract(newDirection,mappedNormal,refractiveIndex/n1);if(dot(newDirection,newDirection)<epsilon){newDirection=reflect(oldDir,mappedNormal);if(i==RAY_BOUNCES-1){vec3 brdfReflected=BRDF_Specular_GGX_Environment(-oldDir,mappedNormal,vec3(f0),0.);vec3 d1=mat3(MODEL_OFFSET_MATRIX)*oldDir;d1=normalize(d1);float cosT=1.-dot(direction,d1);outColor+=((transmission>0.&&cosT<transmission)?SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb:SampleSpecularContribution(oldDir).rgb)*attenuationFactor*colorCorrection*boostFactors*(vec3(1.)-min(vec3(1.),brdfReflected));}}else{vec3 brdfRefracted=vec3(1.)-min(vec3(1.),BRDF_Specular_GGX_Environment(newDirection,-mappedNormal,vec3(f0),0.));vec3 d1=normalize(mat3(MODEL_OFFSET_MATRIX)*newDirection);float cosT=1.-dot(direction,d1);if(transmission>0.&&cosT<transmission){outColor+=SampleSpecularContributionRef(origin2+0.5*d1*cosT,i).rgb*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}else{vec3 dir0=newDirection;vec3 dir1=refract(oldDir,mappedNormal,(refractiveIndex+rIndexDelta)/n1);vec3 dir2=refract(oldDir,mappedNormal,(refractiveIndex-rIndexDelta)/n1);outColor+=vec3(SampleSpecularContribution(dir1).r,SampleSpecularContribution(dir0).g,SampleSpecularContribution(dir2).b)*brdfRefracted*attenuationFactor*colorCorrection*boostFactors;}newDirection=reflect(oldDir,mappedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(newDirection,mappedNormal,vec3(f0),0.);attenuationFactor*=brdfReflected*boostFactors;count++;}}return outColor;}void main(){vec3 normalizedNormal=normalize(vWorldNormal);vec3 viewVector=normalize(vWorldPosition-cameraPosition);const float n1=1.;const float epsilon=1e-4;float f0=(2.4-n1)/(2.4+n1);f0*=f0;vec3 attenuationFactor=vec3(1.);vec3 reflectedDirection=reflect(viewVector,normalizedNormal);vec3 brdfReflected=BRDF_Specular_GGX_Environment(reflectedDirection,normalizedNormal,vec3(f0),0.);vec3 reflectionColor=SampleSpecularReflection(reflectedDirection).rgb*brdfReflected*reflectivity*2.;vec3 refractionColor=getRefractionColor(vWorldPosition,viewVector,normalizedNormal);vec3 normal=normalize(vNormal);vec3 diffuseColor=vec3(1.);
#glMarker beforeAccumulation
gl_FragColor=vec4((refractionColor.rgb+reflectionColor.rgb)*diffuseColor,1.);gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(gammaFactor));gl_FragColor.rgb=max(gl_FragColor.rgb,0.);
#include <colorspace_fragment>
}`
  , diamond_vert = `#ifndef USE_ENVMAP
#define USE_ENVMAP  
#endif
varying vec3 vWorldPosition;varying vec3 vWorldNormal;varying vec3 vViewPosition;varying vec3 vNormal;varying vec2 vUv;
#ifdef USE_INSTANCING
uniform mat4 inverseModelMatrix;uniform mat4 modelOffsetMatrix;varying mat4 vModelInstanceOffsetMatrix;varying mat4 vModelInstanceOffsetMatrixInv;
#endif
#include <morphtarget_pars_vertex>
#ifdef USE_MORPHTARGETS
varying vec3 vCenterOffset;
#ifndef USE_INSTANCING
uniform mat4 modelOffsetMatrixInv;
#endif
#endif
void main(){
#ifdef USE_INSTANCING
vWorldNormal=(modelMatrix*instanceMatrix*vec4(normal,0.)).xyz;
#else
vWorldNormal=(modelMatrix*vec4(normal,0.)).xyz;
#endif
#include <beginnormal_vertex>
#include <defaultnormal_vertex>
#include <normal_vertex>
#include <begin_vertex>
#ifdef USE_MORPHTARGETS
vCenterOffset=transformed;
#include <morphtarget_vertex>
vCenterOffset=transformed-vCenterOffset;
#ifndef USE_INSTANCING
vCenterOffset=(modelOffsetMatrixInv*modelMatrix*vec4(vCenterOffset,1.)).xyz;
#endif
#endif
#include <project_vertex>
vViewPosition=-mvPosition.xyz;vUv=uv;
#include <worldpos_vertex>
vWorldPosition=worldPosition.xyz;
#ifdef USE_INSTANCING
vModelInstanceOffsetMatrix=modelMatrix*instanceMatrix*inverseModelMatrix*modelOffsetMatrix;vModelInstanceOffsetMatrixInv=inverse(vModelInstanceOffsetMatrix);
#ifdef USE_MORPHTARGETS
vCenterOffset=(vModelInstanceOffsetMatrixInv*modelMatrix*vec4(vCenterOffset,1.)).xyz;
#endif
#endif
}`
  , pca = __webpackgi_require__(391);
function computeOffsetMatrix(d) {
    const o = new three_module.Pq0(0,0,0)
      , c = new three_module.Pq0(0,0,0)
      , h = new three_module.Pq0(0,0,0)
      , _ = new three_module.Pq0(0,0,0)
      , b = d.getAttribute("position")
      , _e = d.index;
    if (_e)
        for (let ht = Math.max(0, d.drawRange.start), _t = Math.min(_e.count, d.drawRange.start + d.drawRange.count) - 1; ht < _t / 3; ht += 3) {
            const vt = _e.getX(ht)
              , bt = _e.getX(ht + 1)
              , St = _e.getX(ht + 2);
            c.set(b.getX(vt), b.getY(vt), b.getZ(vt)),
            h.set(b.getX(bt), b.getY(bt), b.getZ(bt)),
            _.set(b.getX(St), b.getY(St), b.getZ(St)),
            h.sub(c),
            _.sub(c),
            _.cross(h),
            _.normalize(),
            o.add(_)
        }
    else
        for (let ht = 0; ht < b.count; ht += 3)
            c.set(b.getX(ht), b.getY(ht), b.getZ(ht)),
            h.set(b.getX(ht + 1), b.getY(ht + 1), b.getZ(ht + 1)),
            _.set(b.getX(ht + 2), b.getY(ht + 2), b.getZ(ht + 2)),
            h.sub(c),
            _.sub(c),
            _.cross(h),
            _.normalize(),
            o.add(_);
    o.normalize();
    let nt = !1
      , it = 0;
    for (; !nt; ) {
        const ht = it / 3
          , _t = _e ? _e.getX(ht) : ht
          , vt = _e ? _e.getX(ht + 1) : ht + 1;
        c.set(b.getX(_t), b.getY(_t), b.getZ(_t)),
        h.set(b.getX(vt), b.getY(vt), b.getZ(vt)),
        c.sub(h),
        c.normalize();
        const bt = o.dot(c);
        Math.abs(bt - 1) > .001 && c.length() > .5 && (nt = !0),
        it += 3
    }
    h.crossVectors(c, o),
    h.normalize(),
    c.crossVectors(o, h),
    c.normalize();
    const at = new three_module.kn4;
    at.elements[0] = c.x,
    at.elements[1] = c.y,
    at.elements[2] = c.z,
    at.elements[3] = 0,
    at.elements[4] = o.x,
    at.elements[5] = o.y,
    at.elements[6] = o.z,
    at.elements[7] = 0,
    at.elements[8] = h.x,
    at.elements[9] = h.y,
    at.elements[10] = h.z,
    at.elements[11] = 0,
    at.elements[12] = 0,
    at.elements[13] = 0,
    at.elements[14] = 0,
    at.elements[15] = 1,
    d.computeBoundingSphere();
    const ut = d.boundingSphere.radius
      , pt = new three_module.kn4().makeScale(ut, ut, ut);
    return at.multiply(pt),
    at
}
function SignedTetrahedronVolume(d, o, c) {
    const h = new three_module.Pq0().copy(d)
      , _ = new three_module.Pq0().copy(o)
      , b = new three_module.Pq0().copy(c);
    return h.dot(_.cross(b)) / 6
}
function TriangleArea(d, o, c) {
    const h = new three_module.Pq0().copy(d)
      , _ = new three_module.Pq0().copy(o)
      , b = new three_module.Pq0().copy(c);
    return _.sub(h),
    b.sub(h),
    b.cross(_),
    .5 * b.length()
}
function computeCenterAndCOM(d, o) {
    const c = new three_module.Pq0;
    for (let pt = 0; pt < d.length; pt += 3)
        c.x += d[pt],
        c.y += d[pt + 1],
        c.z += d[pt + 2];
    c.multiplyScalar(1 / (d.length / 3));
    const h = new three_module.Pq0
      , _ = new three_module.Pq0
      , b = new three_module.Pq0
      , _e = new three_module.Pq0
      , nt = new three_module.Pq0;
    let it = 0
      , at = 0
      , ut = o.length;
    ut % 3 != 0 && (ut -= ut % 3);
    for (let pt = 0; pt < ut; pt += 3) {
        h.set(o[pt][0], o[pt][1], o[pt][2]),
        _.set(o[pt + 1][0], o[pt + 1][1], o[pt + 1][2]),
        b.set(o[pt + 2][0], o[pt + 2][1], o[pt + 2][2]),
        nt.copy(h).add(_).add(b);
        const ht = TriangleArea(h, _, b);
        nt.multiplyScalar(ht / 3),
        _e.add(nt),
        it += ht,
        at += SignedTetrahedronVolume(h, _, b)
    }
    return _e.multiplyScalar(1 / it),
    {
        center: c,
        com: _e,
        volume: at,
        area: it
    }
}
function computeEigenVectors(d) {
    const o = d.getAttribute("position")
      , c = d.getAttribute("normal");
    if (o.count / 3 > 1500)
        return console.warn("DiamondPlugin:: Too many faces. Mirror/Topology issues will not be fixed", o.count / 3),
        computeOffsetMatrix(d);
    const h = new three_module.Pq0(0,0,0)
      , _ = new three_module.Pq0(0,0,0)
      , b = new three_module.Pq0(0,0,0)
      , _e = d.index
      , nt = [];
    if (_e)
        for (let At = Math.max(0, d.drawRange.start), Et = Math.min(_e.count, d.drawRange.start + d.drawRange.count) - 1; At < Et; At += 3) {
            const Pt = _e.getX(At)
              , It = _e.getX(At + 1)
              , Dt = _e.getX(At + 2);
            h.set(o.getX(Pt), o.getY(Pt), o.getZ(Pt)),
            _.set(o.getX(It), o.getY(It), o.getZ(It)),
            b.set(o.getX(Dt), o.getY(Dt), o.getZ(Dt)),
            nt.push(h.toArray(), _.toArray(), b.toArray())
        }
    else
        for (let At = 0; At < o.count; At++)
            h.set(o.getX(At), o.getY(At), o.getZ(At)),
            nt.push(h.toArray());
    const it = computeCenterAndCOM(o.array, nt);
    if (it.volume < 0) {
        console.warn("DiamondPlugin:: Negative Volume, Fixing Normals");
        for (let At = 0; At < c.count; At++)
            c.setX(At, -c.getX(At)),
            c.setY(At, -c.getY(At)),
            c.setZ(At, -c.getZ(At));
        c.needsUpdate = !0
    }
    const at = [];
    for (let At = 0; At < o.array.length; At += 3)
        at.push([o.array[At], o.array[At + 1], o.array[At + 2]]);
    const ut = console.log;
    console.log = () => {}
    ;
    const pt = (0,
    pca.getEigenVectors)(at);
    console.log = ut;
    const ht = new three_module.kn4;
    ht.elements[0] = pt[0].vector[0],
    ht.elements[1] = pt[0].vector[1],
    ht.elements[2] = pt[0].vector[2],
    ht.elements[3] = 0,
    ht.elements[4] = pt[1].vector[0],
    ht.elements[5] = pt[1].vector[1],
    ht.elements[6] = pt[1].vector[2],
    ht.elements[7] = 0,
    ht.elements[8] = pt[2].vector[0],
    ht.elements[9] = pt[2].vector[1],
    ht.elements[10] = pt[2].vector[2],
    ht.elements[11] = 0,
    ht.elements[12] = 0,
    ht.elements[13] = 0,
    ht.elements[14] = 0,
    ht.elements[15] = 1;
    const _t = new three_module.Pq0;
    _t.copy(it.com).sub(it.center),
    _t.normalize();
    const vt = new three_module.Pq0(pt[2].vector[0],pt[2].vector[1],pt[2].vector[2]);
    _t.dot(vt) < 0 && (ht.elements[4] = -pt[1].vector[0],
    ht.elements[5] = -pt[1].vector[1],
    ht.elements[6] = -pt[1].vector[2],
    ht.elements[8] = -pt[2].vector[0],
    ht.elements[9] = -pt[2].vector[1],
    ht.elements[10] = -pt[2].vector[2]),
    d.computeBoundingSphere();
    const bt = d.boundingSphere.radius
      , St = new three_module.kn4().makeScale(bt, bt, bt);
    return ht.multiply(St),
    ht
}
const diamondMaterialPropList = {
    ...threeMaterialPropList,
    color: new three_module.Q1f(1,1,1),
    envMapIntensity: 1,
    envMapRotation: 0,
    dispersion: .012,
    squashFactor: .98,
    geometryFactor: .5,
    gammaFactor: 1,
    absorptionFactor: 1,
    reflectivity: .5,
    refractiveIndex: 2.4,
    boostFactors: new three_module.Pq0(.892,.892,.98595025),
    wireframe: !1,
    envMapRotationOffset: 0,
    wireframeLinewidth: 0,
    skinning: !1,
    transmission: 0,
    morphTargets: !1,
    morphNormals: !1,
    rayBounces: 1,
    diamondOrientedEnvMap: 0,
    envMapIndex: 0
};
var diamondMaterial_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class DiamondMaterial extends three_module.BKk {
    get mmMaterial() {
        return this
    }
    get materialObject() {
        return this
    }
    onBeforeRender(o, c, h, _, b) {
        var _e, nt;
        super.onBeforeRender(o, c, h, _, b),
        this.envMapIntensity === void 0 || this.userData.separateEnvMapIntensity || c.envMapIntensity === void 0 || (this.userData.__envIntensity = this.envMapIntensity,
        this.envMapIntensity = c.envMapIntensity),
        this.envMap !== void 0 && c.fixedEnvMapDirection !== void 0 && (c.fixedEnvMapDirection ? this.defines.FIX_ENV_DIRECTION || (this.defines.FIX_ENV_DIRECTION = "1",
        this.needsUpdate = !0) : this.defines.FIX_ENV_DIRECTION !== void 0 && (delete this.defines.FIX_ENV_DIRECTION,
        this.needsUpdate = !0)),
        this.uniforms.envMapRotation.value = (((_e = this.envMap) === null || _e === void 0 ? void 0 : _e.rotation) || 0) + this.envMapRotationOffset,
        this.uniforms.envMapRotationQuat.value.setFromEuler(new three_module.O9p(this.envMapRotationOffsetX,this.envMapRotationOffsetY,this.envMapRotationOffsetZ)),
        this.extraUniformsToUpload.inverseModelMatrix.value.copy(b.matrixWorld).invert();
        const it = _.userData.normalsCaptureOffsets;
        it && (this.extraUniformsToUpload.centerOffset.value.fromArray(it.centerOffset),
        this.extraUniformsToUpload.modelOffsetMatrix.value.fromArray(it.offsetMatrix).premultiply(b.matrixWorld),
        this.extraUniformsToUpload.modelOffsetMatrixInv.value.copy(this.extraUniformsToUpload.modelOffsetMatrix.value).invert(),
        this.extraUniformsToUpload.radius.value = it.radius);
        const at = (nt = _.userData._normalsCaptureMap) === null || nt === void 0 ? void 0 : nt.texture;
        this.normalsCaptureMap !== at && (this.normalsCaptureMap = at),
        this.dispatchEvent({
            type: "beforeRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    onAfterRender(o, c, h, _, b) {
        super.onAfterRender(o, c, h, _, b),
        this.userData.__envIntensity !== void 0 && (this.envMapIntensity = this.userData.__envIntensity,
        delete this.userData.__envIntensity),
        this.dispatchEvent({
            type: "afterRender",
            renderer: o,
            scene: c,
            camera: h,
            geometry: _,
            object: b
        })
    }
    constructor(o) {
        var c;
        super({
            side: three_module.$EB,
            defines: {
                DIA_ORIENT_ENVMAP: 0,
                RAY_BOUNCES: 5,
                ENV_MAP_TYPE: 0,
                PI: 3.1428
            },
            vertexShader: diamond_vert,
            fragmentShader: diamond_frag,
            uniforms: {
                envMap: {
                    value: (o == null ? void 0 : o.envMap) || null
                },
                envMapRotation: {
                    value: 0
                },
                envMapRotationQuat: {
                    value: new three_module.PTz
                },
                transmission: {
                    value: 0
                },
                transmissionSamplerMap: {
                    value: null
                },
                transmissionSamplerSize: {
                    value: new three_module.I9Y
                },
                normalOffset: {
                    value: 0
                },
                distanceOffset: {
                    value: 0
                },
                colorCorrection: {
                    value: new three_module.Pq0(1,1,1)
                }
            }
        }),
        this.typeSlug = DiamondMaterial.TypeSlug,
        this.assetType = "material",
        this.__envMap = [],
        this.isDiamondMaterial = !0,
        this.color = new three_module.Q1f(1,1,1),
        this.envMapIntensity = 1,
        this.envMapRotationOffset = 0,
        this.envMapRotationOffsetX = 0,
        this.envMapRotationOffsetY = 0,
        this.envMapRotationOffsetZ = 0,
        this.dispersion = .012,
        this.absorptionFactor = 1,
        this.refractiveIndex = 2.4,
        this.squashFactor = .98,
        this.geometryFactor = .5,
        this.gammaFactor = 1,
        this.boostFactors = new three_module.Pq0(.892,.892,.98595025),
        this.transmission = 0,
        this.reflectivity = .5,
        this.rayBounces = 5,
        this.diamondOrientedEnvMap = 0,
        this.normalsCaptureMap = null,
        this.extraUniformsToUpload = {
            inverseModelMatrix: {
                value: new three_module.kn4().identity()
            },
            radius: {
                value: 1
            },
            centerOffset: {
                value: new three_module.Pq0(0,0,0)
            },
            modelOffsetMatrix: {
                value: new three_module.kn4().identity()
            },
            modelOffsetMatrixInv: {
                value: new three_module.kn4().identity()
            }
        },
        this.envMapIndex = 0,
        this.setDirty = this.setDirty.bind(this),
        this.userData.setDirty = h => {
            console.warn("WebGi DiamondMaterial: userData.setDirty is deprecated. Use setDirty instead."),
            this.setDirty(h)
        }
        ,
        this.userData.separateEnvMapIntensity = !0,
        o && this.setValues(o),
        this.materialExtensions = MaterialExtender.RegisterExtensions(this, (c = o == null ? void 0 : o.customMaterialExtensions) !== null && c !== void 0 ? c : [])
    }
    registerMaterialExtensions(o) {
        this.materialExtensions = [...this.materialExtensions, ...MaterialExtender.RegisterExtensions(this, o)]
    }
    unregisterMaterialExtensions(o) {}
    onBeforeCompile(o, c) {
        MaterialExtender.ApplyMaterialExtensions(this, o, this.materialExtensions, c),
        this.dispatchEvent({
            type: "beforeCompile",
            shader: o,
            renderer: c
        }),
        o.fragmentShader = o.fragmentShader.replaceAll("#glMarker", "// "),
        o.vertexShader = o.vertexShader.replaceAll("#glMarker", "// "),
        super.onBeforeCompile(o, c)
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey() + MaterialExtender.CacheKeyForExtensions(this, this.materialExtensions)
    }
    setDirty(o) {
        var c, h;
        this.needsUpdate = !0,
        this.dispatchEvent({
            ...o,
            type: "materialUpdate",
            frameFade: o == null ? void 0 : o.last
        }),
        (o == null ? void 0 : o.last) !== !1 && ((h = (c = this._uiConfig) === null || c === void 0 ? void 0 : c.uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0, 1))
    }
    set envMaps(o) {
        this.__envMap = o,
        this.refreshEnvUniform()
    }
    refreshEnvUniform() {
        var o;
        this.uniforms.envMap.value = this.envMap,
        this.defines.ENV_MAP_TYPE = !((o = this.uniforms.envMap.value) === null || o === void 0) && o.isCubeTexture ? 0 : 1,
        this.needsUpdate = !0
    }
    get envMap() {
        var o, c;
        return (c = (o = this.__envMap[this.envMapIndex]) !== null && o !== void 0 ? o : this.__envMap[0]) !== null && c !== void 0 ? c : null
    }
    set envMap(o) {
        console.error("Setting separate envmap for individual diamond material not supported yet.")
    }
    clone() {
        return super.clone()
    }
    toJSON(o) {
        const c = {
            metadata: {
                version: 4.6,
                type: "DiamondMaterial",
                generator: "DiamondMaterial.toJSON"
            }
        };
        return c.name = this.name,
        c.uuid = this.uuid,
        c.color = this.color.getHex(),
        c.envMapIntensity = this.envMapIntensity,
        c.envMapIndex = this.envMapIndex,
        c.envMapRotationOffset = this.envMapRotationOffset,
        c.dispersion = this.dispersion,
        c.squashFactor = this.squashFactor,
        c.geometryFactor = this.geometryFactor,
        c.gammaFactor = this.gammaFactor,
        c.absorptionFactor = this.absorptionFactor,
        c.reflectivity = this.reflectivity,
        c.refractiveIndex = this.refractiveIndex,
        c.rayBounces = this.rayBounces,
        c.diamondOrientedEnvMap = this.diamondOrientedEnvMap,
        c.boostFactors = {
            x: this.boostFactors.x,
            y: this.boostFactors.y,
            z: this.boostFactors.z,
            isVector3: !0
        },
        c.transmission = this.transmission,
        c.isDiamondMaterialParameters = !0,
        c.type = DiamondMaterial.TYPE,
        c.userData = {},
        copyMaterialUserData(c.userData, this.userData),
        c.userData.uuid = this.userData.uuid,
        c
    }
    get uiConfig() {
        const o = this;
        return this._uiConfigChildren || (this._uiConfigChildren = [{
            type: "input",
            property: [this, "name"]
        }, {
            type: "checkbox",
            property: [this, "wireframe"]
        }, {
            type: "dropdown",
            label: "Environment",
            property: [this, "envMapIndex"],
            children: [0, 1, 2].map(c => ({
                label: "env" + (c + 1),
                value: c
            }))
        }, ...generateUiConfig(this), {
            type: "input",
            label: "Mesh count",
            get value() {
                var c, h, _;
                return (_ = (h = (c = o.userData) === null || c === void 0 ? void 0 : c.__appliedMeshes) === null || h === void 0 ? void 0 : h.size) !== null && _ !== void 0 ? _ : 0
            },
            set value(c) {},
            disabled: !0
        }, {
            type: "input",
            label: "uuid",
            get value() {
                return o.uuid
            },
            set value(c) {},
            disabled: !0
        }, {
            type: "checkbox",
            label: "Render to Depth",
            hidden: () => this.transmission === 0,
            get value() {
                return o.userData.renderToDepth === !0
            },
            set value(c) {
                o.userData.renderToDepth = c || void 0
            }
        }, {
            type: "button",
            label: "Download .dmat",
            value: () => {
                N$2(new Blob([JSON.stringify(o.toJSON(), null, 2)],{
                    type: "application/json"
                }), "diamond-material.dmat")
            }
        }]),
        this._uiConfig || (this._uiConfig = {
            type: "folder",
            label: "Diamond Material",
            expanded: !0,
            children: this._uiConfigChildren,
            limitedUi: !0
        }),
        this._uiConfig.children = [...this._uiConfigChildren, ...this.materialExtensions.map(c => {
            var h;
            return (h = c.getUiConfig) === null || h === void 0 ? void 0 : h.call(c, this)
        }
        )].filter(c => c),
        this._uiConfig
    }
    copyProps(o) {
        if (!o.isDiamondMaterialParameters && !o.isDiamondMaterial && !o.isDiamond && o.type !== DiamondMaterial.TYPE)
            return console.warn("WebGi DiamondMaterial: Material type is not supported", o),
            this;
        const c = {};
        xe$1(o, c, Array.from(Object.keys(diamondMaterialPropList)));
        const h = c.userData;
        return delete c.userData,
        this.setValues(c),
        copyMaterialUserData(this.userData, h),
        this.setDirty(),
        this
    }
    fromJSON(o, c) {
        return this.copyProps(o)
    }
}
DiamondMaterial.TypeSlug = "dmat",
DiamondMaterial.TYPE = "DiamondMaterial",
diamondMaterial_decorate([uiColor("Color", {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "color", void 0),
diamondMaterial_decorate([uiSlider("Env Intensity", [0, 5], .01, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "envMapIntensity", void 0),
diamondMaterial_decorate([uiSlider("Env Rotation Offset", [-Math.PI, Math.PI], .01), ze$1(DiamondMaterial.prototype.setDirty)], DiamondMaterial.prototype, "envMapRotationOffset", void 0),
diamondMaterial_decorate([uiSlider("Env Rotation Offset X", [-Math.PI, Math.PI], .01), ze$1(DiamondMaterial.prototype.setDirty)], DiamondMaterial.prototype, "envMapRotationOffsetX", void 0),
diamondMaterial_decorate([uiSlider("Env Rotation Offset Y", [-Math.PI, Math.PI], .01), ze$1(DiamondMaterial.prototype.setDirty)], DiamondMaterial.prototype, "envMapRotationOffsetY", void 0),
diamondMaterial_decorate([uiSlider("Env Rotation Offset Z", [-Math.PI, Math.PI], .01), ze$1(DiamondMaterial.prototype.setDirty)], DiamondMaterial.prototype, "envMapRotationOffsetZ", void 0),
diamondMaterial_decorate([uiSlider("Dispersion", [0, .1], 1e-4, {
    limitedUi: !0
}), uniform({
    propKey: "rIndexDelta"
})], DiamondMaterial.prototype, "dispersion", void 0),
diamondMaterial_decorate([uiSlider("Absorption", [0, 15], .01, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "absorptionFactor", void 0),
diamondMaterial_decorate([uiSlider("Refractive Index", [0, 4], .01, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "refractiveIndex", void 0),
diamondMaterial_decorate([uniform()], DiamondMaterial.prototype, "squashFactor", void 0),
diamondMaterial_decorate([uniform()], DiamondMaterial.prototype, "geometryFactor", void 0),
diamondMaterial_decorate([uiSlider("Gamma", [.1, 4], .01, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "gammaFactor", void 0),
diamondMaterial_decorate([uiVector("RGB Boost", void 0, void 0, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "boostFactors", void 0),
diamondMaterial_decorate([uiSlider("Transmission", [0, 1], .01, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "transmission", void 0),
diamondMaterial_decorate([uiSlider("Reflectivity", [0, 2], .01, {
    limitedUi: !0
}), uniform()], DiamondMaterial.prototype, "reflectivity", void 0),
diamondMaterial_decorate([matDefine("RAY_BOUNCES", void 0, !0), uiSlider("Ray Bounces", [1, 16], 1)], DiamondMaterial.prototype, "rayBounces", void 0),
diamondMaterial_decorate([matDefine("DIA_ORIENT_ENVMAP", void 0, !0), uiSlider("Diamond Oriented Lighting", [0, 1], 1)], DiamondMaterial.prototype, "diamondOrientedEnvMap", void 0),
diamondMaterial_decorate([uniform({
    propKey: "tCubeMapNormals"
})], DiamondMaterial.prototype, "normalsCaptureMap", void 0),
diamondMaterial_decorate([x$1(DiamondMaterial.prototype.refreshEnvUniform)], DiamondMaterial.prototype, "envMapIndex", void 0);
const algorithms = {
    ES256: {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: {
            name: "SHA-256"
        }
    },
    ES384: {
        name: "ECDSA",
        namedCurve: "P-384",
        hash: {
            name: "SHA-384"
        }
    },
    ES512: {
        name: "ECDSA",
        namedCurve: "P-521",
        hash: {
            name: "SHA-512"
        }
    },
    HS256: {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    },
    HS384: {
        name: "HMAC",
        hash: {
            name: "SHA-384"
        }
    },
    HS512: {
        name: "HMAC",
        hash: {
            name: "SHA-512"
        }
    },
    RS256: {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    },
    RS384: {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-384"
        }
    },
    RS512: {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-512"
        }
    }
};
function decode(d) {
    return JSON.parse(atob(d.split(".")[1]))
}
async function verify(d, o, c) {
    const h = algorithms[c.algorithm || "RS512"]
      , _ = await crypto.subtle.importKey("jwk", o, h, !0, ["verify"])
      , b = d.split(".")
      , _e = new Uint8Array(atob(b[2].replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")).split("").map(it => it.charCodeAt(0)))
      , nt = new Uint8Array((b[0] + "." + b[1]).split("").map(it => it.charCodeAt(0)));
    return await crypto.subtle.verify(h, _, _e, nt)
}
const jwt = {
    decode,
    verify
};
class LicenseVerification {
    constructor(o, c) {
        this.PRODUCT_ID = "IJewel3D_WebGi_V0",
        this.KEY_TYPE_ID = "online-v1",
        this.TOKEN_FILE = "0.txt",
        this.PUBLIC_KEY_FILE = "1.json",
        this.KEY_SERVER = "https://license.ijewel3d.com",
        this.KEY_SERVER_VERIFY = "/api/v1/verify",
        this.KEY_SERVER_CERTS = "/api/v1/certs/" + this.KEY_TYPE_ID,
        this.id = "",
        this.idHash = "",
        this.appVersion = "",
        this.appName = "",
        this._storage = {
            getItem: async h => localStorage.getItem(h),
            setItem: async (h, _) => (localStorage.setItem(h, _),
            _)
        },
        this.silent = !0,
        this.appVersion = c,
        this.appName = o
    }
    _getOriginId() {
        const o = getCurrentDomain(window);
        if (!o || !(o != null && o[0]))
            throw new Error("Failed to get id");
        return "\\\\" + o.map(c => btoa(c)).join("\\\\")
    }
    _getStorage() {
        return this._storage
    }
    async init() {
        var o, c;
        if (this.id = this.id || this._getOriginId(),
        !this.id)
            throw new Error("Failed to get machine id");
        this.idHash = await hash(this.id);
        const h = this._getStorage()
          , _ = this.idHash + this.TOKEN_FILE;
        let b = (o = await h.getItem(_)) !== null && o !== void 0 ? o : await h.setItem(_, "");
        const _e = this.idHash + this.PUBLIC_KEY_FILE
          , nt = (c = await h.getItem(_e)) !== null && c !== void 0 ? c : null;
        let it = await this.getPublicKey().catch( () => null);
        return !it && nt && (it = JSON.parse(nt)),
        it !== nt && await h.setItem(_e, JSON.stringify(it)),
        it || this._throw(new Error("Failed to get public key")),
        {
            token: b,
            publicKey: it
        }
    }
    async verify(o, c) {
        var h;
        try {
            let _, b = (c = c ?? await this.init()).token;
            b && !await jwt.verify(b, c.publicKey, {
                algorithm: "RS512",
                throwError: !1
            }) && (b = ""),
            b && (_ = jwt.decode(b),
            ((h = _.payload) === null || h === void 0 ? void 0 : h.key) !== o && (b = "")),
            b && b.length || (b = await this.setLicenseKey(o)),
            _ = b ? jwt.decode(b) : void 0;
            let _e = !1;
            return _e = _e || b && await jwt.verify(b, c.publicKey, {
                algorithm: "RS512",
                throwError: !1
            }),
            _e = _e || !!_ && await this.verifyData(_),
            _e
        } catch (_) {
            return this.silent || console.error(_),
            !1
        }
    }
    async writeToken(o) {
        const c = this.idHash + this.TOKEN_FILE;
        await this._getStorage().setItem(c, o)
    }
    async verifyData(o) {
        var c, h, _;
        return ((c = o.payload) === null || c === void 0 ? void 0 : c.sub) === this.id && ((h = o.payload) === null || h === void 0 ? void 0 : h.app) === this.appName + "_" + this.appVersion && ((_ = o.payload) === null || _ === void 0 ? void 0 : _.pid) === this.PRODUCT_ID
    }
    async _getPublicKeyFromServer() {
        return fetch(this.KEY_SERVER + this.KEY_SERVER_CERTS).then(o => o.json()).catch(o => ({
            status: o == null ? void 0 : o.status,
            error: o
        }))
    }
    async _validateKeyFromServer(o) {
        return await fetch(this.KEY_SERVER + this.KEY_SERVER_VERIFY, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                key: o,
                id: this.id,
                app: {
                    name: this.appName,
                    version: this.appVersion
                },
                pid: this.PRODUCT_ID
            })
        }).then(c => c.json()).catch(c => ({
            status: c == null ? void 0 : c.status,
            error: c
        }))
    }
    _throw(o) {
        if (!this.silent)
            throw o;
        return null
    }
    async setLicenseKey(o) {
        const c = await this._validateKeyFromServer(o);
        if (c.error)
            return this._throw((c.status ? c.status + ": " : "") + +c.error);
        const h = c.token;
        return h ? (await this.writeToken(h),
        h) : this._throw(new Error("Invalid license key, no token"))
    }
    async getPublicKey() {
        const o = await this._getPublicKeyFromServer();
        return o.error ? this._throw(o.error) : o.jwk || this._throw(new Error("Invalid public key"))
    }
}
async function hash(d) {
    const o = new TextEncoder().encode(d)
      , c = await crypto.subtle.digest("SHA-256", o);
    return Array.from(new Uint8Array(c)).map(h => h.toString(16).padStart(2, "0")).join("")
}
function getCurrentDomain(d) {
    let o, c, h, _, b, _e;
    const nt = function(vt, bt, St) {
        if (vt.length != bt)
            return !1;
        for (let At = 0; At < bt; At++)
            for (let Et = 0; Et < St.length; Et += 2)
                if (At == St[Et] && vt.charCodeAt(At) != St[Et + 1])
                    return !1;
        return !0
    }
      , it = function(vt, bt, St) {
        return nt(bt, St, vt)
    }
      , at = function(vt, bt, St) {
        return it(bt, vt, St)
    };
    for (let vt in d)
        if (nt(vt, 8, [7, 116, 5, 101, 3, 117, 0, 100])) {
            o = vt;
            break
        }
    for (let vt in d)
        if (nt(vt, 6, [5, 116, 0, 112, 4, 110, 2, 114])) {
            b = vt;
            break
        }
    for (let vt in d[o])
        if (at(vt, [5, 110, 0, 100], 6)) {
            c = vt;
            break
        }
    for (let vt in d[o])
        if (at(vt, [7, 110, 0, 108], 8)) {
            h = vt;
            break
        }
    for (let vt in d[o])
        if (at(vt, [7, 114, 0, 114], 8)) {
            _e = vt;
            break
        }
    if (!("~" > c)) {
        for (let vt in d[o][h])
            if (it([7, 101, 0, 104], vt, 8)) {
                _ = vt;
                break
            }
    }
    if (!o || !d[o])
        return;
    const ut = d[b] !== d
      , pt = d[o][c]
      , ht = !!d[o][h] && d[o][h][_]
      , _t = ut && _e ? d[o][_e] : pt || ht;
    return _t ? [_t, pt || ht] : void 0
}
var injectStylesIntoStyleTag = __webpackgi_require__(186)
  , injectStylesIntoStyleTag_default = __webpackgi_require__.n(injectStylesIntoStyleTag)
  , styleDomAPI = __webpackgi_require__(155)
  , styleDomAPI_default = __webpackgi_require__.n(styleDomAPI)
  , setAttributesWithoutAttributes = __webpackgi_require__(626)
  , setAttributesWithoutAttributes_default = __webpackgi_require__.n(setAttributesWithoutAttributes)
  , insertStyleElement = __webpackgi_require__(990)
  , insertStyleElement_default = __webpackgi_require__.n(insertStyleElement)
  , styleTagTransform = __webpackgi_require__(827)
  , styleTagTransform_default = __webpackgi_require__.n(styleTagTransform)
  , loadingScreen = __webpackgi_require__(646)
  , exported = {};
loadingScreen.A && loadingScreen.A.locals && (exported.locals = loadingScreen.A.locals);
var refs = 0, update, options = {};
options.styleTagTransform = styleTagTransform_default(),
options.setAttributes = setAttributesWithoutAttributes_default(),
options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
options.domAPI = styleDomAPI_default(),
options.insertStyleElement = insertStyleElement_default(),
exported.use = function(d) {
    return options.options = d || {},
    refs++ || (update = injectStylesIntoStyleTag_default()(loadingScreen.A, options)),
    exported
}
,
exported.unuse = function() {
    refs > 0 && !--refs && (update(),
    update = null)
}
;
var styles_loadingScreen = exported
  , spinner1 = __webpackgi_require__(611)
  , spinner1_exported = {};
spinner1.A && spinner1.A.locals && (spinner1_exported.locals = spinner1.A.locals);
var spinner1_refs = 0, spinner1_update, spinner1_options = {};
spinner1_options.styleTagTransform = styleTagTransform_default(),
spinner1_options.setAttributes = setAttributesWithoutAttributes_default(),
spinner1_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
spinner1_options.domAPI = styleDomAPI_default(),
spinner1_options.insertStyleElement = insertStyleElement_default(),
spinner1_exported.use = function(d) {
    return spinner1_options.options = d || {},
    spinner1_refs++ || (spinner1_update = injectStylesIntoStyleTag_default()(spinner1.A, spinner1_options)),
    spinner1_exported
}
,
spinner1_exported.unuse = function() {
    spinner1_refs > 0 && !--spinner1_refs && (spinner1_update(),
    spinner1_update = null)
}
;
var loaders_spinner1 = spinner1_exported
  , AAssetManagerProcessStatePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class AAssetManagerProcessStatePlugin extends AViewerPlugin {
    _onEnabledChange() {
        this.enabled || (this._mainDiv.style.display = "none")
    }
    constructor(o, c) {
        super(),
        this.container = c,
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this.processState = new Map,
        this._mainDiv = ee$1({
            id: "assetManager" + o,
            addToBody: !1,
            innerHTML: ""
        }),
        this._contentDiv = ee$1({
            id: "assetManager" + o + "Content",
            addToBody: !1,
            innerHTML: ""
        }),
        this.enabled || (this._mainDiv.style.display = "none"),
        this._mainDiv.appendChild(this._contentDiv)
    }
    async onAdded(o) {
        var c, h, _, b, _e, nt, it, at, ut, pt, ht, _t, vt;
        await super.onAdded(o),
        ((c = this.container) !== null && c !== void 0 ? c : o.container).appendChild(this._mainDiv),
        this._updateMainDiv(this.processState),
        (_ = (h = o.getManager()) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.addEventListener("importFile", bt => {
            bt.state !== "done" ? this.processState.set(bt.path, {
                state: bt.state,
                progress: bt.progress ? 100 * bt.progress : void 0
            }) : this.processState.delete(bt.path),
            this._updateMainDiv(this.processState)
        }
        ),
        (_e = (b = o.getManager()) === null || b === void 0 ? void 0 : b.importer) === null || _e === void 0 || _e.addEventListener("processFileStart", bt => {
            this.processState.set(bt.path, {
                state: "processing",
                progress: void 0
            }),
            this._updateMainDiv(this.processState)
        }
        ),
        (it = (nt = o.getManager()) === null || nt === void 0 ? void 0 : nt.importer) === null || it === void 0 || it.addEventListener("processFileEnd", bt => {
            this.processState.delete(bt.path),
            this._updateMainDiv(this.processState)
        }
        ),
        (ut = (at = o.getManager()) === null || at === void 0 ? void 0 : at.exporter) === null || ut === void 0 || ut.addEventListener("exportFile", bt => {
            bt.state !== "done" ? this.processState.set(bt.obj.name, {
                state: bt.state,
                progress: bt.progress ? 100 * bt.progress : void 0
            }) : this.processState.delete(bt.obj.name),
            this._updateMainDiv(this.processState)
        }
        ),
        (pt = o.getPluginByType("FileTransferPlugin")) === null || pt === void 0 || pt.addEventListener("transferFile", bt => {
            bt.state !== "done" ? this.processState.set(bt.path, {
                state: bt.state,
                progress: bt.progress ? 100 * bt.progress : void 0
            }) : this.processState.delete(bt.path),
            this._updateMainDiv(this.processState)
        }
        ),
        (ht = o.getPluginByType("MaterialConfiguratorPlugin")) === null || ht === void 0 || ht.addEventListener("progress", bt => {
            bt.state !== "done" ? this.processState.set("MatpreviewGeneration", {
                state: bt.state,
                progress: 0
            }) : this.processState.delete("MatpreviewGeneration"),
            this._updateMainDiv(this.processState)
        }
        ),
        (_t = o.getPluginByType("SwitchNodePlugin")) === null || _t === void 0 || _t.addEventListener("progress", bt => {
            bt.state !== "done" ? this.processState.set("SwitchNodeGeneration", {
                state: bt.state,
                progress: 0
            }) : this.processState.delete("SwitchNodeGeneration"),
            this._updateMainDiv(this.processState)
        }
        ),
        (vt = o.getPluginByType("ThemePlugin")) === null || vt === void 0 || vt.addEventListener("progress", bt => {
            bt.state !== "done" ? this.processState.set("ThemeInit", {
                state: bt.state,
                progress: 0
            }) : this.processState.delete("ThemeInit"),
            this._updateMainDiv(this.processState)
        }
        )
    }
    async onRemove(o) {
        var c;
        return this._mainDiv.remove(),
        (c = this._contentDiv) === null || c === void 0 || c.remove(),
        this.processState.clear(),
        super.onRemove(o)
    }
}
AAssetManagerProcessStatePlugin_decorate([uiToggle("Enabled"), x$1(AAssetManagerProcessStatePlugin.prototype._onEnabledChange), serialize()], AAssetManagerProcessStatePlugin.prototype, "enabled", void 0);
var LoadingScreenPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, LoadingScreenPlugin_1;
let LoadingScreenPlugin = LoadingScreenPlugin_1 = class extends AAssetManagerProcessStatePlugin {
    refresh() {
        this._updateMainDiv(this._isPreviewing ? this._previewState : this.processState, !1)
    }
    togglePreview() {
        this.maximize(),
        this._isPreviewing = !this._isPreviewing,
        this.refresh(),
        this._isPreviewing ? this.show() : this.hideWithDelay()
    }
    constructor(d) {
        super("LoadingScreen", d),
        this.styles = styles_loadingScreen,
        this.spinners = [{
            styles: loaders_spinner1,
            html: '<span class="loader"></span>'
        }],
        this.loader = 0,
        this.loadingTextHeader = "Loading Files",
        this.errorTextHeader = "Error Loading Files",
        this.showFileNames = !0,
        this.showProcessStates = !0,
        this.showProgress = !0,
        this.hideOnOnlyErrors = !0,
        this.hideOnFilesLoad = !0,
        this.hideOnSceneObjectLoad = !1,
        this.minimizeOnSceneObjectLoad = !0,
        this.showOnFilesLoading = !0,
        this.showOnSceneEmpty = !0,
        this.hideDelay = 500,
        this.backgroundOpacity = .5,
        this.backgroundBlur = 24,
        this.background = "#ffffff",
        this.textColor = "#222222",
        this.logoImage = LoadingScreenPlugin_1.LS_DEFAULT_LOGO,
        this._isPreviewing = !1,
        this._previewState = new Map([["file.glb", {
            state: "downloading",
            progress: 50
        }], ["1_metal_whitegold_polished_0db3fb834b.pmat", {
            state: "adding"
        }]]),
        this.loadingElement = ee$1({
            classList: ["loadingScreenLoadingElement"],
            addToBody: !1
        }),
        this.filesElement = ee$1({
            classList: ["loadingScreenFilesElement"],
            addToBody: !1
        }),
        this.logoElement = ee$1({
            classList: ["loadingScreenLogoElement"],
            addToBody: !1
        }),
        this._isHidden = !1,
        this._temp = document.createElement("template"),
        this.isEditor = !1,
        this._sceneUpdate = o => {
            if (!this._viewer || !o.hierarchyChanged)
                return;
            const c = this._viewer.scene.modelRoot.children;
            c.length === 0 && this.showOnSceneEmpty && !this.isEditor && this.show(),
            c.length > 0 ? this.hideOnSceneObjectLoad ? this.hideWithDelay() : this.minimizeOnSceneObjectLoad && this._viewer.scene.environment && X$2(this.hideDelay + 300).then( () => this.minimize()) : this.minimizeOnSceneObjectLoad && this.maximize()
        }
        ,
        this._mainDiv.prepend(this.loadingElement),
        this._mainDiv.prepend(this.logoElement),
        this._mainDiv.appendChild(this.filesElement)
    }
    get visible() {
        return !this._isHidden
    }
    async hide() {
        this._isHidden = !0,
        this._mainDiv.style.opacity = "0",
        await X$2(502),
        this._isHidden && (this._mainDiv.style.display = "none",
        this._showMainDiv())
    }
    async hideWithDelay() {
        if (this._isHidden = !0,
        await X$2(this.hideDelay),
        this._isHidden)
            return this.hide()
    }
    show() {
        this._isHidden && (this._isHidden = !1,
        this._showMainDiv(),
        this._mainDiv.style.display = "flex")
    }
    _showMainDiv() {
        this._mainDiv.style.opacity = "1"
    }
    minimize() {
        this._mainDiv.classList.add("minimizedLoadingScreen"),
        this.showFileNames || (this.loadingElement.style.display = "block")
    }
    maximize() {
        this._mainDiv.classList.remove("minimizedLoadingScreen"),
        this.loadingElement.style.display = ""
    }
    _setHTML(d, o) {
        this._temp.innerHTML = o,
        this._temp.innerHTML.trim() == d.innerHTML.trim() || (d.innerHTML = o)
    }
    _updateMainDiv(d, o=!0) {
        if (!this._viewer || !this._contentDiv)
            return;
        if (!this.enabled)
            return void (this._mainDiv.style.display = "none");
        if (this.showFileNames) {
            let h = "";
            d.forEach( (_, b) => {
                let _e = (b || "").split("/").pop();
                if (_e && _e.length > 16) {
                    const nt = _e.split(".").pop();
                    _e = nt === _e ? _e.slice(0, 16) : _e.slice(0, -nt.length - 1).slice(0, 16) + "..." + nt
                }
                h += (this.showProcessStates ? `<span class="loadingScreenProcessState">${_.state}</span>: ` : "") + _e + (this.showProgress && _.progress ? " - " + _.progress.toFixed(0) + "%" : "") + "<br>"
            }
            ),
            this._setHTML(this.filesElement, h)
        } else
            this._setHTML(this.filesElement, "");
        const c = [...d.values()].filter(h => h.state === "error");
        c.length > 0 && c.length === d.size && !this.hideOnOnlyErrors ? this._setHTML(this._contentDiv, this.errorTextHeader) : this._setHTML(this._contentDiv, this.loadingTextHeader),
        this._setHTML(this.loadingElement, this.spinners[this.loader].html),
        this._mainDiv.style.setProperty("--b-opacity", this.backgroundOpacity.toString()),
        this._mainDiv.style.setProperty("--b-background", this.background),
        this._mainDiv.style.backdropFilter = `blur(${this.backgroundBlur}px)`,
        this._mainDiv.style.color = this.textColor,
        this._setHTML(this.logoElement, this.logoImage ? `<img class="loadingScreenLogoImage" src="${this.logoImage}"/>` : ""),
        o && (this.hideOnFilesLoad && (d.size === 0 || c.length === d.size && this.hideOnOnlyErrors) ? this.hideDelay ? this.hideWithDelay() : this.hide() : d.size > 0 && this.showOnFilesLoading && (this._viewer.scene.modelRoot.children.length > 0 && this.minimizeOnSceneObjectLoad && this._viewer.scene.environment ? this.minimize() : this.maximize(),
        this.show()))
    }
    async onAdded(d) {
        var o;
        this.styles.use({
            target: (o = this.container) !== null && o !== void 0 ? o : d.container
        }),
        this.spinners.forEach(c => {
            var h;
            c.styles.use({
                target: (h = this.container) !== null && h !== void 0 ? h : d.container
            })
        }
        ),
        d.scene.addEventListener("sceneUpdate", this._sceneUpdate),
        await super.onAdded(d)
    }
    async onRemove(d) {
        d.scene.removeEventListener("sceneUpdate", this._sceneUpdate),
        await super.onRemove(d)
    }
}
;
LoadingScreenPlugin.PluginType = "LoadingScreenPlugin",
LoadingScreenPlugin.LS_DEFAULT_LOGO = "https://static.webgi.xyz/logo.svg",
LoadingScreenPlugin_decorate([uiDropdown("Loader", ["Spinner 1"].map( (d, o) => ({
    value: o,
    label: d
}))), serialize()], LoadingScreenPlugin.prototype, "loader", void 0),
LoadingScreenPlugin_decorate([uiInput("Loading text header"), x$1(LoadingScreenPlugin.prototype.refresh), serialize()], LoadingScreenPlugin.prototype, "loadingTextHeader", void 0),
LoadingScreenPlugin_decorate([uiInput("Error text header"), serialize()], LoadingScreenPlugin.prototype, "errorTextHeader", void 0),
LoadingScreenPlugin_decorate([uiToggle("Show file names"), serialize(), x$1(LoadingScreenPlugin.prototype.refresh)], LoadingScreenPlugin.prototype, "showFileNames", void 0),
LoadingScreenPlugin_decorate([uiToggle("Show process states"), serialize(), x$1(LoadingScreenPlugin.prototype.refresh)], LoadingScreenPlugin.prototype, "showProcessStates", void 0),
LoadingScreenPlugin_decorate([uiToggle("Show progress"), serialize(), x$1(LoadingScreenPlugin.prototype.refresh)], LoadingScreenPlugin.prototype, "showProgress", void 0),
LoadingScreenPlugin_decorate([uiToggle("Hide on only errors"), serialize()], LoadingScreenPlugin.prototype, "hideOnOnlyErrors", void 0),
LoadingScreenPlugin_decorate([uiToggle("Hide on files load"), serialize()], LoadingScreenPlugin.prototype, "hideOnFilesLoad", void 0),
LoadingScreenPlugin_decorate([uiToggle("Hide on scene object load"), serialize()], LoadingScreenPlugin.prototype, "hideOnSceneObjectLoad", void 0),
LoadingScreenPlugin_decorate([uiToggle("Minimize on scene object load"), serialize()], LoadingScreenPlugin.prototype, "minimizeOnSceneObjectLoad", void 0),
LoadingScreenPlugin_decorate([uiToggle("Show when files start loading"), serialize()], LoadingScreenPlugin.prototype, "showOnFilesLoading", void 0),
LoadingScreenPlugin_decorate([uiToggle("Show when scene empty"), serialize()], LoadingScreenPlugin.prototype, "showOnSceneEmpty", void 0),
LoadingScreenPlugin_decorate([uiInput("Hide delay (ms)"), serialize()], LoadingScreenPlugin.prototype, "hideDelay", void 0),
LoadingScreenPlugin_decorate([uiSlider("Background Opacity", [0, 1]), x$1(LoadingScreenPlugin.prototype.refresh), serialize()], LoadingScreenPlugin.prototype, "backgroundOpacity", void 0),
LoadingScreenPlugin_decorate([uiSlider("Background Blur", [0, 100]), x$1(LoadingScreenPlugin.prototype.refresh), serialize()], LoadingScreenPlugin.prototype, "backgroundBlur", void 0),
LoadingScreenPlugin_decorate([uiInput("Background Color"), x$1(LoadingScreenPlugin.prototype.refresh), serialize()], LoadingScreenPlugin.prototype, "background", void 0),
LoadingScreenPlugin_decorate([uiInput("Text Color"), x$1(LoadingScreenPlugin.prototype.refresh), serialize()], LoadingScreenPlugin.prototype, "textColor", void 0),
LoadingScreenPlugin_decorate([uiInput("Logo Image"), x$1(LoadingScreenPlugin.prototype.refresh), serialize()], LoadingScreenPlugin.prototype, "logoImage", void 0),
LoadingScreenPlugin_decorate([uiButton("Toggle preview")], LoadingScreenPlugin.prototype, "togglePreview", null),
LoadingScreenPlugin_decorate([uiButton("Minimize")], LoadingScreenPlugin.prototype, "minimize", null),
LoadingScreenPlugin_decorate([uiButton("Maximize")], LoadingScreenPlugin.prototype, "maximize", null),
LoadingScreenPlugin = LoadingScreenPlugin_1 = LoadingScreenPlugin_decorate([uiFolder("Loading Screen")], LoadingScreenPlugin);
const APP_NAME = "iJewel3dSDK_WebGi"
  , APP_VERSION = ViewerApp.VERSION
  , logoSvgUrl = "https://playground.ijewel3d.com/logo_black.svg"
  , console1 = {
    error: d => setTimeout( () => console.error(new Error(d)), 612)
};
class BaseIJewel3DKeyPlugin extends AViewerPlugin {
    setKey(o) {
        this._checking || this._checkPromise || (this._checking = Date.now(),
        this._checkPromise = this._check(o),
        this._checkPromise.then( () => this._checkPromise = void 0))
    }
    async _check(o) {
        await new LicenseVerification(APP_NAME,APP_VERSION).verify(o) || (console1.error(this._errMessage),
        this._logoContainer = this._createContainerLogo())
    }
    _createContainerLogo() {
        const o = document.createElement("div");
        o.innerHTML = logoSvg,
        o.style.position = "absolute",
        o.style.padding = "1rem",
        o.style.left = "0",
        o.style.bottom = "0",
        o.style.width = "100%",
        o.style.height = "auto",
        o.style.display = "flex",
        o.style.alignItems = "center",
        o.style.backgroundColor = "rgba(0, 0, 0, 0)",
        o.style.zIndex = "9999",
        o.style.pointerEvents = "none";
        const c = o.children[0];
        c.style.width = "calc(min(20%, 150px))",
        c.style.height = "auto",
        c.onclick = () => {
            window.open("https://ijewel3d.com/", "_top")
        }
        ,
        this._logoContainer = o;
        const h = document.getElementById("webgi-logo");
        return h && h.remove(),
        o
    }
    constructor() {
        super(),
        this._errMessage = `iJewel3D ${APP_NAME} ${APP_VERSION}. FOR EVALUATION PURPOSES ONLY. For more information visit: https://ijewel3d.com/`,
        this._checking = 0,
        this._licenseInUse = !1,
        this._autoKey = !0,
        setInterval( () => {
            var o;
            if (this._checkPromise && Date.now() - this._checking > 15e3 && (console1.error(this._errMessage),
            this._logoContainer = this._createContainerLogo(),
            typeof this._checkPromise.cancel == "function" && this._checkPromise.cancel(),
            this._checkPromise = void 0),
            this._logoContainer && !this._logoContainer.parentElement && this._viewer && this._licenseInUse) {
                this._lContainer.appendChild(this._logoContainer);
                const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(LoadingScreenPlugin);
                c && (c.logoImage = logoSvgUrl,
                LoadingScreenPlugin.LS_DEFAULT_LOGO = logoSvgUrl)
            }
        }
        , 5e3)
    }
    get _lContainer() {
        var o;
        const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.container;
        if (!c)
            return document.body;
        const h = window.getComputedStyle(c).position;
        return h !== "absolute" && h !== "relative" && h !== "fixed" ? document.body : c
    }
    use() {
        var o;
        if (!this._licenseInUse && (this._licenseInUse = !0,
        !this._checking))
            if (this._autoKey)
                this.setKey("auto");
            else {
                console1.error(this._errMessage),
                this._logoContainer = this._createContainerLogo(),
                this._lContainer.appendChild(this._logoContainer);
                const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(LoadingScreenPlugin);
                c && (LoadingScreenPlugin.LS_DEFAULT_LOGO = logoSvgUrl,
                c.logoImage = logoSvgUrl)
            }
    }
    unuse() {}
    async onAdded(o) {
        await super.onAdded(o)
    }
}
const logoSvg = `
`;
var diamondPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class DiamondPlugin extends BaseIJewel3DKeyPlugin {
    get envMapRotation() {
        var o, c;
        return (c = (o = this.envMap) === null || o === void 0 ? void 0 : o.rotation) !== null && c !== void 0 ? c : 0
    }
    set envMapRotation(o) {
        var c;
        const h = [this.envMap, this.envMap2, this.envMap3];
        for (const _ of h)
            _ && (_.rotation = o,
            (c = this._viewer) === null || c === void 0 || c.scene.setDirty())
    }
    refreshEnvMaps() {
        var o, c, h;
        if (!this._viewer)
            return;
        const _ = this.getEnvMaps()
          , b = ((c = (o = this._viewer.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 ? void 0 : c.getMaterialsOfType(DiamondMaterial.TypeSlug)) || [];
        for (const _e of b)
            _e && (_e.envMaps = _);
        (h = this._viewer) === null || h === void 0 || h.scene.setDirty()
    }
    constructor() {
        super(),
        this.offsetCache = {},
        this.enabled = !0,
        this.envMap = null,
        this.envMap2 = null,
        this.envMap3 = null,
        this.forceSceneEnvMap = !1,
        this.getEnvMaps = () => {
            var o;
            if (!this.forceSceneEnvMap && this.envMap)
                return [this.envMap, this.envMap2, this.envMap3];
            const c = ((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.environment) || null;
            return [c, c, c]
        }
        ,
        this._modelProcessor = {
            forAssetType: "model",
            processAsync: async (o, c) => {
                const h = [];
                return o.modelObject.traverse(_ => {
                    var b, _e, nt, it;
                    const at = (_e = (b = _.userData) === null || b === void 0 ? void 0 : b.gltfExtensions) === null || _e === void 0 ? void 0 : _e[DiamondPlugin.DIAMOND_GLTF_EXTENSION];
                    at && _.geometry && (this.prepareDiamondMesh(_, at),
                    delete _.userData.gltfExtensions[DiamondPlugin.DIAMOND_GLTF_EXTENSION]),
                    _.material && !h.includes(_.material) && (!((it = (nt = _.material.userData) === null || nt === void 0 ? void 0 : nt.gltfExtensions) === null || it === void 0) && it[DiamondPlugin.DIAMOND_GLTF_EXTENSION]) && (_.material.materialObject || console.warn("WebGi DiamondPlugin: material not processed", _.material),
                    h.push(_.material))
                }
                ),
                h.forEach(_ => {
                    const b = _.userData.gltfExtensions[DiamondPlugin.DIAMOND_GLTF_EXTENSION];
                    b && this._convertToDiamondMaterial(_, b)
                }
                ),
                o
            }
        },
        this.uiConfig = {
            type: "folder",
            label: "Diamonds",
            children: [{
                type: "checkbox",
                label: "Use Scene Environment",
                property: [this, "forceSceneEnvironment"],
                limitedUi: !0
            }, {
                type: "image",
                label: "Environment",
                hidden: () => this.forceSceneEnvMap,
                property: [this, "envMap"],
                limitedUi: !0
            }, {
                type: "slider",
                bounds: [0, 2 * Math.PI],
                hidden: () => this.forceSceneEnvMap,
                label: "Env Rotation",
                property: [this, "envMapRotation"],
                limitedUi: !0
            }, {
                type: "image",
                label: "Environment 2",
                hidden: () => this.forceSceneEnvMap,
                property: [this, "envMap2"]
            }, {
                type: "image",
                label: "Environment 3",
                hidden: () => this.forceSceneEnvMap,
                property: [this, "envMap3"]
            }, {
                type: "button",
                label: "Make Diamond",
                hidden: () => {
                    var o, c, h;
                    const _ = (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject()) === null || h === void 0 ? void 0 : h.material;
                    return !!Array.isArray(_) || (_ == null ? void 0 : _.typeSlug) !== MeshStandardMaterial2.TypeSlug
                }
                ,
                value: async () => {
                    var o, c, h, _, b, _e;
                    const nt = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
                    if (!(nt != null && nt.material))
                        return;
                    const it = await ((h = this._viewer) === null || h === void 0 ? void 0 : h.prompt("Cache key: Enter optional cache key unique to the diamond shape.", "", !1))
                      , at = (await ((_ = this._viewer) === null || _ === void 0 ? void 0 : _.prompt("Cache size: Enter size of the cache [64-1024]", "512", !1)) || "512").toLowerCase()
                      , ut = at.endsWith("high") ? "high" : at.endsWith("low") ? "low" : "medium";
                    let pt = parseInt(at);
                    isFinite(pt) || (pt = 512),
                    pt < 64 && (pt = 64),
                    ((b = nt.material.userData) === null || b === void 0 ? void 0 : b.__appliedMeshes.size) > 1 && await ((_e = this._viewer) === null || _e === void 0 ? void 0 : _e.confirm("Convert all: Apply diamond material to all the meshes with the same material?")) ? this.makeDiamond(nt.material, {
                        cacheKey: it || void 0,
                        normalMapRes: pt,
                        normalMapPrecision: ut
                    }, {}) : this.makeDiamondMesh(nt, {
                        cacheKey: it || void 0,
                        normalMapRes: pt,
                        normalMapPrecision: ut
                    }, {}),
                    this.refreshUi()
                }
                ,
                limitedUi: !0
            }, {
                type: "button",
                label: "Make Standard",
                hidden: () => {
                    var o, c, h;
                    const _ = (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject()) === null || h === void 0 ? void 0 : h.material;
                    return !!Array.isArray(_) || (_ == null ? void 0 : _.typeSlug) !== DiamondMaterial.TypeSlug
                }
                ,
                value: async () => {
                    var o, c, h, _, b, _e, nt, it;
                    const at = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject()
                      , ut = at == null ? void 0 : at.material;
                    if (!ut)
                        return;
                    const pt = ut.userData.__baseMaterial;
                    let ht = (b = (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getManager()) === null || _ === void 0 ? void 0 : _.materials) === null || b === void 0 ? void 0 : b.findMaterial(pt);
                    if (ht && !ht.isDiamondMaterial || (ht = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.createPhysicalMaterial({
                        color: ut.color
                    })),
                    ht) {
                        const _t = ut.userData.__appliedMeshes.size > 1 && await ((nt = this._viewer) === null || nt === void 0 ? void 0 : nt.confirm("Convert all with this material?")) ? Array.from(ut.userData.__appliedMeshes) : [at];
                        for (const vt of _t)
                            (it = vt == null ? void 0 : vt.setMaterial) === null || it === void 0 || it.call(vt, ht),
                            this.unprepareDiamondMesh(vt)
                    }
                    this.refreshUi()
                }
                ,
                limitedUi: !0
            }, {
                type: "button",
                label: "Auto Instance Diamonds (dev)",
                hidden: () => {
                    var o, c, h, _;
                    const b = (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject()) === null || h === void 0 ? void 0 : h.material;
                    return !!Array.isArray(b) || (b == null ? void 0 : b.typeSlug) !== DiamondMaterial.TypeSlug || ((_ = b.userData.__appliedMeshes) === null || _ === void 0 ? void 0 : _.size) < 2
                }
                ,
                value: async () => {
                    var o, c;
                    const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
                    if (!h)
                        return;
                    const _ = h.material;
                    _ && !Array.isArray(_) && autoGPUInstanceMeshes(_)
                }
            }, {
                type: "button",
                label: "Clear Cache",
                value: () => {
                    this.disposeAllCacheMaps()
                }
            }]
        },
        this.refreshEnvMaps = this.refreshEnvMaps.bind(this),
        this.refreshUi = this.refreshUi.bind(this)
    }
    refreshUi() {
        var o, c, h;
        (o = this._viewer) === null || o === void 0 || o.setDirty(),
        (h = (c = this.uiConfig) === null || c === void 0 ? void 0 : c.uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
    }
    async onAdded(o) {
        var c, h, _, b, _e, nt, it;
        this._normalCapture = new CubeNormalsCaptureHelper(o.renderer),
        this.offsetCache = {},
        o.scene.addEventListener("materialChanged", ht => {
            var _t, vt, bt, St, At;
            if (!((_t = ht.material) === null || _t === void 0) && _t.isDiamondMaterial) {
                const Et = ht.material
                  , Pt = ht.mesh || ht.object;
                if (Pt.geometry && !(!((vt = this._normalCapture) === null || vt === void 0) && vt.hasCapturedNormalMap(Pt.geometry))) {
                    const Dt = (At = (St = (bt = Et == null ? void 0 : Et.userData) === null || bt === void 0 ? void 0 : bt.gltfExtensions) === null || St === void 0 ? void 0 : St[DiamondPlugin.DIAMOND_GLTF_EXTENSION]) !== null && At !== void 0 ? At : {};
                    Dt.cacheKey === void 0 && !Pt.userData._diamondCacheKey && (Et != null && Et.name) && (Dt.cacheKey = Et.name),
                    this.prepareDiamondMesh(Pt, Dt)
                }
                const It = this.getEnvMaps();
                Et.envMaps = It
            }
        }
        ),
        o.scene.addEventListener("environmentChanged", this.refreshEnvMaps);
        const at = o.getPlugin(AssetManagerPlugin);
        (c = at == null ? void 0 : at.importer) === null || c === void 0 || c.processors.add("model", this._modelProcessor),
        (h = o.getPlugin(PickingPlugin)) === null || h === void 0 || h.addEventListener("selectedObjectChanged", this.refreshUi);
        const ut = this.getEnvMaps
          , pt = new Importer(class extends SimpleJSONLoader {
            async loadAsync(ht, _t) {
                var vt;
                const bt = await super.loadAsync(ht, _t);
                return bt.type === DiamondMaterial.TYPE || bt.isDiamondMaterialParameters ? (bt.envMap = ut(),
                (vt = at == null ? void 0 : at.materials) === null || vt === void 0 ? void 0 : vt.generateFromTemplate("diamond", bt)) : (console.error("Invalid material type for Diamond Material.", bt),
                null)
            }
        }
        ,[DiamondMaterial.TypeSlug],!1);
        return (_ = at == null ? void 0 : at.importer) === null || _ === void 0 || _.Importers.push(pt),
        (nt = (_e = (b = at == null ? void 0 : at.exporter) === null || b === void 0 ? void 0 : b.getExporter("gltf", "glb")) === null || _e === void 0 ? void 0 : _e.extensions) === null || nt === void 0 || nt.push(diamondMaterialGLTFExportExtension),
        (it = at == null ? void 0 : at.materials) === null || it === void 0 || it.registerMaterialTemplate({
            name: "diamond",
            materialType: DiamondMaterial.TYPE,
            isDiamondMaterialParameters: !0,
            generator: (ht, _t) => {
                const vt = !(_t != null && _t.metadata || !_t.isDiamondMaterialParameters) || (_t == null ? void 0 : _t.metadata) && (_t == null ? void 0 : _t.metadata.version) <= 4.5
                  , bt = _t == null ? void 0 : _t.color;
                vt && typeof _t.color == "number" && (_t.color = new three_module.Q1f().setHex(_t.color, three_module.Zr2).getHex());
                const St = new DiamondMaterial(ht);
                return St.envMaps = this.getEnvMaps(),
                !_t || _t.isMeshStandardMaterial || _t.isMeshPhysicalMaterial || St.copyProps(_t),
                _t.color = bt,
                St
            }
        }),
        super.onAdded(o)
    }
    async onRemove(o) {
        var c, h, _, b;
        return (c = this._normalCapture) === null || c === void 0 || c.dispose(),
        this._normalCapture = void 0,
        this.offsetCache = {},
        (_ = (h = o.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.processors.remove("model", this._modelProcessor),
        (b = o.getPlugin(PickingPlugin)) === null || b === void 0 || b.removeEventListener("selectedObjectChanged", this.refreshUi),
        super.onRemove(o)
    }
    unprepareDiamondMesh(o) {
        var c;
        o.userData && (delete o.userData._diamondCacheKey,
        delete o.userData._diamondNormalMapRes,
        delete o.userData._diamondNormalMapPrecision,
        o.geometry && (this._removeOffsets(o.geometry),
        (c = this._normalCapture) === null || c === void 0 || c.removeNormalMap(o.geometry)))
    }
    prepareDiamondMesh(o, {cacheKey: c, normalMapRes: h, normalMapPrecision: _}) {
        var b, _e, nt;
        this.use(),
        o.userData._diamondCacheKey = c ?? o.userData._diamondCacheKey,
        o.userData._diamondNormalMapRes = h ?? o.userData._diamondNormalMapRes,
        o.userData._diamondNormalMapPrecision = _ ?? o.userData._diamondNormalMapPrecision,
        c = c && c.length > 0 ? c.includes(";" + o.geometry.uuid) ? c : c + ";" + o.geometry.uuid : o.geometry.uuid,
        this._computeOffsets(o.geometry, o.geometry.uuid);
        const it = (_e = (b = this._normalCapture) === null || b === void 0 ? void 0 : b.captureNormalMap(o.geometry, c, h, _, o)) !== null && _e !== void 0 ? _e : [void 0, !1]
          , at = (nt = this._viewer) === null || nt === void 0 ? void 0 : nt.getPluginByType("debug");
        at && it && (at.counters.normalsCapture || (at.counters.normalsCapture = 0),
        at.counters.normalsCapture++,
        console.log("DEBUG: new normal map captured", at.counters.normalsCapture, c),
        at.addTexture("normal" + at.counters.normalsCapture, () => {
            var ut, pt;
            return (pt = (ut = o.geometry) === null || ut === void 0 ? void 0 : ut.userData._normalsCaptureMap) === null || pt === void 0 ? void 0 : pt.texture
        }
        , [40, 110 * at.counters.normalsCapture - 100, 200, 100], void 0, void 0, "postRender", !0))
    }
    makeDiamond(o, c, h) {
        var _, b;
        Array.from((_ = o == null ? void 0 : o.userData.__appliedMeshes) !== null && _ !== void 0 ? _ : []).forEach(_e => {
            _e != null && _e.isMesh && _e.geometry && this.prepareDiamondMesh(_e, c)
        }
        ),
        this._convertToDiamondMaterial(o, h),
        (b = this._viewer) === null || b === void 0 || b.setDirty()
    }
    makeDiamondMesh(o, c, h) {
        if (!o.modelObject.isMesh || !o.geometry || !o.setMaterial)
            return;
        this.prepareDiamondMesh(o.modelObject, c);
        const _ = Array.isArray(o.material) ? o.material[0] : o.material
          , b = this._convertToDiamondMaterial(_, h, !1);
        o.setMaterial(b)
    }
    _convertToDiamondMaterial(o, c={
        isDiamond: !0
    }, h=!0) {
        var _, b, _e, nt, it, at, ut, pt;
        let ht = {
            ...c ?? {}
        };
        ht.isDiamond || ht.isDiamondMaterialParameters ? Array.isArray(ht.boostFactors) && (ht.boostFactors = new three_module.Pq0().fromArray(ht.boostFactors)) : ht = {
            isDiamondMaterialParameters: !0
        },
        ht.color = (b = (_ = ht.color) !== null && _ !== void 0 ? _ : o == null ? void 0 : o.color) !== null && b !== void 0 ? b : new three_module.Q1f(1,1,1),
        ht.name = (nt = (_e = ht.name) !== null && _e !== void 0 ? _e : o == null ? void 0 : o.name) !== null && nt !== void 0 ? nt : "diamond";
        const _t = (ut = (at = (it = this._viewer) === null || it === void 0 ? void 0 : it.getManager()) === null || at === void 0 ? void 0 : at.materials) === null || ut === void 0 ? void 0 : ut.generateFromTemplate("diamond", ht);
        if (_t && o && !o.isDiamondMaterial && (_t.userData.__baseMaterial = o.uuid),
        h) {
            const vt = bt => {
                var St;
                return (St = bt.setMaterial) !== null && St !== void 0 ? St : At => {
                    bt.material = At.materialObject
                }
            }
            ;
            Array.from((pt = o == null ? void 0 : o.userData.__appliedMeshes) !== null && pt !== void 0 ? pt : []).forEach(bt => {
                vt(bt)(_t),
                this.prepareDiamondMesh(bt, c)
            }
            )
        }
        return _t
    }
    _computeOffsets(o, c, h=!1) {
        var _;
        if (o.userData.normalsCaptureOffsets) {
            if (rt("recomputeOffsets") === null)
                return o.userData.normalsCaptureOffsets;
            console.warn("WebGi DiamondPlugin: recomputeOffsets", o.userData.normalsCaptureOffsets)
        }
        let b;
        !((_ = o.morphAttributes) === null || _ === void 0) && _.position && (b = o.morphAttributes,
        o.morphAttributes = {}),
        o.computeBoundingBox();
        const _e = o.boundingBox.getCenter(new three_module.Pq0).toArray()
          , nt = computeEigenVectors(o).toArray()
          , it = new three_module.kn4().fromArray(nt).invert()
          , at = new three_module.Pq0().fromArray(_e).applyMatrix4(it).toArray()
          , ut = {
            center: _e,
            offsetMatrix: nt,
            offsetMatrixInv: it.toArray(),
            radius: 1,
            centerOffset: at
        };
        return o.userData.normalsCaptureOffsets = ut,
        b && (o.morphAttributes = b,
        o.computeBoundingBox()),
        rt("recomputeOffsets") !== null && console.warn("WebGi DiamondPlugin: recomputeOffsets", ut),
        ut
    }
    _removeOffsets(o) {
        delete o.userData.normalsCaptureOffsets
    }
    getAllCacheMaps() {
        var o;
        const c = new Set;
        return (o = this._viewer) === null || o === void 0 || o.scene.modelObject.traverse(h => {
            h.geometry && h.geometry.userData._normalsCaptureMap && c.add(h.geometry.userData._normalsCaptureMap)
        }
        ),
        [...c]
    }
    disposeCacheMap(o) {
        var c;
        (c = this._normalCapture) === null || c === void 0 || c.disposeTarget(o)
    }
    disposeAllCacheMaps() {
        var o;
        (o = this._normalCapture) === null || o === void 0 || o.disposeAllTargets()
    }
}
DiamondPlugin.PluginType = "Diamond",
DiamondPlugin.DIAMOND_GLTF_EXTENSION = "WEBGI_materials_diamond",
diamondPlugin_decorate([x$1(DiamondPlugin.prototype.refreshEnvMaps), serialize()], DiamondPlugin.prototype, "envMap", void 0),
diamondPlugin_decorate([x$1(DiamondPlugin.prototype.refreshEnvMaps), serialize()], DiamondPlugin.prototype, "envMap2", void 0),
diamondPlugin_decorate([x$1(DiamondPlugin.prototype.refreshEnvMaps), serialize()], DiamondPlugin.prototype, "envMap3", void 0),
diamondPlugin_decorate([x$1(DiamondPlugin.prototype.refreshEnvMaps), serialize()], DiamondPlugin.prototype, "forceSceneEnvMap", void 0);
const diamondMaterialGLTFExportExtension = d => ({
    writeMaterial: (o, c) => {
        o.isDiamondMaterial && (c.extensions = c.extensions || {},
        c.extensions[DiamondPlugin.DIAMOND_GLTF_EXTENSION] = o.toJSON(),
        d.extensionsUsed[DiamondPlugin.DIAMOND_GLTF_EXTENSION] = !0)
    }
    ,
    writeMesh: (o, c) => {
        var h, _;
        if (!(o != null && o.material.isDiamondMaterial))
            return;
        c.extensions = c.extensions || {};
        const b = {};
        (_ = (h = o.userData) === null || h === void 0 ? void 0 : h.gltfExtensions) === null || _ === void 0 || delete _[DiamondPlugin.DIAMOND_GLTF_EXTENSION],
        o.userData._diamondNormalMapRes && (b.normalMapRes = o.userData._diamondNormalMapRes),
        o.userData._diamondNormalMapPrecision && (b.normalMapPrecision = o.userData._diamondNormalMapPrecision),
        o.userData._diamondCacheKey && (b.cacheKey = o.userData._diamondCacheKey),
        c.extensions[DiamondPlugin.DIAMOND_GLTF_EXTENSION] = b,
        d.extensionsUsed[DiamondPlugin.DIAMOND_GLTF_EXTENSION] = !0
    }
});
var __assign = function() {
    return __assign = Object.assign || function(d) {
        for (var o, c = 1, h = arguments.length; c < h; c++)
            for (var _ in o = arguments[c])
                Object.prototype.hasOwnProperty.call(o, _) && (d[_] = o[_]);
        return d
    }
    ,
    __assign.apply(this, arguments)
};
function __rest(d, o) {
    var c = {};
    for (var h in d)
        Object.prototype.hasOwnProperty.call(d, h) && o.indexOf(h) < 0 && (c[h] = d[h]);
    if (d != null && typeof Object.getOwnPropertySymbols == "function") {
        var _ = 0;
        for (h = Object.getOwnPropertySymbols(d); _ < h.length; _++)
            o.indexOf(h[_]) < 0 && Object.prototype.propertyIsEnumerable.call(d, h[_]) && (c[h[_]] = d[h[_]])
    }
    return c
}
function __spreadArray(d, o, c) {
    if (c || arguments.length === 2)
        for (var h, _ = 0, b = o.length; _ < b; _++)
            !h && _ in o || (h || (h = Array.prototype.slice.call(o, 0, _)),
            h[_] = o[_]);
    return d.concat(h || Array.prototype.slice.call(o))
}
typeof SuppressedError == "function" && SuppressedError;
var invariant$1 = function() {}
  , clamp$1 = function(d, o, c) {
    return Math.min(Math.max(c, d), o)
}
  , safeMin$1 = .001
  , minDuration$1 = .01
  , maxDuration$2 = 10
  , minDamping$1 = .05
  , maxDamping$1 = 1;
function findSpring$1(d) {
    var o, c, h = d.duration, _ = h === void 0 ? 800 : h, b = d.bounce, _e = b === void 0 ? .25 : b, nt = d.velocity, it = nt === void 0 ? 0 : nt, at = d.mass, ut = at === void 0 ? 1 : at, pt = 1 - _e;
    pt = clamp$1(minDamping$1, maxDamping$1, pt),
    _ = clamp$1(minDuration$1, maxDuration$2, _ / 1e3),
    pt < 1 ? (o = function(vt) {
        var bt = vt * pt
          , St = bt * _
          , At = bt - it
          , Et = calcAngularFreq$1(vt, pt)
          , Pt = Math.exp(-St);
        return safeMin$1 - At / Et * Pt
    }
    ,
    c = function(vt) {
        var bt = vt * pt * _
          , St = bt * it + it
          , At = Math.pow(pt, 2) * Math.pow(vt, 2) * _
          , Et = Math.exp(-bt)
          , Pt = calcAngularFreq$1(Math.pow(vt, 2), pt);
        return (-o(vt) + safeMin$1 > 0 ? -1 : 1) * ((St - At) * Et) / Pt
    }
    ) : (o = function(vt) {
        return Math.exp(-vt * _) * ((vt - it) * _ + 1) - safeMin$1
    }
    ,
    c = function(vt) {
        return Math.exp(-vt * _) * (_ * _ * (it - vt))
    }
    );
    var ht = approximateRoot$1(o, c, 5 / _);
    if (_ *= 1e3,
    isNaN(ht))
        return {
            stiffness: 100,
            damping: 10,
            duration: _
        };
    var _t = Math.pow(ht, 2) * ut;
    return {
        stiffness: _t,
        damping: 2 * pt * Math.sqrt(ut * _t),
        duration: _
    }
}
var rootIterations$1 = 12;
function approximateRoot$1(d, o, c) {
    for (var h = c, _ = 1; _ < rootIterations$1; _++)
        h -= d(h) / o(h);
    return h
}
function calcAngularFreq$1(d, o) {
    return d * Math.sqrt(1 - o * o)
}
var durationKeys$1 = ["duration", "bounce"]
  , physicsKeys$1 = ["stiffness", "damping", "mass"];
function isSpringType$1(d, o) {
    return o.some(function(c) {
        return d[c] !== void 0
    })
}
function getSpringOptions$1(d) {
    var o = __assign({
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1
    }, d);
    if (!isSpringType$1(d, physicsKeys$1) && isSpringType$1(d, durationKeys$1)) {
        var c = findSpring$1(d);
        (o = __assign(__assign(__assign({}, o), c), {
            velocity: 0,
            mass: 1
        })).isResolvedFromDuration = !0
    }
    return o
}
function spring$1(d) {
    var o = d.from
      , c = o === void 0 ? 0 : o
      , h = d.to
      , _ = h === void 0 ? 1 : h
      , b = d.restSpeed
      , _e = b === void 0 ? 2 : b
      , nt = d.restDelta
      , it = __rest(d, ["from", "to", "restSpeed", "restDelta"])
      , at = {
        done: !1,
        value: c
    }
      , ut = getSpringOptions$1(it)
      , pt = ut.stiffness
      , ht = ut.damping
      , _t = ut.mass
      , vt = ut.velocity
      , bt = ut.duration
      , St = ut.isResolvedFromDuration
      , At = zero
      , Et = zero;
    function Pt() {
        var It = vt ? -vt / 1e3 : 0
          , Dt = _ - c
          , Gt = ht / (2 * Math.sqrt(pt * _t))
          , Bt = Math.sqrt(pt / _t) / 1e3;
        if (nt != null || (nt = Math.abs(_ - c) <= 1 ? .01 : .4),
        Gt < 1) {
            var kt = calcAngularFreq$1(Bt, Gt);
            At = function(Ht) {
                var Kt = Math.exp(-Gt * Bt * Ht);
                return _ - Kt * ((It + Gt * Bt * Dt) / kt * Math.sin(kt * Ht) + Dt * Math.cos(kt * Ht))
            }
            ,
            Et = function(Ht) {
                var Kt = Math.exp(-Gt * Bt * Ht);
                return Gt * Bt * Kt * (Math.sin(kt * Ht) * (It + Gt * Bt * Dt) / kt + Dt * Math.cos(kt * Ht)) - Kt * (Math.cos(kt * Ht) * (It + Gt * Bt * Dt) - kt * Dt * Math.sin(kt * Ht))
            }
        } else if (Gt === 1)
            At = function(Ht) {
                return _ - Math.exp(-Bt * Ht) * (Dt + (It + Bt * Dt) * Ht)
            }
            ;
        else {
            var Ut = Bt * Math.sqrt(Gt * Gt - 1);
            At = function(Ht) {
                var Kt = Math.exp(-Gt * Bt * Ht)
                  , Jt = Math.min(Ut * Ht, 300);
                return _ - Kt * ((It + Gt * Bt * Dt) * Math.sinh(Jt) + Ut * Dt * Math.cosh(Jt)) / Ut
            }
        }
    }
    return Pt(),
    {
        next: function(It) {
            var Dt = At(It);
            if (St)
                at.done = It >= bt;
            else {
                var Gt = 1e3 * Et(It)
                  , Bt = Math.abs(Gt) <= _e
                  , kt = Math.abs(_ - Dt) <= nt;
                at.done = Bt && kt
            }
            return at.value = at.done ? _ : Dt,
            at
        },
        flipTarget: function() {
            var It;
            vt = -vt,
            c = (It = [_, c])[0],
            _ = It[1],
            Pt()
        }
    }
}
spring$1.needsInterpolation = function(d, o) {
    return typeof d == "string" || typeof o == "string"
}
;
var zero = function(d) {
    return 0
}
  , progress$1 = function(d, o, c) {
    var h = o - d;
    return h === 0 ? 1 : (c - d) / h
}
  , mix$1 = function(d, o, c) {
    return -c * d + c * o + d
}
  , utils_clamp = function(d, o) {
    return function(c) {
        return Math.max(Math.min(c, o), d)
    }
}
  , sanitize$1 = function(d) {
    return d % 1 ? Number(d.toFixed(5)) : d
}
  , floatRegex$1 = /(-)?([\d]*\.?[\d])+/g
  , colorRegex$1 = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi
  , singleColorRegex$1 = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString$1(d) {
    return typeof d == "string"
}
var number$1 = {
    test: function(d) {
        return typeof d == "number"
    },
    parse: parseFloat,
    transform: function(d) {
        return d
    }
}
  , alpha$1 = __assign(__assign({}, number$1), {
    transform: utils_clamp(0, 1)
});
__assign(__assign({}, number$1), {
    default: 1
});
var isColorString$1 = function(d, o) {
    return function(c) {
        return !!(isString$1(c) && singleColorRegex$1.test(c) && c.startsWith(d) || o && Object.prototype.hasOwnProperty.call(c, o))
    }
}
  , splitColor$1 = function(d, o, c) {
    return function(h) {
        var _;
        if (!isString$1(h))
            return h;
        var b = h.match(floatRegex$1)
          , _e = b[0]
          , nt = b[1]
          , it = b[2]
          , at = b[3];
        return (_ = {})[d] = parseFloat(_e),
        _[o] = parseFloat(nt),
        _[c] = parseFloat(it),
        _.alpha = at !== void 0 ? parseFloat(at) : 1,
        _
    }
}
  , clampRgbUnit$1 = utils_clamp(0, 255)
  , rgbUnit$1 = __assign(__assign({}, number$1), {
    transform: function(d) {
        return Math.round(clampRgbUnit$1(d))
    }
})
  , rgba$1 = {
    test: isColorString$1("rgb", "red"),
    parse: splitColor$1("red", "green", "blue"),
    transform: function(d) {
        var o = d.red
          , c = d.green
          , h = d.blue
          , _ = d.alpha
          , b = _ === void 0 ? 1 : _;
        return "rgba(" + rgbUnit$1.transform(o) + ", " + rgbUnit$1.transform(c) + ", " + rgbUnit$1.transform(h) + ", " + sanitize$1(alpha$1.transform(b)) + ")"
    }
};
function parseHex$1(d) {
    var o = ""
      , c = ""
      , h = ""
      , _ = "";
    return d.length > 5 ? (o = d.substr(1, 2),
    c = d.substr(3, 2),
    h = d.substr(5, 2),
    _ = d.substr(7, 2)) : (o = d.substr(1, 1),
    c = d.substr(2, 1),
    h = d.substr(3, 1),
    _ = d.substr(4, 1),
    o += o,
    c += c,
    h += h,
    _ += _),
    {
        red: parseInt(o, 16),
        green: parseInt(c, 16),
        blue: parseInt(h, 16),
        alpha: _ ? parseInt(_, 16) / 255 : 1
    }
}
var hex$1 = {
    test: isColorString$1("#"),
    parse: parseHex$1,
    transform: rgba$1.transform
}
  , createUnitType$1 = function(d) {
    return {
        test: function(o) {
            return isString$1(o) && o.endsWith(d) && o.split(" ").length === 1
        },
        parse: parseFloat,
        transform: function(o) {
            return "" + o + d
        }
    }
}
  , percent$1 = createUnitType$1("%");
__assign(__assign({}, percent$1), {
    parse: function(d) {
        return percent$1.parse(d) / 100
    },
    transform: function(d) {
        return percent$1.transform(100 * d)
    }
});
var hsla$1 = {
    test: isColorString$1("hsl", "hue"),
    parse: splitColor$1("hue", "saturation", "lightness"),
    transform: function(d) {
        var o = d.hue
          , c = d.saturation
          , h = d.lightness
          , _ = d.alpha
          , b = _ === void 0 ? 1 : _;
        return "hsla(" + Math.round(o) + ", " + percent$1.transform(sanitize$1(c)) + ", " + percent$1.transform(sanitize$1(h)) + ", " + sanitize$1(alpha$1.transform(b)) + ")"
    }
}
  , mixLinearColor$1 = function(d, o, c) {
    var h = d * d
      , _ = o * o;
    return Math.sqrt(Math.max(0, c * (_ - h) + h))
}
  , colorTypes$1 = [hex$1, rgba$1, hsla$1]
  , getColorType$1 = function(d) {
    return colorTypes$1.find(function(o) {
        return o.test(d)
    })
}
  , mixColor$1 = function(d, o) {
    var c = getColorType$1(d)
      , h = getColorType$1(o);
    if (invariant$1(c.transform === h.transform),
    !c || !h || c.transform !== h.transform)
        return function(it) {
            return "" + (it > 0 ? o : d)
        }
        ;
    var _ = c.parse(d)
      , b = h.parse(o)
      , _e = __assign({}, _)
      , nt = c === hsla$1 ? mix$1 : mixLinearColor$1;
    return function(it) {
        for (var at in _e)
            at !== "alpha" && (_e[at] = nt(_[at], b[at], it));
        return _e.alpha = mix$1(_.alpha, b.alpha, it),
        c.transform(_e)
    }
}
  , color$1 = {
    test: function(d) {
        return rgba$1.test(d) || hex$1.test(d) || hsla$1.test(d)
    },
    parse: function(d) {
        return rgba$1.test(d) ? rgba$1.parse(d) : hsla$1.test(d) ? hsla$1.parse(d) : hex$1.parse(d)
    },
    transform: function(d) {
        return isString$1(d) ? d : d.hasOwnProperty("red") ? rgba$1.transform(d) : hsla$1.transform(d)
    }
}
  , colorToken = "${c}"
  , numberToken = "${n}";
function test$1(d) {
    var o, c, h, _;
    return isNaN(d) && isString$1(d) && ((c = (o = d.match(floatRegex$1)) === null || o === void 0 ? void 0 : o.length) !== null && c !== void 0 ? c : 0) + ((_ = (h = d.match(colorRegex$1)) === null || h === void 0 ? void 0 : h.length) !== null && _ !== void 0 ? _ : 0) > 0
}
function analyse(d) {
    typeof d == "number" && (d = "" + d);
    var o = []
      , c = 0
      , h = d.match(colorRegex$1);
    h && (c = h.length,
    d = d.replace(colorRegex$1, colorToken),
    o.push.apply(o, h.map(color$1.parse)));
    var _ = d.match(floatRegex$1);
    return _ && (d = d.replace(floatRegex$1, numberToken),
    o.push.apply(o, _.map(number$1.parse))),
    {
        values: o,
        numColors: c,
        tokenised: d
    }
}
function parse(d) {
    return analyse(d).values
}
function createTransformer$1(d) {
    var o = analyse(d)
      , c = o.values
      , h = o.numColors
      , _ = o.tokenised
      , b = c.length;
    return function(_e) {
        for (var nt = _, it = 0; it < b; it++)
            nt = nt.replace(it < h ? colorToken : numberToken, it < h ? color$1.transform(_e[it]) : sanitize$1(_e[it]));
        return nt
    }
}
var convertNumbersToZero$1 = function(d) {
    return typeof d == "number" ? 0 : d
};
function getAnimatableNone$2(d) {
    var o = parse(d);
    return createTransformer$1(d)(o.map(convertNumbersToZero$1))
}
var complex$1 = {
    test: test$1,
    parse,
    createTransformer: createTransformer$1,
    getAnimatableNone: getAnimatableNone$2
}
  , zeroPoint = {
    x: 0,
    y: 0,
    z: 0
}
  , isNum = function(d) {
    return typeof d == "number"
}
  , combineFunctions$1 = function(d, o) {
    return function(c) {
        return o(d(c))
    }
}
  , pipe$1 = function() {
    for (var d = [], o = 0; o < arguments.length; o++)
        d[o] = arguments[o];
    return d.reduce(combineFunctions$1)
};
function getMixer$2(d, o) {
    return isNum(d) ? function(c) {
        return mix$1(d, o, c)
    }
    : color$1.test(d) ? mixColor$1(d, o) : mixComplex$1(d, o)
}
var mixArray$1 = function(d, o) {
    var c = __spreadArray([], d)
      , h = c.length
      , _ = d.map(function(b, _e) {
        return getMixer$2(b, o[_e])
    });
    return function(b) {
        for (var _e = 0; _e < h; _e++)
            c[_e] = _[_e](b);
        return c
    }
}
  , mixObject$1 = function(d, o) {
    var c = __assign(__assign({}, d), o)
      , h = {};
    for (var _ in c)
        d[_] !== void 0 && o[_] !== void 0 && (h[_] = getMixer$2(d[_], o[_]));
    return function(b) {
        for (var _e in h)
            c[_e] = h[_e](b);
        return c
    }
};
function mix_complex_analyse(d) {
    for (var o = complex$1.parse(d), c = o.length, h = 0, _ = 0, b = 0, _e = 0; _e < c; _e++)
        h || typeof o[_e] == "number" ? h++ : o[_e].hue !== void 0 ? b++ : _++;
    return {
        parsed: o,
        numNumbers: h,
        numRGB: _,
        numHSL: b
    }
}
var mixComplex$1 = function(d, o) {
    var c = complex$1.createTransformer(o)
      , h = mix_complex_analyse(d)
      , _ = mix_complex_analyse(o);
    return h.numHSL === _.numHSL && h.numRGB === _.numRGB && h.numNumbers >= _.numNumbers ? pipe$1(mixArray$1(h.parsed, _.parsed), c) : function(b) {
        return "" + (b > 0 ? o : d)
    }
}
  , mixNumber$2 = function(d, o) {
    return function(c) {
        return mix$1(d, o, c)
    }
};
function detectMixerFactory(d) {
    return typeof d == "number" ? mixNumber$2 : typeof d == "string" ? color$1.test(d) ? mixColor$1 : mixComplex$1 : Array.isArray(d) ? mixArray$1 : typeof d == "object" ? mixObject$1 : void 0
}
function createMixers$1(d, o, c) {
    for (var h = [], _ = c || detectMixerFactory(d[0]), b = d.length - 1, _e = 0; _e < b; _e++) {
        var nt = _(d[_e], d[_e + 1]);
        if (o) {
            var it = Array.isArray(o) ? o[_e] : o;
            nt = pipe$1(it, nt)
        }
        h.push(nt)
    }
    return h
}
function fastInterpolate(d, o) {
    var c = d[0]
      , h = d[1]
      , _ = o[0];
    return function(b) {
        return _(progress$1(c, h, b))
    }
}
function slowInterpolate(d, o) {
    var c = d.length
      , h = c - 1;
    return function(_) {
        var b = 0
          , _e = !1;
        if (_ <= d[0] ? _e = !0 : _ >= d[h] && (b = h - 1,
        _e = !0),
        !_e) {
            for (var nt = 1; nt < c && !(d[nt] > _ || nt === h); nt++)
                ;
            b = nt - 1
        }
        var it = progress$1(d[b], d[b + 1], _);
        return o[b](it)
    }
}
function interpolate$1(d, o, c) {
    var h = c === void 0 ? {} : c
      , _ = h.clamp
      , b = _ === void 0 || _
      , _e = h.ease
      , nt = h.mixer
      , it = d.length;
    invariant$1(it === o.length),
    invariant$1(!_e || !Array.isArray(_e) || _e.length === it - 1),
    d[0] > d[it - 1] && (d = [].concat(d),
    o = [].concat(o),
    d.reverse(),
    o.reverse());
    var at = createMixers$1(o, _e, nt)
      , ut = it === 2 ? fastInterpolate(d, at) : slowInterpolate(d, at);
    return b ? function(pt) {
        return ut(clamp$1(d[0], d[it - 1], pt))
    }
    : ut
}
var reverseEasing$1 = function(d) {
    return function(o) {
        return 1 - d(1 - o)
    }
}
  , mirrorEasing$1 = function(d) {
    return function(o) {
        return o <= .5 ? d(2 * o) / 2 : (2 - d(2 * (1 - o))) / 2
    }
}
  , createExpoIn = function(d) {
    return function(o) {
        return Math.pow(o, d)
    }
}
  , createBackIn = function(d) {
    return function(o) {
        return o * o * ((d + 1) * o - d)
    }
}
  , createAnticipate = function(d) {
    var o = createBackIn(d);
    return function(c) {
        return (c *= 2) < 1 ? .5 * o(c) : .5 * (2 - Math.pow(2, -10 * (c - 1)))
    }
}
  , DEFAULT_OVERSHOOT_STRENGTH = 1.525
  , BOUNCE_FIRST_THRESHOLD = 4 / 11
  , BOUNCE_SECOND_THRESHOLD = 8 / 11
  , BOUNCE_THIRD_THRESHOLD = .9
  , linear = function(d) {
    return d
}
  , easeIn$1 = createExpoIn(2)
  , easeOut$1 = reverseEasing$1(easeIn$1)
  , easeInOut$1 = mirrorEasing$1(easeIn$1)
  , circIn$1 = function(d) {
    return 1 - Math.sin(Math.acos(d))
}
  , circOut$1 = reverseEasing$1(circIn$1)
  , circInOut$1 = mirrorEasing$1(circOut$1)
  , backIn$1 = createBackIn(DEFAULT_OVERSHOOT_STRENGTH)
  , backOut$1 = reverseEasing$1(backIn$1)
  , backInOut$1 = mirrorEasing$1(backIn$1)
  , anticipate$1 = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH)
  , ca$1 = 4356 / 361
  , cb$1 = 35442 / 1805
  , cc$1 = 16061 / 1805
  , bounceOut = function(d) {
    if (d === 1 || d === 0)
        return d;
    var o = d * d;
    return d < BOUNCE_FIRST_THRESHOLD ? 7.5625 * o : d < BOUNCE_SECOND_THRESHOLD ? 9.075 * o - 9.9 * d + 3.4 : d < BOUNCE_THIRD_THRESHOLD ? ca$1 * o - cb$1 * d + cc$1 : 10.8 * d * d - 20.52 * d + 10.72
}
  , bounceIn = reverseEasing$1(bounceOut)
  , bounceInOut = function(d) {
    return d < .5 ? .5 * (1 - bounceOut(1 - 2 * d)) : .5 * bounceOut(2 * d - 1) + .5
};
function defaultEasing$1(d, o) {
    return d.map(function() {
        return o || easeInOut$1
    }).splice(0, d.length - 1)
}
function defaultOffset$1(d) {
    var o = d.length;
    return d.map(function(c, h) {
        return h !== 0 ? h / (o - 1) : 0
    })
}
function convertOffsetToTimes$1(d, o) {
    return d.map(function(c) {
        return c * o
    })
}
function keyframes$1(d) {
    var o = d.from
      , c = o === void 0 ? 0 : o
      , h = d.to
      , _ = h === void 0 ? 1 : h
      , b = d.ease
      , _e = d.offset
      , nt = d.duration
      , it = nt === void 0 ? 300 : nt
      , at = {
        done: !1,
        value: c
    }
      , ut = Array.isArray(_) ? _ : [c, _]
      , pt = convertOffsetToTimes$1(_e && _e.length === ut.length ? _e : defaultOffset$1(ut), it);
    function ht() {
        return interpolate$1(pt, ut, {
            ease: Array.isArray(b) ? b : defaultEasing$1(ut, b)
        })
    }
    var _t = ht();
    return {
        next: function(vt) {
            return at.value = _t(vt),
            at.done = vt >= it,
            at
        },
        flipTarget: function() {
            ut.reverse(),
            _t = ht()
        }
    }
}
function decay(d) {
    var o = d.velocity
      , c = o === void 0 ? 0 : o
      , h = d.from
      , _ = h === void 0 ? 0 : h
      , b = d.power
      , _e = b === void 0 ? .8 : b
      , nt = d.timeConstant
      , it = nt === void 0 ? 350 : nt
      , at = d.restDelta
      , ut = at === void 0 ? .5 : at
      , pt = d.modifyTarget
      , ht = {
        done: !1,
        value: _
    }
      , _t = _e * c
      , vt = _ + _t
      , bt = pt === void 0 ? vt : pt(vt);
    return bt !== vt && (_t = bt - _),
    {
        next: function(St) {
            var At = -_t * Math.exp(-St / it);
            return ht.done = !(At > ut || At < -ut),
            ht.value = ht.done ? bt : bt + At,
            ht
        },
        flipTarget: function() {}
    }
}
var types = {
    keyframes: keyframes$1,
    spring: spring$1,
    decay
};
function detectAnimationFromOptions(d) {
    if (Array.isArray(d.to))
        return keyframes$1;
    if (types[d.type])
        return types[d.type];
    var o = new Set(Object.keys(d));
    return o.has("ease") || o.has("duration") && !o.has("dampingRatio") ? keyframes$1 : o.has("dampingRatio") || o.has("stiffness") || o.has("mass") || o.has("damping") || o.has("restSpeed") || o.has("restDelta") ? spring$1 : keyframes$1
}
var defaultTimestep = 1 / 60 * 1e3
  , getCurrentTime = typeof performance < "u" ? function() {
    return performance.now()
}
: function() {
    return Date.now()
}
  , onNextFrame = typeof window < "u" ? function(d) {
    return window.requestAnimationFrame(d)
}
: function(d) {
    return setTimeout(function() {
        return d(getCurrentTime())
    }, defaultTimestep)
}
;
function createRenderStep$1(d) {
    var o = []
      , c = []
      , h = 0
      , _ = !1
      , b = new WeakSet
      , _e = {
        schedule: function(nt, it, at) {
            it === void 0 && (it = !1),
            at === void 0 && (at = !1);
            var ut = at && _
              , pt = ut ? o : c;
            return it && b.add(nt),
            pt.indexOf(nt) === -1 && (pt.push(nt),
            ut && _ && (h = o.length)),
            nt
        },
        cancel: function(nt) {
            var it = c.indexOf(nt);
            it !== -1 && c.splice(it, 1),
            b.delete(nt)
        },
        process: function(nt) {
            var it;
            if (_ = !0,
            o = (it = [c, o])[0],
            (c = it[1]).length = 0,
            h = o.length)
                for (var at = 0; at < h; at++) {
                    var ut = o[at];
                    ut(nt),
                    b.has(ut) && (_e.schedule(ut),
                    d())
                }
            _ = !1
        }
    };
    return _e
}
var maxElapsed$1 = 40
  , useDefaultElapsed = !0
  , runNextFrame = !1
  , isProcessing = !1
  , es_frame = {
    delta: 0,
    timestamp: 0
}
  , stepsOrder$1 = ["read", "update", "preRender", "render", "postRender"]
  , steps$1 = stepsOrder$1.reduce(function(d, o) {
    return d[o] = createRenderStep$1(function() {
        return runNextFrame = !0
    }),
    d
}, {})
  , sync = stepsOrder$1.reduce(function(d, o) {
    var c = steps$1[o];
    return d[o] = function(h, _, b) {
        return _ === void 0 && (_ = !1),
        b === void 0 && (b = !1),
        runNextFrame || startLoop(),
        c.schedule(h, _, b)
    }
    ,
    d
}, {})
  , cancelSync = stepsOrder$1.reduce(function(d, o) {
    return d[o] = steps$1[o].cancel,
    d
}, {});
stepsOrder$1.reduce(function(d, o) {
    return d[o] = function() {
        return steps$1[o].process(es_frame)
    }
    ,
    d
}, {});
var processStep = function(d) {
    return steps$1[d].process(es_frame)
}
  , processFrame = function(d) {
    runNextFrame = !1,
    es_frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(d - es_frame.timestamp, maxElapsed$1), 1),
    es_frame.timestamp = d,
    isProcessing = !0,
    stepsOrder$1.forEach(processStep),
    isProcessing = !1,
    runNextFrame && (useDefaultElapsed = !1,
    onNextFrame(processFrame))
}
  , startLoop = function() {
    runNextFrame = !0,
    useDefaultElapsed = !0,
    isProcessing || onNextFrame(processFrame)
}
  , getFrameData = function() {
    return es_frame
}
  , es = sync;
function loopElapsed(d, o, c) {
    return c === void 0 && (c = 0),
    d - o - c
}
function reverseElapsed(d, o, c, h) {
    return c === void 0 && (c = 0),
    h === void 0 && (h = !0),
    h ? loopElapsed(o + -d, o, c) : o - (d - o) + c
}
function hasRepeatDelayElapsed(d, o, c, h) {
    return h ? d >= o + c : d <= -c
}
var framesync = function(d) {
    var o = function(c) {
        var h = c.delta;
        return d(h)
    };
    return {
        start: function() {
            return es.update(o, !0)
        },
        stop: function() {
            return cancelSync.update(o)
        }
    }
};
function animate(d) {
    var o, c, h, _, b, _e = d.from, nt = d.autoplay, it = nt === void 0 || nt, at = d.driver, ut = at === void 0 ? framesync : at, pt = d.elapsed, ht = pt === void 0 ? 0 : pt, _t = d.repeat, vt = _t === void 0 ? 0 : _t, bt = d.repeatType, St = bt === void 0 ? "loop" : bt, At = d.repeatDelay, Et = At === void 0 ? 0 : At, Pt = d.onPlay, It = d.onStop, Dt = d.onComplete, Gt = d.onRepeat, Bt = d.onUpdate, kt = __rest(d, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]), Ut = kt.to, Ht = 0, Kt = kt.duration, Jt = !1, or = !0, ir = detectAnimationFromOptions(kt);
    !((c = (o = ir).needsInterpolation) === null || c === void 0) && c.call(o, _e, Ut) && (b = interpolate$1([0, 100], [_e, Ut], {
        clamp: !1
    }),
    _e = 0,
    Ut = 100);
    var lr = ir(__assign(__assign({}, kt), {
        from: _e,
        to: Ut
    }));
    return it && (Pt == null || Pt(),
    (h = ut(function(ar) {
        if (or || (ar = -ar),
        ht += ar,
        !Jt) {
            var hr = lr.next(Math.max(0, ht));
            _ = hr.value,
            b && (_ = b(_)),
            Jt = or ? hr.done : ht <= 0
        }
        Bt == null || Bt(_),
        Jt && (Ht === 0 && (Kt != null || (Kt = ht)),
        Ht < vt ? hasRepeatDelayElapsed(ht, Kt, Et, or) && (Ht++,
        St === "reverse" ? ht = reverseElapsed(ht, Kt, Et, or = Ht % 2 == 0) : (ht = loopElapsed(ht, Kt, Et),
        St === "mirror" && lr.flipTarget()),
        Jt = !1,
        Gt && Gt()) : (h.stop(),
        Dt && Dt()))
    })).start()),
    {
        stop: function() {
            It == null || It(),
            h.stop()
        }
    }
}
const easeInOutSine = d => -(Math.cos(Math.PI * d) - 1) / 2
  , EasingFunctions = {
    linear,
    easeIn: easeIn$1,
    easeOut: easeOut$1,
    easeInOut: easeInOut$1,
    circIn: circIn$1,
    circOut: circOut$1,
    circInOut: circInOut$1,
    backIn: backIn$1,
    backOut: backOut$1,
    backInOut: backInOut$1,
    anticipate: anticipate$1,
    bounceOut,
    bounceIn,
    bounceInOut,
    easeInOutSine
};
function makeSetterFor(d, o, c) {
    const h = d[o]
      , _ = () => {
        c == null || c()
    }
    ;
    return h && h.isColor ? b => {
        h.set(b),
        _()
    }
    : h && typeof h.copy == "function" ? b => {
        h.copy(b),
        _()
    }
    : b => {
        d[o] = b,
        _()
    }
}
function isAnimatableType(d) {
    return typeof d != "boolean"
}
async function animateTarget$1(d, o, c, h, _=!1) {
    o in d || console.error("invalid key", o, d);
    const b = makeSetterFor(d, o)
      , _e = _ || c.from === void 0 ? d[o] : c.from
      , nt = it => {
        var at;
        b(it),
        (at = c.onUpdate) === null || at === void 0 || at.call(c, it)
    }
    ;
    if (isAnimatableType(_e))
        return typeof c.to == "function" && (c = {
            ...c,
            to: c.to(_e, d)
        }),
        animateAsync({
            ...c,
            from: _e,
            onUpdate: nt
        }, h);
    {
        const {duration: it} = c;
        return X$2(it ?? 0).then( () => nt(c.to))
    }
}
async function animateAsync(d, o) {
    const c = d.onComplete
      , h = d.onStop
      , _ = d.onEnd;
    return d = {
        ...d
    },
    new Promise( (b, _e) => {
        d.onComplete = () => {
            try {
                c == null || c()
            } catch (it) {
                return _ == null || _(),
                void _e(it)
            }
            _ == null || _(),
            b()
        }
        ,
        d.onStop = () => {
            try {
                h == null || h()
            } catch (it) {
                return _ == null || _(),
                void _e(it)
            }
            _ == null || _(),
            b()
        }
        ;
        const nt = animate(d);
        o && o.push(nt)
    }
    )
}
var InteractionPromptPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, InteractionPromptPlugin_1;
let InteractionPromptPlugin = InteractionPromptPlugin_1 = class extends AViewerPlugin {
    constructor(d=!0) {
        super(),
        this.animationRunning = !1,
        this.animationDuration = 2e3,
        this.animationDistance = 80,
        this.animationPauseDuration = 6e3,
        this.rotationDistance = .3,
        this.yOffset = 0,
        this.autoStart = !0,
        this.autoStartDelay = 3e4,
        this.autoStop = !0,
        this.autoStartOnObjectLoad = !0,
        this.autoStartOnObjectLoadDelay = 3e3,
        this.currentTime = 0,
        this.lastActionTime = 1 / 0,
        this._xDamper = new k$1(50),
        this.pointerIcon = `<svg xmlns="http://www.w3.org/2000/svg" style="transform: translate(-50%, -25%);" width="25" height="36">
    <defs>
        <path id="A" d="M.001.232h24.997V36H.001z"></path>
    </defs>
    <g transform="translate(-11 -4)" fill="none" fill-rule="evenodd">
        <path fill-opacity="0" fill="#fff" d="M0 0h44v44H0z"></path>
        <g transform="translate(11 3)">
            <path d="M8.733 11.165c.04-1.108.766-2.027 1.743-2.307a2.54 2.54 0 0 1 .628-.089c.16 0 .314.017.463.044 1.088.2 1.9 1.092 1.9 2.16v8.88h1.26c2.943-1.39 5-4.45 5-8.025a9.01 9.01 0 0 0-1.9-5.56l-.43-.5c-.765-.838-1.683-1.522-2.712-2-1.057-.49-2.226-.77-3.46-.77s-2.4.278-3.46.77c-1.03.478-1.947 1.162-2.71 2l-.43.5a9.01 9.01 0 0 0-1.9 5.56 9.04 9.04 0 0 0 .094 1.305c.03.21.088.41.13.617l.136.624c.083.286.196.56.305.832l.124.333a8.78 8.78 0 0 0 .509.953l.065.122a8.69 8.69 0 0 0 3.521 3.191l1.11.537v-9.178z" fill-opacity=".5" fill="#e4e4e4"></path>
            <path d="M22.94 26.218l-2.76 7.74c-.172.485-.676.8-1.253.8H12.24c-1.606 0-3.092-.68-3.98-1.82-1.592-2.048-3.647-3.822-6.11-5.27-.095-.055-.15-.137-.152-.23-.004-.1.046-.196.193-.297.56-.393 1.234-.6 1.926-.6a3.43 3.43 0 0 1 .691.069l4.922.994V10.972c0-.663.615-1.203 1.37-1.203s1.373.54 1.373 1.203v9.882h2.953c.273 0 .533.073.757.21l6.257 3.874c.027.017.045.042.07.06.41.296.586.77.426 1.22M4.1 16.614c-.024-.04-.042-.083-.065-.122a8.69 8.69 0 0 1-.509-.953c-.048-.107-.08-.223-.124-.333l-.305-.832c-.058-.202-.09-.416-.136-.624l-.13-.617a9.03 9.03 0 0 1-.094-1.305c0-2.107.714-4.04 1.9-5.56l.43-.5c.764-.84 1.682-1.523 2.71-2 1.058-.49 2.226-.77 3.46-.77s2.402.28 3.46.77c1.03.477 1.947 1.16 2.712 2l.428.5a9 9 0 0 1 1.901 5.559c0 3.577-2.056 6.636-5 8.026h-1.26v-8.882c0-1.067-.822-1.96-1.9-2.16-.15-.028-.304-.044-.463-.044-.22 0-.427.037-.628.09-.977.28-1.703 1.198-1.743 2.306v9.178l-1.11-.537C6.18 19.098 4.96 18 4.1 16.614M22.97 24.09l-6.256-3.874c-.102-.063-.218-.098-.33-.144 2.683-1.8 4.354-4.855 4.354-8.243 0-.486-.037-.964-.104-1.43a9.97 9.97 0 0 0-1.57-4.128l-.295-.408-.066-.092a10.05 10.05 0 0 0-.949-1.078c-.342-.334-.708-.643-1.094-.922-1.155-.834-2.492-1.412-3.94-1.65l-.732-.088-.748-.03a9.29 9.29 0 0 0-1.482.119c-1.447.238-2.786.816-3.94 1.65a9.33 9.33 0 0 0-.813.686 9.59 9.59 0 0 0-.845.877l-.385.437-.36.5-.288.468-.418.778-.04.09c-.593 1.28-.93 2.71-.93 4.222 0 3.832 2.182 7.342 5.56 8.938l1.437.68v4.946L5 25.64a4.44 4.44 0 0 0-.888-.086c-.017 0-.034.003-.05.003-.252.004-.503.033-.75.08a5.08 5.08 0 0 0-.237.056c-.193.046-.382.107-.568.18-.075.03-.15.057-.225.1-.25.114-.494.244-.723.405a1.31 1.31 0 0 0-.566 1.122 1.28 1.28 0 0 0 .645 1.051C4 29.925 5.96 31.614 7.473 33.563a5.06 5.06 0 0 0 .434.491c1.086 1.082 2.656 1.713 4.326 1.715h6.697c.748-.001 1.43-.333 1.858-.872.142-.18.256-.38.336-.602l2.757-7.74c.094-.26.13-.53.112-.794s-.088-.52-.203-.76a2.19 2.19 0 0 0-.821-.91" fill-opacity=".6" fill="#000"></path>
            <path d="M22.444 24.94l-6.257-3.874a1.45 1.45 0 0 0-.757-.211h-2.953v-9.88c0-.663-.616-1.203-1.373-1.203s-1.37.54-1.37 1.203v16.643l-4.922-.994a3.44 3.44 0 0 0-.692-.069 3.35 3.35 0 0 0-1.925.598c-.147.102-.198.198-.194.298.004.094.058.176.153.23 2.462 1.448 4.517 3.22 6.11 5.27.887 1.14 2.373 1.82 3.98 1.82h6.686c.577 0 1.08-.326 1.253-.8l2.76-7.74c.16-.448-.017-.923-.426-1.22-.025-.02-.043-.043-.07-.06z" fill="#fff"></path>
            <g transform="translate(0 .769)">
                <mask id="B" fill="#fff">
                    <use xlink:href="#A"></use>
                </mask>
                <path d="M23.993 24.992a1.96 1.96 0 0 1-.111.794l-2.758 7.74c-.08.22-.194.423-.336.602-.427.54-1.11.87-1.857.872h-6.698c-1.67-.002-3.24-.633-4.326-1.715-.154-.154-.3-.318-.434-.49C5.96 30.846 4 29.157 1.646 27.773c-.385-.225-.626-.618-.645-1.05a1.31 1.31 0 0 1 .566-1.122 4.56 4.56 0 0 1 .723-.405l.225-.1a4.3 4.3 0 0 1 .568-.18l.237-.056c.248-.046.5-.075.75-.08.018 0 .034-.003.05-.003.303-.001.597.027.89.086l3.722.752V20.68l-1.436-.68c-3.377-1.596-5.56-5.106-5.56-8.938 0-1.51.336-2.94.93-4.222.015-.03.025-.06.04-.09.127-.267.268-.525.418-.778.093-.16.186-.316.288-.468.063-.095.133-.186.2-.277L3.773 5c.118-.155.26-.29.385-.437.266-.3.544-.604.845-.877a9.33 9.33 0 0 1 .813-.686C6.97 2.167 8.31 1.59 9.757 1.35a9.27 9.27 0 0 1 1.481-.119 8.82 8.82 0 0 1 .748.031c.247.02.49.05.733.088 1.448.238 2.786.816 3.94 1.65.387.28.752.588 1.094.922a9.94 9.94 0 0 1 .949 1.078l.066.092c.102.133.203.268.295.408a9.97 9.97 0 0 1 1.571 4.128c.066.467.103.945.103 1.43 0 3.388-1.67 6.453-4.353 8.243.11.046.227.08.33.144l6.256 3.874c.37.23.645.55.82.9.115.24.185.498.203.76m.697-1.195c-.265-.55-.677-1.007-1.194-1.326l-5.323-3.297c2.255-2.037 3.564-4.97 3.564-8.114 0-2.19-.637-4.304-1.84-6.114-.126-.188-.26-.37-.4-.552-.645-.848-1.402-1.6-2.252-2.204C15.472.91 13.393.232 11.238.232A10.21 10.21 0 0 0 5.23 2.19c-.848.614-1.606 1.356-2.253 2.205-.136.18-.272.363-.398.55C1.374 6.756.737 8.87.737 11.06c0 4.218 2.407 8.08 6.133 9.842l.863.41v3.092l-2.525-.51c-.356-.07-.717-.106-1.076-.106a5.45 5.45 0 0 0-3.14.996c-.653.46-1.022 1.202-.99 1.983a2.28 2.28 0 0 0 1.138 1.872c2.24 1.318 4.106 2.923 5.543 4.772 1.26 1.62 3.333 2.59 5.55 2.592h6.698c1.42-.001 2.68-.86 3.134-2.138l2.76-7.74c.272-.757.224-1.584-.134-2.325" fill-opacity=".05" fill="#000" mask="url(#B)"></path>
            </g>
        </g>
    </g>
</svg>`,
        this._activeCameraUpdate = o => {
            this.isDisabled() || (o.change === "deserialize" && this.animationRunning ? (this.stopAnimation({
                reset: !1
            }),
            this.startAnimation()) : this.lastActionTime = g())
        }
        ,
        this._addSceneObject = () => {
            this.autoStartOnObjectLoad && (this.lastActionTime = g() - this.autoStartDelay + this.autoStartOnObjectLoadDelay)
        }
        ,
        this.onlyOnOrbitControls = !0,
        this._orbitWarning = !1,
        this.startAnimation = () => {
            var o;
            if (this._viewer && this.cursorEl && !this.isDisabled())
                return ((o = this._viewer.scene.activeCamera.controls) === null || o === void 0 ? void 0 : o.type) !== "OrbitControls" && this.onlyOnOrbitControls ? (this._orbitWarning || console.warn("WebGi InteractionPromptPlugin requires OrbitControls, to run anyway, set onlyOnOrbitControls to false"),
                void (this._orbitWarning = !0)) : void (this._viewer.scene.modelRoot.children.length !== 0 && (this.currentSphericalPosition = new three_module.YHV().setFromVector3(new three_module.Pq0().subVectors(this._viewer.scene.activeCamera.position, this._viewer.scene.activeCamera.target)),
                this.cursorEl.style.opacity = "1",
                this.currentTime = 0,
                this.animationRunning = !0,
                this._viewer.scene.activeCamera.setInteractions(!1, InteractionPromptPlugin_1.PluginType)))
        }
        ,
        this.stopAnimation = ({reset: o=!0}={}) => {
            if (this._viewer && this.cursorEl)
                return this.animationRunning = !1,
                this.cursorEl.style.opacity = "0",
                this.currentSphericalPosition && o && (this._viewer.scene.activeCamera.position.setFromSpherical(this.currentSphericalPosition).add(this._viewer.scene.activeCamera.target),
                this._viewer.scene.activeCamera.positionUpdated(),
                this.currentSphericalPosition = void 0),
                this._viewer.scene.activeCamera.setInteractions(!0, InteractionPromptPlugin_1.PluginType),
                this._viewer.doOnce("postFrame")
        }
        ,
        this._pointerDown = () => {
            this.isDisabled() || (this.autoStop && this.stopAnimation({
                reset: !1
            }),
            this.lastActionTime = g())
        }
        ,
        this._x = 0,
        this._preFrame = async o => {
            if (!this._viewer || !this.cursorEl || (this.isDisabled() && this.animationRunning && this.stopAnimation(),
            this.isDisabled()) || (!this.animationRunning && this.autoStart && this.lastActionTime + this.autoStartDelay < g() && this.startAnimation(),
            !this.animationRunning))
                return;
            if (this.currentTime <= this.animationDuration) {
                this.cursorEl.style.opacity = "1";
                const b = this.currentTime / this.animationDuration;
                this._x = Math.sin(2 * Math.PI * b),
                (b < .25 || b > .75) && (this._x *= this._x * Math.sign(this._x))
            } else
                this.cursorEl.style.opacity = "0",
                this._x = 0;
            if (this.currentTime <= this.animationDuration + 50) {
                const b = this.currentSphericalPosition.clone();
                b.theta += this._x * this.rotationDistance,
                this._viewer.scene.activeCamera.position.setFromSpherical(b).add(this._viewer.scene.activeCamera.target),
                this._viewer.scene.activeCamera.positionUpdated()
            }
            const c = this._viewer.container.getBoundingClientRect()
              , h = c.width / 2 + -this._x * Math.min(this.animationDistance, c.width / 4)
              , _ = c.height / 2 + this.yOffset * c.height / 2;
            this.cursorEl.style.transform = `translate(${Math.floor(h)}px, ${Math.floor(_)}px)`,
            this.currentTime += o.deltaTime,
            this.currentTime > this.animationDuration + this.animationPauseDuration && (this.currentTime = 0)
        }
        ,
        this._disabledBy = new Set,
        this.disable = o => {
            this._disabledBy.size,
            this._disabledBy.add(o)
        }
        ,
        this.enable = o => {
            this._disabledBy.size,
            this._disabledBy.delete(o)
        }
        ,
        this.isDisabled = () => this._disabledBy.size > 0 || !this.enabled,
        this.enabled = d
    }
    async onAdded(d) {
        await super.onAdded(d);
        {
            Object.hasOwn(d.plugins, "InteractionPointerPlugin") && delete d.plugins.InteractionPointerPlugin;
            const o = this;
            Object.defineProperty(d.plugins, "InteractionPointerPlugin", {
                get() {
                    return console.warn("WebGi InteractionPromptPlugin: PluginType renamed from InteractionPointerPlugin to InteractionPromptPlugin. Please update your code/vjson."),
                    o
                },
                configurable: !0
            })
        }
        this.lastActionTime = 1 / 0,
        d.addEventListener("preFrame", this._preFrame),
        d.container.addEventListener("pointerdown", this._pointerDown, !0),
        d.container.addEventListener("wheel", this._pointerDown, !0),
        d.scene.addEventListener("addSceneObject", this._addSceneObject),
        d.scene.addEventListener("activeCameraUpdate", this._activeCameraUpdate),
        this._initializeCursor()
    }
    async onRemove(d) {
        return this.stopAnimation(),
        d.removeEventListener("preFrame", this._preFrame),
        d.container.removeEventListener("pointerdown", this._pointerDown, !0),
        d.container.removeEventListener("wheel", this._pointerDown, !0),
        d.scene.removeEventListener("addSceneObject", this._addSceneObject),
        d.scene.removeEventListener("activeCameraUpdate", this._activeCameraUpdate),
        this.cursorEl && this.cursorEl.remove(),
        super.onRemove(d)
    }
    _initializeCursor() {
        this.cursorEl = document.createElement("div"),
        this.cursorEl.style.position = "absolute",
        this.cursorEl.style.top = "0",
        this.cursorEl.style.left = "0",
        this.cursorEl.style.width = "10px",
        this.cursorEl.style.height = "10px",
        this.cursorEl.style.opacity = "0",
        this.cursorEl.innerHTML = this.pointerIcon,
        this._viewer.container.appendChild(this.cursorEl)
    }
}
;
InteractionPromptPlugin.PluginType = "InteractionPromptPlugin",
InteractionPromptPlugin_decorate([serialize(), uiToggle()], InteractionPromptPlugin.prototype, "enabled", void 0),
InteractionPromptPlugin_decorate([serialize(), uiInput()], InteractionPromptPlugin.prototype, "animationDuration", void 0),
InteractionPromptPlugin_decorate([serialize(), uiInput()], InteractionPromptPlugin.prototype, "animationDistance", void 0),
InteractionPromptPlugin_decorate([serialize(), uiInput()], InteractionPromptPlugin.prototype, "animationPauseDuration", void 0),
InteractionPromptPlugin_decorate([serialize(), uiInput()], InteractionPromptPlugin.prototype, "rotationDistance", void 0),
InteractionPromptPlugin_decorate([serialize(), uiInput()], InteractionPromptPlugin.prototype, "yOffset", void 0),
InteractionPromptPlugin_decorate([serialize(), uiToggle()], InteractionPromptPlugin.prototype, "autoStart", void 0),
InteractionPromptPlugin_decorate([serialize(), uiInput()], InteractionPromptPlugin.prototype, "autoStartDelay", void 0),
InteractionPromptPlugin_decorate([serialize(), uiToggle()], InteractionPromptPlugin.prototype, "autoStop", void 0),
InteractionPromptPlugin_decorate([serialize(), uiToggle()], InteractionPromptPlugin.prototype, "autoStartOnObjectLoad", void 0),
InteractionPromptPlugin_decorate([serialize(), uiToggle()], InteractionPromptPlugin.prototype, "autoStartOnObjectLoadDelay", void 0),
InteractionPromptPlugin_decorate([uiMonitor()], InteractionPromptPlugin.prototype, "currentTime", void 0),
InteractionPromptPlugin_decorate([uiMonitor()], InteractionPromptPlugin.prototype, "lastActionTime", void 0),
InteractionPromptPlugin_decorate([serialize()], InteractionPromptPlugin.prototype, "onlyOnOrbitControls", void 0),
InteractionPromptPlugin_decorate([uiButton()], InteractionPromptPlugin.prototype, "startAnimation", void 0),
InteractionPromptPlugin_decorate([uiButton()], InteractionPromptPlugin.prototype, "stopAnimation", void 0),
InteractionPromptPlugin = InteractionPromptPlugin_1 = InteractionPromptPlugin_decorate([uiFolder("Interaction Prompt")], InteractionPromptPlugin);
var CameraViewPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let viewId = 1
  , CameraView = class {
    constructor(d, o, c, h, _=1) {
        this.position = new three_module.Pq0,
        this.target = new three_module.Pq0,
        this.quaternion = new three_module.PTz,
        this.up = new three_module.Pq0,
        this.duration = 1,
        this.name = "Camera View",
        this.focusView = () => {}
        ,
        this.deleteView = () => {}
        ,
        this.updateView = () => {}
        ,
        this.uiConfig = generateUiFolder(this.name, this),
        d && (this.position = d),
        o && (this.target = o),
        c && (this.up = c),
        h && (this.quaternion = h),
        _ !== void 0 && _ !== 0 && (this.duration = _),
        this.name = "#view" + viewId++
    }
    _nameChanged() {
        var d, o;
        this.uiConfig && (this.uiConfig.label = this.name,
        (o = (d = this.uiConfig).uiRefresh) === null || o === void 0 || o.call(d))
    }
}
;
CameraViewPlugin_decorate([serialize(), uiVector()], CameraView.prototype, "position", void 0),
CameraViewPlugin_decorate([serialize(), uiVector()], CameraView.prototype, "target", void 0),
CameraViewPlugin_decorate([serialize(), uiVector()], CameraView.prototype, "quaternion", void 0),
CameraViewPlugin_decorate([serialize(), uiVector()], CameraView.prototype, "up", void 0),
CameraViewPlugin_decorate([serialize(), uiInput()], CameraView.prototype, "duration", void 0),
CameraViewPlugin_decorate([serialize(), uiInput()], CameraView.prototype, "name", void 0),
CameraViewPlugin_decorate([uiButton()], CameraView.prototype, "focusView", void 0),
CameraViewPlugin_decorate([uiButton()], CameraView.prototype, "deleteView", void 0),
CameraViewPlugin_decorate([uiButton()], CameraView.prototype, "updateView", void 0),
CameraView = CameraViewPlugin_decorate([serializable("CameraView")], CameraView);
class CameraViewPlugin extends AViewerPlugin {
    get animationLooping() {
        return this._animationLooping
    }
    get animating() {
        return this._animating
    }
    constructor() {
        super(),
        this.enabled = !0,
        this._cameraViews = [],
        this.viewLooping = !1,
        this.viewPauseTime = 200,
        this.animEase = "easeInOutSine",
        this.animDuration = 1e3,
        this.rotationOffset = .25,
        this.interpolateMode = "spherical",
        this.splineCurve = "chordal",
        this.animateOnScroll = !1,
        this.seekOnScroll = !1,
        this._animating = !1,
        this.dependencies = [],
        this._scrollAnimationState = 0,
        this.scrollAnimationDamping = .1,
        this._updaters = [],
        this._lastFrameTime = 0,
        this._fadeDisabled = !1,
        this._viewQueue = [],
        this._animationLooping = !1,
        this._infiniteLooping = !0,
        this._driver = o => ({
            start: () => this._updaters.push({
                u: o,
                time: 0
            }),
            stop: () => this._updaters.splice(this._updaters.findIndex(c => c.u === o), 1)
        }),
        this.focusNext = (o=!0) => {
            if (this._animating || this._cameraViews.length < 2)
                return;
            let c = this._cameraViews.findIndex(h => h === this._currentView);
            c < 0 && (c = -1),
            c += 1,
            o ? c %= this._cameraViews.length : c = Math.min(c, this._cameraViews.length - 1),
            this.focusView(this._cameraViews[c])
        }
        ,
        this.focusPrevious = (o=!0) => {
            if (this._animating || this._cameraViews.length < 2 || !this._currentView)
                return;
            let c = this._cameraViews.findIndex(h => h === this._currentView);
            c < 0 && (c = 0),
            c -= 1,
            c = o ? (c + this._cameraViews.length) % this._cameraViews.length : Math.max(c, 0),
            this.focusView(this._cameraViews[c])
        }
        ,
        this._popAnimations = [],
        this.uiConfig = {
            type: "folder",
            label: "Camera Views",
            children: [ () => [...this._cameraViews.map(o => o.uiConfig)], ...generateUiConfig(this)]
        },
        this.addCurrentView = this.addCurrentView.bind(this),
        this.animateAllViews = this.animateAllViews.bind(this),
        this.recordAllViews = this.recordAllViews.bind(this),
        this.resetToFirstView = this.resetToFirstView.bind(this),
        this._wheel = this._wheel.bind(this),
        this._pointerMove = this._pointerMove.bind(this),
        this._postFrame = this._postFrame.bind(this)
    }
    get camViews() {
        return this._cameraViews
    }
    _wheel(o) {
        this.enabled && (this.seekOnScroll && !this._animating || Math.abs(o.deltaY) > .001 && (this._scrollAnimationState = -1 * Math.sign(o.deltaY)))
    }
    _pointerMove(o) {
        var c;
        if (this.enabled && !this._animating && this.seekOnScroll) {
            const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.activeCamera;
            if (!h)
                return;
            const _ = new three_module.YHV
              , b = h.position
              , _e = h.target
              , nt = new three_module.PTz().setFromUnitVectors(h.cameraObject.up, new three_module.Pq0(0,1,0))
              , it = nt.clone().invert()
              , at = b.clone().sub(_e);
            at.applyQuaternion(nt),
            _.setFromVector3(at),
            _.theta += this.rotationOffset * o.movementX / this._viewer.canvas.clientWidth,
            _.phi += this.rotationOffset * o.movementY / this._viewer.canvas.clientHeight,
            _.makeSafe(),
            at.setFromSpherical(_),
            at.applyQuaternion(it),
            b.copy(_e).add(at),
            h.positionUpdated(!1),
            h.targetUpdated()
        }
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.addEventListener("preFrame", c => {
            this.seekOnScroll || this._animating ? this._viewer.scene.activeCamera.setInteractions(!1, CameraViewPlugin.PluginType) : this._viewer.scene.activeCamera.setInteractions(!0, CameraViewPlugin.PluginType)
        }
        ),
        o.addEventListener("postFrame", this._postFrame),
        window.addEventListener("wheel", this._wheel),
        window.addEventListener("pointermove", this._pointerMove)
    }
    _postFrame() {
        var o, c;
        if (!this._viewer)
            return;
        if (!this.enabled || !this._animating)
            return this._lastFrameTime = 0,
            void (this._fadeDisabled && ((o = this._viewer.getPluginByType("FrameFade")) === null || o === void 0 || o.enable(CameraViewPlugin.PluginType),
            this._fadeDisabled = !1));
        const h = g() / 1e3;
        this._lastFrameTime < 1 && (this._lastFrameTime = h - 1 / 60);
        let _ = h - this._lastFrameTime;
        this._lastFrameTime = h,
        _ *= this.animateOnScroll ? this._scrollAnimationState : 1;
        const b = (c = this._viewer.getPluginByType("Progressive")) === null || c === void 0 ? void 0 : c.postFrameConvergedRecordingDelta();
        if (b && b > 0 && (_ = b),
        b !== 0 && (_ *= 1e3,
        !(_ <= 0 || (this._updaters.forEach(_e => {
            let nt = _;
            _e.time + nt < 0 && (nt = -_e.time),
            _e.time += nt,
            Math.abs(nt) > .001 && _e.u(nt)
        }
        ),
        this._scrollAnimationState < .001 ? this._scrollAnimationState = 0 : this._scrollAnimationState *= 1 - this.scrollAnimationDamping,
        this._fadeDisabled)))) {
            const _e = this._viewer.getPluginByType("FrameFade");
            _e && (_e.disable(CameraViewPlugin.PluginType),
            this._fadeDisabled = !0)
        }
    }
    async onRemove(o) {
        return o.removeEventListener("postFrame", this._postFrame),
        window.removeEventListener("wheel", this._wheel),
        window.removeEventListener("pointermove", this._pointerMove),
        super.onRemove(o)
    }
    async _animationLoop() {
        if (!this._animationLooping) {
            for (this._animationLooping = !0; (this.viewLooping || !this._infiniteLooping) && this.enabled && !(this._cameraViews.length < 1); ) {
                if (this._viewQueue.length === 0) {
                    if (!this._infiniteLooping)
                        break;
                    this._viewQueue.push(...this._cameraViews)
                }
                await this.animateToView(this._viewQueue.shift()),
                await X$2(2 + this.viewPauseTime)
            }
            this._animationLooping = !1
        }
    }
    async animateAllViews() {
        if (this.enabled && !(this.viewLooping || this._cameraViews.length < 2)) {
            for (; this._viewQueue.length > 0; )
                this._viewQueue.pop();
            this._viewQueue.push(...this._cameraViews),
            this._viewQueue.push(this._viewQueue.shift()),
            this._infiniteLooping = !1,
            await this._animationLoop(),
            this._infiniteLooping = !0
        }
    }
    async resetToFirstView(o=100) {
        this.enabled && (this._currentView = void 0,
        await this.animateToView(this._cameraViews[0], o),
        await X$2(2))
    }
    async recordAllViews(o, c=!0) {
        var h;
        if (!this.enabled)
            return;
        const _ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPluginByType("CanvasRecorder");
        if (!_ || !_.enabled || this._cameraViews.length < 1)
            return;
        if (_.isRecording())
            return void console.error("CanvasRecorderPlugin is already recording");
        let b = !1;
        return this.viewLooping && (b = !0,
        this.viewLooping = !1),
        await this.resetToFirstView(),
        new Promise( (_e, nt) => {
            const it = () => {
                _.removeEventListener("start", at),
                _.removeEventListener("stop", it),
                _.removeEventListener("error", ut)
            }
              , at = async () => {
                var pt;
                it(),
                o == null || o(),
                await this.animateAllViews();
                const ht = await _.stopRecording();
                if (b && (this.viewLooping = !0),
                c) {
                    const _t = await ((pt = this._viewer) === null || pt === void 0 ? void 0 : pt.prompt("Canvas Recorder: Save file as", "recording.mp4"));
                    _t !== null && ht && await this._downloadBlob(ht, _t || "recording.mp4")
                }
                _e(ht)
            }
              , ut = async () => {
                it(),
                nt()
            }
            ;
            _.addEventListener("start", at),
            _.addEventListener("stop", it),
            _.addEventListener("error", ut),
            _.startRecording() || console.error("cannot start recording")
        }
        )
    }
    async addCurrentView() {
        if (!this.enabled)
            return;
        const o = this.getCurrentCameraView();
        this.addView(o)
    }
    addView(o) {
        var c, h;
        this._cameraViews.push(o),
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c),
        this.dispatchEvent({
            type: "viewAdd",
            view: o
        })
    }
    getCurrentCameraView(o, c=!0, h) {
        var _, b, _e;
        if (o || (o = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.scene.activeCamera),
        !o)
            return new CameraView;
        const nt = new three_module.Pq0;
        o.cameraObject.updateWorldMatrix(!0, !1);
        const it = o.cameraObject.matrixWorld;
        nt.x = it.elements[4],
        nt.y = it.elements[5],
        nt.z = it.elements[6],
        nt.normalize();
        const at = o.target.clone()
          , ut = o.position.clone()
          , pt = o.cameraObject.parent;
        pt && (c ? ut.applyMatrix4(pt.matrixWorld) : nt.transformDirection(pt.matrixWorld.clone().invert()));
        const ht = c ? o.cameraObject.getWorldQuaternion(new three_module.PTz) : o.cameraObject.quaternion.clone();
        return h ? (h.position.copy(ut),
        h.target.copy(at),
        h.up.copy(nt),
        h.quaternion.copy(ht)) : ((h = new CameraView(ut,at,nt,ht,1)).focusView = async () => h && this.focusView(h),
        h.deleteView = () => h && this.deleteView(h),
        h.updateView = () => this.getCurrentCameraView(o, c, h)),
        (_e = (b = h.uiConfig).uiRefresh) === null || _e === void 0 || _e.call(b, "postFrame", !0),
        h
    }
    setCurrentCameraView(o) {
        var c;
        const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.activeCamera;
        h && (h.position.copy(o.position),
        h.target.copy(o.target),
        h.cameraObject.quaternion.copy(o.quaternion),
        h.positionUpdated())
    }
    async focusView(o) {
        return this.animateToView(o)
    }
    deleteView(o) {
        var c, h;
        const _ = this._cameraViews.indexOf(o);
        _ >= 0 && this._cameraViews.splice(_, 1),
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c),
        this.dispatchEvent({
            type: "viewDelete",
            view: o
        })
    }
    async stopAllAnimations() {
        for (this.viewLooping = !1,
        this._popAnimations.forEach(o => {
            var c;
            return (c = o == null ? void 0 : o.stop) === null || c === void 0 ? void 0 : c.call(o)
        }
        ),
        this._popAnimations = []; this._animating || this._animationLooping; )
            await X$2(100)
    }
    async animateToView(o, c, h, _=!1) {
        var b, _e, nt;
        const it = (b = this._viewer) === null || b === void 0 ? void 0 : b.scene.activeCamera;
        if (!it)
            return;
        if (this._animating) {
            this._popAnimations.forEach(At => (At == null ? void 0 : At.stop) && At.stop()),
            this._popAnimations = [];
            let St = 0;
            for (; this._animating && (await X$2(100),
            !(St++ > 20)); )
                ;
            if (this._animating)
                return void console.warn("Unable to stop all animations, maybe because of viewLooping?")
        }
        const at = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.getPlugin(InteractionPromptPlugin);
        at && at.animationRunning && await at.stopAnimation({
            reset: !0
        }),
        this._currentView = o,
        this._animating = !0,
        this.dispatchEvent({
            type: "startViewChange",
            view: o
        }),
        c === void 0 && (c = this.animDuration),
        c = Math.max(10, c);
        const ut = typeof h == "function" ? h : EasingFunctions[h || this.animEase]
          , pt = this._driver
          , ht = [];
        this._popAnimations = [];
        const _t = this._popAnimations
          , vt = this.camViews.indexOf(o);
        let bt = this.interpolateMode;
        if (vt < 0 && bt === "spline" && (console.warn("CameraViewPlugin - Cannot animate along a spline with external camera view, fallback to spherical"),
        bt = "spherical"),
        bt === "spherical")
            ht.push(animateCameraToViewSpherical(it, o, c * o.duration, ut, pt, _t));
        else if (bt === "linear") {
            ht.push(animateAsync({
                from: it.position.clone(),
                to: o.position.clone(),
                duration: c * o.duration,
                ease: ut,
                driver: pt,
                onUpdate: Et => it.position = Et,
                onComplete: () => it.position = o.position,
                onStop: () => {
                    throw new Error("Animation stopped")
                }
            }, _t)),
            ht.push(animateAsync({
                from: it.target.clone(),
                to: o.target.clone(),
                duration: c * o.duration,
                ease: ut,
                driver: pt,
                onUpdate: Et => {
                    it.target = Et,
                    it.targetUpdated()
                }
                ,
                onComplete: () => {
                    it.target = o.target,
                    it.targetUpdated()
                }
            }, _t));
            const St = it.cameraObject.quaternion.clone()
              , At = new three_module.PTz;
            ht.push(animateAsync({
                from: 0,
                to: 1,
                duration: c * o.duration,
                ease: ut,
                driver: pt,
                onUpdate: Et => {
                    At.copy(St).slerp(o.quaternion, Et),
                    it.cameraObject.quaternion.copy(At),
                    it.cameraObject.updateProjectionMatrix()
                }
                ,
                onComplete: () => {
                    it.cameraObject.quaternion.copy(o.quaternion),
                    it.cameraObject.updateProjectionMatrix()
                }
            }, _t))
        } else if (bt === "spline") {
            const St = this.camViews.map(Pt => Pt.position.clone())
              , At = new three_module.B6O(St,!0,this.splineCurve,.75)
              , Et = Pt => {
                const It = new three_module.Pq0
                  , Dt = 1 / St.length
                  , Gt = ((vt === 0 ? St.length : vt) - 1) * Dt;
                return At.getPointAt(Gt + Pt * Dt, It),
                It
            }
            ;
            ht.push(animateAsync({
                from: 0,
                to: 1,
                duration: c * o.duration,
                ease: ut,
                driver: pt,
                onUpdate: Pt => it.position = Et(Pt),
                onComplete: () => it.position = Et(1),
                onStop: () => {
                    throw new Error("Animation stopped")
                }
            }, _t)),
            ht.push(animateAsync({
                from: it.target.clone(),
                to: o.target.clone(),
                duration: c * o.duration,
                ease: ut,
                driver: pt,
                onUpdate: Pt => {
                    it.target = Pt,
                    it.targetUpdated()
                }
                ,
                onComplete: () => {
                    it.target = o.target,
                    it.targetUpdated()
                }
            }, _t))
        }
        await Promise.allSettled(ht).catch(St => {
            if (_)
                throw St
        }
        ),
        (nt = this._viewer) === null || nt === void 0 || nt.setDirty(),
        this._animating = !1,
        this.dispatchEvent({
            type: "viewChange",
            view: o
        }),
        await X$2(10)
    }
    fromJSON(o, c) {
        var h, _;
        return this._cameraViews.forEach(b => this.deleteView(b)),
        super.fromJSON(o, c) ? (this._cameraViews.forEach(b => b.focusView = async () => this.focusView(b)),
        this._cameraViews.forEach(b => b.deleteView = () => this.deleteView(b)),
        this._cameraViews.forEach(b => b.updateView = () => this.getCurrentCameraView(void 0, void 0, b)),
        (_ = (h = this.uiConfig).uiRefresh) === null || _ === void 0 || _.call(h),
        this) : null
    }
    async animateToObject(o, c=4, h, _, b={
        min: .5,
        max: 5
    }) {
        if (!this._viewer)
            return;
        const _e = new Box3B().expandByObject(o || this._viewer.scene.modelRoot.modelObject, !1, !0)
          , nt = _e.getCenter(new three_module.Pq0)
          , it = _e.getSize(new three_module.Pq0).length() / 2;
        await this.animateToTarget(Math.min(b.max, Math.max(b.min, it * c)), nt, h, _)
    }
    async animateToFitObject(o, c=1.5, h=1e3, _, b={
        min: .5,
        max: 50
    }) {
        if (!this._viewer)
            return;
        const _e = new Box3B().expandByObject(o || this._viewer.scene.modelRoot.modelObject, !1, !0)
          , nt = _e.getCenter(new three_module.Pq0)
          , it = this._viewer.scene.activeCamera.getFittingDistance(_e);
        await this.animateToTarget(Math.min(b.max, Math.max(b.min, it * c)), nt, h, _)
    }
    async animateToTarget(o, c, h, _) {
        const b = this.getCurrentCameraView();
        b.target.copy(c);
        const _e = new three_module.Pq0().subVectors(b.target, b.position).normalize();
        b.position.copy(_e.multiplyScalar(-o).add(b.target)),
        await this.animateToView(b, h, _)
    }
    async _downloadBlob(o, c) {
        var h, _;
        const b = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPluginByType("FileTransferPlugin");
        b ? await b.exportFile(o, c) : (_ = this._viewer) === null || _ === void 0 || _.console.error("FileTransferPlugin required to export/download file")
    }
}
function sphericalFromObject(d, o) {
    const c = d.position.clone();
    c.sub(o);
    const h = new three_module.YHV().setFromVector3(c);
    return h.makeSafe(),
    h
}
async function animateCameraToViewSpherical(d, o, c, h, _, b, _e) {
    const nt = d.target.clone()
      , it = new three_module.Pq0
      , at = new three_module.Pq0
      , ut = d.cameraObject.parent
      , pt = d.cameraObject.up.clone()
      , ht = sphericalFromObject({
        position: d.cameraObject.getWorldPosition(new three_module.Pq0),
        up: ut ? pt.transformDirection(ut.matrixWorld) : pt
    }, nt)
      , _t = sphericalFromObject(o, o.target)
      , vt = new three_module.YHV;
    function bt() {
        d.position.copy(ut ? ut.worldToLocal(at) : at),
        d.target.copy(it),
        d.positionUpdated()
    }
    return animateAsync({
        from: 0,
        to: 1,
        duration: c,
        ease: h,
        driver: _,
        ..._e,
        onUpdate: St => {
            vt.phi = lerpAngle(ht.phi, _t.phi, St),
            vt.theta = lerpAngle(ht.theta, _t.theta, St),
            vt.radius = three_module.cj9.lerp(ht.radius, _t.radius, St),
            it.copy(nt).lerp(o.target, St),
            at.setFromSpherical(vt),
            at.add(it),
            bt()
        }
        ,
        onComplete: () => {
            at.copy(o.position),
            it.copy(o.target),
            bt()
        }
        ,
        onStop: () => {
            throw new Error("Animation Stopped")
        }
    }, b)
}
function lerpAngle(d, o, c) {
    const h = o - d;
    return h >= Math.PI ? d + (h - 2 * Math.PI) * c : h <= -Math.PI ? d + (h + 2 * Math.PI) * c : d + h * c
}
function lerpAngle2(d, o, c) {
    const h = (1 - c) * Math.cos(d) + c * Math.cos(o)
      , _ = (1 - c) * Math.sin(d) + c * Math.sin(o);
    return Math.atan2(_, h)
}
CameraViewPlugin.PluginType = "CameraViews",
CameraViewPlugin_decorate([serialize("cameraViews")], CameraViewPlugin.prototype, "_cameraViews", void 0),
CameraViewPlugin_decorate([x$1(CameraViewPlugin.prototype._animationLoop), serialize(), uiToggle("Loop All Views", {
    limitedUi: !0
})], CameraViewPlugin.prototype, "viewLooping", void 0),
CameraViewPlugin_decorate([serialize(), uiInput("View Pause Time")], CameraViewPlugin.prototype, "viewPauseTime", void 0),
CameraViewPlugin_decorate([serialize(), uiDropdown("Ease", Object.keys(EasingFunctions).map(d => ({
    label: d
})))], CameraViewPlugin.prototype, "animEase", void 0),
CameraViewPlugin_decorate([serialize(), uiSlider("Duration", [10, 1e4], 10, {
    limitedUi: !0
})], CameraViewPlugin.prototype, "animDuration", void 0),
CameraViewPlugin_decorate([serialize(), uiSlider("RotationOffset", [.2, .75], .01)], CameraViewPlugin.prototype, "rotationOffset", void 0),
CameraViewPlugin_decorate([serialize(), uiDropdown("Interpolation", ["spherical", "linear", "spline (dev)"].map(d => ({
    label: d,
    value: d.split(" ")[0]
})))], CameraViewPlugin.prototype, "interpolateMode", void 0),
CameraViewPlugin_decorate([serialize(), uiDropdown("Spline Curve", ["centripetal", "chordal", "catmullrom"].map(d => ({
    label: d
})), d => ({
    hidden: () => d.interpolateMode !== "spline",
    onChange: () => {
        var o, c;
        return (c = (o = d.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 ? void 0 : c.call(o)
    }
}))], CameraViewPlugin.prototype, "splineCurve", void 0),
CameraViewPlugin_decorate([uiToggle(), serialize()], CameraViewPlugin.prototype, "seekOnScroll", void 0),
CameraViewPlugin_decorate([uiButton("Animate All Views", {
    limitedUi: !0
})], CameraViewPlugin.prototype, "animateAllViews", null),
CameraViewPlugin_decorate([uiButton("Record All Views")], CameraViewPlugin.prototype, "recordAllViews", null),
CameraViewPlugin_decorate([uiButton("Add Current View")], CameraViewPlugin.prototype, "addCurrentView", null),
CameraViewPlugin_decorate([uiButton("Focus Next")], CameraViewPlugin.prototype, "focusNext", void 0),
CameraViewPlugin_decorate([uiButton("Focus Previous")], CameraViewPlugin.prototype, "focusPrevious", void 0);
const tempVec = new three_module.Pq0;
function slerp(d, o, c) {
    let h = d.dot(o);
    h = Math.min(Math.max(h, -1), 1);
    const _ = Math.acos(h) * c;
    return tempVec.copy(d).multiplyScalar(h).sub(o).negate().normalize(),
    d.multiplyScalar(Math.cos(_)).add(tempVec.multiplyScalar(Math.sin(_)))
}
var vignette = "vec4 Vignette(in vec4 color){vec2 uv=vUv*(1.-vUv);float vig=uv.x*uv.y*16.;vig=pow(abs(vig),power);return vec4(mix(color.rgb,vec3(bgcolor),1.-vig),color.a);}"
  , VignettePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let VignetteExtension = class {
    constructor(d) {
        this.enabled = !1,
        this.power = .5,
        this.bgcolor = new three_module.Q1f(0),
        this.extraUniforms = {
            power: {
                value: .5
            },
            bgcolor: {
                value: new three_module.Q1f
            }
        },
        this.parsFragmentSnippet = (o, c) => this.enabled ? fe$1`
            uniform float power;
            uniform vec3 bgcolor;
            ${vignette}
        ` : "",
        this._combinedPostPlugin = d.getPlugin(CombinedPostPlugin),
        this._setDirty = this._setDirty.bind(this)
    }
    shaderExtender(d, o, c) {
        this.enabled && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker", ` 
            gl_FragColor = Vignette(gl_FragColor);
            #glMarker
        `))
    }
    onObjectRender(d, o, c) {
        this.enabled && (this.extraUniforms.power.value = this.power,
        this.extraUniforms.bgcolor.value.copy(this.bgcolor))
    }
    getUiConfig() {
        return this.uiConfig
    }
    computeCacheKey(d) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(d) {
        return !0
    }
    _setDirty() {
        this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0)
    }
    setDirty() {
        var d;
        (d = this.__setDirty) === null || d === void 0 || d.call(this),
        this._setDirty()
    }
}
;
VignetteExtension.PluginType = "Vignette",
VignettePlugin_decorate([x$1(VignetteExtension.prototype._setDirty), uiToggle("Enable"), serialize()], VignetteExtension.prototype, "enabled", void 0),
VignettePlugin_decorate([x$1(VignetteExtension.prototype._setDirty), uiSlider("Power", [.1, 4], .01, {
    limitedUi: !0
}), serialize()], VignetteExtension.prototype, "power", void 0),
VignettePlugin_decorate([x$1(VignetteExtension.prototype._setDirty), uiColor("Color"), serialize()], VignetteExtension.prototype, "bgcolor", void 0),
VignetteExtension = VignettePlugin_decorate([uiFolder("Vignette")], VignetteExtension);
class VignettePlugin extends GenericExtensionPlugin {
    constructor() {
        super()
    }
    generateExtension(o) {
        return new VignetteExtension(o)
    }
    get power() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.power) !== null && c !== void 0 ? c : 1
    }
    set power(o) {
        this._extension && (this._extension.power = o,
        this._extension.setDirty())
    }
    get color() {
        var o, c;
        return (c = (o = this._extension) === null || o === void 0 ? void 0 : o.bgcolor) !== null && c !== void 0 ? c : new three_module.Q1f
    }
    set color(o) {
        this._extension && (this._extension.bgcolor.set(o),
        this._extension.setDirty())
    }
}
VignettePlugin.PluginType = "Vignette";
var ssVelocityVert = `#ifdef USE_ALPHAMAP
#define USE_UV 
#endif
#include <uv_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 modelMatrixPrevious;void main(){
#include <uv_vertex>
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
vec4 mvPosition=vec4(transformed,1.);
#ifdef USE_INSTANCING
mvPosition=instanceMatrix*mvPosition;
#endif
vWorldPosition=(modelMatrix*mvPosition).xyz;vWorldPositionPrevious=(modelMatrixPrevious*mvPosition).xyz;mvPosition=modelViewMatrix*mvPosition;gl_Position=projectionMatrix*mvPosition;
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
}`
  , ssVelocityFrag = "varying vec3 vWorldPosition;varying vec3 vWorldPositionPrevious;uniform mat4 currentProjectionViewMatrix;uniform mat4 lastProjectionViewMatrix;vec2 computeScreenSpaceVelocity2(){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(vWorldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(vWorldPositionPrevious,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}void main(){vec2 velocity=clamp(computeScreenSpaceVelocity2(),-1.,1.);velocity=sign(velocity)*pow(abs(velocity),vec2(1./4.));velocity=velocity*0.5+0.5;gl_FragColor=vec4(velocity.x,velocity.y,1.,1.);}"
  , SSVelocityPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let SSVelocityPass = class extends RenderPass {
    constructor(d, o, c) {
        super(d, o, c ?? new SSVelocityMaterial, new three_module.Q1f(.5,.5,.5), 1),
        this.enabled = !0,
        this._firstCall = !0
    }
    render(d, o, c, h, _) {
        if (!this.enabled || !this.camera)
            return;
        const b = this.overrideMaterial;
        b.uniforms.currentProjectionViewMatrix.value.copy(this.camera.projectionMatrix).multiply(this.camera.matrixWorldInverse),
        this._firstCall && (b.uniforms.lastProjectionViewMatrix.value.copy(b.uniforms.currentProjectionViewMatrix.value),
        this._firstCall = !1),
        super.render(d, o, c, h, _),
        b.uniforms.lastProjectionViewMatrix.value.copy(b.uniforms.currentProjectionViewMatrix.value)
    }
}
;
SSVelocityPass_decorate([uiToggle("Enabled")], SSVelocityPass.prototype, "enabled", void 0),
SSVelocityPass = SSVelocityPass_decorate([uiFolder("Velocity Buffer (TAA)")], SSVelocityPass);
class SSVelocityMaterial extends three_module.BKk {
    constructor() {
        super({
            vertexShader: ssVelocityVert,
            fragmentShader: ssVelocityFrag,
            uniforms: {
                cameraNearFar: {
                    value: new three_module.I9Y(.1,1e3)
                },
                alphaMap: {
                    value: null
                },
                alphaTest: {
                    value: null
                },
                alphaMapTransform: {
                    value: new three_module.dwI
                },
                currentProjectionViewMatrix: {
                    value: new three_module.kn4
                },
                lastProjectionViewMatrix: {
                    value: new three_module.kn4
                }
            }
        }),
        this.extraUniformsToUpload = {
            modelMatrixPrevious: {
                value: new three_module.kn4().identity()
            }
        },
        this._previousWorldMatrices = {}
    }
    onBeforeRender(o, c, h, _, b) {
        var _e, nt;
        const it = this._previousWorldMatrices[b.uuid];
        this.extraUniformsToUpload.modelMatrixPrevious.value.copy(it ?? b.matrixWorld),
        it ? it.copy(b.matrixWorld) : this._previousWorldMatrices[b.uuid] = b.matrixWorld.clone();
        let at = b.material;
        Array.isArray(at) && (at = at[0]),
        this.uniforms.alphaMap.value = (_e = at == null ? void 0 : at.alphaMap) !== null && _e !== void 0 ? _e : null,
        this.uniforms.alphaTest.value = !at || !at.alphaTest || at.alphaTest < 1e-7 ? .001 : at.alphaTest;
        let ut = this.uniforms.alphaMap.value ? 1 : void 0;
        ut !== this.defines.USE_ALPHAMAP && (ut === void 0 ? delete this.defines.USE_ALPHAMAP : this.defines.USE_ALPHAMAP = ut,
        this.needsUpdate = !0),
        ut = at.userData.ALPHA_I_RGBA_PACKING ? 1 : void 0,
        ut !== this.defines.ALPHA_I_RGBA_PACKING && (ut === void 0 ? delete this.defines.ALPHA_I_RGBA_PACKING : this.defines.ALPHA_I_RGBA_PACKING = ut,
        this.needsUpdate = !0),
        this.side = (nt = at.side) !== null && nt !== void 0 ? nt : three_module.$EB
    }
}
class VelocityBufferPlugin extends GenericFilterPlugin {
    passCtor(o) {
        const c = o.renderer.createTarget({
            depthBuffer: !0,
            type: three_module.OUM
        });
        c.texture.name = "velocityBuffer",
        this._velocityBuffers.push(c),
        o.getPluginByType("debug");
        const h = new Set
          , _ = new Set;
        return new class extends SSVelocityPass {
            render(b, _e, nt, it, at) {
                var ut;
                if (o.renderer.frameCount > 0)
                    return;
                const pt = b.getRenderTarget()
                  , ht = b.getActiveCubeFace()
                  , _t = b.getActiveMipmapLevel();
                (ut = this.scene) === null || ut === void 0 || ut.traverse( ({material: vt}) => {
                    var bt, St;
                    if (!vt)
                        return;
                    const At = vt.userData.renderToDepth && !vt.userData.pluginsDisabled && !(!((bt = vt.userData[VelocityBufferPlugin.PluginType]) === null || bt === void 0) && bt.disabled)
                      , Et = vt.userData.renderToDepth === !1 || vt.userData.pluginsDisabled || ((St = vt.userData[VelocityBufferPlugin.PluginType]) === null || St === void 0 ? void 0 : St.disabled);
                    (vt.transparent && At || !vt.transparent && !vt.transmission && Et) && (h.add(vt),
                    vt.transparent = !vt.transparent),
                    Math.abs(vt.transmission || 0) > 0 && At && (_.add([vt, vt.transmission]),
                    vt.transmission = 0)
                }
                ),
                setThreeRendererMode(b, {
                    shadowMapRender: !1,
                    backgroundRender: !1,
                    opaqueRender: !0,
                    transparentRender: !1,
                    transmissionRender: !1,
                    mainRenderPass: !1
                }, () => super.render(b, _e, c, it, at)),
                h.forEach(vt => vt.transparent = !vt.transparent),
                h.clear(),
                _.forEach( ([vt,bt]) => vt.transmission = bt),
                _.clear(),
                b.setRenderTarget(pt, ht, _t)
            }
        }
    }
    _update(o) {
        if (!super._update(o) || o.renderer.frameCount > 0)
            return !1;
        const c = this.pass.passObject;
        return c.scene = o.scene.modelObject,
        o.scene.renderCamera.updateShaderProperties(c.overrideMaterial),
        c.camera = o.scene.renderCamera.cameraObject,
        !0
    }
    constructor(o=!0) {
        super(),
        this.passId = "velocityBuffer",
        this._beforeFilters = ["render"],
        this._afterFilters = [],
        this._requiredFilters = ["render"],
        this._velocityBuffers = [],
        this.enabled = o
    }
    getVelocityBuffer() {
        return this._velocityBuffers.length > 0 ? this._velocityBuffers[0] : void 0
    }
    async onDispose(o) {}
    async onRemove(o) {
        return this._velocityBuffers.forEach(c => {
            var h;
            return o.renderer.disposeTarget((h = c == null ? void 0 : c.dispose) === null || h === void 0 ? void 0 : h.call(c))
        }
        ),
        super.onRemove(o)
    }
    updateShaderProperties(o) {
        var c, h;
        return o.uniforms.tVelocity ? o.uniforms.tVelocity.value = this.enabled && (h = (c = this.getVelocityBuffer()) === null || c === void 0 ? void 0 : c.texture) !== null && h !== void 0 ? h : null : console.warn("BaseRenderer: no uniform: tVelocity"),
        this
    }
    get uiConfig() {
        var o;
        return (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.uiConfig
    }
}
VelocityBufferPlugin.PluginType = "VelocityBuffer";
var lut = `#if (USE_LUT == 1 || USE_LUT1 == 1 || USE_LUT2 == 1)
uniform float lutSize;uniform float lutSize1;uniform float lutSize2;uniform float intensity;
#if USE_3DTEXTURE == 1
precision highp sampler3D;
#if USE_LUT == 1
uniform sampler3D lut3d;
#endif
#if USE_LUT1 == 1
uniform sampler3D lut3d1;
#endif
#if USE_LUT2 == 1
uniform sampler3D lut3d2;
#endif
#else
#if USE_LUT == 1
uniform sampler2D lut2d;
#endif
#if USE_LUT1 == 1
uniform sampler2D lut2d1;
#endif
#if USE_LUT2 == 1
uniform sampler2D lut2d2;
#endif
vec3 lutLookup(sampler2D tex,float size,vec3 rgb){float sliceHeight=1./size;float yPixelHeight=1./(size*size);float slice=rgb.b*size;float interp=fract(slice);float slice0=slice-interp;float centeredInterp=interp-0.5;float slice1=slice0+sign(centeredInterp);float greenOffset=clamp(rgb.g*sliceHeight,yPixelHeight*0.5,sliceHeight-yPixelHeight*0.5);vec2 uv0=vec2(rgb.r,slice0*sliceHeight+greenOffset);vec2 uv1=vec2(rgb.r,slice1*sliceHeight+greenOffset);vec3 sample0=texture2D(tex,uv0).rgb;vec3 sample1=texture2D(tex,uv1).rgb;return mix(sample0,sample1,abs(centeredInterp));}
#endif
int getLUTBit(in int number){
#ifdef WebGL2Context
return number%2;
#else
return int(mod(float(number),2.));
#endif
}int getLUTIndex(in int number){
#ifdef WebGL2Context
return number%8;
#else
return int(mod(float(number),8.));
#endif
}vec3 getUVW(in float lutSize,in vec4 color){float pixelWidth=1./lutSize;float halfPixelWidth=0.5/lutSize;vec3 uvw=vec3(halfPixelWidth)+color.rgb*(1.-pixelWidth);return uvw;}vec4 colorLookUp(in vec4 color){vec4 outColor;float lutFac=float(getLUTBit(getGBufferFlags(vUv).a));float lutIndex=float(getLUTIndex(getGBufferFlags(vUv).g));
#if USE_3DTEXTURE == 1
if(lutIndex==0.){
#if USE_LUT == 1
outColor=vec4(texture(lut3d,getUVW(lutSize,color)).rgb,color.a);
#endif
}else if(lutIndex==1.){
#if USE_LUT1 == 1
outColor=vec4(texture(lut3d1,getUVW(lutSize1,color)).rgb,color.a);
#endif
}else if(lutIndex==2.){
#if USE_LUT2 == 1
outColor=vec4(texture(lut3d2,getUVW(lutSize2,color)).rgb,color.a);
#endif
}else{
#if USE_LUT == 1
outColor=vec4(texture(lut3d,getUVW(lutSize,color)).rgb,color.a);
#endif
}
#else
if(lutIndex==0.){outColor=vec4(lutLookup(lut2d,lutSize,getUVW(lutSize,color)),color.a);}else if(lutIndex==1.){
#if USE_LUT1 == 1
outColor=vec4(lutLookup(lut2d1,lutSize,getUVW(lutSize1,color)),color.a);
#endif
}else if(lutIndex==2.){
#if USE_LUT2 == 1
outColor=vec4(lutLookup(lut2d2,lutSize,getUVW(lutSize2,color)),color.a);
#endif
}else{outColor=vec4(lutLookup(lut2d,lutSize,getUVW(lutSize,color)),color.a);}
#endif
outColor=mix(color,outColor,lutFac);return vec4(mix(color,outColor,intensity));}
#endif
`
  , LUTPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let LUTExtension = class {
    constructor(d) {
        this.enabled = !1,
        this.lutBackground = !0,
        this.intensity = 1,
        this.lutMap = void 0,
        this.lutMap1 = void 0,
        this.lutMap2 = void 0,
        this.extraUniforms = {
            intensity: {
                value: 1
            },
            lutSize: {
                value: 1
            },
            lutSize1: {
                value: 1
            },
            lutSize2: {
                value: 1
            },
            lut3d: {
                value: null
            },
            lut3d1: {
                value: null
            },
            lut3d2: {
                value: null
            },
            lut2d: {
                value: null
            },
            lut2d1: {
                value: null
            },
            lut2d2: {
                value: null
            }
        },
        this.extraDefines = {
            USE_LUT: 0,
            USE_LUT1: 0,
            USE_LUT2: 0,
            USE_3DTEXTURE: 0,
            LUT_BACKGROUND: 0
        },
        this.parsFragmentSnippet = (o, c) => this.enabled ? lut : "",
        this._viewer = d,
        this._combinedPostPlugin = d.getPlugin(CombinedPostPlugin),
        this._setDirty = this._setDirty.bind(this),
        this.setDirty = this.setDirty.bind(this)
    }
    _updateParams() {
        if (!this.enabled)
            return;
        const d = this._viewer.renderer.rendererObject.capabilities.isWebGL2 ? 1 : 0;
        let o = d ? this.extraUniforms.lut3d : this.extraUniforms.lut2d;
        this._updateLUTMap(this.lutMap, o, this.extraUniforms.lutSize, d),
        this.extraDefines.USE_LUT = this.lutMap ? 1 : 0,
        o = d ? this.extraUniforms.lut3d1 : this.extraUniforms.lut2d1,
        this._updateLUTMap(this.lutMap1, o, this.extraUniforms.lutSize1, d),
        this.extraDefines.USE_LUT1 = this.lutMap1 ? 1 : 0,
        o = d ? this.extraUniforms.lut3d2 : this.extraUniforms.lut2d2,
        this._updateLUTMap(this.lutMap2, o, this.extraUniforms.lutSize2, d),
        this.extraDefines.USE_LUT2 = this.lutMap2 ? 1 : 0,
        this.extraUniforms.intensity.value = this.intensity,
        this.extraDefines.LUT_BACKGROUND = this.lutBackground ? 1 : 0,
        this.extraDefines.USE_3DTEXTURE = d,
        this._setDirty()
    }
    _updateLUTMap(d, o, c, h) {
        if (d) {
            let _ = 1;
            h == 1 ? (o.value = d.texture3D,
            _ = d.texture3D.image.width) : d.texture && (o.value = d.texture,
            _ = d.texture.image.width),
            o.value.needsUpdate = !0,
            c.value = _
        }
    }
    shaderExtender(d, o, c) {
        this.enabled && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker", ` 
            #if USE_LUT == 1
                bool isBackground = getDepth(vUv)>0.9999;
                #if LUT_BACKGROUND == 1
                    gl_FragColor = colorLookUp(gl_FragColor);
                #else
                    gl_FragColor = isBackground ? gl_FragColor : colorLookUp(gl_FragColor);
                #endif
            #endif
            #glMarker
        `))
    }
    computeCacheKey(d) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(d) {
        return !0
    }
    _setDirty() {
        var d;
        (d = this.__setDirty) === null || d === void 0 || d.call(this),
        this._combinedPostPlugin && (this._combinedPostPlugin.pass.dirty = !0)
    }
    setDirty() {
        this._setDirty()
    }
}
;
function addLUTData(d) {
    const o = d == null ? void 0 : d.userData;
    if (!o)
        return !1;
    o[LUTPlugin.PluginType] || (o[LUTPlugin.PluginType] = {});
    const c = o[LUTPlugin.PluginType];
    return c.enable = !0,
    c.index === void 0 && (c.index = 0),
    d.isMaterial && (d.needsUpdate = !0),
    !0
}
LUTPlugin_decorate([serialize(), x$1(LUTExtension.prototype._updateParams), uiToggle("Enable")], LUTExtension.prototype, "enabled", void 0),
LUTPlugin_decorate([serialize(), x$1(LUTExtension.prototype._updateParams), uiToggle("LUT Background")], LUTExtension.prototype, "lutBackground", void 0),
LUTPlugin_decorate([serialize(), x$1(LUTExtension.prototype._updateParams), uiSlider("Intensity")], LUTExtension.prototype, "intensity", void 0),
LUTPlugin_decorate([x$1(LUTExtension.prototype._updateParams), uiImage("LUT"), serialize()], LUTExtension.prototype, "lutMap", void 0),
LUTPlugin_decorate([x$1(LUTExtension.prototype._updateParams), uiImage("LUT1"), serialize()], LUTExtension.prototype, "lutMap1", void 0),
LUTPlugin_decorate([x$1(LUTExtension.prototype._updateParams), uiImage("LUT2"), serialize()], LUTExtension.prototype, "lutMap2", void 0),
LUTExtension = LUTPlugin_decorate([uiFolder("LUT")], LUTExtension);
class LUTPlugin extends GenericExtensionPlugin {
    _getUiConfig(o) {
        var c, h;
        const _ = {
            type: "folder",
            label: "LUT",
            children: [{
                type: "checkbox",
                label: "Enabled",
                get value() {
                    var b, _e;
                    return (_e = (b = o.materialObject.userData[LUTPlugin.PluginType]) === null || b === void 0 ? void 0 : b.enable) === null || _e === void 0 || _e
                },
                set value(b) {
                    var _e;
                    const nt = o.materialObject.userData[LUTPlugin.PluginType];
                    b !== (nt == null ? void 0 : nt.enable) && (nt || addLUTData(o.materialObject),
                    o.materialObject.userData[LUTPlugin.PluginType].enable = b,
                    (_e = _.uiRefresh) === null || _e === void 0 || _e.call(_, "postFrame", !0))
                },
                onChange: (c = this._extension) === null || c === void 0 ? void 0 : c.setDirty
            }, {
                type: "dropdown",
                children: [["LUT 0", 0], ["LUT 1", 1], ["LUT 2", 2]].map(b => ({
                    label: b[0],
                    value: b[1]
                })),
                label: "index",
                hidden: () => {
                    const b = o.materialObject.userData[LUTPlugin.PluginType];
                    return !!b && !b.enable
                }
                ,
                get value() {
                    var b, _e;
                    return (_e = (b = o.materialObject.userData[LUTPlugin.PluginType]) === null || b === void 0 ? void 0 : b.index) !== null && _e !== void 0 ? _e : 0
                },
                set value(b) {
                    var _e;
                    o.materialObject.userData[LUTPlugin.PluginType] || addLUTData(o.materialObject),
                    o.materialObject.userData[LUTPlugin.PluginType].index = b,
                    (_e = _.uiRefresh) === null || _e === void 0 || _e.call(_, "postFrame", !0)
                },
                onChange: (h = this._extension) === null || h === void 0 ? void 0 : h.setDirty
            }]
        };
        return _
    }
    constructor() {
        super(),
        this.materialExtension = {
            uuid: esm_browser_v4(),
            getUiConfig: o => {
                if (o.__uiConfigs || (o.__uiConfigs = {}),
                o.__uiConfigs[this.materialExtension.uuid])
                    return o.__uiConfigs[this.materialExtension.uuid];
                const c = this._getUiConfig(o);
                return o.__uiConfigs[this.materialExtension.uuid] = c,
                c
            }
            ,
            computeCacheKey: o => {
                var c;
                return (this.enabled ? "1" : "0") + (!((c = o.materialObject.userData[LUTPlugin.PluginType]) === null || c === void 0) && c.enable ? "1" : "0")
            }
            ,
            isCompatible: o => !0
        },
        this.updateGBuffer = this.updateGBuffer.bind(this)
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 || c.registerGBufferUpdater(this.updateGBuffer);
        const _ = o.getPlugin(AssetManagerPlugin);
        (h = _ == null ? void 0 : _.materials) === null || h === void 0 || h.registerMaterialExtension(this.materialExtension)
    }
    generateExtension(o) {
        return new LUTExtension(o)
    }
    updateGBuffer(o, c) {
        var h, _;
        if (o instanceof three_module.eaF && (!((h = o.material) === null || h === void 0) && h.userData)) {
            const b = (_ = o.material) === null || _ === void 0 ? void 0 : _.userData[LUTPlugin.PluginType];
            if (b) {
                const _e = b.enable === !1 ? 0 : 1;
                c.w = updateBit(c.w, 0, _e);
                for (let it = 0; it < 3; it++)
                    c.y = clearBit(c.y, it);
                let nt = b.enable ? b.index : 0;
                nt = Math.min(nt, 7),
                c.y = c.y | nt
            } else
                c.w = updateBit(c.w, 0, 1)
        }
    }
}
LUTPlugin.PluginType = "LUTPlugin1";
class GyroInputDevice {
    constructor(o) {
        this._zee = new three_module.Pq0(0,0,1),
        this._euler = new three_module.O9p,
        this._q0 = new three_module.PTz,
        this._q1 = new three_module.PTz(-Math.sqrt(.5),0,0,Math.sqrt(.5)),
        this._q2 = new three_module.PTz,
        this._initQuaternionDest = new three_module.PTz,
        this.onScreenOrientationChangeEvent = () => {
            this.screenOrientation = screen.orientation
        }
        ,
        this.onDeviceOrientationChangeEvent = c => {
            this.deviceOrientation = c
        }
        ,
        this._isConnected = !1,
        this._viewer = o
    }
    getOffsetFromCenter(o=!0) {
        if (!this.deviceOrientation)
            return new three_module.I9Y;
        this.getQuaternion(o, this._q2);
        const c = new three_module.Pq0(0,0,1);
        return c.applyQuaternion(this._q2),
        new three_module.I9Y(c.x,c.y)
    }
    getQuaternion(o, c) {
        if (c || (c = new three_module.PTz),
        !this.deviceOrientation)
            return c.identity();
        const h = this.deviceOrientation
          , _ = h.alpha !== null ? three_module.cj9.degToRad(h.alpha) : 0
          , b = h.beta !== null ? three_module.cj9.degToRad(h.beta) : 0
          , _e = h.gamma !== null ? three_module.cj9.degToRad(h.gamma) : 0
          , nt = this.screenOrientation ? three_module.cj9.degToRad(this.screenOrientation.angle) : 0;
        return this._toQuaternion(c, _, b, _e, nt, o),
        c
    }
    _toQuaternion(o, c, h, _, b, _e) {
        this._euler.set(h, c, -_, "YXZ"),
        o.setFromEuler(this._euler),
        o.multiply(this._q1);
        const nt = document.getElementById("debug");
        return nt && (nt.textContent = b + ""),
        o.multiply(this._q0.setFromAxisAngle(this._zee, -b)),
        this._initQuaternionDest.__init || (this._initQuaternionDest.copy(o).invert(),
        this._initQuaternionDest.__init = !0),
        _e && o.premultiply(this._initQuaternionDest),
        o
    }
    static IsCompatible() {
        return window.DeviceOrientationEvent !== void 0 && "ontouchstart"in window
    }
    addPermissionMessage() {
        this.permissionMessage = document.createElement("div"),
        this.permissionMessage.innerHTML = "Tap on the screen to allow gyroscope",
        this.permissionMessage.style.visibility = "visible",
        this.permissionMessage.style.width = "100%",
        this.permissionMessage.style.height = "40px",
        this.permissionMessage.style.color = "black",
        this.permissionMessage.style.position = "absolute",
        this.permissionMessage.style.textAlign = "center",
        this.permissionMessage.style.fontSize = "12px",
        this.permissionMessage.style.bottom = "20%",
        this._viewer.container.appendChild(this.permissionMessage)
    }
    connect() {
        var o;
        if (!this._isConnected)
            return this._isConnected = !0,
            this.onScreenOrientationChangeEvent(),
            !!window.DeviceOrientationEvent && (this.askPermission(),
            (o = this._viewer) === null || o === void 0 || o.renderer.rendererObject.domElement.addEventListener("click", this.askPermission.bind(this)),
            window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent),
            window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent),
            !0)
    }
    askPermission() {
        this.onScreenOrientationChangeEvent(),
        typeof DeviceMotionEvent.requestPermission == "function" && (this.addPermissionMessage(),
        DeviceOrientationEvent.requestPermission().then(o => {
            o == "granted" && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent),
            window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent),
            this._viewer.container.removeChild(this.permissionMessage))
        }
        ).catch(o => {
            console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", o)
        }
        ))
    }
    disconnect() {
        this._isConnected && (this._isConnected = !1,
        window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent),
        window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent),
        this._initQuaternionDest = new three_module.PTz)
    }
}
class MouseInputDevice {
    constructor() {
        this._mousePos = new three_module.I9Y(0,0),
        this._isConnected = !1
    }
    getOffsetFromCenter() {
        return new three_module.I9Y(this._mousePos.x / window.innerWidth * 2 - 1,-(this._mousePos.y / window.innerHeight * 2 - 1))
    }
    connect() {
        this._isConnected || (this._isConnected = !0,
        window.addEventListener("mousemove", this._onMouseMove.bind(this)))
    }
    disconnect() {
        this._isConnected && (this._isConnected = !1,
        window.removeEventListener("mousemove", this._onMouseMove.bind(this)))
    }
    _onMouseMove(o) {
        this._mousePos.set(o.clientX, o.clientY)
    }
}
var ParallaxCameraControllerPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, ParallaxCameraControllerPlugin_1;
let ParallaxCameraControllerPlugin = ParallaxCameraControllerPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !1,
        this.enableEdit = !1,
        this.invert = !1,
        this.sensitivity = .5,
        this.focalPointHit = new three_module.Pq0(0,0,0),
        this.damping = .5,
        this.cameraView = "",
        this._target = new three_module.Pq0,
        this._center = new three_module.Pq0,
        this._pointerDown = !1,
        this._focalDistance = 100,
        this._updateProjectionMatrix = () => {
            var d, o;
            if (!this.enabled)
                return void ((o = (d = this._object)._updateProjectionMatrixParallax) === null || o === void 0 || o.call(d));
            const c = this._object
              , h = c.near;
            let _ = h * Math.tan(.5 * three_module.cj9.DEG2RAD * c.fov) / c.zoom
              , b = 2 * _
              , _e = c.aspect * b
              , nt = -.5 * _e;
            if (c.view !== null && c.view.enabled) {
                const at = c.view.fullWidth
                  , ut = c.view.fullHeight;
                nt += c.view.offsetX * _e / at,
                _ -= c.view.offsetY * b / ut,
                _e *= c.view.width / at,
                b *= c.view.height / ut
            }
            nt -= this._offX * h / this._focalDistance,
            _ -= this._offY * h / this._focalDistance;
            const it = c.filmOffset;
            it !== 0 && (nt += h * it / c.getFilmWidth()),
            c.projectionMatrix.makePerspective(nt, nt + _e, _, _ - b, h, c.far),
            c.projectionMatrixInverse.copy(c.projectionMatrix).invert()
        }
        ,
        this._preFrame = d => {
            this.update(d.deltaTime)
        }
        ,
        this._offX = 0,
        this._offY = 0,
        this._xDamper = new k$1,
        this._yDamper = new k$1,
        this._onEnabledChange = this._onEnabledChange.bind(this),
        this._onDampingChange = this._onDampingChange.bind(this),
        this._onObjectHit = this._onObjectHit.bind(this),
        this._onActiveCameraChange = this._onActiveCameraChange.bind(this)
    }
    async onAdded(d) {
        var o, c, h;
        await super.onAdded(d),
        GyroInputDevice.IsCompatible() ? this._input = new GyroInputDevice(d) : this._input = new MouseInputDevice,
        d.scene.addEventListener("activeCameraChange", this._onActiveCameraChange),
        this.addIndicator(),
        d.addEventListener("preFrame", this._preFrame),
        (o = this._viewer) === null || o === void 0 || o.container.addEventListener("pointerdown", this.onPointerDown.bind(this)),
        (c = this._viewer) === null || c === void 0 || c.container.addEventListener("pointerup", this.onPointerUp.bind(this)),
        (h = d.getPluginByType("Picking")) === null || h === void 0 || h.addEventListener("hitObject", this._onObjectHit),
        this._onEnabledChange()
    }
    _onActiveCameraChange() {
        var d, o, c, h;
        this._object && (!((d = this._object) === null || d === void 0) && d._updateProjectionMatrixParallax) && (this._object.updateProjectionMatrix = this._object._updateProjectionMatrixParallax,
        delete this._object._updateProjectionMatrixParallax),
        this._focalDistance = .01,
        this._object = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.activeCamera.cameraObject,
        !((c = this._object) === null || c === void 0) && c.isOrthographicCamera ? (h = this._viewer) === null || h === void 0 || h.console.warn("ParallaxCameraControllerPlugin: Orthographic camera is not supported") : this.enabled && (this._object._updateProjectionMatrixParallax = this._object.updateProjectionMatrix,
        this._object.updateProjectionMatrix = this._updateProjectionMatrix)
    }
    addIndicator() {
        var d;
        this._viewer && (this._indicator && this._indicator.remove(),
        this._indicator = document.createElement("div"),
        this._indicator.style.width = "40px",
        this._indicator.style.height = "40px",
        this._indicator.style.borderRadius = "100%",
        this._indicator.style.border = "4px solid #ff4444",
        this._indicator.style.transform = "translate(-50%, -50%)",
        this._indicator.style.position = "absolute",
        this._indicator.style.top = "0",
        this._indicator.style.left = "0",
        this._indicator.style.zIndex = "10000",
        this._indicator.style.opacity = "0",
        this._indicator.style.transition = "opacity 0.5s",
        this._indicator.style.pointerEvents = "none",
        (d = this._viewer) === null || d === void 0 || d.container.appendChild(this._indicator))
    }
    onPointerDown(d) {
        this.enabled && this._viewer && (this._pointerDown = !0,
        this.enableEdit && this._indicator && (this._indicator.style.top = d.clientY - this._viewer.container.offsetTop + "px",
        this._indicator.style.left = d.clientX - this._viewer.container.offsetLeft + "px"))
    }
    onPointerUp() {
        this._pointerDown = !1
    }
    update(d) {
        if (!this.enabled || this._pointerDown || !this._input || !this._object || !this._viewer)
            return;
        this._viewer.scene.activeCamera.setInteractions(!1, ParallaxCameraControllerPlugin_1.PluginType),
        this._updateFocalDistance();
        const o = this._object.matrixWorld.elements
          , c = new three_module.Pq0(o[0],o[1],o[2])
          , h = new three_module.Pq0(o[4],o[5],o[6]);
        this._object.position.copy(this._center),
        this._viewer.scene.activeCamera.positionUpdated();
        let _ = this.sensitivity;
        this.invert && (_ *= -1),
        this._offX = this._xDamper.update(this._offX, this._input.getOffsetFromCenter().x * _, d, 1),
        this._offY = this._yDamper.update(this._offY, this._input.getOffsetFromCenter().y * _, d, 1);
        const b = this._object;
        b.position.add(h.multiplyScalar(this._offY)).add(c.multiplyScalar(this._offX)),
        b.updateProjectionMatrix(),
        b.updateMatrixWorld(),
        this._dirty = !0
    }
    _onObjectHit(d) {
        var o, c;
        d.intersects.intersect && this.enableEdit && (this.focalPointHit.copy(d.intersects.intersect.point),
        d.intersects.selectedObject = null,
        (c = (o = this.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0),
        this._indicator && (this._indicator.style.display = "block",
        this._indicator.style.opacity = "1",
        setTimeout( () => {
            var h, _;
            this._indicator.style.opacity = "0",
            setTimeout( () => this._indicator.style.display = "none", 600),
            (_ = (h = this.uiConfig) === null || h === void 0 ? void 0 : h.uiRefresh) === null || _ === void 0 || _.call(h, "postFrame", !0)
        }
        , 200)))
    }
    _updateFocalDistance() {
        if (!this._object)
            return;
        const d = this._object
          , o = new three_module.Pq0;
        d.getWorldDirection(o),
        o.normalize(),
        this._focalDistance = this.focalPointHit.clone().sub(d.position).dot(o)
    }
    _onEnabledChange() {
        var d, o, c;
        if (this._viewer) {
            if (this.enabled) {
                if ((d = this._input) === null || d === void 0 || d.connect(),
                this._onActiveCameraChange(),
                !this._object)
                    return;
                this._viewer.scene.activeCamera.setInteractions(!1, ParallaxCameraControllerPlugin_1.PluginType);
                const h = this._viewer.getPluginByType("CameraViews")
                  , _ = h == null ? void 0 : h.camViews.find(b => b.name === this.cameraView);
                h && _ && h.setCurrentCameraView(_),
                this._updateFocalDistance(),
                this._center.copy(this._object.position),
                this._object.lookAt(this._viewer.scene.activeCamera.target)
            } else if (this._object) {
                this._onActiveCameraChange(),
                this._viewer.scene.activeCamera.setInteractions(!0, ParallaxCameraControllerPlugin_1.PluginType),
                this._object.position.copy(this._center),
                this._object.lookAt(this._viewer.scene.activeCamera.target);
                const h = this._object;
                h.updateProjectionMatrix(),
                h.updateMatrixWorld()
            }
            (c = (o = this.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0)
        }
    }
    _onDampingChange() {
        this._xDamper && this._yDamper && (this._xDamper.setDecayTime(100 * this.damping),
        this._yDamper.setDecayTime(100 * this.damping))
    }
    dispose() {
        var d;
        (d = this._input) === null || d === void 0 || d.disconnect()
    }
}
;
ParallaxCameraControllerPlugin.PluginType = "ParallaxCameraControllerPlugin",
ParallaxCameraControllerPlugin_decorate([x$1(ParallaxCameraControllerPlugin.prototype._onEnabledChange), serialize(), uiToggle("Enabled")], ParallaxCameraControllerPlugin.prototype, "enabled", void 0),
ParallaxCameraControllerPlugin_decorate([serialize(), uiToggle("enableEdit")], ParallaxCameraControllerPlugin.prototype, "enableEdit", void 0),
ParallaxCameraControllerPlugin_decorate([serialize(), uiToggle("Invert")], ParallaxCameraControllerPlugin.prototype, "invert", void 0),
ParallaxCameraControllerPlugin_decorate([serialize(), uiSlider("Sensitivity", [.1, 2], .01)], ParallaxCameraControllerPlugin.prototype, "sensitivity", void 0),
ParallaxCameraControllerPlugin_decorate([serialize("focalPoint"), uiVector("Focal Point Hit", void 0, .001)], ParallaxCameraControllerPlugin.prototype, "focalPointHit", void 0),
ParallaxCameraControllerPlugin_decorate([x$1(ParallaxCameraControllerPlugin.prototype._onDampingChange), serialize(), uiSlider("Damping", [0, 1], .001)], ParallaxCameraControllerPlugin.prototype, "damping", void 0),
ParallaxCameraControllerPlugin_decorate([serialize(), uiInput("Camera View")], ParallaxCameraControllerPlugin.prototype, "cameraView", void 0),
ParallaxCameraControllerPlugin = ParallaxCameraControllerPlugin_1 = ParallaxCameraControllerPlugin_decorate([uiFolder("Parallax Camera Controller")], ParallaxCameraControllerPlugin);
var voronoi = `#ifndef VORONOI_HELPER
#define VORONOI_HELPER 
float voronoi_distance(vec2 a,vec2 b,float metric){return distance(a,b);}float voronoi_f1_2d(in vec2 coord,in float randomness,in float flakeClamp,in float flakeRadius,inout vec3 outColor){vec2 cellPosition=floor(coord);vec2 localPosition=coord-cellPosition;float minDistance=8.;vec2 targetOffset,targetPosition;for(int j=-1;j<=1;j++){for(int i=-1;i<=1;i++){vec2 cellOffset=vec2(i,j);vec2 pointPosition=cellOffset+hash3(cellPosition+cellOffset).xy*randomness;float distanceToPoint=voronoi_distance(pointPosition,localPosition,1.);if(distanceToPoint<minDistance){targetOffset=cellOffset;minDistance=distanceToPoint;targetPosition=pointPosition;}}}float outDistance=minDistance;float dist=step(flakeRadius,outDistance);outColor=hash3(cellPosition+hash3(cellPosition+targetOffset).xy*randomness+targetOffset);vec3 outColor1=minDistance<flakeRadius?outColor:vec3(0.5,0.5,1.);outDistance=mix(dist,minDistance,flakeClamp);outColor=mix(outColor1,outColor,flakeClamp);return outDistance;}
#endif
`
  , noiseBumpMatPars = "uniform vec2 noiseBumpParams;uniform float noiseBumpScale;uniform float noiseBumpFlakeScale;uniform float noiseFlakeClamp;uniform float noiseFlakeRadius;uniform bool useColorFlakes;uniform vec4 flakeParams;uniform vec3 flakeFallOffParams;vec3 perturbNormalArb_nb(vec3 surf_pos,vec3 surf_norm,vec2 dHdxy,float faceDirection){vec3 vSigmaX=dFdx(surf_pos.xyz);vec3 vSigmaY=dFdy(surf_pos.xyz);vec3 vN=surf_norm;vec3 R1=cross(vSigmaY,vN);vec3 R2=cross(vN,vSigmaX);float fDet=dot(vSigmaX,R1)*faceDirection;vec3 vGrad=sign(fDet)*(dHdxy.x*R1+dHdxy.y*R2);return normalize(abs(fDet)*surf_norm-vGrad);}"
  , noiseBumpMat = `vec3 outColor,outColor1,outColor2,outColor3,outColor4,outColor5;float distFac=length(vViewPosition.xyz);float level=1.;vec2 uvMod=noiseBumpFlakeScale*noiseBumpParams.xy*vUv*level;float voronoiDist=clamp(voronoi_f1_2d(uvMod,1.,noiseFlakeClamp,noiseFlakeRadius,outColor),0.,1.);vec3 oldNormal=normal;normal=perturbNormalArb_nb(-vViewPosition,normal,(2.*outColor.xy-1.)*noiseBumpScale,faceDirection);float oldRoughnessFactor=roughnessFactor;float oldMetalnessFactor=metalnessFactor;roughnessFactor=mix(roughnessFactor,flakeParams.x,1.-voronoiDist);metalnessFactor=mix(metalnessFactor,flakeParams.y,1.-voronoiDist);
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
vec3 sparkleRadiance=getIBLRadiance(normalize(vViewPosition),normal,roughnessFactor);float sparkleIntensity=length(sparkleRadiance);float sparkleIntensityMultiplier=sparkleIntensity>1.3?flakeParams.z:1.;vec3 oldDiffuseColor=diffuseColor.rgb;vec2 cellPosition_=floor(uvMod);vec3 colorRGB=useColorFlakes?hash3(cellPosition_):vec3(1.);float fallOff_=mix(1.,1./(1.+flakeFallOffParams.y*distFac+flakeFallOffParams.z*distFac*distFac),flakeFallOffParams.x);diffuseColor.rgb*=mix(vec3(1.),sparkleIntensityMultiplier*colorRGB*fallOff_,vec3(1.-voronoiDist));if(sparkleIntensity<flakeParams.w){float mixFactor=1.;roughnessFactor=mix(roughnessFactor,oldRoughnessFactor,mixFactor);metalnessFactor=mix(metalnessFactor,oldMetalnessFactor,mixFactor);normal=normalize(mix(normal,oldNormal,mixFactor));diffuseColor.rgb=mix(diffuseColor.rgb,oldDiffuseColor,mixFactor);}
#endif
`
  , NoiseBumpMaterialPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let NoiseBumpMaterialPlugin = class extends AViewerPlugin {
    addNoiseBumpMaterial(d) {
        return addNoiseBumpMaterial(d.materialObject)
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsNoiseBumpMaterialExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this._uniforms = {
            noiseBumpParams: {
                value: new three_module.I9Y
            },
            noiseBumpScale: {
                value: .05
            },
            noiseBumpFlakeScale: {
                value: 1e3
            },
            noiseFlakeClamp: {
                value: 1
            },
            noiseFlakeRadius: {
                value: .5
            },
            flakeParams: {
                value: new three_module.IUQ(0,1,3,0)
            },
            flakeFallOffParams: {
                value: new three_module.Pq0(0,1,0)
            },
            useColorFlakes: {
                value: !1
            }
        },
        this.materialExtension = {
            parsFragmentSnippet: (d, o) => {
                var c;
                return this.enabled && (!((c = o == null ? void 0 : o.materialObject.userData._noiseBumpMat) === null || c === void 0) && c.hasBump) ? randomHelpers + `
` + voronoi + `
` + noiseBumpMatPars + `
` : ""
            }
            ,
            shaderExtender: (d, o, c) => {
                var h;
                if (!this.enabled || !(!((h = o.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump))
                    return;
                const _ = "#glMarker beforeAccumulation"
                  , b = noiseBumpMat;
                d.fragmentShader = d.fragmentShader.replace(_, b + `
` + _),
                d.defines.USE_UV = "",
                d.extensionDerivatives = !0
            }
            ,
            onObjectRender: (d, o) => {
                var c;
                const h = (c = o.materialObject.userData) === null || c === void 0 ? void 0 : c._noiseBumpMat;
                if (!(h != null && h.hasBump))
                    return;
                this._uniforms.noiseBumpParams.value.fromArray(h.bumpNoiseParams),
                this._uniforms.noiseBumpScale.value = h.bumpScale,
                this._uniforms.noiseBumpFlakeScale.value = h.flakeScale,
                this._uniforms.noiseFlakeClamp.value = h.flakeClamp,
                this._uniforms.noiseFlakeRadius.value = h.flakeRadius,
                h.flakeParams && this._uniforms.flakeParams.value.copy(h.flakeParams),
                h.flakeFallOffParams && this._uniforms.flakeFallOffParams.value.copy(h.flakeFallOffParams),
                this._uniforms.useColorFlakes.value = h.useColorFlakes;
                const _ = this.enabled ? 1 : 0;
                o.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED !== _ && (o.materialObject.defines.NOISE_BUMP_MATERIAL_ENABLED = _,
                o.materialObject.needsUpdate = !0)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c;
                return (this.enabled ? "1" : "0") + (!((c = (o = d.materialObject.userData) === null || o === void 0 ? void 0 : o._noiseBumpMat) === null || c === void 0) && c.hasBump ? "1" : "0")
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2,
            updaters: () => [],
            getUiConfig: d => {
                const o = this._viewer
                  , c = {
                    type: "folder",
                    label: "SparkleBump (NoiseBump)",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            var h;
                            return ((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.hasBump) || !1
                        },
                        set value(h) {
                            var _, b;
                            h !== ((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0 ? void 0 : _.hasBump) && (h ? addNoiseBumpMaterial(d.materialObject) || o.alert("Cannot add noise bump.") : d.materialObject.userData._noiseBumpMat && (d.materialObject.userData._noiseBumpMat.hasBump = !1,
                            d.materialObject.needsUpdate = !0),
                            (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, () => ({
                        type: "vec4",
                        label: "Bump Noise Params",
                        bounds: [0, 1],
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump)
                        }
                        ,
                        property: [d.materialObject.userData._noiseBumpMat, "bumpNoiseParams"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        label: "Bump Scale",
                        bounds: [0, .001],
                        stepSize: 1e-5,
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump)
                        }
                        ,
                        property: [d.materialObject.userData._noiseBumpMat, "bumpScale"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        label: "Flake Scale",
                        bounds: [100, 1e4],
                        stepSize: 1e-4,
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump)
                        }
                        ,
                        property: [d.materialObject.userData._noiseBumpMat, "flakeScale"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        label: "Flake Clamp",
                        bounds: [0, 1],
                        stepSize: 1,
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump)
                        }
                        ,
                        property: [d.materialObject.userData._noiseBumpMat, "flakeClamp"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        label: "Flake Radius",
                        bounds: [.01, 1],
                        stepSize: .001,
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump)
                        }
                        ,
                        property: [d.materialObject.userData._noiseBumpMat, "flakeRadius"],
                        onChange: this.setDirty
                    }), () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Flake Roughness",
                            bounds: [0, 1],
                            stepSize: .01,
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeParams, "x"],
                            onChange: this.setDirty
                        }
                    }
                    , () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Flake Metalness",
                            bounds: [0, 1],
                            stepSize: .01,
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeParams, "y"],
                            onChange: this.setDirty
                        }
                    }
                    , () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Flake Strength",
                            bounds: [0, 100],
                            stepSize: .001,
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeParams, "z"],
                            onChange: this.setDirty
                        }
                    }
                    , () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Flake Threshold",
                            bounds: [.1, 10],
                            stepSize: .001,
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeParams, "w"],
                            onChange: this.setDirty
                        }
                    }
                    , () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Falloff",
                            stepSize: 1,
                            bounds: [0, 1],
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeFallOffParams, "x"],
                            onChange: this.setDirty
                        }
                    }
                    , () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Linear falloff factor",
                            bounds: [0, 10],
                            stepSize: .001,
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeFallOffParams, "y"],
                            onChange: this.setDirty
                        }
                    }
                    , () => {
                        var h;
                        return {
                            type: "slider",
                            label: "Quadratic falloff factor",
                            bounds: [0, 10],
                            stepSize: .001,
                            hidden: () => {
                                var _;
                                return !(!((_ = d.materialObject.userData._noiseBumpMat) === null || _ === void 0) && _.hasBump)
                            }
                            ,
                            property: [(h = d.materialObject.userData._noiseBumpMat) === null || h === void 0 ? void 0 : h.flakeFallOffParams, "z"],
                            onChange: this.setDirty
                        }
                    }
                    , () => ({
                        type: "checkbox",
                        label: "Colored Flakes",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._noiseBumpMat) === null || h === void 0) && h.hasBump)
                        }
                        ,
                        property: [d.materialObject.userData._noiseBumpMat, "useColorFlakes"],
                        onChange: this.setDirty
                    })]
                };
                return c
            }
        },
        this.setDirty = () => {
            var d, o, c;
            (o = (d = this.materialExtension).setDirty) === null || o === void 0 || o.call(d),
            (c = this._viewer) === null || c === void 0 || c.setDirty()
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsNoiseBumpMaterialExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
function addNoiseBumpMaterial(d) {
    const o = d == null ? void 0 : d.userData;
    if (!o)
        return !1;
    o._noiseBumpMat || (o._noiseBumpMat = {});
    const c = o._noiseBumpMat;
    return c.hasBump = !0,
    c.bumpNoiseParams === void 0 && (c.bumpNoiseParams = [.5, .5]),
    c.bumpScale === void 0 && (c.bumpScale = .05),
    c.flakeScale === void 0 && (c.flakeScale = .05),
    c.flakeClamp === void 0 && (c.flakeClamp = 1),
    c.flakeRadius === void 0 && (c.flakeRadius = .3),
    c.useColorFlakes === void 0 && (c.useColorFlakes = !1),
    c.flakeParams === void 0 && (c.flakeParams = new three_module.IUQ(0,1,3,0)),
    c.flakeFallOffParams === void 0 && (c.flakeFallOffParams = new three_module.Pq0(0,1,0)),
    d.isMaterial && (d.needsUpdate = !0),
    !0
}
NoiseBumpMaterialPlugin.PluginType = "NoiseBumpMaterialPlugin",
NoiseBumpMaterialPlugin.NOISE_BUMP_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_noise_bump",
NoiseBumpMaterialPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], NoiseBumpMaterialPlugin.prototype, "enabled", void 0),
NoiseBumpMaterialPlugin = NoiseBumpMaterialPlugin_decorate([uiFolder("NoiseBump Materials")], NoiseBumpMaterialPlugin);
class GLTFMaterialsNoiseBumpMaterialExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = NoiseBumpMaterialPlugin.NOISE_BUMP_MATERIAL_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        return c.userData || (c.userData = {}),
        addNoiseBumpMaterial(c),
        c.userData._noiseBumpMat = deserializeObject(_, c.userData._noiseBumpMat, !1, {}),
        Promise.resolve()
    }
}
const glTFMaterialsNoiseBumpMaterialExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._noiseBumpMat || !o.userData._noiseBumpMat.hasBump)
            return;
        c.extensions = c.extensions || {};
        const h = serializeObject(o.userData._noiseBumpMat, !1);
        c.extensions[NoiseBumpMaterialPlugin.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = h,
        d.extensionsUsed[NoiseBumpMaterialPlugin.NOISE_BUMP_MATERIAL_GLTF_EXTENSION] = !0
    }
});
var taa = `#include <common>
varying vec2 vUv;uniform vec2 previousRTSize;uniform mat4 lastProjectionViewMatrix;uniform mat4 currentProjectionViewMatrix;uniform mat4 inverseViewMatrix;uniform vec2 jitterSample;uniform vec2 feedBack;uniform bool firstFrame;
#if HAS_VELOCITY_BUFFER == 1
uniform sampler2D tVelocity;
#endif
vec3 find_closest_fragment_3x3(const in vec2 uv){const vec3 offset=vec3(-1.,1.,0.);vec2 texelSize=1./previousRTSize;vec3 dtr=vec3(1,1,getDepth(uv+offset.yy*texelSize));vec3 dtc=vec3(0,1,getDepth(uv+offset.zy*texelSize));vec3 dtl=vec3(-1,1,getDepth(uv+offset.xy*texelSize));vec3 dml=vec3(-1,0,getDepth(uv+offset.xz*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dmr=vec3(1,0,getDepth(uv+offset.yz*texelSize));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.xx*texelSize));vec3 dbc=vec3(0,-1,getDepth(uv+offset.zx*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.yx*texelSize));vec3 dmin=dtl;if(dmin.z>dtc.z)dmin=dtc;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dml.z)dmin=dml;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dmr.z)dmin=dmr;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbc.z)dmin=dbc;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+texelSize.xy*dmin.xy,dmin.z);}vec3 find_closest_fragment_5tap(const in vec2 uv){vec2 texelSize=1./previousRTSize;vec2 offset=vec2(1.,-1.);vec3 dtl=vec3(-1,1,getDepth(uv+offset.yx*texelSize));vec3 dtr=vec3(1,1,getDepth(uv+offset.xx*texelSize));vec3 dmc=vec3(0,0,getDepth(uv));vec3 dbl=vec3(-1,-1,getDepth(uv+offset.yy*texelSize));vec3 dbr=vec3(1,-1,getDepth(uv+offset.xy*texelSize));vec3 dmin=dtl;if(dmin.z>dtr.z)dmin=dtr;if(dmin.z>dmc.z)dmin=dmc;if(dmin.z>dbl.z)dmin=dbl;if(dmin.z>dbr.z)dmin=dbr;return vec3(uv+dmin.xy*texelSize,dmin.z);}vec4 clip_aabb(const in vec4 aabb_min,const in vec4 aabb_max,vec4 p){const float FLT_EPS=1e-8;vec4 p_clip=0.5*(aabb_max+aabb_min);vec4 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=p-p_clip;vec4 v_unit=abs(v_clip/e_clip);float ma_unit=max(v_unit.x,max(v_unit.y,v_unit.z));if(ma_unit>1.)return p_clip+v_clip/ma_unit;else return p;}
#if HAS_VELOCITY_BUFFER == 0
vec2 computeScreenSpaceVelocity(const in vec3 worldPosition){vec4 currentPositionClip=currentProjectionViewMatrix*vec4(worldPosition,1.);vec4 prevPositionClip=lastProjectionViewMatrix*vec4(worldPosition,1.);vec2 currentPositionNDC=currentPositionClip.xy/currentPositionClip.w;vec2 prevPositionNDC=prevPositionClip.xy/prevPositionClip.w;if(prevPositionNDC.x>=1.||prevPositionNDC.x<=-1.||prevPositionNDC.x>=1.||prevPositionNDC.y<=-1.){return vec2(0.);}return 0.5*(currentPositionNDC-prevPositionNDC);}
#endif
vec4 computeTAA(const in vec2 uv,const in vec2 screenSpaceVelocity,const in float feedbackScale){vec2 uvUnJitter=uv;vec4 currentColor=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter));vec4 previousColor=previousRTTexelToLinear(texture2D(previousRT,uv-screenSpaceVelocity));const vec3 offset=vec3(1.,-1.,0.);vec2 texelSize=1./previousRTSize;float texelSpeed=length(screenSpaceVelocity);vec4 tl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yx*texelSize));vec4 tc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zx*texelSize));vec4 tr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xx*texelSize));vec4 ml=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yz*texelSize));vec4 mc=currentColor;vec4 mr=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xz*texelSize));vec4 bl=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.yy*texelSize));vec4 bc=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.zy*texelSize));vec4 br=currentRTTexelToLinear(texture2D(currentRT,uvUnJitter+offset.xy*texelSize));vec4 corners=2.*(tr+bl+br+tl)-2.*mc;mc+=(mc-(corners*0.166667))*2.718282*0.3;mc=max(vec4(0.),mc);vec4 min5=min(tc,min(ml,min(mc,min(mr,bc))));vec4 max5=max(tc,max(ml,max(mc,max(mr,bc))));vec4 cmin=min(min5,min(tl,min(tr,min(bl,br))));vec4 cmax=max(min5,max(tl,max(tr,max(bl,br))));;cmin=0.5*(cmin+min5);cmax=0.5*(cmax+max5);previousColor=clip_aabb(cmin,cmax,previousColor);float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColor.rgb);float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedBack.x,feedBack.y,unbiased_weight_sqr);return mix(currentColor,previousColor,clamp(k_feedback*feedbackScale,0.,1.));}vec3 getWorldPositionFromViewZ(const in vec2 uv,const in float viewDepth){vec2 uv_=2.*uv-1.;float xe=-(uv_.x+projection[2][0])*viewDepth/projection[0][0];float ye=-(uv_.y+projection[2][1])*viewDepth/projection[1][1];return(inverseViewMatrix*vec4(xe,ye,viewDepth,1.)).xyz;}void main(){
#if HAS_VELOCITY_BUFFER == 0
#if QUALITY == 1
vec3 c_frag=find_closest_fragment_3x3(vUv);
#else
vec3 c_frag=find_closest_fragment_5tap(vUv);
#endif
#else
vec3 c_frag=vec3(vUv,0.);
#endif
bool bg=firstFrame;
#if BACKGROUND_TAA 
float d=c_frag.z;float edgef=min(1.,max(0.,1.-(d*100.-99.)));
#else
bg=bg||c_frag.z>0.999;
#endif
if(firstFrame){gl_FragColor=currentRTTexelToLinear(texture2D(currentRT,vUv));}else{
#if HAS_VELOCITY_BUFFER == 0
float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);vec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);
#else
vec2 screenSpaceVelocity=texture2D(tVelocity,c_frag.xy).xy*2.-1.;screenSpaceVelocity=sign(screenSpaceVelocity)*pow(abs(screenSpaceVelocity),vec2(4.));
#endif
#if BACKGROUND_TAA
gl_FragColor=computeTAA(vUv,screenSpaceVelocity*edgef,edgef);
#else
gl_FragColor=computeTAA(vUv,screenSpaceVelocity,1.);
#endif
}
#include <colorspace_fragment>
#ifdef DEBUG_VELOCITY
float sampleViewZ=mix(-cameraNearFar.x,-cameraNearFar.y,c_frag.z);vec3 worldPosition=getWorldPositionFromViewZ(c_frag.xy,sampleViewZ);vec2 screenSpaceVelocity=computeScreenSpaceVelocity(worldPosition);gl_FragColor=vec4(10.*length(screenSpaceVelocity),0.,0.,1.);
#endif
}`
  , TAAPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class TAAPass extends ShaderPass2 {
    constructor(o, c, h=!1) {
        super({
            vertexShader: CopyShader.vertexShader,
            fragmentShader: c + `
` + cameraHelpers + `
` + taa,
            uniforms: {
                currentRT: {
                    value: null
                },
                previousRT: {
                    value: null
                },
                previousRTSize: {
                    value: new three_module.I9Y
                },
                cameraNearFar: {
                    value: new three_module.I9Y
                },
                lastProjectionViewMatrix: {
                    value: new three_module.kn4
                },
                currentProjectionViewMatrix: {
                    value: new three_module.kn4
                },
                projection: {
                    value: new three_module.kn4
                },
                inverseViewMatrix: {
                    value: new three_module.kn4
                },
                jitterSample: {
                    value: new three_module.I9Y
                },
                firstFrame: {
                    value: !0
                },
                tNormalDepth: {
                    value: null
                },
                tVelocity: {
                    value: null
                }
            },
            defines: {
                HAS_VELOCITY_BUFFER: 0,
                QUALITY: 1,
                UNJITTER: 0,
                BACKGROUND_TAA: h ? 1 : 0
            }
        }, "currentRT", "previousRT"),
        this.taaEnabled = !0,
        this.feedBack = new three_module.I9Y(.88,.97),
        this.uiConfig = {
            type: "folder",
            label: "Temporal AA",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "enabled"],
                onChange: () => this.onSizeUpdate()
            }, {
                type: "input",
                label: "Feedback",
                stepSize: 1e-4,
                property: [this, "feedBack"],
                onChange: this.setDirty
            }]
        },
        this.onSizeUpdate = this.onSizeUpdate.bind(this),
        this.target = o,
        this.clear = !1,
        this.needsSwap = !0
    }
    render(o, c, h, _, b) {
        var _e, nt;
        if (!this.taaEnabled || !this.enabled)
            return void (this.needsSwap = !1);
        this.needsSwap = !0;
        const it = this.uniforms.tVelocity.value ? 1 : 0;
        it !== this.material.defines.HAS_VELOCITY_BUFFER && (this.material.defines.HAS_VELOCITY_BUFFER = it,
        this.material.needsUpdate = !0),
        this.uniforms.previousRT.value = (nt = (_e = Ee$1(this.target)) === null || _e === void 0 ? void 0 : _e.texture) !== null && nt !== void 0 ? nt : null,
        super.render(o, c, h, _, b),
        this.uniforms.lastProjectionViewMatrix.value.copy(this.uniforms.currentProjectionViewMatrix.value),
        this.uniforms.firstFrame.value = !1
    }
    updateCameraProperties(o) {
        o && (this.uniforms.currentProjectionViewMatrix.value.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse),
        this.uniforms.inverseViewMatrix.value.copy(o.matrixWorld))
    }
    onSizeUpdate() {
        this.uniforms.firstFrame.value = !0,
        this.setDirty()
    }
    setSize(o, c) {
        super.setSize(o, c),
        this.onSizeUpdate()
    }
}
TAAPass_decorate([serialize(), uniform()], TAAPass.prototype, "feedBack", void 0);
class TemporalAAPlugin extends GenericFilterPlugin {
    constructor() {
        super(...arguments),
        this.passId = "taa",
        this._beforeFilters = ["progressive"],
        this._afterFilters = [],
        this._requiredFilters = ["render", "progressive"],
        this.dependencies = [GBufferPlugin],
        this._stableNoise = !0,
        this._stableNoiseConfig = {
            label: "Stable Noise (Use Total Frame Count)",
            type: "checkbox",
            property: [this, "stableNoise"]
        }
    }
    passCtor(o) {
        if (!o.getPlugin(ProgressivePlugin))
            throw "Add ProgressivePlugin before TAA";
        const c = o.isAntialiased
          , h = new TAAPass( () => {
            var _;
            return (_ = o.getPlugin(ProgressivePlugin)) === null || _ === void 0 ? void 0 : _.lastFrame
        }
        ,o.getPlugin(GBufferPlugin).getUnpackSnippet(),c);
        return o.renderer.addEventListener("resize", h.onSizeUpdate),
        h
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    async onDispose(o) {
        return this.pass && o.renderer.removeEventListener("resize", this.pass.passObject.onSizeUpdate),
        super.onDispose(o)
    }
    _update(o) {
        if (!super._update(o))
            return !1;
        const c = o.renderer.frameCount
          , h = this._pass.passObject;
        if (h.taaEnabled = c <= 1 && o.scene.renderCamera === o.scene.activeCamera,
        !h.taaEnabled)
            return !1;
        const _ = o.scene.renderCamera;
        return h.updateShaderProperties([o.getPlugin(GBufferPlugin), _, o.getPluginByType("VelocityBuffer")]),
        h.target = o.getPlugin(ProgressivePlugin).lastFrame,
        h.updateCameraProperties(_ == null ? void 0 : _.cameraObject),
        !0
    }
    async onAdded(o) {
        await super.onAdded(o),
        this.stableNoise = this._stableNoise
    }
    get stableNoise() {
        var o, c;
        return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.renderer.stableNoise) !== null && c !== void 0 ? c : this._stableNoise
    }
    set stableNoise(o) {
        this._viewer && (this._viewer.renderer.stableNoise = o),
        this._stableNoise = o
    }
    get uiConfig() {
        var o;
        const c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject.uiConfig;
        if (c && c.children)
            return c.children.includes(this._stableNoiseConfig) || c.children.push(this._stableNoiseConfig),
            c
    }
}
TemporalAAPlugin.PluginType = "TAA";
var FullScreenPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let FullScreenPlugin = class extends AViewerPlugin {
    constructor() {
        super(),
        this.toJSON = void 0,
        this.enabled = !0,
        this._lastSize = ["100%", "100%"],
        this._lastFsElement = null,
        this._fsChangeHandler = d => {
            var o;
            if (this.isFullScreen())
                this.dispatchEvent({
                    type: "enter"
                });
            else {
                const c = this._lastFsElement || ((o = this._viewer) === null || o === void 0 ? void 0 : o.canvas);
                c && (c.style.width = this._lastSize[0],
                c.style.height = this._lastSize[1]),
                document.removeEventListener("webkitfullscreenchange", this._fsChangeHandler, !1),
                document.removeEventListener("mozfullscreenchange", this._fsChangeHandler, !1),
                document.removeEventListener("fullscreenchange", this._fsChangeHandler, !1),
                document.removeEventListener("MSFullscreenChange", this._fsChangeHandler, !1),
                this.dispatchEvent({
                    type: "exit"
                })
            }
        }
        ,
        this.enter = this.enter.bind(this),
        this.exit = this.exit.bind(this)
    }
    async enter(d) {
        var o;
        if (this.isFullScreen())
            return;
        const c = d || ((o = this._viewer) === null || o === void 0 ? void 0 : o.canvas);
        return c ? (this._lastFsElement = c,
        document.addEventListener && (document.addEventListener("webkitfullscreenchange", this._fsChangeHandler, !1),
        document.addEventListener("mozfullscreenchange", this._fsChangeHandler, !1),
        document.addEventListener("fullscreenchange", this._fsChangeHandler, !1),
        document.addEventListener("MSFullscreenChange", this._fsChangeHandler, !1)),
        this._lastSize = [c.style.width, c.style.height],
        c.style.width = "100%",
        c.style.height = "100%",
        c.requestFullscreen ? c.requestFullscreen() : c.mozRequestFullScreen ? c.mozRequestFullScreen() : c.webkitRequestFullscreen ? c.webkitRequestFullscreen() : c.msRequestFullscreen ? c.msRequestFullscreen() : void 0) : void 0
    }
    async exit() {
        return document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : void 0
    }
    async toggle(d) {
        return this.isFullScreen() ? this.exit() : this.enter(d)
    }
    isFullScreen() {
        return document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement !== void 0
    }
}
;
FullScreenPlugin.PluginType = "FullScreenPlugin",
FullScreenPlugin_decorate([uiButton("Enter FullScreen")], FullScreenPlugin.prototype, "enter", null),
FullScreenPlugin_decorate([uiButton("Exit FullScreen")], FullScreenPlugin.prototype, "exit", null),
FullScreenPlugin_decorate([uiButton("Toggle FullScreen")], FullScreenPlugin.prototype, "toggle", null),
FullScreenPlugin = FullScreenPlugin_decorate([uiFolder("Full Screen")], FullScreenPlugin);
const ensureUniqueNames = d => {
    const o = []
      , c = new Set;
    for (const h of d) {
        let _ = h
          , b = 0;
        for (; c.has(_); )
            _ = h + "." + ++b;
        c.add(_),
        o.push(_)
    }
    return o
}
  , mappingsArrayToTable = (d, o) => {
    const c = {};
    for (const h of d.mappings)
        for (const _ of h.variants)
            c[o[_]] = {
                material: null,
                gltfMaterialIndex: h.material
            };
    return c
}
  , compatibleObject = d => d.material !== void 0 && d.userData && d.userData._variantMaterials
  , khrMaterialsVariantsGLTF = "KHR_materials_variants";
class GLTFMaterialsVariantsExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = khrMaterialsVariantsGLTF
    }
    async afterRoot(o) {
        const c = this.parser
          , h = c.json;
        if (!h.extensions || !h.extensions[this.name])
            return;
        const _ = h.extensions[this.name].variants || []
          , b = ensureUniqueNames(_.map(_e => _e.name));
        for (const _e of o.scenes)
            _e.traverse(nt => {
                const it = c.associations.get(nt);
                if (!it || it.meshes === void 0 || it.primitives === void 0)
                    return;
                const at = h.meshes[it.meshes].primitives[it.primitives].extensions;
                at && at[this.name] && (nt.userData._variantMaterials = mappingsArrayToTable(at[this.name], b))
            }
            );
        await Promise.all(o.scenes.map(async _e => {
            const nt = [];
            return _e.traverse(it => compatibleObject(it) && nt.push((async at => {
                const ut = at.material
                  , pt = at.userData._variantMaterials
                  , ht = [];
                for (const _t in pt) {
                    const vt = pt[_t];
                    if (vt.material)
                        continue;
                    const bt = vt.gltfMaterialIndex;
                    ht.push(c.getDependency("material", bt).then(St => {
                        at.material = St,
                        c.assignFinalMaterial(at),
                        pt[_t].material = at.material
                    }
                    ))
                }
                return Promise.all(ht).then( () => {
                    at.material = ut
                }
                )
            }
            )(it))),
            _e.userData.__importData || (_e.userData.__importData = {}),
            _e.userData.__importData[khrMaterialsVariantsGLTF] = {
                names: b
            },
            Promise.all(nt)
        }
        ))
    }
}
const GLTFMaterialsVariantsExtensionExport_compatibleObject = d => d.material !== void 0 && d.userData && d.userData._variantMaterials && !!Object.values(d.userData._variantMaterials).filter(o => compatibleMaterial(o == null ? void 0 : o.material))
  , compatibleMaterial = d => d && d.isMaterial && !Array.isArray(d);
class GLTFExporterMaterialsVariantsExtensionExport {
    constructor(o) {
        this.writer = o,
        this.name = khrMaterialsVariantsGLTF,
        this.variantNames = []
    }
    beforeParse(o) {
        const c = new Set;
        for (const h of o)
            h.traverse(_ => {
                if (!GLTFMaterialsVariantsExtensionExport_compatibleObject(_))
                    return;
                const b = _.userData._variantMaterials;
                for (const _e in b) {
                    const nt = b[_e];
                    compatibleMaterial(nt.material) && c.add(_e)
                }
            }
            );
        c.forEach(h => this.variantNames.push(h))
    }
    writeMesh(o, c) {
        var h;
        if (!GLTFMaterialsVariantsExtensionExport_compatibleObject(o))
            return;
        const _ = o.userData
          , b = _._variantMaterials
          , _e = {};
        for (const at in b) {
            const ut = b[at].material;
            if (!compatibleMaterial(ut))
                continue;
            const pt = this.variantNames.indexOf(at)
              , ht = this.writer.processMaterial(ut);
            _e[ht] || (_e[ht] = {
                material: ht,
                variants: []
            }),
            _e[ht].variants.push(pt)
        }
        const nt = Object.values(_e).map(at => at.variants.sort( (ut, pt) => ut - pt) && at).sort( (at, ut) => at.material - ut.material);
        if (nt.length === 0)
            return;
        const it = compatibleMaterial(_._originalMaterial) && (h = this.writer.processMaterial(_._originalMaterial)) !== null && h !== void 0 ? h : -1;
        for (const at of c.primitives)
            it >= 0 && (at.material = it),
            at.extensions = at.extensions || {},
            at.extensions[this.name] = {
                mappings: nt
            }
    }
    afterParse(o) {
        if (this.variantNames.length === 0)
            return;
        const c = this.writer.json;
        c.extensions = c.extensions || {};
        const h = this.variantNames.map(_ => ({
            name: _
        }));
        c.extensions[this.name] = {
            variants: h
        },
        this.writer.extensionsUsed[this.name] = !0
    }
}
function gltfExporterMaterialsVariantsExtensionExport(d) {
    return new GLTFExporterMaterialsVariantsExtensionExport(d)
}
var GLTFKHRMaterialVariantsPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class GLTFKHRMaterialVariantsPlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.dependencies = [AssetManagerPlugin],
        this.variants = {},
        this.selectedVariant = "",
        this._objectAdded = o => {
            var c, h;
            const _ = o.object;
            (_ == null ? void 0 : _.assetType) === "model" && _.modelObject && this._viewer && (_.modelObject.traverse(b => {
                var _e, nt, it, at, ut;
                if (b.userData._variantMaterials)
                    for (const _t of Object.values(b.userData._variantMaterials))
                        _t != null && _t.material && (_t.material = ((it = (nt = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.getManager()) === null || nt === void 0 ? void 0 : nt.materials) === null || it === void 0 ? void 0 : it.processMaterial(_t.material, {})) || _t.material);
                const pt = (ut = (at = b.userData) === null || at === void 0 ? void 0 : at.__importData) === null || ut === void 0 ? void 0 : ut[khrMaterialsVariantsGLTF];
                if (!pt)
                    return;
                const ht = pt.names || [];
                for (const _t of ht)
                    this.variants[_t] || (this.variants[_t] = []),
                    this.variants[_t].push(b);
                delete b.userData.__importData[khrMaterialsVariantsGLTF]
            }
            ),
            (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c))
        }
        ,
        this.uiConfig = {
            type: "folder",
            label: "KHR Material Variants",
            children: [ () => ({
                children: [null, ...Object.keys(this.variants)].map(o => o ? {
                    label: o
                } : {
                    label: "none",
                    value: ""
                }),
                type: "dropdown",
                label: "Variant",
                property: [this, "selectedVariant"]
            })]
        },
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(o) {
        var c, h, _, b;
        await super.onAdded(o),
        o.scene.addEventListener("addSceneObject", this._objectAdded);
        const _e = o.getPlugin(AssetManagerPlugin);
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(gltfExporterMaterialsVariantsExtensionExport)
    }
    _loaderCreate({loader: o}) {
        o.isGLTFLoader2 && o.register(c => new GLTFMaterialsVariantsExtensionImport(c))
    }
    async onRemove(o) {
        var c, h, _, b, _e, nt;
        o.scene.removeEventListener("addSceneObject", this._objectAdded);
        const it = o.getPlugin(AssetManagerPlugin);
        (c = it.importer) === null || c === void 0 || c.removeEventListener("loaderCreate", this._loaderCreate);
        const at = (b = (_ = (h = it.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 ? void 0 : b.indexOf(gltfExporterMaterialsVariantsExtensionExport);
        return at !== void 0 && at !== -1 && ((nt = (_e = it.exporter.getExporter("gltf", "glb")) === null || _e === void 0 ? void 0 : _e.extensions) === null || nt === void 0 || nt.splice(at, 1)),
        this.variants = {},
        super.onRemove(o)
    }
    _variantChanged() {
        this.applyVariant(this.selectedVariant || "", !0)
    }
    applyVariant(o, c=!1, h, _=!0) {
        if (!c && !h && this.selectedVariant === o || !o)
            return;
        h || (this.selectedVariant = o);
        const b = h ? Array.isArray(h) ? h : [h] : o ? this.variants[o] || [] : Object.values(this.variants).flat();
        for (const _e of b) {
            const nt = new Set
              , it = at => {
                var ut, pt;
                if (!at.userData._variantMaterials || nt.has(at))
                    return;
                const ht = o ? (ut = at.userData._variantMaterials[o]) === null || ut === void 0 ? void 0 : ut.material : at.userData._originalMaterial;
                ht && (at.userData._originalMaterial || (at.userData._originalMaterial = at.material),
                (pt = at == null ? void 0 : at.setMaterial) === null || pt === void 0 || pt.call(at, ht)),
                nt.add(at)
            }
            ;
            _ ? _e.traverse(it) : it(_e)
        }
    }
}
GLTFKHRMaterialVariantsPlugin.PluginType = "GLTFKHRMaterialVariantsPlugin",
GLTFKHRMaterialVariantsPlugin_decorate([x$1(GLTFKHRMaterialVariantsPlugin.prototype._variantChanged)], GLTFKHRMaterialVariantsPlugin.prototype, "selectedVariant", void 0);
var edgeMask = "uniform vec2 screenSize;uniform sampler2D tNormalDepth;uniform sampler2D tNormalBuffer;uniform sampler2D tGBufferFlags;uniform float radius;uniform vec2 cameraNearFar;uniform vec3 cameraPositionWorld;const float depthStep=0.2;const float normalThreshold=0.9;float unpack16(vec2 value){return(value.x*0.996108949416342426275150501169264316558837890625+value.y*0.00389105058365758760263730664519243873655796051025390625);}vec3 unpackNormal(vec2 enc){vec2 fenc=enc*4.-2.;float f=dot(fenc,fenc);float g=sqrt(1.-f/4.);return vec3(fenc*g,1.-f/2.);}void lookupNormalDepth(out float depth,out vec3 normal,vec2 off){vec2 uv=(gl_FragCoord.st+off)/screenSize;vec4 texel=texture2D(tNormalDepth,uv);depth=mix(cameraNearFar.x,cameraNearFar.y,pow(unpack16(texel.xy),2.));normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}float getBorderWeight(){float depth1,depth2,depth3,depth4;vec3 normal1,normal2,normal3,normal4;float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(3./(1.+pow(abs(d_),0.5)),0.,1.);float modRad=radius;lookupNormalDepth(depth1,normal1,vec2(0.,modRad));lookupNormalDepth(depth2,normal2,vec2(0.,-modRad));lookupNormalDepth(depth3,normal3,vec2(modRad,0.));lookupNormalDepth(depth4,normal4,vec2(-modRad,0.));vec2 uv=(gl_FragCoord.st)/screenSize;float mask=step(0.0001,texture2D(tGBufferFlags,uv).g);float mask1=texture2D(tGBufferFlags,uv+vec2(0.,modRad)/screenSize).b*255.;float mask2=texture2D(tGBufferFlags,uv+vec2(0.,-modRad)/screenSize).b*255.;float mask3=texture2D(tGBufferFlags,uv+vec2(modRad,0.)/screenSize).b*255.;float mask4=texture2D(tGBufferFlags,uv+vec2(-modRad,0.)/screenSize).b*255.;float maskWeight=max(abs(mask1-mask2),abs(mask3-mask4))*255.;maskWeight=(step(maskWeight,0.01));float a1=dot(normal1,normal2);float a2=dot(normal3,normal4);float normalWeight=min(abs(a1),abs(a2));normalWeight=1.-step(normalThreshold,normalWeight);float depthWeight=max(abs(depth1-depth2),abs(depth3-depth4));depthWeight=(step(depthWeight,depthStep));return normalWeight*depthWeight*maskWeight*mask;}void main(){float weight=getBorderWeight();vec2 uv=gl_FragCoord.st/screenSize;vec4 texel=texture2D(tNormalDepth,uv);float depth=pow(unpack16(texel.xy),2.);vec3 outColor=vec3(0.);if(depth>0.999){weight=0.;}else{outColor=vec3(weight);}gl_FragColor=vec4(outColor,1.);}"
  , seperableBlurShaderMasked = "varying vec2 vUv;uniform sampler2D colorTexture;uniform sampler2D maskTexture;uniform vec2 texSize;uniform vec2 direction;float gaussianPdf(in float x,in float sigma){return 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;}void main(){vec2 invSize=1./texSize;float fSigma=float(SIGMA);float weightSum=gaussianPdf(0.,fSigma);vec4 mask=texture2D(maskTexture,vUv);vec3 diffuseSum=texture2D(colorTexture,vUv).rgb*weightSum;for(int i=1;i<KERNEL_RADIUS;i++){float x=float(i);float w=gaussianPdf(x,fSigma);vec2 uvOffset=direction*invSize*x;vec3 sample1=texture2D(colorTexture,vUv+uvOffset).rgb;vec3 sample2=texture2D(colorTexture,vUv-uvOffset).rgb;diffuseSum+=(sample1+sample2)*w;weightSum+=2.*w;}gl_FragColor=vec4(diffuseSum/weightSum,1.);}"
  , blurNormal = `uniform sampler2D tNormalBuffer;uniform sampler2D edgeMaskBuffer;uniform vec2 screenSize;uniform float dpr;const float depthStep=0.02;uniform vec2 samples[NUM_SAMPLES];uniform vec3 cameraPositionWorld;varying vec2 vUv;
#include <common>
float getBevelRadius(in float number){return floor(number/8.);}vec3 smoothNormal(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 texel=texture2D(tNormalDepth,uv);vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 avgNormal=2.*texture2D(tNormalBuffer,uv).rgb-1.;float depth=pow(unpack16(texel.xy),2.);vec2 invScreenSize=vec2(1.)/screenSize;vec4 mask=texture2D(tGBufferFlags,uv);float weightSum=0.;float radius=getBevelRadius(mask.g*255.)*2.*dpr;float randomAngle=6.2*random(frameCount*0.1);float theta=randomAngle;float snTheta=sin(theta);float csTheta=cos(theta);mat2 randomRotationMatrix=mat2(csTheta,snTheta,-snTheta,csTheta);float d_=dot(cameraPositionWorld,cameraPositionWorld);float radiusModifier=clamp(1./(1.+pow(abs(d_),0.5)),0.,1.);for(int i=0;i<5;i++){float x=float(i)-2.;for(int j=0;j<5;j++){float y=float(j)-2.;vec2 offset=randomRotationMatrix*vec2(x,y)*radius*radiusModifier*invScreenSize;vec4 texel=texture2D(tNormalDepth,uv+offset);float offsetDepth=pow(unpack16(texel.xy),2.);float depthWeight=abs(offsetDepth-depth);depthWeight=(1.-step(depthStep,depthWeight));vec3 offsetNormal=2.*texture2D(tNormalBuffer,uv+offset).rgb-1.;if(dot(offsetNormal,offsetNormal)>0.){avgNormal+=offsetNormal*depthWeight;}}}return normalize(avgNormal);}void main(){vec2 uv=gl_FragCoord.xy/screenSize;vec4 edgeMask=texture2D(edgeMaskBuffer,uv);vec3 normal=vec3(0.);if(edgeMask.x>0.){normal=smoothNormal();}else{normal=2.*texture2D(tNormalBuffer,uv).rgb-1.;}gl_FragColor=vec4(vec3(0.5*normal+0.5),1.);}`
  , SSBevelPass_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
function addSSBevel(d) {
    const o = d == null ? void 0 : d.userData;
    if (!o)
        return !1;
    o._ssBevel || (o._ssBevel = {});
    const c = o._ssBevel;
    return c.hasSSBevel = !0,
    c.radius === void 0 && (c.radius = 0),
    d.isMaterial && (d.needsUpdate = !0),
    !0
}
let SSBevelPass = class extends ShaderPass2 {
    constructor(d, o, c, h) {
        super({
            defines: {
                NUM_SAMPLES: 16
            },
            uniforms: {
                tNormalDepth: {
                    value: null
                },
                tNormalBuffer: {
                    value: null
                },
                tGBufferFlags: {
                    value: null
                },
                edgeMaskBuffer: {
                    value: null
                },
                screenSize: {
                    value: new three_module.I9Y
                },
                radius: {
                    value: 1
                },
                samples: {
                    value: null
                },
                frameCount: {
                    value: 0
                },
                dpr: {
                    value: 1
                },
                cameraPositionWorld: {
                    value: new three_module.Pq0(1,1,1)
                }
            },
            vertexShader: defaultVertex,
            fragmentShader: `

            ${c}

            ${randomHelpers}

            ${blurNormal}
            
            `
        }, "tDiffuse"),
        this.uiConfig = void 0,
        this.sceneBevel = !1,
        this.sceneBevelRadius = 2,
        this.materialExtension = {
            shaderExtender: (_, b, _e) => {
                var nt, it;
                const at = (it = (nt = b.materialObject.userData) === null || nt === void 0 ? void 0 : nt._ssBevel) === null || it === void 0 ? void 0 : it.hasSSBevel;
                !this.enabled || this.sceneBevel && at === !1 || !this.sceneBevel && !at || (_.fragmentShader = shaderReplaceString(_.fragmentShader, "#include <normal_fragment_maps>", ` 
                normal = 2. * texture2D(tSSBevelMap, viewToScreen(vViewPosition.xyz).xy).rgb - 1.;
                normal = normalize(normal);
            `))
            }
            ,
            onObjectRender: (_, b, _e) => {
                var nt, it;
                const at = (it = (nt = b.materialObject.userData) === null || nt === void 0 ? void 0 : nt._ssBevel) === null || it === void 0 ? void 0 : it.hasSSBevel;
                if (!this.enabled || this.sceneBevel && at === !1 || !this.sceneBevel && !at)
                    return;
                const ut = b.materialObject
                  , pt = this._target.texture;
                this.materialExtension.extraUniforms.tSSBevelMap.value !== pt && (this.materialExtension.extraUniforms.tSSBevelMap.value = pt,
                ut.needsUpdate = !0)
            }
            ,
            getUiConfig: _ => {
                const b = {
                    type: "folder",
                    label: "SSBevel (Dev)",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            var _e;
                            return ((_e = _.materialObject.userData._ssBevel) === null || _e === void 0 ? void 0 : _e.hasSSBevel) || !1
                        },
                        set value(_e) {
                            var nt, it;
                            _e !== ((nt = _.materialObject.userData._ssBevel) === null || nt === void 0 ? void 0 : nt.hasSSBevel) && (_e ? addSSBevel(_.materialObject) || alert("Cannot add screen space bevel.") : _.materialObject.userData._ssBevel && (_.materialObject.userData._ssBevel.hasSSBevel = !1,
                            _.materialObject.needsUpdate = !0),
                            (it = b.uiRefresh) === null || it === void 0 || it.call(b, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, () => ({
                        type: "slider",
                        bounds: [0, 16],
                        label: "radius",
                        hidden: () => {
                            var _e;
                            return !(!((_e = _.materialObject.userData._ssBevel) === null || _e === void 0) && _e.hasSSBevel)
                        }
                        ,
                        property: [_.materialObject.userData._ssBevel, "radius"],
                        onChange: this.setDirty
                    })]
                };
                return b
            }
            ,
            parsFragmentSnippet: (_, b) => {
                var _e, nt;
                const it = (nt = (_e = b == null ? void 0 : b.materialObject.userData) === null || _e === void 0 ? void 0 : _e._ssBevel) === null || nt === void 0 ? void 0 : nt.hasSSBevel;
                return !this.enabled || this.sceneBevel && it === !1 || !this.sceneBevel && !it ? "" : fe$1`
            uniform sampler2D tSSBevelMap;
            ${simpleCameraHelpers}
            `
            }
            ,
            extraUniforms: {
                tSSBevelMap: {
                    value: null
                }
            },
            computeCacheKey: _ => {
                var b, _e;
                return (this.enabled ? "1" : "0") + (this.sceneBevel ? "1" : "0") + (!((_e = (b = _.materialObject.userData) === null || b === void 0 ? void 0 : b._ssBevel) === null || _e === void 0) && _e.hasSSBevel ? "1" : "0")
            }
            ,
            isCompatible: _ => _.isMeshStandardMaterial2
        },
        this._target = o,
        this.needsSwap = !1,
        this.clear = !0,
        this._viewerApp = h,
        this._edgeMaterial = new ShaderMaterial2({
            uniforms: {
                tNormalDepth: {
                    value: null
                },
                tNormalBuffer: {
                    value: null
                },
                tGBufferFlags: {
                    value: null
                },
                screenSize: {
                    value: null
                },
                radius: {
                    value: 10
                },
                cameraNearFar: {
                    value: new three_module.I9Y(1,1)
                },
                cameraPositionWorld: {
                    value: new three_module.Pq0(1,1,1)
                }
            },
            vertexShader: defaultVertex,
            fragmentShader: edgeMask
        }),
        this._separableBlurMaterial = new ShaderMaterial2({
            defines: {
                KERNEL_RADIUS: 3,
                SIGMA: 3
            },
            uniforms: {
                colorTexture: {
                    value: null
                },
                maskTexture: {
                    value: null
                },
                texSize: {
                    value: new three_module.I9Y(.5,.5)
                },
                direction: {
                    value: new three_module.I9Y(.5,.5)
                }
            },
            vertexShader: defaultVertex,
            fragmentShader: seperableBlurShaderMasked
        })
    }
    render(d, o, c, h, _) {
        var b, _e;
        if (!this.enabled)
            return;
        const nt = d.baseRenderer
          , it = {
            minFilter: three_module.k6q,
            magFilter: three_module.k6q,
            isAntialiased: !1,
            format: three_module.GWd,
            depthBuffer: !1,
            generateMipmaps: !1
        }
          , at = nt.getTempTarget(it);
        this._renderEdges(nt, at),
        this._blurEdges(nt, at),
        this._viewerApp.scene.renderCamera.updateShaderProperties(this.material),
        (b = this._viewerApp.getPlugin(GBufferPlugin)) === null || b === void 0 || b.updateShaderProperties(this.material),
        (_e = this._viewerApp.getPlugin(NormalBufferPlugin)) === null || _e === void 0 || _e.updateShaderProperties(this.material),
        this._viewerApp.renderer.updateShaderProperties(this.material),
        this.uniforms.edgeMaskBuffer.value = at.texture,
        this.uniforms.dpr.value = this._viewerApp.renderer.displayCanvasScaling,
        super.render(d, this._target, at, h, _),
        nt.releaseTempTarget(at)
    }
    _initsamples() {
        const d = [];
        return d.push(new three_module.I9Y(-8,0).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-6,-4).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-3,-2).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-2,-6).multiplyScalar(.125)),
        d.push(new three_module.I9Y(1,-1).multiplyScalar(.125)),
        d.push(new three_module.I9Y(2,-5).multiplyScalar(.125)),
        d.push(new three_module.I9Y(6,-7).multiplyScalar(.125)),
        d.push(new three_module.I9Y(5,-3).multiplyScalar(.125)),
        d.push(new three_module.I9Y(4,1).multiplyScalar(.125)),
        d.push(new three_module.I9Y(7,4).multiplyScalar(.125)),
        d.push(new three_module.I9Y(3,5).multiplyScalar(.125)),
        d.push(new three_module.I9Y(0,7).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-1,3).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-4,6).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-7,8).multiplyScalar(.125)),
        d.push(new three_module.I9Y(-5,2).multiplyScalar(.125)),
        d
    }
    _blurEdges(d, o) {
        var c, h;
        const _ = {
            minFilter: three_module.k6q,
            magFilter: three_module.k6q,
            isAntialiased: !1,
            format: three_module.GWd,
            depthBuffer: !1,
            generateMipmaps: !1,
            sizeMultiplier: .5
        }
          , b = d.getTempTarget(_)
          , _e = ((c = o.texture.image) === null || c === void 0 ? void 0 : c.width) || 1
          , nt = ((h = o.texture.image) === null || h === void 0 ? void 0 : h.height) || 1;
        this._separableBlurMaterial.uniforms.texSize.value = new three_module.I9Y(_e,nt),
        this._separableBlurMaterial.uniforms.colorTexture.value = o.texture,
        this._separableBlurMaterial.uniforms.direction.value = new three_module.I9Y(1,0),
        d.blit(void 0, b, {
            material: this._separableBlurMaterial
        }),
        this._separableBlurMaterial.uniforms.texSize.value = new three_module.I9Y(_e / 2,nt / 2),
        this._separableBlurMaterial.uniforms.colorTexture.value = b.texture,
        this._separableBlurMaterial.uniforms.direction.value = new three_module.I9Y(0,1),
        d.blit(void 0, o, {
            material: this._separableBlurMaterial
        }),
        d.releaseTempTarget(b)
    }
    _renderEdges(d, o) {
        var c, h, _, b;
        const _e = ((c = o.texture.image) === null || c === void 0 ? void 0 : c.width) || 1
          , nt = ((h = o.texture.image) === null || h === void 0 ? void 0 : h.height) || 1;
        this._edgeMaterial.uniforms.screenSize.value = new three_module.I9Y(_e,nt),
        this._viewerApp.scene.renderCamera.updateShaderProperties(this._edgeMaterial),
        (_ = this._viewerApp.getPlugin(GBufferPlugin)) === null || _ === void 0 || _.updateShaderProperties(this._edgeMaterial),
        (b = this._viewerApp.getPlugin(NormalBufferPlugin)) === null || b === void 0 || b.updateShaderProperties(this._edgeMaterial),
        d.blit(void 0, o, {
            material: this._edgeMaterial
        })
    }
}
;
SSBevelPass_decorate([uiToggle("Scene Bevel"), serialize(), x$1(SSBevelPass.prototype.setDirty)], SSBevelPass.prototype, "sceneBevel", void 0),
SSBevelPass_decorate([uiSlider("Scene Bevel Radius", [0, 8], .1), serialize(), x$1(SSBevelPass.prototype.setDirty)], SSBevelPass.prototype, "sceneBevelRadius", void 0),
SSBevelPass = SSBevelPass_decorate([uiFolder("SSBevel")], SSBevelPass);
class SSBevelPlugin extends GenericFilterPlugin {
    get bevelTarget() {
        return this._bevelTarget
    }
    constructor(o=!0) {
        super(),
        this.passId = "ssBevel",
        this._beforeFilters = ["render"],
        this._afterFilters = ["gbuffer", "normalBuffer"],
        this._requiredFilters = ["render", "gbuffer", "normalBuffer"],
        this._lastEnabled = !1,
        this.dependencies = [AssetManagerPlugin, GBufferPlugin, NormalBufferPlugin],
        this.enabled = o,
        this.setDirty = this.setDirty.bind(this),
        this._loaderCreate = this._loaderCreate.bind(this),
        this.updateGBuffer = this.updateGBuffer.bind(this)
    }
    _loaderCreate({loader: o}) {
        o.isGLTFLoader2 && o.register(c => new GLTFMaterialsSSBevelExtensionImport(c))
    }
    passCtor(o) {
        var c, h;
        return this._bevelTarget = o.renderer.createTarget({
            depthBuffer: !0,
            type: three_module.ix0,
            minFilter: three_module.hxR,
            magFilter: three_module.hxR,
            generateMipmaps: !1
        }),
        this._bevelTarget.texture.name = "bevelBuffer",
        this._bevelTarget.texture.generateMipmaps = !1,
        o.getPluginByType("debug"),
        new SSBevelPass(o.renderer,this._bevelTarget,(h = (c = o.getPlugin(GBufferPlugin)) === null || c === void 0 ? void 0 : c.getUnpackSnippet()) !== null && h !== void 0 ? h : "",o)
    }
    async onAdded(o) {
        var c, h, _, b, _e, nt, it, at;
        await super.onAdded(o);
        const ut = o.getPlugin(AssetManagerPlugin);
        return !((c = this.pass) === null || c === void 0) && c.passObject.materialExtension && ((h = ut == null ? void 0 : ut.materials) === null || h === void 0 || h.registerMaterialExtension((_ = this.pass) === null || _ === void 0 ? void 0 : _.passObject.materialExtension)),
        (b = ut == null ? void 0 : ut.importer) === null || b === void 0 || b.addEventListener("loaderCreate", this._loaderCreate),
        (it = (nt = (_e = ut == null ? void 0 : ut.exporter) === null || _e === void 0 ? void 0 : _e.getExporter("gltf", "glb")) === null || nt === void 0 ? void 0 : nt.extensions) === null || it === void 0 || it.push(glTFMaterialsSSBevelExtensionExport),
        (at = o.getPlugin(GBufferPlugin)) === null || at === void 0 || at.registerGBufferUpdater(this.updateGBuffer),
        super.onAdded(o)
    }
    async onRemove(o) {
        return o.renderer.disposeTarget(this._bevelTarget),
        super.onRemove(o)
    }
    setDirty() {
        var o, c, h, _;
        (o = this._viewer) === null || o === void 0 || o.setDirty(),
        (_ = (c = this.pass) === null || c === void 0 ? void 0 : (h = c.passObject.materialExtension).setDirty) === null || _ === void 0 || _.call(h)
    }
    _update(o) {
        var c, h;
        let _ = this.enabled;
        if (_ && !this._lastEnabled) {
            const b = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("NormalBufferPlugin");
            b && !b.enabled && (b.enabled = !0),
            b || (h = this._viewer) === null || h === void 0 || h.console.error("SSBevelPlugin needs NormalBufferPlugin")
        }
        return this._lastEnabled = _,
        _
    }
    get uiConfig() {
        var o, c, h, _, b;
        const _e = (h = (c = (o = this.pass) === null || o === void 0 ? void 0 : o.passObject) === null || c === void 0 ? void 0 : c.uiConfig) !== null && h !== void 0 ? h : {};
        return (b = (_ = _e.children) === null || _ === void 0 ? void 0 : _.map(nt => Ee$1(nt))) === null || b === void 0 || b.flat(2).forEach(nt => nt && (nt.onChange = this.setDirty)),
        _e
    }
    updateGBuffer(o, c) {
        var h, _, b, _e;
        if (!((h = this._pass) === null || h === void 0) && h.passObject && o.isMesh && (!((_ = o.material) === null || _ === void 0) && _.userData)) {
            for (let at = 3; at < 8; at++)
                c.y = clearBit(c.y, at);
            const nt = (_e = (b = o.material) === null || b === void 0 ? void 0 : b.userData) === null || _e === void 0 ? void 0 : _e._ssBevel;
            let it = this._pass.passObject.sceneBevel && !(nt != null && nt.hasSSBevel) ? this._pass.passObject.sceneBevelRadius : (nt == null ? void 0 : nt.radius) || 0;
            it = Math.min(it, 31),
            it <<= 3,
            c.y = c.y | it
        }
    }
    getBevelMaterials() {
        var o;
        const c = new Set;
        return (o = this._viewer) === null || o === void 0 || o.scene.modelRoot.traverse(h => {
            var _, b;
            !((b = (_ = h.material) === null || _ === void 0 ? void 0 : _.userData) === null || b === void 0) && b._ssBevel.hasSSBevel && c.add(h.material)
        }
        ),
        Array.from(c)
    }
}
SSBevelPlugin.PluginType = "SSBevelPlugin",
SSBevelPlugin.SSBEVEL_GLTF_EXTENSION = "WEBGI_materials_ssbevel";
class GLTFMaterialsSSBevelExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = SSBevelPlugin.SSBEVEL_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        return c.userData || (c.userData = {}),
        addSSBevel(c),
        c.userData._ssBevel = deserializeObject(_, c.userData._ssBevel, !1, {}),
        Promise.resolve()
    }
}
const glTFMaterialsSSBevelExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._ssBevel || !o.userData._ssBevel.hasSSBevel)
            return;
        c.extensions = c.extensions || {};
        const h = serializeObject(o.userData._ssBevel, !1);
        c.extensions[SSBevelPlugin.SSBEVEL_GLTF_EXTENSION] = h,
        d.extensionsUsed[SSBevelPlugin.SSBEVEL_GLTF_EXTENSION] = !0
    }
});
class GammaCorrectionExtension {
    constructor() {
        this.uiConfig = void 0,
        this.enabled = !0
    }
    shaderExtender(o, c, h) {
        this.enabled && (o.fragmentShader = shaderReplaceString(o.fragmentShader, "#glMarker", ` 
            gl_FragColor = LinearTosRGB(gl_FragColor);
            #glMarker
        `))
    }
    computeCacheKey(o) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(o) {
        return !0
    }
}
class GammaCorrectionPlugin extends GenericExtensionPlugin {
    generateExtension(o) {
        return new GammaCorrectionExtension
    }
}
GammaCorrectionPlugin.PluginType = "GammaCorrection";
var triplanarmapping = "struct TriplanarUV{vec2 x;vec2 y;vec2 z;};uniform float triplanarScale;uniform float triplanarBlend;uniform float triplanarOffset;vec3 getTriplanarWeights(in vec3 position,in vec3 normal){vec3 triW=abs(normal);triW=clamp(triW-vec3(triplanarOffset),vec3(0.),vec3(1.));triW=pow(triW,vec3(triplanarBlend));return triW/(triW.x+triW.y+triW.z);}TriplanarUV getTriplanarUV(in vec3 position,in vec3 normal){TriplanarUV triUV;triUV.x=position.zy*triplanarScale;triUV.y=position.xz*triplanarScale;triUV.z=position.xy*triplanarScale;if(normal.x<0.){triUV.x.x=-triUV.x.x;}if(normal.y<0.){triUV.y.x=-triUV.y.x;}if(normal.z>=0.){triUV.z.x=-triUV.z.x;}return triUV;}vec4 textureTriplanar(in sampler2D tex,in vec3 position,in vec3 normal){TriplanarUV triUV=getTriplanarUV(position,normal);vec4 texX=texture2D(tex,triUV.x);vec4 texY=texture2D(tex,triUV.y);vec4 texZ=texture2D(tex,triUV.z);vec3 triW=getTriplanarWeights(position,normal);return texX*triW.x+texY*triW.y+texZ*triW.z;}"
  , TriplanarUVMappingPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let TriplanarUVMappingPlugin = class extends AViewerPlugin {
    addTriplanarMapping(d) {
        var o;
        const c = (o = d.materialObject) === null || o === void 0 ? void 0 : o.userData;
        return !!c && (c._triplanarMapping || (c._triplanarMapping = {}),
        c._triplanarMapping.enable = !0,
        c._triplanarMapping.scaleFactor === void 0 && (c._triplanarMapping.scaleFactor = 1),
        c._triplanarMapping.blendFactor === void 0 && (c._triplanarMapping.blendFactor = 1),
        c._triplanarMapping.offsetFactor === void 0 && (c._triplanarMapping.offsetFactor = 0),
        d.materialObject.needsUpdate = !0,
        !0)
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsTriplanarMappingExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this._uniforms = {
            triplanarScale: {
                value: 1
            },
            triplanarBlend: {
                value: 1
            },
            triplanarOffset: {
                value: 0
            }
        },
        this.materialExtension = {
            shaderExtender: (d, o, c) => {
                var h, _;
                if (!this.enabled || !(!((_ = (h = o.materialObject.userData) === null || h === void 0 ? void 0 : h._triplanarMapping) === null || _ === void 0) && _.enable))
                    return;
                const b = fe$1`
                #ifndef USE_TRANSMISSION
                    varying vec3 vWorldPosition;
                #endif
                varying vec3 vWorldNormal;
            `;
                d.vertexShader = shaderReplaceString(d.vertexShader, "#include <common>", b, {
                    prepend: !0
                });
                const _e = fe$1`
                // same as worldpos_vertex.glsl.js but added a !
                #if !(defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0)
                vec4 worldPosition = vec4( transformed, 1.0 );
                #ifdef USE_INSTANCING
                worldPosition = instanceMatrix * worldPosition;
                #endif
                worldPosition = modelMatrix * worldPosition;
                #endif
                
                #ifndef USE_TRANSMISSION
                    vWorldPosition = worldPosition.xyz; 
                #endif
                vWorldNormal = normalize((modelMatrix * vec4(objectNormal, 0.)).xyz);
            `;
                d.vertexShader = shaderReplaceString(d.vertexShader, "#include <worldpos_vertex>", _e, {
                    append: !0
                });
                const nt = fe$1`
                ${triplanarmapping}
                #ifndef USE_TRANSMISSION
                    varying vec3 vWorldPosition;
                #endif
                varying vec3 vWorldNormal;
            `;
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <common>", nt, {
                    prepend: !0
                });
                const it = fe$1`

            #ifdef USE_BUMPMAP

            uniform sampler2D bumpMap;
            uniform float bumpScale;

            // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
            // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

            // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

            vec2 dHdxy_fwd() {

                vec3 dSTdx = dFdx( vWorldPosition );
                vec3 dSTdy = dFdy( vWorldPosition );

                vec3 normal_ = normalize(vWorldNormal);
                float Hll = bumpScale * textureTriplanar( bumpMap, vWorldPosition, normal_ ).x;
                float dBx = bumpScale * textureTriplanar( bumpMap, vWorldPosition + dSTdx, normal_ ).x - Hll;
                float dBy = bumpScale * textureTriplanar( bumpMap, vWorldPosition + dSTdy, normal_ ).x - Hll;

                return vec2( dBx, dBy );

            }

            vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

                vec3 vSigmaX = dFdx( surf_pos.xyz );
                vec3 vSigmaY = dFdy( surf_pos.xyz );
                vec3 vN = surf_norm; // normalized

                vec3 R1 = cross( vSigmaY, vN );
                vec3 R2 = cross( vN, vSigmaX );

                float fDet = dot( vSigmaX, R1 ) * faceDirection;

                vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
                return normalize( abs( fDet ) * surf_norm - vGrad );

            }

        #endif
            `;
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <bumpmap_pars_fragment>", it);
                let at = shaderReplaceString(three_module.vxI.map_fragment, "texture2D( map, vMapUv );", "textureTriplanar( map, vWorldPosition, normalize(vWorldNormal) );");
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <map_fragment>", at),
                at = shaderReplaceString(three_module.vxI.roughnessmap_fragment, "texture2D( roughnessMap, vRoughnessMapUv );", "textureTriplanar( roughnessMap, vWorldPosition, normalize(vWorldNormal));"),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <roughnessmap_fragment>", at),
                at = shaderReplaceString(three_module.vxI.metalnessmap_fragment, "texture2D( metalnessMap, vMetalnessMapUv );", "textureTriplanar( metalnessMap, vWorldPosition, normalize(vWorldNormal));"),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <metalnessmap_fragment>", at),
                at = shaderReplaceString(three_module.vxI.normal_fragment_maps, "vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;", "vec3 mapN = textureTriplanar( normalMap, vWorldPosition, normalize(vWorldNormal) ).xyz * 2.0 - 1.0;"),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <normal_fragment_maps>", at),
                d.defines.USE_UV = ""
            }
            ,
            onObjectRender: (d, o) => {
                var c, h, _, b;
                const _e = o.materialObject.userData;
                if (!(!((c = _e == null ? void 0 : _e._triplanarMapping) === null || c === void 0) && c.enable))
                    return;
                const nt = d;
                nt.isMesh && nt.geometry && (this._uniforms.triplanarScale.value = (h = _e._triplanarMapping) === null || h === void 0 ? void 0 : h.scaleFactor,
                this._uniforms.triplanarBlend.value = (_ = _e._triplanarMapping) === null || _ === void 0 ? void 0 : _.blendFactor,
                this._uniforms.triplanarOffset.value = (b = _e._triplanarMapping) === null || b === void 0 ? void 0 : b.offsetFactor)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c;
                return (this.enabled ? "1" : "0") + (!((c = (o = d.materialObject.userData) === null || o === void 0 ? void 0 : o._triplanarMapping) === null || c === void 0) && c.enable ? "1" : "0")
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2,
            updaters: () => {
                var d;
                return [(d = this._viewer) === null || d === void 0 ? void 0 : d.renderer]
            }
            ,
            getUiConfig: d => {
                const o = this._viewer
                  , c = this.addTriplanarMapping
                  , h = {
                    type: "folder",
                    label: "Triplanar",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            var _;
                            return ((_ = d.materialObject.userData._triplanarMapping) === null || _ === void 0 ? void 0 : _.enable) || !1
                        },
                        set value(_) {
                            var b, _e;
                            _ !== ((b = d.materialObject.userData._triplanarMapping) === null || b === void 0 ? void 0 : b.enable) && (_ ? c(d) || o.alert("Cannot add Triplanar mapping.") : d.materialObject.userData._triplanarMapping && (d.materialObject.userData._triplanarMapping.enable = !1,
                            d.materialObject.needsUpdate = !0),
                            (_e = h.uiRefresh) === null || _e === void 0 || _e.call(h, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, () => ({
                        type: "slider",
                        bounds: [.1, 10],
                        label: "Scale",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._triplanarMapping) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._triplanarMapping, "scaleFactor"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [1, 10],
                        label: "Blend",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._triplanarMapping) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._triplanarMapping, "blendFactor"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [0, .5],
                        stepSize: .01,
                        label: "Offset",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._triplanarMapping) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._triplanarMapping, "offsetFactor"],
                        onChange: this.setDirty
                    })]
                };
                return h
            }
        },
        this.setDirty = () => {
            var d, o, c;
            (o = (d = this.materialExtension).setDirty) === null || o === void 0 || o.call(d),
            (c = this._viewer) === null || c === void 0 || c.setDirty()
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsTriplanarMappingExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
TriplanarUVMappingPlugin.PluginType = "TriplanarUVMappingPlugin",
TriplanarUVMappingPlugin.TRIPLANAR_GLTF_EXTENSION = "WEBGI_materials_triplanar",
TriplanarUVMappingPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], TriplanarUVMappingPlugin.prototype, "enabled", void 0),
TriplanarUVMappingPlugin = TriplanarUVMappingPlugin_decorate([uiFolder("Triplanar Mapping")], TriplanarUVMappingPlugin);
class GLTFMaterialsTriplanarMappingExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = TriplanarUVMappingPlugin.TRIPLANAR_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        c.userData || (c.userData = {});
        const b = c.userData;
        return b._triplanarMapping || (b._triplanarMapping = {}),
        b._triplanarMapping.enable = !0,
        b._triplanarMapping.scaleFactor === void 0 && (b._triplanarMapping.scaleFactor = 1),
        b._triplanarMapping.blendFactor === void 0 && (b._triplanarMapping.blendFactor = 1),
        b._triplanarMapping.offsetFactor === void 0 && (b._triplanarMapping.offsetFactor = 0),
        c.userData._triplanarMapping = deserializeObject(_, c.userData._triplanarMapping, !1, {}),
        Promise.resolve()
    }
}
const glTFMaterialsTriplanarMappingExtensionExport = d => ({
    writeMaterial: (o, c) => {
        var h;
        if (!o.isMeshStandardMaterial || !(!((h = o.userData._triplanarMapping) === null || h === void 0) && h.enable))
            return;
        c.extensions = c.extensions || {};
        const _ = serializeObject(o.userData._triplanarMapping, !1);
        c.extensions[TriplanarUVMappingPlugin.TRIPLANAR_GLTF_EXTENSION] = _,
        d.extensionsUsed[TriplanarUVMappingPlugin.TRIPLANAR_GLTF_EXTENSION] = !0
    }
});
var sscurvature = "uniform float cutoff;uniform vec3 cavityColor;uniform float cavityRoughness;uniform float cavityMetalness;uniform float cavityScale;uniform float stepSize;uniform sampler2D cavityMap;float getSSCurvature(in vec3 position,in vec3 normal){vec3 n=normalize(normal);vec3 dx=dFdx(n);vec3 dy=dFdy(n);vec3 xneg=n-stepSize*dx;vec3 xpos=n+stepSize*dx;vec3 yneg=n-stepSize*dy;vec3 ypos=n+stepSize*dy;float depth=length(position);float curvature=(cross(xneg,xpos).y-cross(yneg,ypos).x)*4./depth;return curvature;}"
  , LayeredMaterialPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let LayeredMaterialPlugin = class extends AViewerPlugin {
    addLayeredMaterial(d) {
        var o;
        const c = (o = d.materialObject) === null || o === void 0 ? void 0 : o.userData;
        return !!c && (c._layeredMaterial || (c._layeredMaterial = {}),
        c._layeredMaterial.enable = !0,
        c._layeredMaterial.cutoff === void 0 && (c._layeredMaterial.cutoff = -.65),
        c._layeredMaterial.cavityColor === void 0 && (c._layeredMaterial.cavityColor = new three_module.Q1f(5789527)),
        c._layeredMaterial.cavityRoughness === void 0 && (c._layeredMaterial.cavityRoughness = .5),
        c._layeredMaterial.cavityMetalness === void 0 && (c._layeredMaterial.cavityMetalness = .5),
        c._layeredMaterial.cavityScale === void 0 && (c._layeredMaterial.cavityScale = 1),
        c._layeredMaterial.stepSize === void 0 && (c._layeredMaterial.stepSize = 5),
        d.materialObject.needsUpdate = !0,
        !0)
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFLayeredMaterialsExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this._uniforms = {
            cutoff: {
                value: 0
            },
            cavityColor: {
                value: new three_module.Q1f
            },
            cavityRoughness: {
                value: 0
            },
            cavityMetalness: {
                value: 0
            },
            cavityScale: {
                value: 1
            },
            stepSize: {
                value: 1
            }
        },
        this.materialExtension = {
            shaderExtender: (d, o, c) => {
                var h, _;
                if (!this.enabled || !(!((_ = (h = o.materialObject.userData) === null || h === void 0 ? void 0 : h._layeredMaterial) === null || _ === void 0) && _.enable))
                    return;
                const b = fe$1`
                ${sscurvature}
            `;
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <common>", b, {
                    prepend: !0
                });
                const _e = fe$1`
                material.roughness = min( material.roughness, 1.0 );
                float curvature = getSSCurvature(vViewPosition, normal);
                float smoothCurvature = smoothstep(0., 1., curvature - cutoff);
                material.roughness = min( material.roughness, 1.0 );
                curvature = curvature * cavityScale;
                smoothCurvature = smoothCurvature * cavityScale;
                smoothCurvature = min(smoothCurvature, 1.);
                vec3 finalCavityColor = mix(cavityColor, cavityColor*0.5, vec3(smoothCurvature));
                material.roughness = mix(cavityRoughness, material.roughness, smoothCurvature);
                material.diffuseColor = mix(finalCavityColor, material.diffuseColor, smoothCurvature);
            `
                  , nt = fe$1`
                material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
                material.specularColor = mix(material.specularColor, finalCavityColor, (1. - smoothCurvature) * cavityMetalness);
            `;
                let it = three_module.vxI.lights_physical_fragment.replace("material.roughness = min( material.roughness, 1.0 );", _e);
                it = it.replace("material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );", nt),
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <lights_physical_fragment>", it);
                const at = fe$1`
                vec3 debugCurvatureColor = vec3(0., 0., 1.);
                float _epsilon = 1e-4;
                vec3 green = vec3(0., 0., 0.);
                vec3 red = vec3(1., 1., 1.);
                //if(curvature > cutoff)debugCurvatureColor = green;
                //if(curvature < cutoff)debugCurvatureColor = red;
                // curvature /= 2.;
                // curvature = curvature * 0.5 + 0.5;
                debugCurvatureColor = smoothstep(green, red, vec3(curvature - cutoff));
                //debugCurvatureColor = step(red, vec3(curvature - cutoff));
                //debugCurvatureColor = step(green, vec3(curvature - cutoff));
                //gl_FragColor = vec4(vec3(curvature), 1./16.);
            `;
                d.fragmentShader = shaderReplaceString(d.fragmentShader, "#include <dithering_fragment>", at),
                d.vertexUvs = !0
            }
            ,
            onObjectRender: (d, o) => {
                var c, h, _, b, _e, nt, it;
                const at = o.materialObject.userData;
                if (!(!((c = at == null ? void 0 : at._layeredMaterial) === null || c === void 0) && c.enable))
                    return;
                const ut = d;
                ut.isMesh && ut.geometry && (this._uniforms.cutoff.value = (h = at._layeredMaterial) === null || h === void 0 ? void 0 : h.cutoff,
                this._uniforms.cavityRoughness.value = (_ = at._layeredMaterial) === null || _ === void 0 ? void 0 : _.cavityRoughness,
                this._uniforms.cavityMetalness.value = (b = at._layeredMaterial) === null || b === void 0 ? void 0 : b.cavityMetalness,
                this._uniforms.cavityScale.value = (_e = at._layeredMaterial) === null || _e === void 0 ? void 0 : _e.cavityScale,
                this._uniforms.stepSize.value = (nt = at._layeredMaterial) === null || nt === void 0 ? void 0 : nt.stepSize,
                this._uniforms.cavityColor.value.copy((it = at._layeredMaterial) === null || it === void 0 ? void 0 : it.cavityColor))
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c;
                return (this.enabled ? "1" : "0") + (!((c = (o = d.materialObject.userData) === null || o === void 0 ? void 0 : o._layeredMaterial) === null || c === void 0) && c.enable ? "1" : "0")
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2,
            updaters: () => {
                var d;
                return [(d = this._viewer) === null || d === void 0 ? void 0 : d.renderer]
            }
            ,
            getUiConfig: d => {
                const o = this._viewer
                  , c = this.addLayeredMaterial
                  , h = {
                    type: "folder",
                    label: "LayeredMaterial",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            var _;
                            return ((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0 ? void 0 : _.enable) || !1
                        },
                        set value(_) {
                            var b, _e;
                            _ !== ((b = d.materialObject.userData._layeredMaterial) === null || b === void 0 ? void 0 : b.enable) && (_ ? c(d) || o.alert("Cannot add Triplanar mapping.") : (d.materialObject.userData._layeredMaterial.enable = !1,
                            d.materialObject.needsUpdate = !0),
                            (_e = h.uiRefresh) === null || _e === void 0 || _e.call(h, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, () => ({
                        type: "slider",
                        bounds: [-1, 1],
                        stepSize: .001,
                        label: "cutoff",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._layeredMaterial, "cutoff"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "color",
                        label: "color",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._layeredMaterial, "cavityColor"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [0, 1],
                        stepSize: .01,
                        label: "roughness",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._layeredMaterial, "cavityRoughness"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [.1, 20],
                        stepSize: .01,
                        label: "Scale",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._layeredMaterial, "cavityScale"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [.1, 100],
                        stepSize: .01,
                        label: "StepSize",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._layeredMaterial, "stepSize"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [0, 1],
                        stepSize: .01,
                        label: "metalness",
                        hidden: () => {
                            var _;
                            return !(!((_ = d.materialObject.userData._layeredMaterial) === null || _ === void 0) && _.enable)
                        }
                        ,
                        property: [d.materialObject.userData._layeredMaterial, "cavityMetalness"],
                        onChange: this.setDirty
                    })]
                };
                return h
            }
        },
        this.setDirty = () => {
            var d;
            (d = this._viewer) === null || d === void 0 || d.setDirty()
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFLayeredMaterialsExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
LayeredMaterialPlugin.PluginType = "LayeredMaterialPlugin",
LayeredMaterialPlugin.LAYERED_MATERIAL_GLTF_EXTENSION = "WEBGI_materials_layered",
LayeredMaterialPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], LayeredMaterialPlugin.prototype, "enabled", void 0),
LayeredMaterialPlugin = LayeredMaterialPlugin_decorate([uiFolder("Layered Metal")], LayeredMaterialPlugin);
class GLTFLayeredMaterialsExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = LayeredMaterialPlugin.LAYERED_MATERIAL_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        c.userData || (c.userData = {});
        const b = c.userData;
        return b._layeredMaterial || (b._layeredMaterial = {}),
        b._layeredMaterial.enable = !0,
        c.userData._layeredMaterial = deserializeObject(_, c.userData._layeredMaterial, !1, {}),
        Promise.resolve()
    }
}
const glTFLayeredMaterialsExtensionExport = d => ({
    writeMaterial: (o, c) => {
        var h;
        if (!o.isMeshStandardMaterial || !(!((h = o.userData._layeredMaterial) === null || h === void 0) && h.enable))
            return;
        c.extensions = c.extensions || {};
        const _ = serializeObject(o.userData._layeredMaterial, !1);
        c.extensions[LayeredMaterialPlugin.LAYERED_MATERIAL_GLTF_EXTENSION] = _,
        d.extensionsUsed[LayeredMaterialPlugin.LAYERED_MATERIAL_GLTF_EXTENSION] = !0
    }
});
var ClearcoatTintPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ClearcoatTintPlugin = class extends AViewerPlugin {
    addClearcoatTint(d) {
        return addClearcoatTint(d.materialObject)
    }
    _loaderCreate({loader: d}) {
        d.isGLTFLoader2 && d.register(o => new GLTFMaterialsClearcoatTintExtensionImport(o))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this._defines = {},
        this._uniforms = {
            ccTintColor: {
                value: new three_module.Q1f
            },
            ccThickness: {
                value: 0
            },
            ccIor: {
                value: 0
            }
        },
        this.materialExtension = {
            parsFragmentSnippet: (d, o) => {
                var c;
                return this.enabled && (!((c = o == null ? void 0 : o.materialObject.userData._clearcoatTint) === null || c === void 0) && c.enableTint) && o.materialObject.clearcoat > 0 ? `
uniform vec3 ccTintColor;
uniform float ccThickness;
uniform float ccIor;
vec3 clearcoatTint(const in float dotNV, const in float dotNL, const in float clearcoat) {
    vec3 tint = ( ccThickness > 0. ? 1. - ccTintColor : ccTintColor); // Set thickness < 0 for glow.
    tint = exp(tint * -(ccThickness * ((dotNL + dotNV) / max(dotNL * dotNV, 1e-3)))); // beer's law
    return mix(vec3(1.0), tint, clearcoat);
}
        ` : ""
            }
            ,
            shaderExtender: (d, o, c) => {
                var h;
                if (!(this.enabled && (!((h = o == null ? void 0 : o.materialObject.userData._clearcoatTint) === null || h === void 0) && h.enableTint) && o.materialObject.clearcoat > 0))
                    return;
                const _ = "outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;"
                  , b = "float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );";
                d.fragmentShader.includes(b) && d.fragmentShader.includes(_) || console.error("ClearcoatTintPlugin: shaderExtender cannot patch shader, version changed?"),
                d.fragmentShader = d.fragmentShader.replace(b, `
            float dotNVcc = saturate( dot( geometryClearcoatNormal, -refract(geometryViewDir, geometryClearcoatNormal, 1./ccIor) ) );
            `),
                d.fragmentShader = d.fragmentShader.replace(_, `
            outgoingLight *= clearcoatTint(dotNVcc, dotNVcc, material.clearcoat);
            ` + _),
                d.defines.USE_UV = ""
            }
            ,
            onObjectRender: (d, o) => {
                var c;
                const h = (c = o.materialObject.userData) === null || c === void 0 ? void 0 : c._clearcoatTint;
                if (!(h != null && h.enableTint))
                    return;
                this._uniforms.ccTintColor.value.set(h.tintColor),
                this._uniforms.ccThickness.value = h.thickness,
                this._uniforms.ccIor.value = h.ior;
                const _ = this.enabled ? 1 : 0;
                o.materialObject.defines.CLEARCOAT_TINT_ENABLED !== _ && (o.materialObject.defines.CLEARCOAT_TINT_ENABLED = _,
                o.materialObject.needsUpdate = !0)
            }
            ,
            extraUniforms: {
                ...this._uniforms
            },
            computeCacheKey: d => {
                var o, c;
                return (this.enabled ? "1" : "0") + (!((c = (o = d.materialObject.userData) === null || o === void 0 ? void 0 : o._clearcoatTint) === null || c === void 0) && c.enableTint ? "1" : "0") + (d.materialObject.clearcoat > 0 ? "1" : "0")
            }
            ,
            isCompatible: d => d.isMeshStandardMaterial2,
            updaters: () => [],
            getUiConfig: d => {
                const o = this._viewer
                  , c = {
                    type: "folder",
                    label: "ClearcoatTint",
                    children: [{
                        type: "checkbox",
                        label: "Enabled",
                        get value() {
                            var h;
                            return ((h = d.materialObject.userData._clearcoatTint) === null || h === void 0 ? void 0 : h.enableTint) || !1
                        },
                        set value(h) {
                            var _, b;
                            h !== ((_ = d.materialObject.userData._clearcoatTint) === null || _ === void 0 ? void 0 : _.enableTint) && (h ? addClearcoatTint(d.materialObject) || o.alert("Cannot add clearcoat tint.") : d.materialObject.userData._clearcoatTint && (d.materialObject.userData._clearcoatTint.enableTint = !1,
                            d.materialObject.needsUpdate = !0),
                            (b = c.uiRefresh) === null || b === void 0 || b.call(c, "postFrame", !0))
                        },
                        onChange: this.setDirty
                    }, () => ({
                        type: "color",
                        label: "Tint color",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._clearcoatTint) === null || h === void 0) && h.enableTint)
                        }
                        ,
                        property: [d.materialObject.userData._clearcoatTint, "tintColor"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "input",
                        label: "Thickness",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._clearcoatTint) === null || h === void 0) && h.enableTint)
                        }
                        ,
                        property: [d.materialObject.userData._clearcoatTint, "thickness"],
                        onChange: this.setDirty
                    }), () => ({
                        type: "slider",
                        bounds: [.8, 2.5],
                        label: "IOR",
                        hidden: () => {
                            var h;
                            return !(!((h = d.materialObject.userData._clearcoatTint) === null || h === void 0) && h.enableTint)
                        }
                        ,
                        property: [d.materialObject.userData._clearcoatTint, "ior"],
                        onChange: this.setDirty
                    })]
                };
                return c
            }
        },
        this.setDirty = () => {
            var d, o, c;
            (o = (d = this.materialExtension).setDirty) === null || o === void 0 || o.call(d),
            (c = this._viewer) === null || c === void 0 || c.setDirty()
        }
        ,
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b;
        await super.onAdded(d);
        const _e = d.getPlugin(AssetManagerPlugin);
        (o = _e == null ? void 0 : _e.materials) === null || o === void 0 || o.registerMaterialExtension(this.materialExtension),
        (c = _e == null ? void 0 : _e.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate),
        (b = (_ = (h = _e == null ? void 0 : _e.exporter) === null || h === void 0 ? void 0 : h.getExporter("gltf", "glb")) === null || _ === void 0 ? void 0 : _.extensions) === null || b === void 0 || b.push(glTFMaterialsClearcoatTintExtensionExport)
    }
    async onRemove(d) {
        var o, c, h, _;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this.materialExtension),
        (_ = (h = d.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.importer) === null || _ === void 0 || _.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(d)
    }
}
;
function addClearcoatTint(d) {
    const o = d == null ? void 0 : d.userData;
    if (!o)
        return !1;
    o._clearcoatTint || (o._clearcoatTint = {});
    const c = o._clearcoatTint;
    return c.enableTint = !0,
    c.tintColor === void 0 && (c.tintColor = 16777215),
    c.thickness === void 0 && (c.thickness = .1),
    c.ior === void 0 && (c.ior = 1.5),
    d.isMaterial && (d.needsUpdate = !0),
    !0
}
ClearcoatTintPlugin.PluginType = "ClearcoatTintPlugin",
ClearcoatTintPlugin.CLEARCOAT_TINT_GLTF_EXTENSION = "WEBGI_materials_clearcoat_tint",
ClearcoatTintPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: d.setDirty
})), serialize()], ClearcoatTintPlugin.prototype, "enabled", void 0),
ClearcoatTintPlugin = ClearcoatTintPlugin_decorate([uiFolder("ClearcoatTint Materials")], ClearcoatTintPlugin);
class GLTFMaterialsClearcoatTintExtensionImport {
    constructor(o) {
        this.parser = o,
        this.name = ClearcoatTintPlugin.CLEARCOAT_TINT_GLTF_EXTENSION
    }
    async extendMaterialParams(o, c) {
        const h = this.parser.json.materials[o];
        if (!h.extensions || !h.extensions[this.name])
            return Promise.resolve();
        const _ = h.extensions[this.name];
        return c.userData || (c.userData = {}),
        addClearcoatTint(c),
        deserializeObject(_, c.userData._clearcoatTint, !1, {}),
        Promise.resolve()
    }
}
const glTFMaterialsClearcoatTintExtensionExport = d => ({
    writeMaterial: (o, c) => {
        if (!o.isMeshStandardMaterial || !o.userData._clearcoatTint || !o.userData._clearcoatTint.enableTint)
            return;
        c.extensions = c.extensions || {};
        const h = serializeObject(o.userData._clearcoatTint, !1);
        c.extensions[ClearcoatTintPlugin.CLEARCOAT_TINT_GLTF_EXTENSION] = h,
        d.extensionsUsed[ClearcoatTintPlugin.CLEARCOAT_TINT_GLTF_EXTENSION] = !0
    }
});
class WorkerPool {
    constructor(o=4) {
        this.pool = o,
        this.queue = [],
        this.workers = [],
        this.workersResolve = [],
        this.workerStatus = 0
    }
    _initWorker(o) {
        if (!this.workers[o]) {
            const c = this.workerCreator();
            c.addEventListener("message", this._onMessage.bind(this, o)),
            this.workers[o] = c
        }
    }
    _getIdleWorker() {
        for (let o = 0; o < this.pool; o++)
            if (!(this.workerStatus & 1 << o))
                return o;
        return -1
    }
    _onMessage(o, c) {
        const h = this.workersResolve[o];
        if (h && h(c),
        this.queue.length) {
            const {resolve: _, msg: b, transfer: _e} = this.queue.shift();
            this.workersResolve[o] = _,
            this.workers[o].postMessage(b, _e)
        } else
            this.workerStatus ^= 1 << o
    }
    setWorkerCreator(o) {
        this.workerCreator = o
    }
    setWorkerLimit(o) {
        this.pool = o
    }
    postMessage(o, c) {
        return new Promise(h => {
            const _ = this._getIdleWorker();
            _ !== -1 ? (this._initWorker(_),
            this.workerStatus |= 1 << _,
            this.workersResolve[_] = h,
            this.workers[_].postMessage(o, c)) : this.queue.push({
                resolve: h,
                msg: o,
                transfer: c
            })
        }
        )
    }
    dispose() {
        this.workers.forEach(o => o.terminate()),
        this.workersResolve.length = 0,
        this.workers.length = 0,
        this.queue.length = 0,
        this.workerStatus = 0
    }
}
const ktx_parse_module_t = 0
  , n$2 = 2
  , ktx_parse_module_p = 1
  , ktx_parse_module_x = 2
  , ktx_parse_module_E = 0
  , ktx_parse_module_F = 1
  , ktx_parse_module_X = 10
  , ktx_parse_module_nt = 0
  , ktx_parse_module_ct = 9
  , gt = 15
  , yt = 16
  , dt = 22
  , Ot = 37
  , Ft = 43
  , $t = 76
  , ktx_parse_module_se = 83
  , ktx_parse_module_pe = 97
  , ktx_parse_module_xe = 100
  , ktx_parse_module_de = 103
  , ktx_parse_module_Ae = 109
  , Sn = 165
  , In = 166;
let Si$1 = class {
    constructor() {
        this.vkFormat = 0,
        this.typeSize = 1,
        this.pixelWidth = 0,
        this.pixelHeight = 0,
        this.pixelDepth = 0,
        this.layerCount = 0,
        this.faceCount = 1,
        this.supercompressionScheme = 0,
        this.levels = [],
        this.dataFormatDescriptor = [{
            vendorId: 0,
            descriptorType: 0,
            descriptorBlockSize: 0,
            versionNumber: 2,
            colorModel: 0,
            colorPrimaries: 1,
            transferFunction: 2,
            flags: 0,
            texelBlockDimension: [0, 0, 0, 0],
            bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
            samples: []
        }],
        this.keyValue = {},
        this.globalData = null
    }
}
  , Ii$1 = class {
    constructor(o, c, h, _) {
        this._dataView = new DataView(o.buffer,o.byteOffset + c,h),
        this._littleEndian = _,
        this._offset = 0
    }
    _nextUint8() {
        const o = this._dataView.getUint8(this._offset);
        return this._offset += 1,
        o
    }
    _nextUint16() {
        const o = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2,
        o
    }
    _nextUint32() {
        const o = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4,
        o
    }
    _nextUint64() {
        const o = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8,
        o
    }
    _nextInt32() {
        const o = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4,
        o
    }
    _skip(o) {
        return this._offset += o,
        this
    }
    _scan(o, c=0) {
        const h = this._offset;
        let _ = 0;
        for (; this._dataView.getUint8(this._offset) !== c && _ < o; )
            _++,
            this._offset++;
        return _ < o && this._offset++,
        new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + h,_)
    }
}
;
const Ti$1 = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function Ei$1(d) {
    return typeof TextDecoder < "u" ? new TextDecoder().decode(d) : Buffer.from(d).toString("utf8")
}
function Pi$1(d) {
    const o = new Uint8Array(d.buffer,d.byteOffset,Ti$1.length);
    if (o[0] !== Ti$1[0] || o[1] !== Ti$1[1] || o[2] !== Ti$1[2] || o[3] !== Ti$1[3] || o[4] !== Ti$1[4] || o[5] !== Ti$1[5] || o[6] !== Ti$1[6] || o[7] !== Ti$1[7] || o[8] !== Ti$1[8] || o[9] !== Ti$1[9] || o[10] !== Ti$1[10] || o[11] !== Ti$1[11])
        throw new Error("Missing KTX 2.0 identifier.");
    const c = new Si$1
      , h = 17 * Uint32Array.BYTES_PER_ELEMENT
      , _ = new Ii$1(d,Ti$1.length,h,!0);
    c.vkFormat = _._nextUint32(),
    c.typeSize = _._nextUint32(),
    c.pixelWidth = _._nextUint32(),
    c.pixelHeight = _._nextUint32(),
    c.pixelDepth = _._nextUint32(),
    c.layerCount = _._nextUint32(),
    c.faceCount = _._nextUint32();
    const b = _._nextUint32();
    c.supercompressionScheme = _._nextUint32();
    const _e = _._nextUint32()
      , nt = _._nextUint32()
      , it = _._nextUint32()
      , at = _._nextUint32()
      , ut = _._nextUint64()
      , pt = _._nextUint64()
      , ht = new Ii$1(d,Ti$1.length + h,3 * b * 8,!0);
    for (let hr = 0; hr < b; hr++)
        c.levels.push({
            levelData: new Uint8Array(d.buffer,d.byteOffset + ht._nextUint64(),ht._nextUint64()),
            uncompressedByteLength: ht._nextUint64()
        });
    const _t = new Ii$1(d,_e,nt,!0)
      , vt = {
        vendorId: _t._skip(4)._nextUint16(),
        descriptorType: _t._nextUint16(),
        versionNumber: _t._nextUint16(),
        descriptorBlockSize: _t._nextUint16(),
        colorModel: _t._nextUint8(),
        colorPrimaries: _t._nextUint8(),
        transferFunction: _t._nextUint8(),
        flags: _t._nextUint8(),
        texelBlockDimension: [_t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8()],
        bytesPlane: [_t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8()],
        samples: []
    }
      , bt = (vt.descriptorBlockSize / 4 - 6) / 4;
    for (let hr = 0; hr < bt; hr++) {
        const gr = {
            bitOffset: _t._nextUint16(),
            bitLength: _t._nextUint8(),
            channelType: _t._nextUint8(),
            samplePosition: [_t._nextUint8(), _t._nextUint8(), _t._nextUint8(), _t._nextUint8()],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
        };
        64 & gr.channelType ? (gr.sampleLower = _t._nextInt32(),
        gr.sampleUpper = _t._nextInt32()) : (gr.sampleLower = _t._nextUint32(),
        gr.sampleUpper = _t._nextUint32()),
        vt.samples[hr] = gr
    }
    c.dataFormatDescriptor.length = 0,
    c.dataFormatDescriptor.push(vt);
    const St = new Ii$1(d,it,at,!0);
    for (; St._offset < at; ) {
        const hr = St._nextUint32()
          , gr = St._scan(hr)
          , dr = Ei$1(gr)
          , cr = St._scan(hr - gr.byteLength);
        c.keyValue[dr] = dr.match(/^ktx/i) ? Ei$1(cr) : cr,
        St._offset % 4 && St._skip(4 - St._offset % 4)
    }
    if (pt <= 0)
        return c;
    const At = new Ii$1(d,ut,pt,!0)
      , Et = At._nextUint16()
      , Pt = At._nextUint16()
      , It = At._nextUint32()
      , Dt = At._nextUint32()
      , Gt = At._nextUint32()
      , Bt = At._nextUint32()
      , kt = [];
    for (let hr = 0; hr < b; hr++)
        kt.push({
            imageFlags: At._nextUint32(),
            rgbSliceByteOffset: At._nextUint32(),
            rgbSliceByteLength: At._nextUint32(),
            alphaSliceByteOffset: At._nextUint32(),
            alphaSliceByteLength: At._nextUint32()
        });
    const Ut = ut + At._offset
      , Ht = Ut + It
      , Kt = Ht + Dt
      , Jt = Kt + Gt
      , or = new Uint8Array(d.buffer,d.byteOffset + Ut,It)
      , ir = new Uint8Array(d.buffer,d.byteOffset + Ht,Dt)
      , lr = new Uint8Array(d.buffer,d.byteOffset + Kt,Gt)
      , ar = new Uint8Array(d.buffer,d.byteOffset + Jt,Bt);
    return c.globalData = {
        endpointCount: Et,
        selectorCount: Pt,
        imageDescs: kt,
        endpointsData: or,
        selectorsData: ir,
        tablesData: lr,
        extendedData: ar
    },
    c
}
let zstddec_module_A, zstddec_module_I, zstddec_module_B;
const zstddec_module_g = {
    env: {
        emscripten_notify_memory_growth: function(d) {
            zstddec_module_B = new Uint8Array(zstddec_module_I.exports.memory.buffer)
        }
    }
};
class zstddec_module_Q {
    init() {
        return zstddec_module_A || (zstddec_module_A = typeof fetch < "u" ? fetch("data:application/wasm;base64," + zstddec_module_C).then(o => o.arrayBuffer()).then(o => WebAssembly.instantiate(o, zstddec_module_g)).then(this._init) : WebAssembly.instantiate(Buffer.from(zstddec_module_C, "base64"), zstddec_module_g).then(this._init),
        zstddec_module_A)
    }
    _init(o) {
        zstddec_module_I = o.instance,
        zstddec_module_g.env.emscripten_notify_memory_growth(0)
    }
    decode(o, c=0) {
        if (!zstddec_module_I)
            throw new Error("ZSTDDecoder: Await .init() before decoding.");
        const h = o.byteLength
          , _ = zstddec_module_I.exports.malloc(h);
        zstddec_module_B.set(o, _),
        c = c || Number(zstddec_module_I.exports.ZSTD_findDecompressedSize(_, h));
        const b = zstddec_module_I.exports.malloc(c)
          , _e = zstddec_module_I.exports.ZSTD_decompress(b, c, _, h)
          , nt = zstddec_module_B.slice(b, b + _e);
        return zstddec_module_I.exports.free(_),
        zstddec_module_I.exports.free(b),
        nt
    }
}
const zstddec_module_C = "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ"
  , _taskCache = new WeakMap;
let _activeLoaders = 0, _zstd;
class KTX2Loader extends three_module.aHM {
    constructor(o) {
        super(o),
        this.transcoderPath = "",
        this.transcoderBinary = null,
        this.transcoderPending = null,
        this.workerPool = new WorkerPool,
        this.workerSourceURL = "",
        this.workerConfig = null,
        typeof MSC_TRANSCODER < "u" && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
    }
    setTranscoderPath(o) {
        return this.transcoderPath = o,
        this
    }
    setWorkerLimit(o) {
        return this.workerPool.setWorkerLimit(o),
        this
    }
    detectSupport(o) {
        return o.isWebGPURenderer === !0 ? this.workerConfig = {
            astcSupported: o.hasFeature("texture-compression-astc"),
            etc1Supported: !1,
            etc2Supported: o.hasFeature("texture-compression-etc2"),
            dxtSupported: o.hasFeature("texture-compression-bc"),
            bptcSupported: !1,
            pvrtcSupported: !1
        } : (this.workerConfig = {
            astcSupported: o.extensions.has("WEBGL_compressed_texture_astc"),
            etc1Supported: o.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: o.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: o.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: o.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported: o.extensions.has("WEBGL_compressed_texture_pvrtc") || o.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
        },
        o.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)),
        this
    }
    init() {
        if (!this.transcoderPending) {
            const o = new three_module.Y9S(this.manager);
            o.setPath(this.transcoderPath),
            o.setWithCredentials(this.withCredentials);
            const c = o.loadAsync("basis_transcoder.js")
              , h = new three_module.Y9S(this.manager);
            h.setPath(this.transcoderPath),
            h.setResponseType("arraybuffer"),
            h.setWithCredentials(this.withCredentials);
            const _ = h.loadAsync("basis_transcoder.wasm");
            this.transcoderPending = Promise.all([c, _]).then( ([b,_e]) => {
                const nt = KTX2Loader.BasisWorker
                  , it = ["/* constants */", "let _EngineFormat = " + JSON.stringify(KTX2Loader.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(KTX2Loader.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(KTX2Loader.BasisFormat), "/* basis_transcoder.js */", b, "/* worker */", nt.substring(nt.indexOf("{") + 1, nt.lastIndexOf("}"))].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([it])),
                this.transcoderBinary = _e,
                this.workerPool.setWorkerCreator( () => {
                    const at = new Worker(this.workerSourceURL)
                      , ut = this.transcoderBinary.slice(0);
                    return at.postMessage({
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: ut
                    }, [ut]),
                    at
                }
                )
            }
            ),
            _activeLoaders > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."),
            _activeLoaders++
        }
        return this.transcoderPending
    }
    load(o, c, h, _) {
        if (this.workerConfig === null)
            throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
        const b = new three_module.Y9S(this.manager);
        b.setResponseType("arraybuffer"),
        b.setCrossOrigin(this.crossOrigin),
        b.setWithCredentials(this.withCredentials),
        b.load(o, _e => {
            if (_taskCache.has(_e))
                return _taskCache.get(_e).promise.then(c).catch(_);
            this.createTexture(_e).then(nt => c ? c(nt) : null).catch(_)
        }
        , h, _)
    }
    _createTextureFrom(o, c) {
        const {faces: h, width: _, height: b, format: _e, type: nt, error: it, dfdFlags: at} = o;
        if (nt === "error")
            return Promise.reject(it);
        let ut;
        if (c.faceCount === 6)
            ut = new three_module.c5h(h,_e,three_module.OUM);
        else {
            const pt = h[0].mipmaps;
            ut = c.layerCount > 1 ? new three_module.iOZ(pt,_,b,c.layerCount,_e,three_module.OUM) : new three_module.FvD(pt,_,b,_e,three_module.OUM)
        }
        return ut.minFilter = h[0].mipmaps.length === 1 ? three_module.k6q : three_module.$_I,
        ut.magFilter = three_module.k6q,
        ut.generateMipmaps = !1,
        ut.needsUpdate = !0,
        ut.colorSpace = parseColorSpace(c),
        ut.premultiplyAlpha = !!(at & ktx_parse_module_p),
        ut
    }
    async createTexture(o, c={}) {
        const h = Pi$1(new Uint8Array(o));
        if (h.vkFormat !== ktx_parse_module_nt)
            return createRawTexture(h);
        const _ = c
          , b = this.init().then( () => this.workerPool.postMessage({
            type: "transcode",
            buffer: o,
            taskConfig: _
        }, [o])).then(_e => this._createTextureFrom(_e.data, h));
        return _taskCache.set(o, {
            promise: b
        }),
        b
    }
    dispose() {
        return this.workerPool.dispose(),
        this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
        _activeLoaders--,
        this
    }
}
KTX2Loader.BasisFormat = {
    ETC1S: 0,
    UASTC_4x4: 1
},
KTX2Loader.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16
},
KTX2Loader.EngineFormat = {
    RGBAFormat: three_module.GWd,
    RGBA_ASTC_4x4_Format: three_module.qa3,
    RGBA_BPTC_Format: three_module.Fn,
    RGBA_ETC2_EAC_Format: three_module.KDk,
    RGBA_PVRTC_4BPPV1_Format: three_module.HXV,
    RGBA_S3TC_DXT5_Format: three_module.BXX,
    RGB_ETC1_Format: three_module.CVz,
    RGB_ETC2_Format: three_module.Riy,
    RGB_PVRTC_4BPPV1_Format: three_module.k6Q,
    RGB_S3TC_DXT1_Format: three_module.IE4
},
KTX2Loader.BasisWorker = `function () {

	let config;
	let transcoderPending;
	let BasisModule;

	const EngineFormat = _EngineFormat; // eslint-disable-line no-undef
	const TranscoderFormat = _TranscoderFormat; // eslint-disable-line no-undef
	const BasisFormat = _BasisFormat; // eslint-disable-line no-undef

	self.addEventListener( 'message', function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				config = message.config;
				init( message.transcoderBinary );
				break;

			case 'transcode':
				transcoderPending.then( () => {

					try {

						const { faces, buffers, width, height, hasAlpha, format, dfdFlags } = transcode( message.buffer );

						self.postMessage( { type: 'transcode', id: message.id, faces, width, height, hasAlpha, format, dfdFlags }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					}

				} );
				break;

		}

	} );

	function init( wasmBinary ) {

		transcoderPending = new Promise( ( resolve ) => {

			BasisModule = { wasmBinary, onRuntimeInitialized: resolve };
			BASIS( BasisModule ); // eslint-disable-line no-undef

		} ).then( () => {

			BasisModule.initializeBasis();

			if ( BasisModule.KTX2File === undefined ) {

				console.warn( 'THREE.KTX2Loader: Please update Basis Universal transcoder.' );

			}

		} );

	}

	function transcode( buffer ) {

		const ktx2File = new BasisModule.KTX2File( new Uint8Array( buffer ) );

		function cleanup() {

			ktx2File.close();
			ktx2File.delete();

		}

		if ( ! ktx2File.isValid() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid or unsupported .ktx2 file' );

		}

		const basisFormat = ktx2File.isUASTC() ? BasisFormat.UASTC_4x4 : BasisFormat.ETC1S;
		const width = ktx2File.getWidth();
		const height = ktx2File.getHeight();
		const layerCount = ktx2File.getLayers() || 1;
		const levelCount = ktx2File.getLevels();
		const faceCount = ktx2File.getFaces();
		const hasAlpha = ktx2File.getHasAlpha();
		const dfdFlags = ktx2File.getDFDFlags();

		const { transcoderFormat, engineFormat } = getTranscoderFormat( basisFormat, width, height, hasAlpha );

		if ( ! width || ! height || ! levelCount ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader:	Invalid texture' );

		}

		if ( ! ktx2File.startTranscoding() ) {

			cleanup();
			throw new Error( 'THREE.KTX2Loader: .startTranscoding failed' );

		}

		const faces = [];
		const buffers = [];

		for ( let face = 0; face < faceCount; face ++ ) {

			const mipmaps = [];

			for ( let mip = 0; mip < levelCount; mip ++ ) {

				const layerMips = [];

				let mipWidth, mipHeight;

				for ( let layer = 0; layer < layerCount; layer ++ ) {

					const levelInfo = ktx2File.getImageLevelInfo( mip, layer, face );

					if ( face === 0 && mip === 0 && layer === 0 && ( levelInfo.origWidth % 4 !== 0 || levelInfo.origHeight % 4 !== 0 ) ) {

						console.warn( 'THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions.' );

					}

					if ( levelCount > 1 ) {

						mipWidth = levelInfo.origWidth;
						mipHeight = levelInfo.origHeight;

					} else {

						// Handles non-multiple-of-four dimensions in textures without mipmaps. Textures with
						// mipmaps must use multiple-of-four dimensions, for some texture formats and APIs.
						// See mrdoob/three.js#25908.
						mipWidth = levelInfo.width;
						mipHeight = levelInfo.height;

					}

					const dst = new Uint8Array( ktx2File.getImageTranscodedSizeInBytes( mip, layer, 0, transcoderFormat ) );
					const status = ktx2File.transcodeImage( dst, mip, layer, face, transcoderFormat, 0, - 1, - 1 );

					if ( ! status ) {

						cleanup();
						throw new Error( 'THREE.KTX2Loader: .transcodeImage failed.' );

					}

					layerMips.push( dst );

				}

				const mipData = concat( layerMips );

				mipmaps.push( { data: mipData, width: mipWidth, height: mipHeight } );
				buffers.push( mipData.buffer );

			}

			faces.push( { mipmaps, width, height, format: engineFormat } );

		}

		cleanup();

		return { faces, buffers, width, height, hasAlpha, format: engineFormat, dfdFlags };

	}

	//

	// Optimal choice of a transcoder target format depends on the Basis format (ETC1S or UASTC),
	// device capabilities, and texture dimensions. The list below ranks the formats separately
	// for ETC1S and UASTC.
	//
	// In some cases, transcoding UASTC to RGBA32 might be preferred for higher quality (at
	// significant memory cost) compared to ETC1/2, BC1/3, and PVRTC. The transcoder currently
	// chooses RGBA32 only as a last resort and does not expose that option to the caller.
	const FORMAT_OPTIONS = [
		{
			if: 'astcSupported',
			basisFormat: [ BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.ASTC_4x4, TranscoderFormat.ASTC_4x4 ],
			engineFormat: [ EngineFormat.RGBA_ASTC_4x4_Format, EngineFormat.RGBA_ASTC_4x4_Format ],
			priorityETC1S: Infinity,
			priorityUASTC: 1,
			needsPowerOfTwo: false,
		},
		{
			if: 'bptcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.BC7_M5, TranscoderFormat.BC7_M5 ],
			engineFormat: [ EngineFormat.RGBA_BPTC_Format, EngineFormat.RGBA_BPTC_Format ],
			priorityETC1S: 3,
			priorityUASTC: 2,
			needsPowerOfTwo: false,
		},
		{
			if: 'dxtSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.BC1, TranscoderFormat.BC3 ],
			engineFormat: [ EngineFormat.RGB_S3TC_DXT1_Format, EngineFormat.RGBA_S3TC_DXT5_Format ],
			priorityETC1S: 4,
			priorityUASTC: 5,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc2Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.ETC1, TranscoderFormat.ETC2 ],
			engineFormat: [ EngineFormat.RGB_ETC2_Format, EngineFormat.RGBA_ETC2_EAC_Format ],
			priorityETC1S: 1,
			priorityUASTC: 3,
			needsPowerOfTwo: false,
		},
		{
			if: 'etc1Supported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.ETC1 ],
			engineFormat: [ EngineFormat.RGB_ETC1_Format ],
			priorityETC1S: 2,
			priorityUASTC: 4,
			needsPowerOfTwo: false,
		},
		{
			if: 'pvrtcSupported',
			basisFormat: [ BasisFormat.ETC1S, BasisFormat.UASTC_4x4 ],
			transcoderFormat: [ TranscoderFormat.PVRTC1_4_RGB, TranscoderFormat.PVRTC1_4_RGBA ],
			engineFormat: [ EngineFormat.RGB_PVRTC_4BPPV1_Format, EngineFormat.RGBA_PVRTC_4BPPV1_Format ],
			priorityETC1S: 5,
			priorityUASTC: 6,
			needsPowerOfTwo: true,
		},
	];

	const ETC1S_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {

		return a.priorityETC1S - b.priorityETC1S;

	} );
	const UASTC_OPTIONS = FORMAT_OPTIONS.sort( function ( a, b ) {

		return a.priorityUASTC - b.priorityUASTC;

	} );

	function getTranscoderFormat( basisFormat, width, height, hasAlpha ) {

		let transcoderFormat;
		let engineFormat;

		const options = basisFormat === BasisFormat.ETC1S ? ETC1S_OPTIONS : UASTC_OPTIONS;

		for ( let i = 0; i < options.length; i ++ ) {

			const opt = options[ i ];

			if ( ! config[ opt.if ] ) continue;
			if ( ! opt.basisFormat.includes( basisFormat ) ) continue;
			if ( hasAlpha && opt.transcoderFormat.length < 2 ) continue;
			if ( opt.needsPowerOfTwo && ! ( isPowerOfTwo( width ) && isPowerOfTwo( height ) ) ) continue;

			transcoderFormat = opt.transcoderFormat[ hasAlpha ? 1 : 0 ];
			engineFormat = opt.engineFormat[ hasAlpha ? 1 : 0 ];

			return { transcoderFormat, engineFormat };

		}

		console.warn( 'THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32.' );

		transcoderFormat = TranscoderFormat.RGBA32;
		engineFormat = EngineFormat.RGBAFormat;

		return { transcoderFormat, engineFormat };

	}

	function isPowerOfTwo( value ) {

		if ( value <= 2 ) return true;

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	}

	/** Concatenates N byte arrays. */
	function concat( arrays ) {

		if ( arrays.length === 1 ) return arrays[ 0 ];

		let totalByteLength = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			totalByteLength += array.byteLength;

		}

		const result = new Uint8Array( totalByteLength );

		let byteOffset = 0;

		for ( let i = 0; i < arrays.length; i ++ ) {

			const array = arrays[ i ];
			result.set( array, byteOffset );

			byteOffset += array.byteLength;

		}

		return result;

	}

}`;
const UNCOMPRESSED_FORMATS = new Set([three_module.GWd, three_module.paN, three_module.VT0])
  , FORMAT_MAP = {
    [ktx_parse_module_Ae]: three_module.GWd,
    [ktx_parse_module_pe]: three_module.GWd,
    [Ot]: three_module.GWd,
    [Ft]: three_module.GWd,
    [ktx_parse_module_de]: three_module.paN,
    [ktx_parse_module_se]: three_module.paN,
    [yt]: three_module.paN,
    [dt]: three_module.paN,
    [ktx_parse_module_xe]: three_module.VT0,
    [$t]: three_module.VT0,
    [gt]: three_module.VT0,
    [ktx_parse_module_ct]: three_module.VT0,
    [In]: three_module.Qrf,
    [Sn]: three_module.Qrf
}
  , TYPE_MAP = {
    [ktx_parse_module_Ae]: three_module.RQf,
    [ktx_parse_module_pe]: three_module.ix0,
    [Ot]: three_module.OUM,
    [Ft]: three_module.OUM,
    [ktx_parse_module_de]: three_module.RQf,
    [ktx_parse_module_se]: three_module.ix0,
    [yt]: three_module.OUM,
    [dt]: three_module.OUM,
    [ktx_parse_module_xe]: three_module.RQf,
    [$t]: three_module.ix0,
    [gt]: three_module.OUM,
    [ktx_parse_module_ct]: three_module.OUM,
    [In]: three_module.OUM,
    [Sn]: three_module.OUM
};
async function createRawTexture(d) {
    const {vkFormat: o} = d;
    if (FORMAT_MAP[o] === void 0)
        throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
    let c;
    d.supercompressionScheme === n$2 && (_zstd || (_zstd = new Promise(async b => {
        const _e = new zstddec_module_Q;
        await _e.init(),
        b(_e)
    }
    )),
    c = await _zstd);
    const h = [];
    for (let b = 0; b < d.levels.length; b++) {
        const _e = Math.max(1, d.pixelWidth >> b)
          , nt = Math.max(1, d.pixelHeight >> b)
          , it = d.pixelDepth ? Math.max(1, d.pixelDepth >> b) : 0
          , at = d.levels[b];
        let ut, pt;
        if (d.supercompressionScheme === ktx_parse_module_t)
            ut = at.levelData;
        else {
            if (d.supercompressionScheme !== n$2)
                throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
            ut = c.decode(at.levelData, at.uncompressedByteLength)
        }
        pt = TYPE_MAP[o] === three_module.RQf ? new Float32Array(ut.buffer,ut.byteOffset,ut.byteLength / Float32Array.BYTES_PER_ELEMENT) : TYPE_MAP[o] === three_module.ix0 ? new Uint16Array(ut.buffer,ut.byteOffset,ut.byteLength / Uint16Array.BYTES_PER_ELEMENT) : ut,
        h.push({
            data: pt,
            width: _e,
            height: nt,
            depth: it
        })
    }
    let _;
    if (UNCOMPRESSED_FORMATS.has(FORMAT_MAP[o]))
        _ = d.pixelDepth === 0 ? new three_module.GYF(h[0].data,d.pixelWidth,d.pixelHeight) : new three_module.dYF(h[0].data,d.pixelWidth,d.pixelHeight,d.pixelDepth);
    else {
        if (d.pixelDepth > 0)
            throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
        _ = new three_module.FvD(h,d.pixelWidth,d.pixelHeight)
    }
    return _.mipmaps = h,
    _.type = TYPE_MAP[o],
    _.format = FORMAT_MAP[o],
    _.colorSpace = parseColorSpace(d),
    _.needsUpdate = !0,
    Promise.resolve(_)
}
function parseColorSpace(d) {
    const o = d.dataFormatDescriptor[0];
    return o.colorPrimaries === ktx_parse_module_F ? o.transferFunction === ktx_parse_module_x ? three_module.er$ : three_module.Zr2 : o.colorPrimaries === ktx_parse_module_X ? o.transferFunction === ktx_parse_module_x ? three_module.V5c : three_module.qIQ : (o.colorPrimaries === ktx_parse_module_E || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${o.colorPrimaries}"`),
    three_module.jf0)
}
const KHR_TEXTURE_BASISU = "KHR_texture_basisu";
class KTX2LoadPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin]
    }
    async onAdded(o) {
        var c, h, _, b, _e, nt;
        this._importer || (this._importer = new Importer(class extends KTX2Loader {
            constructor(it) {
                super(it),
                this.setTranscoderPath(KTX2LoadPlugin.TRANSCODER_LIBRARY_PATH).detectSupport(o.renderer.rendererObject)
            }
            async createTexture(it, at) {
                const ut = KTX2LoadPlugin.SAVE_SOURCE_BLOBS ? new Uint8Array(it.slice(0)) : void 0
                  , pt = await super.createTexture(it, at);
                return KTX2LoadPlugin.SAVE_SOURCE_BLOBS && ut && (pt.source._sourceImgBuffer = ut,
                pt.userData.mimeType = "image/ktx2",
                pt.source._canSerialize = !0,
                pt.toJSON = ht => serializeTextureInExtras(pt, ht, pt.name, "image/ktx2"),
                pt.clone = () => {
                    throw new Error("ktx2 texture cloning not supported")
                }
                ),
                pt
            }
        }
        ,["ktx2"],!1)),
        (h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.Importers.push(this._importer),
        (nt = (_e = (b = (_ = o.getManager()) === null || _ === void 0 ? void 0 : _.exporter) === null || b === void 0 ? void 0 : b.getExporter("gltf", "glb")) === null || _e === void 0 ? void 0 : _e.extensions) === null || nt === void 0 || nt.push(glTFTextureBasisUExtensionExport)
    }
    async onDispose(o) {
        this._importer = void 0
    }
    async onRemove(o) {
        var c, h;
        this._importer && (!((h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0) && h.Importers) && o.getManager().importer.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer), 1),
        this._importer = void 0
    }
}
KTX2LoadPlugin.PluginType = "KTX2LoadPlugin",
KTX2LoadPlugin.TRANSCODER_LIBRARY_PATH = "https://cdn.jsdelivr.net/gh/BinomialLLC/basis_universal@master/webgl/transcoder/build/",
KTX2LoadPlugin.SAVE_SOURCE_BLOBS = !1;
const glTFTextureBasisUExtensionExport = d => ({
    writeTexture: (o, c) => {
        if (o.userData.mimeType !== "image/ktx2")
            return;
        if (c.source !== void 0 && c.source !== null)
            return void console.warn("ktx2 export: source already set");
        const h = o.source._sourceImgBuffer || o.userData.__sourceBuffer;
        if (!h)
            return void console.warn("ktx2 export: no source buffer for ktx2");
        c.extensions = c.extensions || {};
        const _ = {}
          , b = new Blob([h],{
            type: "image/ktx2"
        });
        _.source = d.processImageBlob(b, o),
        c.extensions[KHR_TEXTURE_BASISU] = _,
        d.extensionsUsed[KHR_TEXTURE_BASISU] = !0
    }
});
class DebugPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dirty = !1,
        this.counters = {},
        this._generators = new Map,
        this._preRender = () => this._showDebug("preRender"),
        this._postRender = () => this._showDebug("postRender")
    }
    async onAdded(o) {
        this._viewer = o,
        o.addEventListener("preRender", this._preRender),
        o.addEventListener("postFrame", this._postRender)
    }
    addTexture(o, c, h, _, b, _e="postRender", nt=!1) {
        var it;
        this._generators.has(_e) || this._generators.set(_e, []),
        (it = this._generators.get(_e)) === null || it === void 0 || it.push({
            key: o,
            fn: c,
            rect: h ? [...h] : void 0,
            frag: b || _ || nt ? new three_module.BKk({
                vertexShader: CopyShader.vertexShader,
                uniforms: {
                    tDiffuse: {
                        value: null
                    },
                    opacity: {
                        value: 1
                    }
                },
                fragmentShader: b ?? `
        #include <common>
        #include <packing>
        uniform float opacity;
		uniform ${nt ? "samplerCube" : "sampler2D"} tDiffuse;
		varying vec2 vUv;
		void main() {
			vec4 texel = ${nt ? "textureCube( tDiffuse, vec3(cos(vUv.y * PI2) * cos(vUv.x * PI2), sin(vUv.y * PI2), cos(vUv.y * PI2) * sin(vUv.x * PI2)) )" : "texture2D( tDiffuse, vUv )"};
			${_ ?? ""}
			gl_FragColor = opacity * texel;
		}
            `
            }) : void 0
        })
    }
    removeTexture(o, c="postRender") {
        var h, _;
        this._generators.set(c, (_ = (h = this._generators.get(c)) === null || h === void 0 ? void 0 : h.filter(b => b.key !== o)) !== null && _ !== void 0 ? _ : [])
    }
    async onDispose(o) {
        return Promise.resolve(void 0)
    }
    async onRemove(o) {
        return o.removeEventListener("preRender", this._preRender),
        o.removeEventListener("postRender", this._postRender),
        this._viewer = void 0,
        Promise.resolve(void 0)
    }
    _showDebug(o) {
        var c;
        const h = this._viewer
          , _ = h == null ? void 0 : h.renderer;
        _ && h && ((c = this._generators.get(o)) === null || c === void 0 || c.forEach( ({key: b, fn: _e, rect: nt, frag: it}) => {
            const at = _e(h);
            if (at) {
                if (at.image && nt) {
                    const ut = at.image.width / at.image.height;
                    nt[2] < 1 && nt[3] < 1 && (nt[2] = 200),
                    nt[2] < 1 && (nt[2] = nt[3] * ut),
                    nt[3] < 1 && (nt[3] = nt[2] / ut)
                }
                _.blit(at, void 0, {
                    viewport: nt,
                    clear: !1,
                    material: it
                })
            }
        }
        ))
    }
}
DebugPlugin.PluginType = "debug";
class MTLLoader2 extends three_module.aHM {
    constructor(o) {
        super(o)
    }
    load(o, c, h, _) {
        const b = this
          , _e = this.path === "" ? three_module.r6x.extractUrlBase(o) : this.path
          , nt = new three_module.Y9S(this.manager);
        nt.setPath(this.path),
        nt.setRequestHeader(this.requestHeader),
        nt.setWithCredentials(this.withCredentials),
        nt.load(o, function(it) {
            try {
                c(b.parse(it, _e))
            } catch (at) {
                _ ? _(at) : console.error(at),
                b.manager.itemError(o)
            }
        }, h, _)
    }
    setMaterialOptions(o) {
        return this.materialOptions = o,
        this
    }
    parse(o, c) {
        const h = o.split(`
`);
        let _ = {};
        const b = /\s+/
          , _e = {};
        for (let it = 0; it < h.length; it++) {
            let at = h[it];
            if (at = at.trim(),
            at.length === 0 || at.charAt(0) === "#")
                continue;
            const ut = at.indexOf(" ");
            let pt = ut >= 0 ? at.substring(0, ut) : at;
            pt = pt.toLowerCase();
            let ht = ut >= 0 ? at.substring(ut + 1) : "";
            if (ht = ht.trim(),
            pt === "newmtl")
                _ = {
                    name: ht
                },
                _e[ht] = _;
            else if (pt === "ka" || pt === "kd" || pt === "ks" || pt === "ke") {
                const _t = ht.split(b, 3);
                _[pt] = [parseFloat(_t[0]), parseFloat(_t[1]), parseFloat(_t[2])]
            } else
                _[pt] = ht
        }
        const nt = new MaterialCreator(this.resourcePath || c,this.materialOptions);
        return nt.setCrossOrigin(this.crossOrigin),
        nt.setManager(this.manager),
        nt.setMaterials(_e),
        nt
    }
}
class MaterialCreator {
    constructor(o="", c={}) {
        this.baseUrl = o,
        this.options = c,
        this.materialsInfo = {},
        this.materials = {},
        this.materialsArray = [],
        this.nameLookup = {},
        this.crossOrigin = "anonymous",
        this.side = this.options.side !== void 0 ? this.options.side : three_module.hB5,
        this.wrap = this.options.wrap !== void 0 ? this.options.wrap : three_module.GJx
    }
    setCrossOrigin(o) {
        return this.crossOrigin = o,
        this
    }
    setManager(o) {
        this.manager = o
    }
    setMaterials(o) {
        this.materialsInfo = this.convert(o),
        this.materials = {},
        this.materialsArray = [],
        this.nameLookup = {}
    }
    convert(o) {
        if (!this.options)
            return o;
        const c = {};
        for (const h in o) {
            const _ = o[h]
              , b = {};
            c[h] = b;
            for (const _e in _) {
                let nt = !0
                  , it = _[_e];
                const at = _e.toLowerCase();
                switch (at) {
                case "kd":
                case "ka":
                case "ks":
                    this.options && this.options.normalizeRGB && (it = [it[0] / 255, it[1] / 255, it[2] / 255]),
                    this.options && this.options.ignoreZeroRGBs && it[0] === 0 && it[1] === 0 && it[2] === 0 && (nt = !1)
                }
                nt && (b[at] = it)
            }
        }
        return c
    }
    async preload() {
        for (const o in this.materialsInfo)
            await this.create(o)
    }
    getIndex(o) {
        return this.nameLookup[o]
    }
    async getAsArray() {
        let o = 0;
        for (const c in this.materialsInfo)
            this.materialsArray[o] = await this.create(c),
            this.nameLookup[c] = o,
            o++;
        return this.materialsArray
    }
    async create(o) {
        return this.materials[o] === void 0 && await this.createMaterial_(o),
        this.materials[o]
    }
    async createMaterial_(o) {
        const c = this
          , h = this.materialsInfo[o]
          , _ = {
            name: o,
            side: this.side
        };
        async function b(it, at) {
            if (_[it])
                return;
            const ut = c.getTextureParams(at, _);
            return new Promise( (pt, ht) => {
                let _t = !1
                  , vt = () => !_t && (_t = !0) && pt();
                const bt = c.loadTexture((St = c.baseUrl,
                typeof (At = ut.url) != "string" || At === "" ? "" : /^https?:\/\//i.test(At) ? At : St + At), void 0, Et => {
                    _[it] = Et,
                    vt()
                }
                , void 0, vt);
                var St, At;
                setTimeout(vt, 50),
                bt.repeat.copy(ut.scale),
                bt.offset.copy(ut.offset),
                bt.wrapS = c.wrap,
                bt.wrapT = c.wrap,
                it !== "map" && it !== "emissiveMap" || (bt.colorSpace = three_module.er$)
            }
            )
        }
        const _e = Array.from(Object.keys(h || {}));
        let nt = _e.includes("d") || _e.includes("D");
        for (const it of _e) {
            const at = h[it];
            let ut;
            if (at !== "")
                switch (it.toLowerCase()) {
                case "kd":
                    _.color = new three_module.Q1f().fromArray(at).convertSRGBToLinear();
                    break;
                case "ks":
                    _.specular = new three_module.Q1f().fromArray(at).convertSRGBToLinear();
                    break;
                case "ke":
                    _.emissive = new three_module.Q1f().fromArray(at).convertSRGBToLinear();
                    break;
                case "map_kd":
                    await b("map", at);
                    break;
                case "map_ks":
                    await b("specularMap", at);
                    break;
                case "map_ke":
                    await b("emissiveMap", at);
                    break;
                case "norm":
                    await b("normalMap", at);
                    break;
                case "map_bump":
                case "bump":
                    await b("bumpMap", at);
                    break;
                case "map_d":
                    await b("alphaMap", at),
                    _.transparent = !0;
                    break;
                case "ns":
                    _.shininess = parseFloat(at);
                    break;
                case "d":
                    ut = parseFloat(at),
                    ut < 1 && (_.opacity = ut,
                    _.transparent = !0);
                    break;
                case "tr":
                    if (nt)
                        break;
                    ut = parseFloat(at),
                    this.options && this.options.invertTrProperty && (ut = 1 - ut),
                    ut > 0 && (_.opacity = 1 - ut,
                    _.transparent = !0)
                }
        }
        return this.materials[o] = new three_module.tXL(_),
        this.materials[o]
    }
    getTextureParams(o, c) {
        const h = {
            scale: new three_module.I9Y(1,1),
            offset: new three_module.I9Y(0,0)
        }
          , _ = o.split(/\s+/);
        let b;
        return b = _.indexOf("-bm"),
        b >= 0 && (c.bumpScale = parseFloat(_[b + 1]),
        _.splice(b, 2)),
        b = _.indexOf("-s"),
        b >= 0 && (h.scale.set(parseFloat(_[b + 1]), parseFloat(_[b + 2])),
        _.splice(b, 4)),
        b = _.indexOf("-o"),
        b >= 0 && (h.offset.set(parseFloat(_[b + 1]), parseFloat(_[b + 2])),
        _.splice(b, 4)),
        h.url = _.join(" ").trim(),
        h
    }
    loadTexture(o, c, h, _, b) {
        const _e = this.manager !== void 0 ? this.manager : three_module.h_9;
        let nt = _e.getHandler(o);
        nt === null && (nt = new three_module.Tap(_e)),
        nt.setCrossOrigin && nt.setCrossOrigin(this.crossOrigin);
        const it = nt.load(o, h, _, b);
        return c !== void 0 && (it.mapping = c),
        it
    }
}
const _object_pattern = /^[og]\s*(.+)?/
  , _material_library_pattern = /^mtllib /
  , _material_use_pattern = /^usemtl /
  , _map_use_pattern = /^usemap /
  , _face_vertex_data_separator_pattern = /\s+/
  , _vA = new three_module.Pq0
  , _vB = new three_module.Pq0
  , _vC = new three_module.Pq0
  , _ab = new three_module.Pq0
  , _cb = new three_module.Pq0
  , _color = new three_module.Q1f;
function ParserState() {
    const d = {
        objects: [],
        object: {},
        vertices: [],
        normals: [],
        colors: [],
        uvs: [],
        materials: {},
        materialLibraries: [],
        startObject: function(o, c) {
            if (this.object && this.object.fromDeclaration === !1)
                return this.object.name = o,
                void (this.object.fromDeclaration = c !== !1);
            const h = this.object && typeof this.object.currentMaterial == "function" ? this.object.currentMaterial() : void 0;
            if (this.object && typeof this.object._finalize == "function" && this.object._finalize(!0),
            this.object = {
                name: o || "",
                fromDeclaration: c !== !1,
                geometry: {
                    vertices: [],
                    normals: [],
                    colors: [],
                    uvs: [],
                    hasUVIndices: !1
                },
                materials: [],
                smooth: !0,
                startMaterial: function(_, b) {
                    const _e = this._finalize(!1);
                    _e && (_e.inherited || _e.groupCount <= 0) && this.materials.splice(_e.index, 1);
                    const nt = {
                        index: this.materials.length,
                        name: _ || "",
                        mtllib: Array.isArray(b) && b.length > 0 ? b[b.length - 1] : "",
                        smooth: _e !== void 0 ? _e.smooth : this.smooth,
                        groupStart: _e !== void 0 ? _e.groupEnd : 0,
                        groupEnd: -1,
                        groupCount: -1,
                        inherited: !1,
                        clone: function(it) {
                            const at = {
                                index: typeof it == "number" ? it : this.index,
                                name: this.name,
                                mtllib: this.mtllib,
                                smooth: this.smooth,
                                groupStart: 0,
                                groupEnd: -1,
                                groupCount: -1,
                                inherited: !1
                            };
                            return at.clone = this.clone.bind(at),
                            at
                        }
                    };
                    return this.materials.push(nt),
                    nt
                },
                currentMaterial: function() {
                    if (this.materials.length > 0)
                        return this.materials[this.materials.length - 1]
                },
                _finalize: function(_) {
                    const b = this.currentMaterial();
                    if (b && b.groupEnd === -1 && (b.groupEnd = this.geometry.vertices.length / 3,
                    b.groupCount = b.groupEnd - b.groupStart,
                    b.inherited = !1),
                    _ && this.materials.length > 1)
                        for (let _e = this.materials.length - 1; _e >= 0; _e--)
                            this.materials[_e].groupCount <= 0 && this.materials.splice(_e, 1);
                    return _ && this.materials.length === 0 && this.materials.push({
                        name: "",
                        smooth: this.smooth
                    }),
                    b
                }
            },
            h && h.name && typeof h.clone == "function") {
                const _ = h.clone(0);
                _.inherited = !0,
                this.object.materials.push(_)
            }
            this.objects.push(this.object)
        },
        finalize: function() {
            this.object && typeof this.object._finalize == "function" && this.object._finalize(!0)
        },
        parseVertexIndex: function(o, c) {
            const h = parseInt(o, 10);
            return 3 * (h >= 0 ? h - 1 : h + c / 3)
        },
        parseNormalIndex: function(o, c) {
            const h = parseInt(o, 10);
            return 3 * (h >= 0 ? h - 1 : h + c / 3)
        },
        parseUVIndex: function(o, c) {
            const h = parseInt(o, 10);
            return 2 * (h >= 0 ? h - 1 : h + c / 2)
        },
        addVertex: function(o, c, h) {
            const _ = this.vertices
              , b = this.object.geometry.vertices;
            b.push(_[o + 0], _[o + 1], _[o + 2]),
            b.push(_[c + 0], _[c + 1], _[c + 2]),
            b.push(_[h + 0], _[h + 1], _[h + 2])
        },
        addVertexPoint: function(o) {
            const c = this.vertices;
            this.object.geometry.vertices.push(c[o + 0], c[o + 1], c[o + 2])
        },
        addVertexLine: function(o) {
            const c = this.vertices;
            this.object.geometry.vertices.push(c[o + 0], c[o + 1], c[o + 2])
        },
        addNormal: function(o, c, h) {
            const _ = this.normals
              , b = this.object.geometry.normals;
            b.push(_[o + 0], _[o + 1], _[o + 2]),
            b.push(_[c + 0], _[c + 1], _[c + 2]),
            b.push(_[h + 0], _[h + 1], _[h + 2])
        },
        addFaceNormal: function(o, c, h) {
            const _ = this.vertices
              , b = this.object.geometry.normals;
            _vA.fromArray(_, o),
            _vB.fromArray(_, c),
            _vC.fromArray(_, h),
            _cb.subVectors(_vC, _vB),
            _ab.subVectors(_vA, _vB),
            _cb.cross(_ab),
            _cb.normalize(),
            b.push(_cb.x, _cb.y, _cb.z),
            b.push(_cb.x, _cb.y, _cb.z),
            b.push(_cb.x, _cb.y, _cb.z)
        },
        addColor: function(o, c, h) {
            const _ = this.colors
              , b = this.object.geometry.colors;
            _[o] !== void 0 && b.push(_[o + 0], _[o + 1], _[o + 2]),
            _[c] !== void 0 && b.push(_[c + 0], _[c + 1], _[c + 2]),
            _[h] !== void 0 && b.push(_[h + 0], _[h + 1], _[h + 2])
        },
        addUV: function(o, c, h) {
            const _ = this.uvs
              , b = this.object.geometry.uvs;
            b.push(_[o + 0], _[o + 1]),
            b.push(_[c + 0], _[c + 1]),
            b.push(_[h + 0], _[h + 1])
        },
        addDefaultUV: function() {
            const o = this.object.geometry.uvs;
            o.push(0, 0),
            o.push(0, 0),
            o.push(0, 0)
        },
        addUVLine: function(o) {
            const c = this.uvs;
            this.object.geometry.uvs.push(c[o + 0], c[o + 1])
        },
        addFace: function(o, c, h, _, b, _e, nt, it, at) {
            const ut = this.vertices.length;
            let pt = this.parseVertexIndex(o, ut)
              , ht = this.parseVertexIndex(c, ut)
              , _t = this.parseVertexIndex(h, ut);
            if (this.addVertex(pt, ht, _t),
            this.addColor(pt, ht, _t),
            nt !== void 0 && nt !== "") {
                const vt = this.normals.length;
                pt = this.parseNormalIndex(nt, vt),
                ht = this.parseNormalIndex(it, vt),
                _t = this.parseNormalIndex(at, vt),
                this.addNormal(pt, ht, _t)
            } else
                this.addFaceNormal(pt, ht, _t);
            if (_ !== void 0 && _ !== "") {
                const vt = this.uvs.length;
                pt = this.parseUVIndex(_, vt),
                ht = this.parseUVIndex(b, vt),
                _t = this.parseUVIndex(_e, vt),
                this.addUV(pt, ht, _t),
                this.object.geometry.hasUVIndices = !0
            } else
                this.addDefaultUV()
        },
        addPointGeometry: function(o) {
            this.object.geometry.type = "Points";
            const c = this.vertices.length;
            for (let h = 0, _ = o.length; h < _; h++) {
                const b = this.parseVertexIndex(o[h], c);
                this.addVertexPoint(b),
                this.addColor(b)
            }
        },
        addLineGeometry: function(o, c) {
            this.object.geometry.type = "Line";
            const h = this.vertices.length
              , _ = this.uvs.length;
            for (let b = 0, _e = o.length; b < _e; b++)
                this.addVertexLine(this.parseVertexIndex(o[b], h));
            for (let b = 0, _e = c.length; b < _e; b++)
                this.addUVLine(this.parseUVIndex(c[b], _))
        }
    };
    return d.startObject("", !1),
    d
}
class OBJLoader2 extends three_module.aHM {
    constructor(o) {
        super(o),
        this.materials = null
    }
    load(o, c, h, _) {
        const b = this
          , _e = new three_module.Y9S(this.manager);
        _e.setPath(this.path),
        _e.setRequestHeader(this.requestHeader),
        _e.setWithCredentials(this.withCredentials),
        _e.load(o, async function(nt) {
            try {
                c(await b.parse(nt))
            } catch (it) {
                _ ? _(it) : console.error(it),
                b.manager.itemError(o)
            }
        }, h, _)
    }
    setMaterials(o) {
        return this.materials = o,
        this
    }
    async parse(o) {
        const c = new ParserState;
        o.indexOf(`\r
`) !== -1 && (o = o.replace(/\r\n/g, `
`)),
        o.indexOf(`\\
`) !== -1 && (o = o.replace(/\\\n/g, ""));
        const h = o.split(`
`);
        let _ = [];
        for (let _e = 0, nt = h.length; _e < nt; _e++) {
            const it = h[_e].trimStart();
            if (it.length === 0)
                continue;
            const at = it.charAt(0);
            if (at !== "#")
                if (at === "v") {
                    const ut = it.split(_face_vertex_data_separator_pattern);
                    switch (ut[0]) {
                    case "v":
                        c.vertices.push(parseFloat(ut[1]), parseFloat(ut[2]), parseFloat(ut[3])),
                        ut.length >= 7 ? (_color.setRGB(parseFloat(ut[4]), parseFloat(ut[5]), parseFloat(ut[6])).convertSRGBToLinear(),
                        c.colors.push(_color.r, _color.g, _color.b)) : c.colors.push(void 0, void 0, void 0);
                        break;
                    case "vn":
                        c.normals.push(parseFloat(ut[1]), parseFloat(ut[2]), parseFloat(ut[3]));
                        break;
                    case "vt":
                        c.uvs.push(parseFloat(ut[1]), parseFloat(ut[2]))
                    }
                } else if (at === "f") {
                    const ut = it.slice(1).trim().split(_face_vertex_data_separator_pattern)
                      , pt = [];
                    for (let _t = 0, vt = ut.length; _t < vt; _t++) {
                        const bt = ut[_t];
                        if (bt.length > 0) {
                            const St = bt.split("/");
                            pt.push(St)
                        }
                    }
                    const ht = pt[0];
                    for (let _t = 1, vt = pt.length - 1; _t < vt; _t++) {
                        const bt = pt[_t]
                          , St = pt[_t + 1];
                        c.addFace(ht[0], bt[0], St[0], ht[1], bt[1], St[1], ht[2], bt[2], St[2])
                    }
                } else if (at === "l") {
                    const ut = it.substring(1).trim().split(" ");
                    let pt = [];
                    const ht = [];
                    if (it.indexOf("/") === -1)
                        pt = ut;
                    else
                        for (let _t = 0, vt = ut.length; _t < vt; _t++) {
                            const bt = ut[_t].split("/");
                            bt[0] !== "" && pt.push(bt[0]),
                            bt[1] !== "" && ht.push(bt[1])
                        }
                    c.addLineGeometry(pt, ht)
                } else if (at === "p") {
                    const ut = it.slice(1).trim().split(" ");
                    c.addPointGeometry(ut)
                } else if ((_ = _object_pattern.exec(it)) !== null) {
                    const ut = (" " + _[0].slice(1).trim()).slice(1);
                    c.startObject(ut)
                } else if (_material_use_pattern.test(it))
                    c.object.startMaterial(it.substring(7).trim(), c.materialLibraries);
                else if (_material_library_pattern.test(it)) {
                    c.materialLibraries.push(it.substring(7).trim());
                    const ut = it.substring(7).trim()
                      , pt = this.manager.getHandler(ut);
                    if (pt) {
                        const ht = await pt.loadAsync(ut).catch(_t => {
                            console.warn(_t)
                        }
                        );
                        ht && this.setMaterials(ht)
                    } else
                        console.warn("OBJLoader2: Set MTLLoader to loading manager to load materials.")
                } else if (_map_use_pattern.test(it))
                    console.warn('OBJLoader2: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                else if (at === "s") {
                    if (_ = it.split(" "),
                    _.length > 1) {
                        const pt = _[1].trim().toLowerCase();
                        c.object.smooth = pt !== "0" && pt !== "off"
                    } else
                        c.object.smooth = !0;
                    const ut = c.object.currentMaterial();
                    ut && (ut.smooth = c.object.smooth)
                } else {
                    if (it === "\0")
                        continue;
                    console.warn('THREE.OBJLoader: Unexpected line: "' + it + '"')
                }
        }
        c.finalize();
        const b = new three_module.YJl;
        if (b.materialLibraries = [].concat(c.materialLibraries),
        !(c.objects.length === 1 && c.objects[0].geometry.vertices.length === 0))
            for (let _e = 0, nt = c.objects.length; _e < nt; _e++) {
                const it = c.objects[_e]
                  , at = it.geometry
                  , ut = it.materials
                  , pt = at.type === "Line"
                  , ht = at.type === "Points";
                let _t = !1;
                if (at.vertices.length === 0)
                    continue;
                const vt = new three_module.LoY;
                vt.setAttribute("position", new three_module.qtW(at.vertices,3)),
                at.normals.length > 0 && vt.setAttribute("normal", new three_module.qtW(at.normals,3)),
                at.colors.length > 0 && (_t = !0,
                vt.setAttribute("color", new three_module.qtW(at.colors,3))),
                at.hasUVIndices === !0 && vt.setAttribute("uv", new three_module.qtW(at.uvs,2));
                const bt = [];
                for (let At = 0, Et = ut.length; At < Et; At++) {
                    const Pt = ut[At]
                      , It = Pt.name + "_" + Pt.smooth + "_" + _t;
                    let Dt = c.materials[It];
                    if (this.materials !== null)
                        if (Dt = await this.materials.create(Pt.name),
                        !pt || !Dt || Dt instanceof three_module.mrM) {
                            if (ht && Dt && !(Dt instanceof three_module.BH$)) {
                                const Gt = new three_module.BH$({
                                    size: 10,
                                    sizeAttenuation: !1
                                });
                                three_module.imn.prototype.copy.call(Gt, Dt),
                                Gt.color.copy(Dt.color),
                                Gt.map = Dt.map,
                                Dt = Gt
                            }
                        } else {
                            const Gt = new three_module.mrM;
                            three_module.imn.prototype.copy.call(Gt, Dt),
                            Gt.color.copy(Dt.color),
                            Dt = Gt
                        }
                    Dt === void 0 && (Dt = pt ? new three_module.mrM : ht ? new three_module.BH$({
                        size: 1,
                        sizeAttenuation: !1
                    }) : new three_module.tXL,
                    Dt.name = Pt.name,
                    Dt.flatShading = !Pt.smooth,
                    Dt.vertexColors = _t,
                    c.materials[It] = Dt),
                    bt.push(Dt)
                }
                let St;
                if (bt.length > 1) {
                    for (let At = 0, Et = ut.length; At < Et; At++) {
                        const Pt = ut[At];
                        vt.addGroup(Pt.groupStart, Pt.groupCount, At)
                    }
                    St = pt ? new three_module.DXC(vt,bt) : ht ? new three_module.ONl(vt,bt) : new three_module.eaF(vt,bt)
                } else
                    St = pt ? new three_module.DXC(vt,bt[0]) : ht ? new three_module.ONl(vt,bt[0]) : new three_module.eaF(vt,bt[0]);
                St.name = it.name,
                b.add(St)
            }
        else if (c.vertices.length > 0) {
            const _e = new three_module.BH$({
                size: 1,
                sizeAttenuation: !1
            })
              , nt = new three_module.LoY;
            nt.setAttribute("position", new three_module.qtW(c.vertices,3)),
            c.colors.length > 0 && c.colors[0] !== void 0 && (nt.setAttribute("color", new three_module.qtW(c.colors,3)),
            _e.vertexColors = !0);
            const it = new three_module.ONl(nt,_e);
            b.add(it)
        }
        return b
    }
}
class ObjMtlLoadPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin],
        this._importer1 = new Importer(OBJLoader2,["obj"],!0),
        this._importer2 = new Importer(MTLLoader2,["mtl"],!1)
    }
    async onAdded(o) {
        var c, h, _, b;
        (h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.Importers.push(this._importer1),
        (b = (_ = o.getManager()) === null || _ === void 0 ? void 0 : _.importer) === null || b === void 0 || b.Importers.push(this._importer2)
    }
    async onDispose(o) {}
    async onRemove(o) {
        var c, h;
        !((h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0) && h.Importers && (o.getManager().importer.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer1), 1),
        o.getManager().importer.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer2), 1))
    }
}
ObjMtlLoadPlugin.PluginType = "ObjMtlLoadPlugin";
var durl = function(d) {
    return URL.createObjectURL(new Blob([d],{
        type: "text/javascript"
    }))
};
try {
    URL.revokeObjectURL(durl(""))
} catch (d) {
    durl = function(o) {
        return "data:application/javascript;charset=UTF-8," + encodeURI(o)
    }
}
var fflate_module_u8 = Uint8Array
  , fflate_module_u16 = Uint16Array
  , fflate_module_u32 = Uint32Array
  , fflate_module_fleb = new fflate_module_u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , fflate_module_fdeb = new fflate_module_u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , fflate_module_clim = new fflate_module_u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , fflate_module_freb = function(d, o) {
    for (var c = new fflate_module_u16(31), h = 0; h < 31; ++h)
        c[h] = o += 1 << d[h - 1];
    var _ = new fflate_module_u32(c[30]);
    for (h = 1; h < 30; ++h)
        for (var b = c[h]; b < c[h + 1]; ++b)
            _[b] = b - c[h] << 5 | h;
    return [c, _]
}
  , fflate_module_a = fflate_module_freb(fflate_module_fleb, 2)
  , fflate_module_fl = fflate_module_a[0]
  , fflate_module_revfl = fflate_module_a[1];
fflate_module_fl[28] = 258,
fflate_module_revfl[258] = 28;
for (var fflate_module_b = fflate_module_freb(fflate_module_fdeb, 0), fflate_module_fd = fflate_module_b[0], fflate_module_revfd = fflate_module_b[1], fflate_module_rev = new fflate_module_u16(32768), fflate_module_i = 0; fflate_module_i < 32768; ++fflate_module_i) {
    var fflate_module_x = (43690 & fflate_module_i) >>> 1 | (21845 & fflate_module_i) << 1;
    fflate_module_x = (52428 & fflate_module_x) >>> 2 | (13107 & fflate_module_x) << 2,
    fflate_module_x = (61680 & fflate_module_x) >>> 4 | (3855 & fflate_module_x) << 4,
    fflate_module_rev[fflate_module_i] = ((65280 & fflate_module_x) >>> 8 | (255 & fflate_module_x) << 8) >>> 1
}
for (var fflate_module_hMap = function(o, c, h) {
    for (var _ = o.length, b = 0, _e = new fflate_module_u16(c); b < _; ++b)
        ++_e[o[b] - 1];
    var nt, it = new fflate_module_u16(c);
    for (b = 0; b < c; ++b)
        it[b] = it[b - 1] + _e[b - 1] << 1;
    if (h) {
        nt = new fflate_module_u16(1 << c);
        var at = 15 - c;
        for (b = 0; b < _; ++b)
            if (o[b])
                for (var ut = b << 4 | o[b], pt = c - o[b], ht = it[o[b] - 1]++ << pt, _t = ht | (1 << pt) - 1; ht <= _t; ++ht)
                    nt[fflate_module_rev[ht] >>> at] = ut
    } else
        for (nt = new fflate_module_u16(_),
        b = 0; b < _; ++b)
            o[b] && (nt[b] = fflate_module_rev[it[o[b] - 1]++] >>> 15 - o[b]);
    return nt
}, fflate_module_flt = new fflate_module_u8(288), fflate_module_i = 0; fflate_module_i < 144; ++fflate_module_i)
    fflate_module_flt[fflate_module_i] = 8;
for (var fflate_module_i = 144; fflate_module_i < 256; ++fflate_module_i)
    fflate_module_flt[fflate_module_i] = 9;
for (var fflate_module_i = 256; fflate_module_i < 280; ++fflate_module_i)
    fflate_module_flt[fflate_module_i] = 7;
for (var fflate_module_i = 280; fflate_module_i < 288; ++fflate_module_i)
    fflate_module_flt[fflate_module_i] = 8;
for (var fflate_module_fdt = new fflate_module_u8(32), fflate_module_i = 0; fflate_module_i < 32; ++fflate_module_i)
    fflate_module_fdt[fflate_module_i] = 5;
var fflate_module_flm = fflate_module_hMap(fflate_module_flt, 9, 0)
  , fflate_module_flrm = fflate_module_hMap(fflate_module_flt, 9, 1)
  , fflate_module_fdm = fflate_module_hMap(fflate_module_fdt, 5, 0)
  , fflate_module_fdrm = fflate_module_hMap(fflate_module_fdt, 5, 1)
  , fflate_module_max = function(d) {
    for (var o = d[0], c = 1; c < d.length; ++c)
        d[c] > o && (o = d[c]);
    return o
}
  , fflate_module_bits = function(d, o, c) {
    var h = o / 8 | 0;
    return (d[h] | d[h + 1] << 8) >> (7 & o) & c
}
  , fflate_module_bits16 = function(d, o) {
    var c = o / 8 | 0;
    return (d[c] | d[c + 1] << 8 | d[c + 2] << 16) >> (7 & o)
}
  , fflate_module_shft = function(d) {
    return (d / 8 | 0) + (7 & d && 1)
}
  , fflate_module_slc = function(d, o, c) {
    (c == null || c > d.length) && (c = d.length);
    var h = new (d instanceof fflate_module_u16 ? fflate_module_u16 : d instanceof fflate_module_u32 ? fflate_module_u32 : fflate_module_u8)(c - o);
    return h.set(d.subarray(o, c)),
    h
}
  , fflate_module_inflt = function(d, o, c) {
    var h = d.length;
    if (!h || c && !c.l && h < 5)
        return o || new fflate_module_u8(0);
    var _ = !o || c
      , b = !c || c.i;
    c || (c = {}),
    o || (o = new fflate_module_u8(3 * h));
    var _e = function(fr) {
        var vr = o.length;
        if (fr > vr) {
            var Zr = new fflate_module_u8(Math.max(2 * vr, fr));
            Zr.set(o),
            o = Zr
        }
    }
      , nt = c.f || 0
      , it = c.p || 0
      , at = c.b || 0
      , ut = c.l
      , pt = c.d
      , ht = c.m
      , _t = c.n
      , vt = 8 * h;
    do {
        if (!ut) {
            c.f = nt = fflate_module_bits(d, it, 1);
            var bt = fflate_module_bits(d, it + 1, 3);
            if (it += 3,
            !bt) {
                var St = d[(Kt = fflate_module_shft(it) + 4) - 4] | d[Kt - 3] << 8
                  , At = Kt + St;
                if (At > h) {
                    if (b)
                        throw "unexpected EOF";
                    break
                }
                _ && _e(at + St),
                o.set(d.subarray(Kt, At), at),
                c.b = at += St,
                c.p = it = 8 * At;
                continue
            }
            if (bt == 1)
                ut = fflate_module_flrm,
                pt = fflate_module_fdrm,
                ht = 9,
                _t = 5;
            else {
                if (bt != 2)
                    throw "invalid block type";
                var Et = fflate_module_bits(d, it, 31) + 257
                  , Pt = fflate_module_bits(d, it + 10, 15) + 4
                  , It = Et + fflate_module_bits(d, it + 5, 31) + 1;
                it += 14;
                for (var Dt = new fflate_module_u8(It), Gt = new fflate_module_u8(19), Bt = 0; Bt < Pt; ++Bt)
                    Gt[fflate_module_clim[Bt]] = fflate_module_bits(d, it + 3 * Bt, 7);
                it += 3 * Pt;
                var kt = fflate_module_max(Gt)
                  , Ut = (1 << kt) - 1
                  , Ht = fflate_module_hMap(Gt, kt, 1);
                for (Bt = 0; Bt < It; ) {
                    var Kt, Jt = Ht[fflate_module_bits(d, it, Ut)];
                    if (it += 15 & Jt,
                    (Kt = Jt >>> 4) < 16)
                        Dt[Bt++] = Kt;
                    else {
                        var or = 0
                          , ir = 0;
                        for (Kt == 16 ? (ir = 3 + fflate_module_bits(d, it, 3),
                        it += 2,
                        or = Dt[Bt - 1]) : Kt == 17 ? (ir = 3 + fflate_module_bits(d, it, 7),
                        it += 3) : Kt == 18 && (ir = 11 + fflate_module_bits(d, it, 127),
                        it += 7); ir--; )
                            Dt[Bt++] = or
                    }
                }
                var lr = Dt.subarray(0, Et)
                  , ar = Dt.subarray(Et);
                ht = fflate_module_max(lr),
                _t = fflate_module_max(ar),
                ut = fflate_module_hMap(lr, ht, 1),
                pt = fflate_module_hMap(ar, _t, 1)
            }
            if (it > vt) {
                if (b)
                    throw "unexpected EOF";
                break
            }
        }
        _ && _e(at + 131072);
        for (var hr = (1 << ht) - 1, gr = (1 << _t) - 1, dr = it; ; dr = it) {
            var cr = (or = ut[fflate_module_bits16(d, it) & hr]) >>> 4;
            if ((it += 15 & or) > vt) {
                if (b)
                    throw "unexpected EOF";
                break
            }
            if (!or)
                throw "invalid length/literal";
            if (cr < 256)
                o[at++] = cr;
            else {
                if (cr == 256) {
                    dr = it,
                    ut = null;
                    break
                }
                var Ar = cr - 254;
                if (cr > 264) {
                    var wr = fflate_module_fleb[Bt = cr - 257];
                    Ar = fflate_module_bits(d, it, (1 << wr) - 1) + fflate_module_fl[Bt],
                    it += wr
                }
                var Rr = pt[fflate_module_bits16(d, it) & gr]
                  , Cr = Rr >>> 4;
                if (!Rr)
                    throw "invalid distance";
                if (it += 15 & Rr,
                ar = fflate_module_fd[Cr],
                Cr > 3 && (wr = fflate_module_fdeb[Cr],
                ar += fflate_module_bits16(d, it) & (1 << wr) - 1,
                it += wr),
                it > vt) {
                    if (b)
                        throw "unexpected EOF";
                    break
                }
                _ && _e(at + 131072);
                for (var tr = at + Ar; at < tr; at += 4)
                    o[at] = o[at - ar],
                    o[at + 1] = o[at + 1 - ar],
                    o[at + 2] = o[at + 2 - ar],
                    o[at + 3] = o[at + 3 - ar];
                at = tr
            }
        }
        c.l = ut,
        c.p = dr,
        c.b = at,
        ut && (nt = 1,
        c.m = ht,
        c.d = pt,
        c.n = _t)
    } while (!nt);
    return at == o.length ? o : fflate_module_slc(o, 0, at)
}
  , fflate_module_wbits = function(d, o, c) {
    c <<= 7 & o;
    var h = o / 8 | 0;
    d[h] |= c,
    d[h + 1] |= c >>> 8
}
  , fflate_module_wbits16 = function(d, o, c) {
    c <<= 7 & o;
    var h = o / 8 | 0;
    d[h] |= c,
    d[h + 1] |= c >>> 8,
    d[h + 2] |= c >>> 16
}
  , fflate_module_hTree = function(d, o) {
    for (var c = [], h = 0; h < d.length; ++h)
        d[h] && c.push({
            s: h,
            f: d[h]
        });
    var _ = c.length
      , b = c.slice();
    if (!_)
        return [fflate_module_et, 0];
    if (_ == 1) {
        var _e = new fflate_module_u8(c[0].s + 1);
        return _e[c[0].s] = 1,
        [_e, 1]
    }
    c.sort(function(Dt, Gt) {
        return Dt.f - Gt.f
    }),
    c.push({
        s: -1,
        f: 25001
    });
    var nt = c[0]
      , it = c[1]
      , at = 0
      , ut = 1
      , pt = 2;
    for (c[0] = {
        s: -1,
        f: nt.f + it.f,
        l: nt,
        r: it
    }; ut != _ - 1; )
        nt = c[c[at].f < c[pt].f ? at++ : pt++],
        it = c[at != ut && c[at].f < c[pt].f ? at++ : pt++],
        c[ut++] = {
            s: -1,
            f: nt.f + it.f,
            l: nt,
            r: it
        };
    var ht = b[0].s;
    for (h = 1; h < _; ++h)
        b[h].s > ht && (ht = b[h].s);
    var _t = new fflate_module_u16(ht + 1)
      , vt = fflate_module_ln(c[ut - 1], _t, 0);
    if (vt > o) {
        h = 0;
        var bt = 0
          , St = vt - o
          , At = 1 << St;
        for (b.sort(function(Dt, Gt) {
            return _t[Gt.s] - _t[Dt.s] || Dt.f - Gt.f
        }); h < _; ++h) {
            var Et = b[h].s;
            if (!(_t[Et] > o))
                break;
            bt += At - (1 << vt - _t[Et]),
            _t[Et] = o
        }
        for (bt >>>= St; bt > 0; ) {
            var Pt = b[h].s;
            _t[Pt] < o ? bt -= 1 << o - _t[Pt]++ - 1 : ++h
        }
        for (; h >= 0 && bt; --h) {
            var It = b[h].s;
            _t[It] == o && (--_t[It],
            ++bt)
        }
        vt = o
    }
    return [new fflate_module_u8(_t), vt]
}
  , fflate_module_ln = function(d, o, c) {
    return d.s == -1 ? Math.max(fflate_module_ln(d.l, o, c + 1), fflate_module_ln(d.r, o, c + 1)) : o[d.s] = c
}
  , fflate_module_lc = function(d) {
    for (var o = d.length; o && !d[--o]; )
        ;
    for (var c = new fflate_module_u16(++o), h = 0, _ = d[0], b = 1, _e = function(it) {
        c[h++] = it
    }, nt = 1; nt <= o; ++nt)
        if (d[nt] == _ && nt != o)
            ++b;
        else {
            if (!_ && b > 2) {
                for (; b > 138; b -= 138)
                    _e(32754);
                b > 2 && (_e(b > 10 ? b - 11 << 5 | 28690 : b - 3 << 5 | 12305),
                b = 0)
            } else if (b > 3) {
                for (_e(_),
                --b; b > 6; b -= 6)
                    _e(8304);
                b > 2 && (_e(b - 3 << 5 | 8208),
                b = 0)
            }
            for (; b--; )
                _e(_);
            b = 1,
            _ = d[nt]
        }
    return [c.subarray(0, h), o]
}
  , fflate_module_clen = function(d, o) {
    for (var c = 0, h = 0; h < o.length; ++h)
        c += d[h] * o[h];
    return c
}
  , fflate_module_wfblk = function(d, o, c) {
    var h = c.length
      , _ = fflate_module_shft(o + 2);
    d[_] = 255 & h,
    d[_ + 1] = h >>> 8,
    d[_ + 2] = 255 ^ d[_],
    d[_ + 3] = 255 ^ d[_ + 1];
    for (var b = 0; b < h; ++b)
        d[_ + b + 4] = c[b];
    return 8 * (_ + 4 + h)
}
  , fflate_module_wblk = function(d, o, c, h, _, b, _e, nt, it, at, ut) {
    fflate_module_wbits(o, ut++, c),
    ++_[256];
    for (var pt = fflate_module_hTree(_, 15), ht = pt[0], _t = pt[1], vt = fflate_module_hTree(b, 15), bt = vt[0], St = vt[1], At = fflate_module_lc(ht), Et = At[0], Pt = At[1], It = fflate_module_lc(bt), Dt = It[0], Gt = It[1], Bt = new fflate_module_u16(19), kt = 0; kt < Et.length; ++kt)
        Bt[31 & Et[kt]]++;
    for (kt = 0; kt < Dt.length; ++kt)
        Bt[31 & Dt[kt]]++;
    for (var Ut = fflate_module_hTree(Bt, 7), Ht = Ut[0], Kt = Ut[1], Jt = 19; Jt > 4 && !Ht[fflate_module_clim[Jt - 1]]; --Jt)
        ;
    var or, ir, lr, ar, hr = at + 5 << 3, gr = fflate_module_clen(_, fflate_module_flt) + fflate_module_clen(b, fflate_module_fdt) + _e, dr = fflate_module_clen(_, ht) + fflate_module_clen(b, bt) + _e + 14 + 3 * Jt + fflate_module_clen(Bt, Ht) + (2 * Bt[16] + 3 * Bt[17] + 7 * Bt[18]);
    if (hr <= gr && hr <= dr)
        return fflate_module_wfblk(o, ut, d.subarray(it, it + at));
    if (fflate_module_wbits(o, ut, 1 + (dr < gr)),
    ut += 2,
    dr < gr) {
        or = fflate_module_hMap(ht, _t, 0),
        ir = ht,
        lr = fflate_module_hMap(bt, St, 0),
        ar = bt;
        var cr = fflate_module_hMap(Ht, Kt, 0);
        for (fflate_module_wbits(o, ut, Pt - 257),
        fflate_module_wbits(o, ut + 5, Gt - 1),
        fflate_module_wbits(o, ut + 10, Jt - 4),
        ut += 14,
        kt = 0; kt < Jt; ++kt)
            fflate_module_wbits(o, ut + 3 * kt, Ht[fflate_module_clim[kt]]);
        ut += 3 * Jt;
        for (var Ar = [Et, Dt], wr = 0; wr < 2; ++wr) {
            var Rr = Ar[wr];
            for (kt = 0; kt < Rr.length; ++kt) {
                var Cr = 31 & Rr[kt];
                fflate_module_wbits(o, ut, cr[Cr]),
                ut += Ht[Cr],
                Cr > 15 && (fflate_module_wbits(o, ut, Rr[kt] >>> 5 & 127),
                ut += Rr[kt] >>> 12)
            }
        }
    } else
        or = fflate_module_flm,
        ir = fflate_module_flt,
        lr = fflate_module_fdm,
        ar = fflate_module_fdt;
    for (kt = 0; kt < nt; ++kt)
        if (h[kt] > 255) {
            Cr = h[kt] >>> 18 & 31,
            fflate_module_wbits16(o, ut, or[Cr + 257]),
            ut += ir[Cr + 257],
            Cr > 7 && (fflate_module_wbits(o, ut, h[kt] >>> 23 & 31),
            ut += fflate_module_fleb[Cr]);
            var tr = 31 & h[kt];
            fflate_module_wbits16(o, ut, lr[tr]),
            ut += ar[tr],
            tr > 3 && (fflate_module_wbits16(o, ut, h[kt] >>> 5 & 8191),
            ut += fflate_module_fdeb[tr])
        } else
            fflate_module_wbits16(o, ut, or[h[kt]]),
            ut += ir[h[kt]];
    return fflate_module_wbits16(o, ut, or[256]),
    ut + ir[256]
}
  , fflate_module_deo = new fflate_module_u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632])
  , fflate_module_et = new fflate_module_u8(0)
  , fflate_module_dflt = function(d, o, c, h, _, b) {
    var _e = d.length
      , nt = new fflate_module_u8(h + _e + 5 * (1 + Math.ceil(_e / 7e3)) + _)
      , it = nt.subarray(h, nt.length - _)
      , at = 0;
    if (!o || _e < 8)
        for (var ut = 0; ut <= _e; ut += 65535) {
            var pt = ut + 65535;
            pt < _e ? at = fflate_module_wfblk(it, at, d.subarray(ut, pt)) : (it[ut] = b,
            at = fflate_module_wfblk(it, at, d.subarray(ut, _e)))
        }
    else {
        for (var ht = fflate_module_deo[o - 1], _t = ht >>> 13, vt = 8191 & ht, bt = (1 << c) - 1, St = new fflate_module_u16(32768), At = new fflate_module_u16(bt + 1), Et = Math.ceil(c / 3), Pt = 2 * Et, It = function(Wn) {
            return (d[Wn] ^ d[Wn + 1] << Et ^ d[Wn + 2] << Pt) & bt
        }, Dt = new fflate_module_u32(25e3), Gt = new fflate_module_u16(288), Bt = new fflate_module_u16(32), kt = 0, Ut = 0, Ht = (ut = 0,
        0), Kt = 0, Jt = 0; ut < _e; ++ut) {
            var or = It(ut)
              , ir = 32767 & ut
              , lr = At[or];
            if (St[ir] = lr,
            At[or] = ir,
            Kt <= ut) {
                var ar = _e - ut;
                if ((kt > 7e3 || Ht > 24576) && ar > 423) {
                    at = fflate_module_wblk(d, it, 0, Dt, Gt, Bt, Ut, Ht, Jt, ut - Jt, at),
                    Ht = kt = Ut = 0,
                    Jt = ut;
                    for (var hr = 0; hr < 286; ++hr)
                        Gt[hr] = 0;
                    for (hr = 0; hr < 30; ++hr)
                        Bt[hr] = 0
                }
                var gr = 2
                  , dr = 0
                  , cr = vt
                  , Ar = ir - lr & 32767;
                if (ar > 2 && or == It(ut - Ar))
                    for (var wr = Math.min(_t, ar) - 1, Rr = Math.min(32767, ut), Cr = Math.min(258, ar); Ar <= Rr && --cr && ir != lr; ) {
                        if (d[ut + gr] == d[ut + gr - Ar]) {
                            for (var tr = 0; tr < Cr && d[ut + tr] == d[ut + tr - Ar]; ++tr)
                                ;
                            if (tr > gr) {
                                if (gr = tr,
                                dr = Ar,
                                tr > wr)
                                    break;
                                var fr = Math.min(Ar, tr - 2)
                                  , vr = 0;
                                for (hr = 0; hr < fr; ++hr) {
                                    var Zr = ut - Ar + hr + 32768 & 32767
                                      , rn = Zr - St[Zr] + 32768 & 32767;
                                    rn > vr && (vr = rn,
                                    lr = Zr)
                                }
                            }
                        }
                        Ar += (ir = lr) - (lr = St[ir]) + 32768 & 32767
                    }
                if (dr) {
                    Dt[Ht++] = 268435456 | fflate_module_revfl[gr] << 18 | fflate_module_revfd[dr];
                    var hn = 31 & fflate_module_revfl[gr]
                      , Nn = 31 & fflate_module_revfd[dr];
                    Ut += fflate_module_fleb[hn] + fflate_module_fdeb[Nn],
                    ++Gt[257 + hn],
                    ++Bt[Nn],
                    Kt = ut + gr,
                    ++kt
                } else
                    Dt[Ht++] = d[ut],
                    ++Gt[d[ut]]
            }
        }
        at = fflate_module_wblk(d, it, b, Dt, Gt, Bt, Ut, Ht, Jt, ut - Jt, at)
    }
    return fflate_module_slc(nt, 0, h + fflate_module_shft(at) + _)
}
  , fflate_module_adler = function() {
    var d = 1
      , o = 0;
    return {
        p: function(c) {
            for (var h = d, _ = o, b = c.length, _e = 0; _e != b; ) {
                for (var nt = Math.min(_e + 2655, b); _e < nt; ++_e)
                    _ += h += c[_e];
                h = (65535 & h) + 15 * (h >> 16),
                _ = (65535 & _) + 15 * (_ >> 16)
            }
            d = h,
            o = _
        },
        d: function() {
            return (255 & (d %= 65521)) << 24 | d >>> 8 << 16 | (255 & (o %= 65521)) << 8 | o >>> 8
        }
    }
}
  , fflate_module_dopt = function(d, o, c, h, _) {
    return fflate_module_dflt(d, o.level == null ? 6 : o.level, o.mem == null ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(d.length)))) : 12 + o.mem, c, h, !_)
}
  , fflate_module_wbytes = function(d, o, c) {
    for (; c; ++o)
        d[o] = c,
        c >>>= 8
}
  , fflate_module_zlh = function(d, o) {
    var c = o.level
      , h = c == 0 ? 0 : c < 6 ? 1 : c == 9 ? 3 : 2;
    d[0] = 120,
    d[1] = h << 6 | (h ? 32 - 2 * h : 1)
}
  , fflate_module_zlv = function(d) {
    if ((15 & d[0]) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31)
        throw "invalid zlib data";
    if (32 & d[1])
        throw "invalid zlib data: preset dictionaries not supported"
};
function fflate_module_zlibSync(d, o) {
    o || (o = {});
    var c = fflate_module_adler();
    c.p(d);
    var h = fflate_module_dopt(d, o, 2, 4);
    return fflate_module_zlh(h, o),
    fflate_module_wbytes(h, h.length - 4, c.d()),
    h
}
function fflate_module_unzlibSync(d, o) {
    return fflate_module_inflt((fflate_module_zlv(d),
    d.subarray(2, -4)), o)
}
typeof TextEncoder < "u" && new TextEncoder;
var fflate_module_td = typeof TextDecoder < "u" && new TextDecoder
  , fflate_module_tds = 0;
try {
    fflate_module_td.decode(fflate_module_et, {
        stream: !0
    }),
    fflate_module_tds = 1
} catch (d) {}
function findSpan(d, o, c) {
    const h = c.length - d - 1;
    if (o >= c[h])
        return h - 1;
    if (o <= c[d])
        return d;
    let _ = d
      , b = h
      , _e = Math.floor((_ + b) / 2);
    for (; o < c[_e] || o >= c[_e + 1]; )
        o < c[_e] ? b = _e : _ = _e,
        _e = Math.floor((_ + b) / 2);
    return _e
}
function calcBasisFunctions(d, o, c, h) {
    const _ = []
      , b = []
      , _e = [];
    _[0] = 1;
    for (let nt = 1; nt <= c; ++nt) {
        b[nt] = o - h[d + 1 - nt],
        _e[nt] = h[d + nt] - o;
        let it = 0;
        for (let at = 0; at < nt; ++at) {
            const ut = _e[at + 1]
              , pt = b[nt - at]
              , ht = _[at] / (ut + pt);
            _[at] = it + ut * ht,
            it = pt * ht
        }
        _[nt] = it
    }
    return _
}
function calcBSplinePoint(d, o, c, h) {
    const _ = findSpan(d, h, o)
      , b = calcBasisFunctions(_, h, d, o)
      , _e = new three_module.IUQ(0,0,0,0);
    for (let nt = 0; nt <= d; ++nt) {
        const it = c[_ - d + nt]
          , at = b[nt]
          , ut = it.w * at;
        _e.x += it.x * ut,
        _e.y += it.y * ut,
        _e.z += it.z * ut,
        _e.w += it.w * at
    }
    return _e
}
function calcBasisFunctionDerivatives(d, o, c, h, _) {
    const b = [];
    for (let pt = 0; pt <= c; ++pt)
        b[pt] = 0;
    const _e = [];
    for (let pt = 0; pt <= h; ++pt)
        _e[pt] = b.slice(0);
    const nt = [];
    for (let pt = 0; pt <= c; ++pt)
        nt[pt] = b.slice(0);
    nt[0][0] = 1;
    const it = b.slice(0)
      , at = b.slice(0);
    for (let pt = 1; pt <= c; ++pt) {
        it[pt] = o - _[d + 1 - pt],
        at[pt] = _[d + pt] - o;
        let ht = 0;
        for (let _t = 0; _t < pt; ++_t) {
            const vt = at[_t + 1]
              , bt = it[pt - _t];
            nt[pt][_t] = vt + bt;
            const St = nt[_t][pt - 1] / nt[pt][_t];
            nt[_t][pt] = ht + vt * St,
            ht = bt * St
        }
        nt[pt][pt] = ht
    }
    for (let pt = 0; pt <= c; ++pt)
        _e[0][pt] = nt[pt][c];
    for (let pt = 0; pt <= c; ++pt) {
        let ht = 0
          , _t = 1;
        const vt = [];
        for (let bt = 0; bt <= c; ++bt)
            vt[bt] = b.slice(0);
        vt[0][0] = 1;
        for (let bt = 1; bt <= h; ++bt) {
            let St = 0;
            const At = pt - bt
              , Et = c - bt;
            pt >= bt && (vt[_t][0] = vt[ht][0] / nt[Et + 1][At],
            St = vt[_t][0] * nt[At][Et]);
            const Pt = pt - 1 <= Et ? bt - 1 : c - pt;
            for (let Dt = At >= -1 ? 1 : -At; Dt <= Pt; ++Dt)
                vt[_t][Dt] = (vt[ht][Dt] - vt[ht][Dt - 1]) / nt[Et + 1][At + Dt],
                St += vt[_t][Dt] * nt[At + Dt][Et];
            pt <= Et && (vt[_t][bt] = -vt[ht][bt - 1] / nt[Et + 1][pt],
            St += vt[_t][bt] * nt[pt][Et]),
            _e[bt][pt] = St;
            const It = ht;
            ht = _t,
            _t = It
        }
    }
    let ut = c;
    for (let pt = 1; pt <= h; ++pt) {
        for (let ht = 0; ht <= c; ++ht)
            _e[pt][ht] *= ut;
        ut *= c - pt
    }
    return _e
}
function calcBSplineDerivatives(d, o, c, h, _) {
    const b = _ < d ? _ : d
      , _e = []
      , nt = findSpan(d, h, o)
      , it = calcBasisFunctionDerivatives(nt, h, d, b, o)
      , at = [];
    for (let ut = 0; ut < c.length; ++ut) {
        const pt = c[ut].clone()
          , ht = pt.w;
        pt.x *= ht,
        pt.y *= ht,
        pt.z *= ht,
        at[ut] = pt
    }
    for (let ut = 0; ut <= b; ++ut) {
        const pt = at[nt - d].clone().multiplyScalar(it[ut][0]);
        for (let ht = 1; ht <= d; ++ht)
            pt.add(at[nt - d + ht].clone().multiplyScalar(it[ut][ht]));
        _e[ut] = pt
    }
    for (let ut = b + 1; ut <= _ + 1; ++ut)
        _e[ut] = new three_module.IUQ(0,0,0);
    return _e
}
function calcKoverI(d, o) {
    let c = 1;
    for (let _ = 2; _ <= d; ++_)
        c *= _;
    let h = 1;
    for (let _ = 2; _ <= o; ++_)
        h *= _;
    for (let _ = 2; _ <= d - o; ++_)
        h *= _;
    return c / h
}
function calcRationalCurveDerivatives(d) {
    const o = d.length
      , c = []
      , h = [];
    for (let b = 0; b < o; ++b) {
        const _e = d[b];
        c[b] = new three_module.Pq0(_e.x,_e.y,_e.z),
        h[b] = _e.w
    }
    const _ = [];
    for (let b = 0; b < o; ++b) {
        const _e = c[b].clone();
        for (let nt = 1; nt <= b; ++nt)
            _e.sub(_[b - nt].clone().multiplyScalar(calcKoverI(b, nt) * h[nt]));
        _[b] = _e.divideScalar(h[0])
    }
    return _
}
function calcNURBSDerivatives(d, o, c, h, _) {
    return calcRationalCurveDerivatives(calcBSplineDerivatives(d, o, c, h, _))
}
class NURBSCurve extends three_module.Ipv {
    constructor(o, c, h, _, b) {
        super(),
        this.degree = o,
        this.knots = c,
        this.controlPoints = [],
        this.startKnot = _ || 0,
        this.endKnot = b || this.knots.length - 1;
        for (let _e = 0; _e < h.length; ++_e) {
            const nt = h[_e];
            this.controlPoints[_e] = new three_module.IUQ(nt.x,nt.y,nt.z,nt.w)
        }
    }
    getPoint(o, c=new three_module.Pq0) {
        const h = c
          , _ = this.knots[this.startKnot] + o * (this.knots[this.endKnot] - this.knots[this.startKnot])
          , b = calcBSplinePoint(this.degree, this.knots, this.controlPoints, _);
        return b.w !== 1 && b.divideScalar(b.w),
        h.set(b.x, b.y, b.z)
    }
    getTangent(o, c=new three_module.Pq0) {
        const h = c
          , _ = this.knots[0] + o * (this.knots[this.knots.length - 1] - this.knots[0])
          , b = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, _, 1);
        return h.copy(b[1]).normalize(),
        h
    }
}
let fbxTree, connections, sceneGraph;
class FBXLoader extends three_module.aHM {
    constructor(o) {
        super(o)
    }
    load(o, c, h, _) {
        const b = this
          , _e = b.path === "" ? three_module.r6x.extractUrlBase(o) : b.path
          , nt = new three_module.Y9S(this.manager);
        nt.setPath(b.path),
        nt.setResponseType("arraybuffer"),
        nt.setRequestHeader(b.requestHeader),
        nt.setWithCredentials(b.withCredentials),
        nt.load(o, function(it) {
            try {
                c(b.parse(it, _e))
            } catch (at) {
                _ ? _(at) : console.error(at),
                b.manager.itemError(o)
            }
        }, h, _)
    }
    parse(o, c) {
        if (isFbxFormatBinary(o))
            fbxTree = new BinaryParser().parse(o);
        else {
            const b = convertArrayBufferToString(o);
            if (!isFbxFormatASCII(b))
                throw new Error("THREE.FBXLoader: Unknown format.");
            if (getFbxVersion(b) < 7e3)
                throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + getFbxVersion(b));
            fbxTree = new TextParser().parse(b)
        }
        const h = new three_module.Tap(this.manager).setPath(this.resourcePath || c).setCrossOrigin(this.crossOrigin)
          , _ = new FBXTreeParser(h,this.manager).parse(fbxTree);
        return fbxTree = null,
        connections = null,
        sceneGraph = null,
        _
    }
}
class FBXTreeParser {
    constructor(o, c) {
        this.textureLoader = o,
        this.manager = c
    }
    parse() {
        connections = this.parseConnections();
        const o = this.parseImages()
          , c = this.parseTextures(o)
          , h = this.parseMaterials(c)
          , _ = this.parseDeformers()
          , b = new GeometryParser().parse(_);
        return this.parseScene(_, b, h),
        sceneGraph
    }
    parseConnections() {
        const o = new Map;
        return "Connections"in fbxTree && fbxTree.Connections.connections.forEach(function(c) {
            const h = c[0]
              , _ = c[1]
              , b = c[2];
            o.has(h) || o.set(h, {
                parents: [],
                children: []
            });
            const _e = {
                ID: _,
                relationship: b
            };
            o.get(h).parents.push(_e),
            o.has(_) || o.set(_, {
                parents: [],
                children: []
            });
            const nt = {
                ID: h,
                relationship: b
            };
            o.get(_).children.push(nt)
        }),
        o
    }
    parseImages() {
        const o = {}
          , c = {};
        if ("Video"in fbxTree.Objects) {
            const h = fbxTree.Objects.Video;
            for (const _ in h) {
                const b = h[_];
                if (o[parseInt(_)] = b.RelativeFilename || b.Filename,
                "Content"in b) {
                    const _e = b.Content instanceof ArrayBuffer && b.Content.byteLength > 0
                      , nt = typeof b.Content == "string" && b.Content !== "";
                    if (_e || nt) {
                        const it = this.parseImage(h[_]);
                        c[b.RelativeFilename || b.Filename] = it
                    }
                }
            }
        }
        for (const h in o) {
            const _ = o[h];
            c[_] !== void 0 ? o[h] = c[_] : o[h] = o[h].split("\\").pop()
        }
        return o
    }
    parseImage(o) {
        const c = o.Content
          , h = o.RelativeFilename || o.Filename
          , _ = h.slice(h.lastIndexOf(".") + 1).toLowerCase();
        let b;
        switch (_) {
        case "bmp":
            b = "image/bmp";
            break;
        case "jpg":
        case "jpeg":
            b = "image/jpeg";
            break;
        case "png":
            b = "image/png";
            break;
        case "tif":
            b = "image/tiff";
            break;
        case "tga":
            this.manager.getHandler(".tga") === null && console.warn("FBXLoader: TGA loader not found, skipping ", h),
            b = "image/tga";
            break;
        default:
            return void console.warn('FBXLoader: Image type "' + _ + '" is not supported.')
        }
        if (typeof c == "string")
            return "data:" + b + ";base64," + c;
        {
            const _e = new Uint8Array(c);
            return window.URL.createObjectURL(new Blob([_e],{
                type: b
            }))
        }
    }
    parseTextures(o) {
        const c = new Map;
        if ("Texture"in fbxTree.Objects) {
            const h = fbxTree.Objects.Texture;
            for (const _ in h) {
                const b = this.parseTexture(h[_], o);
                c.set(parseInt(_), b)
            }
        }
        return c
    }
    parseTexture(o, c) {
        const h = this.loadTexture(o, c);
        h.ID = o.id,
        h.name = o.attrName;
        const _ = o.WrapModeU
          , b = o.WrapModeV
          , _e = _ !== void 0 ? _.value : 0
          , nt = b !== void 0 ? b.value : 0;
        if (h.wrapS = _e === 0 ? three_module.GJx : three_module.ghU,
        h.wrapT = nt === 0 ? three_module.GJx : three_module.ghU,
        "Scaling"in o) {
            const it = o.Scaling.value;
            h.repeat.x = it[0],
            h.repeat.y = it[1]
        }
        if ("Translation"in o) {
            const it = o.Translation.value;
            h.offset.x = it[0],
            h.offset.y = it[1]
        }
        return h
    }
    loadTexture(o, c) {
        let h;
        const _ = this.textureLoader.path
          , b = connections.get(o.id).children;
        let _e;
        b !== void 0 && b.length > 0 && c[b[0].ID] !== void 0 && (h = c[b[0].ID],
        h.indexOf("blob:") !== 0 && h.indexOf("data:") !== 0 || this.textureLoader.setPath(void 0));
        const nt = o.FileName.slice(-3).toLowerCase();
        if (nt === "tga") {
            const it = this.manager.getHandler(".tga");
            it === null ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", o.RelativeFilename),
            _e = new three_module.gPd) : (it.setPath(this.textureLoader.path),
            _e = it.load(h))
        } else
            nt === "psd" ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", o.RelativeFilename),
            _e = new three_module.gPd) : _e = this.textureLoader.load(h);
        return this.textureLoader.setPath(_),
        _e
    }
    parseMaterials(o) {
        const c = new Map;
        if ("Material"in fbxTree.Objects) {
            const h = fbxTree.Objects.Material;
            for (const _ in h) {
                const b = this.parseMaterial(h[_], o);
                b !== null && c.set(parseInt(_), b)
            }
        }
        return c
    }
    parseMaterial(o, c) {
        const h = o.id
          , _ = o.attrName;
        let b = o.ShadingModel;
        if (typeof b == "object" && (b = b.value),
        !connections.has(h))
            return null;
        const _e = this.parseParameters(o, c, h);
        let nt;
        switch (b.toLowerCase()) {
        case "phong":
            nt = new three_module.tXL;
            break;
        case "lambert":
            nt = new three_module.G_z;
            break;
        default:
            console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', b),
            nt = new three_module.tXL
        }
        return nt.setValues(_e),
        nt.name = _,
        nt
    }
    parseParameters(o, c, h) {
        const _ = {};
        o.BumpFactor && (_.bumpScale = o.BumpFactor.value),
        o.Diffuse ? _.color = new three_module.Q1f().fromArray(o.Diffuse.value).convertSRGBToLinear() : !o.DiffuseColor || o.DiffuseColor.type !== "Color" && o.DiffuseColor.type !== "ColorRGB" || (_.color = new three_module.Q1f().fromArray(o.DiffuseColor.value).convertSRGBToLinear()),
        o.DisplacementFactor && (_.displacementScale = o.DisplacementFactor.value),
        o.Emissive ? _.emissive = new three_module.Q1f().fromArray(o.Emissive.value).convertSRGBToLinear() : !o.EmissiveColor || o.EmissiveColor.type !== "Color" && o.EmissiveColor.type !== "ColorRGB" || (_.emissive = new three_module.Q1f().fromArray(o.EmissiveColor.value).convertSRGBToLinear()),
        o.EmissiveFactor && (_.emissiveIntensity = parseFloat(o.EmissiveFactor.value)),
        o.Opacity && (_.opacity = parseFloat(o.Opacity.value)),
        _.opacity < 1 && (_.transparent = !0),
        o.ReflectionFactor && (_.reflectivity = o.ReflectionFactor.value),
        o.Shininess && (_.shininess = o.Shininess.value),
        o.Specular ? _.specular = new three_module.Q1f().fromArray(o.Specular.value).convertSRGBToLinear() : o.SpecularColor && o.SpecularColor.type === "Color" && (_.specular = new three_module.Q1f().fromArray(o.SpecularColor.value).convertSRGBToLinear());
        const b = this;
        return connections.get(h).children.forEach(function(_e) {
            const nt = _e.relationship;
            switch (nt) {
            case "Bump":
                _.bumpMap = b.getTexture(c, _e.ID);
                break;
            case "Maya|TEX_ao_map":
                _.aoMap = b.getTexture(c, _e.ID);
                break;
            case "DiffuseColor":
            case "Maya|TEX_color_map":
                _.map = b.getTexture(c, _e.ID),
                _.map !== void 0 && (_.map.colorSpace = three_module.er$);
                break;
            case "DisplacementColor":
                _.displacementMap = b.getTexture(c, _e.ID);
                break;
            case "EmissiveColor":
                _.emissiveMap = b.getTexture(c, _e.ID),
                _.emissiveMap !== void 0 && (_.emissiveMap.colorSpace = three_module.er$);
                break;
            case "NormalMap":
            case "Maya|TEX_normal_map":
                _.normalMap = b.getTexture(c, _e.ID);
                break;
            case "ReflectionColor":
                _.envMap = b.getTexture(c, _e.ID),
                _.envMap !== void 0 && (_.envMap.mapping = three_module.wfO,
                _.envMap.colorSpace = three_module.er$);
                break;
            case "SpecularColor":
                _.specularMap = b.getTexture(c, _e.ID),
                _.specularMap !== void 0 && (_.specularMap.colorSpace = three_module.er$);
                break;
            case "TransparentColor":
            case "TransparencyFactor":
                _.alphaMap = b.getTexture(c, _e.ID),
                _.transparent = !0;
                break;
            default:
                console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", nt)
            }
        }),
        _
    }
    getTexture(o, c) {
        return "LayeredTexture"in fbxTree.Objects && c in fbxTree.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),
        c = connections.get(c).children[0].ID),
        o.get(c)
    }
    parseDeformers() {
        const o = {}
          , c = {};
        if ("Deformer"in fbxTree.Objects) {
            const h = fbxTree.Objects.Deformer;
            for (const _ in h) {
                const b = h[_]
                  , _e = connections.get(parseInt(_));
                if (b.attrType === "Skin") {
                    const nt = this.parseSkeleton(_e, h);
                    nt.ID = _,
                    _e.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),
                    nt.geometryID = _e.parents[0].ID,
                    o[_] = nt
                } else if (b.attrType === "BlendShape") {
                    const nt = {
                        id: _
                    };
                    nt.rawTargets = this.parseMorphTargets(_e, h),
                    nt.id = _,
                    _e.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),
                    c[_] = nt
                }
            }
        }
        return {
            skeletons: o,
            morphTargets: c
        }
    }
    parseSkeleton(o, c) {
        const h = [];
        return o.children.forEach(function(_) {
            const b = c[_.ID];
            if (b.attrType !== "Cluster")
                return;
            const _e = {
                ID: _.ID,
                indices: [],
                weights: [],
                transformLink: new three_module.kn4().fromArray(b.TransformLink.a)
            };
            "Indexes"in b && (_e.indices = b.Indexes.a,
            _e.weights = b.Weights.a),
            h.push(_e)
        }),
        {
            rawBones: h,
            bones: []
        }
    }
    parseMorphTargets(o, c) {
        const h = [];
        for (let _ = 0; _ < o.children.length; _++) {
            const b = o.children[_]
              , _e = c[b.ID]
              , nt = {
                name: _e.attrName,
                initialWeight: _e.DeformPercent,
                id: _e.id,
                fullWeights: _e.FullWeights.a
            };
            if (_e.attrType !== "BlendShapeChannel")
                return;
            nt.geoID = connections.get(parseInt(b.ID)).children.filter(function(it) {
                return it.relationship === void 0
            })[0].ID,
            h.push(nt)
        }
        return h
    }
    parseScene(o, c, h) {
        sceneGraph = new three_module.YJl;
        const _ = this.parseModels(o.skeletons, c, h)
          , b = fbxTree.Objects.Model
          , _e = this;
        _.forEach(function(it) {
            const at = b[it.ID];
            _e.setLookAtProperties(it, at),
            connections.get(it.ID).parents.forEach(function(ut) {
                const pt = _.get(ut.ID);
                pt !== void 0 && pt.add(it)
            }),
            it.parent === null && sceneGraph.add(it)
        }),
        this.bindSkeleton(o.skeletons, c, _),
        this.createAmbientLight(),
        sceneGraph.traverse(function(it) {
            if (it.userData.transformData) {
                it.parent && (it.userData.transformData.parentMatrix = it.parent.matrix,
                it.userData.transformData.parentMatrixWorld = it.parent.matrixWorld);
                const at = generateTransform(it.userData.transformData);
                it.applyMatrix4(at),
                it.updateWorldMatrix()
            }
        });
        const nt = new AnimationParser().parse();
        sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup && (sceneGraph.children[0].animations = nt,
        sceneGraph = sceneGraph.children[0]),
        sceneGraph.animations = nt
    }
    parseModels(o, c, h) {
        const _ = new Map
          , b = fbxTree.Objects.Model;
        for (const _e in b) {
            const nt = parseInt(_e)
              , it = b[_e]
              , at = connections.get(nt);
            let ut = this.buildSkeleton(at, o, nt, it.attrName);
            if (!ut) {
                switch (it.attrType) {
                case "Camera":
                    ut = this.createCamera(at);
                    break;
                case "Light":
                    ut = this.createLight(at);
                    break;
                case "Mesh":
                    ut = this.createMesh(at, c, h);
                    break;
                case "NurbsCurve":
                    ut = this.createCurve(at, c);
                    break;
                case "LimbNode":
                case "Root":
                    ut = new three_module.$Kf;
                    break;
                default:
                    ut = new three_module.YJl
                }
                ut.name = it.attrName ? three_module.Nwf.sanitizeNodeName(it.attrName) : "",
                ut.userData.originalName = it.attrName,
                ut.ID = nt
            }
            this.getTransformData(ut, it),
            _.set(nt, ut)
        }
        return _
    }
    buildSkeleton(o, c, h, _) {
        let b = null;
        return o.parents.forEach(function(_e) {
            for (const nt in c) {
                const it = c[nt];
                it.rawBones.forEach(function(at, ut) {
                    if (at.ID === _e.ID) {
                        const pt = b;
                        b = new three_module.$Kf,
                        b.matrixWorld.copy(at.transformLink),
                        b.name = _ ? three_module.Nwf.sanitizeNodeName(_) : "",
                        b.userData.originalName = _,
                        b.ID = h,
                        it.bones[ut] = b,
                        pt !== null && b.add(pt)
                    }
                })
            }
        }),
        b
    }
    createCamera(o) {
        let c, h;
        if (o.children.forEach(function(_) {
            const b = fbxTree.Objects.NodeAttribute[_.ID];
            b !== void 0 && (h = b)
        }),
        h === void 0)
            c = new three_module.B69;
        else {
            let _ = 0;
            h.CameraProjectionType !== void 0 && h.CameraProjectionType.value === 1 && (_ = 1);
            let b = 1;
            h.NearPlane !== void 0 && (b = h.NearPlane.value / 1e3);
            let _e = 1e3;
            h.FarPlane !== void 0 && (_e = h.FarPlane.value / 1e3);
            let nt = window.innerWidth
              , it = window.innerHeight;
            h.AspectWidth !== void 0 && h.AspectHeight !== void 0 && (nt = h.AspectWidth.value,
            it = h.AspectHeight.value);
            const at = nt / it;
            let ut = 45;
            h.FieldOfView !== void 0 && (ut = h.FieldOfView.value);
            const pt = h.FocalLength ? h.FocalLength.value : null;
            switch (_) {
            case 0:
                c = new three_module.ubm(ut,at,b,_e),
                pt !== null && c.setFocalLength(pt);
                break;
            case 1:
                c = new three_module.qUd(-nt / 2,nt / 2,it / 2,-it / 2,b,_e);
                break;
            default:
                console.warn("THREE.FBXLoader: Unknown camera type " + _ + "."),
                c = new three_module.B69
            }
        }
        return c
    }
    createLight(o) {
        let c, h;
        if (o.children.forEach(function(_) {
            const b = fbxTree.Objects.NodeAttribute[_.ID];
            b !== void 0 && (h = b)
        }),
        h === void 0)
            c = new three_module.B69;
        else {
            let _;
            _ = h.LightType === void 0 ? 0 : h.LightType.value;
            let b = 16777215;
            h.Color !== void 0 && (b = new three_module.Q1f().fromArray(h.Color.value).convertSRGBToLinear());
            let _e = h.Intensity === void 0 ? 1 : h.Intensity.value / 100;
            h.CastLightOnObject !== void 0 && h.CastLightOnObject.value === 0 && (_e = 0);
            let nt = 0;
            h.FarAttenuationEnd !== void 0 && (nt = h.EnableFarAttenuation !== void 0 && h.EnableFarAttenuation.value === 0 ? 0 : h.FarAttenuationEnd.value);
            const it = 1;
            switch (_) {
            case 0:
                c = new three_module.HiM(b,_e,nt,it);
                break;
            case 1:
                c = new three_module.ZyN(b,_e);
                break;
            case 2:
                let at = Math.PI / 3;
                h.InnerAngle !== void 0 && (at = three_module.cj9.degToRad(h.InnerAngle.value));
                let ut = 0;
                h.OuterAngle !== void 0 && (ut = three_module.cj9.degToRad(h.OuterAngle.value),
                ut = Math.max(ut, 1)),
                c = new three_module.nCl(b,_e,nt,at,ut,it);
                break;
            default:
                console.warn("THREE.FBXLoader: Unknown light type " + h.LightType.value + ", defaulting to a PointLight."),
                c = new three_module.HiM(b,_e)
            }
            h.CastShadows !== void 0 && h.CastShadows.value === 1 && (c.castShadow = !0)
        }
        return c
    }
    createMesh(o, c, h) {
        let _, b = null, _e = null;
        const nt = [];
        return o.children.forEach(function(it) {
            c.has(it.ID) && (b = c.get(it.ID)),
            h.has(it.ID) && nt.push(h.get(it.ID))
        }),
        nt.length > 1 ? _e = nt : nt.length > 0 ? _e = nt[0] : (_e = new three_module.tXL({
            name: three_module.aHM.DEFAULT_MATERIAL_NAME,
            color: 13421772
        }),
        nt.push(_e)),
        "color"in b.attributes && nt.forEach(function(it) {
            it.vertexColors = !0
        }),
        b.FBX_Deformer ? (_ = new three_module.I46(b,_e),
        _.normalizeSkinWeights()) : _ = new three_module.eaF(b,_e),
        _
    }
    createCurve(o, c) {
        const h = o.children.reduce(function(b, _e) {
            return c.has(_e.ID) && (b = c.get(_e.ID)),
            b
        }, null)
          , _ = new three_module.mrM({
            name: three_module.aHM.DEFAULT_MATERIAL_NAME,
            color: 3342591,
            linewidth: 1
        });
        return new three_module.N1A(h,_)
    }
    getTransformData(o, c) {
        const h = {};
        "InheritType"in c && (h.inheritType = parseInt(c.InheritType.value)),
        h.eulerOrder = "RotationOrder"in c ? getEulerOrder(c.RotationOrder.value) : "ZYX",
        "Lcl_Translation"in c && (h.translation = c.Lcl_Translation.value),
        "PreRotation"in c && (h.preRotation = c.PreRotation.value),
        "Lcl_Rotation"in c && (h.rotation = c.Lcl_Rotation.value),
        "PostRotation"in c && (h.postRotation = c.PostRotation.value),
        "Lcl_Scaling"in c && (h.scale = c.Lcl_Scaling.value),
        "ScalingOffset"in c && (h.scalingOffset = c.ScalingOffset.value),
        "ScalingPivot"in c && (h.scalingPivot = c.ScalingPivot.value),
        "RotationOffset"in c && (h.rotationOffset = c.RotationOffset.value),
        "RotationPivot"in c && (h.rotationPivot = c.RotationPivot.value),
        o.userData.transformData = h
    }
    setLookAtProperties(o, c) {
        "LookAtProperty"in c && connections.get(o.ID).children.forEach(function(h) {
            if (h.relationship === "LookAtProperty") {
                const _ = fbxTree.Objects.Model[h.ID];
                if ("Lcl_Translation"in _) {
                    const b = _.Lcl_Translation.value;
                    o.target !== void 0 ? (o.target.position.fromArray(b),
                    sceneGraph.add(o.target)) : o.lookAt(new three_module.Pq0().fromArray(b))
                }
            }
        })
    }
    bindSkeleton(o, c, h) {
        const _ = this.parsePoseNodes();
        for (const b in o) {
            const _e = o[b];
            connections.get(parseInt(_e.ID)).parents.forEach(function(nt) {
                if (c.has(nt.ID)) {
                    const it = nt.ID;
                    connections.get(it).parents.forEach(function(at) {
                        h.has(at.ID) && h.get(at.ID).bind(new three_module.EAD(_e.bones), _[at.ID])
                    })
                }
            })
        }
    }
    parsePoseNodes() {
        const o = {};
        if ("Pose"in fbxTree.Objects) {
            const c = fbxTree.Objects.Pose;
            for (const h in c)
                if (c[h].attrType === "BindPose" && c[h].NbPoseNodes > 0) {
                    const _ = c[h].PoseNode;
                    Array.isArray(_) ? _.forEach(function(b) {
                        o[b.Node] = new three_module.kn4().fromArray(b.Matrix.a)
                    }) : o[_.Node] = new three_module.kn4().fromArray(_.Matrix.a)
                }
        }
        return o
    }
    createAmbientLight() {
        if ("GlobalSettings"in fbxTree && "AmbientColor"in fbxTree.GlobalSettings) {
            const o = fbxTree.GlobalSettings.AmbientColor.value
              , c = o[0]
              , h = o[1]
              , _ = o[2];
            if (c !== 0 || h !== 0 || _ !== 0) {
                const b = new three_module.Q1f(c,h,_).convertSRGBToLinear();
                sceneGraph.add(new three_module.$p8(b,1))
            }
        }
    }
}
class GeometryParser {
    constructor() {
        this.negativeMaterialIndices = !1
    }
    parse(o) {
        const c = new Map;
        if ("Geometry"in fbxTree.Objects) {
            const h = fbxTree.Objects.Geometry;
            for (const _ in h) {
                const b = connections.get(parseInt(_))
                  , _e = this.parseGeometry(b, h[_], o);
                c.set(parseInt(_), _e)
            }
        }
        return this.negativeMaterialIndices === !0 && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),
        c
    }
    parseGeometry(o, c, h) {
        switch (c.attrType) {
        case "Mesh":
            return this.parseMeshGeometry(o, c, h);
        case "NurbsCurve":
            return this.parseNurbsGeometry(c)
        }
    }
    parseMeshGeometry(o, c, h) {
        const _ = h.skeletons
          , b = []
          , _e = o.parents.map(function(pt) {
            return fbxTree.Objects.Model[pt.ID]
        });
        if (_e.length === 0)
            return;
        const nt = o.children.reduce(function(pt, ht) {
            return _[ht.ID] !== void 0 && (pt = _[ht.ID]),
            pt
        }, null);
        o.children.forEach(function(pt) {
            h.morphTargets[pt.ID] !== void 0 && b.push(h.morphTargets[pt.ID])
        });
        const it = _e[0]
          , at = {};
        "RotationOrder"in it && (at.eulerOrder = getEulerOrder(it.RotationOrder.value)),
        "InheritType"in it && (at.inheritType = parseInt(it.InheritType.value)),
        "GeometricTranslation"in it && (at.translation = it.GeometricTranslation.value),
        "GeometricRotation"in it && (at.rotation = it.GeometricRotation.value),
        "GeometricScaling"in it && (at.scale = it.GeometricScaling.value);
        const ut = generateTransform(at);
        return this.genGeometry(c, nt, b, ut)
    }
    genGeometry(o, c, h, _) {
        const b = new three_module.LoY;
        o.attrName && (b.name = o.attrName);
        const _e = this.parseGeoNode(o, c)
          , nt = this.genBuffers(_e)
          , it = new three_module.qtW(nt.vertex,3);
        if (it.applyMatrix4(_),
        b.setAttribute("position", it),
        nt.colors.length > 0 && b.setAttribute("color", new three_module.qtW(nt.colors,3)),
        c && (b.setAttribute("skinIndex", new three_module.A$4(nt.weightsIndices,4)),
        b.setAttribute("skinWeight", new three_module.qtW(nt.vertexWeights,4)),
        b.FBX_Deformer = c),
        nt.normal.length > 0) {
            const at = new three_module.dwI().getNormalMatrix(_)
              , ut = new three_module.qtW(nt.normal,3);
            ut.applyNormalMatrix(at),
            b.setAttribute("normal", ut)
        }
        if (nt.uvs.forEach(function(at, ut) {
            const pt = ut === 0 ? "uv" : `uv${ut}`;
            b.setAttribute(pt, new three_module.qtW(nt.uvs[ut],2))
        }),
        _e.material && _e.material.mappingType !== "AllSame") {
            let at = nt.materialIndex[0]
              , ut = 0;
            if (nt.materialIndex.forEach(function(pt, ht) {
                pt !== at && (b.addGroup(ut, ht - ut, at),
                at = pt,
                ut = ht)
            }),
            b.groups.length > 0) {
                const pt = b.groups[b.groups.length - 1]
                  , ht = pt.start + pt.count;
                ht !== nt.materialIndex.length && b.addGroup(ht, nt.materialIndex.length - ht, at)
            }
            b.groups.length === 0 && b.addGroup(0, nt.materialIndex.length, nt.materialIndex[0])
        }
        return this.addMorphTargets(b, o, h, _),
        b
    }
    parseGeoNode(o, c) {
        const h = {};
        if (h.vertexPositions = o.Vertices !== void 0 ? o.Vertices.a : [],
        h.vertexIndices = o.PolygonVertexIndex !== void 0 ? o.PolygonVertexIndex.a : [],
        o.LayerElementColor && (h.color = this.parseVertexColors(o.LayerElementColor[0])),
        o.LayerElementMaterial && (h.material = this.parseMaterialIndices(o.LayerElementMaterial[0])),
        o.LayerElementNormal && (h.normal = this.parseNormals(o.LayerElementNormal[0])),
        o.LayerElementUV) {
            h.uv = [];
            let _ = 0;
            for (; o.LayerElementUV[_]; )
                o.LayerElementUV[_].UV && h.uv.push(this.parseUVs(o.LayerElementUV[_])),
                _++
        }
        return h.weightTable = {},
        c !== null && (h.skeleton = c,
        c.rawBones.forEach(function(_, b) {
            _.indices.forEach(function(_e, nt) {
                h.weightTable[_e] === void 0 && (h.weightTable[_e] = []),
                h.weightTable[_e].push({
                    id: b,
                    weight: _.weights[nt]
                })
            })
        })),
        h
    }
    genBuffers(o) {
        const c = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: []
        };
        let h = 0
          , _ = 0
          , b = !1
          , _e = []
          , nt = []
          , it = []
          , at = []
          , ut = []
          , pt = [];
        const ht = this;
        return o.vertexIndices.forEach(function(_t, vt) {
            let bt, St = !1;
            _t < 0 && (_t = ~_t,
            St = !0);
            let At = []
              , Et = [];
            if (_e.push(3 * _t, 3 * _t + 1, 3 * _t + 2),
            o.color) {
                const Pt = getData(vt, h, _t, o.color);
                it.push(Pt[0], Pt[1], Pt[2])
            }
            if (o.skeleton) {
                if (o.weightTable[_t] !== void 0 && o.weightTable[_t].forEach(function(Pt) {
                    Et.push(Pt.weight),
                    At.push(Pt.id)
                }),
                Et.length > 4) {
                    b || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),
                    b = !0);
                    const Pt = [0, 0, 0, 0]
                      , It = [0, 0, 0, 0];
                    Et.forEach(function(Dt, Gt) {
                        let Bt = Dt
                          , kt = At[Gt];
                        It.forEach(function(Ut, Ht, Kt) {
                            if (Bt > Ut) {
                                Kt[Ht] = Bt,
                                Bt = Ut;
                                const Jt = Pt[Ht];
                                Pt[Ht] = kt,
                                kt = Jt
                            }
                        })
                    }),
                    At = Pt,
                    Et = It
                }
                for (; Et.length < 4; )
                    Et.push(0),
                    At.push(0);
                for (let Pt = 0; Pt < 4; ++Pt)
                    ut.push(Et[Pt]),
                    pt.push(At[Pt])
            }
            if (o.normal) {
                const Pt = getData(vt, h, _t, o.normal);
                nt.push(Pt[0], Pt[1], Pt[2])
            }
            o.material && o.material.mappingType !== "AllSame" && (bt = getData(vt, h, _t, o.material)[0],
            bt < 0 && (ht.negativeMaterialIndices = !0,
            bt = 0)),
            o.uv && o.uv.forEach(function(Pt, It) {
                const Dt = getData(vt, h, _t, Pt);
                at[It] === void 0 && (at[It] = []),
                at[It].push(Dt[0]),
                at[It].push(Dt[1])
            }),
            _++,
            St && (_ > 4 && console.warn("THREE.FBXLoader: Polygons with more than four sides are not supported. Make sure to triangulate the geometry during export."),
            ht.genFace(c, o, _e, bt, nt, it, at, ut, pt, _),
            h++,
            _ = 0,
            _e = [],
            nt = [],
            it = [],
            at = [],
            ut = [],
            pt = [])
        }),
        c
    }
    genFace(o, c, h, _, b, _e, nt, it, at, ut) {
        for (let pt = 2; pt < ut; pt++)
            o.vertex.push(c.vertexPositions[h[0]]),
            o.vertex.push(c.vertexPositions[h[1]]),
            o.vertex.push(c.vertexPositions[h[2]]),
            o.vertex.push(c.vertexPositions[h[3 * (pt - 1)]]),
            o.vertex.push(c.vertexPositions[h[3 * (pt - 1) + 1]]),
            o.vertex.push(c.vertexPositions[h[3 * (pt - 1) + 2]]),
            o.vertex.push(c.vertexPositions[h[3 * pt]]),
            o.vertex.push(c.vertexPositions[h[3 * pt + 1]]),
            o.vertex.push(c.vertexPositions[h[3 * pt + 2]]),
            c.skeleton && (o.vertexWeights.push(it[0]),
            o.vertexWeights.push(it[1]),
            o.vertexWeights.push(it[2]),
            o.vertexWeights.push(it[3]),
            o.vertexWeights.push(it[4 * (pt - 1)]),
            o.vertexWeights.push(it[4 * (pt - 1) + 1]),
            o.vertexWeights.push(it[4 * (pt - 1) + 2]),
            o.vertexWeights.push(it[4 * (pt - 1) + 3]),
            o.vertexWeights.push(it[4 * pt]),
            o.vertexWeights.push(it[4 * pt + 1]),
            o.vertexWeights.push(it[4 * pt + 2]),
            o.vertexWeights.push(it[4 * pt + 3]),
            o.weightsIndices.push(at[0]),
            o.weightsIndices.push(at[1]),
            o.weightsIndices.push(at[2]),
            o.weightsIndices.push(at[3]),
            o.weightsIndices.push(at[4 * (pt - 1)]),
            o.weightsIndices.push(at[4 * (pt - 1) + 1]),
            o.weightsIndices.push(at[4 * (pt - 1) + 2]),
            o.weightsIndices.push(at[4 * (pt - 1) + 3]),
            o.weightsIndices.push(at[4 * pt]),
            o.weightsIndices.push(at[4 * pt + 1]),
            o.weightsIndices.push(at[4 * pt + 2]),
            o.weightsIndices.push(at[4 * pt + 3])),
            c.color && (o.colors.push(_e[0]),
            o.colors.push(_e[1]),
            o.colors.push(_e[2]),
            o.colors.push(_e[3 * (pt - 1)]),
            o.colors.push(_e[3 * (pt - 1) + 1]),
            o.colors.push(_e[3 * (pt - 1) + 2]),
            o.colors.push(_e[3 * pt]),
            o.colors.push(_e[3 * pt + 1]),
            o.colors.push(_e[3 * pt + 2])),
            c.material && c.material.mappingType !== "AllSame" && (o.materialIndex.push(_),
            o.materialIndex.push(_),
            o.materialIndex.push(_)),
            c.normal && (o.normal.push(b[0]),
            o.normal.push(b[1]),
            o.normal.push(b[2]),
            o.normal.push(b[3 * (pt - 1)]),
            o.normal.push(b[3 * (pt - 1) + 1]),
            o.normal.push(b[3 * (pt - 1) + 2]),
            o.normal.push(b[3 * pt]),
            o.normal.push(b[3 * pt + 1]),
            o.normal.push(b[3 * pt + 2])),
            c.uv && c.uv.forEach(function(ht, _t) {
                o.uvs[_t] === void 0 && (o.uvs[_t] = []),
                o.uvs[_t].push(nt[_t][0]),
                o.uvs[_t].push(nt[_t][1]),
                o.uvs[_t].push(nt[_t][2 * (pt - 1)]),
                o.uvs[_t].push(nt[_t][2 * (pt - 1) + 1]),
                o.uvs[_t].push(nt[_t][2 * pt]),
                o.uvs[_t].push(nt[_t][2 * pt + 1])
            })
    }
    addMorphTargets(o, c, h, _) {
        if (h.length === 0)
            return;
        o.morphTargetsRelative = !0,
        o.morphAttributes.position = [];
        const b = this;
        h.forEach(function(_e) {
            _e.rawTargets.forEach(function(nt) {
                const it = fbxTree.Objects.Geometry[nt.geoID];
                it !== void 0 && b.genMorphGeometry(o, c, it, _, nt.name)
            })
        })
    }
    genMorphGeometry(o, c, h, _, b) {
        const _e = c.PolygonVertexIndex !== void 0 ? c.PolygonVertexIndex.a : []
          , nt = h.Vertices !== void 0 ? h.Vertices.a : []
          , it = h.Indexes !== void 0 ? h.Indexes.a : []
          , at = 3 * o.attributes.position.count
          , ut = new Float32Array(at);
        for (let vt = 0; vt < it.length; vt++) {
            const bt = 3 * it[vt];
            ut[bt] = nt[3 * vt],
            ut[bt + 1] = nt[3 * vt + 1],
            ut[bt + 2] = nt[3 * vt + 2]
        }
        const pt = {
            vertexIndices: _e,
            vertexPositions: ut
        }
          , ht = this.genBuffers(pt)
          , _t = new three_module.qtW(ht.vertex,3);
        _t.name = b || h.attrName,
        _t.applyMatrix4(_),
        o.morphAttributes.position.push(_t)
    }
    parseNormals(o) {
        const c = o.MappingInformationType
          , h = o.ReferenceInformationType
          , _ = o.Normals.a;
        let b = [];
        return h === "IndexToDirect" && ("NormalIndex"in o ? b = o.NormalIndex.a : "NormalsIndex"in o && (b = o.NormalsIndex.a)),
        {
            dataSize: 3,
            buffer: _,
            indices: b,
            mappingType: c,
            referenceType: h
        }
    }
    parseUVs(o) {
        const c = o.MappingInformationType
          , h = o.ReferenceInformationType
          , _ = o.UV.a;
        let b = [];
        return h === "IndexToDirect" && (b = o.UVIndex.a),
        {
            dataSize: 2,
            buffer: _,
            indices: b,
            mappingType: c,
            referenceType: h
        }
    }
    parseVertexColors(o) {
        const c = o.MappingInformationType
          , h = o.ReferenceInformationType
          , _ = o.Colors.a;
        let b = [];
        h === "IndexToDirect" && (b = o.ColorIndex.a);
        for (let _e = 0, nt = new three_module.Q1f; _e < _.length; _e += 4)
            nt.fromArray(_, _e).convertSRGBToLinear().toArray(_, _e);
        return {
            dataSize: 4,
            buffer: _,
            indices: b,
            mappingType: c,
            referenceType: h
        }
    }
    parseMaterialIndices(o) {
        const c = o.MappingInformationType
          , h = o.ReferenceInformationType;
        if (c === "NoMappingInformation")
            return {
                dataSize: 1,
                buffer: [0],
                indices: [0],
                mappingType: "AllSame",
                referenceType: h
            };
        const _ = o.Materials.a
          , b = [];
        for (let _e = 0; _e < _.length; ++_e)
            b.push(_e);
        return {
            dataSize: 1,
            buffer: _,
            indices: b,
            mappingType: c,
            referenceType: h
        }
    }
    parseNurbsGeometry(o) {
        const c = parseInt(o.Order);
        if (isNaN(c))
            return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", o.Order, o.id),
            new three_module.LoY;
        const h = c - 1
          , _ = o.KnotVector.a
          , b = []
          , _e = o.Points.a;
        for (let ut = 0, pt = _e.length; ut < pt; ut += 4)
            b.push(new three_module.IUQ().fromArray(_e, ut));
        let nt, it;
        if (o.Form === "Closed")
            b.push(b[0]);
        else if (o.Form === "Periodic") {
            nt = h,
            it = _.length - 1 - nt;
            for (let ut = 0; ut < h; ++ut)
                b.push(b[ut])
        }
        const at = new NURBSCurve(h,_,b,nt,it).getPoints(12 * b.length);
        return new three_module.LoY().setFromPoints(at)
    }
}
class AnimationParser {
    parse() {
        const o = []
          , c = this.parseClips();
        if (c !== void 0)
            for (const h in c) {
                const _ = c[h]
                  , b = this.addClip(_);
                o.push(b)
            }
        return o
    }
    parseClips() {
        if (fbxTree.Objects.AnimationCurve === void 0)
            return;
        const o = this.parseAnimationCurveNodes();
        this.parseAnimationCurves(o);
        const c = this.parseAnimationLayers(o);
        return this.parseAnimStacks(c)
    }
    parseAnimationCurveNodes() {
        const o = fbxTree.Objects.AnimationCurveNode
          , c = new Map;
        for (const h in o) {
            const _ = o[h];
            if (_.attrName.match(/S|R|T|DeformPercent/) !== null) {
                const b = {
                    id: _.id,
                    attr: _.attrName,
                    curves: {}
                };
                c.set(b.id, b)
            }
        }
        return c
    }
    parseAnimationCurves(o) {
        const c = fbxTree.Objects.AnimationCurve;
        for (const h in c) {
            const _ = {
                id: c[h].id,
                times: c[h].KeyTime.a.map(convertFBXTimeToSeconds),
                values: c[h].KeyValueFloat.a
            }
              , b = connections.get(_.id);
            if (b !== void 0) {
                const _e = b.parents[0].ID
                  , nt = b.parents[0].relationship;
                nt.match(/X/) ? o.get(_e).curves.x = _ : nt.match(/Y/) ? o.get(_e).curves.y = _ : nt.match(/Z/) ? o.get(_e).curves.z = _ : nt.match(/DeformPercent/) && o.has(_e) && (o.get(_e).curves.morph = _)
            }
        }
    }
    parseAnimationLayers(o) {
        const c = fbxTree.Objects.AnimationLayer
          , h = new Map;
        for (const _ in c) {
            const b = []
              , _e = connections.get(parseInt(_));
            _e !== void 0 && (_e.children.forEach(function(nt, it) {
                if (o.has(nt.ID)) {
                    const at = o.get(nt.ID);
                    if (at.curves.x !== void 0 || at.curves.y !== void 0 || at.curves.z !== void 0) {
                        if (b[it] === void 0) {
                            const ut = connections.get(nt.ID).parents.filter(function(pt) {
                                return pt.relationship !== void 0
                            })[0].ID;
                            if (ut !== void 0) {
                                const pt = fbxTree.Objects.Model[ut.toString()];
                                if (pt === void 0)
                                    return void console.warn("THREE.FBXLoader: Encountered a unused curve.", nt);
                                const ht = {
                                    modelName: pt.attrName ? three_module.Nwf.sanitizeNodeName(pt.attrName) : "",
                                    ID: pt.id,
                                    initialPosition: [0, 0, 0],
                                    initialRotation: [0, 0, 0],
                                    initialScale: [1, 1, 1]
                                };
                                sceneGraph.traverse(function(_t) {
                                    _t.ID === pt.id && (ht.transform = _t.matrix,
                                    _t.userData.transformData && (ht.eulerOrder = _t.userData.transformData.eulerOrder))
                                }),
                                ht.transform || (ht.transform = new three_module.kn4),
                                "PreRotation"in pt && (ht.preRotation = pt.PreRotation.value),
                                "PostRotation"in pt && (ht.postRotation = pt.PostRotation.value),
                                b[it] = ht
                            }
                        }
                        b[it] && (b[it][at.attr] = at)
                    } else if (at.curves.morph !== void 0) {
                        if (b[it] === void 0) {
                            const ut = connections.get(nt.ID).parents.filter(function(St) {
                                return St.relationship !== void 0
                            })[0].ID
                              , pt = connections.get(ut).parents[0].ID
                              , ht = connections.get(pt).parents[0].ID
                              , _t = connections.get(ht).parents[0].ID
                              , vt = fbxTree.Objects.Model[_t]
                              , bt = {
                                modelName: vt.attrName ? three_module.Nwf.sanitizeNodeName(vt.attrName) : "",
                                morphName: fbxTree.Objects.Deformer[ut].attrName
                            };
                            b[it] = bt
                        }
                        b[it][at.attr] = at
                    }
                }
            }),
            h.set(parseInt(_), b))
        }
        return h
    }
    parseAnimStacks(o) {
        const c = fbxTree.Objects.AnimationStack
          , h = {};
        for (const _ in c) {
            const b = connections.get(parseInt(_)).children;
            b.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
            const _e = o.get(b[0].ID);
            h[_] = {
                name: c[_].attrName,
                layer: _e
            }
        }
        return h
    }
    addClip(o) {
        let c = [];
        const h = this;
        return o.layer.forEach(function(_) {
            c = c.concat(h.generateTracks(_))
        }),
        new three_module.tz3(o.name,-1,c)
    }
    generateTracks(o) {
        const c = [];
        let h = new three_module.Pq0
          , _ = new three_module.PTz
          , b = new three_module.Pq0;
        if (o.transform && o.transform.decompose(h, _, b),
        h = h.toArray(),
        _ = new three_module.O9p().setFromQuaternion(_, o.eulerOrder).toArray(),
        b = b.toArray(),
        o.T !== void 0 && Object.keys(o.T.curves).length > 0) {
            const _e = this.generateVectorTrack(o.modelName, o.T.curves, h, "position");
            _e !== void 0 && c.push(_e)
        }
        if (o.R !== void 0 && Object.keys(o.R.curves).length > 0) {
            const _e = this.generateRotationTrack(o.modelName, o.R.curves, _, o.preRotation, o.postRotation, o.eulerOrder);
            _e !== void 0 && c.push(_e)
        }
        if (o.S !== void 0 && Object.keys(o.S.curves).length > 0) {
            const _e = this.generateVectorTrack(o.modelName, o.S.curves, b, "scale");
            _e !== void 0 && c.push(_e)
        }
        if (o.DeformPercent !== void 0) {
            const _e = this.generateMorphTrack(o);
            _e !== void 0 && c.push(_e)
        }
        return c
    }
    generateVectorTrack(o, c, h, _) {
        const b = this.getTimesForAllAxes(c)
          , _e = this.getKeyframeTrackValues(b, c, h);
        return new three_module.RiT(o + "." + _,b,_e)
    }
    generateRotationTrack(o, c, h, _, b, _e) {
        c.x !== void 0 && (this.interpolateRotations(c.x),
        c.x.values = c.x.values.map(three_module.cj9.degToRad)),
        c.y !== void 0 && (this.interpolateRotations(c.y),
        c.y.values = c.y.values.map(three_module.cj9.degToRad)),
        c.z !== void 0 && (this.interpolateRotations(c.z),
        c.z.values = c.z.values.map(three_module.cj9.degToRad));
        const nt = this.getTimesForAllAxes(c)
          , it = this.getKeyframeTrackValues(nt, c, h);
        _ !== void 0 && ((_ = _.map(three_module.cj9.degToRad)).push(_e),
        _ = new three_module.O9p().fromArray(_),
        _ = new three_module.PTz().setFromEuler(_)),
        b !== void 0 && ((b = b.map(three_module.cj9.degToRad)).push(_e),
        b = new three_module.O9p().fromArray(b),
        b = new three_module.PTz().setFromEuler(b).invert());
        const at = new three_module.PTz
          , ut = new three_module.O9p
          , pt = [];
        for (let ht = 0; ht < it.length; ht += 3)
            ut.set(it[ht], it[ht + 1], it[ht + 2], _e),
            at.setFromEuler(ut),
            _ !== void 0 && at.premultiply(_),
            b !== void 0 && at.multiply(b),
            at.toArray(pt, ht / 3 * 4);
        return new three_module.MBL(o + ".quaternion",nt,pt)
    }
    generateMorphTrack(o) {
        const c = o.DeformPercent.curves.morph
          , h = c.values.map(function(b) {
            return b / 100
        })
          , _ = sceneGraph.getObjectByName(o.modelName).morphTargetDictionary[o.morphName];
        return new three_module.Hit(o.modelName + ".morphTargetInfluences[" + _ + "]",c.times,h)
    }
    getTimesForAllAxes(o) {
        let c = [];
        if (o.x !== void 0 && (c = c.concat(o.x.times)),
        o.y !== void 0 && (c = c.concat(o.y.times)),
        o.z !== void 0 && (c = c.concat(o.z.times)),
        c = c.sort(function(h, _) {
            return h - _
        }),
        c.length > 1) {
            let h = 1
              , _ = c[0];
            for (let b = 1; b < c.length; b++) {
                const _e = c[b];
                _e !== _ && (c[h] = _e,
                _ = _e,
                h++)
            }
            c = c.slice(0, h)
        }
        return c
    }
    getKeyframeTrackValues(o, c, h) {
        const _ = h
          , b = [];
        let _e = -1
          , nt = -1
          , it = -1;
        return o.forEach(function(at) {
            if (c.x && (_e = c.x.times.indexOf(at)),
            c.y && (nt = c.y.times.indexOf(at)),
            c.z && (it = c.z.times.indexOf(at)),
            _e !== -1) {
                const ut = c.x.values[_e];
                b.push(ut),
                _[0] = ut
            } else
                b.push(_[0]);
            if (nt !== -1) {
                const ut = c.y.values[nt];
                b.push(ut),
                _[1] = ut
            } else
                b.push(_[1]);
            if (it !== -1) {
                const ut = c.z.values[it];
                b.push(ut),
                _[2] = ut
            } else
                b.push(_[2])
        }),
        b
    }
    interpolateRotations(o) {
        for (let c = 1; c < o.values.length; c++) {
            const h = o.values[c - 1]
              , _ = o.values[c] - h
              , b = Math.abs(_);
            if (b >= 180) {
                const _e = b / 180
                  , nt = _ / _e;
                let it = h + nt;
                const at = o.times[c - 1]
                  , ut = (o.times[c] - at) / _e;
                let pt = at + ut;
                const ht = []
                  , _t = [];
                for (; pt < o.times[c]; )
                    ht.push(pt),
                    pt += ut,
                    _t.push(it),
                    it += nt;
                o.times = inject(o.times, c, ht),
                o.values = inject(o.values, c, _t)
            }
        }
    }
}
class TextParser {
    getPrevNode() {
        return this.nodeStack[this.currentIndent - 2]
    }
    getCurrentNode() {
        return this.nodeStack[this.currentIndent - 1]
    }
    getCurrentProp() {
        return this.currentProp
    }
    pushStack(o) {
        this.nodeStack.push(o),
        this.currentIndent += 1
    }
    popStack() {
        this.nodeStack.pop(),
        this.currentIndent -= 1
    }
    setCurrentProp(o, c) {
        this.currentProp = o,
        this.currentPropName = c
    }
    parse(o) {
        this.currentIndent = 0,
        this.allNodes = new FBXTree,
        this.nodeStack = [],
        this.currentProp = [],
        this.currentPropName = "";
        const c = this
          , h = o.split(/[\r\n]+/);
        return h.forEach(function(_, b) {
            const _e = _.match(/^[\s\t]*;/)
              , nt = _.match(/^[\s\t]*$/);
            if (_e || nt)
                return;
            const it = _.match("^\\t{" + c.currentIndent + "}(\\w+):(.*){", "")
              , at = _.match("^\\t{" + c.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)")
              , ut = _.match("^\\t{" + (c.currentIndent - 1) + "}}");
            it ? c.parseNodeBegin(_, it) : at ? c.parseNodeProperty(_, at, h[++b]) : ut ? c.popStack() : _.match(/^[^\s\t}]/) && c.parseNodePropertyContinued(_)
        }),
        this.allNodes
    }
    parseNodeBegin(o, c) {
        const h = c[1].trim().replace(/^"/, "").replace(/"$/, "")
          , _ = c[2].split(",").map(function(it) {
            return it.trim().replace(/^"/, "").replace(/"$/, "")
        })
          , b = {
            name: h
        }
          , _e = this.parseNodeAttr(_)
          , nt = this.getCurrentNode();
        this.currentIndent === 0 ? this.allNodes.add(h, b) : h in nt ? (h === "PoseNode" ? nt.PoseNode.push(b) : nt[h].id !== void 0 && (nt[h] = {},
        nt[h][nt[h].id] = nt[h]),
        _e.id !== "" && (nt[h][_e.id] = b)) : typeof _e.id == "number" ? (nt[h] = {},
        nt[h][_e.id] = b) : h !== "Properties70" && (nt[h] = h === "PoseNode" ? [b] : b),
        typeof _e.id == "number" && (b.id = _e.id),
        _e.name !== "" && (b.attrName = _e.name),
        _e.type !== "" && (b.attrType = _e.type),
        this.pushStack(b)
    }
    parseNodeAttr(o) {
        let c = o[0];
        o[0] !== "" && (c = parseInt(o[0]),
        isNaN(c) && (c = o[0]));
        let h = ""
          , _ = "";
        return o.length > 1 && (h = o[1].replace(/^(\w+)::/, ""),
        _ = o[2]),
        {
            id: c,
            name: h,
            type: _
        }
    }
    parseNodeProperty(o, c, h) {
        let _ = c[1].replace(/^"/, "").replace(/"$/, "").trim()
          , b = c[2].replace(/^"/, "").replace(/"$/, "").trim();
        _ === "Content" && b === "," && (b = h.replace(/"/g, "").replace(/,$/, "").trim());
        const _e = this.getCurrentNode();
        if (_e.name !== "Properties70") {
            if (_ === "C") {
                const nt = b.split(",").slice(1)
                  , it = parseInt(nt[0])
                  , at = parseInt(nt[1]);
                let ut = b.split(",").slice(3);
                ut = ut.map(function(pt) {
                    return pt.trim().replace(/^"/, "")
                }),
                _ = "connections",
                b = [it, at],
                append(b, ut),
                _e[_] === void 0 && (_e[_] = [])
            }
            _ === "Node" && (_e.id = b),
            _ in _e && Array.isArray(_e[_]) ? _e[_].push(b) : _ !== "a" ? _e[_] = b : _e.a = b,
            this.setCurrentProp(_e, _),
            _ === "a" && b.slice(-1) !== "," && (_e.a = parseNumberArray(b))
        } else
            this.parseNodeSpecialProperty(o, _, b)
    }
    parseNodePropertyContinued(o) {
        const c = this.getCurrentNode();
        c.a += o,
        o.slice(-1) !== "," && (c.a = parseNumberArray(c.a))
    }
    parseNodeSpecialProperty(o, c, h) {
        const _ = h.split('",').map(function(ut) {
            return ut.trim().replace(/^\"/, "").replace(/\s/, "_")
        })
          , b = _[0]
          , _e = _[1]
          , nt = _[2]
          , it = _[3];
        let at = _[4];
        switch (_e) {
        case "int":
        case "enum":
        case "bool":
        case "ULongLong":
        case "double":
        case "Number":
        case "FieldOfView":
            at = parseFloat(at);
            break;
        case "Color":
        case "ColorRGB":
        case "Vector3D":
        case "Lcl_Translation":
        case "Lcl_Rotation":
        case "Lcl_Scaling":
            at = parseNumberArray(at)
        }
        this.getPrevNode()[b] = {
            type: _e,
            type2: nt,
            flag: it,
            value: at
        },
        this.setCurrentProp(this.getPrevNode(), b)
    }
}
class BinaryParser {
    parse(o) {
        const c = new BinaryReader(o);
        c.skip(23);
        const h = c.getUint32();
        if (h < 6400)
            throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + h);
        const _ = new FBXTree;
        for (; !this.endOfContent(c); ) {
            const b = this.parseNode(c, h);
            b !== null && _.add(b.name, b)
        }
        return _
    }
    endOfContent(o) {
        return o.size() % 16 == 0 ? (o.getOffset() + 160 + 16 & -16) >= o.size() : o.getOffset() + 160 + 16 >= o.size()
    }
    parseNode(o, c) {
        const h = {}
          , _ = c >= 7500 ? o.getUint64() : o.getUint32()
          , b = c >= 7500 ? o.getUint64() : o.getUint32();
        c >= 7500 ? o.getUint64() : o.getUint32();
        const _e = o.getUint8()
          , nt = o.getString(_e);
        if (_ === 0)
            return null;
        const it = [];
        for (let ht = 0; ht < b; ht++)
            it.push(this.parseProperty(o));
        const at = it.length > 0 ? it[0] : ""
          , ut = it.length > 1 ? it[1] : ""
          , pt = it.length > 2 ? it[2] : "";
        for (h.singleProperty = b === 1 && o.getOffset() === _; _ > o.getOffset(); ) {
            const ht = this.parseNode(o, c);
            ht !== null && this.parseSubNode(nt, h, ht)
        }
        return h.propertyList = it,
        typeof at == "number" && (h.id = at),
        ut !== "" && (h.attrName = ut),
        pt !== "" && (h.attrType = pt),
        nt !== "" && (h.name = nt),
        h
    }
    parseSubNode(o, c, h) {
        if (h.singleProperty === !0) {
            const _ = h.propertyList[0];
            Array.isArray(_) ? (c[h.name] = h,
            h.a = _) : c[h.name] = _
        } else if (o === "Connections" && h.name === "C") {
            const _ = [];
            h.propertyList.forEach(function(b, _e) {
                _e !== 0 && _.push(b)
            }),
            c.connections === void 0 && (c.connections = []),
            c.connections.push(_)
        } else if (h.name === "Properties70")
            Object.keys(h).forEach(function(_) {
                c[_] = h[_]
            });
        else if (o === "Properties70" && h.name === "P") {
            let _ = h.propertyList[0]
              , b = h.propertyList[1];
            const _e = h.propertyList[2]
              , nt = h.propertyList[3];
            let it;
            _.indexOf("Lcl ") === 0 && (_ = _.replace("Lcl ", "Lcl_")),
            b.indexOf("Lcl ") === 0 && (b = b.replace("Lcl ", "Lcl_")),
            it = b === "Color" || b === "ColorRGB" || b === "Vector" || b === "Vector3D" || b.indexOf("Lcl_") === 0 ? [h.propertyList[4], h.propertyList[5], h.propertyList[6]] : h.propertyList[4],
            c[_] = {
                type: b,
                type2: _e,
                flag: nt,
                value: it
            }
        } else
            c[h.name] === void 0 ? typeof h.id == "number" ? (c[h.name] = {},
            c[h.name][h.id] = h) : c[h.name] = h : h.name === "PoseNode" ? (Array.isArray(c[h.name]) || (c[h.name] = [c[h.name]]),
            c[h.name].push(h)) : c[h.name][h.id] === void 0 && (c[h.name][h.id] = h)
    }
    parseProperty(o) {
        const c = o.getString(1);
        let h;
        switch (c) {
        case "C":
            return o.getBoolean();
        case "D":
            return o.getFloat64();
        case "F":
            return o.getFloat32();
        case "I":
            return o.getInt32();
        case "L":
            return o.getInt64();
        case "R":
            return h = o.getUint32(),
            o.getArrayBuffer(h);
        case "S":
            return h = o.getUint32(),
            o.getString(h);
        case "Y":
            return o.getInt16();
        case "b":
        case "c":
        case "d":
        case "f":
        case "i":
        case "l":
            const _ = o.getUint32()
              , b = o.getUint32()
              , _e = o.getUint32();
            if (b === 0)
                switch (c) {
                case "b":
                case "c":
                    return o.getBooleanArray(_);
                case "d":
                    return o.getFloat64Array(_);
                case "f":
                    return o.getFloat32Array(_);
                case "i":
                    return o.getInt32Array(_);
                case "l":
                    return o.getInt64Array(_)
                }
            const nt = fflate_module_unzlibSync(new Uint8Array(o.getArrayBuffer(_e)))
              , it = new BinaryReader(nt.buffer);
            switch (c) {
            case "b":
            case "c":
                return it.getBooleanArray(_);
            case "d":
                return it.getFloat64Array(_);
            case "f":
                return it.getFloat32Array(_);
            case "i":
                return it.getInt32Array(_);
            case "l":
                return it.getInt64Array(_)
            }
            break;
        default:
            throw new Error("THREE.FBXLoader: Unknown property type " + c)
        }
    }
}
class BinaryReader {
    constructor(o, c) {
        this.dv = new DataView(o),
        this.offset = 0,
        this.littleEndian = c === void 0 || c,
        this._textDecoder = new TextDecoder
    }
    getOffset() {
        return this.offset
    }
    size() {
        return this.dv.buffer.byteLength
    }
    skip(o) {
        this.offset += o
    }
    getBoolean() {
        return !(1 & ~this.getUint8())
    }
    getBooleanArray(o) {
        const c = [];
        for (let h = 0; h < o; h++)
            c.push(this.getBoolean());
        return c
    }
    getUint8() {
        const o = this.dv.getUint8(this.offset);
        return this.offset += 1,
        o
    }
    getInt16() {
        const o = this.dv.getInt16(this.offset, this.littleEndian);
        return this.offset += 2,
        o
    }
    getInt32() {
        const o = this.dv.getInt32(this.offset, this.littleEndian);
        return this.offset += 4,
        o
    }
    getInt32Array(o) {
        const c = [];
        for (let h = 0; h < o; h++)
            c.push(this.getInt32());
        return c
    }
    getUint32() {
        const o = this.dv.getUint32(this.offset, this.littleEndian);
        return this.offset += 4,
        o
    }
    getInt64() {
        let o, c;
        return this.littleEndian ? (o = this.getUint32(),
        c = this.getUint32()) : (c = this.getUint32(),
        o = this.getUint32()),
        2147483648 & c ? (c = 4294967295 & ~c,
        o = 4294967295 & ~o,
        o === 4294967295 && (c = c + 1 & 4294967295),
        o = o + 1 & 4294967295,
        -(4294967296 * c + o)) : 4294967296 * c + o
    }
    getInt64Array(o) {
        const c = [];
        for (let h = 0; h < o; h++)
            c.push(this.getInt64());
        return c
    }
    getUint64() {
        let o, c;
        return this.littleEndian ? (o = this.getUint32(),
        c = this.getUint32()) : (c = this.getUint32(),
        o = this.getUint32()),
        4294967296 * c + o
    }
    getFloat32() {
        const o = this.dv.getFloat32(this.offset, this.littleEndian);
        return this.offset += 4,
        o
    }
    getFloat32Array(o) {
        const c = [];
        for (let h = 0; h < o; h++)
            c.push(this.getFloat32());
        return c
    }
    getFloat64() {
        const o = this.dv.getFloat64(this.offset, this.littleEndian);
        return this.offset += 8,
        o
    }
    getFloat64Array(o) {
        const c = [];
        for (let h = 0; h < o; h++)
            c.push(this.getFloat64());
        return c
    }
    getArrayBuffer(o) {
        const c = this.dv.buffer.slice(this.offset, this.offset + o);
        return this.offset += o,
        c
    }
    getString(o) {
        const c = this.offset;
        let h = new Uint8Array(this.dv.buffer,c,o);
        this.skip(o);
        const _ = h.indexOf(0);
        return _ >= 0 && (h = new Uint8Array(this.dv.buffer,c,_)),
        this._textDecoder.decode(h)
    }
}
class FBXTree {
    add(o, c) {
        this[o] = c
    }
}
function isFbxFormatBinary(d) {
    return d.byteLength >= 21 && convertArrayBufferToString(d, 0, 21) === "Kaydara FBX Binary  \0"
}
function isFbxFormatASCII(d) {
    const o = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
    let c = 0;
    function h(_) {
        const b = d[_ - 1];
        return d = d.slice(c + _),
        c++,
        b
    }
    for (let _ = 0; _ < o.length; ++_)
        if (h(1) === o[_])
            return !1;
    return !0
}
function getFbxVersion(d) {
    const o = d.match(/FBXVersion: (\d+)/);
    if (o)
        return parseInt(o[1]);
    throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
}
function convertFBXTimeToSeconds(d) {
    return d / 46186158e3
}
const dataArray = [];
function getData(d, o, c, h) {
    let _;
    switch (h.mappingType) {
    case "ByPolygonVertex":
        _ = d;
        break;
    case "ByPolygon":
        _ = o;
        break;
    case "ByVertice":
        _ = c;
        break;
    case "AllSame":
        _ = h.indices[0];
        break;
    default:
        console.warn("THREE.FBXLoader: unknown attribute mapping type " + h.mappingType)
    }
    h.referenceType === "IndexToDirect" && (_ = h.indices[_]);
    const b = _ * h.dataSize
      , _e = b + h.dataSize;
    return slice(dataArray, h.buffer, b, _e)
}
const tempEuler = new three_module.O9p
  , FBXLoader_tempVec = new three_module.Pq0;
function generateTransform(d) {
    const o = new three_module.kn4
      , c = new three_module.kn4
      , h = new three_module.kn4
      , _ = new three_module.kn4
      , b = new three_module.kn4
      , _e = new three_module.kn4
      , nt = new three_module.kn4
      , it = new three_module.kn4
      , at = new three_module.kn4
      , ut = new three_module.kn4
      , pt = new three_module.kn4
      , ht = new three_module.kn4
      , _t = d.inheritType ? d.inheritType : 0;
    if (d.translation && o.setPosition(FBXLoader_tempVec.fromArray(d.translation)),
    d.preRotation) {
        const Ht = d.preRotation.map(three_module.cj9.degToRad);
        Ht.push(d.eulerOrder || three_module.O9p.DEFAULT_ORDER),
        c.makeRotationFromEuler(tempEuler.fromArray(Ht))
    }
    if (d.rotation) {
        const Ht = d.rotation.map(three_module.cj9.degToRad);
        Ht.push(d.eulerOrder || three_module.O9p.DEFAULT_ORDER),
        h.makeRotationFromEuler(tempEuler.fromArray(Ht))
    }
    if (d.postRotation) {
        const Ht = d.postRotation.map(three_module.cj9.degToRad);
        Ht.push(d.eulerOrder || three_module.O9p.DEFAULT_ORDER),
        _.makeRotationFromEuler(tempEuler.fromArray(Ht)),
        _.invert()
    }
    d.scale && b.scale(FBXLoader_tempVec.fromArray(d.scale)),
    d.scalingOffset && nt.setPosition(FBXLoader_tempVec.fromArray(d.scalingOffset)),
    d.scalingPivot && _e.setPosition(FBXLoader_tempVec.fromArray(d.scalingPivot)),
    d.rotationOffset && it.setPosition(FBXLoader_tempVec.fromArray(d.rotationOffset)),
    d.rotationPivot && at.setPosition(FBXLoader_tempVec.fromArray(d.rotationPivot)),
    d.parentMatrixWorld && (pt.copy(d.parentMatrix),
    ut.copy(d.parentMatrixWorld));
    const vt = c.clone().multiply(h).multiply(_)
      , bt = new three_module.kn4;
    bt.extractRotation(ut);
    const St = new three_module.kn4;
    St.copyPosition(ut);
    const At = St.clone().invert().multiply(ut)
      , Et = bt.clone().invert().multiply(At)
      , Pt = b
      , It = new three_module.kn4;
    if (_t === 0)
        It.copy(bt).multiply(vt).multiply(Et).multiply(Pt);
    else if (_t === 1)
        It.copy(bt).multiply(Et).multiply(vt).multiply(Pt);
    else {
        const Ht = new three_module.kn4().scale(new three_module.Pq0().setFromMatrixScale(pt)).clone().invert()
          , Kt = Et.clone().multiply(Ht);
        It.copy(bt).multiply(vt).multiply(Kt).multiply(Pt)
    }
    const Dt = at.clone().invert()
      , Gt = _e.clone().invert();
    let Bt = o.clone().multiply(it).multiply(at).multiply(c).multiply(h).multiply(_).multiply(Dt).multiply(nt).multiply(_e).multiply(b).multiply(Gt);
    const kt = new three_module.kn4().copyPosition(Bt)
      , Ut = ut.clone().multiply(kt);
    return ht.copyPosition(Ut),
    Bt = ht.clone().multiply(It),
    Bt.premultiply(ut.invert()),
    Bt
}
function getEulerOrder(d) {
    const o = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
    return (d = d || 0) === 6 ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),
    o[0]) : o[d]
}
function parseNumberArray(d) {
    return d.split(",").map(function(o) {
        return parseFloat(o)
    })
}
function convertArrayBufferToString(d, o, c) {
    return o === void 0 && (o = 0),
    c === void 0 && (c = d.byteLength),
    new TextDecoder().decode(new Uint8Array(d,o,c))
}
function append(d, o) {
    for (let c = 0, h = d.length, _ = o.length; c < _; c++,
    h++)
        d[h] = o[c]
}
function slice(d, o, c, h) {
    for (let _ = c, b = 0; _ < h; _++,
    b++)
        d[b] = o[_];
    return d
}
function inject(d, o, c) {
    return d.slice(0, o).concat(c).concat(d.slice(o))
}
class FBXLoader2 extends FBXLoader {
    async loadAsync(o, c) {
        const h = three_module.gPd.DEFAULT_IMAGE;
        three_module.gPd.DEFAULT_IMAGE || (three_module.gPd.DEFAULT_IMAGE = AssetImporter.WHITE_IMAGE_DATA);
        const _ = await super.loadAsync(o, c);
        return three_module.gPd.DEFAULT_IMAGE = h,
        _
    }
}
class FBXLoadPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin],
        this._importer = new Importer(FBXLoader2,["fbx"],!0)
    }
    async onAdded(o) {
        var c, h;
        (h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.Importers.push(this._importer)
    }
    async onDispose(o) {}
    async onRemove(o) {
        var c, h, _, b;
        !((h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0) && h.Importers && ((b = (_ = o.getManager()) === null || _ === void 0 ? void 0 : _.importer) === null || b === void 0 || b.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer), 1))
    }
}
FBXLoadPlugin.PluginType = "FBXLoadPlugin";
const camera = new three_module.ubm(45,1,.1,1e3);
function snapObject(d, o, c, h=7, _=new three_module.Pq0(0,0,1.5)) {
    c = c ?? d.scene.modelObject;
    const b = new Box3B().expandByObject(c ?? o, !0, !0)
      , _e = b.getCenter(new three_module.Pq0)
      , nt = b.getSize(new three_module.Pq0);
    camera.position.copy(_e).add(_.clone().multiplyScalar(Math.max(nt.x, nt.y, nt.z))),
    camera.lookAt(_e),
    o && o.traverseVisible(ut => {
        ut.layers.enable(h)
    }
    ),
    h > 0 ? camera.layers.set(h) : camera.layers.enableAll();
    const it = o == null ? void 0 : o.visible;
    o && (o.visible = !0),
    d.renderer.rendererObject.setRenderTarget(null),
    d.renderer.rendererObject.render(c, camera);
    const at = d.renderer.rendererObject.domElement.toDataURL("image/png");
    return o && (o.visible = it,
    o.traverseVisible(ut => {
        ut.layers.disable(h)
    }
    ),
    camera.layers.enableAll()),
    d.setDirty(),
    at
}
class MaterialPreviewGenerator {
    constructor(o) {
        this.viewer = o,
        this._lights = [],
        this.shapes = {
            sphere: new three_module.eaF(new three_module.Gu$(1)),
            cube: new three_module.eaF(new three_module.iNn(1,1,1)),
            cylinder: new three_module.eaF(new three_module.Ho_(.5,.5,1))
        };
        const c = new three_module.Z58;
        this._channel = 7;
        const h = new three_module.dth(16777215,4473924,1);
        h.position.set(0, 10, 0),
        h.layers.set(this._channel),
        c.add(h),
        this._lights.push(h),
        this._scene = c
    }
    dispose() {
        [...this._lights].forEach(o => o.dispose()),
        Object.values(this.shapes).forEach(o => {
            o.geometry && o.geometry.dispose()
        }
        )
    }
    generate(o, c="sphere") {
        const h = this.shapes[c] || new three_module.eaF(new three_module.Gu$(1));
        h.material = o.materialObject,
        h.geometry.attributes.tangent || h.geometry.computeTangents(),
        this._scene.add(h),
        this._scene.environment = this.viewer.scene.environment;
        const _ = h.material.envMapIntensity;
        typeof _ == "number" && (h.material.envMapIntensity = Math.max(_, 2));
        const b = snapObject(this.viewer, h, this._scene, this._channel, new three_module.Pq0(0,0,1.5));
        return typeof _ == "number" && (h.material.envMapIntensity = _),
        this._scene.remove(h),
        h.material = void 0,
        b
    }
}
var MaterialConfiguratorBasePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class MaterialConfiguratorBasePlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this._uiNeedRefresh = !1,
        this.applyOnLoad = !0,
        this._refreshUiConfig = () => {
            var o, c;
            this.enabled && ((c = (o = this.uiConfig).uiRefresh) === null || c === void 0 || c.call(o))
        }
        ,
        this.dependencies = [AssetManagerPlugin],
        this.variations = [],
        this._selectedMaterial = () => {
            var o, c;
            return ((c = (o = this._picking) === null || o === void 0 ? void 0 : o.getSelectedObject()) === null || c === void 0 ? void 0 : c.material) || void 0
        }
        ,
        this.uiConfig = {
            label: "Material Configurator",
            type: "folder",
            children: [ () => {
                var o;
                return [{
                    type: "input",
                    label: "uuid",
                    property: [this._selectedMaterial(), "uuid"],
                    hidden: () => !this._selectedMaterial(),
                    disabled: !0
                }, {
                    type: "input",
                    label: "mapping",
                    hidden: () => !this._selectedMaterial(),
                    property: () => [this.getSelectedVariation(), "uuid"],
                    onChange: async () => this.refreshUi()
                }, {
                    type: "input",
                    label: "title",
                    hidden: () => !this._selectedMaterial(),
                    property: () => [this.getSelectedVariation(), "title"],
                    onChange: async () => this.refreshUi()
                }, {
                    type: "dropdown",
                    label: "Preview Type",
                    hidden: () => !this._selectedMaterial(),
                    property: () => [this.getSelectedVariation(), "preview"],
                    onChange: async () => this.refreshUi(),
                    children: ["generate:sphere", "generate:cube", "color", "map", "emissive", ...Object.keys(standardMaterialPropList).filter(c => c.endsWith("Map"))].map(c => ({
                        label: c,
                        value: c
                    }))
                }, ...((o = this.getSelectedVariation()) === null || o === void 0 ? void 0 : o.materials.map(c => c.uiConfig ? Object.assign(c.uiConfig, {
                    expanded: !1
                }) : {})) || [], {
                    type: "button",
                    label: "Clear variations",
                    hidden: () => !this._selectedMaterial(),
                    value: async () => {
                        const c = this.getSelectedVariation();
                        c && await this._viewer.confirm("Material configurator: Remove all variations for this material?") && (c.materials = []),
                        this.refreshUi()
                    }
                }, {
                    type: "button",
                    label: "Remove completely",
                    hidden: () => !this._selectedMaterial(),
                    value: async () => {
                        const c = this.getSelectedVariation();
                        c && await this._viewer.confirm("Material configurator: Remove this variation?") && this.removeVariation(c)
                    }
                }, {
                    type: "button",
                    label: "Add Variation",
                    hidden: () => !this._selectedMaterial(),
                    value: async () => {
                        var c;
                        const h = this._selectedMaterial();
                        h && (h.name || await ((c = this._viewer) === null || c === void 0 ? void 0 : c.confirm("Material configurator: Material has no name. Use uuid instead?"))) && this.addVariation(h)
                    }
                }, {
                    type: "button",
                    label: "Refresh Ui",
                    value: () => this.refreshUi()
                }, {
                    type: "button",
                    label: "Apply All",
                    value: () => {
                        this.variations.forEach(async c => this.applyVariation(c, c.materials[0].uuid))
                    }
                }]
            }
            ]
        },
        this.addEventListener("deserialize", this.refreshUi),
        this.refreshUi = this.refreshUi.bind(this),
        this._refreshUi = this._refreshUi.bind(this)
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        this._picking = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Picking"),
        this._previewGenerator = new MaterialPreviewGenerator(this._viewer),
        (h = this._picking) === null || h === void 0 || h.addEventListener("selectedObjectChanged", this._refreshUiConfig),
        o.addEventListener("preFrame", this._refreshUi)
    }
    reapplyAll() {
        this.variations.forEach(async o => {
            var c;
            return this.applyVariation(o, o.materials[(c = o.selectedIndex) !== null && c !== void 0 ? c : 0].uuid)
        }
        )
    }
    fromJSON(o, c) {
        return this.variations = [],
        super.fromJSON(o, c) ? (o.applyOnLoad === void 0 && (this.applyOnLoad = !1),
        this.applyOnLoad && this.reapplyAll(),
        this) : null
    }
    async onRemove(o) {
        var c, h;
        return (c = this._previewGenerator) === null || c === void 0 || c.dispose(),
        this._previewGenerator = void 0,
        (h = this._picking) === null || h === void 0 || h.removeEventListener("selectedObjectChanged", this._refreshUiConfig),
        this.removeEventListener("deserialize", this.refreshUi),
        o.removeEventListener("preFrame", this._refreshUi),
        this._picking = void 0,
        super.onRemove(o)
    }
    findVariation(o) {
        return o ? this.variations.find(c => c.uuid === o) : void 0
    }
    getSelectedVariation() {
        var o, c;
        return this.findVariation((o = this._selectedMaterial()) === null || o === void 0 ? void 0 : o.uuid) || this.findVariation((c = this._selectedMaterial()) === null || c === void 0 ? void 0 : c.name)
    }
    applyVariation(o, c) {
        var h, _;
        const b = (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getManager()) === null || _ === void 0 ? void 0 : _.materials;
        if (!b)
            return !1;
        const _e = typeof c == "string" ? o.materials.find(nt => nt.uuid === c) : o.materials[c];
        return !!_e && (o.selectedIndex = o.materials.indexOf(_e),
        b.applyMaterial(_e, o.uuid))
    }
    getPreview(o, c, h=!0) {
        if (!this._viewer)
            return "";
        const _ = o;
        if (!_)
            return "";
        let b = "";
        if (c.startsWith("generate:"))
            b = this._previewGenerator.generate(_, c.split(":")[1]);
        else {
            const _e = _[c] || "#ff00ff";
            b = _e.image ? Ne$1(_e.image, 100) : "",
            b.length || (b = Ge$1(_e.isColor ? _e.getHexString() : _e))
        }
        return h && this._viewer.setDirty(),
        b
    }
    refreshUi() {
        this.enabled && this._viewer && (this._uiNeedRefresh = !0)
    }
    async _refreshUi() {
        return !(!this.enabled || !this._viewer || !this._uiNeedRefresh || (this._uiNeedRefresh = !1,
        this._refreshUiConfig(),
        0))
    }
    removeVariationForMaterial(o) {
        let c = this.findVariation(o.uuid);
        !c && o.name.length > 0 && (c = this.findVariation(o.name)),
        c && this.removeVariation(c)
    }
    removeVariation(o) {
        o && (this.variations.splice(this.variations.indexOf(o), 1),
        this.refreshUi())
    }
    addVariation(o, c, h=!0) {
        var _;
        const b = h ? (_ = o == null ? void 0 : o.clone) === null || _ === void 0 ? void 0 : _.call(o) : o;
        if (o && b) {
            let _e = this.findVariation(c ?? o.uuid);
            !_e && !c && o.name.length > 0 && (_e = this.findVariation(o.name)),
            _e || (_e = this.createVariation(o, c)),
            _e.materials.push(b),
            this.refreshUi()
        }
    }
    createVariation(o, c) {
        return this.variations.push({
            uuid: c ?? o.name.length > 0 ? o.name : o.uuid,
            title: o.name.length > 0 ? o.name : "No Name",
            preview: "generate:sphere",
            materials: []
        }),
        this.variations[this.variations.length - 1]
    }
}
MaterialConfiguratorBasePlugin.PluginType = "MaterialConfiguratorPlugin",
MaterialConfiguratorBasePlugin_decorate([serialize()], MaterialConfiguratorBasePlugin.prototype, "variations", void 0);
class CustomContextGrid {
    static _initializeStyles() {
        P$2($`
  .customContextGrid {
    background: #eeeeee55;
    border: 0.5px solid rgba(220, 220, 220, 0.2);
    width: auto;
    height: auto;
    position: absolute;
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    z-index: 200;
    padding: 0.35rem 0.35rem;
    border-radius: 0.375rem;
    min-width: 5rem;
    pointer-events: auto;
    box-shadow: 0px 2px 6px rgba(12, 12, 12, 0.2);

    color: #111111;
    font-size: 0.65rem;
    font-family: Inter, "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
    backdrop-filter: blur(20px);
  }
  .customContextGridItems {
    background-color: transparent;
    cursor: pointer;
    border-radius: 0.25rem;
    line-height: 1rem;
    font-weight: 500;
    overflow: hidden;
    margin: 0.12rem;
  }

  .customContextGridItems:hover {
    color: white;
    //background-color: #017AFF;
    box-shadow: 0 0 7px 0px rgba(64, 64, 64, 0.3);
  }
  .customContextGridItemImage{
    width: 100%;
    height: 100%;
  }
  .customContextGridHeading{
    width: 100%;
    padding: 5px;
    font-size: 0.85rem;
  }
  .customContextGridParent{
    position: absolute;
    top: 0;
    left: 0;
    width: 270px;
    height: calc(100% - 100px);
    overflow-y: scroll;
    z-index: 100;
    display: flex;
    flex-direction: column;
    margin-bottom: 50px;
    margin-top: 50px;
  }
  /* Hide scrollbar for Chrome, Safari and Opera */
  .customContextGridParent::-webkit-scrollbar {
    display: none;
  }
  /* Hide scrollbar for IE, Edge and Firefox */
  .customContextGridParent {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }

        `, this._container),
        this._container.style.position = "absolute",
        this._container.style.top = "0",
        this._container.style.left = "0",
        this._container.style.width = "270px",
        this._container.style.height = "100%",
        this._container.style.pointerEvents = "none",
        this._container.style.zIndex = "100",
        this._container.style.overflowY = "auto"
    }
    static Create(o, c, h, _, b, _e, nt) {
        var it;
        const at = we$1()
          , ut = at ? .15 : .25
          , pt = at ? 1.5 : 2.5
          , ht = ee$1({
            classList: ["customContextGrid"],
            addToBody: !1,
            innerHTML: `
            <div class="customContextGridHeading"> ${c} </div>
            `
        });
        ht.style.top = b + "px",
        ht.style.left = _ + "px",
        ht.style.gap = ut + "rem",
        ht.style.width = (pt + ut) * h - ut + "rem",
        ht.dataset.tag = o;
        for (const _t of _e) {
            const vt = ee$1({
                classList: ["customContextGridItems"],
                addToBody: !1,
                innerHTML: `
            <img src="${_t.image}" class="customContextGridItemImage">
            `
            });
            vt.style.width = pt + "rem",
            vt.style.height = pt + "rem",
            ht.appendChild(vt),
            vt.onclick = () => {
                var bt;
                return (bt = _t.onClick) === null || bt === void 0 ? void 0 : bt.call(_t, _t.id)
            }
            ,
            nt(vt, _t, ht)
        }
        return (it = this.Elements) === null || it === void 0 || it.push(ht),
        ht
    }
    static RemoveAll(o) {
        if (o) {
            const c = this.Elements.filter(h => h.dataset.tag === o);
            for (const h of c)
                h.remove();
            this.Elements = this.Elements.filter(h => h.dataset.tag !== o)
        } else {
            for (const c of this.Elements)
                c.remove();
            this.Elements = []
        }
    }
    static RebuildUi(o) {
        if (this.Elements.length === 0)
            return;
        o || (o = ee$1({
            addToBody: !0,
            classList: ["customContextGridParent"]
        }));
        for (const h of this.Elements)
            h.remove();
        this._container.innerHTML = "",
        this._initializeStyles();
        let c = 20;
        o.appendChild(this._container);
        for (const h of this.Elements)
            h.style.top = c + "px",
            this._container.appendChild(h),
            c += h.clientHeight + 20
    }
}
function getWindow(d) {
    if (d == null)
        return window;
    if (d.toString() !== "[object Window]") {
        var o = d.ownerDocument;
        return o && o.defaultView || window
    }
    return d
}
function isElement(d) {
    return d instanceof getWindow(d).Element || d instanceof Element
}
function isHTMLElement(d) {
    return d instanceof getWindow(d).HTMLElement || d instanceof HTMLElement
}
function isShadowRoot(d) {
    return typeof ShadowRoot < "u" && (d instanceof getWindow(d).ShadowRoot || d instanceof ShadowRoot)
}
CustomContextGrid.Elements = [],
CustomContextGrid._container = document.createElement("div");
var math_max = Math.max
  , math_min = Math.min
  , round = Math.round;
function getUAString() {
    var d = navigator.userAgentData;
    return d != null && d.brands && Array.isArray(d.brands) ? d.brands.map(function(o) {
        return o.brand + "/" + o.version
    }).join(" ") : navigator.userAgent
}
function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function getBoundingClientRect(d, o, c) {
    o === void 0 && (o = !1),
    c === void 0 && (c = !1);
    var h = d.getBoundingClientRect()
      , _ = 1
      , b = 1;
    o && isHTMLElement(d) && (_ = d.offsetWidth > 0 && round(h.width) / d.offsetWidth || 1,
    b = d.offsetHeight > 0 && round(h.height) / d.offsetHeight || 1);
    var _e = (isElement(d) ? getWindow(d) : window).visualViewport
      , nt = !isLayoutViewport() && c
      , it = (h.left + (nt && _e ? _e.offsetLeft : 0)) / _
      , at = (h.top + (nt && _e ? _e.offsetTop : 0)) / b
      , ut = h.width / _
      , pt = h.height / b;
    return {
        width: ut,
        height: pt,
        top: at,
        right: it + ut,
        bottom: at + pt,
        left: it,
        x: it,
        y: at
    }
}
function getWindowScroll(d) {
    var o = getWindow(d);
    return {
        scrollLeft: o.pageXOffset,
        scrollTop: o.pageYOffset
    }
}
function getHTMLElementScroll(d) {
    return {
        scrollLeft: d.scrollLeft,
        scrollTop: d.scrollTop
    }
}
function getNodeScroll(d) {
    return d !== getWindow(d) && isHTMLElement(d) ? getHTMLElementScroll(d) : getWindowScroll(d)
}
function getNodeName(d) {
    return d ? (d.nodeName || "").toLowerCase() : null
}
function getDocumentElement(d) {
    return ((isElement(d) ? d.ownerDocument : d.document) || window.document).documentElement
}
function getWindowScrollBarX(d) {
    return getBoundingClientRect(getDocumentElement(d)).left + getWindowScroll(d).scrollLeft
}
function getComputedStyle$1(d) {
    return getWindow(d).getComputedStyle(d)
}
function isScrollParent(d) {
    var o = getComputedStyle$1(d)
      , c = o.overflow
      , h = o.overflowX
      , _ = o.overflowY;
    return /auto|scroll|overlay|hidden/.test(c + _ + h)
}
function isElementScaled(d) {
    var o = d.getBoundingClientRect()
      , c = round(o.width) / d.offsetWidth || 1
      , h = round(o.height) / d.offsetHeight || 1;
    return c !== 1 || h !== 1
}
function getCompositeRect(d, o, c) {
    c === void 0 && (c = !1);
    var h = isHTMLElement(o)
      , _ = isHTMLElement(o) && isElementScaled(o)
      , b = getDocumentElement(o)
      , _e = getBoundingClientRect(d, _, c)
      , nt = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , it = {
        x: 0,
        y: 0
    };
    return (h || !h && !c) && ((getNodeName(o) !== "body" || isScrollParent(b)) && (nt = getNodeScroll(o)),
    isHTMLElement(o) ? ((it = getBoundingClientRect(o, !0)).x += o.clientLeft,
    it.y += o.clientTop) : b && (it.x = getWindowScrollBarX(b))),
    {
        x: _e.left + nt.scrollLeft - it.x,
        y: _e.top + nt.scrollTop - it.y,
        width: _e.width,
        height: _e.height
    }
}
function getLayoutRect(d) {
    var o = getBoundingClientRect(d)
      , c = d.offsetWidth
      , h = d.offsetHeight;
    return Math.abs(o.width - c) <= 1 && (c = o.width),
    Math.abs(o.height - h) <= 1 && (h = o.height),
    {
        x: d.offsetLeft,
        y: d.offsetTop,
        width: c,
        height: h
    }
}
function getParentNode(d) {
    return getNodeName(d) === "html" ? d : d.assignedSlot || d.parentNode || (isShadowRoot(d) ? d.host : null) || getDocumentElement(d)
}
function getScrollParent(d) {
    return ["html", "body", "#document"].indexOf(getNodeName(d)) >= 0 ? d.ownerDocument.body : isHTMLElement(d) && isScrollParent(d) ? d : getScrollParent(getParentNode(d))
}
function listScrollParents(d, o) {
    var c;
    o === void 0 && (o = []);
    var h = getScrollParent(d)
      , _ = h === ((c = d.ownerDocument) == null ? void 0 : c.body)
      , b = getWindow(h)
      , _e = _ ? [b].concat(b.visualViewport || [], isScrollParent(h) ? h : []) : h
      , nt = o.concat(_e);
    return _ ? nt : nt.concat(listScrollParents(getParentNode(_e)))
}
function isTableElement(d) {
    return ["table", "td", "th"].indexOf(getNodeName(d)) >= 0
}
function getTrueOffsetParent(d) {
    return isHTMLElement(d) && getComputedStyle$1(d).position !== "fixed" ? d.offsetParent : null
}
function getContainingBlock(d) {
    var o = /firefox/i.test(getUAString());
    if (/Trident/i.test(getUAString()) && isHTMLElement(d) && getComputedStyle$1(d).position === "fixed")
        return null;
    var c = getParentNode(d);
    for (isShadowRoot(c) && (c = c.host); isHTMLElement(c) && ["html", "body"].indexOf(getNodeName(c)) < 0; ) {
        var h = getComputedStyle$1(c);
        if (h.transform !== "none" || h.perspective !== "none" || h.contain === "paint" || ["transform", "perspective"].indexOf(h.willChange) !== -1 || o && h.willChange === "filter" || o && h.filter && h.filter !== "none")
            return c;
        c = c.parentNode
    }
    return null
}
function getOffsetParent(d) {
    for (var o = getWindow(d), c = getTrueOffsetParent(d); c && isTableElement(c) && getComputedStyle$1(c).position === "static"; )
        c = getTrueOffsetParent(c);
    return c && (getNodeName(c) === "html" || getNodeName(c) === "body" && getComputedStyle$1(c).position === "static") ? o : c || getContainingBlock(d) || o
}
var enums_top = "top"
  , bottom = "bottom"
  , right = "right"
  , left = "left"
  , auto$1 = "auto"
  , basePlacements = [enums_top, bottom, right, left]
  , start = "start"
  , end = "end"
  , clippingParents = "clippingParents"
  , viewport = "viewport"
  , popper = "popper"
  , reference = "reference"
  , variationPlacements = basePlacements.reduce(function(d, o) {
    return d.concat([o + "-" + start, o + "-" + end])
}, [])
  , enums_placements = [].concat(basePlacements, [auto$1]).reduce(function(d, o) {
    return d.concat([o, o + "-" + start, o + "-" + end])
}, [])
  , beforeRead = "beforeRead"
  , enums_read = "read"
  , afterRead = "afterRead"
  , beforeMain = "beforeMain"
  , main = "main"
  , afterMain = "afterMain"
  , beforeWrite = "beforeWrite"
  , write = "write"
  , afterWrite = "afterWrite"
  , modifierPhases = [beforeRead, enums_read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function order(d) {
    var o = new Map
      , c = new Set
      , h = [];
    function _(b) {
        c.add(b.name),
        [].concat(b.requires || [], b.requiresIfExists || []).forEach(function(_e) {
            if (!c.has(_e)) {
                var nt = o.get(_e);
                nt && _(nt)
            }
        }),
        h.push(b)
    }
    return d.forEach(function(b) {
        o.set(b.name, b)
    }),
    d.forEach(function(b) {
        c.has(b.name) || _(b)
    }),
    h
}
function orderModifiers(d) {
    var o = order(d);
    return modifierPhases.reduce(function(c, h) {
        return c.concat(o.filter(function(_) {
            return _.phase === h
        }))
    }, [])
}
function debounce(d) {
    var o;
    return function() {
        return o || (o = new Promise(function(c) {
            Promise.resolve().then(function() {
                o = void 0,
                c(d())
            })
        }
        )),
        o
    }
}
function mergeByName(d) {
    var o = d.reduce(function(c, h) {
        var _ = c[h.name];
        return c[h.name] = _ ? Object.assign({}, _, h, {
            options: Object.assign({}, _.options, h.options),
            data: Object.assign({}, _.data, h.data)
        }) : h,
        c
    }, {});
    return Object.keys(o).map(function(c) {
        return o[c]
    })
}
var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function areValidElements() {
    for (var d = arguments.length, o = new Array(d), c = 0; c < d; c++)
        o[c] = arguments[c];
    return !o.some(function(h) {
        return !(h && typeof h.getBoundingClientRect == "function")
    })
}
function popperGenerator(d) {
    d === void 0 && (d = {});
    var o = d
      , c = o.defaultModifiers
      , h = c === void 0 ? [] : c
      , _ = o.defaultOptions
      , b = _ === void 0 ? DEFAULT_OPTIONS : _;
    return function(_e, nt, it) {
        it === void 0 && (it = b);
        var at = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, b),
            modifiersData: {},
            elements: {
                reference: _e,
                popper: nt
            },
            attributes: {},
            styles: {}
        }
          , ut = []
          , pt = !1
          , ht = {
            state: at,
            setOptions: function(vt) {
                var bt = typeof vt == "function" ? vt(at.options) : vt;
                _t(),
                at.options = Object.assign({}, b, at.options, bt),
                at.scrollParents = {
                    reference: isElement(_e) ? listScrollParents(_e) : _e.contextElement ? listScrollParents(_e.contextElement) : [],
                    popper: listScrollParents(nt)
                };
                var St = orderModifiers(mergeByName([].concat(h, at.options.modifiers)));
                return at.orderedModifiers = St.filter(function(At) {
                    return At.enabled
                }),
                at.orderedModifiers.forEach(function(At) {
                    var Et = At.name
                      , Pt = At.options
                      , It = Pt === void 0 ? {} : Pt
                      , Dt = At.effect;
                    if (typeof Dt == "function") {
                        var Gt = Dt({
                            state: at,
                            name: Et,
                            instance: ht,
                            options: It
                        });
                        ut.push(Gt || function() {}
                        )
                    }
                }),
                ht.update()
            },
            forceUpdate: function() {
                if (!pt) {
                    var vt = at.elements
                      , bt = vt.reference
                      , St = vt.popper;
                    if (areValidElements(bt, St)) {
                        at.rects = {
                            reference: getCompositeRect(bt, getOffsetParent(St), at.options.strategy === "fixed"),
                            popper: getLayoutRect(St)
                        },
                        at.reset = !1,
                        at.placement = at.options.placement,
                        at.orderedModifiers.forEach(function(Bt) {
                            return at.modifiersData[Bt.name] = Object.assign({}, Bt.data)
                        });
                        for (var At = 0; At < at.orderedModifiers.length; At++)
                            if (at.reset !== !0) {
                                var Et = at.orderedModifiers[At]
                                  , Pt = Et.fn
                                  , It = Et.options
                                  , Dt = It === void 0 ? {} : It
                                  , Gt = Et.name;
                                typeof Pt == "function" && (at = Pt({
                                    state: at,
                                    options: Dt,
                                    name: Gt,
                                    instance: ht
                                }) || at)
                            } else
                                at.reset = !1,
                                At = -1
                    }
                }
            },
            update: debounce(function() {
                return new Promise(function(vt) {
                    ht.forceUpdate(),
                    vt(at)
                }
                )
            }),
            destroy: function() {
                _t(),
                pt = !0
            }
        };
        if (!areValidElements(_e, nt))
            return ht;
        function _t() {
            ut.forEach(function(vt) {
                return vt()
            }),
            ut = []
        }
        return ht.setOptions(it).then(function(vt) {
            !pt && it.onFirstUpdate && it.onFirstUpdate(vt)
        }),
        ht
    }
}
var createPopper = popperGenerator()
  , passive = {
    passive: !0
};
function effect(d) {
    var o = d.state
      , c = d.instance
      , h = d.options
      , _ = h.scroll
      , b = _ === void 0 || _
      , _e = h.resize
      , nt = _e === void 0 || _e
      , it = getWindow(o.elements.popper)
      , at = [].concat(o.scrollParents.reference, o.scrollParents.popper);
    return b && at.forEach(function(ut) {
        ut.addEventListener("scroll", c.update, passive)
    }),
    nt && it.addEventListener("resize", c.update, passive),
    function() {
        b && at.forEach(function(ut) {
            ut.removeEventListener("scroll", c.update, passive)
        }),
        nt && it.removeEventListener("resize", c.update, passive)
    }
}
var eventListeners = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect,
    data: {}
};
function getBasePlacement(d) {
    return d.split("-")[0]
}
function getVariation(d) {
    return d.split("-")[1]
}
function getMainAxisFromPlacement(d) {
    return ["top", "bottom"].indexOf(d) >= 0 ? "x" : "y"
}
function computeOffsets(d) {
    var o, c = d.reference, h = d.element, _ = d.placement, b = _ ? getBasePlacement(_) : null, _e = _ ? getVariation(_) : null, nt = c.x + c.width / 2 - h.width / 2, it = c.y + c.height / 2 - h.height / 2;
    switch (b) {
    case enums_top:
        o = {
            x: nt,
            y: c.y - h.height
        };
        break;
    case bottom:
        o = {
            x: nt,
            y: c.y + c.height
        };
        break;
    case right:
        o = {
            x: c.x + c.width,
            y: it
        };
        break;
    case left:
        o = {
            x: c.x - h.width,
            y: it
        };
        break;
    default:
        o = {
            x: c.x,
            y: c.y
        }
    }
    var at = b ? getMainAxisFromPlacement(b) : null;
    if (at != null) {
        var ut = at === "y" ? "height" : "width";
        switch (_e) {
        case start:
            o[at] = o[at] - (c[ut] / 2 - h[ut] / 2);
            break;
        case end:
            o[at] = o[at] + (c[ut] / 2 - h[ut] / 2)
        }
    }
    return o
}
function popperOffsets(d) {
    var o = d.state
      , c = d.name;
    o.modifiersData[c] = computeOffsets({
        reference: o.rects.reference,
        element: o.rects.popper,
        strategy: "absolute",
        placement: o.placement
    })
}
var modifiers_popperOffsets = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: popperOffsets,
    data: {}
}
  , unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function roundOffsetsByDPR(d, o) {
    var c = d.x
      , h = d.y
      , _ = o.devicePixelRatio || 1;
    return {
        x: round(c * _) / _ || 0,
        y: round(h * _) / _ || 0
    }
}
function mapToStyles(d) {
    var o, c = d.popper, h = d.popperRect, _ = d.placement, b = d.variation, _e = d.offsets, nt = d.position, it = d.gpuAcceleration, at = d.adaptive, ut = d.roundOffsets, pt = d.isFixed, ht = _e.x, _t = ht === void 0 ? 0 : ht, vt = _e.y, bt = vt === void 0 ? 0 : vt, St = typeof ut == "function" ? ut({
        x: _t,
        y: bt
    }) : {
        x: _t,
        y: bt
    };
    _t = St.x,
    bt = St.y;
    var At = _e.hasOwnProperty("x")
      , Et = _e.hasOwnProperty("y")
      , Pt = left
      , It = enums_top
      , Dt = window;
    if (at) {
        var Gt = getOffsetParent(c)
          , Bt = "clientHeight"
          , kt = "clientWidth";
        Gt === getWindow(c) && getComputedStyle$1(Gt = getDocumentElement(c)).position !== "static" && nt === "absolute" && (Bt = "scrollHeight",
        kt = "scrollWidth"),
        (_ === enums_top || (_ === left || _ === right) && b === end) && (It = bottom,
        bt -= (pt && Gt === Dt && Dt.visualViewport ? Dt.visualViewport.height : Gt[Bt]) - h.height,
        bt *= it ? 1 : -1),
        _ !== left && (_ !== enums_top && _ !== bottom || b !== end) || (Pt = right,
        _t -= (pt && Gt === Dt && Dt.visualViewport ? Dt.visualViewport.width : Gt[kt]) - h.width,
        _t *= it ? 1 : -1)
    }
    var Ut, Ht = Object.assign({
        position: nt
    }, at && unsetSides), Kt = ut === !0 ? roundOffsetsByDPR({
        x: _t,
        y: bt
    }, getWindow(c)) : {
        x: _t,
        y: bt
    };
    return _t = Kt.x,
    bt = Kt.y,
    it ? Object.assign({}, Ht, ((Ut = {})[It] = Et ? "0" : "",
    Ut[Pt] = At ? "0" : "",
    Ut.transform = (Dt.devicePixelRatio || 1) <= 1 ? "translate(" + _t + "px, " + bt + "px)" : "translate3d(" + _t + "px, " + bt + "px, 0)",
    Ut)) : Object.assign({}, Ht, ((o = {})[It] = Et ? bt + "px" : "",
    o[Pt] = At ? _t + "px" : "",
    o.transform = "",
    o))
}
function computeStyles(d) {
    var o = d.state
      , c = d.options
      , h = c.gpuAcceleration
      , _ = h === void 0 || h
      , b = c.adaptive
      , _e = b === void 0 || b
      , nt = c.roundOffsets
      , it = nt === void 0 || nt
      , at = {
        placement: getBasePlacement(o.placement),
        variation: getVariation(o.placement),
        popper: o.elements.popper,
        popperRect: o.rects.popper,
        gpuAcceleration: _,
        isFixed: o.options.strategy === "fixed"
    };
    o.modifiersData.popperOffsets != null && (o.styles.popper = Object.assign({}, o.styles.popper, mapToStyles(Object.assign({}, at, {
        offsets: o.modifiersData.popperOffsets,
        position: o.options.strategy,
        adaptive: _e,
        roundOffsets: it
    })))),
    o.modifiersData.arrow != null && (o.styles.arrow = Object.assign({}, o.styles.arrow, mapToStyles(Object.assign({}, at, {
        offsets: o.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: it
    })))),
    o.attributes.popper = Object.assign({}, o.attributes.popper, {
        "data-popper-placement": o.placement
    })
}
var modifiers_computeStyles = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
};
function applyStyles(d) {
    var o = d.state;
    Object.keys(o.elements).forEach(function(c) {
        var h = o.styles[c] || {}
          , _ = o.attributes[c] || {}
          , b = o.elements[c];
        isHTMLElement(b) && getNodeName(b) && (Object.assign(b.style, h),
        Object.keys(_).forEach(function(_e) {
            var nt = _[_e];
            nt === !1 ? b.removeAttribute(_e) : b.setAttribute(_e, nt === !0 ? "" : nt)
        }))
    })
}
function applyStyles_effect(d) {
    var o = d.state
      , c = {
        popper: {
            position: o.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(o.elements.popper.style, c.popper),
    o.styles = c,
    o.elements.arrow && Object.assign(o.elements.arrow.style, c.arrow),
    function() {
        Object.keys(o.elements).forEach(function(h) {
            var _ = o.elements[h]
              , b = o.attributes[h] || {}
              , _e = Object.keys(o.styles.hasOwnProperty(h) ? o.styles[h] : c[h]).reduce(function(nt, it) {
                return nt[it] = "",
                nt
            }, {});
            isHTMLElement(_) && getNodeName(_) && (Object.assign(_.style, _e),
            Object.keys(b).forEach(function(nt) {
                _.removeAttribute(nt)
            }))
        })
    }
}
var modifiers_applyStyles = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: applyStyles,
    effect: applyStyles_effect,
    requires: ["computeStyles"]
};
function distanceAndSkiddingToXY(d, o, c) {
    var h = getBasePlacement(d)
      , _ = [left, enums_top].indexOf(h) >= 0 ? -1 : 1
      , b = typeof c == "function" ? c(Object.assign({}, o, {
        placement: d
    })) : c
      , _e = b[0]
      , nt = b[1];
    return _e = _e || 0,
    nt = (nt || 0) * _,
    [left, right].indexOf(h) >= 0 ? {
        x: nt,
        y: _e
    } : {
        x: _e,
        y: nt
    }
}
function offset(d) {
    var o = d.state
      , c = d.options
      , h = d.name
      , _ = c.offset
      , b = _ === void 0 ? [0, 0] : _
      , _e = enums_placements.reduce(function(ut, pt) {
        return ut[pt] = distanceAndSkiddingToXY(pt, o.rects, b),
        ut
    }, {})
      , nt = _e[o.placement]
      , it = nt.x
      , at = nt.y;
    o.modifiersData.popperOffsets != null && (o.modifiersData.popperOffsets.x += it,
    o.modifiersData.popperOffsets.y += at),
    o.modifiersData[h] = _e
}
var modifiers_offset = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
}
  , getOppositePlacement_hash = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function getOppositePlacement(d) {
    return d.replace(/left|right|bottom|top/g, function(o) {
        return getOppositePlacement_hash[o]
    })
}
var getOppositeVariationPlacement_hash = {
    start: "end",
    end: "start"
};
function getOppositeVariationPlacement(d) {
    return d.replace(/start|end/g, function(o) {
        return getOppositeVariationPlacement_hash[o]
    })
}
function getViewportRect(d, o) {
    var c = getWindow(d)
      , h = getDocumentElement(d)
      , _ = c.visualViewport
      , b = h.clientWidth
      , _e = h.clientHeight
      , nt = 0
      , it = 0;
    if (_) {
        b = _.width,
        _e = _.height;
        var at = isLayoutViewport();
        (at || !at && o === "fixed") && (nt = _.offsetLeft,
        it = _.offsetTop)
    }
    return {
        width: b,
        height: _e,
        x: nt + getWindowScrollBarX(d),
        y: it
    }
}
function getDocumentRect(d) {
    var o, c = getDocumentElement(d), h = getWindowScroll(d), _ = (o = d.ownerDocument) == null ? void 0 : o.body, b = math_max(c.scrollWidth, c.clientWidth, _ ? _.scrollWidth : 0, _ ? _.clientWidth : 0), _e = math_max(c.scrollHeight, c.clientHeight, _ ? _.scrollHeight : 0, _ ? _.clientHeight : 0), nt = -h.scrollLeft + getWindowScrollBarX(d), it = -h.scrollTop;
    return getComputedStyle$1(_ || c).direction === "rtl" && (nt += math_max(c.clientWidth, _ ? _.clientWidth : 0) - b),
    {
        width: b,
        height: _e,
        x: nt,
        y: it
    }
}
function contains(d, o) {
    var c = o.getRootNode && o.getRootNode();
    if (d.contains(o))
        return !0;
    if (c && isShadowRoot(c)) {
        var h = o;
        do {
            if (h && d.isSameNode(h))
                return !0;
            h = h.parentNode || h.host
        } while (h)
    }
    return !1
}
function rectToClientRect(d) {
    return Object.assign({}, d, {
        left: d.x,
        top: d.y,
        right: d.x + d.width,
        bottom: d.y + d.height
    })
}
function getInnerBoundingClientRect(d, o) {
    var c = getBoundingClientRect(d, !1, o === "fixed");
    return c.top = c.top + d.clientTop,
    c.left = c.left + d.clientLeft,
    c.bottom = c.top + d.clientHeight,
    c.right = c.left + d.clientWidth,
    c.width = d.clientWidth,
    c.height = d.clientHeight,
    c.x = c.left,
    c.y = c.top,
    c
}
function getClientRectFromMixedType(d, o, c) {
    return o === viewport ? rectToClientRect(getViewportRect(d, c)) : isElement(o) ? getInnerBoundingClientRect(o, c) : rectToClientRect(getDocumentRect(getDocumentElement(d)))
}
function getClippingParents(d) {
    var o = listScrollParents(getParentNode(d))
      , c = ["absolute", "fixed"].indexOf(getComputedStyle$1(d).position) >= 0 && isHTMLElement(d) ? getOffsetParent(d) : d;
    return isElement(c) ? o.filter(function(h) {
        return isElement(h) && contains(h, c) && getNodeName(h) !== "body"
    }) : []
}
function getClippingRect(d, o, c, h) {
    var _ = o === "clippingParents" ? getClippingParents(d) : [].concat(o)
      , b = [].concat(_, [c])
      , _e = b[0]
      , nt = b.reduce(function(it, at) {
        var ut = getClientRectFromMixedType(d, at, h);
        return it.top = math_max(ut.top, it.top),
        it.right = math_min(ut.right, it.right),
        it.bottom = math_min(ut.bottom, it.bottom),
        it.left = math_max(ut.left, it.left),
        it
    }, getClientRectFromMixedType(d, _e, h));
    return nt.width = nt.right - nt.left,
    nt.height = nt.bottom - nt.top,
    nt.x = nt.left,
    nt.y = nt.top,
    nt
}
function getFreshSideObject() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function mergePaddingObject(d) {
    return Object.assign({}, getFreshSideObject(), d)
}
function expandToHashMap(d, o) {
    return o.reduce(function(c, h) {
        return c[h] = d,
        c
    }, {})
}
function detectOverflow(d, o) {
    o === void 0 && (o = {});
    var c = o
      , h = c.placement
      , _ = h === void 0 ? d.placement : h
      , b = c.strategy
      , _e = b === void 0 ? d.strategy : b
      , nt = c.boundary
      , it = nt === void 0 ? clippingParents : nt
      , at = c.rootBoundary
      , ut = at === void 0 ? viewport : at
      , pt = c.elementContext
      , ht = pt === void 0 ? popper : pt
      , _t = c.altBoundary
      , vt = _t !== void 0 && _t
      , bt = c.padding
      , St = bt === void 0 ? 0 : bt
      , At = mergePaddingObject(typeof St != "number" ? St : expandToHashMap(St, basePlacements))
      , Et = ht === popper ? reference : popper
      , Pt = d.rects.popper
      , It = d.elements[vt ? Et : ht]
      , Dt = getClippingRect(isElement(It) ? It : It.contextElement || getDocumentElement(d.elements.popper), it, ut, _e)
      , Gt = getBoundingClientRect(d.elements.reference)
      , Bt = computeOffsets({
        reference: Gt,
        element: Pt,
        strategy: "absolute",
        placement: _
    })
      , kt = rectToClientRect(Object.assign({}, Pt, Bt))
      , Ut = ht === popper ? kt : Gt
      , Ht = {
        top: Dt.top - Ut.top + At.top,
        bottom: Ut.bottom - Dt.bottom + At.bottom,
        left: Dt.left - Ut.left + At.left,
        right: Ut.right - Dt.right + At.right
    }
      , Kt = d.modifiersData.offset;
    if (ht === popper && Kt) {
        var Jt = Kt[_];
        Object.keys(Ht).forEach(function(or) {
            var ir = [right, bottom].indexOf(or) >= 0 ? 1 : -1
              , lr = [enums_top, bottom].indexOf(or) >= 0 ? "y" : "x";
            Ht[or] += Jt[lr] * ir
        })
    }
    return Ht
}
function computeAutoPlacement(d, o) {
    o === void 0 && (o = {});
    var c = o
      , h = c.placement
      , _ = c.boundary
      , b = c.rootBoundary
      , _e = c.padding
      , nt = c.flipVariations
      , it = c.allowedAutoPlacements
      , at = it === void 0 ? enums_placements : it
      , ut = getVariation(h)
      , pt = ut ? nt ? variationPlacements : variationPlacements.filter(function(vt) {
        return getVariation(vt) === ut
    }) : basePlacements
      , ht = pt.filter(function(vt) {
        return at.indexOf(vt) >= 0
    });
    ht.length === 0 && (ht = pt);
    var _t = ht.reduce(function(vt, bt) {
        return vt[bt] = detectOverflow(d, {
            placement: bt,
            boundary: _,
            rootBoundary: b,
            padding: _e
        })[getBasePlacement(bt)],
        vt
    }, {});
    return Object.keys(_t).sort(function(vt, bt) {
        return _t[vt] - _t[bt]
    })
}
function getExpandedFallbackPlacements(d) {
    if (getBasePlacement(d) === auto$1)
        return [];
    var o = getOppositePlacement(d);
    return [getOppositeVariationPlacement(d), o, getOppositeVariationPlacement(o)]
}
function flip(d) {
    var o = d.state
      , c = d.options
      , h = d.name;
    if (!o.modifiersData[h]._skip) {
        for (var _ = c.mainAxis, b = _ === void 0 || _, _e = c.altAxis, nt = _e === void 0 || _e, it = c.fallbackPlacements, at = c.padding, ut = c.boundary, pt = c.rootBoundary, ht = c.altBoundary, _t = c.flipVariations, vt = _t === void 0 || _t, bt = c.allowedAutoPlacements, St = o.options.placement, At = getBasePlacement(St), Et = it || (At !== St && vt ? getExpandedFallbackPlacements(St) : [getOppositePlacement(St)]), Pt = [St].concat(Et).reduce(function(Ar, wr) {
            return Ar.concat(getBasePlacement(wr) === auto$1 ? computeAutoPlacement(o, {
                placement: wr,
                boundary: ut,
                rootBoundary: pt,
                padding: at,
                flipVariations: vt,
                allowedAutoPlacements: bt
            }) : wr)
        }, []), It = o.rects.reference, Dt = o.rects.popper, Gt = new Map, Bt = !0, kt = Pt[0], Ut = 0; Ut < Pt.length; Ut++) {
            var Ht = Pt[Ut]
              , Kt = getBasePlacement(Ht)
              , Jt = getVariation(Ht) === start
              , or = [enums_top, bottom].indexOf(Kt) >= 0
              , ir = or ? "width" : "height"
              , lr = detectOverflow(o, {
                placement: Ht,
                boundary: ut,
                rootBoundary: pt,
                altBoundary: ht,
                padding: at
            })
              , ar = or ? Jt ? right : left : Jt ? bottom : enums_top;
            It[ir] > Dt[ir] && (ar = getOppositePlacement(ar));
            var hr = getOppositePlacement(ar)
              , gr = [];
            if (b && gr.push(lr[Kt] <= 0),
            nt && gr.push(lr[ar] <= 0, lr[hr] <= 0),
            gr.every(function(Ar) {
                return Ar
            })) {
                kt = Ht,
                Bt = !1;
                break
            }
            Gt.set(Ht, gr)
        }
        if (Bt)
            for (var dr = function(Ar) {
                var wr = Pt.find(function(Rr) {
                    var Cr = Gt.get(Rr);
                    if (Cr)
                        return Cr.slice(0, Ar).every(function(tr) {
                            return tr
                        })
                });
                if (wr)
                    return kt = wr,
                    "break"
            }, cr = vt ? 3 : 1; cr > 0 && dr(cr) !== "break"; cr--)
                ;
        o.placement !== kt && (o.modifiersData[h]._skip = !0,
        o.placement = kt,
        o.reset = !0)
    }
}
var modifiers_flip = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function getAltAxis(d) {
    return d === "x" ? "y" : "x"
}
function within(d, o, c) {
    return math_max(d, math_min(o, c))
}
function withinMaxClamp(d, o, c) {
    var h = within(d, o, c);
    return h > c ? c : h
}
function preventOverflow(d) {
    var o = d.state
      , c = d.options
      , h = d.name
      , _ = c.mainAxis
      , b = _ === void 0 || _
      , _e = c.altAxis
      , nt = _e !== void 0 && _e
      , it = c.boundary
      , at = c.rootBoundary
      , ut = c.altBoundary
      , pt = c.padding
      , ht = c.tether
      , _t = ht === void 0 || ht
      , vt = c.tetherOffset
      , bt = vt === void 0 ? 0 : vt
      , St = detectOverflow(o, {
        boundary: it,
        rootBoundary: at,
        padding: pt,
        altBoundary: ut
    })
      , At = getBasePlacement(o.placement)
      , Et = getVariation(o.placement)
      , Pt = !Et
      , It = getMainAxisFromPlacement(At)
      , Dt = getAltAxis(It)
      , Gt = o.modifiersData.popperOffsets
      , Bt = o.rects.reference
      , kt = o.rects.popper
      , Ut = typeof bt == "function" ? bt(Object.assign({}, o.rects, {
        placement: o.placement
    })) : bt
      , Ht = typeof Ut == "number" ? {
        mainAxis: Ut,
        altAxis: Ut
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, Ut)
      , Kt = o.modifiersData.offset ? o.modifiersData.offset[o.placement] : null
      , Jt = {
        x: 0,
        y: 0
    };
    if (Gt) {
        if (b) {
            var or, ir = It === "y" ? enums_top : left, lr = It === "y" ? bottom : right, ar = It === "y" ? "height" : "width", hr = Gt[It], gr = hr + St[ir], dr = hr - St[lr], cr = _t ? -kt[ar] / 2 : 0, Ar = Et === start ? Bt[ar] : kt[ar], wr = Et === start ? -kt[ar] : -Bt[ar], Rr = o.elements.arrow, Cr = _t && Rr ? getLayoutRect(Rr) : {
                width: 0,
                height: 0
            }, tr = o.modifiersData["arrow#persistent"] ? o.modifiersData["arrow#persistent"].padding : getFreshSideObject(), fr = tr[ir], vr = tr[lr], Zr = within(0, Bt[ar], Cr[ar]), rn = Pt ? Bt[ar] / 2 - cr - Zr - fr - Ht.mainAxis : Ar - Zr - fr - Ht.mainAxis, hn = Pt ? -Bt[ar] / 2 + cr + Zr + vr + Ht.mainAxis : wr + Zr + vr + Ht.mainAxis, Nn = o.elements.arrow && getOffsetParent(o.elements.arrow), Wn = Nn ? It === "y" ? Nn.clientTop || 0 : Nn.clientLeft || 0 : 0, qn = (or = Kt == null ? void 0 : Kt[It]) != null ? or : 0, mo = hr + hn - qn, Ur = within(_t ? math_min(gr, hr + rn - qn - Wn) : gr, hr, _t ? math_max(dr, mo) : dr);
            Gt[It] = Ur,
            Jt[It] = Ur - hr
        }
        if (nt) {
            var nn, xn = It === "x" ? enums_top : left, ur = It === "x" ? bottom : right, pr = Gt[Dt], Ir = Dt === "y" ? "height" : "width", jr = pr + St[xn], Qr = pr - St[ur], Or = [enums_top, left].indexOf(At) !== -1, qr = (nn = Kt == null ? void 0 : Kt[Dt]) != null ? nn : 0, gn = Or ? jr : pr - Bt[Ir] - kt[Ir] - qr + Ht.altAxis, Mn = Or ? pr + Bt[Ir] + kt[Ir] - qr - Ht.altAxis : Qr, Tn = _t && Or ? withinMaxClamp(gn, pr, Mn) : within(_t ? gn : jr, pr, _t ? Mn : Qr);
            Gt[Dt] = Tn,
            Jt[Dt] = Tn - pr
        }
        o.modifiersData[h] = Jt
    }
}
var modifiers_preventOverflow = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
}
  , toPaddingObject = function(d, o) {
    return mergePaddingObject(typeof (d = typeof d == "function" ? d(Object.assign({}, o.rects, {
        placement: o.placement
    })) : d) != "number" ? d : expandToHashMap(d, basePlacements))
};
function arrow(d) {
    var o, c = d.state, h = d.name, _ = d.options, b = c.elements.arrow, _e = c.modifiersData.popperOffsets, nt = getBasePlacement(c.placement), it = getMainAxisFromPlacement(nt), at = [left, right].indexOf(nt) >= 0 ? "height" : "width";
    if (b && _e) {
        var ut = toPaddingObject(_.padding, c)
          , pt = getLayoutRect(b)
          , ht = it === "y" ? enums_top : left
          , _t = it === "y" ? bottom : right
          , vt = c.rects.reference[at] + c.rects.reference[it] - _e[it] - c.rects.popper[at]
          , bt = _e[it] - c.rects.reference[it]
          , St = getOffsetParent(b)
          , At = St ? it === "y" ? St.clientHeight || 0 : St.clientWidth || 0 : 0
          , Et = vt / 2 - bt / 2
          , Pt = ut[ht]
          , It = At - pt[at] - ut[_t]
          , Dt = At / 2 - pt[at] / 2 + Et
          , Gt = within(Pt, Dt, It)
          , Bt = it;
        c.modifiersData[h] = ((o = {})[Bt] = Gt,
        o.centerOffset = Gt - Dt,
        o)
    }
}
function arrow_effect(d) {
    var o = d.state
      , c = d.options.element
      , h = c === void 0 ? "[data-popper-arrow]" : c;
    h != null && (typeof h != "string" || (h = o.elements.popper.querySelector(h))) && contains(o.elements.popper, h) && (o.elements.arrow = h)
}
var modifiers_arrow = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: arrow,
    effect: arrow_effect,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function getSideOffsets(d, o, c) {
    return c === void 0 && (c = {
        x: 0,
        y: 0
    }),
    {
        top: d.top - o.height - c.y,
        right: d.right - o.width + c.x,
        bottom: d.bottom - o.height + c.y,
        left: d.left - o.width - c.x
    }
}
function isAnySideFullyClipped(d) {
    return [enums_top, right, bottom, left].some(function(o) {
        return d[o] >= 0
    })
}
function hide(d) {
    var o = d.state
      , c = d.name
      , h = o.rects.reference
      , _ = o.rects.popper
      , b = o.modifiersData.preventOverflow
      , _e = detectOverflow(o, {
        elementContext: "reference"
    })
      , nt = detectOverflow(o, {
        altBoundary: !0
    })
      , it = getSideOffsets(_e, h)
      , at = getSideOffsets(nt, _, b)
      , ut = isAnySideFullyClipped(it)
      , pt = isAnySideFullyClipped(at);
    o.modifiersData[c] = {
        referenceClippingOffsets: it,
        popperEscapeOffsets: at,
        isReferenceHidden: ut,
        hasPopperEscaped: pt
    },
    o.attributes.popper = Object.assign({}, o.attributes.popper, {
        "data-popper-reference-hidden": ut,
        "data-popper-escaped": pt
    })
}
var modifiers_hide = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
}
  , defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide]
  , popper_createPopper = popperGenerator({
    defaultModifiers
})
  , BOX_CLASS = "tippy-box"
  , CONTENT_CLASS = "tippy-content"
  , BACKDROP_CLASS = "tippy-backdrop"
  , ARROW_CLASS = "tippy-arrow"
  , SVG_ARROW_CLASS = "tippy-svg-arrow"
  , TOUCH_OPTIONS = {
    passive: !0,
    capture: !0
}
  , TIPPY_DEFAULT_APPEND_TO = function() {
    return document.body
};
function getValueAtIndexOrReturn(d, o, c) {
    if (Array.isArray(d)) {
        var h = d[o];
        return h ?? (Array.isArray(c) ? c[o] : c)
    }
    return d
}
function isType(d, o) {
    var c = {}.toString.call(d);
    return c.indexOf("[object") === 0 && c.indexOf(o + "]") > -1
}
function invokeWithArgsOrReturn(d, o) {
    return typeof d == "function" ? d.apply(void 0, o) : d
}
function tippy_esm_debounce(d, o) {
    return o === 0 ? d : function(h) {
        clearTimeout(c),
        c = setTimeout(function() {
            d(h)
        }, o)
    }
    ;
    var c
}
function removeProperties(d, o) {
    var c = Object.assign({}, d);
    return o.forEach(function(h) {
        delete c[h]
    }),
    c
}
function splitBySpaces(d) {
    return d.split(/\s+/).filter(Boolean)
}
function normalizeToArray(d) {
    return [].concat(d)
}
function pushIfUnique(d, o) {
    d.indexOf(o) === -1 && d.push(o)
}
function unique(d) {
    return d.filter(function(o, c) {
        return d.indexOf(o) === c
    })
}
function tippy_esm_getBasePlacement(d) {
    return d.split("-")[0]
}
function arrayFrom(d) {
    return [].slice.call(d)
}
function removeUndefinedProps(d) {
    return Object.keys(d).reduce(function(o, c) {
        return d[c] !== void 0 && (o[c] = d[c]),
        o
    }, {})
}
function div() {
    return document.createElement("div")
}
function tippy_esm_isElement(d) {
    return ["Element", "Fragment"].some(function(o) {
        return isType(d, o)
    })
}
function isNodeList(d) {
    return isType(d, "NodeList")
}
function isMouseEvent(d) {
    return isType(d, "MouseEvent")
}
function isReferenceElement(d) {
    return !(!d || !d._tippy || d._tippy.reference !== d)
}
function getArrayOfElements(d) {
    return tippy_esm_isElement(d) ? [d] : isNodeList(d) ? arrayFrom(d) : Array.isArray(d) ? d : arrayFrom(document.querySelectorAll(d))
}
function setTransitionDuration(d, o) {
    d.forEach(function(c) {
        c && (c.style.transitionDuration = o + "ms")
    })
}
function setVisibilityState(d, o) {
    d.forEach(function(c) {
        c && c.setAttribute("data-state", o)
    })
}
function getOwnerDocument(d) {
    var o, c = normalizeToArray(d)[0];
    return c != null && (o = c.ownerDocument) != null && o.body ? c.ownerDocument : document
}
function isCursorOutsideInteractiveBorder(d, o) {
    var c = o.clientX
      , h = o.clientY;
    return d.every(function(_) {
        var b = _.popperRect
          , _e = _.popperState
          , nt = _.props.interactiveBorder
          , it = tippy_esm_getBasePlacement(_e.placement)
          , at = _e.modifiersData.offset;
        if (!at)
            return !0;
        var ut = it === "bottom" ? at.top.y : 0
          , pt = it === "top" ? at.bottom.y : 0
          , ht = it === "right" ? at.left.x : 0
          , _t = it === "left" ? at.right.x : 0
          , vt = b.top - h + ut > nt
          , bt = h - b.bottom - pt > nt
          , St = b.left - c + ht > nt
          , At = c - b.right - _t > nt;
        return vt || bt || St || At
    })
}
function updateTransitionEndListener(d, o, c) {
    var h = o + "EventListener";
    ["transitionend", "webkitTransitionEnd"].forEach(function(_) {
        d[h](_, c)
    })
}
function actualContains(d, o) {
    for (var c = o; c; ) {
        var h;
        if (d.contains(c))
            return !0;
        c = c.getRootNode == null || (h = c.getRootNode()) == null ? void 0 : h.host
    }
    return !1
}
var currentInput = {
    isTouch: !1
}
  , lastMouseMoveTime = 0;
function onDocumentTouchStart() {
    currentInput.isTouch || (currentInput.isTouch = !0,
    window.performance && document.addEventListener("mousemove", onDocumentMouseMove))
}
function onDocumentMouseMove() {
    var d = performance.now();
    d - lastMouseMoveTime < 20 && (currentInput.isTouch = !1,
    document.removeEventListener("mousemove", onDocumentMouseMove)),
    lastMouseMoveTime = d
}
function onWindowBlur() {
    var d = document.activeElement;
    if (isReferenceElement(d)) {
        var o = d._tippy;
        d.blur && !o.state.isVisible && d.blur()
    }
}
function bindGlobalEventListeners() {
    document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS),
    window.addEventListener("blur", onWindowBlur)
}
var isBrowser$1 = typeof window < "u" && typeof document < "u"
  , isIE11 = !!isBrowser$1 && !!window.msCrypto
  , pluginProps = {
    animateFill: !1,
    followCursor: !1,
    inlinePositioning: !1,
    sticky: !1
}
  , renderProps = {
    allowHTML: !1,
    animation: "fade",
    arrow: !0,
    content: "",
    inertia: !1,
    maxWidth: 350,
    role: "tooltip",
    theme: "",
    zIndex: 9999
}
  , defaultProps$1 = Object.assign({
    appendTo: TIPPY_DEFAULT_APPEND_TO,
    aria: {
        content: "auto",
        expanded: "auto"
    },
    delay: 0,
    duration: [300, 250],
    getReferenceClientRect: null,
    hideOnClick: !0,
    ignoreAttributes: !1,
    interactive: !1,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    moveTransition: "",
    offset: [0, 10],
    onAfterUpdate: function() {},
    onBeforeUpdate: function() {},
    onCreate: function() {},
    onDestroy: function() {},
    onHidden: function() {},
    onHide: function() {},
    onMount: function() {},
    onShow: function() {},
    onShown: function() {},
    onTrigger: function() {},
    onUntrigger: function() {},
    onClickOutside: function() {},
    placement: "top",
    plugins: [],
    popperOptions: {},
    render: null,
    showOnCreate: !1,
    touch: !0,
    trigger: "mouseenter focus",
    triggerTarget: null
}, pluginProps, renderProps)
  , defaultKeys = Object.keys(defaultProps$1)
  , setDefaultProps = function(d) {
    Object.keys(d).forEach(function(o) {
        defaultProps$1[o] = d[o]
    })
};
function getExtendedPassedProps(d) {
    var o = (d.plugins || []).reduce(function(c, h) {
        var _, b = h.name, _e = h.defaultValue;
        return b && (c[b] = d[b] !== void 0 ? d[b] : (_ = defaultProps$1[b]) != null ? _ : _e),
        c
    }, {});
    return Object.assign({}, d, o)
}
function getDataAttributeProps(d, o) {
    return (o ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps$1, {
        plugins: o
    }))) : defaultKeys).reduce(function(c, h) {
        var _ = (d.getAttribute("data-tippy-" + h) || "").trim();
        if (!_)
            return c;
        if (h === "content")
            c[h] = _;
        else
            try {
                c[h] = JSON.parse(_)
            } catch {
                c[h] = _
            }
        return c
    }, {})
}
function evaluateProps(d, o) {
    var c = Object.assign({}, o, {
        content: invokeWithArgsOrReturn(o.content, [d])
    }, o.ignoreAttributes ? {} : getDataAttributeProps(d, o.plugins));
    return c.aria = Object.assign({}, defaultProps$1.aria, c.aria),
    c.aria = {
        expanded: c.aria.expanded === "auto" ? o.interactive : c.aria.expanded,
        content: c.aria.content === "auto" ? o.interactive ? null : "describedby" : c.aria.content
    },
    c
}
var innerHTML = function() {
    return "innerHTML"
};
function dangerouslySetInnerHTML(d, o) {
    d[innerHTML()] = o
}
function createArrowElement(d) {
    var o = div();
    return d === !0 ? o.className = ARROW_CLASS : (o.className = SVG_ARROW_CLASS,
    tippy_esm_isElement(d) ? o.appendChild(d) : dangerouslySetInnerHTML(o, d)),
    o
}
function setContent(d, o) {
    tippy_esm_isElement(o.content) ? (dangerouslySetInnerHTML(d, ""),
    d.appendChild(o.content)) : typeof o.content != "function" && (o.allowHTML ? dangerouslySetInnerHTML(d, o.content) : d.textContent = o.content)
}
function getChildren(d) {
    var o = d.firstElementChild
      , c = arrayFrom(o.children);
    return {
        box: o,
        content: c.find(function(h) {
            return h.classList.contains(CONTENT_CLASS)
        }),
        arrow: c.find(function(h) {
            return h.classList.contains(ARROW_CLASS) || h.classList.contains(SVG_ARROW_CLASS)
        }),
        backdrop: c.find(function(h) {
            return h.classList.contains(BACKDROP_CLASS)
        })
    }
}
function render(d) {
    var o = div()
      , c = div();
    c.className = BOX_CLASS,
    c.setAttribute("data-state", "hidden"),
    c.setAttribute("tabindex", "-1");
    var h = div();
    function _(b, _e) {
        var nt = getChildren(o)
          , it = nt.box
          , at = nt.content
          , ut = nt.arrow;
        _e.theme ? it.setAttribute("data-theme", _e.theme) : it.removeAttribute("data-theme"),
        typeof _e.animation == "string" ? it.setAttribute("data-animation", _e.animation) : it.removeAttribute("data-animation"),
        _e.inertia ? it.setAttribute("data-inertia", "") : it.removeAttribute("data-inertia"),
        it.style.maxWidth = typeof _e.maxWidth == "number" ? _e.maxWidth + "px" : _e.maxWidth,
        _e.role ? it.setAttribute("role", _e.role) : it.removeAttribute("role"),
        b.content === _e.content && b.allowHTML === _e.allowHTML || setContent(at, d.props),
        _e.arrow ? ut ? b.arrow !== _e.arrow && (it.removeChild(ut),
        it.appendChild(createArrowElement(_e.arrow))) : it.appendChild(createArrowElement(_e.arrow)) : ut && it.removeChild(ut)
    }
    return h.className = CONTENT_CLASS,
    h.setAttribute("data-state", "hidden"),
    setContent(h, d.props),
    o.appendChild(c),
    c.appendChild(h),
    _(d.props, d.props),
    {
        popper: o,
        onUpdate: _
    }
}
render.$$tippy = !0;
var idCounter = 1
  , mouseMoveListeners = []
  , mountedInstances = [];
function createTippy(d, o) {
    var c, h, _, b, _e, nt, it, at = evaluateProps(d, Object.assign({}, defaultProps$1, getExtendedPassedProps(removeUndefinedProps(o)))), ut = !1, pt = !1, ht = !1, _t = !1, vt = [], bt = tippy_esm_debounce(hn, at.interactiveDebounce), St = idCounter++, At = unique(at.plugins), Et = {
        id: St,
        reference: d,
        popper: div(),
        popperInstance: null,
        props: at,
        state: {
            isEnabled: !0,
            isVisible: !1,
            isDestroyed: !1,
            isMounted: !1,
            isShown: !1
        },
        plugins: At,
        clearDelayTimeouts: function() {
            clearTimeout(c),
            clearTimeout(h),
            cancelAnimationFrame(_)
        },
        setProps: function(pr) {
            if (!Et.state.isDestroyed) {
                ar("onBeforeUpdate", [Et, pr]),
                Zr();
                var Ir = Et.props
                  , jr = evaluateProps(d, Object.assign({}, Ir, removeUndefinedProps(pr), {
                    ignoreAttributes: !0
                }));
                Et.props = jr,
                vr(),
                Ir.interactiveDebounce !== jr.interactiveDebounce && (dr(),
                bt = tippy_esm_debounce(hn, jr.interactiveDebounce)),
                Ir.triggerTarget && !jr.triggerTarget ? normalizeToArray(Ir.triggerTarget).forEach(function(Qr) {
                    Qr.removeAttribute("aria-expanded")
                }) : jr.triggerTarget && d.removeAttribute("aria-expanded"),
                gr(),
                lr(),
                Dt && Dt(Ir, jr),
                Et.popperInstance && (mo(),
                nn().forEach(function(Qr) {
                    requestAnimationFrame(Qr._tippy.popperInstance.forceUpdate)
                })),
                ar("onAfterUpdate", [Et, pr])
            }
        },
        setContent: function(pr) {
            Et.setProps({
                content: pr
            })
        },
        show: function() {
            var pr = Et.state.isVisible
              , Ir = Et.state.isDestroyed
              , jr = !Et.state.isEnabled
              , Qr = currentInput.isTouch && !Et.props.touch
              , Or = getValueAtIndexOrReturn(Et.props.duration, 0, defaultProps$1.duration);
            if (!(pr || Ir || jr || Qr || Kt().hasAttribute("disabled") || (ar("onShow", [Et], !1),
            Et.props.onShow(Et) === !1))) {
                if (Et.state.isVisible = !0,
                Ht() && (It.style.visibility = "visible"),
                lr(),
                Rr(),
                Et.state.isMounted || (It.style.transition = "none"),
                Ht()) {
                    var qr = or();
                    setTransitionDuration([qr.box, qr.content], 0)
                }
                var gn, Mn, Tn;
                nt = function() {
                    var wn;
                    if (Et.state.isVisible && !_t) {
                        if (_t = !0,
                        It.offsetHeight,
                        It.style.transition = Et.props.moveTransition,
                        Ht() && Et.props.animation) {
                            var Cn = or()
                              , fn = Cn.box
                              , bn = Cn.content;
                            setTransitionDuration([fn, bn], Or),
                            setVisibilityState([fn, bn], "visible")
                        }
                        hr(),
                        gr(),
                        pushIfUnique(mountedInstances, Et),
                        (wn = Et.popperInstance) == null || wn.forceUpdate(),
                        ar("onMount", [Et]),
                        Et.props.animation && Ht() && function(Xn) {
                            tr(Xn, function() {
                                Et.state.isShown = !0,
                                ar("onShown", [Et])
                            })
                        }(Or)
                    }
                }
                ,
                Mn = Et.props.appendTo,
                Tn = Kt(),
                (gn = Et.props.interactive && Mn === TIPPY_DEFAULT_APPEND_TO || Mn === "parent" ? Tn.parentNode : invokeWithArgsOrReturn(Mn, [Tn])).contains(It) || gn.appendChild(It),
                Et.state.isMounted = !0,
                mo()
            }
        },
        hide: function() {
            var pr = !Et.state.isVisible
              , Ir = Et.state.isDestroyed
              , jr = !Et.state.isEnabled
              , Qr = getValueAtIndexOrReturn(Et.props.duration, 1, defaultProps$1.duration);
            if (!(pr || Ir || jr) && (ar("onHide", [Et], !1),
            Et.props.onHide(Et) !== !1)) {
                if (Et.state.isVisible = !1,
                Et.state.isShown = !1,
                _t = !1,
                ut = !1,
                Ht() && (It.style.visibility = "hidden"),
                dr(),
                Cr(),
                lr(!0),
                Ht()) {
                    var Or = or()
                      , qr = Or.box
                      , gn = Or.content;
                    Et.props.animation && (setTransitionDuration([qr, gn], Qr),
                    setVisibilityState([qr, gn], "hidden"))
                }
                hr(),
                gr(),
                Et.props.animation ? Ht() && function(Mn, Tn) {
                    tr(Mn, function() {
                        !Et.state.isVisible && It.parentNode && It.parentNode.contains(It) && Tn()
                    })
                }(Qr, Et.unmount) : Et.unmount()
            }
        },
        hideWithInteractivity: function(pr) {
            Jt().addEventListener("mousemove", bt),
            pushIfUnique(mouseMoveListeners, bt),
            bt(pr)
        },
        enable: function() {
            Et.state.isEnabled = !0
        },
        disable: function() {
            Et.hide(),
            Et.state.isEnabled = !1
        },
        unmount: function() {
            Et.state.isVisible && Et.hide(),
            Et.state.isMounted && (Ur(),
            nn().forEach(function(pr) {
                pr._tippy.unmount()
            }),
            It.parentNode && It.parentNode.removeChild(It),
            mountedInstances = mountedInstances.filter(function(pr) {
                return pr !== Et
            }),
            Et.state.isMounted = !1,
            ar("onHidden", [Et]))
        },
        destroy: function() {
            Et.state.isDestroyed || (Et.clearDelayTimeouts(),
            Et.unmount(),
            Zr(),
            delete d._tippy,
            Et.state.isDestroyed = !0,
            ar("onDestroy", [Et]))
        }
    };
    if (!at.render)
        return Et;
    var Pt = at.render(Et)
      , It = Pt.popper
      , Dt = Pt.onUpdate;
    It.setAttribute("data-tippy-root", ""),
    It.id = "tippy-" + Et.id,
    Et.popper = It,
    d._tippy = Et,
    It._tippy = Et;
    var Gt = At.map(function(pr) {
        return pr.fn(Et)
    })
      , Bt = d.hasAttribute("aria-expanded");
    return vr(),
    gr(),
    lr(),
    ar("onCreate", [Et]),
    at.showOnCreate && xn(),
    It.addEventListener("mouseenter", function() {
        Et.props.interactive && Et.state.isVisible && Et.clearDelayTimeouts()
    }),
    It.addEventListener("mouseleave", function() {
        Et.props.interactive && Et.props.trigger.indexOf("mouseenter") >= 0 && Jt().addEventListener("mousemove", bt)
    }),
    Et;
    function kt() {
        var pr = Et.props.touch;
        return Array.isArray(pr) ? pr : [pr, 0]
    }
    function Ut() {
        return kt()[0] === "hold"
    }
    function Ht() {
        var pr;
        return !((pr = Et.props.render) == null || !pr.$$tippy)
    }
    function Kt() {
        return it || d
    }
    function Jt() {
        var pr = Kt().parentNode;
        return pr ? getOwnerDocument(pr) : document
    }
    function or() {
        return getChildren(It)
    }
    function ir(pr) {
        return Et.state.isMounted && !Et.state.isVisible || currentInput.isTouch || b && b.type === "focus" ? 0 : getValueAtIndexOrReturn(Et.props.delay, pr ? 0 : 1, defaultProps$1.delay)
    }
    function lr(pr) {
        pr === void 0 && (pr = !1),
        It.style.pointerEvents = Et.props.interactive && !pr ? "" : "none",
        It.style.zIndex = "" + Et.props.zIndex
    }
    function ar(pr, Ir, jr) {
        var Qr;
        jr === void 0 && (jr = !0),
        Gt.forEach(function(Or) {
            Or[pr] && Or[pr].apply(Or, Ir)
        }),
        jr && (Qr = Et.props)[pr].apply(Qr, Ir)
    }
    function hr() {
        var pr = Et.props.aria;
        if (pr.content) {
            var Ir = "aria-" + pr.content
              , jr = It.id;
            normalizeToArray(Et.props.triggerTarget || d).forEach(function(Qr) {
                var Or = Qr.getAttribute(Ir);
                if (Et.state.isVisible)
                    Qr.setAttribute(Ir, Or ? Or + " " + jr : jr);
                else {
                    var qr = Or && Or.replace(jr, "").trim();
                    qr ? Qr.setAttribute(Ir, qr) : Qr.removeAttribute(Ir)
                }
            })
        }
    }
    function gr() {
        !Bt && Et.props.aria.expanded && normalizeToArray(Et.props.triggerTarget || d).forEach(function(pr) {
            Et.props.interactive ? pr.setAttribute("aria-expanded", Et.state.isVisible && pr === Kt() ? "true" : "false") : pr.removeAttribute("aria-expanded")
        })
    }
    function dr() {
        Jt().removeEventListener("mousemove", bt),
        mouseMoveListeners = mouseMoveListeners.filter(function(pr) {
            return pr !== bt
        })
    }
    function cr(pr) {
        if (!currentInput.isTouch || !ht && pr.type !== "mousedown") {
            var Ir = pr.composedPath && pr.composedPath()[0] || pr.target;
            if (!Et.props.interactive || !actualContains(It, Ir)) {
                if (normalizeToArray(Et.props.triggerTarget || d).some(function(jr) {
                    return actualContains(jr, Ir)
                })) {
                    if (currentInput.isTouch || Et.state.isVisible && Et.props.trigger.indexOf("click") >= 0)
                        return
                } else
                    ar("onClickOutside", [Et, pr]);
                Et.props.hideOnClick === !0 && (Et.clearDelayTimeouts(),
                Et.hide(),
                pt = !0,
                setTimeout(function() {
                    pt = !1
                }),
                Et.state.isMounted || Cr())
            }
        }
    }
    function Ar() {
        ht = !0
    }
    function wr() {
        ht = !1
    }
    function Rr() {
        var pr = Jt();
        pr.addEventListener("mousedown", cr, !0),
        pr.addEventListener("touchend", cr, TOUCH_OPTIONS),
        pr.addEventListener("touchstart", wr, TOUCH_OPTIONS),
        pr.addEventListener("touchmove", Ar, TOUCH_OPTIONS)
    }
    function Cr() {
        var pr = Jt();
        pr.removeEventListener("mousedown", cr, !0),
        pr.removeEventListener("touchend", cr, TOUCH_OPTIONS),
        pr.removeEventListener("touchstart", wr, TOUCH_OPTIONS),
        pr.removeEventListener("touchmove", Ar, TOUCH_OPTIONS)
    }
    function tr(pr, Ir) {
        var jr = or().box;
        function Qr(Or) {
            Or.target === jr && (updateTransitionEndListener(jr, "remove", Qr),
            Ir())
        }
        if (pr === 0)
            return Ir();
        updateTransitionEndListener(jr, "remove", _e),
        updateTransitionEndListener(jr, "add", Qr),
        _e = Qr
    }
    function fr(pr, Ir, jr) {
        jr === void 0 && (jr = !1),
        normalizeToArray(Et.props.triggerTarget || d).forEach(function(Qr) {
            Qr.addEventListener(pr, Ir, jr),
            vt.push({
                node: Qr,
                eventType: pr,
                handler: Ir,
                options: jr
            })
        })
    }
    function vr() {
        Ut() && (fr("touchstart", rn, {
            passive: !0
        }),
        fr("touchend", Nn, {
            passive: !0
        })),
        splitBySpaces(Et.props.trigger).forEach(function(pr) {
            if (pr !== "manual")
                switch (fr(pr, rn),
                pr) {
                case "mouseenter":
                    fr("mouseleave", Nn);
                    break;
                case "focus":
                    fr(isIE11 ? "focusout" : "blur", Wn);
                    break;
                case "focusin":
                    fr("focusout", Wn)
                }
        })
    }
    function Zr() {
        vt.forEach(function(pr) {
            var Ir = pr.node
              , jr = pr.eventType
              , Qr = pr.handler
              , Or = pr.options;
            Ir.removeEventListener(jr, Qr, Or)
        }),
        vt = []
    }
    function rn(pr) {
        var Ir, jr = !1;
        if (Et.state.isEnabled && !qn(pr) && !pt) {
            var Qr = ((Ir = b) == null ? void 0 : Ir.type) === "focus";
            b = pr,
            it = pr.currentTarget,
            gr(),
            !Et.state.isVisible && isMouseEvent(pr) && mouseMoveListeners.forEach(function(Or) {
                return Or(pr)
            }),
            pr.type === "click" && (Et.props.trigger.indexOf("mouseenter") < 0 || ut) && Et.props.hideOnClick !== !1 && Et.state.isVisible ? jr = !0 : xn(pr),
            pr.type === "click" && (ut = !jr),
            jr && !Qr && ur(pr)
        }
    }
    function hn(pr) {
        var Ir = pr.target
          , jr = Kt().contains(Ir) || It.contains(Ir);
        if (pr.type !== "mousemove" || !jr) {
            var Qr = nn().concat(It).map(function(Or) {
                var qr, gn = (qr = Or._tippy.popperInstance) == null ? void 0 : qr.state;
                return gn ? {
                    popperRect: Or.getBoundingClientRect(),
                    popperState: gn,
                    props: at
                } : null
            }).filter(Boolean);
            isCursorOutsideInteractiveBorder(Qr, pr) && (dr(),
            ur(pr))
        }
    }
    function Nn(pr) {
        qn(pr) || Et.props.trigger.indexOf("click") >= 0 && ut || (Et.props.interactive ? Et.hideWithInteractivity(pr) : ur(pr))
    }
    function Wn(pr) {
        Et.props.trigger.indexOf("focusin") < 0 && pr.target !== Kt() || Et.props.interactive && pr.relatedTarget && It.contains(pr.relatedTarget) || ur(pr)
    }
    function qn(pr) {
        return !!currentInput.isTouch && Ut() !== pr.type.indexOf("touch") >= 0
    }
    function mo() {
        Ur();
        var pr = Et.props
          , Ir = pr.popperOptions
          , jr = pr.placement
          , Qr = pr.offset
          , Or = pr.getReferenceClientRect
          , qr = pr.moveTransition
          , gn = Ht() ? getChildren(It).arrow : null
          , Mn = Or ? {
            getBoundingClientRect: Or,
            contextElement: Or.contextElement || Kt()
        } : d
          , Tn = [{
            name: "offset",
            options: {
                offset: Qr
            }
        }, {
            name: "preventOverflow",
            options: {
                padding: {
                    top: 2,
                    bottom: 2,
                    left: 5,
                    right: 5
                }
            }
        }, {
            name: "flip",
            options: {
                padding: 5
            }
        }, {
            name: "computeStyles",
            options: {
                adaptive: !qr
            }
        }, {
            name: "$$tippy",
            enabled: !0,
            phase: "beforeWrite",
            requires: ["computeStyles"],
            fn: function(wn) {
                var Cn = wn.state;
                if (Ht()) {
                    var fn = or().box;
                    ["placement", "reference-hidden", "escaped"].forEach(function(bn) {
                        bn === "placement" ? fn.setAttribute("data-placement", Cn.placement) : Cn.attributes.popper["data-popper-" + bn] ? fn.setAttribute("data-" + bn, "") : fn.removeAttribute("data-" + bn)
                    }),
                    Cn.attributes.popper = {}
                }
            }
        }];
        Ht() && gn && Tn.push({
            name: "arrow",
            options: {
                element: gn,
                padding: 3
            }
        }),
        Tn.push.apply(Tn, (Ir == null ? void 0 : Ir.modifiers) || []),
        Et.popperInstance = popper_createPopper(Mn, It, Object.assign({}, Ir, {
            placement: jr,
            onFirstUpdate: nt,
            modifiers: Tn
        }))
    }
    function Ur() {
        Et.popperInstance && (Et.popperInstance.destroy(),
        Et.popperInstance = null)
    }
    function nn() {
        return arrayFrom(It.querySelectorAll("[data-tippy-root]"))
    }
    function xn(pr) {
        Et.clearDelayTimeouts(),
        pr && ar("onTrigger", [Et, pr]),
        Rr();
        var Ir = ir(!0)
          , jr = kt()
          , Qr = jr[0]
          , Or = jr[1];
        currentInput.isTouch && Qr === "hold" && Or && (Ir = Or),
        Ir ? c = setTimeout(function() {
            Et.show()
        }, Ir) : Et.show()
    }
    function ur(pr) {
        if (Et.clearDelayTimeouts(),
        ar("onUntrigger", [Et, pr]),
        Et.state.isVisible) {
            if (!(Et.props.trigger.indexOf("mouseenter") >= 0 && Et.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(pr.type) >= 0 && ut)) {
                var Ir = ir(!1);
                Ir ? h = setTimeout(function() {
                    Et.state.isVisible && Et.hide()
                }, Ir) : _ = requestAnimationFrame(function() {
                    Et.hide()
                })
            }
        } else
            Cr()
    }
}
function tippy(d, o) {
    o === void 0 && (o = {});
    var c = defaultProps$1.plugins.concat(o.plugins || []);
    bindGlobalEventListeners();
    var h = Object.assign({}, o, {
        plugins: c
    })
      , _ = getArrayOfElements(d).reduce(function(b, _e) {
        var nt = _e && createTippy(_e, h);
        return nt && b.push(nt),
        b
    }, []);
    return tippy_esm_isElement(d) ? _[0] : _
}
tippy.defaultProps = defaultProps$1,
tippy.setDefaultProps = setDefaultProps,
tippy.currentInput = currentInput;
var applyStylesModifier = Object.assign({}, modifiers_applyStyles, {
    effect: function(d) {
        var o = d.state
          , c = {
            popper: {
                position: o.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
        Object.assign(o.elements.popper.style, c.popper),
        o.styles = c,
        o.elements.arrow && Object.assign(o.elements.arrow.style, c.arrow)
    }
})
  , createSingleton = function(d, o) {
    var c;
    o === void 0 && (o = {});
    var h, _ = d, b = [], _e = [], nt = o.overrides, it = [], at = !1;
    function ut() {
        _e = _.map(function(Pt) {
            return normalizeToArray(Pt.props.triggerTarget || Pt.reference)
        }).reduce(function(Pt, It) {
            return Pt.concat(It)
        }, [])
    }
    function pt() {
        b = _.map(function(Pt) {
            return Pt.reference
        })
    }
    function ht(Pt) {
        _.forEach(function(It) {
            Pt ? It.enable() : It.disable()
        })
    }
    function _t(Pt) {
        return _.map(function(It) {
            var Dt = It.setProps;
            return It.setProps = function(Gt) {
                Dt(Gt),
                It.reference === h && Pt.setProps(Gt)
            }
            ,
            function() {
                It.setProps = Dt
            }
        })
    }
    function vt(Pt, It) {
        var Dt = _e.indexOf(It);
        if (It !== h) {
            h = It;
            var Gt = (nt || []).concat("content").reduce(function(Bt, kt) {
                return Bt[kt] = _[Dt].props[kt],
                Bt
            }, {});
            Pt.setProps(Object.assign({}, Gt, {
                getReferenceClientRect: typeof Gt.getReferenceClientRect == "function" ? Gt.getReferenceClientRect : function() {
                    var Bt;
                    return (Bt = b[Dt]) == null ? void 0 : Bt.getBoundingClientRect()
                }
            }))
        }
    }
    ht(!1),
    pt(),
    ut();
    var bt = {
        fn: function() {
            return {
                onDestroy: function() {
                    ht(!0)
                },
                onHidden: function() {
                    h = null
                },
                onClickOutside: function(Pt) {
                    Pt.props.showOnCreate && !at && (at = !0,
                    h = null)
                },
                onShow: function(Pt) {
                    Pt.props.showOnCreate && !at && (at = !0,
                    vt(Pt, b[0]))
                },
                onTrigger: function(Pt, It) {
                    vt(Pt, It.currentTarget)
                }
            }
        }
    }
      , St = tippy(div(), Object.assign({}, removeProperties(o, ["overrides"]), {
        plugins: [bt].concat(o.plugins || []),
        triggerTarget: _e,
        popperOptions: Object.assign({}, o.popperOptions, {
            modifiers: [].concat(((c = o.popperOptions) == null ? void 0 : c.modifiers) || [], [applyStylesModifier])
        })
    }))
      , At = St.show;
    St.show = function(Pt) {
        if (At(),
        !h && Pt == null)
            return vt(St, b[0]);
        if (!h || Pt != null) {
            if (typeof Pt == "number")
                return b[Pt] && vt(St, b[Pt]);
            if (_.indexOf(Pt) >= 0) {
                var It = Pt.reference;
                return vt(St, It)
            }
            return b.indexOf(Pt) >= 0 ? vt(St, Pt) : void 0
        }
    }
    ,
    St.showNext = function() {
        var Pt = b[0];
        if (!h)
            return St.show(0);
        var It = b.indexOf(h);
        St.show(b[It + 1] || Pt)
    }
    ,
    St.showPrevious = function() {
        var Pt = b[b.length - 1];
        if (!h)
            return St.show(Pt);
        var It = b.indexOf(h)
          , Dt = b[It - 1] || Pt;
        St.show(Dt)
    }
    ;
    var Et = St.setProps;
    return St.setProps = function(Pt) {
        nt = Pt.overrides || nt,
        Et(Pt)
    }
    ,
    St.setInstances = function(Pt) {
        ht(!0),
        it.forEach(function(It) {
            return It()
        }),
        _ = Pt,
        ht(!1),
        pt(),
        ut(),
        it = _t(St),
        St.setProps({
            triggerTarget: _e
        })
    }
    ,
    it = _t(St),
    St
};
tippy.setDefaultProps({
    render
});
var tippy_esm = tippy;
class CustomContextMenu {
    static _initialize() {
        this._inited = !0,
        P$2($`
          #customContextMenu {
            background: #2c2c2e99;
            backdrop-filter: blur(8px);
            border: 0.5px solid rgba(20, 20, 20, 0.3);
            width: auto;
            height: auto;
            position: absolute;
            display: flex;
            flex-direction: column;
            z-index: 9999;
            padding: 0.35rem 0.20rem;
            border-radius: 0.375rem;
            min-width: 6rem;
            pointer-events: auto;
            box-shadow: 0px 2px 10px rgba(12, 12, 12, 0.2);
          }

          .customContextMenuItems {
            color: white;
            font-size: 0.65rem;
            font-family: "Roboto Mono", "Source Code Pro", Menlo, Courier, monospace;
            background-color: transparent;
            cursor: pointer;
            padding: 0.12rem 0.35rem;
            border-radius: 0.25rem;
            line-height: 1rem;
            font-weight: 500;
          }

          .customContextMenuItems:hover {
            color: white;
            background-color: #017AFF;
          }
        `),
        document.addEventListener("mouseup", o => {
            this.Element && !this.Element.contains(o.target) && o.button === 0 && this.Remove()
        }
        )
    }
    static Create(o, c, h) {
        this._inited || this._initialize(),
        this.Element && this.Remove();
        const _ = ee$1({
            id: "customContextMenu",
            addToBody: !1
        });
        _.style.top = h + "px",
        _.style.left = c + "px";
        for (const [b,_e] of Object.entries(o)) {
            const nt = ee$1({
                classList: ["customContextMenuItems"],
                addToBody: !1,
                innerHTML: b
            });
            _.appendChild(nt),
            nt.onclick = _e
        }
        return this.Element = _,
        _
    }
    static Remove() {
        var o;
        (o = this.Element) === null || o === void 0 || o.remove(),
        this.Element = void 0
    }
}
CustomContextMenu.Element = void 0,
CustomContextMenu._inited = !1;
class MaterialConfiguratorPlugin extends MaterialConfiguratorBasePlugin {
    constructor() {
        super(...arguments),
        this.enableEditContextMenus = !1
    }
    async _refreshUi() {
        var o;
        if (!await super._refreshUi())
            return !1;
        CustomContextGrid.RemoveAll(MaterialConfiguratorPlugin.PluginType);
        for (const c of this.variations)
            CustomContextGrid.Create(MaterialConfiguratorPlugin.PluginType, c.title + (this.enableEditContextMenus ? " (" + c.uuid + ")" : ""), 5, 20, 0, c.materials.map(h => {
                let _;
                if (c.preview.startsWith("generate:"))
                    _ = this._previewGenerator.generate(h, c.preview.split(":")[1]);
                else {
                    const b = h[c.preview] || "#ff00ff";
                    _ = b.image ? Ne$1(b.image, 100) : void 0,
                    _ || (_ = Ge$1(b != null && b.isColor ? b.getHexString() : b))
                }
                return {
                    id: h.uuid,
                    image: _,
                    onClick: b => this.applyVariation(c, b),
                    tooltip: h.name || h.uuid
                }
            }
            ), (h, _, b) => {
                tippy_esm(h, {
                    placement: "bottom",
                    content: _.tooltip
                }),
                h.oncontextmenu = _e => {
                    if (!this.enableEditContextMenus)
                        return;
                    _e.preventDefault(),
                    _e.stopPropagation();
                    const nt = CustomContextMenu.Create({
                        Remove: async () => {
                            var it;
                            await ((it = this._viewer) === null || it === void 0 ? void 0 : it.confirm("Remove material: Remove material from this variation list?")) && (c.materials = c.materials.filter(at => at.uuid !== _.id),
                            this.refreshUi(),
                            CustomContextMenu.Remove())
                        }
                        ,
                        "Remove All": async () => {
                            var it;
                            await ((it = this._viewer) === null || it === void 0 ? void 0 : it.confirm("Remove all: Remove all materials from this variation list?")) && (c.materials = [],
                            this.refreshUi(),
                            CustomContextMenu.Remove())
                        }
                    }, _e.clientX, _e.clientY);
                    document.body.appendChild(nt)
                }
                ,
                b.oncontextmenu = _e => {
                    if (!this.enableEditContextMenus)
                        return;
                    _e.preventDefault(),
                    _e.stopPropagation();
                    const nt = CustomContextMenu.Create({
                        "Rename mapping": async () => {
                            var it;
                            const at = await ((it = this._viewer) === null || it === void 0 ? void 0 : it.prompt("Change name: New material name to map to", c.uuid, !0));
                            at && (c.uuid = at,
                            this.refreshUi())
                        }
                        ,
                        "Rename title": async () => {
                            var it;
                            const at = await ((it = this._viewer) === null || it === void 0 ? void 0 : it.prompt("Change name: New material name to map to", c.title, !0));
                            at && (c.title = at,
                            this.refreshUi())
                        }
                        ,
                        "Remove Section": async () => {
                            var it;
                            await ((it = this._viewer) === null || it === void 0 ? void 0 : it.confirm("Remove variations: Remove this category of variations?")) && (this.removeVariation(c),
                            CustomContextMenu.Remove())
                        }
                    }, _e.clientX, _e.clientY);
                    document.body.appendChild(nt)
                }
            }
            );
        return CustomContextGrid.RebuildUi((o = this._viewer) === null || o === void 0 ? void 0 : o.container),
        !0
    }
}
MaterialConfiguratorPlugin.PluginType = "MaterialConfiguratorPlugin";
var SwitchNodeBasePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class SwitchNodeBasePlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this._uiNeedRefresh = !1,
        this._isVisibleChanged = !1,
        this._postFrame = () => {
            this._uiNeedRefresh && this._refreshUi()
        }
        ,
        this._preRender = () => {
            if (this._viewer && this.enabled) {
                for (const o of this.variations) {
                    if (!o.name)
                        continue;
                    const c = this._viewer.scene.getObjectByName(o.name);
                    if (!c || c.children.length < 1)
                        return;
                    o.selected || (o.selected = c.children[0].name || c.children[0].uuid);
                    for (const h of c.children)
                        h.userData.__oldVisible = h.visible,
                        h.visible = (h.name || h.uuid) === o.selected
                }
                this._isVisibleChanged = !0
            }
        }
        ,
        this._postRender = () => {
            if (this._viewer && this._isVisibleChanged) {
                for (const o of this.variations) {
                    if (!o.name)
                        continue;
                    const c = this._viewer.scene.getObjectByName(o.name);
                    if (!c || c.children.length < 1)
                        return;
                    for (const h of c.children) {
                        if (h.userData.__oldVisible === void 0)
                            return;
                        h.visible = h.userData.__oldVisible,
                        delete h.userData.__oldVisible
                    }
                }
                this._isVisibleChanged = !1
            }
        }
        ,
        this.autoSnapIcons = !1,
        this.dependencies = [AssetManagerPlugin],
        this.variations = [],
        this._selectedSwitchNode = () => {
            var o;
            const c = (o = this._picking) === null || o === void 0 ? void 0 : o.getSelectedObject();
            if (!c)
                return;
            const h = this.variations.map(b => b.name);
            let _;
            return c.traverseAncestors(b => {
                _ || b.name && h.includes(b.name) && (_ = b)
            }
            ),
            _
        }
        ,
        this.uiConfig = {
            label: "Switch Node",
            type: "folder",
            children: [{
                type: "checkbox",
                label: "Enabled",
                property: [this, "enabled"]
            }, () => [{
                type: "folder",
                label: "All nodes",
                expanded: !0,
                children: [this.variations.map(o => ({
                    type: "input",
                    label: o.title,
                    property: [o, "name"],
                    onChange: () => this.refreshUi()
                }))]
            }, {
                type: "button",
                label: "Add Node",
                value: () => {
                    this.variations.push({
                        name: "switch_node",
                        selected: "",
                        title: "Switch Node",
                        camView: "front",
                        camDistance: 1
                    }),
                    this.refreshUi()
                }
            }, {
                type: "button",
                label: "Refresh UI",
                value: () => this.refreshUi()
            }, {
                type: "input",
                label: "Selected node title",
                hidden: () => !this._selectedSwitchNode(),
                property: () => {
                    const o = this._selectedSwitchNode();
                    return o ? [this.variations.find(c => c.name === o.name), "title"] : []
                }
                ,
                onChange: () => this.refreshUi()
            }, {
                type: "slider",
                bounds: [.01, 2],
                stepSize: .01,
                label: "Cam Distance",
                hidden: () => !this._selectedSwitchNode(),
                property: () => {
                    const o = this._selectedSwitchNode();
                    return o ? [this.variations.find(c => c.name === o.name), "camDistance"] : []
                }
            }, {
                type: "dropdown",
                label: "Cam View",
                hidden: () => !this._selectedSwitchNode(),
                property: () => {
                    const o = this._selectedSwitchNode();
                    return o ? [this.variations.find(c => c.name === o.name), "camView"] : []
                }
                ,
                onChange: () => this.refreshUi(),
                children: ["top", "bottom", "front", "back", "left", "right"].map(o => ({
                    label: o,
                    value: o
                }))
            }]]
        },
        this.refreshUi = this.refreshUi.bind(this),
        this._refreshUi = this._refreshUi.bind(this)
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        this._picking = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Picking"),
        (h = this._picking) === null || h === void 0 || h.addEventListener("selectedObjectChanged", this._refreshUi),
        o.addEventListener("postFrame", this._postFrame),
        o.addEventListener("preRender", this._preRender),
        o.addEventListener("postRender", this._postRender),
        this.addEventListener("deserialize", this.refreshUi)
    }
    async onRemove(o) {
        var c;
        return (c = this._picking) === null || c === void 0 || c.removeEventListener("selectedObjectChanged", this._refreshUi),
        o.removeEventListener("postFrame", this._postFrame),
        o.removeEventListener("preRender", this._preRender),
        o.removeEventListener("postRender", this._postRender),
        this._picking = void 0,
        super.onRemove(o)
    }
    refreshUi() {
        this.enabled && (this._uiNeedRefresh = !0)
    }
    _refreshUi() {
        var o, c;
        return !!this.enabled && !!this._viewer && (this._uiNeedRefresh = !1,
        (c = (o = this.uiConfig).uiRefresh) === null || c === void 0 || c.call(o),
        this.autoSnapIcons && this.snapIcons(),
        !0)
    }
    snapIcons() {
        for (const o of this.variations) {
            const c = this._viewer.scene.getObjectByName(o.name);
            if (c) {
                c.children.length < 1 && console.warn("SwitchNode does not have enough children", o);
                for (const h of c.children) {
                    if (h.userData.__icon)
                        return;
                    const _ = o.camView
                      , b = new three_module.Pq0((_.includes("right") ? 1 : 0) - (_.includes("left") ? 1 : 0),(_.includes("top") ? 1 : 0) - (_.includes("bottom") ? 1 : 0),(_.includes("front") ? 1 : 0) - (_.includes("back") ? 1 : 0));
                    o.camDistance || (o.camDistance = 1);
                    const _e = snapObject(this._viewer, h, void 0, 7, b.multiplyScalar(.5 * o.camDistance));
                    h.userData.__icon = _e
                }
            } else
                console.warn("no object found for variation, skipping", o)
        }
    }
}
SwitchNodeBasePlugin_decorate([serialize()], SwitchNodeBasePlugin.prototype, "variations", void 0);
class SwitchNodePlugin extends SwitchNodeBasePlugin {
    _refreshUi() {
        var o;
        if (!super._refreshUi())
            return !1;
        CustomContextGrid.RemoveAll(SwitchNodePlugin.PluginType);
        for (const c of this.variations) {
            const h = this._viewer.scene.getObjectByName(c.name);
            h ? (h.children.length < 1 && console.warn("SwitchNode does not have enough children", c),
            CustomContextGrid.Create(SwitchNodePlugin.PluginType, c.title, Math.min(5, h.children.length), 20, 0, h.children.map(_ => {
                const b = c.camView
                  , _e = new three_module.Pq0((b.includes("right") ? 1 : 0) - (b.includes("left") ? 1 : 0),(b.includes("top") ? 1 : 0) - (b.includes("bottom") ? 1 : 0),(b.includes("front") ? 1 : 0) - (b.includes("back") ? 1 : 0));
                c.camDistance || (c.camDistance = 1);
                const nt = snapObject(this._viewer, _, void 0, 7, _e.multiplyScalar(.5 * c.camDistance));
                return {
                    id: _.uuid,
                    image: nt,
                    onClick: () => {
                        var it;
                        c.selected = _.name || _.uuid,
                        (it = this._viewer) === null || it === void 0 || it.scene.setDirty({
                            sceneUpdate: !0,
                            frameFade: !0
                        })
                    }
                    ,
                    tooltip: _.name || _.uuid
                }
            }
            ), (_, b) => tippy_esm(_, {
                placement: "bottom",
                content: b.tooltip
            }))) : console.warn("no object found for variation, skipping", c)
        }
        return CustomContextGrid.RebuildUi((o = this._viewer) === null || o === void 0 ? void 0 : o.container),
        !0
    }
}
SwitchNodePlugin.PluginType = "SwitchNodePlugin";
var MaterialLibraryBasePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class MaterialLibraryBasePlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this._uiNeedRefresh = !1,
        this._refreshUiConfig = () => {
            var o, c;
            this.enabled && ((c = (o = this.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0))
        }
        ,
        this.dependencies = [AssetManagerPlugin],
        this._selectedObject = () => {
            var o;
            return ((o = this._picking) === null || o === void 0 ? void 0 : o.getSelectedObject()) || void 0
        }
        ,
        this._selectedMaterial = () => {
            var o;
            return ((o = this._selectedObject()) === null || o === void 0 ? void 0 : o.material) || void 0
        }
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        this.refreshUi = this.refreshUi.bind(this),
        this._refreshUi = this._refreshUi.bind(this),
        this._picking = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Picking"),
        this._previewGenerator = new MaterialPreviewGenerator(this._viewer),
        (h = this._picking) === null || h === void 0 || h.addEventListener("selectedObjectChanged", this._refreshUiConfig),
        o.addEventListener("preFrame", this._refreshUi),
        this.addEventListener("deserialize", this.refreshUi)
    }
    async onRemove(o) {
        var c, h;
        return (c = this._previewGenerator) === null || c === void 0 || c.dispose(),
        this._previewGenerator = void 0,
        (h = this._picking) === null || h === void 0 || h.removeEventListener("selectedObjectChanged", this._refreshUiConfig),
        this.removeEventListener("deserialize", this.refreshUi),
        o.removeEventListener("preFrame", this._refreshUi),
        this._picking = void 0,
        super.onRemove(o)
    }
    refreshUi() {
        this.enabled && (this._uiNeedRefresh = !0)
    }
    async _refreshUi() {
        return this._uiNeedRefresh && this.enabled && this._refreshUiConfig(),
        this._uiNeedRefresh = !1,
        !1
    }
}
MaterialLibraryBasePlugin.PluginType = "MaterialLibraryBasePlugin",
MaterialLibraryBasePlugin_decorate([uiToggle("Enabled")], MaterialLibraryBasePlugin.prototype, "enabled", void 0);
var MaterialLibraryPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class MaterialLibraryPlugin extends MaterialLibraryBasePlugin {
    constructor() {
        super(...arguments),
        this.replaceMaterial = !1,
        this.uiConfig = {
            type: "folder",
            label: "Material Library",
            uuid: esm_browser_v4(),
            children: [...generateUiConfig(this), () => ({
                type: "dropdown",
                label: "Apply Material",
                limitedUi: !0,
                hidden: () => !this._selectedObject(),
                children: [{
                    label: "select one",
                    value: ""
                }, [...this._viewer.getPlugin(AssetManagerPlugin).materials.getAllMaterials().map(o => ({
                    label: o.name || o.uuid,
                    value: o.uuid
                })) || []]],
                getValue: () => {
                    var o;
                    return (o = this._selectedMaterial()) === null || o === void 0 ? void 0 : o.uuid
                }
                ,
                setValue: o => {
                    var c, h, _, b, _e;
                    const nt = (_ = (h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(AssetManagerPlugin)) === null || h === void 0 ? void 0 : h.materials) === null || _ === void 0 ? void 0 : _.findMaterial(o);
                    if (nt)
                        if (this.replaceMaterial)
                            (_e = (b = this._selectedObject()) === null || b === void 0 ? void 0 : b.setMaterial) === null || _e === void 0 || _e.call(b, nt);
                        else {
                            const it = this._selectedMaterial();
                            if (it) {
                                const at = it.name
                                  , ut = it.uuid;
                                it.copyProps(nt),
                                it.name = at,
                                it.uuid = ut,
                                it.userData.uuid && (it.userData.uuid = ut)
                            }
                        }
                    this._refreshUi()
                }
            })]
        }
    }
    async _refreshUi() {
        var o, c, h;
        if (!await super._refreshUi())
            return !1;
        const _ = [MeshStandardMaterial2.TypeSlug, DiamondMaterial.TypeSlug]
          , b = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(AssetManagerPlugin)) === null || c === void 0 ? void 0 : c.materials
          , _e = _.map(nt => [nt, b == null ? void 0 : b.getMaterialsOfType(nt)]);
        CustomContextGrid.RemoveAll(MaterialLibraryPlugin.PluginType);
        for (const [nt,it] of _e)
            CustomContextGrid.Create(MaterialLibraryPlugin.PluginType, nt, 5, 20, 0, it == null ? void 0 : it.filter(at => !at.userData.runtimeMaterial).map(at => {
                let ut;
                const pt = "generate:sphere";
                if (pt.startsWith("generate:"))
                    ut = this._previewGenerator.generate(at, pt.split(":")[1]);
                else {
                    const ht = at[pt] || "#ff00ff";
                    ut = ht.image ? Ne$1(ht.image, 100) : void 0,
                    ut || (ut = Je$1(ht))
                }
                return {
                    id: at.uuid,
                    image: ut,
                    onClick: ht => {
                        const _t = b == null ? void 0 : b.findMaterial(ht);
                        if (_t) {
                            const vt = _t.userData.__appliedMeshes;
                            if (vt != null && vt.size) {
                                const bt = vt.keys().next().value;
                                bt == null || bt.dispatchEvent({
                                    type: "select",
                                    value: bt
                                })
                            }
                        }
                    }
                    ,
                    tooltip: at.name || at.uuid
                }
            }
            ), (at, ut) => tippy_esm(at, {
                placement: "bottom",
                content: ut.tooltip
            }));
        return CustomContextGrid.RebuildUi((h = this._viewer) === null || h === void 0 ? void 0 : h.container),
        !0
    }
}
MaterialLibraryPlugin.PluginType = "MaterialLibraryPlugin",
MaterialLibraryPlugin_decorate([uiToggle("Replace Material")], MaterialLibraryPlugin.prototype, "replaceMaterial", void 0);
var FSShadowMaterial_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class FSShadowMaterial extends three_module.q2 {
    constructor() {
        super(...arguments),
        this.typeSlug = "fsShadow",
        this.assetType = "material",
        this._uniforms = {},
        this.lastFrameTexture = null
    }
    get materialObject() {
        return this
    }
    onBeforeCompile(o, c) {
        o.vertexShader = o.vertexShader.replace("#include <project_vertex>", `
#include <project_vertex>
gl_Position = vec4(uv*2.-1., 0, 1.); 
        `),
        o.vertexShader = o.vertexShader.replace("void main() {", `
varying vec2 vUv;
void main() {
    vUv = uv;
        `),
        o.fragmentShader = o.fragmentShader.replace("void main() {", `
varying vec2 vUv;
uniform sampler2D tLastThis;
void main() {
        `),
        o.fragmentShader = o.fragmentShader.replace("gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );", fe$1`
float shadow = getShadowMask();

//shift the color by dither_shift
shadow = clamp(shadow + mix(-1./512., 1./512., rand( gl_FragCoord.xy )), 0., 1.);

float last = unpackRGBAToDepth(texture2D(tLastThis, vUv));
gl_FragColor = packDepthToRGBA(mix(last, shadow, opacity));
//if not useMovingAverage:
//gl_FragColor = packDepthToRGBA(shadow * opacity + last);
        `),
        Object.assign(o.uniforms, this._uniforms),
        super.onBeforeCompile(o, c)
    }
    customProgramCacheKey() {
        return super.customProgramCacheKey()
    }
    toJSON(o) {
        throw new Error("Method not supported for this material.")
    }
    fromJSON(o, c) {
        throw new Error("Method not supported for this material.")
    }
    copyProps(o) {
        throw new Error("Method not supported for this material.")
    }
    setDirty(o) {
        this.needsUpdate = !0,
        this.dispatchEvent({
            ...o,
            type: "materialUpdate"
        })
    }
}
FSShadowMaterial_decorate([uniform({
    propKey: "tLastThis"
})], FSShadowMaterial.prototype, "lastFrameTexture", void 0);
var seperableShadowBlur = `#include <packing>
uniform sampler2D colorTexture;uniform vec2 size;uniform vec2 direction;uniform float step;varying vec2 vUv;void main(){float sum=0.;vec2 uvDelta=step*direction/size;sum+=unpackRGBAToDepth(texture2D(colorTexture,vUv-1.*uvDelta))*0.3333;sum+=unpackRGBAToDepth(texture2D(colorTexture,vec2(vUv.x,vUv.y)))*0.3333;sum+=unpackRGBAToDepth(texture2D(colorTexture,vUv+1.*uvDelta))*0.3333;gl_FragColor=packDepthToRGBA(sum);}`
  , ShadowMapBaker_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class ShadowMapBaker extends I$2 {
    get attachedMesh() {
        return this._attachedMesh
    }
    set attachedMesh(o) {
        this._attachedMesh !== o && (this._attachedMesh && this.cleanupMaterial(),
        this._attachedMesh = o,
        this._attachedMesh && this._updateMaterial())
    }
    get target() {
        return this._target
    }
    get light() {
        return this._light
    }
    constructor(o) {
        super(),
        this.enabled = !0,
        this._lightLayer = 5,
        this._frameNumber = 0,
        this.maxFrameNumber = 400,
        this.smoothShadow = !1,
        this.shadowMapType = three_module.bTm,
        this.groundMapMode = "aoMap",
        this.alphaVignette = !0,
        this.alphaVignetteAxis = "xy",
        this.shadowAutoUpdate = !0,
        this._bakeCounter = 0,
        this.maxBakeCount = 1 / 0,
        this.materialExtension = {
            parsFragmentSnippet: (h, _) => fe$1`
            uniform float transitionOpacity;
            `,
            extraUniforms: {
                transitionOpacity: {
                    value: 1
                }
            },
            shaderExtender: (h, _, b) => {
                this.groundMapMode === "aoMap" ? h.fragmentShader = shaderReplaceString(h.fragmentShader, "#include <aomap_fragment>", shaderReplaceString(three_module.vxI.aomap_fragment, "float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;", "float ambientOcclusion = ( mix(1., unpackRGBAToDepth(texture2D( aoMap, vAoMapUv ) ), transitionOpacity) - 1.0) * aoMapIntensity + 1.0;")) : this.groundMapMode === "map" ? h.fragmentShader = shaderReplaceString(h.fragmentShader, "#include <map_fragment>", shaderReplaceString(three_module.vxI.map_fragment, "diffuseColor *= sampledDiffuseColor", "float groundShadow = mix(1., unpackRGBAToDepth(sampledDiffuseColor), transitionOpacity); diffuseColor.rgb *= groundShadow; diffuseColor.a *= max(0., 1.-groundShadow) * transitionOpacity;")) : this.groundMapMode === "alphaMap" && (h.fragmentShader = shaderReplaceString(h.fragmentShader, "#include <alphamap_fragment>", shaderReplaceString(three_module.vxI.alphamap_fragment, "texture2D( alphaMap, vAlphaMapUv ).g", "1. - unpackRGBAToDepth( texture2D( alphaMap, vAlphaMapUv ) )", {
                    replaceAll: !0
                }))),
                h.fragmentShader = shaderReplaceString(h.fragmentShader, "#include <opaque_fragment>", fe$1`#include <opaque_fragment>
                #ifndef OPAQUE
                    #ifdef USE_AOMAP
                        #if NUM_DIR_LIGHT_SHADOWS > 0
                            // TODO find a better solution
                            float alphaMod = length(reflectedLight.directDiffuse)*4./float(NUM_DIR_LIGHT_SHADOWS);
                        #else
                            float alphaMod = 1.;
                        #endif
                        float t1 = 1. - ambientOcclusion;
                        float t2 = max(1. - alphaMod, 0.);
                        float t = t1 + t2;
                        gl_FragColor.a *= max(t, 0.);
                    #endif
                #endif
            `),
                this.alphaVignette && b.capabilities.isWebGL2 && (h.defines.USE_UV = "",
                h.fragmentShader = shaderReplaceString(h.fragmentShader, "#include <opaque_fragment>", fe$1`#include <opaque_fragment>
                    #ifndef OPAQUE
                    float weight = 0.;
                    #ifdef USE_UV // why are we checking for this? this is always supposed to be true
                    weight = 2.*abs(length(0.5 - vUv.${this.alphaVignetteAxis}));
                    #endif
                    #if defined(USE_LIGHTMAP) || defined(USE_AOMAP)
                    weight = 2.*abs(length(0.5 - vAoMapUv.${this.alphaVignetteAxis}));
                    #endif
                    weight = min(1., max(0., weight))-0.5;
                    weight = min(1., max(0., 1.0-2.*weight));
                    weight = pow(weight, 1.5);
                    gl_FragColor.a *= weight;
                    //gl_FragColor.rgb /= max(0.01, weight);
                    gl_FragColor = saturate(gl_FragColor);
                    //gl_FragColor.a = 0.5;
                    #endif
                    `))
            }
            ,
            computeCacheKey: () => this.groundMapMode + "." + this.alphaVignette + "." + this.alphaVignetteAxis,
            onObjectRender: (h, _) => {
                _.materialObject.userData.gMapMode !== this.groundMapMode && (_.materialObject.userData.gMapMode = this.groundMapMode,
                _.materialObject.needsUpdate = !0)
            }
            ,
            isCompatible: h => h.isMeshStandardMaterial2
        },
        this._viewer = o;
        const c = new RandomizedDirectionalLight(16777215,10,{
            near: 1.5,
            far: 20,
            bias: 0,
            frustumSize: 4,
            width: 1024,
            height: 1024,
            enabled: !0,
            radius: 10,
            normalBias: 0
        },{
            direction: new three_module.Pq0(.2,1,.2).normalize(),
            spread: .9,
            focus: 1,
            distanceScale: 20,
            minDistanceScale: new three_module.Pq0(10,10,10),
            normalDirection: new three_module.Pq0(0,1,0)
        });
        c.shadow.camera.updateProjectionMatrix(),
        c.layers.disableAll(),
        c.layers.set(this._lightLayer),
        this._light = c,
        o.scene.addLight(this._light, {
            addToRoot: !0
        }),
        this._shadowMat = new FSShadowMaterial({
            color: "#ffffff",
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            premultipliedAlpha: !1,
            opacity: 1,
            transparent: !1,
            blending: three_module.XIg
        }),
        this._shadowBlurMat = new ShaderMaterial2({
            uniforms: {
                colorTexture: {
                    value: null
                },
                step: {
                    value: .1
                },
                size: {
                    value: new three_module.I9Y(.5,.5)
                },
                direction: {
                    value: new three_module.I9Y(.5,.5)
                }
            },
            vertexShader: defaultVertex,
            fragmentShader: seperableShadowBlur
        })
    }
    dispose() {
        this._shadowMat.dispose(),
        this._target = void 0,
        this.reset()
    }
    cleanupMaterial() {
        this._updateMaterial(!0)
    }
    _groundMapModeChanged() {
        this._attachedMesh && (this.cleanupMaterial(),
        this._updateMaterial(),
        this.groundMapMode === "alphaMap" ? this._attachedMesh.material.transparent = !0 : this._attachedMesh.material.transparent = !1),
        this.reset()
    }
    _alphaVignetteChanged() {
        var o, c, h;
        (c = (o = this.materialExtension) === null || o === void 0 ? void 0 : o.setDirty) === null || c === void 0 || c.call(o),
        (h = this._viewer) === null || h === void 0 || h.setDirty()
    }
    fromJSON(o, c) {
        return deserializeObject(o, this, !0, c),
        this.reset(),
        this
    }
    reset() {
        this._frameNumber = 0
    }
    get frameNumber() {
        return this._frameNumber
    }
    autoUpdateShadow() {
        return !(!this.shadowAutoUpdate || this._bakeCounter >= this.maxBakeCount || !this.updateShadow() || (this._frameNumber === this.maxFrameNumber ? this.dispatchEvent({
            type: "shadowBaked",
            bakeCount: ++this._bakeCounter
        }) : this._frameNumber > 0 && this._frameNumber < this.maxFrameNumber && this.dispatchEvent({
            type: "shadowBaking",
            progress: this._frameNumber / this.maxFrameNumber,
            bakeCount: this._bakeCounter
        }),
        0))
    }
    updateShadow() {
        if (!this.enabled)
            return !1;
        const o = this._attachedMesh;
        if (!o || ++this._frameNumber > this.maxFrameNumber)
            return !1;
        const c = 1024;
        this._target || (this._target = this._viewer.renderer.createTarget({
            type: three_module.OUM,
            depthBuffer: !1,
            size: new three_module.I9Y(c,c),
            sizeMultiplier: void 0,
            colorSpace: three_module.jf0,
            format: three_module.GWd
        })),
        this._frameNumber < 3 ? this._light.randomizePosition(0, 1, 0) : this._light.randomizePosition(this._frameNumber),
        o.castShadow = !1;
        const h = this._viewer.renderer.rendererObject
          , _ = h.shadowMap
          , b = _.type
          , _e = _.needsUpdate
          , nt = _.autoUpdate;
        _.type = this.shadowMapType,
        _.needsUpdate = !0,
        _.autoUpdate = !1;
        const it = this._viewer.scene
          , at = new three_module.zgK;
        at.disableAll(),
        it.modelObject.traverse(vt => {
            vt.isLight && vt !== this._light.lightObject && (vt.userData.__gp_layers = vt.layers,
            vt.layers = at)
        }
        );
        const ut = it.activeCamera.cameraObject;
        if (ut.layers.mask & 1 << this._lightLayer)
            throw "Camera can render pseudo directional light, check layers";
        ut.layers.enable(this._lightLayer),
        o.layers.disable(this._lightLayer),
        setThreeRendererMode(h, {
            shadowMapRender: !0,
            backgroundRender: !1,
            sceneRender: !1
        }, () => this._viewer.renderer.renderScene(it)),
        ut.layers.disable(this._lightLayer);
        const pt = ut.layers.mask;
        ut.layers.set(this._lightLayer),
        o.layers.enable(this._lightLayer);
        const ht = this._viewer.renderer.getTempTarget({
            type: three_module.OUM,
            depthBuffer: !1,
            size: new three_module.I9Y(c,c),
            colorSpace: three_module.jf0,
            format: three_module.GWd
        })
          , _t = ht.texture.colorSpace;
        ht.texture.colorSpace = three_module.jf0,
        this._viewer.renderer.blit(this._target.texture, ht, {
            clear: !0
        });
        {
            const vt = o.material
              , bt = o.frustumCulled
              , St = h.getRenderTarget()
              , At = h.getActiveCubeFace()
              , Et = h.getActiveMipmapLevel();
            o.material = this._shadowMat,
            o.frustumCulled = !1,
            h.setRenderTarget(this._target),
            this._shadowMat.opacity = Math.max(1 / this.maxFrameNumber, 1 / this._frameNumber),
            this._shadowMat.lastFrameTexture = ht.texture,
            this._shadowMat.needsUpdate = !0,
            setThreeRendererMode(h, {
                shadowMapRender: !1,
                backgroundRender: !1,
                opaqueRender: !0,
                transparentRender: !1,
                transmissionRender: !1
            }, () => this._viewer.renderer.renderScene(it)),
            h.setRenderTarget(St, At, Et),
            o.frustumCulled = bt,
            o.material = vt,
            this.smoothShadow && this._applySmoothFilter(this._target, ht)
        }
        return ht.texture.colorSpace = _t,
        this._viewer.renderer.releaseTempTarget(ht),
        o.layers.disable(this._lightLayer),
        ut.layers.mask = pt,
        it.modelObject.traverse(vt => {
            vt.isLight && vt !== this._light.lightObject && (vt.layers = vt.userData.__gp_layers,
            delete vt.userData.__gp_layers)
        }
        ),
        _.type = b,
        _.needsUpdate = _e,
        _.autoUpdate = nt,
        o.castShadow = !0,
        (this._frameNumber < 3 || this._frameNumber > Math.min(100, this.maxFrameNumber) && this._frameNumber % 4 == 0) && (this._updateMaterial(),
        this._viewer.setDirty(),
        o.dispatchEvent({
            type: "materialUpdate"
        })),
        !0
    }
    _updateMaterial(o=!1) {
        var c, h, _;
        this._attachedMesh && (o ? (this._attachedMesh.material.alphaMap === ((c = this._target) === null || c === void 0 ? void 0 : c.texture) && (this._attachedMesh.material.alphaMap = null),
        this._attachedMesh.material.aoMap === ((h = this._target) === null || h === void 0 ? void 0 : h.texture) && (this._attachedMesh.material.aoMap = null),
        this._attachedMesh.material.map === ((_ = this._target) === null || _ === void 0 ? void 0 : _.texture) && (this._attachedMesh.material.map = null)) : this._target && (this.groundMapMode === "alphaMap" && (this._attachedMesh.material.alphaMap = this._target.texture),
        this.groundMapMode === "aoMap" && (this._attachedMesh.material.aoMap = this._target.texture),
        this.groundMapMode === "map" && (this._attachedMesh.material.map = this._target.texture)),
        this._attachedMesh.material && (this._attachedMesh.material.userData.ALPHA_I_RGBA_PACKING = !o && this.groundMapMode === "alphaMap",
        this._attachedMesh.material.alphaTest = o || this.groundMapMode !== "alphaMap" ? 0 : .01,
        this._attachedMesh.material.needsUpdate = !0))
    }
    _applySmoothFilter(o, c) {
        this._shadowBlurMat.uniforms.colorTexture.value = o.texture,
        this._shadowBlurMat.uniforms.direction.value.set(1, 0),
        this._shadowBlurMat.uniforms.size.value.set(o.width, o.height),
        this._viewer.renderer.blit(void 0, c, {
            material: this._shadowBlurMat
        }),
        this._shadowBlurMat.uniforms.colorTexture.value = c.texture,
        this._shadowBlurMat.uniforms.direction.value.set(0, 1),
        this._shadowBlurMat.uniforms.size.value.set(c.width, c.height),
        this._viewer.renderer.blit(void 0, o, {
            material: this._shadowBlurMat
        })
    }
}
ShadowMapBaker_decorate([serialize("randomizedLight")], ShadowMapBaker.prototype, "_light", void 0),
ShadowMapBaker_decorate([x$1(ShadowMapBaker.prototype.reset), serialize()], ShadowMapBaker.prototype, "maxFrameNumber", void 0),
ShadowMapBaker_decorate([x$1(ShadowMapBaker.prototype.reset), serialize()], ShadowMapBaker.prototype, "smoothShadow", void 0),
ShadowMapBaker_decorate([serialize(), x$1(ShadowMapBaker.prototype.reset)], ShadowMapBaker.prototype, "shadowMapType", void 0),
ShadowMapBaker_decorate([x$1(ShadowMapBaker.prototype._groundMapModeChanged), serialize()], ShadowMapBaker.prototype, "groundMapMode", void 0),
ShadowMapBaker_decorate([serialize(), x$1(ShadowMapBaker.prototype._alphaVignetteChanged)], ShadowMapBaker.prototype, "alphaVignette", void 0),
ShadowMapBaker_decorate([serialize(), x$1(ShadowMapBaker.prototype._alphaVignetteChanged)], ShadowMapBaker.prototype, "alphaVignetteAxis", void 0),
ShadowMapBaker_decorate([serialize()], ShadowMapBaker.prototype, "maxBakeCount", void 0);
var reflectorSample = `#ifndef D_sceneBoundingRadius
#define D_sceneBoundingRadius 
uniform float sceneBoundingRadius;
#endif
varying vec4 vRefUv;uniform sampler2D tRefDiffuse;uniform vec2 tRefDiffuseSize;float getSpecularMIPLevel(const in float roughness,const in float maxMIPLevel){float sigma=PI*roughness*roughness/(1.+roughness);float desiredMIPLevel=maxMIPLevel+log2(sigma);return clamp(desiredMIPLevel,0.,maxMIPLevel);}vec4 getReflectionColor(const in float roughness,const in float depthModifier){float mip=getSpecularMIPLevel(roughness+depthModifier,5.);vec4 color=texture2D(tRefDiffuse,vRefUv.xy/vRefUv.w,mip);float blurDist=saturate(2./(1.+pow(abs(vViewPosition.z),0.25)))*mip*32.*color.a;float rnd=PI2*interleavedGradientNoise(vUv.xy,frameCount);vec4 rotationMatrix=vec4(cos(rnd),-sin(rnd),0.,0.);rotationMatrix.z=-rotationMatrix.y;rotationMatrix.w=rotationMatrix.x;vec3 colorSum=color.rgb*color.a;float weightSum=0.001+color.a;vec2 ofs;setPds();
#pragma unroll_loop_start
for(int i=0;i<16;i++){ofs=poisson_disk_samples[UNROLLED_LOOP_INDEX];ofs=vec2(dot(ofs,rotationMatrix.xy),dot(ofs,rotationMatrix.zw));ofs=vRefUv.xy+vRefUv.w*blurDist*ofs/tRefDiffuseSize.xy;color=texture2D(tRefDiffuse,ofs/vRefUv.w,mip);colorSum+=color.rgb*color.a;weightSum+=color.a;}
#pragma unroll_loop_end
return vec4(colorSum/weightSum,1.);}`
  , Reflector2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class Reflector2 extends three_module.eaF {
    _updateExtension() {
        var o, c;
        this.transparentReflectionBackground = this.reflectorModePhysical,
        (c = (o = this.materialExtension) === null || o === void 0 ? void 0 : o.setDirty) === null || c === void 0 || c.call(o)
    }
    constructor(o, c, h=0) {
        super(o),
        this.type = "Reflector",
        this.isReflector2 = !0,
        this.enabled = !0,
        this.reflectorModePhysical = !0,
        this.reflectionTargetNeedsUpdate = !0,
        this.transparentReflectionBackground = !0,
        this.materialExtension = {
            extraUniforms: {
                tRefDiffuse: {
                    value: null
                },
                tRefDiffuseSize: {
                    value: new three_module.I9Y
                },
                refTextureMatrix: {
                    value: null
                },
                frameCount: {
                    value: 0
                },
                sceneBoundingRadius: {
                    value: 0
                }
            },
            extraDefines: {
                USE_UV: ""
            },
            updaters: [],
            shaderExtender: (St, At, Et) => {
                if (this.enabled) {
                    St.vertexShader = shaderReplaceString(St.vertexShader, "void main() {", `void main() {
vRefUv = refTextureMatrix * vec4( position, 1.0 );`);
                    const Pt = "#glMarker beforeModulation";
                    St.fragmentShader = shaderReplaceString(St.fragmentShader, Pt, `
                    if(roughnessFactor < 0.95) {
                        float d = 0.;//textureProj(tRefDepth, vRefUv).r;
                        // d = min(2., max(0., (d-0.06) * ((7./3.-ior)) * sceneBoundingRadius));
                        vec4 refBaseColor = getReflectionColor(material.roughness, material.roughness * d);
                        // refBaseColor.rgb = vec3(refBaseColor.a);
                        // refBaseColor.a *= 1.0 - clamp(material.roughness * .3, 0., 1.);
                        ` + (this.reflectorModePhysical ? `
                        #if !defined(SSR_ENABLED) || SSR_ENABLED < 1 
                        vec3 specularColor = EnvironmentBRDF(geometryNormal, geometryViewDir, material.specularColor.rgb, material.specularF90, material.roughness);
                        #endif
                        reflectedLight.indirectSpecular = mix(vec3(reflectedLight.indirectSpecular), saturate(specularColor.rgb * refBaseColor.rgb), refBaseColor.a);
                        ` : `
                        reflectedLight.indirectSpecular = saturate(diffuseColor.rgb * refBaseColor.rgb);
                        diffuseColor.a *= refBaseColor.a;
                        `) + `}
` + Pt)
                }
            }
            ,
            parsVertexSnippet: () => this.enabled ? `
		uniform mat4 refTextureMatrix;
		varying vec4 vRefUv;
` : "",
            parsFragmentSnippet: () => this.enabled ? poissonDiskSamples + `
` + randomHelpers + `
` + reflectorSample : "",
            computeCacheKey: St => this.enabled + " " + St.materialObject.transparent + " " + this.reflectorModePhysical + " ",
            onObjectRender: (St, {materialObject: At}) => {
                At.userData.__lastTransparent !== At.transparent && (At.needsUpdate = !0,
                At.userData.__lastTransparent = At.transparent)
            }
            ,
            isCompatible: St => St.isMeshStandardMaterial2
        },
        this.material = void 0,
        this._renderTarget = c;
        const _ = new three_module.Zcv
          , b = new three_module.Pq0
          , _e = new three_module.Pq0
          , nt = new three_module.Pq0
          , it = new three_module.kn4
          , at = new three_module.Pq0(0,0,-1)
          , ut = new three_module.IUQ
          , pt = new three_module.Pq0
          , ht = new three_module.Pq0
          , _t = new three_module.IUQ
          , vt = new three_module.kn4
          , bt = new three_module.ubm;
        three_module.cj9.isPowerOfTwo(c.texture.image.width) && three_module.cj9.isPowerOfTwo(c.texture.image.height) || (this._renderTarget.texture.generateMipmaps = !1),
        this.onBeforeRender = (St, At, Et) => {
            if (!this.enabled || !St.userData.mainRenderPass || !this.reflectionTargetNeedsUpdate)
                return;
            const Pt = Et.view ? Object.assign({}, Et.view) : null;
            if (Pt && Et.clearViewOffset && Et.clearViewOffset(),
            _e.setFromMatrixPosition(this.matrixWorld),
            nt.setFromMatrixPosition(Et.matrixWorld),
            it.extractRotation(this.matrixWorld),
            b.set(0, 0, 1),
            b.applyMatrix4(it),
            pt.subVectors(_e, nt),
            pt.dot(b) > 0)
                return;
            pt.reflect(b).negate(),
            pt.add(_e),
            it.extractRotation(Et.matrixWorld),
            at.set(0, 0, -1),
            at.applyMatrix4(it),
            at.add(nt),
            ht.subVectors(_e, at),
            ht.reflect(b).negate(),
            ht.add(_e),
            bt.position.copy(pt),
            bt.up.set(0, 1, 0),
            bt.up.applyMatrix4(it),
            bt.up.reflect(b),
            bt.lookAt(ht),
            bt.far = 2,
            bt.near = 0,
            bt.updateMatrixWorld(),
            bt.projectionMatrix.copy(Et.projectionMatrix),
            vt.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            vt.multiply(bt.projectionMatrix),
            vt.multiply(bt.matrixWorldInverse),
            vt.multiply(this.matrixWorld),
            _.setFromNormalAndCoplanarPoint(b, _e),
            _.applyMatrix4(bt.matrixWorldInverse),
            ut.set(_.normal.x, _.normal.y, _.normal.z, _.constant);
            const It = bt.projectionMatrix;
            _t.x = (Math.sign(ut.x) + It.elements[8]) / It.elements[0],
            _t.y = (Math.sign(ut.y) + It.elements[9]) / It.elements[5],
            _t.z = -1,
            _t.w = (1 + It.elements[10]) / It.elements[14],
            ut.multiplyScalar(2 / ut.dot(_t)),
            It.elements[2] = ut.x,
            It.elements[6] = ut.y,
            It.elements[10] = ut.z + 1 - h,
            It.elements[14] = ut.w,
            this.visible = !1;
            const Dt = St.getRenderTarget()
              , Gt = St.xr.enabled
              , Bt = St.shadowMap.autoUpdate;
            St.xr.enabled = !1,
            St.shadowMap.autoUpdate = !1,
            St.setRenderTarget(this._renderTarget),
            St.state.buffers.depth.setMask(!0),
            St.autoClear === !1 && St.clear();
            const kt = At.background;
            this.transparentReflectionBackground && (At.background = null);
            const Ut = !this.transparentReflectionBackground;
            kt != null && kt.isTexture && Ut && (kt.userData || (kt.userData = {}),
            kt.userData.flipX = !kt.userData.flipX),
            setThreeRendererMode(St, {
                shadowMapRender: !1,
                backgroundRender: Ut,
                opaqueRender: !0,
                transparentRender: !0,
                transmissionRender: !1,
                screenSpaceRendering: !1
            }, () => St.render(At, bt)),
            kt != null && kt.isTexture && Ut && (kt.userData.flipX = !kt.userData.flipX || void 0),
            this.transparentReflectionBackground && (At.background = kt),
            St.xr.enabled = Gt,
            St.shadowMap.autoUpdate = Bt,
            St.setRenderTarget(Dt),
            Pt != null && Pt.enabled && Et.setViewOffset && Et.setViewOffset(Pt.fullWidth, Pt.fullHeight, Pt.offsetX, Pt.offsetY, Pt.width, Pt.height);
            const Ht = Et.viewport;
            Ht !== void 0 && St.state.viewport(Ht),
            this.visible = !0,
            this.reflectionTargetNeedsUpdate = !1
        }
        ,
        this.textureMatrix = vt,
        this.materialExtension.extraUniforms.tRefDiffuse.value = this._renderTarget.texture,
        this.materialExtension.extraUniforms.tRefDiffuseSize.value = new three_module.I9Y(this._renderTarget.width,this._renderTarget.height),
        this.materialExtension.extraUniforms.refTextureMatrix.value = vt
    }
    getRenderTarget() {
        return this._renderTarget
    }
}
Reflector2_decorate([x$1(Reflector2.prototype._updateExtension)], Reflector2.prototype, "enabled", void 0),
Reflector2_decorate([x$1(Reflector2.prototype._updateExtension)], Reflector2.prototype, "reflectorModePhysical", void 0),
Reflector2.prototype.isReflector = !0;
var BaseGroundPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class BaseGroundPlugin extends AViewerPlugin {
    get enabled() {
        return this.visible
    }
    set enabled(o) {
        this.visible = o
    }
    get material() {
        return this._material
    }
    get mesh() {
        return this._iMesh
    }
    constructor(o={}) {
        super(),
        this._transformNeedRefresh = !0,
        this.dependencies = [AssetManagerPlugin],
        this.visible = !0,
        this.size = 8,
        this.yOffset = 0,
        this.renderToDepth = !0,
        this.tonemapGround = !0,
        this.limitCameraAboveGround = !1,
        this.enableRefreshTransform = !0,
        this._cameraLimitsSet = !1,
        this._cameraLastMaxPolarAngle = Math.PI,
        this.useModelBounds = !1,
        this._refreshMaterial = this._refreshMaterial.bind(this),
        this._refreshTransform = this._refreshTransform.bind(this),
        this._refreshCameraLimits = this._refreshCameraLimits.bind(this),
        this.refreshOptions = this.refreshOptions.bind(this),
        this._refreshOptions2 = this._refreshOptions2.bind(this),
        this._onSceneUpdate = this._onSceneUpdate.bind(this),
        this._preRender = this._preRender.bind(this),
        this._postFrame = this._postFrame.bind(this),
        this._geometry = new three_module.bdM(1,1,1,1),
        this._geometry.attributes.uv2 = this._geometry.attributes.uv.clone(),
        this._geometry.attributes.uv2.needsUpdate = !0,
        this._options = {
            shape: "",
            up: [0, 100, 0],
            autoAdjustTransform: !0
        },
        this.setOptions(o)
    }
    get autoAdjustTransform() {
        return this._options.autoAdjustTransform
    }
    set autoAdjustTransform(o) {
        this._options.autoAdjustTransform = o,
        this.refreshTransform()
    }
    _createMesh() {
        return new three_module.eaF(this._geometry)
    }
    setGeometry(o) {
        o ? this._geometry && this._geometry.dispose() : o = this._geometry,
        o && (o.attributes.uv2 || (o.attributes.uv2 = o.attributes.uv.clone(),
        o.attributes.uv2.needsUpdate = !0),
        this._mesh && (this._mesh.geometry = o))
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        o.getPluginByType("TweakpaneUi") && console.error("TweakpaneUiPlugin must be added after Ground Plugin"),
        this._manager = o.getPlugin(AssetManagerPlugin);
        const _ = this._createMesh();
        _.userData.physicsMass = 0,
        _.userData.isGroundMesh = !0,
        this._iMesh = await ((c = this._manager) === null || c === void 0 ? void 0 : c.addImportedSingle(_, {
            pseudoCenter: !1,
            autoScale: !1,
            addToRoot: !0
        })),
        this._mesh = (h = this._iMesh) === null || h === void 0 ? void 0 : h.modelObject,
        this._mesh && (this._mesh.userData.userSelectable = !1,
        this._mesh.castShadow = !0,
        this._mesh.receiveShadow = !0,
        this._mesh.name = "Ground Plane"),
        o.scene.addEventListener("sceneUpdate", this._onSceneUpdate),
        o.scene.addEventListener("addSceneObject", this._onSceneUpdate),
        o.addEventListener("preRender", this._preRender),
        o.addEventListener("postFrame", this._postFrame),
        this.refreshOptions()
    }
    _postFrame() {
        this._transformNeedRefresh && this._refreshTransform(),
        this._viewer
    }
    _preRender() {
        this._viewer
    }
    async onDispose(o) {
        var c, h, _;
        return this._removeMaterial(),
        this._geometry.dispose(),
        (c = this._material) === null || c === void 0 || c.dispose(),
        (_ = (h = this._iMesh) === null || h === void 0 ? void 0 : h.dispose) === null || _ === void 0 || _.call(h),
        super.onDispose(o)
    }
    async onRemove(o) {
        return this._removeMaterial(),
        o.scene.removeEventListener("sceneUpdate", this._onSceneUpdate),
        o.scene.removeEventListener("addSceneObject", this._onSceneUpdate),
        o.removeEventListener("postFrame", this._postFrame),
        o.removeEventListener("preRender", this._preRender),
        this._manager = void 0,
        super.onRemove(o)
    }
    _removeMaterial() {
        this._material && (this._material.userData.renderToDepth = this._material.userData.__renderToDepth,
        this._material.userData.__renderToDepth = void 0,
        this._material = void 0)
    }
    _onSceneUpdate(o) {
        (o == null ? void 0 : o.geometryChanged) !== !1 && (o == null ? void 0 : o.updateGround) !== !1 && this.refreshTransform()
    }
    refreshTransform() {
        this.enableRefreshTransform && (this._transformNeedRefresh = !0)
    }
    _refreshOptions2() {
        this.refreshOptions()
    }
    refreshOptions() {
        this._viewer && (this._refreshMaterial(),
        this.refreshTransform(),
        this._refreshCameraLimits())
    }
    _refreshCameraLimits() {
        var o;
        const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.activeCamera.controls;
        c && (c.maxPolarAngle !== void 0 ? this.limitCameraAboveGround ? (this._cameraLimitsSet || (this._cameraLastMaxPolarAngle = c.maxPolarAngle),
        c.maxPolarAngle = Math.PI / 2,
        this._cameraLimitsSet = !0) : this._cameraLimitsSet && (c.maxPolarAngle = this._cameraLastMaxPolarAngle,
        this._cameraLimitsSet = !1) : console.warn("refreshCameraLimits only available with orbit controls."))
    }
    _refreshTransform() {
        var o, c, h;
        if (!this._mesh || !this._viewer)
            return;
        let _ = !1;
        if (this.visible !== this._mesh.visible && (this._mesh.visible = this.visible,
        _ = !0),
        this.enabled) {
            if (this._options.autoAdjustTransform) {
                this._mesh.userData.bboxVisible = !1;
                const b = this.useModelBounds ? this._viewer.scene.getModelBounds(!0, !0, !0) : this._viewer.scene.getBounds(!0, !0, !0);
                this._mesh.userData.bboxVisible = !0;
                const _e = b.getCenter(new three_module.Pq0).sub(new three_module.Pq0(0,b.getSize(new three_module.Pq0).y / 2 + this.yOffset,0));
                _ = _ || _e.clone().sub(this._mesh.position).length() > 1e-4,
                _ && this._mesh.position.copy(_e)
            }
            _ = _ || Math.abs(this._mesh.scale.x - this.size) > 1e-4,
            _ && (this._mesh.scale.setScalar(this.size),
            this._mesh.setRotationFromEuler(new three_module.O9p(-Math.PI / 2,0,this._mesh.rotation.z)),
            this._mesh.matrixWorldNeedsUpdate = !0,
            (h = (c = this._mesh).setDirty) === null || h === void 0 || h.call(c)),
            this._transformNeedRefresh = !1
        } else
            _ && ((o = this._viewer) === null || o === void 0 || o.scene.setDirty())
    }
    _refreshMaterial() {
        var o, c, h, _, b, _e;
        if (!this._viewer || !this.enabled)
            return !1;
        this._manager || console.error("GroundPlugin requires asset manager");
        const nt = (o = this._material) !== null && o !== void 0 ? o : (h = (c = this._manager) === null || c === void 0 ? void 0 : c.materials) === null || h === void 0 ? void 0 : h.findOrCreate("standard", {
            name: "BaseGroundMaterial",
            runtimeMaterial: !0,
            color: 16777215,
            roughness: .75,
            metalness: .5
        });
        nt && nt.userData.runtimeMaterial;
        let it = !1;
        return nt !== this._material && (this._removeMaterial(),
        nt && (this._material = nt),
        !((_ = this._material) === null || _ === void 0) && _.uuid || console.warn("No material found for ground"),
        this._viewer.scene.setDirty(),
        this._mesh && this._material && (this._material.roughness = .75,
        this._material.metalness = .5,
        ((_e = (b = this._mesh) === null || b === void 0 ? void 0 : b.setMaterial) !== null && _e !== void 0 ? _e : ut => {
            this._mesh && (this._mesh.material = ut.materialObject)
        }
        )(this._material)),
        it = !0),
        this._material && (this._material.userData.__renderToDepth === void 0 && (this._material.userData.__renderToDepth = this._material.userData.renderToDepth),
        this._material.userData.renderToDepth !== this.renderToDepth && (this._material.userData.renderToDepth = this.renderToDepth),
        this._material.userData.__postTonemap === void 0 && (this._material.userData.__postTonemap = this._material.userData.postTonemap),
        this._material.userData.postTonemap !== this.tonemapGround && (this._material.userData.postTonemap = this.tonemapGround),
        this._material.materialObject.userData.ssaoDisabled = !0,
        this._material.materialObject.userData.sscsDisabled = !0),
        this._viewer.setDirty(this),
        it
    }
    setOptions(o) {
        Object.assign(this._options, o),
        this.refreshOptions()
    }
    fromJSON(o, c) {
        return super.fromJSON(o, c) ? (this.refreshOptions(),
        this) : null
    }
    _extraUiConfig() {
        return [ () => {
            var o;
            return (o = this._material) === null || o === void 0 ? void 0 : o.uiConfig
        }
        ]
    }
    get uiConfig() {
        return this._uiConfig ? this._uiConfig : this._uiConfig = {
            type: "folder",
            label: "Ground",
            children: [{
                label: "Visible",
                type: "checkbox",
                property: [this, "visible"],
                limitedUi: !0
            }, {
                label: "Size",
                type: "input",
                property: [this, "size"],
                limitedUi: !0
            }, {
                label: "Render to Depth",
                type: "checkbox",
                property: [this, "renderToDepth"]
            }, {
                label: "Limit Camera",
                type: "checkbox",
                property: [this, "limitCameraAboveGround"]
            }, {
                label: "Tonemap",
                type: "checkbox",
                property: [this, "tonemapGround"]
            }, {
                label: "Height",
                type: "slider",
                bounds: [-2, 2],
                property: [this, "yOffset"]
            }, {
                label: "Auto adjust transform",
                type: "checkbox",
                property: [this, "autoAdjustTransform"]
            }, ...this._extraUiConfig()]
        }
    }
}
BaseGroundPlugin_decorate([serialize("material")], BaseGroundPlugin.prototype, "_material", void 0),
BaseGroundPlugin_decorate([x$1(BaseGroundPlugin.prototype.refreshTransform), serialize()], BaseGroundPlugin.prototype, "visible", void 0),
BaseGroundPlugin_decorate([ze$1(BaseGroundPlugin.prototype._onSceneUpdate), serialize()], BaseGroundPlugin.prototype, "size", void 0),
BaseGroundPlugin_decorate([ze$1(BaseGroundPlugin.prototype._onSceneUpdate), serialize()], BaseGroundPlugin.prototype, "yOffset", void 0),
BaseGroundPlugin_decorate([x$1(BaseGroundPlugin.prototype._refreshOptions2), serialize()], BaseGroundPlugin.prototype, "renderToDepth", void 0),
BaseGroundPlugin_decorate([x$1(BaseGroundPlugin.prototype._refreshOptions2), serialize()], BaseGroundPlugin.prototype, "tonemapGround", void 0),
BaseGroundPlugin_decorate([x$1(BaseGroundPlugin.prototype._refreshCameraLimits), serialize()], BaseGroundPlugin.prototype, "limitCameraAboveGround", void 0);
var GroundPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class GroundPlugin extends BaseGroundPlugin {
    get shadowBaker() {
        return this._shadowBaker
    }
    bakeShadows() {
        var o;
        (o = this._shadowBaker) === null || o === void 0 || o.reset()
    }
    constructor(o={}, c=!1) {
        super(o),
        this.bakedShadows = !0,
        this.groundReflection = !1,
        this.physicalReflections = !1,
        this.autoFrustumSize = !0,
        this.autoBakeShadows = !0,
        this._showDebug = c,
        c && this.dependencies.push(DebugPlugin),
        this._onSceneUpdate = this._onSceneUpdate.bind(this)
    }
    _createMesh() {
        const o = new Reflector2(this._geometry,this._viewer.renderer.createTarget({
            type: three_module.OUM,
            format: three_module.GWd,
            colorSpace: three_module.jf0,
            size: {
                width: 1024,
                height: 1024
            },
            generateMipmaps: !0,
            depthBuffer: !0,
            minFilter: three_module.$_I,
            magFilter: three_module.k6q
        }))
          , c = o.onBeforeRender;
        return o.onBeforeRender = (...h) => {
            var _, b, _e, nt, it;
            let at = (b = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getPluginByType("SSReflection")) === null || b === void 0 ? void 0 : b.passes.ssr.passObject;
            at && !at.enabled && (at = void 0),
            at && (at.enabled = !1);
            let ut = (it = (nt = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.getPluginByType("SSBevelPlugin")) === null || nt === void 0 ? void 0 : nt.pass) === null || it === void 0 ? void 0 : it.passObject;
            ut && !ut.enabled && (ut = void 0),
            ut && (ut.enabled = !1),
            c(...h),
            at && (at.enabled = !0),
            ut && (ut.enabled = !0)
        }
        ,
        o
    }
    async onAdded(o) {
        var c, h;
        await super.onAdded(o),
        this._showDebug && ((c = o.getPlugin(DebugPlugin)) === null || c === void 0 || c.addTexture("bake_ground_1", () => {
            var _, b;
            return (b = (_ = this._shadowBaker) === null || _ === void 0 ? void 0 : _.light.shadow.map) === null || b === void 0 ? void 0 : b.texture
        }
        , [100, 100, 200, 200]),
        (h = o.getPlugin(DebugPlugin)) === null || h === void 0 || h.addTexture("bake_ground_2", () => {
            var _, b;
            return (b = (_ = this._shadowBaker) === null || _ === void 0 ? void 0 : _.target) === null || b === void 0 ? void 0 : b.texture
        }
        , [100, 400, 400, 400], "texel = vec4(vec3(unpackRGBAToDepth(texel)), 1.0);"))
    }
    _postFrame() {
        super._postFrame(),
        this._viewer && this.enabled && this._shadowBaker && this.bakedShadows && this._shadowBaker.autoUpdateShadow()
    }
    _preRender() {
        super._preRender(),
        this._viewer && (this._mesh.reflectionTargetNeedsUpdate = this._viewer.renderer.frameCount < 1)
    }
    async onDispose(o) {
        return super.onDispose(o)
    }
    async onRemove(o) {
        return super.onRemove(o)
    }
    _removeMaterial() {
        var o, c, h, _;
        if (this._material) {
            if (this._shadowBaker && this._material.groundMatExtension && ((c = (o = this._material).unregisterMaterialExtensions) === null || c === void 0 || c.call(o, [this._shadowBaker.materialExtension]),
            delete this._material.groundMatExtension),
            this._material.reflectorMatExtension) {
                const b = this._mesh.materialExtension;
                b || console.warn("WebGi GroundPlugin: unable to find the extension to unregister"),
                (_ = (h = this._material).unregisterMaterialExtensions) === null || _ === void 0 || _.call(h, [b]),
                delete this._material.reflectorMatExtension
            }
            super._removeMaterial()
        }
    }
    _onSceneUpdate(o) {
        var c;
        super._onSceneUpdate(o),
        o.geometryChanged !== !1 && this.autoBakeShadows && ((c = this._shadowBaker) === null || c === void 0 || c.reset())
    }
    refreshOptions() {
        if (!this._viewer)
            return;
        this.bakedShadows && !this._shadowBaker ? (this._shadowBaker = new ShadowMapBaker(this._viewer),
        this._shadowBaker.attachedMesh = this._mesh) : !this.bakedShadows && this._shadowBaker && (this._shadowBaker.reset(),
        this._shadowBaker.cleanupMaterial());
        const o = this._mesh;
        o.isReflector2 && (o.enabled = this.groundReflection,
        o.reflectorModePhysical = this.physicalReflections),
        super.refreshOptions(),
        this._viewer.setDirty(this)
    }
    _refreshTransform() {
        if (this.autoFrustumSize) {
            const o = this.shadowBaker;
            if (o) {
                const c = this.size / 2;
                c !== o.light.shadowParams.frustumSize && (o.light.shadowParams.frustumSize = c,
                o.light.updateShadowParams(),
                o.reset())
            }
        }
        super._refreshTransform()
    }
    fromJSON(o, c) {
        return super.fromJSON(o, c) ? (o.autoFrustumSize === void 0 && (this.autoFrustumSize = !1),
        this) : null
    }
    _refreshMaterial() {
        var o, c, h, _;
        if (!this._viewer)
            return !1;
        const b = super._refreshMaterial();
        if (!this._material)
            return b;
        if (this.groundReflection && this._mesh.isReflector2 && !this._material.reflectorMatExtension) {
            const _e = this._mesh.materialExtension;
            _e.updaters = [this._viewer.scene, this._viewer.renderer],
            (c = (o = this._material).registerMaterialExtensions) === null || c === void 0 || c.call(o, [_e]),
            this._material.reflectorMatExtension = !0
        }
        return this.bakedShadows && this._shadowBaker && !this._material.groundMatExtension && ((_ = (h = this._material).registerMaterialExtensions) === null || _ === void 0 || _.call(h, [this._shadowBaker.materialExtension]),
        this._material.groundMatExtension = !0),
        this._material.materialObject.userData.ssreflDisabled = this.groundReflection,
        this._material.materialObject.userData.ssreflNonPhysical = !this.physicalReflections,
        this._viewer.setDirty(this),
        b
    }
    _extraUiConfig() {
        var o, c, h, _, b, _e, nt, it, at, ut, pt, ht, _t, vt, bt, St, At, Et, Pt, It, Dt, Gt, Bt, kt, Ut, Ht, Kt, Jt, or, ir;
        return [{
            label: "Baked Shadows",
            type: "checkbox",
            property: [this, "bakedShadows"]
        }, {
            label: "Shadow Frames",
            type: "input",
            hidden: () => !this._shadowBaker,
            stepSize: 1,
            bounds: [1, 1e3],
            property: [this._shadowBaker, "maxFrameNumber"]
        }, {
            label: "Alpha Vignette",
            type: "checkbox",
            hidden: () => !this._material || this._material.transmission < 1e-4 && !this._material.transparent,
            property: [this._shadowBaker, "alphaVignette"],
            limitedUi: !0,
            onChange: () => {
                var lr, ar;
                return (ar = (lr = this._uiConfig) === null || lr === void 0 ? void 0 : lr.uiRefresh) === null || ar === void 0 ? void 0 : ar.call(lr, "postFrame", !0)
            }
        }, {
            label: "Alpha Vignette Axis",
            type: "dropdown",
            hidden: () => {
                var lr;
                return !(!((lr = this._shadowBaker) === null || lr === void 0) && lr.alphaVignette) || !this._material || this._material.transmission < 1e-4 && !this._material.transparent
            }
            ,
            property: [this._shadowBaker, "alphaVignetteAxis"],
            children: ["x", "y", "xy"].map(lr => ({
                label: lr,
                value: lr
            })),
            limitedUi: !0
        }, {
            label: "Planar Reflections",
            type: "checkbox",
            property: [this, "groundReflection"]
        }, {
            label: "Auto Frustum Size",
            type: "checkbox",
            property: [this, "autoFrustumSize"]
        }, {
            label: "Physical Reflections",
            type: "checkbox",
            property: [this, "physicalReflections"],
            limitedUi: !0
        }, {
            label: "Shadow type",
            type: "dropdown",
            hidden: () => !this._shadowBaker,
            property: [this._shadowBaker, "groundMapMode"],
            children: [{
                label: "aoMap"
            }, {
                label: "map"
            }, {
                label: "alphaMap"
            }],
            limitedUi: !0
        }, {
            label: "Smooth Shadow",
            type: "checkbox",
            property: [this._shadowBaker, "smoothShadow"]
        }, {
            label: "Baked shadow type",
            type: "dropdown",
            children: [["Basic", three_module.bTm], ["PCF", three_module.QP0], ["PCFSoft", three_module.Wk7], ["VSM", three_module.RyA]].map(lr => ({
                label: lr[0].toString(),
                value: lr[1]
            })),
            property: [this._shadowBaker, "shadowMapType"]
        }, {
            type: "folder",
            label: "Randomized Light",
            hidden: () => !this._shadowBaker,
            limitedUi: !0,
            children: [{
                type: "color",
                label: "Color",
                property: [(o = this._shadowBaker) === null || o === void 0 ? void 0 : o.light, "color"]
            }, {
                type: "slider",
                label: "Intensity",
                bounds: [0, 100],
                property: [(c = this._shadowBaker) === null || c === void 0 ? void 0 : c.light, "intensity"]
            }, {
                type: "checkbox",
                label: "Shadow Enabled",
                property: [(_ = (h = this._shadowBaker) === null || h === void 0 ? void 0 : h.light) === null || _ === void 0 ? void 0 : _.shadowParams, "enabled"],
                onChange: [(_e = (b = this._shadowBaker) === null || b === void 0 ? void 0 : b.light) === null || _e === void 0 ? void 0 : _e.updateShadowParams, this._onSceneUpdate]
            }, {
                type: "slider",
                bounds: [0, 1],
                property: [(it = (nt = this._shadowBaker) === null || nt === void 0 ? void 0 : nt.light) === null || it === void 0 ? void 0 : it.randomParams, "focus"],
                onChange: [this._onSceneUpdate]
            }, {
                type: "slider",
                bounds: [0, 1],
                property: [(ut = (at = this._shadowBaker) === null || at === void 0 ? void 0 : at.light) === null || ut === void 0 ? void 0 : ut.randomParams, "spread"],
                onChange: [this._onSceneUpdate],
                limitedUi: !0
            }, {
                type: "slider",
                bounds: [.01, 60],
                property: [(ht = (pt = this._shadowBaker) === null || pt === void 0 ? void 0 : pt.light) === null || ht === void 0 ? void 0 : ht.randomParams, "distanceScale"],
                onChange: [(vt = (_t = this._shadowBaker) === null || _t === void 0 ? void 0 : _t.light) === null || vt === void 0 ? void 0 : vt.updateShadowParams, this._onSceneUpdate]
            }, {
                type: "vec3",
                bounds: [-1, 1],
                property: [(St = (bt = this._shadowBaker) === null || bt === void 0 ? void 0 : bt.light) === null || St === void 0 ? void 0 : St.randomParams, "direction"],
                onChange: [this._onSceneUpdate],
                limitedUi: !0
            }, {
                type: "vec3",
                bounds: [-1, 1],
                property: [(Et = (At = this._shadowBaker) === null || At === void 0 ? void 0 : At.light) === null || Et === void 0 ? void 0 : Et.randomParams, "normalDirection"],
                onChange: [this._onSceneUpdate],
                limitedUi: !0
            }, {
                type: "slider",
                bounds: [.01, 10],
                property: [(It = (Pt = this._shadowBaker) === null || Pt === void 0 ? void 0 : Pt.light) === null || It === void 0 ? void 0 : It.shadowParams, "radius"],
                onChange: [(Gt = (Dt = this._shadowBaker) === null || Dt === void 0 ? void 0 : Dt.light) === null || Gt === void 0 ? void 0 : Gt.updateShadowParams, this._onSceneUpdate]
            }, {
                type: "input",
                property: [(kt = (Bt = this._shadowBaker) === null || Bt === void 0 ? void 0 : Bt.light) === null || kt === void 0 ? void 0 : kt.shadowParams, "frustumSize"],
                hidden: () => this.autoFrustumSize,
                onChange: [(Ht = (Ut = this._shadowBaker) === null || Ut === void 0 ? void 0 : Ut.light) === null || Ht === void 0 ? void 0 : Ht.updateShadowParams, this._onSceneUpdate]
            }, {
                type: "slider",
                bounds: [-.1, .1],
                property: [(Jt = (Kt = this._shadowBaker) === null || Kt === void 0 ? void 0 : Kt.light) === null || Jt === void 0 ? void 0 : Jt.shadowParams, "bias"],
                onChange: [(ir = (or = this._shadowBaker) === null || or === void 0 ? void 0 : or.light) === null || ir === void 0 ? void 0 : ir.updateShadowParams, this._onSceneUpdate]
            }]
        }, ...super._extraUiConfig()]
    }
}
GroundPlugin.PluginType = "Ground",
GroundPlugin_decorate([x$1(GroundPlugin.prototype.refreshOptions), serialize()], GroundPlugin.prototype, "bakedShadows", void 0),
GroundPlugin_decorate([x$1(GroundPlugin.prototype.refreshOptions), serialize()], GroundPlugin.prototype, "groundReflection", void 0),
GroundPlugin_decorate([x$1(GroundPlugin.prototype.refreshOptions), serialize()], GroundPlugin.prototype, "physicalReflections", void 0),
GroundPlugin_decorate([x$1(GroundPlugin.prototype.refreshOptions), serialize()], GroundPlugin.prototype, "autoFrustumSize", void 0),
GroundPlugin_decorate([serialize("shadowBaker")], GroundPlugin.prototype, "_shadowBaker", void 0);
class EXRLoader extends three_module.BRH {
    constructor(o) {
        super(o),
        this.type = three_module.ix0
    }
    parse(o) {
        const b = Math.pow(2.7182818, 2.2)
          , _e = {
            l: 0,
            c: 0,
            lc: 0
        };
        function nt(ur, pr, Ir, jr, Qr) {
            for (; Ir < ur; )
                pr = pr << 8 | wr(jr, Qr),
                Ir += 8;
            Ir -= ur,
            _e.l = pr >> Ir & (1 << ur) - 1,
            _e.c = pr,
            _e.lc = Ir
        }
        const it = new Array(59);
        function at(ur) {
            return 63 & ur
        }
        function ut(ur) {
            return ur >> 6
        }
        const pt = {
            c: 0,
            lc: 0
        };
        function ht(ur, pr, Ir, jr) {
            ur = ur << 8 | wr(Ir, jr),
            pr += 8,
            pt.c = ur,
            pt.lc = pr
        }
        const _t = {
            c: 0,
            lc: 0
        };
        function vt(ur, pr, Ir, jr, Qr, Or, qr, gn, Mn) {
            if (ur == pr) {
                jr < 8 && (ht(Ir, jr, Qr, Or),
                Ir = pt.c,
                jr = pt.lc);
                let Tn = Ir >> (jr -= 8);
                if (Tn = new Uint8Array([Tn])[0],
                gn.value + Tn > Mn)
                    return !1;
                const wn = qr[gn.value - 1];
                for (; Tn-- > 0; )
                    qr[gn.value++] = wn
            } else {
                if (!(gn.value < Mn))
                    return !1;
                qr[gn.value++] = ur
            }
            _t.c = Ir,
            _t.lc = jr
        }
        function bt(ur) {
            return 65535 & ur
        }
        function St(ur) {
            const pr = bt(ur);
            return pr > 32767 ? pr - 65536 : pr
        }
        const At = {
            a: 0,
            b: 0
        };
        function Et(ur, pr) {
            const Ir = St(ur)
              , jr = St(pr)
              , Qr = Ir + (1 & jr) + (jr >> 1)
              , Or = Qr
              , qr = Qr - jr;
            At.a = Or,
            At.b = qr
        }
        function Pt(ur, pr) {
            const Ir = bt(ur)
              , jr = bt(pr)
              , Qr = Ir - (jr >> 1) & 65535
              , Or = jr + Qr - 32768 & 65535;
            At.a = Or,
            At.b = Qr
        }
        function It(ur, pr, Ir, jr, Qr, Or, qr) {
            const gn = qr < 16384
              , Mn = Ir > Qr ? Qr : Ir;
            let Tn, wn, Cn = 1;
            for (; Cn <= Mn; )
                Cn <<= 1;
            for (Cn >>= 1,
            Tn = Cn,
            Cn >>= 1; Cn >= 1; ) {
                wn = 0;
                const fn = wn + Or * (Qr - Tn)
                  , bn = Or * Cn
                  , Xn = Or * Tn
                  , En = jr * Cn
                  , Qn = jr * Tn;
                let Rn, Yn, Bo, vo;
                for (; wn <= fn; wn += Xn) {
                    let Hn = wn;
                    const $n = wn + jr * (Ir - Tn);
                    for (; Hn <= $n; Hn += Qn) {
                        const ao = Hn + En
                          , zo = Hn + bn
                          , Zo = zo + En;
                        gn ? (Et(ur[Hn + pr], ur[zo + pr]),
                        Rn = At.a,
                        Bo = At.b,
                        Et(ur[ao + pr], ur[Zo + pr]),
                        Yn = At.a,
                        vo = At.b,
                        Et(Rn, Yn),
                        ur[Hn + pr] = At.a,
                        ur[ao + pr] = At.b,
                        Et(Bo, vo),
                        ur[zo + pr] = At.a,
                        ur[Zo + pr] = At.b) : (Pt(ur[Hn + pr], ur[zo + pr]),
                        Rn = At.a,
                        Bo = At.b,
                        Pt(ur[ao + pr], ur[Zo + pr]),
                        Yn = At.a,
                        vo = At.b,
                        Pt(Rn, Yn),
                        ur[Hn + pr] = At.a,
                        ur[ao + pr] = At.b,
                        Pt(Bo, vo),
                        ur[zo + pr] = At.a,
                        ur[Zo + pr] = At.b)
                    }
                    if (Ir & Cn) {
                        const ao = Hn + bn;
                        gn ? Et(ur[Hn + pr], ur[ao + pr]) : Pt(ur[Hn + pr], ur[ao + pr]),
                        Rn = At.a,
                        ur[ao + pr] = At.b,
                        ur[Hn + pr] = Rn
                    }
                }
                if (Qr & Cn) {
                    let Hn = wn;
                    const $n = wn + jr * (Ir - Tn);
                    for (; Hn <= $n; Hn += Qn) {
                        const ao = Hn + En;
                        gn ? Et(ur[Hn + pr], ur[ao + pr]) : Pt(ur[Hn + pr], ur[ao + pr]),
                        Rn = At.a,
                        ur[ao + pr] = At.b,
                        ur[Hn + pr] = Rn
                    }
                }
                Tn = Cn,
                Cn >>= 1
            }
            return wn
        }
        function Dt(ur, pr, Ir, jr, Qr, Or) {
            const qr = Ir.value
              , gn = Ar(pr, Ir)
              , Mn = Ar(pr, Ir);
            Ir.value += 4;
            const Tn = Ar(pr, Ir);
            if (Ir.value += 4,
            gn < 0 || gn >= 65537 || Mn < 0 || Mn >= 65537)
                throw new Error("Something wrong with HUF_ENCSIZE");
            const wn = new Array(65537)
              , Cn = new Array(16384);
            if (function(fn) {
                for (let bn = 0; bn < 16384; bn++)
                    fn[bn] = {},
                    fn[bn].len = 0,
                    fn[bn].lit = 0,
                    fn[bn].p = null
            }(Cn),
            function(fn, bn, Xn, En, Qn, Rn) {
                const Yn = bn;
                let Bo = 0
                  , vo = 0;
                for (; En <= Qn; En++) {
                    if (Yn.value - bn.value > Xn)
                        return !1;
                    nt(6, Bo, vo, fn, Yn);
                    const Hn = _e.l;
                    if (Bo = _e.c,
                    vo = _e.lc,
                    Rn[En] = Hn,
                    Hn == 63) {
                        if (Yn.value - bn.value > Xn)
                            throw new Error("Something wrong with hufUnpackEncTable");
                        nt(8, Bo, vo, fn, Yn);
                        let $n = _e.l + 6;
                        if (Bo = _e.c,
                        vo = _e.lc,
                        En + $n > Qn + 1)
                            throw new Error("Something wrong with hufUnpackEncTable");
                        for (; $n--; )
                            Rn[En++] = 0;
                        En--
                    } else if (Hn >= 59) {
                        let $n = Hn - 59 + 2;
                        if (En + $n > Qn + 1)
                            throw new Error("Something wrong with hufUnpackEncTable");
                        for (; $n--; )
                            Rn[En++] = 0;
                        En--
                    }
                }
                (function(Hn) {
                    for (let ao = 0; ao <= 58; ++ao)
                        it[ao] = 0;
                    for (let ao = 0; ao < 65537; ++ao)
                        it[Hn[ao]] += 1;
                    let $n = 0;
                    for (let ao = 58; ao > 0; --ao) {
                        const zo = $n + it[ao] >> 1;
                        it[ao] = $n,
                        $n = zo
                    }
                    for (let ao = 0; ao < 65537; ++ao) {
                        const zo = Hn[ao];
                        zo > 0 && (Hn[ao] = zo | it[zo]++ << 6)
                    }
                }
                )(Rn)
            }(ur, Ir, jr - (Ir.value - qr), gn, Mn, wn),
            Tn > 8 * (jr - (Ir.value - qr)))
                throw new Error("Something wrong with hufUncompress");
            (function(fn, bn, Xn, En) {
                for (; bn <= Xn; bn++) {
                    const Qn = ut(fn[bn])
                      , Rn = at(fn[bn]);
                    if (Qn >> Rn)
                        throw new Error("Invalid table entry");
                    if (Rn > 14) {
                        const Yn = En[Qn >> Rn - 14];
                        if (Yn.len)
                            throw new Error("Invalid table entry");
                        if (Yn.lit++,
                        Yn.p) {
                            const Bo = Yn.p;
                            Yn.p = new Array(Yn.lit);
                            for (let vo = 0; vo < Yn.lit - 1; ++vo)
                                Yn.p[vo] = Bo[vo]
                        } else
                            Yn.p = new Array(1);
                        Yn.p[Yn.lit - 1] = bn
                    } else if (Rn) {
                        let Yn = 0;
                        for (let Bo = 1 << 14 - Rn; Bo > 0; Bo--) {
                            const vo = En[(Qn << 14 - Rn) + Yn];
                            if (vo.len || vo.p)
                                throw new Error("Invalid table entry");
                            vo.len = Rn,
                            vo.lit = bn,
                            Yn++
                        }
                    }
                }
            }
            )(wn, gn, Mn, Cn),
            function(fn, bn, Xn, En, Qn, Rn, Yn, Bo, vo) {
                let Hn = 0
                  , $n = 0;
                const ao = Yn
                  , zo = Math.trunc(En.value + (Qn + 7) / 8);
                for (; En.value < zo; )
                    for (ht(Hn, $n, Xn, En),
                    Hn = pt.c,
                    $n = pt.lc; $n >= 14; ) {
                        const $o = bn[Hn >> $n - 14 & 16383];
                        if ($o.len)
                            $n -= $o.len,
                            vt($o.lit, Rn, Hn, $n, Xn, En, Bo, vo, ao),
                            Hn = _t.c,
                            $n = _t.lc;
                        else {
                            if (!$o.p)
                                throw new Error("hufDecode issues");
                            let Yo;
                            for (Yo = 0; Yo < $o.lit; Yo++) {
                                const ss = at(fn[$o.p[Yo]]);
                                for (; $n < ss && En.value < zo; )
                                    ht(Hn, $n, Xn, En),
                                    Hn = pt.c,
                                    $n = pt.lc;
                                if ($n >= ss && ut(fn[$o.p[Yo]]) == (Hn >> $n - ss & (1 << ss) - 1)) {
                                    $n -= ss,
                                    vt($o.p[Yo], Rn, Hn, $n, Xn, En, Bo, vo, ao),
                                    Hn = _t.c,
                                    $n = _t.lc;
                                    break
                                }
                            }
                            if (Yo == $o.lit)
                                throw new Error("hufDecode issues")
                        }
                    }
                const Zo = 8 - Qn & 7;
                for (Hn >>= Zo,
                $n -= Zo; $n > 0; ) {
                    const $o = bn[Hn << 14 - $n & 16383];
                    if (!$o.len)
                        throw new Error("hufDecode issues");
                    $n -= $o.len,
                    vt($o.lit, Rn, Hn, $n, Xn, En, Bo, vo, ao),
                    Hn = _t.c,
                    $n = _t.lc
                }
            }(wn, Cn, ur, Ir, Tn, Mn, Or, Qr, {
                value: 0
            })
        }
        function Gt(ur) {
            for (let pr = 1; pr < ur.length; pr++) {
                const Ir = ur[pr - 1] + ur[pr] - 128;
                ur[pr] = Ir
            }
        }
        function Bt(ur, pr) {
            let Ir = 0
              , jr = Math.floor((ur.length + 1) / 2)
              , Qr = 0;
            const Or = ur.length - 1;
            for (; !(Qr > Or || (pr[Qr++] = ur[Ir++],
            Qr > Or)); )
                pr[Qr++] = ur[jr++]
        }
        function kt(ur) {
            let pr = ur.byteLength;
            const Ir = new Array;
            let jr = 0;
            const Qr = new DataView(ur);
            for (; pr > 0; ) {
                const Or = Qr.getInt8(jr++);
                if (Or < 0) {
                    const qr = -Or;
                    pr -= qr + 1;
                    for (let gn = 0; gn < qr; gn++)
                        Ir.push(Qr.getUint8(jr++))
                } else {
                    const qr = Or;
                    pr -= 2;
                    const gn = Qr.getUint8(jr++);
                    for (let Mn = 0; Mn < qr + 1; Mn++)
                        Ir.push(gn)
                }
            }
            return Ir
        }
        function Ut(ur, pr, Ir) {
            let jr, Qr = 1;
            for (; Qr < 64; )
                jr = pr[ur.value],
                jr == 65280 ? Qr = 64 : jr >> 8 == 255 ? Qr += 255 & jr : (Ir[Qr] = jr,
                Qr++),
                ur.value++
        }
        function Ht(ur) {
            const pr = .5 * Math.cos(.7853975)
              , Ir = .5 * Math.cos(3.14159 / 16)
              , jr = .5 * Math.cos(3.14159 / 8)
              , Qr = .5 * Math.cos(3 * 3.14159 / 16)
              , Or = .5 * Math.cos(.981746875)
              , qr = .5 * Math.cos(3 * 3.14159 / 8)
              , gn = .5 * Math.cos(1.374445625)
              , Mn = new Array(4)
              , Tn = new Array(4)
              , wn = new Array(4)
              , Cn = new Array(4);
            for (let fn = 0; fn < 8; ++fn) {
                const bn = 8 * fn;
                Mn[0] = jr * ur[bn + 2],
                Mn[1] = qr * ur[bn + 2],
                Mn[2] = jr * ur[bn + 6],
                Mn[3] = qr * ur[bn + 6],
                Tn[0] = Ir * ur[bn + 1] + Qr * ur[bn + 3] + Or * ur[bn + 5] + gn * ur[bn + 7],
                Tn[1] = Qr * ur[bn + 1] - gn * ur[bn + 3] - Ir * ur[bn + 5] - Or * ur[bn + 7],
                Tn[2] = Or * ur[bn + 1] - Ir * ur[bn + 3] + gn * ur[bn + 5] + Qr * ur[bn + 7],
                Tn[3] = gn * ur[bn + 1] - Or * ur[bn + 3] + Qr * ur[bn + 5] - Ir * ur[bn + 7],
                wn[0] = pr * (ur[bn + 0] + ur[bn + 4]),
                wn[3] = pr * (ur[bn + 0] - ur[bn + 4]),
                wn[1] = Mn[0] + Mn[3],
                wn[2] = Mn[1] - Mn[2],
                Cn[0] = wn[0] + wn[1],
                Cn[1] = wn[3] + wn[2],
                Cn[2] = wn[3] - wn[2],
                Cn[3] = wn[0] - wn[1],
                ur[bn + 0] = Cn[0] + Tn[0],
                ur[bn + 1] = Cn[1] + Tn[1],
                ur[bn + 2] = Cn[2] + Tn[2],
                ur[bn + 3] = Cn[3] + Tn[3],
                ur[bn + 4] = Cn[3] - Tn[3],
                ur[bn + 5] = Cn[2] - Tn[2],
                ur[bn + 6] = Cn[1] - Tn[1],
                ur[bn + 7] = Cn[0] - Tn[0]
            }
            for (let fn = 0; fn < 8; ++fn)
                Mn[0] = jr * ur[16 + fn],
                Mn[1] = qr * ur[16 + fn],
                Mn[2] = jr * ur[48 + fn],
                Mn[3] = qr * ur[48 + fn],
                Tn[0] = Ir * ur[8 + fn] + Qr * ur[24 + fn] + Or * ur[40 + fn] + gn * ur[56 + fn],
                Tn[1] = Qr * ur[8 + fn] - gn * ur[24 + fn] - Ir * ur[40 + fn] - Or * ur[56 + fn],
                Tn[2] = Or * ur[8 + fn] - Ir * ur[24 + fn] + gn * ur[40 + fn] + Qr * ur[56 + fn],
                Tn[3] = gn * ur[8 + fn] - Or * ur[24 + fn] + Qr * ur[40 + fn] - Ir * ur[56 + fn],
                wn[0] = pr * (ur[fn] + ur[32 + fn]),
                wn[3] = pr * (ur[fn] - ur[32 + fn]),
                wn[1] = Mn[0] + Mn[3],
                wn[2] = Mn[1] - Mn[2],
                Cn[0] = wn[0] + wn[1],
                Cn[1] = wn[3] + wn[2],
                Cn[2] = wn[3] - wn[2],
                Cn[3] = wn[0] - wn[1],
                ur[0 + fn] = Cn[0] + Tn[0],
                ur[8 + fn] = Cn[1] + Tn[1],
                ur[16 + fn] = Cn[2] + Tn[2],
                ur[24 + fn] = Cn[3] + Tn[3],
                ur[32 + fn] = Cn[3] - Tn[3],
                ur[40 + fn] = Cn[2] - Tn[2],
                ur[48 + fn] = Cn[1] - Tn[1],
                ur[56 + fn] = Cn[0] - Tn[0]
        }
        function Kt(ur) {
            for (let pr = 0; pr < 64; ++pr) {
                const Ir = ur[0][pr]
                  , jr = ur[1][pr]
                  , Qr = ur[2][pr];
                ur[0][pr] = Ir + 1.5747 * Qr,
                ur[1][pr] = Ir - .1873 * jr - .4682 * Qr,
                ur[2][pr] = Ir + 1.8556 * jr
            }
        }
        function Jt(ur, pr, Ir) {
            for (let Qr = 0; Qr < 64; ++Qr)
                pr[Ir + Qr] = three_module.GxU.toHalfFloat((jr = ur[Qr]) <= 1 ? Math.sign(jr) * Math.pow(Math.abs(jr), 2.2) : Math.sign(jr) * Math.pow(b, Math.abs(jr) - 1));
            var jr
        }
        function or(ur) {
            return new DataView(ur.array.buffer,ur.offset.value,ur.size)
        }
        function ir(ur) {
            const pr = ur.viewer.buffer.slice(ur.offset.value, ur.offset.value + ur.size)
              , Ir = new Uint8Array(kt(pr))
              , jr = new Uint8Array(Ir.length);
            return Gt(Ir),
            Bt(Ir, jr),
            new DataView(jr.buffer)
        }
        function lr(ur) {
            const pr = fflate_module_unzlibSync(ur.array.slice(ur.offset.value, ur.offset.value + ur.size))
              , Ir = new Uint8Array(pr.length);
            return Gt(pr),
            Bt(pr, Ir),
            new DataView(Ir.buffer)
        }
        function ar(ur) {
            const pr = ur.viewer
              , Ir = {
                value: ur.offset.value
            }
              , jr = new Uint16Array(ur.width * ur.scanlineBlockSize * (ur.channels * ur.type))
              , Qr = new Uint8Array(8192);
            let Or = 0;
            const qr = new Array(ur.channels);
            for (let Xn = 0; Xn < ur.channels; Xn++)
                qr[Xn] = {},
                qr[Xn].start = Or,
                qr[Xn].end = qr[Xn].start,
                qr[Xn].nx = ur.width,
                qr[Xn].ny = ur.lines,
                qr[Xn].size = ur.type,
                Or += qr[Xn].nx * qr[Xn].ny * qr[Xn].size;
            const gn = Zr(pr, Ir)
              , Mn = Zr(pr, Ir);
            if (Mn >= 8192)
                throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
            if (gn <= Mn)
                for (let Xn = 0; Xn < Mn - gn + 1; Xn++)
                    Qr[Xn + gn] = Rr(pr, Ir);
            const Tn = new Uint16Array(65536)
              , wn = function(Xn, En) {
                let Qn = 0;
                for (let Yn = 0; Yn < 65536; ++Yn)
                    (Yn == 0 || Xn[Yn >> 3] & 1 << (7 & Yn)) && (En[Qn++] = Yn);
                const Rn = Qn - 1;
                for (; Qn < 65536; )
                    En[Qn++] = 0;
                return Rn
            }(Qr, Tn)
              , Cn = Ar(pr, Ir);
            Dt(ur.array, pr, Ir, Cn, jr, Or);
            for (let Xn = 0; Xn < ur.channels; ++Xn) {
                const En = qr[Xn];
                for (let Qn = 0; Qn < qr[Xn].size; ++Qn)
                    It(jr, En.start + Qn, En.nx, En.size, En.ny, En.nx * En.size, wn)
            }
            (function(Xn, En, Qn) {
                for (let Rn = 0; Rn < Qn; ++Rn)
                    En[Rn] = Xn[En[Rn]]
            }
            )(Tn, jr, Or);
            let fn = 0;
            const bn = new Uint8Array(jr.buffer.byteLength);
            for (let Xn = 0; Xn < ur.lines; Xn++)
                for (let En = 0; En < ur.channels; En++) {
                    const Qn = qr[En]
                      , Rn = Qn.nx * Qn.size
                      , Yn = new Uint8Array(jr.buffer,2 * Qn.end,2 * Rn);
                    bn.set(Yn, fn),
                    fn += 2 * Rn,
                    Qn.end += Rn
                }
            return new DataView(bn.buffer)
        }
        function hr(ur) {
            const pr = fflate_module_unzlibSync(ur.array.slice(ur.offset.value, ur.offset.value + ur.size))
              , Ir = ur.lines * ur.channels * ur.width
              , jr = ur.type == 1 ? new Uint16Array(Ir) : new Uint32Array(Ir);
            let Qr = 0
              , Or = 0;
            const qr = new Array(4);
            for (let gn = 0; gn < ur.lines; gn++)
                for (let Mn = 0; Mn < ur.channels; Mn++) {
                    let Tn = 0;
                    switch (ur.type) {
                    case 1:
                        qr[0] = Qr,
                        qr[1] = qr[0] + ur.width,
                        Qr = qr[1] + ur.width;
                        for (let wn = 0; wn < ur.width; ++wn)
                            Tn += pr[qr[0]++] << 8 | pr[qr[1]++],
                            jr[Or] = Tn,
                            Or++;
                        break;
                    case 2:
                        qr[0] = Qr,
                        qr[1] = qr[0] + ur.width,
                        qr[2] = qr[1] + ur.width,
                        Qr = qr[2] + ur.width;
                        for (let wn = 0; wn < ur.width; ++wn)
                            Tn += pr[qr[0]++] << 24 | pr[qr[1]++] << 16 | pr[qr[2]++] << 8,
                            jr[Or] = Tn,
                            Or++
                    }
                }
            return new DataView(jr.buffer)
        }
        function gr(ur) {
            const pr = ur.viewer
              , Ir = {
                value: ur.offset.value
            }
              , jr = new Uint8Array(ur.width * ur.lines * (ur.channels * ur.type * 2))
              , Qr = {
                version: Cr(pr, Ir),
                unknownUncompressedSize: Cr(pr, Ir),
                unknownCompressedSize: Cr(pr, Ir),
                acCompressedSize: Cr(pr, Ir),
                dcCompressedSize: Cr(pr, Ir),
                rleCompressedSize: Cr(pr, Ir),
                rleUncompressedSize: Cr(pr, Ir),
                rleRawSize: Cr(pr, Ir),
                totalAcUncompressedCount: Cr(pr, Ir),
                totalDcUncompressedCount: Cr(pr, Ir),
                acCompression: Cr(pr, Ir)
            };
            if (Qr.version < 2)
                throw new Error("EXRLoader.parse: " + mo.compression + " version " + Qr.version + " is unsupported");
            const Or = new Array;
            let qr = Zr(pr, Ir) - 2;
            for (; qr > 0; ) {
                const En = dr(pr.buffer, Ir)
                  , Qn = Rr(pr, Ir)
                  , Rn = Qn >> 2 & 3
                  , Yn = new Int8Array([(Qn >> 4) - 1])[0]
                  , Bo = Rr(pr, Ir);
                Or.push({
                    name: En,
                    index: Yn,
                    type: Bo,
                    compression: Rn
                }),
                qr -= En.length + 3
            }
            const gn = mo.channels
              , Mn = new Array(ur.channels);
            for (let En = 0; En < ur.channels; ++En) {
                const Qn = Mn[En] = {}
                  , Rn = gn[En];
                Qn.name = Rn.name,
                Qn.compression = 0,
                Qn.decoded = !1,
                Qn.type = Rn.pixelType,
                Qn.pLinear = Rn.pLinear,
                Qn.width = ur.width,
                Qn.height = ur.lines
            }
            const Tn = {
                idx: new Array(3)
            };
            for (let En = 0; En < ur.channels; ++En) {
                const Qn = Mn[En];
                for (let Rn = 0; Rn < Or.length; ++Rn) {
                    const Yn = Or[Rn];
                    Qn.name == Yn.name && (Qn.compression = Yn.compression,
                    Yn.index >= 0 && (Tn.idx[Yn.index] = En),
                    Qn.offset = En)
                }
            }
            let wn, Cn, fn;
            if (Qr.acCompressedSize > 0)
                switch (Qr.acCompression) {
                case 0:
                    wn = new Uint16Array(Qr.totalAcUncompressedCount),
                    Dt(ur.array, pr, Ir, Qr.acCompressedSize, wn, Qr.totalAcUncompressedCount);
                    break;
                case 1:
                    const En = fflate_module_unzlibSync(ur.array.slice(Ir.value, Ir.value + Qr.totalAcUncompressedCount));
                    wn = new Uint16Array(En.buffer),
                    Ir.value += Qr.totalAcUncompressedCount
                }
            if (Qr.dcCompressedSize > 0) {
                const En = {
                    array: ur.array,
                    offset: Ir,
                    size: Qr.dcCompressedSize
                };
                Cn = new Uint16Array(lr(En).buffer),
                Ir.value += Qr.dcCompressedSize
            }
            Qr.rleRawSize > 0 && (fn = kt(fflate_module_unzlibSync(ur.array.slice(Ir.value, Ir.value + Qr.rleCompressedSize)).buffer),
            Ir.value += Qr.rleCompressedSize);
            let bn = 0;
            const Xn = new Array(Mn.length);
            for (let En = 0; En < Xn.length; ++En)
                Xn[En] = new Array;
            for (let En = 0; En < ur.lines; ++En)
                for (let Qn = 0; Qn < Mn.length; ++Qn)
                    Xn[Qn].push(bn),
                    bn += Mn[Qn].width * ur.type * 2;
            (function(En, Qn, Rn, Yn, Bo, vo) {
                let Hn = new DataView(vo.buffer);
                const $n = Rn[En.idx[0]].width
                  , ao = Rn[En.idx[0]].height
                  , zo = Math.floor($n / 8)
                  , Zo = Math.ceil($n / 8)
                  , $o = Math.ceil(ao / 8)
                  , Yo = $n - 8 * (Zo - 1)
                  , ss = ao - 8 * ($o - 1)
                  , Os = {
                    value: 0
                }
                  , $l = new Array(3)
                  , wl = new Array(3)
                  , Ps = new Array(3)
                  , ys = new Array(3)
                  , as = new Array(3);
                for (let Eo = 0; Eo < 3; ++Eo)
                    as[Eo] = Qn[En.idx[Eo]],
                    $l[Eo] = Eo < 1 ? 0 : $l[Eo - 1] + Zo * $o,
                    wl[Eo] = new Float32Array(64),
                    Ps[Eo] = new Uint16Array(64),
                    ys[Eo] = new Uint16Array(64 * Zo);
                for (let Eo = 0; Eo < $o; ++Eo) {
                    let Sl = 8;
                    Eo == $o - 1 && (Sl = ss);
                    let Ks = 8;
                    for (let yo = 0; yo < Zo; ++yo) {
                        yo == Zo - 1 && (Ks = Yo);
                        for (let ko = 0; ko < 3; ++ko)
                            Ps[ko].fill(0),
                            Ps[ko][0] = Bo[$l[ko]++],
                            Ut(Os, Yn, Ps[ko]),
                            Ln = Ps[ko],
                            (Vn = wl[ko])[0] = vr(Ln[0]),
                            Vn[1] = vr(Ln[1]),
                            Vn[2] = vr(Ln[5]),
                            Vn[3] = vr(Ln[6]),
                            Vn[4] = vr(Ln[14]),
                            Vn[5] = vr(Ln[15]),
                            Vn[6] = vr(Ln[27]),
                            Vn[7] = vr(Ln[28]),
                            Vn[8] = vr(Ln[2]),
                            Vn[9] = vr(Ln[4]),
                            Vn[10] = vr(Ln[7]),
                            Vn[11] = vr(Ln[13]),
                            Vn[12] = vr(Ln[16]),
                            Vn[13] = vr(Ln[26]),
                            Vn[14] = vr(Ln[29]),
                            Vn[15] = vr(Ln[42]),
                            Vn[16] = vr(Ln[3]),
                            Vn[17] = vr(Ln[8]),
                            Vn[18] = vr(Ln[12]),
                            Vn[19] = vr(Ln[17]),
                            Vn[20] = vr(Ln[25]),
                            Vn[21] = vr(Ln[30]),
                            Vn[22] = vr(Ln[41]),
                            Vn[23] = vr(Ln[43]),
                            Vn[24] = vr(Ln[9]),
                            Vn[25] = vr(Ln[11]),
                            Vn[26] = vr(Ln[18]),
                            Vn[27] = vr(Ln[24]),
                            Vn[28] = vr(Ln[31]),
                            Vn[29] = vr(Ln[40]),
                            Vn[30] = vr(Ln[44]),
                            Vn[31] = vr(Ln[53]),
                            Vn[32] = vr(Ln[10]),
                            Vn[33] = vr(Ln[19]),
                            Vn[34] = vr(Ln[23]),
                            Vn[35] = vr(Ln[32]),
                            Vn[36] = vr(Ln[39]),
                            Vn[37] = vr(Ln[45]),
                            Vn[38] = vr(Ln[52]),
                            Vn[39] = vr(Ln[54]),
                            Vn[40] = vr(Ln[20]),
                            Vn[41] = vr(Ln[22]),
                            Vn[42] = vr(Ln[33]),
                            Vn[43] = vr(Ln[38]),
                            Vn[44] = vr(Ln[46]),
                            Vn[45] = vr(Ln[51]),
                            Vn[46] = vr(Ln[55]),
                            Vn[47] = vr(Ln[60]),
                            Vn[48] = vr(Ln[21]),
                            Vn[49] = vr(Ln[34]),
                            Vn[50] = vr(Ln[37]),
                            Vn[51] = vr(Ln[47]),
                            Vn[52] = vr(Ln[50]),
                            Vn[53] = vr(Ln[56]),
                            Vn[54] = vr(Ln[59]),
                            Vn[55] = vr(Ln[61]),
                            Vn[56] = vr(Ln[35]),
                            Vn[57] = vr(Ln[36]),
                            Vn[58] = vr(Ln[48]),
                            Vn[59] = vr(Ln[49]),
                            Vn[60] = vr(Ln[57]),
                            Vn[61] = vr(Ln[58]),
                            Vn[62] = vr(Ln[62]),
                            Vn[63] = vr(Ln[63]),
                            Ht(wl[ko]);
                        Kt(wl);
                        for (let ko = 0; ko < 3; ++ko)
                            Jt(wl[ko], ys[ko], 64 * yo)
                    }
                    let ds = 0;
                    for (let yo = 0; yo < 3; ++yo) {
                        const ko = Rn[En.idx[yo]].type;
                        for (let xs = 8 * Eo; xs < 8 * Eo + Sl; ++xs) {
                            ds = as[yo][xs];
                            for (let Js = 0; Js < zo; ++Js) {
                                const bs = 64 * Js + 8 * (7 & xs);
                                Hn.setUint16(ds + 0 * ko, ys[yo][bs + 0], !0),
                                Hn.setUint16(ds + 2 * ko, ys[yo][bs + 1], !0),
                                Hn.setUint16(ds + 4 * ko, ys[yo][bs + 2], !0),
                                Hn.setUint16(ds + 6 * ko, ys[yo][bs + 3], !0),
                                Hn.setUint16(ds + 8 * ko, ys[yo][bs + 4], !0),
                                Hn.setUint16(ds + 10 * ko, ys[yo][bs + 5], !0),
                                Hn.setUint16(ds + 12 * ko, ys[yo][bs + 6], !0),
                                Hn.setUint16(ds + 14 * ko, ys[yo][bs + 7], !0),
                                ds += 16 * ko
                            }
                        }
                        if (zo != Zo)
                            for (let xs = 8 * Eo; xs < 8 * Eo + Sl; ++xs) {
                                const Js = as[yo][xs] + 8 * zo * 2 * ko
                                  , bs = 64 * zo + 8 * (7 & xs);
                                for (let Bl = 0; Bl < Ks; ++Bl)
                                    Hn.setUint16(Js + 2 * Bl * ko, ys[yo][bs + Bl], !0)
                            }
                    }
                }
                var Ln, Vn;
                const Ys = new Uint16Array($n);
                Hn = new DataView(vo.buffer);
                for (let Eo = 0; Eo < 3; ++Eo) {
                    Rn[En.idx[Eo]].decoded = !0;
                    const Sl = Rn[En.idx[Eo]].type;
                    if (Rn[Eo].type == 2)
                        for (let Ks = 0; Ks < ao; ++Ks) {
                            const ds = as[Eo][Ks];
                            for (let yo = 0; yo < $n; ++yo)
                                Ys[yo] = Hn.getUint16(ds + 2 * yo * Sl, !0);
                            for (let yo = 0; yo < $n; ++yo)
                                Hn.setFloat32(ds + 2 * yo * Sl, vr(Ys[yo]), !0)
                        }
                }
            }
            )(Tn, Xn, Mn, wn, Cn, jr);
            for (let En = 0; En < Mn.length; ++En) {
                const Qn = Mn[En];
                if (!Qn.decoded) {
                    if (Qn.compression !== 2)
                        throw new Error("EXRLoader.parse: unsupported channel compression");
                    {
                        let Rn = 0
                          , Yn = 0;
                        for (let Bo = 0; Bo < ur.lines; ++Bo) {
                            let vo = Xn[En][Rn];
                            for (let Hn = 0; Hn < Qn.width; ++Hn) {
                                for (let $n = 0; $n < 2 * Qn.type; ++$n)
                                    jr[vo++] = fn[Yn + $n * Qn.width * Qn.height];
                                Yn++
                            }
                            Rn++
                        }
                    }
                }
            }
            return new DataView(jr.buffer)
        }
        function dr(ur, pr) {
            const Ir = new Uint8Array(ur);
            let jr = 0;
            for (; Ir[pr.value + jr] != 0; )
                jr += 1;
            const Qr = new TextDecoder().decode(Ir.slice(pr.value, pr.value + jr));
            return pr.value = pr.value + jr + 1,
            Qr
        }
        function cr(ur, pr) {
            const Ir = ur.getInt32(pr.value, !0);
            return pr.value = pr.value + 4,
            Ir
        }
        function Ar(ur, pr) {
            const Ir = ur.getUint32(pr.value, !0);
            return pr.value = pr.value + 4,
            Ir
        }
        function wr(ur, pr) {
            const Ir = ur[pr.value];
            return pr.value = pr.value + 1,
            Ir
        }
        function Rr(ur, pr) {
            const Ir = ur.getUint8(pr.value);
            return pr.value = pr.value + 1,
            Ir
        }
        const Cr = function(ur, pr) {
            let Ir;
            return Ir = "getBigInt64"in DataView.prototype ? Number(ur.getBigInt64(pr.value, !0)) : ur.getUint32(pr.value + 4, !0) + Number(ur.getUint32(pr.value, !0) << 32),
            pr.value += 8,
            Ir
        };
        function tr(ur, pr) {
            const Ir = ur.getFloat32(pr.value, !0);
            return pr.value += 4,
            Ir
        }
        function fr(ur, pr) {
            return three_module.GxU.toHalfFloat(tr(ur, pr))
        }
        function vr(ur) {
            const pr = (31744 & ur) >> 10
              , Ir = 1023 & ur;
            return (ur >> 15 ? -1 : 1) * (pr ? pr === 31 ? Ir ? NaN : 1 / 0 : Math.pow(2, pr - 15) * (1 + Ir / 1024) : Ir / 1024 * 6103515625e-14)
        }
        function Zr(ur, pr) {
            const Ir = ur.getUint16(pr.value, !0);
            return pr.value += 2,
            Ir
        }
        function rn(ur, pr) {
            return vr(Zr(ur, pr))
        }
        function hn(ur, pr, Ir, jr, Qr) {
            return jr === "string" || jr === "stringvector" || jr === "iccProfile" ? function(Or, qr, gn) {
                const Mn = new TextDecoder().decode(new Uint8Array(Or).slice(qr.value, qr.value + gn));
                return qr.value = qr.value + gn,
                Mn
            }(pr, Ir, Qr) : jr === "chlist" ? function(Or, qr, gn, Mn) {
                const Tn = gn.value
                  , wn = [];
                for (; gn.value < Tn + Mn - 1; ) {
                    const Cn = dr(qr, gn)
                      , fn = cr(Or, gn)
                      , bn = Rr(Or, gn);
                    gn.value += 3;
                    const Xn = cr(Or, gn)
                      , En = cr(Or, gn);
                    wn.push({
                        name: Cn,
                        pixelType: fn,
                        pLinear: bn,
                        xSampling: Xn,
                        ySampling: En
                    })
                }
                return gn.value += 1,
                wn
            }(ur, pr, Ir, Qr) : jr === "chromaticities" ? function(Or, qr) {
                return {
                    redX: tr(Or, qr),
                    redY: tr(Or, qr),
                    greenX: tr(Or, qr),
                    greenY: tr(Or, qr),
                    blueX: tr(Or, qr),
                    blueY: tr(Or, qr),
                    whiteX: tr(Or, qr),
                    whiteY: tr(Or, qr)
                }
            }(ur, Ir) : jr === "compression" ? function(Or, qr) {
                return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][Rr(Or, qr)]
            }(ur, Ir) : jr === "box2i" ? function(Or, qr) {
                return {
                    xMin: Ar(Or, qr),
                    yMin: Ar(Or, qr),
                    xMax: Ar(Or, qr),
                    yMax: Ar(Or, qr)
                }
            }(ur, Ir) : jr === "lineOrder" ? function(Or, qr) {
                return ["INCREASING_Y"][Rr(Or, qr)]
            }(ur, Ir) : jr === "float" ? tr(ur, Ir) : jr === "v2f" ? function(Or, qr) {
                return [tr(Or, qr), tr(Or, qr)]
            }(ur, Ir) : jr === "v3f" ? function(Or, qr) {
                return [tr(Or, qr), tr(Or, qr), tr(Or, qr)]
            }(ur, Ir) : jr === "int" ? cr(ur, Ir) : jr === "rational" ? function(Or, qr) {
                return [cr(Or, qr), Ar(Or, qr)]
            }(ur, Ir) : jr === "timecode" ? function(Or, qr) {
                return [Ar(Or, qr), Ar(Or, qr)]
            }(ur, Ir) : jr === "preview" ? (Ir.value += Qr,
            "skipped") : void (Ir.value += Qr)
        }
        const Nn = new DataView(o)
          , Wn = new Uint8Array(o)
          , qn = {
            value: 0
        }
          , mo = function(ur, pr, Ir) {
            const jr = {};
            if (ur.getUint32(0, !0) != 20000630)
                throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
            jr.version = ur.getUint8(4);
            const Qr = ur.getUint8(5);
            jr.spec = {
                singleTile: !!(2 & Qr),
                longName: !!(4 & Qr),
                deepFormat: !!(8 & Qr),
                multiPart: !!(16 & Qr)
            },
            Ir.value = 8;
            let Or = !0;
            for (; Or; ) {
                const qr = dr(pr, Ir);
                if (qr == 0)
                    Or = !1;
                else {
                    const gn = dr(pr, Ir)
                      , Mn = hn(ur, pr, Ir, gn, Ar(ur, Ir));
                    Mn === void 0 ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${gn}'.`) : jr[qr] = Mn
                }
            }
            if (-5 & Qr)
                throw console.error("THREE.EXRHeader:", jr),
                new Error("THREE.EXRLoader: Provided file is currently unsupported.");
            return jr
        }(Nn, o, qn)
          , Ur = function(ur, pr, Ir, jr, Qr) {
            const Or = {
                size: 0,
                viewer: pr,
                array: Ir,
                offset: jr,
                width: ur.dataWindow.xMax - ur.dataWindow.xMin + 1,
                height: ur.dataWindow.yMax - ur.dataWindow.yMin + 1,
                channels: ur.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: ur.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                colorSpace: three_module.Zr2
            };
            switch (ur.compression) {
            case "NO_COMPRESSION":
                Or.lines = 1,
                Or.uncompress = or;
                break;
            case "RLE_COMPRESSION":
                Or.lines = 1,
                Or.uncompress = ir;
                break;
            case "ZIPS_COMPRESSION":
                Or.lines = 1,
                Or.uncompress = lr;
                break;
            case "ZIP_COMPRESSION":
                Or.lines = 16,
                Or.uncompress = lr;
                break;
            case "PIZ_COMPRESSION":
                Or.lines = 32,
                Or.uncompress = ar;
                break;
            case "PXR24_COMPRESSION":
                Or.lines = 16,
                Or.uncompress = hr;
                break;
            case "DWAA_COMPRESSION":
                Or.lines = 32,
                Or.uncompress = gr;
                break;
            case "DWAB_COMPRESSION":
                Or.lines = 256,
                Or.uncompress = gr;
                break;
            default:
                throw new Error("EXRLoader.parse: " + ur.compression + " is unsupported")
            }
            if (Or.scanlineBlockSize = Or.lines,
            Or.type == 1)
                switch (Qr) {
                case three_module.RQf:
                    Or.getter = rn,
                    Or.inputSize = 2;
                    break;
                case three_module.ix0:
                    Or.getter = Zr,
                    Or.inputSize = 2
                }
            else {
                if (Or.type != 2)
                    throw new Error("EXRLoader.parse: unsupported pixelType " + Or.type + " for " + ur.compression + ".");
                switch (Qr) {
                case three_module.RQf:
                    Or.getter = tr,
                    Or.inputSize = 4;
                    break;
                case three_module.ix0:
                    Or.getter = fr,
                    Or.inputSize = 4
                }
            }
            Or.blockCount = (ur.dataWindow.yMax + 1) / Or.scanlineBlockSize;
            for (let gn = 0; gn < Or.blockCount; gn++)
                Cr(pr, jr);
            Or.outputChannels = Or.channels == 3 ? 4 : Or.channels;
            const qr = Or.width * Or.height * Or.outputChannels;
            switch (Qr) {
            case three_module.RQf:
                Or.byteArray = new Float32Array(qr),
                Or.channels < Or.outputChannels && Or.byteArray.fill(1, 0, qr);
                break;
            case three_module.ix0:
                Or.byteArray = new Uint16Array(qr),
                Or.channels < Or.outputChannels && Or.byteArray.fill(15360, 0, qr);
                break;
            default:
                console.error("THREE.EXRLoader: unsupported type: ", Qr)
            }
            return Or.bytesPerLine = Or.width * Or.inputSize * Or.channels,
            Or.outputChannels == 4 ? (Or.format = three_module.GWd,
            Or.colorSpace = three_module.Zr2) : (Or.format = three_module.VT0,
            Or.colorSpace = three_module.jf0),
            Or
        }(mo, Nn, Wn, qn, this.type)
          , nn = {
            value: 0
        }
          , xn = {
            R: 0,
            G: 1,
            B: 2,
            A: 3,
            Y: 0
        };
        for (let ur = 0; ur < Ur.height / Ur.scanlineBlockSize; ur++) {
            const pr = Ar(Nn, qn);
            Ur.size = Ar(Nn, qn),
            Ur.lines = pr + Ur.scanlineBlockSize > Ur.height ? Ur.height - pr : Ur.scanlineBlockSize;
            const Ir = Ur.size < Ur.lines * Ur.bytesPerLine ? Ur.uncompress(Ur) : or(Ur);
            qn.value += Ur.size;
            for (let jr = 0; jr < Ur.scanlineBlockSize; jr++) {
                const Qr = jr + ur * Ur.scanlineBlockSize;
                if (Qr >= Ur.height)
                    break;
                for (let Or = 0; Or < Ur.channels; Or++) {
                    const qr = xn[mo.channels[Or].name];
                    for (let gn = 0; gn < Ur.width; gn++) {
                        nn.value = (jr * (Ur.channels * Ur.width) + Or * Ur.width + gn) * Ur.inputSize;
                        const Mn = (Ur.height - 1 - Qr) * (Ur.width * Ur.outputChannels) + gn * Ur.outputChannels + qr;
                        Ur.byteArray[Mn] = Ur.getter(Ir, nn)
                    }
                }
            }
        }
        return {
            header: mo,
            width: Ur.width,
            height: Ur.height,
            data: Ur.byteArray,
            format: Ur.format,
            colorSpace: Ur.colorSpace,
            type: this.type
        }
    }
    setDataType(o) {
        return this.type = o,
        this
    }
    load(o, c, h, _) {
        return super.load(o, function(b, _e) {
            b.colorSpace = _e.colorSpace,
            b.minFilter = three_module.k6q,
            b.magFilter = three_module.k6q,
            b.generateMipmaps = !1,
            b.flipY = !1,
            c && c(b, _e)
        }, h, _)
    }
}
class EXRLoadPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin]
    }
    async onAdded(o) {
        var c, h;
        this._importer || (this._importer = new Importer(class extends EXRLoader {
            constructor(_) {
                super(_),
                this.setDataType(getTextureDataType(o.renderer.rendererObject))
            }
        }
        ,["exr"],!1)),
        (h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.Importers.push(this._importer)
    }
    async onDispose(o) {
        this._importer = void 0
    }
    async onRemove(o) {
        var c, h;
        this._importer && (!((h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0) && h.Importers) && o.getManager().importer.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer), 1),
        this._importer = void 0
    }
}
EXRLoadPlugin.PluginType = "EXRLoadPlugin";
const _3DMLoader_taskCache = new WeakMap;
class Rhino3dmLoader extends three_module.aHM {
    constructor(o) {
        super(o),
        this.libraryPath = "",
        this.libraryPending = null,
        this.libraryBinary = null,
        this.libraryConfig = {},
        this.url = "",
        this.workerLimit = 4,
        this.workerPool = [],
        this.workerNextTaskID = 1,
        this.workerSourceURL = "",
        this.workerConfig = {},
        this.materials = [],
        this.warnings = []
    }
    setLibraryPath(o) {
        return this.libraryPath = o,
        this
    }
    setWorkerLimit(o) {
        return this.workerLimit = o,
        this
    }
    load(o, c, h, _) {
        const b = new three_module.Y9S(this.manager);
        b.setPath(this.path),
        b.setResponseType("arraybuffer"),
        b.setRequestHeader(this.requestHeader),
        this.url = o,
        b.load(o, _e => {
            if (_3DMLoader_taskCache.has(_e))
                return _3DMLoader_taskCache.get(_e).promise.then(c).catch(_);
            this.decodeObjects(_e, o).then(nt => {
                nt.userData.warnings = this.warnings,
                this.warnings = [],
                c(nt)
            }
            ).catch(nt => _(nt))
        }
        , h, _)
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(o => o._taskLoad))
    }
    decodeObjects(o, c) {
        let h, _;
        const b = o.byteLength
          , _e = this._getWorker(b).then(nt => (h = nt,
        _ = this.workerNextTaskID++,
        new Promise( (it, at) => {
            h._callbacks[_] = {
                resolve: it,
                reject: at
            },
            h.postMessage({
                type: "decode",
                id: _,
                buffer: o
            }, [o])
        }
        ))).then(nt => this._createGeometry(nt.data)).catch(nt => {
            throw nt
        }
        );
        return _e.catch( () => !0).then( () => {
            h && _ && this._releaseTask(h, _)
        }
        ),
        _3DMLoader_taskCache.set(o, {
            url: c,
            promise: _e
        }),
        _e
    }
    parse(o, c, h) {
        this.decodeObjects(o, "").then(_ => {
            _.userData.warnings = this.warnings,
            c(_)
        }
        ).catch(_ => h(_))
    }
    _compareMaterials(o) {
        if (this.materials.includes(o))
            return o;
        const c = {};
        c.name = o.name,
        c.color = {},
        c.color.r = o.color.r,
        c.color.g = o.color.g,
        c.color.b = o.color.b,
        c.type = o.type,
        c.vertexColors = o.vertexColors;
        const h = JSON.stringify(c);
        for (let _ = 0; _ < this.materials.length; _++) {
            const b = this.materials[_]
              , _e = {};
            if (_e.name = b.name,
            _e.color = {},
            _e.color.r = b.color.r,
            _e.color.g = b.color.g,
            _e.color.b = b.color.b,
            _e.type = b.type,
            _e.vertexColors = b.vertexColors,
            JSON.stringify(_e) === h)
                return b
        }
        return this.materials.push(o),
        o
    }
    _createMaterial(o, c) {
        if (o === void 0)
            return new three_module._4j({
                color: new three_module.Q1f(1,1,1),
                metalness: .8,
                name: three_module.aHM.DEFAULT_MATERIAL_NAME,
                side: three_module.$EB
            });
        const h = new three_module.uSd({
            color: new three_module.Q1f(o.diffuseColor.r / 255,o.diffuseColor.g / 255,o.diffuseColor.b / 255),
            emissive: new three_module.Q1f(o.emissionColor.r,o.emissionColor.g,o.emissionColor.b),
            flatShading: o.disableLighting,
            ior: o.indexOfRefraction,
            name: o.name,
            reflectivity: o.reflectivity,
            opacity: 1 - o.transparency,
            side: three_module.$EB,
            specularColor: o.specularColor,
            transparent: o.transparency > 0
        });
        if (h.userData.id = o.id,
        o.pbrSupported) {
            const b = o.pbr;
            h.anisotropy = b.anisotropic,
            h.anisotropyRotation = b.anisotropicRotation,
            h.color = new three_module.Q1f(b.baseColor.r,b.baseColor.g,b.baseColor.b),
            h.clearcoat = b.clearcoat,
            h.clearcoatRoughness = b.clearcoatRoughness,
            h.metalness = b.metallic,
            h.transmission = 1 - b.opacity,
            h.roughness = b.roughness,
            h.sheen = b.sheen,
            h.specularIntensity = b.specular,
            h.thickness = b.subsurface
        }
        o.pbrSupported && o.pbr.opacity === 0 && o.transparency === 1 && (h.opacity = .2,
        h.transmission = 1);
        const _ = new three_module.Tap;
        for (let b = 0; b < o.textures.length; b++) {
            const _e = o.textures[b];
            if (_e.image !== null) {
                const nt = _.load(_e.image);
                switch (_e.type) {
                case "Bump":
                    h.bumpMap = nt;
                    break;
                case "Diffuse":
                case "PBR_BaseColor":
                    h.map = nt;
                    break;
                case "Emap":
                    h.envMap = nt;
                    break;
                case "Opacity":
                    h.transmissionMap = nt;
                    break;
                case "Transparency":
                case "PBR_Alpha":
                    h.alphaMap = nt,
                    h.transparent = !0;
                    break;
                case "PBR_AmbientOcclusion":
                    h.aoMap = nt;
                    break;
                case "PBR_Anisotropic":
                    h.anisotropyMap = nt;
                    break;
                case "PBR_Clearcoat":
                    h.clearcoatMap = nt;
                    break;
                case "PBR_ClearcoatBump":
                    h.clearcoatNormalMap = nt;
                    break;
                case "PBR_ClearcoatRoughness":
                    h.clearcoatRoughnessMap = nt;
                    break;
                case "PBR_Displacement":
                    h.displacementMap = nt;
                    break;
                case "PBR_Emission":
                    h.emissiveMap = nt;
                    break;
                case "PBR_Metallic":
                    h.metalnessMap = nt;
                    break;
                case "PBR_Roughness":
                    h.roughnessMap = nt;
                    break;
                case "PBR_Sheen":
                    h.sheenColorMap = nt;
                    break;
                case "PBR_Specular":
                    h.specularColorMap = nt;
                    break;
                case "PBR_Subsurface":
                    h.thicknessMap = nt;
                    break;
                default:
                    this.warnings.push({
                        message: `THREE.3DMLoader: No conversion exists for 3dm ${_e.type}.`,
                        type: "no conversion"
                    })
                }
                nt.wrapS = _e.wrapU === 0 ? three_module.GJx : three_module.ghU,
                nt.wrapT = _e.wrapV === 0 ? three_module.GJx : three_module.ghU,
                _e.repeat && nt.repeat.set(_e.repeat[0], _e.repeat[1])
            }
        }
        return c && new EXRLoader().load(c.image, function(b) {
            b.mapping = THREE.EquirectangularReflectionMapping,
            h.envMap = b
        }),
        h
    }
    _createGeometry(o) {
        const c = new three_module.B69
          , h = []
          , _ = []
          , b = [];
        c.userData.layers = o.layers,
        c.userData.groups = o.groups,
        c.userData.settings = o.settings,
        c.userData.settings.renderSettings = o.renderSettings,
        c.userData.strings = o.strings,
        c.userData.objectType = "File3dm",
        c.userData.materials = null,
        c.name = this.url;
        let _e = o.objects;
        const nt = o.materials;
        for (let it = 0; it < _e.length; it++) {
            const at = _e[it]
              , ut = at.attributes;
            switch (at.objectType) {
            case "InstanceDefinition":
                _.push(at);
                break;
            case "InstanceReference":
                b.push(at);
                break;
            default:
                let pt, ht = null;
                switch (ut.materialSource.name) {
                case "ObjectMaterialSource_MaterialFromLayer":
                    ut.layerIndex >= 0 && (ht = o.layers[ut.layerIndex].renderMaterialIndex);
                    break;
                case "ObjectMaterialSource_MaterialFromObject":
                    ht = ut.materialIndex >= 0 ? ut.materialIndex : null
                }
                if (ht >= 0) {
                    const bt = nt[ht];
                    pt = this._createMaterial(bt, o.renderEnvironment)
                } else
                    pt = this._createMaterial();
                pt = this._compareMaterials(pt);
                const _t = this._createObject(at, pt);
                if (_t === void 0)
                    continue;
                const vt = o.layers[ut.layerIndex];
                _t.visible = !vt || vt.visible,
                ut.isInstanceDefinitionObject ? h.push(_t) : c.add(_t)
            }
        }
        for (let it = 0; it < _.length; it++) {
            const at = _[it];
            _e = [];
            for (let ut = 0; ut < at.attributes.objectIds.length; ut++) {
                const pt = at.attributes.objectIds[ut];
                for (let ht = 0; ht < h.length; ht++)
                    pt === h[ht].userData.attributes.id && _e.push(h[ht])
            }
            for (let ut = 0; ut < b.length; ut++) {
                const pt = b[ut];
                if (pt.geometry.parentIdefId === at.attributes.id) {
                    const ht = pt.geometry.xform.array
                      , _t = new three_module.kn4;
                    if (_t.set(...ht),
                    _e.length === 1) {
                        const vt = _e[0].clone(!0);
                        if (vt.name = pt.attributes.name || vt.name,
                        vt.applyMatrix4(_t),
                        pt.attributes.materialIndex >= 0 && pt.attributes.materialIndex !== _e[0].userData.attributes.materialIndex) {
                            const bt = nt[pt.attributes.materialIndex]
                              , St = this._createMaterial(bt);
                            vt.material = this._compareMaterials(St)
                        }
                        if (vt.userData.defAttributes = vt.userData.attributes,
                        vt.userData.defObjectType = vt.userData.objectType,
                        vt.userData.attributes = {
                            ...vt.userData.attributes,
                            ...pt.attributes
                        },
                        vt.userData.objectType = pt.objectType,
                        pt.attributes.layerIndex !== void 0) {
                            const bt = o.layers[pt.attributes.layerIndex];
                            vt.visible = bt ? bt.visible : vt.visible
                        }
                        c.add(vt)
                    } else {
                        console.warn("THREE.Rhino3dmLoader: InstanceReference with multiple/no objects, not all properties will be copied.");
                        const vt = new three_module.B69;
                        vt.applyMatrix4(_t);
                        for (let bt = 0; bt < _e.length; bt++)
                            vt.add(_e[bt].clone(!0));
                        c.add(vt)
                    }
                }
            }
        }
        return c.userData.materials = this.materials,
        c.name = "",
        c
    }
    _createObject(o, c) {
        const h = new three_module.SUR
          , _ = o.attributes;
        let b, _e, nt, it;
        switch (o.objectType) {
        case "Point":
        case "PointSet":
            b = h.parse(o.geometry),
            b.attributes.hasOwnProperty("color") ? _e = new three_module.BH$({
                vertexColors: !0,
                sizeAttenuation: !1,
                size: 2
            }) : (nt = _.drawColor,
            it = new three_module.Q1f(nt.r / 255,nt.g / 255,nt.b / 255),
            _e = new three_module.BH$({
                color: it,
                sizeAttenuation: !1,
                size: 2
            })),
            _e = this._compareMaterials(_e);
            const at = new three_module.ONl(b,_e);
            return at.userData.attributes = _,
            at.userData.objectType = o.objectType,
            _.name && (at.name = _.name),
            at;
        case "Mesh":
        case "Extrusion":
        case "SubD":
        case "Brep":
            if (o.geometry === null)
                return;
            b = h.parse(o.geometry),
            c === null && (c = this._createMaterial(),
            c = this._compareMaterials(c)),
            b.attributes.hasOwnProperty("color") && (c.vertexColors = !0);
            const ut = new three_module.eaF(b,c);
            return ut.castShadow = _.castsShadows,
            ut.receiveShadow = _.receivesShadows,
            ut.userData.attributes = _,
            ut.userData.objectType = o.objectType,
            _.name && (ut.name = _.name,
            b.name = _.name),
            ut;
        case "Curve":
            b = h.parse(o.geometry),
            nt = _.drawColor,
            it = new three_module.Q1f(nt.r / 255,nt.g / 255,nt.b / 255),
            _e = new three_module.mrM({
                color: it
            }),
            _e = this._compareMaterials(_e);
            const pt = new three_module.N1A(b,_e);
            return pt.userData.attributes = _,
            pt.userData.objectType = o.objectType,
            _.name && (pt.name = _.name),
            pt;
        case "TextDot":
            b = o.geometry;
            const ht = document.createElement("canvas").getContext("2d")
              , _t = `${b.fontHeight}px ${b.fontFace}`;
            ht.font = _t;
            const vt = ht.measureText(b.text).width + 10
              , bt = b.fontHeight + 10
              , St = window.devicePixelRatio;
            ht.canvas.width = vt * St,
            ht.canvas.height = bt * St,
            ht.canvas.style.width = vt + "px",
            ht.canvas.style.height = bt + "px",
            ht.setTransform(St, 0, 0, St, 0, 0),
            ht.font = _t,
            ht.textBaseline = "middle",
            ht.textAlign = "center",
            it = _.drawColor,
            ht.fillStyle = `rgba(${it.r},${it.g},${it.b},${it.a})`,
            ht.fillRect(0, 0, vt, bt),
            ht.fillStyle = "white",
            ht.fillText(b.text, vt / 2, bt / 2);
            const At = new three_module.GOR(ht.canvas);
            At.minFilter = three_module.k6q,
            At.generateMipmaps = !1,
            At.wrapS = three_module.ghU,
            At.wrapT = three_module.ghU,
            _e = new three_module.RoJ({
                map: At,
                depthTest: !1
            });
            const Et = new three_module.kxk(_e);
            return Et.position.set(b.point[0], b.point[1], b.point[2]),
            Et.scale.set(vt / 10, bt / 10, 1),
            Et.userData.attributes = _,
            Et.userData.objectType = o.objectType,
            _.name && (Et.name = _.name),
            Et;
        case "Light":
            let Pt;
            switch (b = o.geometry,
            b.lightStyle.name) {
            case "LightStyle_WorldPoint":
                Pt = new three_module.HiM,
                Pt.castShadow = _.castsShadows,
                Pt.position.set(b.location[0], b.location[1], b.location[2]),
                Pt.shadow.normalBias = .1;
                break;
            case "LightStyle_WorldSpot":
                Pt = new three_module.nCl,
                Pt.castShadow = _.castsShadows,
                Pt.position.set(b.location[0], b.location[1], b.location[2]),
                Pt.target.position.set(b.direction[0], b.direction[1], b.direction[2]),
                Pt.angle = b.spotAngleRadians,
                Pt.shadow.normalBias = .1;
                break;
            case "LightStyle_WorldRectangular":
                Pt = new three_module.ure;
                const It = Math.abs(b.width[2])
                  , Dt = Math.abs(b.length[0]);
                Pt.position.set(b.location[0] - Dt / 2, b.location[1], b.location[2] - It / 2),
                Pt.height = Dt,
                Pt.width = It,
                Pt.lookAt(b.direction[0], b.direction[1], b.direction[2]);
                break;
            case "LightStyle_WorldDirectional":
                Pt = new three_module.ZyN,
                Pt.castShadow = _.castsShadows,
                Pt.position.set(b.location[0], b.location[1], b.location[2]),
                Pt.target.position.set(b.direction[0], b.direction[1], b.direction[2]),
                Pt.shadow.normalBias = .1
            }
            return Pt && (Pt.intensity = b.intensity,
            nt = b.diffuse,
            it = new three_module.Q1f(nt.r / 255,nt.g / 255,nt.b / 255),
            Pt.color = it,
            Pt.userData.attributes = _,
            Pt.userData.objectType = o.objectType),
            Pt
        }
    }
    _initLibrary() {
        if (!this.libraryPending) {
            const o = new three_module.Y9S(this.manager);
            o.setPath(this.libraryPath);
            const c = new Promise( (b, _e) => {
                o.load("rhino3dm.js", b, void 0, _e)
            }
            )
              , h = new three_module.Y9S(this.manager);
            h.setPath(this.libraryPath),
            h.setResponseType("arraybuffer");
            const _ = new Promise( (b, _e) => {
                h.load("rhino3dm.wasm", b, void 0, _e)
            }
            );
            this.libraryPending = Promise.all([c, _]).then( ([b,_e]) => {
                this.libraryConfig.wasmBinary = _e;
                const nt = DRACOWorkerStr
                  , it = ["/* rhino3dm.js */", b, "/* worker */", nt.substring(nt.indexOf("{") + 1, nt.lastIndexOf("}"))].join(`
`);
                this.workerSourceURL = URL.createObjectURL(new Blob([it]))
            }
            )
        }
        return this.libraryPending
    }
    _getWorker(o) {
        return this._initLibrary().then( () => {
            if (this.workerPool.length < this.workerLimit) {
                const h = new Worker(this.workerSourceURL);
                h._callbacks = {},
                h._taskCosts = {},
                h._taskLoad = 0,
                h.postMessage({
                    type: "init",
                    libraryConfig: this.libraryConfig
                }),
                h.onmessage = _ => {
                    const b = _.data;
                    switch (b.type) {
                    case "warning":
                        this.warnings.push(b.data),
                        console.warn(b.data);
                        break;
                    case "decode":
                        h._callbacks[b.id].resolve(b);
                        break;
                    case "error":
                        h._callbacks[b.id].reject(b);
                        break;
                    default:
                        console.error('THREE.Rhino3dmLoader: Unexpected message, "' + b.type + '"')
                    }
                }
                ,
                this.workerPool.push(h)
            } else
                this.workerPool.sort(function(h, _) {
                    return h._taskLoad > _._taskLoad ? -1 : 1
                });
            const c = this.workerPool[this.workerPool.length - 1];
            return c._taskLoad += o,
            c
        }
        )
    }
    _releaseTask(o, c) {
        o._taskLoad -= o._taskCosts[c],
        delete o._callbacks[c],
        delete o._taskCosts[c]
    }
    dispose() {
        for (let o = 0; o < this.workerPool.length; ++o)
            this.workerPool[o].terminate();
        return this.workerPool.length = 0,
        this
    }
}
const DRACOWorkerStr = `
function Rhino3dmWorker() {

	let libraryPending;
	let libraryConfig;
	let rhino;
	let taskID;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':

				libraryConfig = message.libraryConfig;
				const wasmBinary = libraryConfig.wasmBinary;
				let RhinoModule;
				libraryPending = new Promise( function ( resolve ) {

					/* Like Basis Loader */
					RhinoModule = { wasmBinary, onRuntimeInitialized: resolve };

					rhino3dm( RhinoModule ); // eslint-disable-line no-undef

				 } ).then( () => {

					rhino = RhinoModule;

				 } );

				break;

			case 'decode':

				taskID = message.id;
				const buffer = message.buffer;
				libraryPending.then( () => {

					try {

						const data = decodeObjects( rhino, buffer );
						self.postMessage( { type: 'decode', id: message.id, data } );

					} catch ( error ) {

						self.postMessage( { type: 'error', id: message.id, error } );

					}

				} );

				break;

		}

	};

	function decodeObjects( rhino, buffer ) {

		const arr = new Uint8Array( buffer );
		const doc = rhino.File3dm.fromByteArray( arr );

		const objects = [];
		const materials = [];
		const layers = [];
		const views = [];
		const namedViews = [];
		const groups = [];
		const strings = [];

		//Handle objects

		const objs = doc.objects();
		const cnt = objs.count;

		for ( let i = 0; i < cnt; i ++ ) {

			const _object = objs.get( i );

			const object = extractObjectData( _object, doc );

			_object.delete();

			if ( object ) {

				objects.push( object );

			}

		}

		// Handle instance definitions
		// console.log( \`Instance Definitions Count: \${doc.instanceDefinitions().count()}\` );

		for ( let i = 0; i < doc.instanceDefinitions().count; i ++ ) {

			const idef = doc.instanceDefinitions().get( i );
			const idefAttributes = extractProperties( idef );
			idefAttributes.objectIds = idef.getObjectIds();

			objects.push( { geometry: null, attributes: idefAttributes, objectType: 'InstanceDefinition' } );

		}

		// Handle materials

		const textureTypes = [
			// rhino.TextureType.Bitmap,
			rhino.TextureType.Diffuse,
			rhino.TextureType.Bump,
			rhino.TextureType.Transparency,
			rhino.TextureType.Opacity,
			rhino.TextureType.Emap
		];

		const pbrTextureTypes = [
			rhino.TextureType.PBR_BaseColor,
			rhino.TextureType.PBR_Subsurface,
			rhino.TextureType.PBR_SubsurfaceScattering,
			rhino.TextureType.PBR_SubsurfaceScatteringRadius,
			rhino.TextureType.PBR_Metallic,
			rhino.TextureType.PBR_Specular,
			rhino.TextureType.PBR_SpecularTint,
			rhino.TextureType.PBR_Roughness,
			rhino.TextureType.PBR_Anisotropic,
			rhino.TextureType.PBR_Anisotropic_Rotation,
			rhino.TextureType.PBR_Sheen,
			rhino.TextureType.PBR_SheenTint,
			rhino.TextureType.PBR_Clearcoat,
			rhino.TextureType.PBR_ClearcoatBump,
			rhino.TextureType.PBR_ClearcoatRoughness,
			rhino.TextureType.PBR_OpacityIor,
			rhino.TextureType.PBR_OpacityRoughness,
			rhino.TextureType.PBR_Emission,
			rhino.TextureType.PBR_AmbientOcclusion,
			rhino.TextureType.PBR_Displacement
		];

		for ( let i = 0; i < doc.materials().count; i ++ ) {

			const _material = doc.materials().get( i );

			let material = extractProperties( _material );

			const textures = [];

			textures.push( ...extractTextures( _material, textureTypes, doc ) );

			material.pbrSupported = _material.physicallyBased().supported;

			if ( material.pbrSupported ) {

				textures.push( ...extractTextures( _material, pbrTextureTypes, doc ) );
				material.pbr = extractProperties( _material.physicallyBased() );

			}

			material.textures = textures;

			materials.push( material );

			_material.delete();

		}

		// Handle layers

		for ( let i = 0; i < doc.layers().count; i ++ ) {

			const _layer = doc.layers().get( i );
			const layer = extractProperties( _layer );

			layers.push( layer );

			_layer.delete();

		}

		// Handle views

		for ( let i = 0; i < doc.views().count; i ++ ) {

			const _view = doc.views().get( i );
			const view = extractProperties( _view );

			views.push( view );

			_view.delete();

		}

		// Handle named views

		for ( let i = 0; i < doc.namedViews().count; i ++ ) {

			const _namedView = doc.namedViews().get( i );
			const namedView = extractProperties( _namedView );

			namedViews.push( namedView );

			_namedView.delete();

		}

		// Handle groups

		for ( let i = 0; i < doc.groups().count; i ++ ) {

			const _group = doc.groups().get( i );
			const group = extractProperties( _group );

			groups.push( group );

			_group.delete();

		}

		// Handle settings

		const settings = extractProperties( doc.settings() );

		//TODO: Handle other document stuff like dimstyles, instance definitions, bitmaps etc.

		// Handle dimstyles
		// console.log( \`Dimstyle Count: \${doc.dimstyles().count()}\` );

		// Handle bitmaps
		// console.log( \`Bitmap Count: \${doc.bitmaps().count()}\` );

		// Handle strings
		// console.log( \`Document Strings Count: \${doc.strings().count()}\` );
		// Note: doc.strings().documentUserTextCount() counts any doc.strings defined in a section
		// console.log( \`Document User Text Count: \${doc.strings().documentUserTextCount()}\` );

		const strings_count = doc.strings().count;

		for ( let i = 0; i < strings_count; i ++ ) {

			strings.push( doc.strings().get( i ) );

		}

		// Handle Render Environments for Material Environment

		// get the id of the active render environment skylight, which we'll use for environment texture
		const reflectionId = doc.settings().renderSettings().renderEnvironments.reflectionId;

		const rc = doc.renderContent();

		let renderEnvironment = null;

		for( let i = 0; i < rc.count; i++ ) {

			const content = rc.get(i);

			switch( content.kind ) {

				case 'environment':

					const id = content.id;

					// there could be multiple render environments in a 3dm file
					if ( id !== reflectionId ) break;

					const renderTexture = content.findChild( 'texture' );
					const fileName = renderTexture.fileName;

					for ( let j = 0; j < doc.embeddedFiles().count; j ++ ) {

						const _fileName = doc.embeddedFiles().get( j ).fileName;

						if ( fileName === _fileName ) {

							const background = doc.getEmbeddedFileAsBase64( fileName );
							const backgroundImage = 'data:image/png;base64,' + background;
							renderEnvironment = { type: 'renderEnvironment', image: backgroundImage, name: fileName };

						}

					}

					break;

			}

		}

		// Handle Render Settings

		const renderSettings = {
			ambientLight: doc.settings().renderSettings().ambientLight,
			backgroundColorTop: doc.settings().renderSettings().backgroundColorTop,
			backgroundColorBottom: doc.settings().renderSettings().backgroundColorBottom,
			useHiddenLights: doc.settings().renderSettings().useHiddenLights,
			depthCue: doc.settings().renderSettings().depthCue,
			flatShade: doc.settings().renderSettings().flatShade,
			renderBackFaces: doc.settings().renderSettings().renderBackFaces,
			renderPoints: doc.settings().renderSettings().renderPoints,
			renderCurves: doc.settings().renderSettings().renderCurves,
			renderIsoParams: doc.settings().renderSettings().renderIsoParams,
			renderMeshEdges: doc.settings().renderSettings().renderMeshEdges,
			renderAnnotations: doc.settings().renderSettings().renderAnnotations,
			useViewportSize: doc.settings().renderSettings().useViewportSize,
			scaleBackgroundToFit: doc.settings().renderSettings().scaleBackgroundToFit,
			transparentBackground: doc.settings().renderSettings().transparentBackground,
			imageDpi: doc.settings().renderSettings().imageDpi,
			shadowMapLevel: doc.settings().renderSettings().shadowMapLevel,
			namedView: doc.settings().renderSettings().namedView,
			snapShot: doc.settings().renderSettings().snapShot,
			specificViewport: doc.settings().renderSettings().specificViewport,
			groundPlane: extractProperties( doc.settings().renderSettings().groundPlane ),
			safeFrame: extractProperties( doc.settings().renderSettings().safeFrame ),
			dithering: extractProperties( doc.settings().renderSettings().dithering ),
			skylight: extractProperties( doc.settings().renderSettings().skylight ),
			linearWorkflow: extractProperties( doc.settings().renderSettings().linearWorkflow ),
			renderChannels: extractProperties( doc.settings().renderSettings().renderChannels ),
			sun: extractProperties( doc.settings().renderSettings().sun ),
			renderEnvironments: extractProperties( doc.settings().renderSettings().renderEnvironments ),
			postEffects: extractProperties( doc.settings().renderSettings().postEffects ),

		};

		doc.delete();

		return { objects, materials, layers, views, namedViews, groups, strings, settings, renderSettings, renderEnvironment };

	}

	function extractTextures( m, tTypes, d ) {

		const textures = [];

		for ( let i = 0; i < tTypes.length; i ++ ) {

			const _texture = m.getTexture( tTypes[ i ] );
			if ( _texture ) {

				let textureType = tTypes[ i ].constructor.name;
				textureType = textureType.substring( 12, textureType.length );
				const texture = extractTextureData( _texture, textureType, d );
				textures.push( texture );
				_texture.delete();

			}

		}

		return textures;

	}

	function extractTextureData( t, tType, d ) {

		const texture = { type: tType };

		const image = d.getEmbeddedFileAsBase64( t.fileName );

		texture.wrapU = t.wrapU;
		texture.wrapV = t.wrapV;
		texture.wrapW = t.wrapW;
		const uvw = t.uvwTransform.toFloatArray( true );

		texture.repeat = [ uvw[ 0 ], uvw[ 5 ] ];

		if ( image ) {

			texture.image = 'data:image/png;base64,' + image;

		} else {

			self.postMessage( { type: 'warning', id: taskID, data: {
				message: \`THREE.3DMLoader: Image for \${tType} texture not embedded in file.\`,
				type: 'missing resource'
			}

			} );

			texture.image = null;

		}

		return texture;

	}

	function extractObjectData( object, doc ) {

		const _geometry = object.geometry();
		const _attributes = object.attributes();
		let objectType = _geometry.objectType;
		let geometry, attributes, position, data, mesh;

		// skip instance definition objects
		//if( _attributes.isInstanceDefinitionObject ) { continue; }

		// TODO: handle other geometry types
		switch ( objectType ) {

			case rhino.ObjectType.Curve:

				const pts = curveToPoints( _geometry, 100 );

				position = {};
				attributes = {};
				data = {};

				position.itemSize = 3;
				position.type = 'Float32Array';
				position.array = [];

				for ( let j = 0; j < pts.length; j ++ ) {

					position.array.push( pts[ j ][ 0 ] );
					position.array.push( pts[ j ][ 1 ] );
					position.array.push( pts[ j ][ 2 ] );

				}

				attributes.position = position;
				data.attributes = attributes;

				geometry = { data };

				break;

			case rhino.ObjectType.Point:

				const pt = _geometry.location;

				position = {};
				const color = {};
				attributes = {};
				data = {};

				position.itemSize = 3;
				position.type = 'Float32Array';
				position.array = [ pt[ 0 ], pt[ 1 ], pt[ 2 ] ];

				const _color = _attributes.drawColor( doc );

				color.itemSize = 3;
				color.type = 'Float32Array';
				color.array = [ _color.r / 255.0, _color.g / 255.0, _color.b / 255.0 ];

				attributes.position = position;
				attributes.color = color;
				data.attributes = attributes;

				geometry = { data };

				break;

			case rhino.ObjectType.PointSet:
			case rhino.ObjectType.Mesh:

				geometry = _geometry.toThreejsJSON();

				break;

			case rhino.ObjectType.Brep:

				const faces = _geometry.faces();
				mesh = new rhino.Mesh();

				for ( let faceIndex = 0; faceIndex < faces.count; faceIndex ++ ) {

					const face = faces.get( faceIndex );
					const _mesh = face.getMesh( rhino.MeshType.Any );

					if ( _mesh ) {

						mesh.append( _mesh );
						_mesh.delete();

					}

					face.delete();

				}

				if ( mesh.faces().count > 0 ) {

					mesh.compact();
					geometry = mesh.toThreejsJSON();
					faces.delete();

				}

				mesh.delete();

				break;

			case rhino.ObjectType.Extrusion:

				mesh = _geometry.getMesh( rhino.MeshType.Any );

				if ( mesh ) {

					geometry = mesh.toThreejsJSON();
					mesh.delete();

				}

				break;

			case rhino.ObjectType.TextDot:

				geometry = extractProperties( _geometry );

				break;

			case rhino.ObjectType.Light:

				geometry = extractProperties( _geometry );

				if ( geometry.lightStyle.name === 'LightStyle_WorldLinear' ) {

					self.postMessage( { type: 'warning', id: taskID, data: {
						message: \`THREE.3DMLoader: No conversion exists for \${objectType.constructor.name} \${geometry.lightStyle.name}\`,
						type: 'no conversion',
						guid: _attributes.id
					}

					} );

				}

				break;

			case rhino.ObjectType.InstanceReference:

				geometry = extractProperties( _geometry );
				geometry.xform = extractProperties( _geometry.xform );
				geometry.xform.array = _geometry.xform.toFloatArray( true );

				break;

			case rhino.ObjectType.SubD:

				// TODO: precalculate resulting vertices and faces and warn on excessive results
				_geometry.subdivide( 3 );
				mesh = rhino.Mesh.createFromSubDControlNet( _geometry, false );
				if ( mesh ) {

					geometry = mesh.toThreejsJSON();
					mesh.delete();

				}

				break;

				/*
				case rhino.ObjectType.Annotation:
				case rhino.ObjectType.Hatch:
				case rhino.ObjectType.ClipPlane:
				*/

			default:

				self.postMessage( { type: 'warning', id: taskID, data: {
					message: \`THREE.3DMLoader: Conversion not implemented for \${objectType.constructor.name}\`,
					type: 'not implemented',
					guid: _attributes.id
				}

				} );

				break;

		}

		if ( geometry ) {

			attributes = extractProperties( _attributes );
			attributes.geometry = extractProperties( _geometry );

			if ( _attributes.groupCount > 0 ) {

				attributes.groupIds = _attributes.getGroupList();

			}

			if ( _attributes.userStringCount > 0 ) {

				attributes.userStrings = _attributes.getUserStrings();

			}

			if ( _geometry.userStringCount > 0 ) {

				attributes.geometry.userStrings = _geometry.getUserStrings();

			}

			if ( _attributes.decals().count > 0 ) {

				self.postMessage( { type: 'warning', id: taskID, data: {
					message: \`THREE.3DMLoader: No conversion exists for the decals associated with this object.\`,
					type: 'no conversion',
					guid: _attributes.id
				}

				} );

			}

			attributes.drawColor = _attributes.drawColor( doc );

			objectType = objectType.constructor.name;
			objectType = objectType.substring( 11, objectType.length );

			return { geometry, attributes, objectType };

		} else {

			self.postMessage( { type: 'warning', id: taskID, data: {
				message: \`THREE.3DMLoader: \${objectType.constructor.name} has no associated mesh geometry.\`,
				type: 'missing mesh',
				guid: _attributes.id
			}

			} );

		}

	}

	function extractProperties( object ) {

		const result = {};

		for ( const property in object ) {

			const value = object[ property ];

			if ( typeof value !== 'function' ) {

				if ( typeof value === 'object' && value !== null && value.hasOwnProperty( 'constructor' ) ) {

					result[ property ] = { name: value.constructor.name, value: value.value };

				} else if ( typeof value === 'object' && value !== null ) {

					result[ property ] = extractProperties( value );

				} else {

					result[ property ] = value;

				}

			} else {

				// these are functions that could be called to extract more data.
				//console.log( \`\${property}: \${object[ property ].constructor.name}\` );

			}

		}

		return result;

	}

	function curveToPoints( curve, pointLimit ) {

		let pointCount = pointLimit;
		let rc = [];
		const ts = [];

		if ( curve instanceof rhino.LineCurve ) {

			return [ curve.pointAtStart, curve.pointAtEnd ];

		}

		if ( curve instanceof rhino.PolylineCurve ) {

			pointCount = curve.pointCount;
			for ( let i = 0; i < pointCount; i ++ ) {

				rc.push( curve.point( i ) );

			}

			return rc;

		}

		if ( curve instanceof rhino.PolyCurve ) {

			const segmentCount = curve.segmentCount;

			for ( let i = 0; i < segmentCount; i ++ ) {

				const segment = curve.segmentCurve( i );
				const segmentArray = curveToPoints( segment, pointCount );
				rc = rc.concat( segmentArray );
				segment.delete();

			}

			return rc;

		}

		if ( curve instanceof rhino.ArcCurve ) {

			pointCount = Math.floor( curve.angleDegrees / 5 );
			pointCount = pointCount < 2 ? 2 : pointCount;
			// alternative to this hardcoded version: https://stackoverflow.com/a/18499923/2179399

		}

		if ( curve instanceof rhino.NurbsCurve && curve.degree === 1 ) {

			const pLine = curve.tryGetPolyline();

			for ( let i = 0; i < pLine.count; i ++ ) {

				rc.push( pLine.get( i ) );

			}

			pLine.delete();

			return rc;

		}

		const domain = curve.domain;
		const divisions = pointCount - 1.0;

		for ( let j = 0; j < pointCount; j ++ ) {

			const t = domain[ 0 ] + ( j / divisions ) * ( domain[ 1 ] - domain[ 0 ] );

			if ( t === domain[ 0 ] || t === domain[ 1 ] ) {

				ts.push( t );
				continue;

			}

			const tan = curve.tangentAt( t );
			const prevTan = curve.tangentAt( ts.slice( - 1 )[ 0 ] );

			// Duplicated from THREE.Vector3
			// How to pass imports to worker?

			const tS = tan[ 0 ] * tan[ 0 ] + tan[ 1 ] * tan[ 1 ] + tan[ 2 ] * tan[ 2 ];
			const ptS = prevTan[ 0 ] * prevTan[ 0 ] + prevTan[ 1 ] * prevTan[ 1 ] + prevTan[ 2 ] * prevTan[ 2 ];

			const denominator = Math.sqrt( tS * ptS );

			let angle;

			if ( denominator === 0 ) {

				angle = Math.PI / 2;

			} else {

				const theta = ( tan.x * prevTan.x + tan.y * prevTan.y + tan.z * prevTan.z ) / denominator;
				angle = Math.acos( Math.max( - 1, Math.min( 1, theta ) ) );

			}

			if ( angle < 0.1 ) continue;

			ts.push( t );

		}

		rc = ts.map( t => curve.pointAt( t ) );
		return rc;

	}

}
`;
var rhino3dm_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class Rhino3dmLoader2 extends Rhino3dmLoader {
    constructor(o) {
        super(o),
        this.materials = [],
        this.setLibraryPath(Rhino3dmLoader2.LIBRARY_PATH)
    }
    _createMaterial(o) {
        return Rhino3dmLoader2.ImportMaterials ? super._createMaterial(o) : this.materials[0] || new three_module._4j({
            color: new three_module.Q1f(1,1,1),
            metalness: .8,
            name: three_module.aHM.DEFAULT_MATERIAL_NAME,
            side: three_module.$EB
        })
    }
    async loadAsync(o, c) {
        const h = await super.loadAsync(o, c);
        h.rotateX(-Math.PI / 2),
        h.userData.materials && delete h.userData.materials;
        const _ = h.userData.layers;
        return h.traverse(b => {
            var _e, nt, it, at, ut;
            const pt = (_e = b.userData.attributes) === null || _e === void 0 ? void 0 : _e.castsShadows
              , ht = (nt = b.userData.attributes) === null || nt === void 0 ? void 0 : nt.receivesShadows;
            b.castShadow = pt,
            b.receiveShadow = ht;
            const _t = (at = (it = b.userData.attributes) === null || it === void 0 ? void 0 : it.layerIndex) !== null && at !== void 0 ? at : (ut = b.userData.defAttributes) === null || ut === void 0 ? void 0 : ut.layerIndex
              , vt = _[_t];
            vt && (b.userData.rhinoLayer = vt),
            b.userData.rhino3dmRoot = h.uuid,
            Rhino3dmLoader2.LoadUserDataStrings || (b.userData.strings = []),
            Rhino3dmLoader2.LoadUserDataWarnings || delete b.userData.warnings,
            this._hideLineMesh(b),
            this._useInstancedMesh(b),
            this._useMaterialSource(b, vt)
        }
        ),
        this.materials = [],
        h
    }
    _useMaterialSource(o, c) {
        var h, _, b, _e, nt;
        if (!Rhino3dmLoader2.ImportMaterials)
            return;
        const it = o;
        if (((h = it.material) === null || h === void 0 ? void 0 : h.name) === "default" || Rhino3dmLoader2.ForceLayerMaterials) {
            const at = ((_ = it.userData.attributes) === null || _ === void 0 ? void 0 : _.materialSource) || ((b = it.userData.defAttributes) === null || b === void 0 ? void 0 : b.materialSource)
              , ut = ((_e = it.userData.attributes) === null || _e === void 0 ? void 0 : _e.colorSource) || ((nt = it.userData.defAttributes) === null || nt === void 0 ? void 0 : nt.colorSource);
            if (!Rhino3dmLoader2.ForceLayerMaterials && !at && !ut)
                return;
            Rhino3dmLoader2.ForceLayerMaterials || (at == null ? void 0 : at.value) === 0 || (at == null ? void 0 : at.value) === 1 && (ut == null ? void 0 : ut.value) === 0 ? c && (it.material = this._compareMaterials(this._createMaterial({
                diffuseColor: c.color,
                name: c.name,
                emissionColor: {
                    r: 0,
                    g: 0,
                    b: 0
                },
                disableLighting: !1,
                indexOfRefraction: 1.5,
                reflectivity: 1,
                transparency: 0,
                specularColor: {
                    r: 0,
                    g: 0,
                    b: 0
                },
                textures: []
            }))) : (at == null ? void 0 : at.value) === 3 || (at == null ? void 0 : at.value) === 1 && (ut == null ? void 0 : ut.value) === 3 ? it.traverseAncestors(pt => {
                pt != null && pt.material && (it.material = pt.material)
            }
            ) : at && at.value !== 1 && console.warn("Unknown material source", at, it, it.userData.attributes)
        }
    }
    _useInstancedMesh(o) {
        if (!Rhino3dmLoader2.ReplaceWithInstancedMesh || o.children.length <= 0)
            return;
        const c = o.children
          , h = c.map(b => b.geometry);
        h.filter( (b, _e) => h.indexOf(b) === _e).forEach(b => {
            var _e;
            const nt = c.filter(at => at.geometry === b)
              , it = nt.length > 0 ? nt.filter(at => at.material === nt[0].material) : [];
            if (it.length > 1) {
                const at = new three_module.ZLX(b,it[0].material,it.length);
                at.userData = {
                    ...it[0].userData
                },
                at.userData.instanceUserData = [],
                at.userData.attributes = at.userData.defAttributes || at.userData.attributes,
                at.userData.defAttributes && delete at.userData.defAttributes,
                at.name = ((_e = at.userData.attributes) === null || _e === void 0 ? void 0 : _e.name) || it[0].name,
                it.forEach( (ut, pt) => {
                    at.setMatrixAt(pt, ut.matrix),
                    o.remove(ut),
                    at.userData.instanceUserData.push(ut.userData)
                }
                ),
                o.add(at)
            }
        }
        )
    }
    _hideLineMesh(o) {
        if (!Rhino3dmLoader2.HideLineMesh && !Rhino3dmLoader2.HidePointMesh || o.children.length <= 0)
            return;
        const c = [];
        o.traverse(h => {
            (h && Rhino3dmLoader2.HideLineMesh && (h.isLine || h.isLineSegments) || Rhino3dmLoader2.HidePointMesh && h.isPoints) && c.push(h)
        }
        ),
        c.forEach(h => {
            h.userData.visible_3dm = h.visible,
            h.visible = !1
        }
        )
    }
}
Rhino3dmLoader2.LIBRARY_PATH = "https://cdn.jsdelivr.net/npm/rhino3dm@8.9.0/",
Rhino3dmLoader2.ImportMaterials = !0,
Rhino3dmLoader2.ForceLayerMaterials = !1,
Rhino3dmLoader2.ReplaceWithInstancedMesh = !1,
Rhino3dmLoader2.HideLineMesh = !1,
Rhino3dmLoader2.HidePointMesh = !1,
Rhino3dmLoader2.LoadUserDataStrings = !0,
Rhino3dmLoader2.LoadUserDataWarnings = !0;
let Rhino3dmLoadPlugin = class extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin],
        this._importer = new Importer(Rhino3dmLoader2,["3dm"],!0),
        this.importMaterials = !0,
        this.forceLayerMaterials = !1,
        this.replaceWithInstancedMesh = !1,
        this.hideLineMesh = !1,
        this.hidePointMesh = !0,
        this.loadUserDataStrings = !0
    }
    _refresh() {
        Rhino3dmLoader2.ImportMaterials = this.importMaterials,
        Rhino3dmLoader2.ForceLayerMaterials = this.forceLayerMaterials,
        Rhino3dmLoader2.ReplaceWithInstancedMesh = this.replaceWithInstancedMesh,
        Rhino3dmLoader2.HideLineMesh = this.hideLineMesh,
        Rhino3dmLoader2.HidePointMesh = this.hidePointMesh,
        Rhino3dmLoader2.LoadUserDataStrings = this.loadUserDataStrings,
        Rhino3dmLoader2.LoadUserDataWarnings = !1
    }
    async onAdded(d) {
        var o, c;
        (c = (o = d.getManager()) === null || o === void 0 ? void 0 : o.importer) === null || c === void 0 || c.Importers.push(this._importer),
        this._refresh()
    }
    async onDispose(d) {}
    async onRemove(d) {
        var o, c;
        !((c = (o = d.getManager()) === null || o === void 0 ? void 0 : o.importer) === null || c === void 0) && c.Importers && d.getManager().importer.Importers.splice(d.getManager().importer.Importers.indexOf(this._importer), 1)
    }
}
;
Rhino3dmLoadPlugin.PluginType = "Rhino3dmLoadPlugin",
rhino3dm_decorate([x$1(Rhino3dmLoadPlugin.prototype._refresh), uiToggle()], Rhino3dmLoadPlugin.prototype, "importMaterials", void 0),
rhino3dm_decorate([x$1(Rhino3dmLoadPlugin.prototype._refresh), uiToggle()], Rhino3dmLoadPlugin.prototype, "forceLayerMaterials", void 0),
rhino3dm_decorate([x$1(Rhino3dmLoadPlugin.prototype._refresh), uiToggle()], Rhino3dmLoadPlugin.prototype, "replaceWithInstancedMesh", void 0),
rhino3dm_decorate([x$1(Rhino3dmLoadPlugin.prototype._refresh), uiToggle()], Rhino3dmLoadPlugin.prototype, "hideLineMesh", void 0),
rhino3dm_decorate([x$1(Rhino3dmLoadPlugin.prototype._refresh), uiToggle()], Rhino3dmLoadPlugin.prototype, "hidePointMesh", void 0),
rhino3dm_decorate([x$1(Rhino3dmLoadPlugin.prototype._refresh), uiToggle()], Rhino3dmLoadPlugin.prototype, "loadUserDataStrings", void 0),
Rhino3dmLoadPlugin = rhino3dm_decorate([uiFolder("Rhino 3dm loader")], Rhino3dmLoadPlugin);
class STLLoader extends three_module.aHM {
    constructor(o) {
        super(o)
    }
    load(o, c, h, _) {
        const b = this
          , _e = new three_module.Y9S(this.manager);
        _e.setPath(this.path),
        _e.setResponseType("arraybuffer"),
        _e.setRequestHeader(this.requestHeader),
        _e.setWithCredentials(this.withCredentials),
        _e.load(o, function(nt) {
            try {
                c(b.parse(nt))
            } catch (it) {
                _ ? _(it) : console.error(it),
                b.manager.itemError(o)
            }
        }, h, _)
    }
    parse(o) {
        function c(b, _e, nt) {
            for (let it = 0, at = b.length; it < at; it++)
                if (b[it] !== _e.getUint8(nt + it))
                    return !1;
            return !0
        }
        const h = function(b) {
            if (typeof b == "string") {
                const _e = new Uint8Array(b.length);
                for (let nt = 0; nt < b.length; nt++)
                    _e[nt] = 255 & b.charCodeAt(nt);
                return _e.buffer || _e
            }
            return b
        }(o);
        return function(b) {
            const _e = new DataView(b);
            if (84 + 50 * _e.getUint32(80, !0) === _e.byteLength)
                return !0;
            const nt = [115, 111, 108, 105, 100];
            for (let it = 0; it < 5; it++)
                if (c(nt, _e, it))
                    return !1;
            return !0
        }(h) ? function(b) {
            const _e = new DataView(b)
              , nt = _e.getUint32(80, !0);
            let it, at, ut, pt, ht, _t, vt, bt, St = !1;
            for (let Dt = 0; Dt < 70; Dt++)
                _e.getUint32(Dt, !1) == 1129270351 && _e.getUint8(Dt + 4) == 82 && _e.getUint8(Dt + 5) == 61 && (St = !0,
                pt = new Float32Array(3 * nt * 3),
                ht = _e.getUint8(Dt + 6) / 255,
                _t = _e.getUint8(Dt + 7) / 255,
                vt = _e.getUint8(Dt + 8) / 255,
                bt = _e.getUint8(Dt + 9) / 255);
            const At = new three_module.LoY
              , Et = new Float32Array(3 * nt * 3)
              , Pt = new Float32Array(3 * nt * 3)
              , It = new three_module.Q1f;
            for (let Dt = 0; Dt < nt; Dt++) {
                const Gt = 84 + 50 * Dt
                  , Bt = _e.getFloat32(Gt, !0)
                  , kt = _e.getFloat32(Gt + 4, !0)
                  , Ut = _e.getFloat32(Gt + 8, !0);
                if (St) {
                    const Ht = _e.getUint16(Gt + 48, !0);
                    32768 & Ht ? (it = ht,
                    at = _t,
                    ut = vt) : (it = (31 & Ht) / 31,
                    at = (Ht >> 5 & 31) / 31,
                    ut = (Ht >> 10 & 31) / 31)
                }
                for (let Ht = 1; Ht <= 3; Ht++) {
                    const Kt = Gt + 12 * Ht
                      , Jt = 3 * Dt * 3 + 3 * (Ht - 1);
                    Et[Jt] = _e.getFloat32(Kt, !0),
                    Et[Jt + 1] = _e.getFloat32(Kt + 4, !0),
                    Et[Jt + 2] = _e.getFloat32(Kt + 8, !0),
                    Pt[Jt] = Bt,
                    Pt[Jt + 1] = kt,
                    Pt[Jt + 2] = Ut,
                    St && (It.set(it, at, ut).convertSRGBToLinear(),
                    pt[Jt] = It.r,
                    pt[Jt + 1] = It.g,
                    pt[Jt + 2] = It.b)
                }
            }
            return At.setAttribute("position", new three_module.THS(Et,3)),
            At.setAttribute("normal", new three_module.THS(Pt,3)),
            St && (At.setAttribute("color", new three_module.THS(pt,3)),
            At.hasColors = !0,
            At.alpha = bt),
            At
        }(h) : function(b) {
            const _e = new three_module.LoY
              , nt = /solid([\s\S]*?)endsolid/g
              , it = /facet([\s\S]*?)endfacet/g
              , at = /solid\s(.+)/;
            let ut = 0;
            const pt = /[\s]+([+-]?(?:\d*)(?:\.\d*)?(?:[eE][+-]?\d+)?)/.source
              , ht = new RegExp("vertex" + pt + pt + pt,"g")
              , _t = new RegExp("normal" + pt + pt + pt,"g")
              , vt = []
              , bt = []
              , St = []
              , At = new three_module.Pq0;
            let Et, Pt = 0, It = 0, Dt = 0;
            for (; (Et = nt.exec(b)) !== null; ) {
                It = Dt;
                const Gt = Et[0]
                  , Bt = (Et = at.exec(Gt)) !== null ? Et[1] : "";
                for (St.push(Bt); (Et = it.exec(Gt)) !== null; ) {
                    let Ht = 0
                      , Kt = 0;
                    const Jt = Et[0];
                    for (; (Et = _t.exec(Jt)) !== null; )
                        At.x = parseFloat(Et[1]),
                        At.y = parseFloat(Et[2]),
                        At.z = parseFloat(Et[3]),
                        Kt++;
                    for (; (Et = ht.exec(Jt)) !== null; )
                        vt.push(parseFloat(Et[1]), parseFloat(Et[2]), parseFloat(Et[3])),
                        bt.push(At.x, At.y, At.z),
                        Ht++,
                        Dt++;
                    Kt !== 1 && console.error("THREE.STLLoader: Something isn't right with the normal of face number " + ut),
                    Ht !== 3 && console.error("THREE.STLLoader: Something isn't right with the vertices of face number " + ut),
                    ut++
                }
                const kt = It
                  , Ut = Dt - It;
                _e.userData.groupNames = St,
                _e.addGroup(kt, Ut, Pt),
                Pt++
            }
            return _e.setAttribute("position", new three_module.qtW(vt,3)),
            _e.setAttribute("normal", new three_module.qtW(bt,3)),
            _e
        }(typeof (_ = o) != "string" ? new TextDecoder().decode(_) : _);
        var _
    }
}
class STLLoadPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin]
    }
    async onAdded(o) {
        var c, h;
        this._importer || (this._importer = new Importer(STLLoader,["stl"],!0)),
        (h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.Importers.push(this._importer)
    }
    async onDispose(o) {
        this._importer = void 0
    }
    async onRemove(o) {
        var c, h;
        this._importer && (!((h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0) && h.Importers) && o.getManager().importer.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer), 1),
        this._importer = void 0
    }
}
STLLoadPlugin.PluginType = "STLLoadPlugin";
class GLTFMeshOptPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin]
    }
    async onAdded(o) {
        const c = document.createElement("script");
        c.type = "module",
        c.innerHTML = `
import { MeshoptDecoder } from '${GLTFMeshOptPlugin.DECODER_URL}';
window.MeshoptDecoder = MeshoptDecoder
`,
        document.head.appendChild(c),
        this._script = c
    }
    async onDispose(o) {}
    async onRemove(o) {
        this._script && (document.head.removeChild(this._script),
        this._script = void 0)
    }
}
GLTFMeshOptPlugin.PluginType = "GLTFMeshOptPlugin",
GLTFMeshOptPlugin.DECODER_URL = "https://unpkg.com/meshoptimizer@0.20.0/meshopt_decoder.module.js";
var SnowFallPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, SnowFallPlugin_1;
let SnowFallPlugin = SnowFallPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !1,
        this.maxRange = maxRange,
        this.particleSize = .35,
        this.particleSpeed = .35,
        this.minRangeY = 1,
        this.paused = !1,
        this._needsReset = !0,
        this._preFrame = () => {
            var b, _e;
            if (!this._viewer || !this.enabled)
                return;
            const nt = this.maxRange
              , it = nt / 2;
            if (this._viewer.scene.fog) {
                const ht = this._viewer.scene.activeCamera;
                this._viewer.scene.fog.near = Math.max(0, ht.near - 2),
                this._viewer.scene.fog.far = ht.far
            }
            if (this._viewer.scene.backgroundColor && ((b = this._viewer.scene.fog) === null || b === void 0 || b.color.set(this._viewer.scene.backgroundColor)),
            this.paused)
                return;
            const at = this.particles;
            at.material.size = this.particleSize;
            const ut = at.geometry.getAttribute("position")
              , pt = at.geometry.velocities;
            if (this._needsReset) {
                for (let ht = 0; ht < particleNum; ht++) {
                    const _t = Math.random() * nt - it
                      , vt = Math.random() * nt - it
                      , bt = Math.random() * nt - it;
                    ut.setXYZ(ht, _t, vt, bt);
                    const St = .005 * (6 * Math.random() - 3)
                      , At = -.002 * (10 * Math.random() + 3)
                      , Et = .005 * (6 * Math.random() - 3);
                    pt[ht].set(St, At, Et).multiplyScalar(this.particleSpeed)
                }
                this._needsReset = !1
            }
            for (let ht = 0; ht < ut.count; ht++) {
                const _t = pt[ht];
                if (!_t)
                    return;
                const vt = g()
                  , bt = .001 * Math.sin(.001 * vt * _t.x)
                  , St = .001 * Math.cos(.0015 * vt * _t.z);
                let At = ut.getX(ht) + bt
                  , Et = ut.getY(ht) + _t.y
                  , Pt = ut.getZ(ht) + St;
                At < -it ? At = it : At > it && (At = -it),
                Et < Math.max(-it, -this.minRangeY) && (Et = it),
                Pt < -it ? Pt = it : Pt > it && (Pt = -it),
                ut.setX(ht, At),
                ut.setY(ht, Et),
                ut.setZ(ht, Pt)
            }
            ut.needsUpdate = !0,
            (_e = this._viewer) === null || _e === void 0 || _e.setDirty()
        }
        ;
        const d = new three_module.LoY
          , o = [];
        for (let b = 0; b < particleNum; b++) {
            const _e = Math.random() * maxRange - minRange
              , nt = Math.random() * maxRange - minRange
              , it = Math.random() * maxRange - minRange;
            o.push(_e, nt, it)
        }
        d.setAttribute("position", new three_module.qtW(o,3));
        const c = new three_module.BH$({
            size: .75,
            color: 16777215,
            vertexColors: !1,
            map: getTexture(),
            transparent: !0,
            fog: !0,
            depthWrite: !1
        });
        c.userData.renderToDepth = !1;
        const h = [];
        for (let b = 0; b < particleNum; b++) {
            const _e = .005 * (6 * Math.random() - 3)
              , nt = -.002 * (10 * Math.random() + 3)
              , it = .005 * (6 * Math.random() - 3)
              , at = new three_module.Pq0(_e,nt,it);
            h.push(at)
        }
        const _ = new three_module.ONl(d,c);
        _.userData.bboxVisible = !1,
        _.geometry.velocities = h,
        this.particles = _
    }
    async onAdded(d) {
        await super.onAdded(d),
        d.addEventListener("preFrame", this._preFrame),
        this.enabled && await this.onEnable()
    }
    async onEnable() {
        var d, o;
        const c = this._viewer;
        if (!c)
            return;
        const h = c.getPlugin(FrameFadePlugin);
        if (!this.enabled)
            return this.particles.visible = !1,
            this.particles.geometry.dispose(),
            this.particles.material.dispose(),
            void (h && h.enable(SnowFallPlugin_1.PluginType));
        c.scene.fog = new three_module.jUj((d = c.scene.backgroundColor) !== null && d !== void 0 ? d : 54,0,maxRange);
        const _ = (o = c.scene.getObjectByName("SnowFallPlugin_root")) !== null && o !== void 0 ? o : (await c.createObject3D(void 0, !0)).modelObject;
        _.name = "SnowFallPlugin_root",
        _.clear(),
        h && h.disable(SnowFallPlugin_1.PluginType),
        _.add(this.particles),
        this.particles.visible = !0,
        this._needsReset = !0
    }
    async onRemove(d) {
        return d.removeEventListener("preFrame", this._preFrame),
        this.particles.removeFromParent(),
        super.onRemove(d)
    }
    reset() {
        this._needsReset = !0
    }
}
;
SnowFallPlugin.PluginType = "SnowFallPlugin",
SnowFallPlugin_decorate([uiToggle(), serialize(), x$1(SnowFallPlugin.prototype.onEnable)], SnowFallPlugin.prototype, "enabled", void 0),
SnowFallPlugin_decorate([uiSlider("Bounds size", [1, 50]), x$1(SnowFallPlugin.prototype.reset), serialize()], SnowFallPlugin.prototype, "maxRange", void 0),
SnowFallPlugin_decorate([uiSlider("Particle size", [.01, 2]), serialize()], SnowFallPlugin.prototype, "particleSize", void 0),
SnowFallPlugin_decorate([uiSlider("Particle speed", [0, 2]), x$1(SnowFallPlugin.prototype.reset), serialize()], SnowFallPlugin.prototype, "particleSpeed", void 0),
SnowFallPlugin_decorate([uiSlider("Bottom clamp", [0, 30]), serialize()], SnowFallPlugin.prototype, "minRangeY", void 0),
SnowFallPlugin_decorate([uiToggle("Paused"), serialize()], SnowFallPlugin.prototype, "paused", void 0),
SnowFallPlugin = SnowFallPlugin_1 = SnowFallPlugin_decorate([uiFolder("Snow Fall Particles")], SnowFallPlugin);
const particleNum = 4e3
  , maxRange = 17
  , minRange = maxRange / 2
  , textureSize = 64
  , drawRadialGradation = (d, o, c, h) => {
    d.save();
    const _ = d.createRadialGradient(o, o, 0, o, o, o);
    _.addColorStop(0, "rgba(255,255,255,1.0)"),
    _.addColorStop(.5, "rgba(255,255,255,0.5)"),
    _.addColorStop(1, "rgba(255,255,255,0)"),
    d.fillStyle = _,
    d.fillRect(0, 0, c, h),
    d.restore()
}
  , getTexture = () => {
    const d = document.createElement("canvas")
      , o = d.getContext("2d");
    if (!o)
        throw new Error("no context");
    const c = textureSize;
    d.width = c,
    d.height = c,
    drawRadialGradation(o, c / 2, d.width, d.height);
    const h = new three_module.gPd(d);
    return h.type = three_module.RQf,
    h.colorSpace = "srgb-linear",
    h.needsUpdate = !0,
    h
}
;
class SnowFlakes extends three_module.B69 {
    constructor() {
        super(),
        this.snowList = [],
        this.angle = 0;
        const o = new three_module.LoY
          , c = []
          , h = new three_module.Tap
          , _ = h.load("https://dl.dropbox.com/s/13ec3ht27adnu1l/snowflake1.png?dl=0")
          , b = h.load("https://dl.dropbox.com/s/rczse8o8zt5mxe6/snowflake2.png?dl=0")
          , _e = h.load("https://dl.dropbox.com/s/cs17pph4bu096k7/snowflake3.png?dl=0")
          , nt = h.load("https://dl.dropbox.com/s/plwtcfvokuoz931/snowflake4.png?dl=0")
          , it = h.load("https://dl.dropbox.com/s/uhh77omqdwqo2z5/snowflake5.png?dl=0")
          , at = [];
        for (let pt = 0; pt < 10; pt++) {
            const ht = getRandom(0, 500)
              , _t = getRandom(0, 500)
              , vt = getRandom(0, 500);
            at.push(ht, _t, vt)
        }
        o.setAttribute("position", new three_module.qtW(at,3));
        const ut = [["#FFFFFF", b, getRandom(10, 10)], ["#FFFFFF", _e, getRandom(10, 15)], ["#FFFFFF", _, getRandom(10, 15)], ["#FFFFFF", it, getRandom(5, 10)], ["#FFFFFF", nt, getRandom(5, 10)]];
        for (let pt = 0; pt < ut.length; pt++) {
            const ht = ut[pt][1]
              , _t = ut[pt][2];
            c[pt] = new three_module.BH$({
                size: _t,
                map: ht,
                blending: three_module.EZo,
                depthTest: !1,
                transparent: !0
            });
            const vt = new three_module.ONl(o,c[pt]);
            vt.rotation.x = 360 * Math.random(),
            vt.rotation.y = 360 * Math.random(),
            vt.rotation.z = 360 * Math.random(),
            vt.vx = 0,
            vt.vy = 0,
            vt.material.opacity = 0,
            this.add(vt),
            this.snowList.push(vt)
        }
    }
    update() {
        this.angle += .001;
        for (let o = 0; o < this.snowList.length; o++)
            this.snowList[o].material.opacity += .01,
            this.snowList[o].vy -= 1,
            this.snowList[o].vx = Math.sin(this.angle) * Math.cos(this.angle) * 10,
            this.snowList[o].vx *= .2,
            this.snowList[o].vy *= .6,
            this.snowList[o].position.x += this.snowList[o].vx,
            this.snowList[o].position.y += this.snowList[o].vy,
            this.snowList[o].position.y < -1e3 && (this.snowList[o].material.opacity += .1,
            this.remove(this.snowList[o]),
            this.snowList.splice(o, 1),
            o -= 1);
        return this.snowList.length
    }
}
function getRandom(d, o) {
    return Math.random() * (o - d) + d
}
var ModelStagePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ModelStagePlugin = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.model = "",
        this.dependencies = [AssetManagerPlugin],
        this._sceneUpdate = d => {
            d.hierarchyChanged && this.refreshTransform()
        }
        ,
        this._lastPhysicalGroundProps = void 0,
        this._animationStep = d => {}
        ,
        this._animationStep2 = d => {
            this._animationStep(d)
        }
        ,
        this.groundBelowModel = !1
    }
    async promptLoadModel() {
        if (!this._viewer)
            return void console.warn("ModelStagePlugin: No viewer");
        const d = await ge$1(!1, !1);
        if (!d.length)
            return;
        const o = d[0];
        await this.setModel(o)
    }
    async promptLoadModelUrl() {
        if (!this._viewer)
            return void console.warn("ModelStagePlugin: No viewer");
        const d = await this._viewer.prompt("Model Stage Plugin: Enter URL for the 3d model (glb, gltf, obj, fbx, etc)");
        d && await this.setModel(d)
    }
    async setModel(d) {
        var o, c, h;
        if (!this._viewer)
            return void console.warn("ModelStagePlugin: No viewer");
        const _ = this.modelRef
          , b = d ? await this._viewer.load(typeof d == "string" ? d : {
            path: d.name,
            file: d
        }, {
            autoCenter: !1,
            autoScale: !1,
            addToRoot: !0,
            importConfig: !1
        }) : void 0;
        if (!b && d)
            return void console.warn("ModelStagePlugin: Unable to load stage model");
        this.model = d || "",
        this.modelRef = b,
        _ && _.modelObject !== ((o = this.modelRef) === null || o === void 0 ? void 0 : o.modelObject) && _.dispose(),
        this.refreshTransform();
        const _e = this._viewer.getPlugin(LoadingScreenPlugin);
        return _e != null && _e.visible && await _e.hideWithDelay(),
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postRender", !0, 1),
        this.model
    }
    refreshTransform() {
        var d, o, c, h, _, b;
        const _e = this.modelRef;
        if (!_e || !this._viewer)
            return;
        const nt = this._viewer.getPluginByType("Ground");
        if (nt) {
            nt.useModelBounds = this.groundBelowModel;
            const Et = this._viewer.getPlugin(GroundPlugin);
            Et && (this.groundBelowModel ? (this._lastPhysicalGroundProps = {
                renderToDepth: Et.renderToDepth,
                physicalReflections: Et.physicalReflections,
                groundReflection: Et.groundReflection,
                material: {
                    transparent: (d = Et.material) === null || d === void 0 ? void 0 : d.transparent
                }
            },
            Et.renderToDepth = !1,
            Et.physicalReflections = !1,
            Et.groundReflection = !1,
            Et.material && (Et.material.transparent = !0)) : this._lastPhysicalGroundProps && (Et.renderToDepth = this._lastPhysicalGroundProps.renderToDepth,
            Et.physicalReflections = this._lastPhysicalGroundProps.physicalReflections,
            Et.groundReflection = this._lastPhysicalGroundProps.groundReflection,
            Et.material && this._lastPhysicalGroundProps.material && (Et.material.transparent = this._lastPhysicalGroundProps.material.transparent),
            this._lastPhysicalGroundProps = void 0))
        }
        const it = this._getPlaceholders()
          , at = it[0];
        if (it.forEach(Et => Et.visible = !1),
        !at)
            return void console.warn("ModelStagePlugin: No placeholder found");
        const ut = this._viewer.scene.modelRoot.children[0];
        if (!ut)
            return void console.warn("ModelStagePlugin: No object in scene");
        const pt = new Box3B().expandByObject(ut, !0, !0)
          , ht = new Box3B().expandByObject(at, !0, !1)
          , _t = pt.getSize(new three_module.Pq0)
          , vt = ht.getSize(new three_module.Pq0)
          , bt = pt.getCenter(new three_module.Pq0)
          , St = ht.getCenter(new three_module.Pq0)
          , At = Math.max(_t.x / vt.x, _t.y / vt.y, _t.z / vt.z);
        if (isFinite(At) && At !== 0) {
            _e.modelObject.scale.multiplyScalar(At),
            St.multiplyScalar(At),
            _e.modelObject.position.add(bt).sub(St),
            _e.modelObject.position.y += (vt.y * At - _t.y) / 2,
            (c = (o = _e.modelObject).setDirty) === null || c === void 0 || c.call(o);
            for (let Et = 1; Et < this._viewer.scene.modelRoot.children.length; Et++) {
                const Pt = it[Et % it.length]
                  , It = this._viewer.scene.modelRoot.children[Et];
                Pt.updateMatrixWorld(!0),
                It.updateMatrixWorld(!0);
                const Dt = Pt.getWorldQuaternion(new three_module.PTz);
                It.applyQuaternion(Dt),
                It.updateMatrixWorld(!0);
                const Gt = new Box3B().expandByObject(Pt, !0, !1)
                  , Bt = new Box3B().expandByObject(It, !0, !0)
                  , kt = Gt.getSize(new three_module.Pq0)
                  , Ut = Bt.getSize(new three_module.Pq0)
                  , Ht = Gt.getCenter(new three_module.Pq0)
                  , Kt = Bt.getCenter(new three_module.Pq0)
                  , Jt = Math.min(kt.x / Ut.x, kt.y / Ut.y, kt.z / Ut.z);
                isFinite(Jt) && Jt !== 0 && (It.scale.multiplyScalar(Jt),
                Kt.multiplyScalar(Jt),
                It.position.add(Ht).sub(Kt),
                It.position.y += (Ut.y * Jt - kt.y) / 2,
                (_ = (h = It).setDirty) === null || _ === void 0 || _.call(h))
            }
            if (at.updateMatrixWorld(!0),
            _e.modelObject.animations.length) {
                let Et = at.matrixWorld.clone();
                this._animationStep = () => {
                    const Pt = at.matrixWorld.clone()
                      , It = Et.invert().premultiply(Pt);
                    ut.applyMatrix4(It),
                    Et = Pt
                }
            } else
                this._animationStep = () => {}
                ;
            if (!this.groundBelowModel) {
                const Et = this._viewer.getPluginByType("Ground");
                if (!((b = Et == null ? void 0 : Et.mesh) === null || b === void 0) && b.modelObject && Et) {
                    const Pt = new Box3B().expandByObject(_e.modelObject, !0, !1).getSize(new three_module.Pq0)
                      , It = Math.max(Pt.x, Pt.z);
                    Et.autoFrustumSize = !1,
                    Et.size = It;
                    const Dt = Et.shadowBaker;
                    Dt && (Dt.light.shadowParams.frustumSize = 2 * It,
                    Dt.light.updateShadowParams())
                }
            }
        }
    }
    _getPlaceholders(d) {
        var o;
        const c = [];
        return (o = d ?? this.modelRef) === null || o === void 0 || o.modelObject.traverse(h => {
            h.name.toLowerCase().startsWith("placeholder") && c.push(h)
        }
        ),
        c
    }
    async onAdded(d) {
        var o;
        await super.onAdded(d),
        d.scene.addEventListener("sceneUpdate", this._sceneUpdate),
        (o = d.getPlugin(GLTFAnimationPlugin)) === null || o === void 0 || o.addEventListener("animationStep", this._animationStep2)
    }
    async onRemove(d) {
        var o;
        return this.modelRef && this.modelRef.dispose(),
        d.scene.removeEventListener("sceneUpdate", this._sceneUpdate),
        (o = d.getPlugin(GLTFAnimationPlugin)) === null || o === void 0 || o.removeEventListener("animationStep", this._animationStep2),
        super.onRemove(d)
    }
    fromJSON(d, o) {
        return d.model !== void 0 && this.setModel(d.model),
        super.fromJSON(d, o)
    }
    loadSampleModel() {
        // this.setModel("https://cors-proxy.r2cache.com/https://assets.demodrive.ijewel3d.com/test-stage/stage-placeholder4.glb")
        console.log("Sample model loading disabled - using local assets only")
    }
    togglePlaceholders() {
        var d;
        this._getPlaceholders().forEach(o => {
            o.material && (o.material.opacity = Math.min(.75, o.material.opacity || 1),
            o.material.transparent = !0),
            o.visible = !o.visible
        }
        ),
        (d = this._viewer) === null || d === void 0 || d.setDirty()
    }
    importStageViewerConfig() {
        var d, o, c;
        const h = ((d = this.modelRef) === null || d === void 0 ? void 0 : d.modelObject).__importedViewerConfig;
        if (!h || typeof h != "object" || !this._viewer)
            return;
        const _ = this._viewer.scene.activeCamera.toJSON()
          , b = this._viewer.serializePluginsIgnored;
        this._viewer.serializePluginsIgnored = [...b, LoadingScreenPlugin.PluginType, InteractionPromptPlugin.PluginType, "ReliefParallaxMapping", "RendererParamsUiPlugin", CameraViewPlugin.PluginType, "MaterialConfiguratorPlugin", "SwitchNodePlugin", "FrameFade", "GLTFAnimationPlugin", "ModelStagePlugin", SnowFallPlugin.PluginType],
        (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.assetManager) === null || c === void 0 || c.applyViewerConfig(h, h.resources),
        this._viewer.serializePluginsIgnored = b,
        this._viewer.scene.activeCamera.fromJSON(_)
    }
}
;
ModelStagePlugin.PluginType = "ModelStagePlugin",
ModelStagePlugin_decorate([serialize()], ModelStagePlugin.prototype, "model", void 0),
ModelStagePlugin_decorate([uiButton("Prompt Local File")], ModelStagePlugin.prototype, "promptLoadModel", null),
ModelStagePlugin_decorate([uiButton("Prompt URL")], ModelStagePlugin.prototype, "promptLoadModelUrl", null),
ModelStagePlugin_decorate([uiButton("Refresh Placeholder Transform")], ModelStagePlugin.prototype, "refreshTransform", null),
ModelStagePlugin_decorate([serialize(), x$1(ModelStagePlugin.prototype.refreshTransform), uiToggle()], ModelStagePlugin.prototype, "groundBelowModel", void 0),
ModelStagePlugin_decorate([uiButton("Load sample model")], ModelStagePlugin.prototype, "loadSampleModel", null),
ModelStagePlugin_decorate([uiButton("Toggle Placeholders")], ModelStagePlugin.prototype, "togglePlaceholders", null),
ModelStagePlugin_decorate([uiButton("Import Stage Config", d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d.modelRef) === null || o === void 0 ? void 0 : o.modelObject) === null || c === void 0) && c.__importedViewerConfig)
    }
}))], ModelStagePlugin.prototype, "importStageViewerConfig", null),
ModelStagePlugin = ModelStagePlugin_decorate([uiFolder("Model Stage")], ModelStagePlugin);
class CoreViewerApp extends ViewerApp {
    constructor(o) {
        super(o),
        this.licenseKey = o.licenseKey
    }
    async initialize({caching: o=!0, ground: c=!0, bloom: h=!0, depthTonemap: _=!0, enableDrop: b=!1, importPopup: _e=!0, debug: nt=!1, interactionPrompt: it=!0}={}) {
        nt && await this.addPlugin(DebugPlugin),
        this.getPlugin(AssetManagerPlugin) || this.addPluginSync(AssetManagerPlugin, void 0, void 0, {
            storage: o && window.caches ? await caches.open("webgi-cache-storage") : void 0
        }),
        await addBasePlugins(this, {
            ground: c,
            bloom: h,
            depthTonemap: _,
            enableDrop: b,
            importPopup: _e,
            interactionPrompt: it
        }),
        await this.getOrAddPlugin(PresetLibraryPlugin);
        const at = await this.getOrAddPlugin(DiamondPlugin);
        return this.licenseKey && at.setKey(this.licenseKey),
        await this.addPlugin(MaterialConfiguratorPlugin),
        await this.addPlugin(SwitchNodePlugin),
        await this.addPlugin(MaterialLibraryPlugin),
        this
    }
}
async function addBasePlugins(d, {ground: o=!0, bloom: c=!0, depthTonemap: h=!0, enableDrop: _=!1, importPopup: b=!1, interactionPrompt: _e=!0}={}) {
    await d.getOrAddPlugin(AssetManagerPlugin),
    b && await d.getOrAddPlugin(LoadingScreenPlugin),
    await d.getOrAddPlugin(GBufferPlugin),
    await d.getOrAddPlugin(FullScreenPlugin),
    _ && await d.getOrAddPlugin(DropzonePlugin),
    await d.addPlugin(new ProgressivePlugin(32)),
    await d.getOrAddPlugin(CombinedPostPlugin),
    await d.getOrAddPlugin(ChromaticAberrationPlugin),
    await d.addPlugin(new TonemapPlugin(h || !d.useRgbm)),
    await d.getOrAddPlugin(LUTPlugin),
    await d.getOrAddPlugin(VignettePlugin),
    await d.getOrAddPlugin(FilmicGrainPlugin),
    await d.getOrAddPlugin(GammaCorrectionPlugin),
    await d.getOrAddPlugin(SSRPlugin),
    await d.getOrAddPlugin(SSAOPlugin),
    await d.getOrAddPlugin(FrameFadePlugin),
    await d.getOrAddPlugin(GLTFAnimationPlugin),
    await d.getOrAddPlugin(AnisotropyPlugin),
    await d.getOrAddPlugin(TriplanarUVMappingPlugin),
    await d.getOrAddPlugin(ThinFilmLayerPlugin),
    await d.getOrAddPlugin(FragmentClippingExtensionPlugin),
    await d.getOrAddPlugin(NoiseBumpMaterialPlugin),
    await d.getOrAddPlugin(CustomBumpMapPlugin),
    await d.getOrAddPlugin(ClearcoatTintPlugin),
    await d.getOrAddPlugin(GLTFKHRMaterialVariantsPlugin),
    await d.getOrAddPlugin(VelocityBufferPlugin, !1),
    await d.getOrAddPlugin(TemporalAAPlugin),
    await d.getOrAddPlugin(CameraViewPlugin),
    await d.getOrAddPlugin(RandomizedDirectionalLightPlugin, !1),
    await d.getOrAddPlugin(HDRiGroundPlugin, !1),
    await d.getOrAddPlugin(DepthOfFieldPlugin, !1),
    await d.getOrAddPlugin(SSContactShadows, !1),
    await d.getOrAddPlugin(SSGIPlugin, !1),
    await d.getOrAddPlugin(NormalBufferPlugin, !1),
    await d.getOrAddPlugin(SSBevelPlugin, !1),
    await d.getOrAddPlugin(KTX2LoadPlugin),
    await d.getOrAddPlugin(ObjMtlLoadPlugin),
    await d.getOrAddPlugin(FBXLoadPlugin),
    await d.getOrAddPlugin(Rhino3dmLoadPlugin),
    await d.getOrAddPlugin(STLLoadPlugin),
    await d.getOrAddPlugin(EXRLoadPlugin),
    await d.getOrAddPlugin(GLTFMeshOptPlugin),
    await d.getOrAddPlugin(ModelStagePlugin),
    await d.getOrAddPlugin(ParallaxCameraControllerPlugin),
    c && await d.getOrAddPlugin(BloomPlugin),
    o && await d.getOrAddPlugin(GroundPlugin),
    _e && await d.getOrAddPlugin(InteractionPromptPlugin),
    await d.getOrAddPlugin(LayeredMaterialPlugin),
    d.renderer.refreshPipeline()
}
var dist_tippy = __webpackgi_require__(774)
  , tippy_exported = {};
dist_tippy.A && dist_tippy.A.locals && (tippy_exported.locals = dist_tippy.A.locals);
var tippy_refs = 0, tippy_update, tippy_options = {};
tippy_options.styleTagTransform = styleTagTransform_default(),
tippy_options.setAttributes = setAttributesWithoutAttributes_default(),
tippy_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
tippy_options.domAPI = styleDomAPI_default(),
tippy_options.insertStyleElement = insertStyleElement_default(),
tippy_exported.use = function(d) {
    return tippy_options.options = d || {},
    tippy_refs++ || (tippy_update = injectStylesIntoStyleTag_default()(dist_tippy.A, tippy_options)),
    tippy_exported
}
,
tippy_exported.unuse = function() {
    tippy_refs > 0 && !--tippy_refs && (tippy_update(),
    tippy_update = null)
}
;
var tippy_js_dist_tippy = tippy_exported;
const placeholderModel = ""
  , placeholderEnvironment = "";
let id$3 = 0;
class WebGiViewerElement extends HTMLElement {
    constructor() {
        super(),
        this._initialized = !1,
        this._state = {
            src: "",
            environment: ""
        },
        this._models = {},
        this._refreshingModels = !1,
        this._refreshingEnvironment = !1,
        this._environmentFromSource = null,
        this.viewerIndex = id$3++,
        this.canvasId = "webgi-viewer-" + this.viewerIndex,
        window.freeViewers || (window.freeViewers = []),
        this.attachShadow({
            mode: "open"
        }),
        this.wrapper = document.createElement("div"),
        this.wrapper.style.width = "100%",
        this.wrapper.style.height = "100%",
        this.wrapper.style.display = "block";
        const o = window.freeViewers.pop()
          , c = document.createElement("style");
        c.textContent = $`
            #${this.canvasId}{
              width: 100%; height: 100%; z-index: 1;
              display: block;
            }
            //.tippy-box[data-theme~='editor']{
            //    margin: 0.25rem !important;
            //    background-color: hsla(230, 10%, 30%, 1.00) !important;
            //    font-size: 0.9rem !important;
            //    color: hsla(230, 5%, 90%, 1.00) !important;
            //}
        `,
        tippy_js_dist_tippy.use({
            target: this.wrapper
        }),
        tippy_esm.setDefaultProps({
            duration: 300,
            arrow: !0,
            appendTo: () => this.wrapper
        }),
        this.shadowRoot.append(c, this.wrapper),
        this._initialized = !0,
        this._initialize(o).then(async () => this.refreshAll())
    }
    async refreshAll() {
        this.viewer && (this.viewer.renderer.displayCanvasScaling = parseFloat(this.getAttribute("renderScale") || this.getAttribute("renderscale") || this.viewer.renderer.displayCanvasScaling.toString())),
        await Promise.all([this.refreshModelSource(), this.refreshEnvironment()])
    }
    async _initialize(o) {
        o != null && o._lastState && (this._state.src = o._lastState.src || this._state.src,
        this._state.environment = o._lastState.environment || this._state.environment,
        delete o._lastState),
        o != null && o.__models && (this._models = {
            ...this._models,
            ...o.__models
        },
        delete o.__models),
        this.canvas = (o == null ? void 0 : o.canvas) || j(),
        this.canvas.setAttribute("id", this.canvasId),
        this.wrapper.append(this.canvas),
        this.viewer = o ?? new CoreViewerApp({
            canvas: this.canvas,
            useRgbm: this._getAttr("rgbm", "true") === "true",
            useGBufferDepth: this._getAttr("depth-prepass", "true") === "true",
            assetManager: {
                storage: window.caches ? await caches.open("webgi-cache-storage") : void 0
            }
        }),
        this.viewer && (this.viewer.renderer.displayCanvasScaling = parseFloat(this.getAttribute("renderScale") || this.getAttribute("renderscale") || this.viewer.renderer.displayCanvasScaling.toString())),
        o || await this.viewer.initialize({
            debug: this._getAttr("debug", "false") === "true",
            ground: this._getAttr("ground", "baked") === "baked",
            bloom: this._getAttr("bloom", "true") === "true",
            depthTonemap: !0
        }),
        this.dispatchEvent(new Event("initialized"))
    }
    connectedCallback() {
        this._initialized && this.viewer && (this.viewer.resize(),
        this.viewer.enabled = !0,
        this.dispatchEvent(new Event("connected")))
    }
    disconnectedCallback() {
        var o, c;
        this.viewer && (this.getAttribute("disposeOnRemove") === "true" || this.getAttribute("disposeonremove") === "true" ? ((o = this.canvas) === null || o === void 0 || o.remove(),
        this.clearViewer(),
        this.viewer.dispose(),
        this.viewer = void 0,
        this.canvas = void 0,
        this._initialized = !1) : this.getAttribute("autoManageViewers") === "true" || this.getAttribute("automanageviewers") === "true" ? ((c = this.canvas) === null || c === void 0 || c.remove(),
        this.viewer._lastState = {
            ...this._state
        },
        this.viewer._lastState.src = "",
        this.clearViewer(),
        window.freeViewers.push(this.viewer),
        this.viewer = void 0,
        this.canvas = void 0,
        this._initialized = !1) : this.viewer.enabled = !1,
        this.dispatchEvent(new Event("disconnected")))
    }
    adoptedCallback() {
        this.viewer && (this.viewer.resize(),
        this.viewer.enabled = !0)
    }
    static get observedAttributes() {
        return ["src", "environment", "renderScale"]
    }
    attributeChangedCallback(o, c, h) {
        this.refreshAll()
    }
    clearViewer() {
        var o, c;
        (o = this.viewer) === null || o === void 0 || o.scene.disposeSceneModels(),
        (c = this.viewer) === null || c === void 0 || c.scene.setEnvironment(null),
        Object.values(this._models).forEach(async h => h.then(_ => _.forEach(b => b.dispose && b.dispose()))),
        this._models = {}
    }
    async refreshModelSource() {
        if (!this.viewer)
            return;
        const o = this._getAttr("src", placeholderModel);
        if (o === this._state.src || this._refreshingModels)
            return;
        this._refreshingModels = !0;
        const c = [o]
          , h = []
          , _ = []
          , b = this.viewer.scene.environment;
        this.viewer.scene.environment = null,
        this._environmentFromSource = null;
        for (const nt of c)
            !this._models[nt] && nt && (this._models[nt] = this.viewer.getManager().importer.importPath(nt, {
                autoScale: this._getAttr("auto-scale", "true") === "true",
                autoCenter: this._getAttr("auto-center", "true") === "true",
                processImported: !0,
                pathOverride: this._getAttr("filename", "") || void 0
            }));
        const _e = this.viewer.scene.environment;
        _e ? this._environmentFromSource = _e : this.viewer.scene.environment = b;
        for (const [nt,it] of Object.entries(this._models))
            c.includes(nt) ? h.push(it.then(at => [nt, at])) : _.push(it);
        await Promise.all([Promise.all(h).then(async nt => Promise.all(nt.map(async it => (this._models[it[0]] = this.viewer.getManager().importer.processImported(it[1]),
        this._models[it[0]])))).then(nt => {
            for (const it of nt)
                for (const at of it)
                    at && at.assetType === "model" && this.viewer.scene.addSceneObject(at)
        }
        ), Promise.all(_).then(nt => {
            for (const it of nt)
                for (const at of it)
                    at && at.assetType === "model" && at.modelObject.removeFromParent()
        }
        )]),
        this._state.src = o,
        this._refreshingModels = !1
    }
    async refreshEnvironment() {
        if (!this.viewer)
            return;
        if (!this.hasAttribute("environment"))
            return void (this._state.environment = null);
        if (this._environmentFromSource)
            return void this.viewer.console.warn("Environment is already set by model source, ignoring environment attribute.");
        const o = this._getAttr("environment", placeholderEnvironment);
        if (o === this._state.src || this._refreshingEnvironment)
            return;
        this._refreshingEnvironment = !0;
        const c = this.viewer.scene.getEnvironment()
          , h = o ? await this.viewer.getManager().importer.importSinglePath(o) : void 0;
        this._environmentFromSource ? this.viewer.console.warn("Environment is already set by model source, ignoring environment attribute.") : (h && h.assetType !== "texture" || await this.viewer.scene.setEnvironment(h),
        c == null || c.dispose(),
        this.dispatchEvent(new CustomEvent("environment-loaded",{
            detail: {
                src: o
            }
        })),
        this._state.environment = o,
        this._refreshingEnvironment = !1)
    }
    _getAttr(o, c) {
        return this.hasAttribute(o) ? this.getAttribute(o) : c
    }
    addEventListener(o, c, h) {
        super.addEventListener(o, c, h),
        o === "initialized" && this._initialized && this.dispatchEvent(new Event("initialized"))
    }
}
window && window.customElements && !window.customElements.get("webgi-viewer") && window.customElements.define("webgi-viewer", WebGiViewerElement);
var popup = __webpackgi_require__(636)
  , popup_exported = {};
popup.A && popup.A.locals && (popup_exported.locals = popup.A.locals);
var popup_refs = 0, popup_update, popup_options = {};
popup_options.styleTagTransform = styleTagTransform_default(),
popup_options.setAttributes = setAttributesWithoutAttributes_default(),
popup_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
popup_options.domAPI = styleDomAPI_default(),
popup_options.insertStyleElement = insertStyleElement_default(),
popup_exported.use = function(d) {
    return popup_options.options = d || {},
    popup_refs++ || (popup_update = injectStylesIntoStyleTag_default()(popup.A, popup_options)),
    popup_exported
}
,
popup_exported.unuse = function() {
    popup_refs > 0 && !--popup_refs && (popup_update(),
    popup_update = null)
}
;
var styles_popup = popup_exported
  , AssetManagerPopupPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let AssetManagerBasicPopupPlugin = class extends AAssetManagerProcessStatePlugin {
    constructor() {
        super("Popup");
        const d = ee$1({
            id: "assetManagerPopupClose",
            addToBody: !1,
            innerHTML: "&#10005"
        });
        d.addEventListener("click", () => {
            this._mainDiv.style.display = "none"
        }
        ),
        this._mainDiv.appendChild(d)
    }
    _updateMainDiv(d) {
        if (!this._contentDiv)
            return;
        if (!this.enabled)
            return void (this._mainDiv.style.display = "none");
        let o = "";
        d.forEach( (c, h) => {
            o += `<span class="processState">${c.state}</span>: ${(h || "").split("/").pop()} ${c.progress ? " - " + c.progress.toFixed(0) + "%" : ""}<br>`
        }
        ),
        this._contentDiv.innerHTML = o,
        d.size === 0 ? this._mainDiv.style.display = "none" : this._mainDiv.style.display = "block"
    }
    async onAdded(d) {
        styles_popup.use({
            target: d.container
        }),
        await super.onAdded(d)
    }
}
;
AssetManagerBasicPopupPlugin.PluginType = "AssetManagerBasicPopupPlugin",
AssetManagerBasicPopupPlugin = AssetManagerPopupPlugin_decorate([uiFolder("Asset manager popup")], AssetManagerBasicPopupPlugin);
var loadingBar = __webpackgi_require__(223)
  , loadingBar_exported = {};
loadingBar.A && loadingBar.A.locals && (loadingBar_exported.locals = loadingBar.A.locals);
var loadingBar_refs = 0, loadingBar_update, loadingBar_options = {};
loadingBar_options.styleTagTransform = styleTagTransform_default(),
loadingBar_options.setAttributes = setAttributesWithoutAttributes_default(),
loadingBar_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
loadingBar_options.domAPI = styleDomAPI_default(),
loadingBar_options.insertStyleElement = insertStyleElement_default(),
loadingBar_exported.use = function(d) {
    return loadingBar_options.options = d || {},
    loadingBar_refs++ || (loadingBar_update = injectStylesIntoStyleTag_default()(loadingBar.A, loadingBar_options)),
    loadingBar_exported
}
,
loadingBar_exported.unuse = function() {
    loadingBar_refs > 0 && !--loadingBar_refs && (loadingBar_update(),
    loadingBar_update = null)
}
;
var styles_loadingBar = loadingBar_exported
  , AssetManagerLoadingBarPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let AssetManagerLoadingBarPlugin = class extends AAssetManagerProcessStatePlugin {
    constructor(d=!0) {
        super("LoadingBar"),
        this.showText = d,
        this.hideOnOnlyErrors = !0
    }
    _updateMainDiv(d) {
        if (!this._contentDiv)
            return;
        if (!this.enabled)
            return void (this._mainDiv.style.display = "none");
        let o = 1
          , c = 1;
        d.forEach( (_, b) => {
            var _e;
            o += (_e = _.progress) !== null && _e !== void 0 ? _e : 99,
            c += 100
        }
        ),
        this._contentDiv.innerHTML = this.showText ? (100 * o / c).toFixed(0) + "%" : "&nbsp;",
        this._contentDiv.style.width = (100 * o / c).toFixed(0) + "%";
        const h = [...d.values()].filter(_ => _.state === "error");
        h.length > 0 && h.length === d.size && this.hideOnOnlyErrors || d.size === 0 ? this._mainDiv.style.display = "none" : this._mainDiv.style.display = "block"
    }
    async onAdded(d) {
        styles_loadingBar.use({
            target: d.container
        }),
        await super.onAdded(d)
    }
}
;
AssetManagerLoadingBarPlugin.PluginType = "AssetManagerLoadingBarPlugin",
AssetManagerLoadingBarPlugin_decorate([uiToggle("Hide on only errors"), serialize()], AssetManagerLoadingBarPlugin.prototype, "hideOnOnlyErrors", void 0),
AssetManagerLoadingBarPlugin = AssetManagerLoadingBarPlugin_decorate([uiFolder("Asset manager loading bar")], AssetManagerLoadingBarPlugin);
class SimpleAssetList {
    get basePath() {
        return this._basePath
    }
    get assets() {
        return this._assets
    }
    constructor(o) {
        var c, h, _;
        this._basePath = (c = o == null ? void 0 : o.basePath) !== null && c !== void 0 ? c : "",
        this._assets = (_ = (h = o == null ? void 0 : o.assets) === null || h === void 0 ? void 0 : h.map(b => this._resolveAsset(b))) !== null && _ !== void 0 ? _ : []
    }
    find(o) {
        const c = this._assets.find(o);
        return c ?? void 0
    }
    _resolveAsset(o) {
        return {
            ...o,
            path: ot([this._basePath, o.path])
        }
    }
}
class SimpleDataSource extends I$2 {
    constructor(...o) {
        super(),
        this._assets = o
    }
    addAssetList(o) {
        this._assets.push(o)
    }
    removeAssetList(o) {
        const c = this._assets.indexOf(o);
        c >= 0 && this._assets.splice(c, 1)
    }
    async findAssetRegex(o) {
        for (const c of this._assets) {
            const h = c.find(_ => {
                var b, _e;
                return _ && (o.test(_.path) || o.test((_e = (b = _.file) === null || b === void 0 ? void 0 : b.name) !== null && _e !== void 0 ? _e : ""))
            }
            );
            if (h)
                return h
        }
        console.warn("Asset not found:", o)
    }
    async findAsset(o) {
        return this.findAssetRegex(o.query)
    }
    async findAssetSimple(o, c=!1) {
        return this.findAssetRegex(new RegExp(o,c ? "i" : ""))
    }
}
const LineSegments2_start = new three_module.Pq0
  , LineSegments2_end = new three_module.Pq0
  , _start4 = new three_module.IUQ
  , _end4 = new three_module.IUQ
  , _ssOrigin = new three_module.IUQ
  , _ssOrigin3 = new three_module.Pq0
  , _mvMatrix = new three_module.kn4
  , _line = new three_module.cZY
  , _closestPoint = new three_module.Pq0
  , LineSegments2_box = new three_module.NRn
  , _sphere = new three_module.iyt
  , _clipToWorldVector = new three_module.IUQ;
let LineSegments2_ray, _lineWidth;
function getWorldSpaceHalfWidth(d, o, c) {
    return _clipToWorldVector.set(0, 0, -o, 1).applyMatrix4(d.projectionMatrix),
    _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w),
    _clipToWorldVector.x = _lineWidth / c.width,
    _clipToWorldVector.y = _lineWidth / c.height,
    _clipToWorldVector.applyMatrix4(d.projectionMatrixInverse),
    _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w),
    Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y))
}
function raycastWorldUnits(d, o) {
    const c = d.matrixWorld
      , h = d.geometry
      , _ = h.attributes.instanceStart
      , b = h.attributes.instanceEnd;
    for (let _e = 0, nt = Math.min(h.instanceCount, _.count); _e < nt; _e++) {
        _line.start.fromBufferAttribute(_, _e),
        _line.end.fromBufferAttribute(b, _e),
        _line.applyMatrix4(c);
        const it = new three_module.Pq0
          , at = new three_module.Pq0;
        LineSegments2_ray.distanceSqToSegment(_line.start, _line.end, at, it),
        at.distanceTo(it) < .5 * _lineWidth && o.push({
            point: at,
            pointOnLine: it,
            distance: LineSegments2_ray.origin.distanceTo(at),
            object: d,
            face: null,
            faceIndex: _e,
            uv: null,
            uv1: null
        })
    }
}
function raycastScreenSpace(d, o, c) {
    const h = o.projectionMatrix
      , _ = d.material.resolution
      , b = d.matrixWorld
      , _e = d.geometry
      , nt = _e.attributes.instanceStart
      , it = _e.attributes.instanceEnd
      , at = Math.min(_e.instanceCount, nt.count)
      , ut = -o.near;
    LineSegments2_ray.at(1, _ssOrigin),
    _ssOrigin.w = 1,
    _ssOrigin.applyMatrix4(o.matrixWorldInverse),
    _ssOrigin.applyMatrix4(h),
    _ssOrigin.multiplyScalar(1 / _ssOrigin.w),
    _ssOrigin.x *= _.x / 2,
    _ssOrigin.y *= _.y / 2,
    _ssOrigin.z = 0,
    _ssOrigin3.copy(_ssOrigin),
    _mvMatrix.multiplyMatrices(o.matrixWorldInverse, b);
    for (let pt = 0, ht = at; pt < ht; pt++) {
        if (_start4.fromBufferAttribute(nt, pt),
        _end4.fromBufferAttribute(it, pt),
        _start4.w = 1,
        _end4.w = 1,
        _start4.applyMatrix4(_mvMatrix),
        _end4.applyMatrix4(_mvMatrix),
        _start4.z > ut && _end4.z > ut)
            continue;
        if (_start4.z > ut) {
            const At = _start4.z - _end4.z
              , Et = (_start4.z - ut) / At;
            _start4.lerp(_end4, Et)
        } else if (_end4.z > ut) {
            const At = _end4.z - _start4.z
              , Et = (_end4.z - ut) / At;
            _end4.lerp(_start4, Et)
        }
        _start4.applyMatrix4(h),
        _end4.applyMatrix4(h),
        _start4.multiplyScalar(1 / _start4.w),
        _end4.multiplyScalar(1 / _end4.w),
        _start4.x *= _.x / 2,
        _start4.y *= _.y / 2,
        _end4.x *= _.x / 2,
        _end4.y *= _.y / 2,
        _line.start.copy(_start4),
        _line.start.z = 0,
        _line.end.copy(_end4),
        _line.end.z = 0;
        const _t = _line.closestPointToPointParameter(_ssOrigin3, !0);
        _line.at(_t, _closestPoint);
        const vt = three_module.cj9.lerp(_start4.z, _end4.z, _t)
          , bt = vt >= -1 && vt <= 1
          , St = _ssOrigin3.distanceTo(_closestPoint) < .5 * _lineWidth;
        if (bt && St) {
            _line.start.fromBufferAttribute(nt, pt),
            _line.end.fromBufferAttribute(it, pt),
            _line.start.applyMatrix4(b),
            _line.end.applyMatrix4(b);
            const At = new three_module.Pq0
              , Et = new three_module.Pq0;
            LineSegments2_ray.distanceSqToSegment(_line.start, _line.end, Et, At),
            c.push({
                point: Et,
                pointOnLine: At,
                distance: LineSegments2_ray.origin.distanceTo(Et),
                object: d,
                face: null,
                faceIndex: pt,
                uv: null,
                uv1: null
            })
        }
    }
}
class LineSegments2 extends three_module.eaF {
    constructor(o=new LineSegmentsGeometry, c=new LineMaterial({
        color: 16777215 * Math.random()
    })) {
        super(o, c),
        this.isLineSegments2 = !0,
        this.type = "LineSegments2"
    }
    computeLineDistances() {
        const o = this.geometry
          , c = o.attributes.instanceStart
          , h = o.attributes.instanceEnd
          , _ = new Float32Array(2 * c.count);
        for (let _e = 0, nt = 0, it = c.count; _e < it; _e++,
        nt += 2)
            LineSegments2_start.fromBufferAttribute(c, _e),
            LineSegments2_end.fromBufferAttribute(h, _e),
            _[nt] = nt === 0 ? 0 : _[nt - 1],
            _[nt + 1] = _[nt] + LineSegments2_start.distanceTo(LineSegments2_end);
        const b = new three_module.LuO(_,2,1);
        return o.setAttribute("instanceDistanceStart", new three_module.eHs(b,1,0)),
        o.setAttribute("instanceDistanceEnd", new three_module.eHs(b,1,1)),
        this
    }
    raycast(o, c) {
        const h = this.material.worldUnits
          , _ = o.camera;
        _ !== null || h || console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
        const b = o.params.Line2 !== void 0 && o.params.Line2.threshold || 0;
        LineSegments2_ray = o.ray;
        const _e = this.matrixWorld
          , nt = this.geometry
          , it = this.material;
        let at, ut;
        _lineWidth = it.linewidth + b,
        nt.boundingSphere === null && nt.computeBoundingSphere(),
        _sphere.copy(nt.boundingSphere).applyMatrix4(_e),
        at = h ? .5 * _lineWidth : getWorldSpaceHalfWidth(_, Math.max(_.near, _sphere.distanceToPoint(LineSegments2_ray.origin)), it.resolution),
        _sphere.radius += at,
        LineSegments2_ray.intersectsSphere(_sphere) !== !1 && (nt.boundingBox === null && nt.computeBoundingBox(),
        LineSegments2_box.copy(nt.boundingBox).applyMatrix4(_e),
        ut = h ? .5 * _lineWidth : getWorldSpaceHalfWidth(_, Math.max(_.near, LineSegments2_box.distanceToPoint(LineSegments2_ray.origin)), it.resolution),
        LineSegments2_box.expandByScalar(ut),
        LineSegments2_ray.intersectsBox(LineSegments2_box) !== !1 && (h ? raycastWorldUnits(this, c) : raycastScreenSpace(this, _, c)))
    }
}
class LineGeometry extends LineSegmentsGeometry {
    constructor() {
        super(),
        this.isLineGeometry = !0,
        this.type = "LineGeometry"
    }
    setPositions(o) {
        const c = o.length - 3
          , h = new Float32Array(2 * c);
        for (let _ = 0; _ < c; _ += 3)
            h[2 * _] = o[_],
            h[2 * _ + 1] = o[_ + 1],
            h[2 * _ + 2] = o[_ + 2],
            h[2 * _ + 3] = o[_ + 3],
            h[2 * _ + 4] = o[_ + 4],
            h[2 * _ + 5] = o[_ + 5];
        return super.setPositions(h),
        this
    }
    setColors(o) {
        const c = o.length - 3
          , h = new Float32Array(2 * c);
        for (let _ = 0; _ < c; _ += 3)
            h[2 * _] = o[_],
            h[2 * _ + 1] = o[_ + 1],
            h[2 * _ + 2] = o[_ + 2],
            h[2 * _ + 3] = o[_ + 3],
            h[2 * _ + 4] = o[_ + 4],
            h[2 * _ + 5] = o[_ + 5];
        return super.setColors(h),
        this
    }
    fromLine(o) {
        const c = o.geometry;
        return this.setPositions(c.attributes.position.array),
        this
    }
}
class Line2 extends LineSegments2 {
    constructor(o=new LineGeometry, c=new LineMaterial({
        color: 16777215 * Math.random()
    })) {
        super(o, c),
        this.isLine2 = !0,
        this.type = "Line2"
    }
}
class KTXLoader extends three_module.YRT {
    constructor(o) {
        super(o)
    }
    parse(o, c) {
        const h = new KhronosTextureContainer(o,1);
        return {
            mipmaps: h.mipmaps(c),
            width: h.pixelWidth,
            height: h.pixelHeight,
            format: h.glInternalFormat,
            isCubemap: h.numberOfFaces === 6,
            mipmapCount: h.numberOfMipmapLevels
        }
    }
}
const HEADER_LEN = 64
  , COMPRESSED_2D = 0;
class KhronosTextureContainer {
    constructor(o, c) {
        this.arrayBuffer = o;
        const h = new Uint8Array(this.arrayBuffer,0,12);
        if (h[0] !== 171 || h[1] !== 75 || h[2] !== 84 || h[3] !== 88 || h[4] !== 32 || h[5] !== 49 || h[6] !== 49 || h[7] !== 187 || h[8] !== 13 || h[9] !== 10 || h[10] !== 26 || h[11] !== 10)
            return void console.error("texture missing KTX identifier");
        const _ = Uint32Array.BYTES_PER_ELEMENT
          , b = new DataView(this.arrayBuffer,12,13 * _)
          , _e = b.getUint32(0, !0) === 67305985;
        this.glType = b.getUint32(1 * _, _e),
        this.glTypeSize = b.getUint32(2 * _, _e),
        this.glFormat = b.getUint32(3 * _, _e),
        this.glInternalFormat = b.getUint32(4 * _, _e),
        this.glBaseInternalFormat = b.getUint32(5 * _, _e),
        this.pixelWidth = b.getUint32(6 * _, _e),
        this.pixelHeight = b.getUint32(7 * _, _e),
        this.pixelDepth = b.getUint32(8 * _, _e),
        this.numberOfArrayElements = b.getUint32(9 * _, _e),
        this.numberOfFaces = b.getUint32(10 * _, _e),
        this.numberOfMipmapLevels = b.getUint32(11 * _, _e),
        this.bytesOfKeyValueData = b.getUint32(12 * _, _e),
        this.glType === 0 ? (this.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels),
        this.pixelHeight !== 0 && this.pixelDepth === 0 ? this.numberOfArrayElements === 0 ? this.numberOfFaces === c ? this.loadType = COMPRESSED_2D : console.warn("number of faces expected" + c + ", but found " + this.numberOfFaces) : console.warn("texture arrays not currently supported") : console.warn("only 2D textures currently supported")) : console.warn("only compressed formats currently supported")
    }
    mipmaps(o) {
        const c = [];
        let h = HEADER_LEN + this.bytesOfKeyValueData
          , _ = this.pixelWidth
          , b = this.pixelHeight;
        const _e = o ? this.numberOfMipmapLevels : 1;
        for (let nt = 0; nt < _e; nt++) {
            const it = new Int32Array(this.arrayBuffer,h,1)[0];
            h += 4;
            for (let at = 0; at < this.numberOfFaces; at++) {
                const ut = new Uint8Array(this.arrayBuffer,h,it);
                c.push({
                    data: ut,
                    width: _,
                    height: b
                }),
                h += it,
                h += 3 - (it + 3) % 4
            }
            _ = Math.max(1, .5 * _),
            b = Math.max(1, .5 * b)
        }
        return c
    }
}
class KTXLoadPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin]
    }
    async onAdded(o) {
        var c, h;
        this._importer || (this._importer = new Importer(KTXLoader,["ktx"],!1)),
        (h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.Importers.push(this._importer)
    }
    async onDispose(o) {
        this._importer = void 0
    }
    async onRemove(o) {
        var c, h;
        this._importer && (!((h = (c = o.getManager()) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0) && h.Importers) && o.getManager().importer.Importers.splice(o.getManager().importer.Importers.indexOf(this._importer), 1),
        this._importer = void 0
    }
}
KTXLoadPlugin.PluginType = "KTXLoadPlugin";
class BlobLoader extends three_module.Y9S {
    constructor(o) {
        super(o),
        this.responseType = "blob"
    }
}
class DataUrlLoader extends three_module.Y9S {
    constructor(o) {
        super(o),
        this.responseType = "blob"
    }
    load(o, c, h, _) {
        return super.load(o, b => {
            try {
                c == null || c(q$2(b))
            } catch (_e) {
                _ == null || _(_e)
            }
        }
        , h, _)
    }
}
class SimpleJSONExporter {
    async parseAsync(o, c) {
        var h;
        return new Blob([JSON.stringify(o, null, (h = c.jsonSpaces) !== null && h !== void 0 ? h : 2)],{
            type: "application/json"
        })
    }
}
class SimpleTextExporter {
    async parseAsync(o, c) {
        return new Blob([o],{
            type: "text/plain"
        })
    }
}
let _renderer, fullscreenQuadGeometry, fullscreenQuadMaterial, fullscreenQuad;
function TextureUtils_decompress(d, o=1 / 0, c=null) {
    fullscreenQuadGeometry || (fullscreenQuadGeometry = new three_module.bdM(2,2,1,1)),
    fullscreenQuadMaterial || (fullscreenQuadMaterial = new three_module.BKk({
        uniforms: {
            blitTexture: new three_module.nc$(d)
        },
        vertexShader: `
            varying vec2 vUv;
            void main(){
                vUv = uv;
                gl_Position = vec4(position.xy * 1.0,0.,.999999);
            }`,
        fragmentShader: `
            uniform sampler2D blitTexture; 
            varying vec2 vUv;

            void main(){ 
                gl_FragColor = vec4(vUv.xy, 0, 1);
                
                #ifdef IS_SRGB
                gl_FragColor = LinearTosRGB( texture2D( blitTexture, vUv) );
                #else
                gl_FragColor = texture2D( blitTexture, vUv);
                #endif
            }`
    })),
    fullscreenQuadMaterial.uniforms.blitTexture.value = d,
    fullscreenQuadMaterial.defines.IS_SRGB = d.colorSpace == three_module.er$,
    fullscreenQuadMaterial.needsUpdate = !0,
    fullscreenQuad || (fullscreenQuad = new three_module.eaF(fullscreenQuadGeometry,fullscreenQuadMaterial),
    fullscreenQuad.frustrumCulled = !1);
    const h = new three_module.ubm
      , _ = new three_module.Z58;
    _.add(fullscreenQuad),
    c || (c = _renderer = new three_module.JeP({
        antialias: !1
    })),
    c.setSize(Math.min(d.image.width, o), Math.min(d.image.height, o)),
    c.clear(),
    c.render(_, h);
    const b = new three_module.gPd(c.domElement);
    return b.minFilter = d.minFilter,
    b.magFilter = d.magFilter,
    b.wrapS = d.wrapS,
    b.wrapT = d.wrapT,
    b.name = d.name,
    _renderer && (_renderer.dispose(),
    _renderer = null),
    b
}
const KHR_mesh_quantization_ExtraAttrTypes = {
    POSITION: ["byte", "byte normalized", "unsigned byte", "unsigned byte normalized", "short", "short normalized", "unsigned short", "unsigned short normalized"],
    NORMAL: ["byte normalized", "short normalized"],
    TANGENT: ["byte normalized", "short normalized"],
    TEXCOORD: ["byte", "byte normalized", "unsigned byte", "short", "short normalized", "unsigned short"]
};
class GLTFExporter {
    constructor() {
        this.pluginCallbacks = [],
        this.register(function(o) {
            return new GLTFLightExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsUnlitExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsTransmissionExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsVolumeExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsIorExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsSpecularExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsClearcoatExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsIridescenceExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsSheenExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsAnisotropyExtension(o)
        }),
        this.register(function(o) {
            return new GLTFExporter_GLTFMaterialsEmissiveStrengthExtension(o)
        })
    }
    register(o) {
        return this.pluginCallbacks.indexOf(o) === -1 && this.pluginCallbacks.push(o),
        this
    }
    unregister(o) {
        return this.pluginCallbacks.indexOf(o) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(o), 1),
        this
    }
    parse(o, c, h, _, b) {
        const _e = b || new GLTFWriter
          , nt = [];
        for (let it = 0, at = this.pluginCallbacks.length; it < at; it++)
            nt.push(this.pluginCallbacks[it](_e));
        _e.setPlugins(nt),
        _e.write(o, c, _).catch(h)
    }
    parseAsync(o, c) {
        const h = this;
        return new Promise(function(_, b) {
            h.parse(o, _, b, c)
        }
        )
    }
}
const GLTFExporter_WEBGL_CONSTANTS = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    ARRAY_BUFFER: 34962,
    ELEMENT_ARRAY_BUFFER: 34963,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
}
  , KHR_MESH_QUANTIZATION = "KHR_mesh_quantization"
  , THREE_TO_WEBGL = {};
THREE_TO_WEBGL[three_module.hxR] = GLTFExporter_WEBGL_CONSTANTS.NEAREST,
THREE_TO_WEBGL[three_module.pHI] = GLTFExporter_WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,
THREE_TO_WEBGL[three_module.Cfg] = GLTFExporter_WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,
THREE_TO_WEBGL[three_module.k6q] = GLTFExporter_WEBGL_CONSTANTS.LINEAR,
THREE_TO_WEBGL[three_module.kRr] = GLTFExporter_WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,
THREE_TO_WEBGL[three_module.$_I] = GLTFExporter_WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR,
THREE_TO_WEBGL[three_module.ghU] = GLTFExporter_WEBGL_CONSTANTS.CLAMP_TO_EDGE,
THREE_TO_WEBGL[three_module.GJx] = GLTFExporter_WEBGL_CONSTANTS.REPEAT,
THREE_TO_WEBGL[three_module.kTW] = GLTFExporter_WEBGL_CONSTANTS.MIRRORED_REPEAT;
const GLTFExporter_PATH_PROPERTIES = {
    scale: "scale",
    position: "translation",
    quaternion: "rotation",
    morphTargetInfluences: "weights"
}
  , DEFAULT_SPECULAR_COLOR = new three_module.Q1f
  , GLB_HEADER_BYTES = 12
  , GLB_HEADER_MAGIC = 1179937895
  , GLB_VERSION = 2
  , GLB_CHUNK_PREFIX_BYTES = 8
  , GLB_CHUNK_TYPE_JSON = 1313821514
  , GLB_CHUNK_TYPE_BIN = 5130562;
function equalArray(d, o) {
    return d.length === o.length && d.every(function(c, h) {
        return c === o[h]
    })
}
function stringToArrayBuffer(d) {
    return new TextEncoder().encode(d).buffer
}
function isIdentityMatrix(d) {
    return equalArray(d.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
}
function getMinMax(d, o, c) {
    const h = {
        min: new Array(d.itemSize).fill(Number.POSITIVE_INFINITY),
        max: new Array(d.itemSize).fill(Number.NEGATIVE_INFINITY)
    };
    for (let _ = o; _ < o + c; _++)
        for (let b = 0; b < d.itemSize; b++) {
            let _e;
            d.itemSize > 4 ? _e = d.array[_ * d.itemSize + b] : (b === 0 ? _e = d.getX(_) : b === 1 ? _e = d.getY(_) : b === 2 ? _e = d.getZ(_) : b === 3 && (_e = d.getW(_)),
            d.normalized === !0 && (_e = three_module.cj9.normalize(_e, d.array))),
            h.min[b] = Math.min(h.min[b], _e),
            h.max[b] = Math.max(h.max[b], _e)
        }
    return h
}
function getPaddedBufferSize(d) {
    return 4 * Math.ceil(d / 4)
}
function getPaddedArrayBuffer(d, o=0) {
    const c = getPaddedBufferSize(d.byteLength);
    if (c !== d.byteLength) {
        const h = new Uint8Array(c);
        if (h.set(new Uint8Array(d)),
        o !== 0)
            for (let _ = d.byteLength; _ < c; _++)
                h[_] = o;
        return h.buffer
    }
    return d
}
function getCanvas() {
    return typeof document > "u" && typeof OffscreenCanvas < "u" ? new OffscreenCanvas(1,1) : document.createElement("canvas")
}
function getToBlobPromise(d, o) {
    if (d.toBlob !== void 0)
        return new Promise(h => d.toBlob(h, o));
    let c;
    return o === "image/jpeg" ? c = .92 : o === "image/webp" && (c = .8),
    d.convertToBlob({
        type: o,
        quality: c
    })
}
class GLTFWriter {
    constructor() {
        this.plugins = [],
        this.options = {},
        this.pending = [],
        this.buffers = [],
        this.byteOffset = 0,
        this.buffers = [],
        this.nodeMap = new Map,
        this.skins = [],
        this.extensionsUsed = {},
        this.extensionsRequired = {},
        this.uids = new Map,
        this.uid = 0,
        this.json = {
            asset: {
                version: "2.0",
                generator: "THREE.GLTFExporter"
            }
        },
        this.cache = {
            meshes: new Map,
            attributes: new Map,
            attributesNormalized: new Map,
            materials: new Map,
            textures: new Map,
            images: new Map
        }
    }
    setPlugins(o) {
        this.plugins = o
    }
    async write(o, c, h={}) {
        this.options = Object.assign({
            binary: !1,
            trs: !1,
            onlyVisible: !0,
            maxTextureSize: 1 / 0,
            animations: [],
            includeCustomExtensions: !1,
            ignoreInvalidMorphTargetTracks: !1,
            ignoreEmptyTextures: !1
        }, h),
        this.options.animations.length > 0 && (this.options.trs = !0),
        this.processInput(o),
        await Promise.all(this.pending);
        const _ = this
          , b = _.buffers
          , _e = _.json;
        h = _.options;
        const nt = _.extensionsUsed
          , it = _.extensionsRequired
          , at = new Blob(b,{
            type: "application/octet-stream"
        })
          , ut = Object.keys(nt)
          , pt = Object.keys(it);
        if (ut.length > 0 && (_e.extensionsUsed = ut),
        pt.length > 0 && (_e.extensionsRequired = pt),
        _e.buffers && _e.buffers.length > 0 && (_e.buffers[0].byteLength = at.size),
        h.binary === !0) {
            const ht = new FileReader;
            ht.readAsArrayBuffer(at),
            ht.onloadend = function() {
                const _t = getPaddedArrayBuffer(ht.result)
                  , vt = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
                vt.setUint32(0, _t.byteLength, !0),
                vt.setUint32(4, GLB_CHUNK_TYPE_BIN, !0);
                const bt = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(_e)), 32)
                  , St = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));
                St.setUint32(0, bt.byteLength, !0),
                St.setUint32(4, GLB_CHUNK_TYPE_JSON, !0);
                const At = new ArrayBuffer(GLB_HEADER_BYTES)
                  , Et = new DataView(At);
                Et.setUint32(0, GLB_HEADER_MAGIC, !0),
                Et.setUint32(4, GLB_VERSION, !0);
                const Pt = GLB_HEADER_BYTES + St.byteLength + bt.byteLength + vt.byteLength + _t.byteLength;
                Et.setUint32(8, Pt, !0);
                const It = new Blob([At, St, bt, vt, _t],{
                    type: "application/octet-stream"
                })
                  , Dt = new FileReader;
                Dt.readAsArrayBuffer(It),
                Dt.onloadend = function() {
                    c(Dt.result)
                }
            }
        } else if (_e.buffers && _e.buffers.length > 0) {
            const ht = new FileReader;
            ht.readAsDataURL(at),
            ht.onloadend = function() {
                const _t = ht.result;
                _e.buffers[0].uri = _t,
                c(_e)
            }
        } else
            c(_e)
    }
    serializeUserData(o, c) {
        if (Object.keys(o.userData).length === 0)
            return;
        const h = this.options
          , _ = this.extensionsUsed;
        try {
            const b = JSON.parse(JSON.stringify(o.userData));
            if (h.includeCustomExtensions && b.gltfExtensions) {
                c.extensions === void 0 && (c.extensions = {});
                for (const _e in b.gltfExtensions)
                    c.extensions[_e] = b.gltfExtensions[_e],
                    _[_e] = !0;
                delete b.gltfExtensions
            }
            Object.keys(b).length > 0 && (c.extras = b)
        } catch (b) {
            console.warn("THREE.GLTFExporter: userData of '" + o.name + "' won't be serialized because of JSON.stringify error - " + b.message),
            console.warn({
                ...o.userData
            })
        }
    }
    getUID(o, c=!1) {
        if (this.uids.has(o) === !1) {
            const h = new Map;
            h.set(!0, this.uid++),
            h.set(!1, this.uid++),
            this.uids.set(o, h)
        }
        return this.uids.get(o).get(c)
    }
    isNormalizedNormalAttribute(o) {
        if (this.cache.attributesNormalized.has(o))
            return !1;
        const c = new three_module.Pq0;
        for (let h = 0, _ = o.count; h < _; h++)
            if (Math.abs(c.fromBufferAttribute(o, h).length() - 1) > 5e-4)
                return !1;
        return !0
    }
    createNormalizedNormalAttribute(o) {
        const c = this.cache;
        if (c.attributesNormalized.has(o))
            return c.attributesNormalized.get(o);
        const h = o.clone()
          , _ = new three_module.Pq0;
        for (let b = 0, _e = h.count; b < _e; b++)
            _.fromBufferAttribute(h, b),
            _.x === 0 && _.y === 0 && _.z === 0 ? _.setX(1) : _.normalize(),
            h.setXYZ(b, _.x, _.y, _.z);
        return c.attributesNormalized.set(o, h),
        h
    }
    applyTextureTransform(o, c) {
        let h = !1;
        const _ = {};
        c.offset.x === 0 && c.offset.y === 0 || (_.offset = c.offset.toArray(),
        h = !0),
        c.rotation !== 0 && (_.rotation = c.rotation,
        h = !0),
        c.repeat.x === 1 && c.repeat.y === 1 || (_.scale = c.repeat.toArray(),
        h = !0),
        h && (o.extensions = o.extensions || {},
        o.extensions.KHR_texture_transform = _,
        this.extensionsUsed.KHR_texture_transform = !0)
    }
    buildMetalRoughTexture(o, c) {
        if (o === c)
            return o;
        function h(ht) {
            return ht.colorSpace === three_module.er$ ? function(_t) {
                return _t < .04045 ? .0773993808 * _t : Math.pow(.9478672986 * _t + .0521327014, 2.4)
            }
            : function(_t) {
                return _t
            }
        }
        console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),
        o instanceof three_module.FvD && (o = TextureUtils_decompress(o)),
        c instanceof three_module.FvD && (c = TextureUtils_decompress(c));
        const _ = o ? o.image : null
          , b = c ? c.image : null
          , _e = Math.max(_ ? _.width : 0, b ? b.width : 0)
          , nt = Math.max(_ ? _.height : 0, b ? b.height : 0)
          , it = getCanvas();
        it.width = _e,
        it.height = nt;
        const at = it.getContext("2d");
        at.fillStyle = "#00ffff",
        at.fillRect(0, 0, _e, nt);
        const ut = at.getImageData(0, 0, _e, nt);
        if (_) {
            at.drawImage(_, 0, 0, _e, nt);
            const ht = h(o)
              , _t = at.getImageData(0, 0, _e, nt).data;
            for (let vt = 2; vt < _t.length; vt += 4)
                ut.data[vt] = 256 * ht(_t[vt] / 256)
        }
        if (b) {
            at.drawImage(b, 0, 0, _e, nt);
            const ht = h(c)
              , _t = at.getImageData(0, 0, _e, nt).data;
            for (let vt = 1; vt < _t.length; vt += 4)
                ut.data[vt] = 256 * ht(_t[vt] / 256)
        }
        at.putImageData(ut, 0, 0);
        const pt = (o || c).clone();
        return pt.source = new three_module.kLi(it),
        pt.colorSpace = three_module.jf0,
        pt.channel = (o || c).channel,
        o && c && o.channel !== c.channel && console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),
        pt
    }
    processBuffer(o) {
        const c = this.json
          , h = this.buffers;
        return c.buffers || (c.buffers = [{
            byteLength: 0
        }]),
        h.push(o),
        0
    }
    processBufferView(o, c, h, _, b) {
        const _e = this.json;
        let nt;
        switch (_e.bufferViews || (_e.bufferViews = []),
        c) {
        case GLTFExporter_WEBGL_CONSTANTS.BYTE:
        case GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_BYTE:
            nt = 1;
            break;
        case GLTFExporter_WEBGL_CONSTANTS.SHORT:
        case GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_SHORT:
            nt = 2;
            break;
        default:
            nt = 4
        }
        const it = getPaddedBufferSize(_ * o.itemSize * nt)
          , at = new DataView(new ArrayBuffer(it));
        let ut = 0;
        for (let ht = h; ht < h + _; ht++)
            for (let _t = 0; _t < o.itemSize; _t++) {
                let vt;
                o.itemSize > 4 ? vt = o.array[ht * o.itemSize + _t] : (_t === 0 ? vt = o.getX(ht) : _t === 1 ? vt = o.getY(ht) : _t === 2 ? vt = o.getZ(ht) : _t === 3 && (vt = o.getW(ht)),
                o.normalized === !0 && (vt = three_module.cj9.normalize(vt, o.array))),
                c === GLTFExporter_WEBGL_CONSTANTS.FLOAT ? at.setFloat32(ut, vt, !0) : c === GLTFExporter_WEBGL_CONSTANTS.INT ? at.setInt32(ut, vt, !0) : c === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_INT ? at.setUint32(ut, vt, !0) : c === GLTFExporter_WEBGL_CONSTANTS.SHORT ? at.setInt16(ut, vt, !0) : c === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_SHORT ? at.setUint16(ut, vt, !0) : c === GLTFExporter_WEBGL_CONSTANTS.BYTE ? at.setInt8(ut, vt) : c === GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_BYTE && at.setUint8(ut, vt),
                ut += nt
            }
        const pt = {
            buffer: this.processBuffer(at.buffer),
            byteOffset: this.byteOffset,
            byteLength: it
        };
        return b !== void 0 && (pt.target = b),
        b === GLTFExporter_WEBGL_CONSTANTS.ARRAY_BUFFER && (pt.byteStride = o.itemSize * nt),
        this.byteOffset += it,
        _e.bufferViews.push(pt),
        {
            id: _e.bufferViews.length - 1,
            byteLength: 0
        }
    }
    processBufferViewImage(o) {
        const c = this
          , h = c.json;
        return h.bufferViews || (h.bufferViews = []),
        new Promise(function(_) {
            const b = new FileReader;
            b.readAsArrayBuffer(o),
            b.onloadend = function() {
                const _e = getPaddedArrayBuffer(b.result)
                  , nt = {
                    buffer: c.processBuffer(_e),
                    byteOffset: c.byteOffset,
                    byteLength: _e.byteLength
                };
                c.byteOffset += _e.byteLength,
                _(h.bufferViews.push(nt) - 1)
            }
        }
        )
    }
    processBufferViewImageBuffer(o) {
        const c = this
          , h = c.json;
        h.bufferViews || (h.bufferViews = []),
        o = getPaddedArrayBuffer(o);
        const _ = {
            buffer: c.processBuffer(o),
            byteOffset: c.byteOffset,
            byteLength: o.byteLength
        };
        return c.byteOffset += o.byteLength,
        h.bufferViews.push(_) - 1
    }
    processAccessor(o, c, h, _) {
        const b = this.json;
        let _e;
        if (o.array.constructor === Float32Array)
            _e = GLTFExporter_WEBGL_CONSTANTS.FLOAT;
        else if (o.array.constructor === Int32Array)
            _e = GLTFExporter_WEBGL_CONSTANTS.INT;
        else if (o.array.constructor === Uint32Array)
            _e = GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_INT;
        else if (o.array.constructor === Int16Array)
            _e = GLTFExporter_WEBGL_CONSTANTS.SHORT;
        else if (o.array.constructor === Uint16Array)
            _e = GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_SHORT;
        else if (o.array.constructor === Int8Array)
            _e = GLTFExporter_WEBGL_CONSTANTS.BYTE;
        else {
            if (o.array.constructor !== Uint8Array)
                throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: " + o.array.constructor.name);
            _e = GLTFExporter_WEBGL_CONSTANTS.UNSIGNED_BYTE
        }
        if (h === void 0 && (h = 0),
        _ === void 0 && (_ = o.count),
        _ === 0)
            return null;
        const nt = getMinMax(o, h, _);
        let it;
        c !== void 0 && (it = o === c.index ? GLTFExporter_WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : GLTFExporter_WEBGL_CONSTANTS.ARRAY_BUFFER);
        const at = this.processBufferView(o, _e, h, _, it)
          , ut = {
            bufferView: at.id,
            byteOffset: at.byteOffset,
            componentType: _e,
            count: _,
            max: nt.max,
            min: nt.min,
            type: {
                1: "SCALAR",
                2: "VEC2",
                3: "VEC3",
                4: "VEC4",
                9: "MAT3",
                16: "MAT4"
            }[o.itemSize]
        };
        return o.normalized === !0 && (ut.normalized = !0),
        b.accessors || (b.accessors = []),
        b.accessors.push(ut) - 1
    }
    processImage(o, c, h, _="image/png", b=void 0, _e=void 0) {
        if (o !== null) {
            const nt = this
              , it = nt.cache
              , at = nt.json
              , ut = nt.options
              , pt = nt.pending;
            it.images.has(o) || it.images.set(o, {});
            const ht = it.images.get(o)
              , _t = _ + ":flipY/" + h.toString() + (b || _e ? ";" + b + ";" + _e : "");
            if (ht[_t] !== void 0)
                return ht[_t];
            at.images || (at.images = []);
            const vt = {
                mimeType: _
            }
              , bt = getCanvas();
            bt.width = Math.min(b || o.width, ut.maxTextureSize),
            bt.height = Math.min(_e || o.height, ut.maxTextureSize);
            const St = bt.getContext("2d");
            if (h === !0 && (St.translate(0, bt.height),
            St.scale(1, -1)),
            o.data !== void 0) {
                c !== three_module.GWd && console.error("GLTFExporter: Only RGBAFormat is supported.", c),
                (o.width > ut.maxTextureSize || o.height > ut.maxTextureSize) && console.warn("GLTFExporter: Image size is bigger than maxTextureSize", o);
                const Et = new Uint8ClampedArray(o.height * o.width * 4);
                for (let Pt = 0; Pt < Et.length; Pt += 4)
                    Et[Pt + 0] = o.data[Pt + 0],
                    Et[Pt + 1] = o.data[Pt + 1],
                    Et[Pt + 2] = o.data[Pt + 2],
                    Et[Pt + 3] = o.data[Pt + 3];
                St.putImageData(new ImageData(Et,o.width,o.height), 0, 0)
            } else
                St.drawImage(o, 0, 0, bt.width, bt.height);
            ut.binary === !0 ? pt.push(getToBlobPromise(bt, _).then(Et => nt.processBufferViewImage(Et)).then(Et => {
                vt.bufferView = Et
            }
            )) : bt.toDataURL !== void 0 ? vt.uri = bt.toDataURL(_) : pt.push(getToBlobPromise(bt, _).then(Et => new FileReader().readAsDataURL(Et)).then(Et => {
                vt.uri = Et
            }
            ));
            const At = at.images.push(vt) - 1;
            return ht[_t] = At,
            At
        }
        throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")
    }
    processSampler(o) {
        const c = this.json;
        c.samplers || (c.samplers = []);
        const h = {
            magFilter: THREE_TO_WEBGL[o.magFilter],
            minFilter: THREE_TO_WEBGL[o.minFilter],
            wrapS: THREE_TO_WEBGL[o.wrapS],
            wrapT: THREE_TO_WEBGL[o.wrapT]
        };
        return c.samplers.push(h) - 1
    }
    processTexture(o) {
        const c = this.options
          , h = this.cache
          , _ = this.json;
        if (h.textures.has(o))
            return h.textures.get(o);
        _.textures || (_.textures = []),
        o instanceof three_module.FvD && !o.source._canSerialize && (o = TextureUtils_decompress(o, c.maxTextureSize));
        let b = o.userData.mimeType;
        b === "image/webp" && (b = "image/png"),
        b === "image/jpg" && (b = "image/jpeg");
        const _e = {
            sampler: this.processSampler(o),
            source: !b || ["image/jpeg", "image/png"].includes(b) ? this.processImage(o.image, o.format, o.flipY, b) : null
        };
        o.name && (_e.name = o.name),
        this._invokeAll(function(it) {
            it.writeTexture && it.writeTexture(o, _e)
        }),
        _e.source === null && console.error("GLTFExporter: Unsupported mime type: " + b + ". Cannot export texture.", o);
        const nt = _.textures.push(_e) - 1;
        return h.textures.set(o, nt),
        nt
    }
    processMaterial(o) {
        const c = this.cache
          , h = this.json;
        if (c.materials.has(o))
            return c.materials.get(o);
        if (o.isShaderMaterial)
            return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),
            null;
        h.materials || (h.materials = []);
        const _ = {
            pbrMetallicRoughness: {}
        };
        o.isMeshStandardMaterial !== !0 && o.isMeshBasicMaterial !== !0 && console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");
        const b = o.color.toArray().concat([o.opacity]);
        if (equalArray(b, [1, 1, 1, 1]) || (_.pbrMetallicRoughness.baseColorFactor = b),
        o.isMeshStandardMaterial ? (_.pbrMetallicRoughness.metallicFactor = o.metalness,
        _.pbrMetallicRoughness.roughnessFactor = o.roughness) : (_.pbrMetallicRoughness.metallicFactor = .5,
        _.pbrMetallicRoughness.roughnessFactor = .5),
        this.checkEmptyMap(o.metalnessMap) || this.checkEmptyMap(o.roughnessMap)) {
            const nt = this.buildMetalRoughTexture(o.metalnessMap, o.roughnessMap)
              , it = {
                index: this.processTexture(nt),
                channel: nt.channel
            };
            this.applyTextureTransform(it, nt),
            _.pbrMetallicRoughness.metallicRoughnessTexture = it
        }
        if (this.checkEmptyMap(o.map)) {
            const nt = {
                index: this.processTexture(o.map),
                texCoord: o.map.channel
            };
            this.applyTextureTransform(nt, o.map),
            _.pbrMetallicRoughness.baseColorTexture = nt
        }
        if (o.emissive) {
            const nt = o.emissive;
            if (Math.max(nt.r, nt.g, nt.b) > 0 && (_.emissiveFactor = o.emissive.toArray()),
            this.checkEmptyMap(o.emissiveMap)) {
                const it = {
                    index: this.processTexture(o.emissiveMap),
                    texCoord: o.emissiveMap.channel
                };
                this.applyTextureTransform(it, o.emissiveMap),
                _.emissiveTexture = it
            }
        }
        if (this.checkEmptyMap(o.normalMap)) {
            const nt = {
                index: this.processTexture(o.normalMap),
                texCoord: o.normalMap.channel
            };
            o.normalScale && o.normalScale.x !== 1 && (nt.scale = o.normalScale.x),
            this.applyTextureTransform(nt, o.normalMap),
            _.normalTexture = nt
        }
        if (this.checkEmptyMap(o.aoMap)) {
            const nt = {
                index: this.processTexture(o.aoMap),
                texCoord: o.aoMap.channel
            };
            o.aoMapIntensity !== 1 && (nt.strength = o.aoMapIntensity),
            this.applyTextureTransform(nt, o.aoMap),
            _.occlusionTexture = nt
        }
        o.transparent ? _.alphaMode = "BLEND" : o.alphaTest > 0 && (_.alphaMode = "MASK",
        _.alphaCutoff = o.alphaTest),
        o.side === three_module.$EB && (_.doubleSided = !0),
        o.name !== "" && (_.name = o.name),
        this.serializeUserData(o, _),
        this._invokeAll(function(nt) {
            nt.writeMaterial && nt.writeMaterial(o, _)
        });
        const _e = h.materials.push(_) - 1;
        return c.materials.set(o, _e),
        _e
    }
    processMesh(o) {
        const c = this.cache
          , h = this.json
          , _ = [o.geometry.uuid];
        if (Array.isArray(o.material))
            for (let Pt = 0, It = o.material.length; Pt < It; Pt++)
                _.push(o.material[Pt].uuid);
        else
            _.push(o.material.uuid);
        const b = _.join(":");
        if (c.meshes.has(b))
            return c.meshes.get(b);
        const _e = o.geometry;
        let nt;
        nt = o.isLineSegments ? GLTFExporter_WEBGL_CONSTANTS.LINES : o.isLineLoop ? GLTFExporter_WEBGL_CONSTANTS.LINE_LOOP : o.isLine ? GLTFExporter_WEBGL_CONSTANTS.LINE_STRIP : o.isPoints ? GLTFExporter_WEBGL_CONSTANTS.POINTS : o.material.wireframe ? GLTFExporter_WEBGL_CONSTANTS.LINES : GLTFExporter_WEBGL_CONSTANTS.TRIANGLES;
        const it = {}
          , at = {}
          , ut = []
          , pt = []
          , ht = {
            uv: "TEXCOORD_0",
            uv1: "TEXCOORD_1",
            color: "COLOR_0",
            skinWeight: "WEIGHTS_0",
            skinIndex: "JOINTS_0"
        }
          , _t = _e.getAttribute("normal");
        _t === void 0 || this.isNormalizedNormalAttribute(_t) || (console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),
        _e.setAttribute("normal", this.createNormalizedNormalAttribute(_t)));
        let vt = null;
        for (let Pt in _e.attributes) {
            if (Pt.slice(0, 5) === "morph")
                continue;
            const It = _e.attributes[Pt];
            if (Pt = ht[Pt] || Pt.toUpperCase(),
            /^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(Pt) || (Pt = "_" + Pt),
            c.attributes.has(this.getUID(It))) {
                at[Pt] = c.attributes.get(this.getUID(It));
                continue
            }
            vt = null;
            const Dt = It.array;
            Pt !== "JOINTS_0" || Dt instanceof Uint16Array || Dt instanceof Uint8Array || (console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),
            vt = new three_module.THS(new Uint16Array(Dt),It.itemSize,It.normalized));
            const Gt = this.processAccessor(vt || It, _e);
            Gt !== null && (Pt.startsWith("_") || this.detectMeshQuantization(Pt, It),
            at[Pt] = Gt,
            c.attributes.set(this.getUID(It), Gt))
        }
        if (_t !== void 0 && _e.setAttribute("normal", _t),
        Object.keys(at).length === 0)
            return null;
        if (o.morphTargetInfluences !== void 0 && o.morphTargetInfluences.length > 0) {
            const Pt = []
              , It = []
              , Dt = {};
            if (o.morphTargetDictionary !== void 0)
                for (const Gt in o.morphTargetDictionary)
                    Dt[o.morphTargetDictionary[Gt]] = Gt;
            for (let Gt = 0; Gt < o.morphTargetInfluences.length; ++Gt) {
                const Bt = {};
                let kt = !1;
                for (const Ut in _e.morphAttributes) {
                    if (Ut !== "position" && Ut !== "normal") {
                        kt || (console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),
                        kt = !0);
                        continue
                    }
                    const Ht = _e.morphAttributes[Ut][Gt]
                      , Kt = Ut.toUpperCase()
                      , Jt = _e.attributes[Ut];
                    if (c.attributes.has(this.getUID(Ht, !0))) {
                        Bt[Kt] = c.attributes.get(this.getUID(Ht, !0));
                        continue
                    }
                    const or = Ht.clone();
                    if (!_e.morphTargetsRelative)
                        for (let ir = 0, lr = Ht.count; ir < lr; ir++)
                            for (let ar = 0; ar < Ht.itemSize; ar++)
                                ar === 0 && or.setX(ir, Ht.getX(ir) - Jt.getX(ir)),
                                ar === 1 && or.setY(ir, Ht.getY(ir) - Jt.getY(ir)),
                                ar === 2 && or.setZ(ir, Ht.getZ(ir) - Jt.getZ(ir)),
                                ar === 3 && or.setW(ir, Ht.getW(ir) - Jt.getW(ir));
                    Bt[Kt] = this.processAccessor(or, _e),
                    c.attributes.set(this.getUID(Jt, !0), Bt[Kt])
                }
                pt.push(Bt),
                Pt.push(o.morphTargetInfluences[Gt]),
                o.morphTargetDictionary !== void 0 && It.push(Dt[Gt])
            }
            it.weights = Pt,
            It.length > 0 && (it.extras = {},
            it.extras.targetNames = It)
        }
        const bt = Array.isArray(o.material);
        if (bt && _e.groups.length === 0)
            return null;
        const St = bt ? o.material : [o.material]
          , At = bt ? _e.groups : [{
            materialIndex: 0,
            start: void 0,
            count: void 0
        }];
        for (let Pt = 0, It = At.length; Pt < It; Pt++) {
            const Dt = {
                mode: nt,
                attributes: at
            };
            if (this.serializeUserData(_e, Dt),
            pt.length > 0 && (Dt.targets = pt),
            _e.index !== null) {
                let Bt = this.getUID(_e.index);
                At[Pt].start === void 0 && At[Pt].count === void 0 || (Bt += ":" + At[Pt].start + ":" + At[Pt].count),
                c.attributes.has(Bt) ? Dt.indices = c.attributes.get(Bt) : (Dt.indices = this.processAccessor(_e.index, _e, At[Pt].start, At[Pt].count),
                c.attributes.set(Bt, Dt.indices)),
                Dt.indices === null && delete Dt.indices
            }
            const Gt = this.processMaterial(St[At[Pt].materialIndex]);
            Gt !== null && (Dt.material = Gt),
            ut.push(Dt)
        }
        it.primitives = ut,
        h.meshes || (h.meshes = []),
        this._invokeAll(function(Pt) {
            Pt.writeMesh && Pt.writeMesh(o, it)
        });
        const Et = h.meshes.push(it) - 1;
        return c.meshes.set(b, Et),
        Et
    }
    detectMeshQuantization(o, c) {
        if (this.extensionsUsed[KHR_MESH_QUANTIZATION])
            return;
        let h;
        switch (c.array.constructor) {
        case Int8Array:
            h = "byte";
            break;
        case Uint8Array:
            h = "unsigned byte";
            break;
        case Int16Array:
            h = "short";
            break;
        case Uint16Array:
            h = "unsigned short";
            break;
        default:
            return
        }
        c.normalized && (h += " normalized");
        const _ = o.split("_", 1)[0];
        KHR_mesh_quantization_ExtraAttrTypes[_] && KHR_mesh_quantization_ExtraAttrTypes[_].includes(h) && (this.extensionsUsed[KHR_MESH_QUANTIZATION] = !0,
        this.extensionsRequired[KHR_MESH_QUANTIZATION] = !0)
    }
    processCamera(o) {
        const c = this.json;
        c.cameras || (c.cameras = []);
        const h = o.isOrthographicCamera
          , _ = {
            type: h ? "orthographic" : "perspective"
        };
        return h ? _.orthographic = {
            xmag: 2 * o.right,
            ymag: 2 * o.top,
            zfar: o.far <= 0 ? .001 : o.far,
            znear: o.near < 0 ? 0 : o.near
        } : _.perspective = {
            aspectRatio: o.aspect,
            yfov: three_module.cj9.degToRad(o.fov),
            zfar: o.far <= 0 ? .001 : o.far,
            znear: o.near < 0 ? 0 : o.near
        },
        o.name !== "" && (_.name = o.type),
        c.cameras.push(_) - 1
    }
    processAnimation(o, c) {
        const h = this.json
          , _ = this.nodeMap;
        h.animations || (h.animations = []);
        try {
            o = GLTFExporter.Utils.mergeMorphTargetTracks(o.clone(), c)
        } catch (it) {
            if (console.warn('THREE.GLTFExporter: Could not export animation clip "%s".', o.name),
            !this.options.ignoreInvalidMorphTargetTracks)
                throw it;
            return console.error(it),
            null
        }
        const b = o.tracks
          , _e = []
          , nt = [];
        for (let it = 0; it < b.length; ++it) {
            const at = b[it]
              , ut = three_module.Nwf.parseTrackName(at.name);
            let pt = three_module.Nwf.findNode(c, ut.nodeName);
            const ht = GLTFExporter_PATH_PROPERTIES[ut.propertyName];
            if (ut.objectName === "bones" && (pt = pt.isSkinnedMesh === !0 ? pt.skeleton.getBoneByName(ut.objectIndex) : void 0),
            !pt || !ht)
                return console.warn('THREE.GLTFExporter: Could not export animation track "%s".', at.name),
                null;
            const _t = 1;
            let vt, bt = at.values.length / at.times.length;
            ht === GLTFExporter_PATH_PROPERTIES.morphTargetInfluences && (bt /= pt.morphTargetInfluences.length),
            at.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === !0 ? (vt = "CUBICSPLINE",
            bt /= 3) : vt = at.getInterpolation() === three_module.ljd ? "STEP" : "LINEAR",
            nt.push({
                input: this.processAccessor(new three_module.THS(at.times,_t)),
                output: this.processAccessor(new three_module.THS(at.values,bt)),
                interpolation: vt
            }),
            _e.push({
                sampler: nt.length - 1,
                target: {
                    node: _.get(pt),
                    path: ht
                }
            })
        }
        return h.animations.push({
            name: o.name || "clip_" + h.animations.length,
            samplers: nt,
            channels: _e
        }),
        h.animations.length - 1
    }
    processSkin(o) {
        const c = this.json
          , h = this.nodeMap
          , _ = c.nodes[h.get(o)]
          , b = o.skeleton;
        if (b === void 0)
            return null;
        const _e = o.skeleton.bones[0];
        if (_e === void 0)
            return null;
        const nt = []
          , it = new Float32Array(16 * b.bones.length)
          , at = new three_module.kn4;
        for (let ut = 0; ut < b.bones.length; ++ut)
            nt.push(h.get(b.bones[ut])),
            at.copy(b.boneInverses[ut]),
            at.multiply(o.bindMatrix).toArray(it, 16 * ut);
        return c.skins === void 0 && (c.skins = []),
        c.skins.push({
            inverseBindMatrices: this.processAccessor(new three_module.THS(it,16)),
            joints: nt,
            skeleton: h.get(_e)
        }),
        _.skin = c.skins.length - 1
    }
    processNode(o) {
        const c = this.json
          , h = this.options
          , _ = this.nodeMap;
        c.nodes || (c.nodes = []);
        const b = {};
        if (h.trs) {
            const nt = o.quaternion.toArray()
              , it = o.position.toArray()
              , at = o.scale.toArray();
            equalArray(nt, [0, 0, 0, 1]) || (b.rotation = nt),
            equalArray(it, [0, 0, 0]) || (b.translation = it),
            equalArray(at, [1, 1, 1]) || (b.scale = at)
        } else
            o.matrixAutoUpdate && o.updateMatrix(),
            isIdentityMatrix(o.matrix) === !1 && (b.matrix = o.matrix.elements);
        if (o.name !== "" && (b.name = String(o.name)),
        this.serializeUserData(o, b),
        o.isMesh || o.isLine || o.isPoints) {
            const nt = this.processMesh(o);
            nt !== null && (b.mesh = nt)
        } else
            o.isCamera && (b.camera = this.processCamera(o));
        if (o.isSkinnedMesh && this.skins.push(o),
        o.children.length > 0) {
            const nt = [];
            for (let it = 0, at = o.children.length; it < at; it++) {
                const ut = o.children[it];
                if (ut.visible || h.onlyVisible === !1) {
                    const pt = this.processNode(ut);
                    pt !== null && nt.push(pt)
                }
            }
            nt.length > 0 && (b.children = nt)
        }
        this._invokeAll(function(nt) {
            nt.writeNode && nt.writeNode(o, b)
        });
        const _e = c.nodes.push(b) - 1;
        return _.set(o, _e),
        _e
    }
    processScene(o) {
        const c = this.json
          , h = this.options;
        c.scenes || (c.scenes = [],
        c.scene = 0);
        const _ = {};
        o.name !== "" && (_.name = o.name),
        c.scenes.push(_);
        const b = [];
        for (let _e = 0, nt = o.children.length; _e < nt; _e++) {
            const it = o.children[_e];
            if (it.visible || h.onlyVisible === !1) {
                const at = this.processNode(it);
                at !== null && b.push(at)
            }
        }
        b.length > 0 && (_.nodes = b),
        this.serializeUserData(o, _)
    }
    processObjects(o) {
        const c = new three_module.Z58;
        c.name = "AuxScene";
        for (let h = 0; h < o.length; h++)
            c.children.push(o[h]);
        this.processScene(c)
    }
    processInput(o) {
        const c = this.options;
        o = o instanceof Array ? o : [o],
        this._invokeAll(function(_) {
            _.beforeParse && _.beforeParse(o)
        });
        const h = [];
        for (let _ = 0; _ < o.length; _++)
            o[_]instanceof three_module.Z58 ? this.processScene(o[_]) : h.push(o[_]);
        h.length > 0 && this.processObjects(h);
        for (let _ = 0; _ < this.skins.length; ++_)
            this.processSkin(this.skins[_]);
        for (let _ = 0; _ < c.animations.length; ++_)
            this.processAnimation(c.animations[_], o[0]);
        this._invokeAll(function(_) {
            _.afterParse && _.afterParse(o)
        })
    }
    _invokeAll(o) {
        for (let c = 0, h = this.plugins.length; c < h; c++)
            o(this.plugins[c])
    }
    checkEmptyMap(o) {
        return !(!o || this.options.ignoreEmptyTextures && !o.image)
    }
}
class GLTFLightExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_lights_punctual"
    }
    writeNode(o, c) {
        if (!o.isLight)
            return;
        if (!o.isDirectionalLight && !o.isPointLight && !o.isSpotLight)
            return void console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.", o);
        const h = this.writer
          , _ = h.json
          , b = h.extensionsUsed
          , _e = {};
        o.name && (_e.name = o.name),
        _e.color = o.color.toArray(),
        _e.intensity = o.intensity,
        o.isDirectionalLight ? _e.type = "directional" : o.isPointLight ? (_e.type = "point",
        o.distance > 0 && (_e.range = o.distance)) : o.isSpotLight && (_e.type = "spot",
        o.distance > 0 && (_e.range = o.distance),
        _e.spot = {},
        _e.spot.innerConeAngle = (1 - o.penumbra) * o.angle,
        _e.spot.outerConeAngle = o.angle),
        o.decay !== void 0 && o.decay !== 2 && console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),
        !o.target || o.target.parent === o && o.target.position.x === 0 && o.target.position.y === 0 && o.target.position.z === -1 || console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),
        b[this.name] || (_.extensions = _.extensions || {},
        _.extensions[this.name] = {
            lights: []
        },
        b[this.name] = !0);
        const nt = _.extensions[this.name].lights;
        nt.push(_e),
        c.extensions = c.extensions || {},
        c.extensions[this.name] = {
            light: nt.length - 1
        }
    }
}
class GLTFExporter_GLTFMaterialsUnlitExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_unlit"
    }
    writeMaterial(o, c) {
        if (!o.isMeshBasicMaterial)
            return;
        const h = this.writer.extensionsUsed;
        c.extensions = c.extensions || {},
        c.extensions[this.name] = {},
        h[this.name] = !0,
        c.pbrMetallicRoughness.metallicFactor = 0,
        c.pbrMetallicRoughness.roughnessFactor = .9
    }
}
class GLTFExporter_GLTFMaterialsClearcoatExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_clearcoat"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.clearcoat === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.clearcoatFactor = o.clearcoat,
        h.checkEmptyMap(o.clearcoatMap)) {
            const _e = {
                index: h.processTexture(o.clearcoatMap),
                texCoord: o.clearcoatMap.channel
            };
            h.applyTextureTransform(_e, o.clearcoatMap),
            b.clearcoatTexture = _e
        }
        if (b.clearcoatRoughnessFactor = o.clearcoatRoughness,
        h.checkEmptyMap(o.clearcoatRoughnessMap)) {
            const _e = {
                index: h.processTexture(o.clearcoatRoughnessMap),
                texCoord: o.clearcoatRoughnessMap.channel
            };
            h.applyTextureTransform(_e, o.clearcoatRoughnessMap),
            b.clearcoatRoughnessTexture = _e
        }
        if (h.checkEmptyMap(o.clearcoatNormalMap)) {
            const _e = {
                index: h.processTexture(o.clearcoatNormalMap),
                texCoord: o.clearcoatNormalMap.channel
            };
            h.applyTextureTransform(_e, o.clearcoatNormalMap),
            b.clearcoatNormalTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsIridescenceExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_iridescence"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.iridescence === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.iridescenceFactor = o.iridescence,
        h.checkEmptyMap(o.iridescenceMap)) {
            const _e = {
                index: h.processTexture(o.iridescenceMap),
                texCoord: o.iridescenceMap.channel
            };
            h.applyTextureTransform(_e, o.iridescenceMap),
            b.iridescenceTexture = _e
        }
        if (b.iridescenceIor = o.iridescenceIOR,
        b.iridescenceThicknessMinimum = o.iridescenceThicknessRange[0],
        b.iridescenceThicknessMaximum = o.iridescenceThicknessRange[1],
        h.checkEmptyMap(o.iridescenceThicknessMap)) {
            const _e = {
                index: h.processTexture(o.iridescenceThicknessMap),
                texCoord: o.iridescenceThicknessMap.channel
            };
            h.applyTextureTransform(_e, o.iridescenceThicknessMap),
            b.iridescenceThicknessTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsTransmissionExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_transmission"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.transmission === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.transmissionFactor = o.transmission,
        h.checkEmptyMap(o.transmissionMap)) {
            const _e = {
                index: h.processTexture(o.transmissionMap),
                texCoord: o.transmissionMap.channel
            };
            h.applyTextureTransform(_e, o.transmissionMap),
            b.transmissionTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsVolumeExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_volume"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.transmission === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.thicknessFactor = o.thickness,
        h.checkEmptyMap(o.thicknessMap)) {
            const _e = {
                index: h.processTexture(o.thicknessMap),
                texCoord: o.thicknessMap.channel
            };
            h.applyTextureTransform(_e, o.thicknessMap),
            b.thicknessTexture = _e
        }
        b.attenuationDistance = o.attenuationDistance,
        b.attenuationColor = o.attenuationColor.toArray(),
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsIorExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_ior"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.ior === 1.5)
            return;
        const h = this.writer.extensionsUsed
          , _ = {};
        _.ior = o.ior,
        c.extensions = c.extensions || {},
        c.extensions[this.name] = _,
        h[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsSpecularExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_specular"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.specularIntensity === 1 && o.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !o.specularIntensityMap && !o.specularColorTexture)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (h.checkEmptyMap(o.specularIntensityMap)) {
            const _e = {
                index: h.processTexture(o.specularIntensityMap),
                texCoord: o.specularIntensityMap.channel
            };
            h.applyTextureTransform(_e, o.specularIntensityMap),
            b.specularTexture = _e
        }
        if (h.checkEmptyMap(o.specularColorMap)) {
            const _e = {
                index: h.processTexture(o.specularColorMap),
                texCoord: o.specularColorMap.channel
            };
            h.applyTextureTransform(_e, o.specularColorMap),
            b.specularColorTexture = _e
        }
        b.specularFactor = o.specularIntensity,
        b.specularColorFactor = o.specularColor.toArray(),
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsSheenExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_sheen"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.sheen < .001)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (h.checkEmptyMap(o.sheenRoughnessMap)) {
            const _e = {
                index: h.processTexture(o.sheenRoughnessMap),
                texCoord: o.sheenRoughnessMap.channel
            };
            h.applyTextureTransform(_e, o.sheenRoughnessMap),
            b.sheenRoughnessTexture = _e
        }
        if (h.checkEmptyMap(o.sheenColorMap)) {
            const _e = {
                index: h.processTexture(o.sheenColorMap),
                texCoord: o.sheenColorMap.channel
            };
            h.applyTextureTransform(_e, o.sheenColorMap),
            b.sheenColorTexture = _e
        }
        b.sheenRoughnessFactor = o.sheenRoughness,
        b.sheenColorFactor = o.sheenColor.toArray(),
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        c.extras = c.extras || {},
        c.extras.sheenFactor = o.sheen,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsAnisotropyExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_anisotropy"
    }
    writeMaterial(o, c) {
        if (!o.isMeshPhysicalMaterial || o.anisotropy == 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (h.checkEmptyMap(o.anisotropyMap)) {
            const _e = {
                index: h.processTexture(o.anisotropyMap)
            };
            h.applyTextureTransform(_e, o.anisotropyMap),
            b.anisotropyTexture = _e
        }
        b.anisotropyStrength = o.anisotropy,
        b.anisotropyRotation = o.anisotropyRotation,
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFExporter_GLTFMaterialsEmissiveStrengthExtension {
    constructor(o) {
        this.writer = o,
        this.name = "KHR_materials_emissive_strength"
    }
    writeMaterial(o, c) {
        if (!o.isMeshStandardMaterial || o.emissiveIntensity === 1)
            return;
        const h = this.writer.extensionsUsed
          , _ = {};
        _.emissiveStrength = o.emissiveIntensity,
        c.extensions = c.extensions || {},
        c.extensions[this.name] = _,
        h[this.name] = !0
    }
}
GLTFExporter.Utils = {
    GLTFWriter,
    insertKeyframe: function(d, o) {
        const h = d.getValueSize()
          , _ = new d.TimeBufferType(d.times.length + 1)
          , b = new d.ValueBufferType(d.values.length + h)
          , _e = d.createInterpolant(new d.ValueBufferType(h));
        let nt;
        if (d.times.length === 0) {
            _[0] = o;
            for (let it = 0; it < h; it++)
                b[it] = 0;
            nt = 0
        } else if (o < d.times[0]) {
            if (Math.abs(d.times[0] - o) < .001)
                return 0;
            _[0] = o,
            _.set(d.times, 1),
            b.set(_e.evaluate(o), 0),
            b.set(d.values, h),
            nt = 0
        } else if (o > d.times[d.times.length - 1]) {
            if (Math.abs(d.times[d.times.length - 1] - o) < .001)
                return d.times.length - 1;
            _[_.length - 1] = o,
            _.set(d.times, 0),
            b.set(d.values, 0),
            b.set(_e.evaluate(o), d.values.length),
            nt = _.length - 1
        } else
            for (let it = 0; it < d.times.length; it++) {
                if (Math.abs(d.times[it] - o) < .001)
                    return it;
                if (d.times[it] < o && d.times[it + 1] > o) {
                    _.set(d.times.slice(0, it + 1), 0),
                    _[it + 1] = o,
                    _.set(d.times.slice(it + 1), it + 2),
                    b.set(d.values.slice(0, (it + 1) * h), 0),
                    b.set(_e.evaluate(o), (it + 1) * h),
                    b.set(d.values.slice((it + 1) * h), (it + 2) * h),
                    nt = it + 1;
                    break
                }
            }
        return d.times = _,
        d.values = b,
        nt
    },
    mergeMorphTargetTracks: function(d, o) {
        const c = []
          , h = {}
          , _ = d.tracks;
        for (let b = 0; b < _.length; ++b) {
            let _e = _[b];
            const nt = three_module.Nwf.parseTrackName(_e.name)
              , it = three_module.Nwf.findNode(o, nt.nodeName);
            if (nt.propertyName !== "morphTargetInfluences" || nt.propertyIndex === void 0) {
                c.push(_e);
                continue
            }
            if (_e.createInterpolant !== _e.InterpolantFactoryMethodDiscrete && _e.createInterpolant !== _e.InterpolantFactoryMethodLinear) {
                if (_e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)
                    throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");
                console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),
                _e = _e.clone(),
                _e.setInterpolation(three_module.PJ3)
            }
            const at = it.morphTargetInfluences.length
              , ut = it.morphTargetDictionary[nt.propertyIndex];
            if (ut === void 0)
                throw new Error("THREE.GLTFExporter: Morph target name not found: " + nt.propertyIndex);
            let pt;
            if (h[it.uuid] === void 0) {
                pt = _e.clone();
                const _t = new pt.ValueBufferType(at * pt.times.length);
                for (let vt = 0; vt < pt.times.length; vt++)
                    _t[vt * at + ut] = pt.values[vt];
                pt.name = (nt.nodeName || "") + ".morphTargetInfluences",
                pt.values = _t,
                h[it.uuid] = pt,
                c.push(pt);
                continue
            }
            const ht = _e.createInterpolant(new _e.ValueBufferType(1));
            pt = h[it.uuid];
            for (let _t = 0; _t < pt.times.length; _t++)
                pt.values[_t * at + ut] = ht.evaluate(pt.times[_t]);
            for (let _t = 0; _t < _e.times.length; _t++) {
                const vt = this.insertKeyframe(pt, _e.times[_t]);
                pt.values[vt * at + ut] = _e.values[_t]
            }
        }
        return d.tracks = c,
        d
    }
};
class GLTFWriter2 extends GLTFExporter.Utils.GLTFWriter {
    constructor() {
        super(...arguments),
        this._defaultMaterial = new three_module._4j
    }
    serializeUserData(o, c) {
        const h = o.userData
          , _ = {};
        h.__disposed && console.error("Serializing a disposed object", o),
        Object.entries(h).forEach( ([_e,nt]) => {
            (!nt || typeof nt == "function" || nt.isObject3D || nt.isTexture || nt.isMaterial || nt.assetType != null || _e.startsWith("_") || _e !== "uuid" && (iGeometryIgnoredUserData.includes(_e) || iModelIgnoredUserData.includes(_e) || iMaterialIgnoredUserData.includes(_e))) && (_[_e] = nt,
            delete h[_e])
        }
        );
        const b = serializeObject(h, !1);
        Object.entries(_).forEach( ([_e,nt]) => {
            h[_e] = nt,
            delete _[_e]
        }
        ),
        o.userData = b,
        super.serializeUserData(o, c),
        o.userData = h
    }
    processObjects(o) {
        var c;
        o.length === 1 && (!((c = o[0]) === null || c === void 0) && c.userData.rootSceneModelRoot) ? this.processScene(o[0]) : super.processObjects(o)
    }
    processMaterial(o) {
        if (this.cache.materials.has(o))
            return this.cache.materials.get(o);
        let c = o;
        c && !c.isShaderMaterial || (c = this._defaultMaterial);
        const h = super.processMaterial(c);
        if (h === null)
            return console.error("GLTFWriter2: Unexpected error: Failed to process material", o),
            null;
        if (!o || c === o)
            return h;
        const _ = JSON.stringify(this.json.materials[h])
          , b = JSON.parse(_);
        this.serializeUserData(o, b),
        this._invokeAll(nt => {
            nt.writeMaterial && nt.writeMaterial(o, b)
        }
        );
        const _e = this.json.materials.push(b) - 1;
        return this.cache.materials.set(o, _e),
        _e
    }
    processImageBlob(o, c) {
        if (!o)
            return -1;
        const h = this.cache
          , _ = this.options
          , b = this.pending
          , _e = this.json
          , nt = c.image;
        h.images.has(nt) || h.images.set(nt, {});
        const it = h.images.get(nt)
          , at = o.type + ":flipY/" + c.flipY.toString();
        if (it[at] !== void 0)
            return it[at];
        _e.images || (_e.images = []);
        const ut = {
            mimeType: o.type
        };
        _.binary === !0 ? b.push(new Promise(ht => {
            this.processBufferViewImage(o).then(_t => {
                ut.bufferView = _t,
                ht()
            }
            )
        }
        )) : b.push(q$2(o).then(ht => {
            ut.uri = ht
        }
        ));
        const pt = _e.images.push(ut) - 1;
        return it[at] = pt,
        pt
    }
    processSampler(o) {
        return super.processSampler(o)
    }
    processTexture(o) {
        const c = this.cache
          , h = this.json;
        if (c.textures.has(o))
            return c.textures.get(o);
        const _ = o.source.data
          , b = o.userData.mimeType;
        o.userData.rootPath && !this.options.embedUrlImages && (o.userData.rootPath.startsWith("http") || o.userData.rootPath.startsWith("data:")) && (o.source.data && (!this.options.exporterOptions.embedUrlImagePreviews || o.isDataTexture ? o.source.data = null : o.source.data._savePreview = !0),
        delete o.userData.mimeType);
        const _e = super.processTexture(o)
          , nt = h.textures[_e];
        if (!nt)
            return console.error("No texture def", _e, o),
            _e;
        const it = h.images ? h.images[nt.source] : null;
        if (it && (it.extras || (it.extras = {}),
        o.source && (it.extras.uuid = o.source.uuid),
        it.extras.t_uuid = o.uuid),
        o.userData.rootPath && !this.options.embedUrlImages && (o.userData.rootPath.startsWith("http") || o.userData.rootPath.startsWith("data:"))) {
            if (o.source.data ? delete o.source.data._savePreview : o.source.data = _,
            o.userData.mimeType = b,
            !nt)
                return console.error("textureDef is null", _e, o),
                _e;
            if (nt.source >= 0) {
                const at = this.json.images[nt.source];
                at.uri ? console.warn("GLTFWriter2: uri already set", at.uri) : (at.uri = o.userData.rootPath,
                at.mimeType = b,
                at.extras || (at.extras = {}),
                at.extras.flipY = o.flipY,
                at.extras.uri = o.userData.rootPath)
            } else
                nt.source = this.processImageUri(o.image, o.userData.rootPath, o.flipY, b)
        }
        return nt.source < 0 && (console.error("textureDef.source cannot be saved", nt, o),
        delete nt.source),
        _e
    }
    processImage(o, c, h, _="image/png") {
        return o ? super.processImage(o, c, h, _, o._savePreview ? 32 : void 0, o._savePreview ? 32 : void 0) : -1
    }
    processImageUri(o, c, h, _="image/png") {
        const b = this.cache
          , _e = this.json;
        b.images.has(o) || b.images.set(o, {});
        const nt = b.images.get(o)
          , it = _ + ":flipY/" + h.toString();
        if (nt[it] !== void 0)
            return nt[it];
        _e.images || (_e.images = []);
        const at = {
            mimeType: _,
            uri: c,
            extras: {
                flipY: h
            }
        }
          , ut = _e.images.push(at) - 1;
        return nt[it] = ut,
        ut
    }
}
async function setInnerHTMLWithScripts(d, o) {
    var c;
    d.innerHTML = o;
    const h = d.getElementsByTagName("script");
    for (let _ = 0; _ < h.length; _++) {
        const b = h[_]
          , _e = cloneScriptTag(b);
        let nt = !1;
        await new Promise(it => {
            _e.onload = it,
            _e.onerror = () => {
                nt = !0,
                it(void 0)
            }
        }
        ),
        nt || (c = b.parentNode) === null || c === void 0 || c.replaceChild(_e, b)
    }
}
function cloneScriptTag(d, o) {
    (o = o ?? document.createElement("script")).type = d.type || "text/javascript",
    o.text = d.text;
    for (let c = 0; c < d.attributes.length; c++) {
        const h = d.attributes[c];
        o.setAttribute(h.name, h.value)
    }
    return o
}
function dom_getPaddedArrayBuffer(d, o=0) {
    const c = dom_getPaddedBufferSize(d.byteLength);
    if (c !== d.byteLength) {
        const h = new Uint8Array(c);
        if (h.set(new Uint8Array(d)),
        o !== 0)
            for (let _ = d.byteLength; _ < c; _++)
                h[_] = o;
        return h.buffer
    }
    return d
}
function dom_getPaddedBufferSize(d) {
    return 4 * Math.ceil(d / 4)
}
ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function(d, o) {
    const c = new Uint8Array(this);
    o == null && (o = c.length);
    const h = new ArrayBuffer(o - (d || 0))
      , _ = new Uint8Array(h);
    for (let b = 0; b < _.length; b++)
        _[b] = c[b + (d || 0)];
    return h
}
);
const dom_GLB_HEADER_BYTES = 12
  , dom_GLB_HEADER_MAGIC = 1179937895
  , dom_GLB_VERSION = 2
  , dom_GLB_CHUNK_PREFIX_BYTES = 8
  , dom_GLB_CHUNK_TYPE_JSON = 1313821514
  , dom_GLB_CHUNK_TYPE_BIN = 5130562;
function makeGLBFile(d, o) {
    const c = dom_getPaddedArrayBuffer(d)
      , h = new DataView(new ArrayBuffer(dom_GLB_CHUNK_PREFIX_BYTES));
    h.setUint32(0, c.byteLength, !0),
    h.setUint32(4, dom_GLB_CHUNK_TYPE_BIN, !0);
    const _ = dom_getPaddedArrayBuffer(new TextEncoder().encode(JSON.stringify(o || {})).buffer, 32)
      , b = new DataView(new ArrayBuffer(dom_GLB_CHUNK_PREFIX_BYTES));
    b.setUint32(0, _.byteLength, !0),
    b.setUint32(4, dom_GLB_CHUNK_TYPE_JSON, !0);
    const _e = new ArrayBuffer(dom_GLB_HEADER_BYTES)
      , nt = new DataView(_e);
    nt.setUint32(0, dom_GLB_HEADER_MAGIC, !0),
    nt.setUint32(4, dom_GLB_VERSION, !0);
    const it = dom_GLB_HEADER_BYTES + b.byteLength + _.byteLength + h.byteLength + c.byteLength;
    nt.setUint32(8, it, !0);
    const at = new Blob([_e, b, _, h, c],{
        type: "application/octet-stream"
    });
    return at.ext = "glb",
    at
}
class GLTFExporter2 extends GLTFExporter {
    register(o) {
        return super.register(o)
    }
    async parseAsync(o, c) {
        var h;
        if (!o)
            throw new Error("No object to export");
        const _ = o.__isGLTFOutput || !Array.isArray(o) && !o.isObject3D ? o : await new Promise( (b, _e) => this.parse(o, b, _e, c));
        if (_ && typeof _ == "object" && !_.byteLength)
            return new Blob([JSON.stringify(_, (b, _e) => b.startsWith("__") ? void 0 : _e, (h = c.jsonSpaces) !== null && h !== void 0 ? h : 2)],{
                type: "model/gltf+json"
            });
        if (_) {
            let b = null;
            return c.encrypt && (!c.encryptKey && window.prompt && (c.encryptKey = window.prompt("GLTFEncryption: Enter encryption key") || ""),
            c.encryptKey ? b = makeGLBFile(await Te$1(new Uint8Array(_), c.encryptKey), {
                asset: {
                    version: "2.0",
                    generator: "WebGiGLBWrapper",
                    encryption: {
                        type: "aesgcm",
                        version: 1
                    }
                }
            }) : console.warn("WebGi GLTF Export: encryption key not provided, skipping encryption")),
            b || (b = new Blob([_],{
                type: "model/gltf+binary"
            })),
            b
        }
        throw new Error("GLTFExporter2.parse() failed")
    }
    parse(o, c, h, _={}) {
        var b, _e, nt, it, at, ut, pt;
        const ht = {
            binary: !1,
            trs: (b = _.trs) !== null && b !== void 0 && b,
            onlyVisible: (_e = _.onlyVisible) !== null && _e !== void 0 && _e,
            truncateDrawRange: (nt = _.truncateDrawRange) === null || nt === void 0 || nt,
            externalImagesInExtras: !_.embedUrlImages && _.externalImagesInExtras || !1,
            embedUrlImages: (it = _.embedUrlImages) !== null && it !== void 0 && it,
            maxTextureSize: (at = _.maxTextureSize) !== null && at !== void 0 ? at : 1 / 0,
            animations: (ut = _.animations) !== null && ut !== void 0 ? ut : [],
            includeCustomExtensions: (pt = _.includeCustomExtensions) === null || pt === void 0 || pt,
            exporterOptions: _,
            ignoreInvalidMorphTargetTracks: _.ignoreInvalidMorphTargetTracks,
            ignoreEmptyTextures: _.ignoreEmptyTextures
        };
        return _.exportExt === "glb" && (ht.binary = !0),
        _.preserveUUIDs !== !1 && (Array.isArray(o) ? o : [o]).forEach(_t => _t.traverse(vt => {
            vt.uuid && (vt.userData.gltfUUID = vt.uuid)
        }
        )),
        (Array.isArray(o) ? o : [o]).forEach(_t => _t.traverse(vt => {
            if (vt.animations)
                for (const bt of vt.animations)
                    bt.__gltfExport === !1 || ht.animations.includes(bt) || ht.animations.push(...vt.animations)
        }
        )),
        super.parse(o, _t => {
            _.preserveUUIDs !== !1 && (Array.isArray(o) ? o : [o]).forEach(vt => vt.traverse(bt => {
                delete bt.userData.gltfUUID
            }
            )),
            c(Object.assign(_t, {
                __isGLTFOutput: !0
            }))
        }
        , h, ht, new GLTFWriter2)
    }
}
function processViewer(d, o) {
    const c = d.getPlugin(AssetManagerPlugin).exportViewerConfig();
    o.json.textures && o.json.samplers && o.json.images && c.resources.textures && [...Object.entries(c.resources.textures)].forEach( ([_,b]) => {
        o.json.textures.find(nt => {
            var it, at, ut, pt, ht;
            return ((it = nt.extras) === null || it === void 0 ? void 0 : it.uuid) === _ || ((ut = (at = o.json.samplers[nt.sampler]) === null || at === void 0 ? void 0 : at.extras) === null || ut === void 0 ? void 0 : ut.uuid) === _ || ((ht = (pt = o.json.images[nt.source]) === null || pt === void 0 ? void 0 : pt.extras) === null || ht === void 0 ? void 0 : ht.t_uuid) === _
        }
        ) && (b.image && c.resources.images && c.resources.images[b.image] && delete c.resources.images[b.image],
        c.resources.textures[_] = {})
    }
    ),
    o.json.materials && c.resources.materials && [...Object.entries(c.resources.materials)].forEach( ([_,b]) => {
        o.json.materials.find(nt => {
            var it;
            return ((it = nt.extras) === null || it === void 0 ? void 0 : it.uuid) === _
        }
        ) && (c.resources.materials[_] = {})
    }
    );
    const h = [];
    Object.values(c.resources).forEach(_ => {
        _ && Object.values(_).forEach(b => {
            b.url && (b.url.type === "Uint16Array" && b.url.data ? (b.url.data instanceof Uint16Array || (b.url.data = new Uint16Array(b.url.data)),
            h.push(b.url)) : b.url.type === "Uint8Array" && b.url.data && (b.url.data instanceof Uint8Array || (b.url.data = new Uint8Array(b.url.data)),
            h.push(b.url)))
        }
        )
    }
    );
    for (const _ of h) {
        let b = "application/octet-stream";
        if (_.mimeType && (b = _.mimeType),
        o.options.exporterOptions.encodeUint16Rgbe && _.type === "Uint16Array" && _.width > 0 && _.height > 0) {
            const at = halfFloatToRgbe(_.data, 4)
              , ut = new ImageData(at,_.width,_.height)
              , pt = three_module.HgN.getDataURL(ut, !0).split(",")[1]
              , ht = 2;
            b = "image/png",
            ht === 1 || (_.data = Uint8Array.from(atob(pt), _t => _t.charCodeAt(0))),
            _.encoding = "rgbe",
            _.encodingVersion = ht
        }
        o.json.images || (o.json.images = []);
        const _e = {
            mimeType: b
        }
          , nt = o.json.images.push(_e) - 1
          , it = _.data;
        _e.bufferView = o.processBufferViewImageBuffer(it),
        _.data = {
            image: nt
        }
    }
    return c
}
function halfFloatToRgbe(d, o=3, c) {
    let h, _, b, _e, nt;
    const it = d.byteLength / (2 * o) | 0;
    c = c || new Uint8ClampedArray(4 * it);
    for (let at = 0; at < it; at++) {
        h = d[at * o],
        _ = d[at * o + 1],
        b = d[at * o + 2],
        _e = Math.max(Math.max(h, _), b);
        const ut = Math.ceil(Math.log2(_e));
        nt = Math.pow(2, ut - 8),
        c[4 * at] = h / nt | 0,
        c[4 * at + 1] = _ / nt | 0,
        c[4 * at + 2] = b / nt | 0,
        c[4 * at + 3] = ut + 128
    }
    return c
}
function addGLTFExporter(d, o, c=GLTFExporter2, h) {
    var _;
    if (!o)
        return;
    const b = d.Exporters.findIndex(nt => nt.ext.includes("gltf") || nt.ext.includes("glb"))
      , _e = [];
    b >= 0 ? (_e.push(...(_ = d.Exporters[b].extensions) !== null && _ !== void 0 ? _ : []),
    d.Exporters.splice(b, 1)) : (_e.push(gltfMaterialExtrasWriter),
    _e.push(gltfObject3DExtrasWriter),
    _e.push(gltfLightExtrasWriter),
    _e.push(nt => new GLTFMeshGpuInstancingExporter(nt)),
    _e.push(nt => new GLTFMaterialsBumpMapExtensionExport(nt)),
    _e.push(nt => new GLTFMaterialsDisplacementMapExtensionExport(nt)),
    _e.push(nt => new GLTFMaterialsLightMapExtensionExport(nt)),
    _e.push(nt => new GLTFMaterialsAlphaMapExtensionExport(nt))),
    d.Exporters.push({
        ctor: () => {
            const nt = new c;
            return _e.forEach(it => nt.register(it)),
            nt.register(it => ({
                afterParse: at => {
                    var ut, pt;
                    if (!(!((ut = (at = Array.isArray(at) ? at[0] : at) == null ? void 0 : at.userData) === null || ut === void 0) && ut.rootSceneModelRoot) || ((pt = at == null ? void 0 : at.userData) === null || pt === void 0 ? void 0 : pt.__exportViewerConfig) === !1)
                        return;
                    const ht = it.json.scenes[it.json.scene || 0];
                    ht.extensions || (ht.extensions = {}),
                    ht.extensions[viewerGLTFExtension] = processViewer(o, it),
                    it.extensionsUsed[viewerGLTFExtension] = !0
                }
            })),
            h == null || h(nt),
            nt
        }
        ,
        ext: ["gltf", "glb"],
        extensions: _e
    })
}
const gltfLightExtrasWriter = d => ({
    writeNode: (o, c) => {
        if (!(o != null && o.isLight))
            return;
        c.extensions || (c.extensions = {});
        const h = {};
        o.shadow && (h.shadow = o.shadow.toJSON()),
        Object.keys(h).length > 0 && (c.extensions[webgiLightExtrasExtension] = h,
        d.extensionsUsed[webgiLightExtrasExtension] = !0)
    }
})
  , gltfObject3DExtrasWriter = d => ({
    writeNode: (o, c) => {
        if (!(o != null && o.isObject3D))
            return;
        c.extensions || (c.extensions = {});
        const h = {};
        o.castShadow !== void 0 && (h.castShadow = o.castShadow),
        o.receiveShadow !== void 0 && (h.receiveShadow = o.receiveShadow),
        o.visible === !1 && (h.visible = !1),
        o.frustumCulled === !1 && (h.frustumCulled = !1),
        o.renderOrder !== 0 && (h.renderOrder = o.renderOrder),
        o.layers.mask !== 1 && (h.layers = o.layers.mask),
        o.matrixAutoUpdate === !1 && (h.matrixAutoUpdate = !1),
        Object.keys(h).length > 0 && (c.extensions[webgiObject3DExtrasExtension] = h,
        d.extensionsUsed[webgiObject3DExtrasExtension] = !0)
    }
})
  , gltfMaterialExtrasWriter = d => ({
    writeMaterial(o, c) {
        if (!(o != null && o.isMaterial))
            return;
        c.extensions || (c.extensions = {});
        const h = {};
        o.fog !== void 0 && (h.fog = o.fog),
        o.flatShading !== void 0 && (h.flatShading = o.flatShading),
        o.blending !== void 0 && (h.blending = o.blending),
        o.side !== void 0 && o.side !== three_module.$EB && (h.side = o.side),
        o.shadowSide !== void 0 && (h.shadowSide = o.shadowSide),
        o.depthFunc !== void 0 && (h.depthFunc = o.depthFunc),
        o.depthTest !== void 0 && (h.depthTest = o.depthTest),
        o.depthWrite !== void 0 && (h.depthWrite = o.depthWrite),
        o.colorWrite !== void 0 && (h.colorWrite = o.colorWrite),
        o.vertexColors !== void 0 && (h.vertexColors = o.vertexColors),
        o.alphaTest !== void 0 && (h.alphaTest = o.alphaTest),
        o.alphaHash !== void 0 && (h.alphaHash = o.alphaHash),
        o.envMapIntensity !== void 0 && (h.envMapIntensity = o.envMapIntensity),
        o.wireframe !== void 0 && (h.wireframe = o.wireframe),
        o.wireframeLinewidth !== void 0 && (h.wireframeLinewidth = o.wireframeLinewidth),
        o.wireframeLinecap !== void 0 && (h.wireframeLinecap = o.wireframeLinecap),
        o.wireframeLinejoin !== void 0 && (h.wireframeLinejoin = o.wireframeLinejoin),
        o.rotation !== void 0 && (h.rotation = o.rotation),
        o.polygonOffset !== void 0 && (h.polygonOffset = o.polygonOffset),
        o.polygonOffsetFactor !== void 0 && (h.polygonOffsetFactor = o.polygonOffsetFactor),
        o.polygonOffsetUnits !== void 0 && (h.polygonOffsetUnits = o.polygonOffsetUnits),
        o.dithering !== void 0 && (h.dithering = o.dithering),
        o.alphaToCoverage !== void 0 && (h.alphaToCoverage = o.alphaToCoverage),
        o.premultipliedAlpha !== void 0 && (h.premultipliedAlpha = o.premultipliedAlpha),
        o.toneMapped !== void 0 && (h.toneMapped = o.toneMapped),
        o.normalScale !== void 0 && (h.normalScale = [o.normalScale.x, o.normalScale.y]);
        const _ = this.materialExternalResources[o.uuid];
        _ && Object.entries(_).forEach( ([b,_e]) => {
            var nt;
            b.startsWith("_") || (_e != null && _e.userData && (_e.userData.__embedUrlImagePreviews = (nt = d.options.exporterOptions) === null || nt === void 0 ? void 0 : nt.embedUrlImagePreviews),
            h[b] = serializeObject(_e, !1, this.serializedMeta),
            _e != null && _e.userData && delete _e.userData.__embedUrlImagePreviews)
        }
        ),
        Object.keys(h).length > 0 && (c.extensions[webgiMaterialExtrasExtension] = h,
        d.extensionsUsed[webgiMaterialExtrasExtension] = !0)
    },
    materialExternalResources: {},
    serializedMeta: {
        images: {},
        textures: {}
    },
    beforeParse(o) {
        if (this.materialExternalResources = {},
        !d.options.externalImagesInExtras)
            return;
        const c = [];
        (Array.isArray(o) ? o : [o]).forEach(h => {
            h == null || h.traverse(_ => {
                var b;
                _ && (!((b = _.material) === null || b === void 0) && b.isMaterial) && c.push(_.material)
            }
            )
        }
        ),
        c.forEach(h => {
            h && (this.materialExternalResources[h.uuid] || (this.materialExternalResources[h.uuid] = {}),
            this.materialExternalResources[h.uuid].__materialRef = h,
            Object.entries(h).forEach( ([_,b]) => {
                _.startsWith("_") || b && b.isTexture && b.userData.rootPath && (b.userData.rootPath.startsWith("http") || b.userData.rootPath.startsWith("data:")) && (h[_] = null,
                this.materialExternalResources[h.uuid][_] = b)
            }
            ))
        }
        )
    },
    afterParse(o) {
        const c = Object.values(this.materialExternalResources);
        if (c.length < 1)
            return;
        c.forEach(_ => {
            const b = _.__materialRef;
            b && (Object.entries(_).forEach( ([_e,nt]) => {
                _e.startsWith("_") || nt && (b[_e] = nt)
            }
            ),
            delete this.materialExternalResources[b.uuid])
        }
        );
        const h = d.json.scenes[d.json.scene || 0];
        h.extensions || (h.extensions = {}),
        h.extensions[webgiMaterialExtrasExtension] = {
            resources: this.serializedMeta
        },
        d.extensionsUsed[webgiMaterialExtrasExtension] = !0
    }
});
class GLTFMaterialsBumpMapExtensionExport {
    constructor(o) {
        this.writer = o,
        this.name = GLTFMaterialsBumpMapExtensionName
    }
    writeMaterial(o, c) {
        if (!o.isMeshStandardMaterial || o.bumpScale === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.bumpScale = o.bumpScale,
        o.bumpMap && h.checkEmptyMap(o.bumpMap)) {
            const _e = {
                index: h.processTexture(o.bumpMap)
            };
            h.applyTextureTransform(_e, o.bumpMap),
            b.bumpTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFMaterialsDisplacementMapExtensionExport {
    constructor(o) {
        this.writer = o,
        this.name = GLTFMaterialsDisplacementMapExtensionName
    }
    writeMaterial(o, c) {
        if (!o.isMeshStandardMaterial || o.displacementScale === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.displacementScale = o.displacementScale,
        b.displacementBias = o.displacementBias,
        o.displacementMap && h.checkEmptyMap(o.displacementMap)) {
            const _e = {
                index: h.processTexture(o.displacementMap)
            };
            h.applyTextureTransform(_e, o.displacementMap),
            b.displacementTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFMaterialsLightMapExtensionExport {
    constructor(o) {
        this.writer = o,
        this.name = GLTFMaterialsLightMapExtensionName
    }
    writeMaterial(o, c) {
        if (!o.isMeshStandardMaterial || o.lightMapIntensity === 0)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (b.lightMapIntensity = o.lightMapIntensity,
        o.lightMap && h.checkEmptyMap(o.lightMap)) {
            const _e = {
                index: h.processTexture(o.lightMap)
            };
            h.applyTextureTransform(_e, o.lightMap),
            b.lightMapTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
class GLTFMaterialsAlphaMapExtensionExport {
    constructor(o) {
        this.writer = o,
        this.name = GLTFMaterialsAlphaMapExtensionName
    }
    writeMaterial(o, c) {
        if (!o.isMeshStandardMaterial || !o.alphaMap)
            return;
        const h = this.writer
          , _ = h.extensionsUsed
          , b = {};
        if (h.checkEmptyMap(o.alphaMap)) {
            const _e = {
                index: h.processTexture(o.alphaMap)
            };
            h.applyTextureTransform(_e, o.alphaMap),
            b.alphaTexture = _e
        }
        c.extensions = c.extensions || {},
        c.extensions[this.name] = b,
        _[this.name] = !0
    }
}
const textEncoder = new TextEncoder
  , ZIP_COMPRESSION = 3;
class EXRExporter {
    parse(o, c, h) {
        if (!o || !o.isWebGLRenderer && !o.isDataTexture)
            throw Error("EXRExporter.parse: Unsupported first parameter, expected instance of WebGLRenderer or DataTexture.");
        if (o.isWebGLRenderer) {
            const _ = o
              , b = c
              , _e = h;
            supportedRTT(b);
            const nt = buildInfoRTT(b, _e);
            return fillData(compressData(reorganizeDataBuffer(getPixelData(_, b, nt), nt), nt), nt)
        }
        if (o.isDataTexture) {
            const _ = o
              , b = c;
            supportedDT(_);
            const _e = buildInfoDT(_, b);
            return fillData(compressData(reorganizeDataBuffer(_.image.data, _e), _e), _e)
        }
    }
}
function supportedRTT(d) {
    if (!d || !d.isWebGLRenderTarget)
        throw Error("EXRExporter.parse: Unsupported second parameter, expected instance of WebGLRenderTarget.");
    if (d.isWebGLCubeRenderTarget || d.isWebGL3DRenderTarget || d.isWebGLArrayRenderTarget)
        throw Error("EXRExporter.parse: Unsupported render target type, expected instance of WebGLRenderTarget.");
    if (d.texture.type !== three_module.RQf && d.texture.type !== three_module.ix0)
        throw Error("EXRExporter.parse: Unsupported WebGLRenderTarget texture type.");
    if (d.texture.format !== three_module.GWd)
        throw Error("EXRExporter.parse: Unsupported WebGLRenderTarget texture format, expected RGBAFormat.")
}
function supportedDT(d) {
    if (d.type !== three_module.RQf && d.type !== three_module.ix0)
        throw Error("EXRExporter.parse: Unsupported DataTexture texture type.");
    if (d.format !== three_module.GWd)
        throw Error("EXRExporter.parse: Unsupported DataTexture texture format, expected RGBAFormat.");
    if (!d.image.data)
        throw Error("EXRExporter.parse: Invalid DataTexture image data.");
    if (d.type === three_module.RQf && d.image.data.constructor.name !== "Float32Array")
        throw Error("EXRExporter.parse: DataTexture image data doesn't match type, expected 'Float32Array'.");
    if (d.type === three_module.ix0 && d.image.data.constructor.name !== "Uint16Array")
        throw Error("EXRExporter.parse: DataTexture image data doesn't match type, expected 'Uint16Array'.")
}
function buildInfoRTT(d, o={}) {
    const c = d.width
      , h = d.height
      , _ = d.texture.type
      , b = d.texture.format
      , _e = (texture.colorSpace,
    o.compression !== void 0 ? o.compression : ZIP_COMPRESSION)
      , nt = (o.type !== void 0 ? o.type : three_module.ix0) === three_module.RQf ? 2 : 1
      , it = {
        0: 1,
        2: 1,
        3: 16
    }[_e];
    return {
        width: c,
        height: h,
        type: _,
        format: b,
        compression: _e,
        blockLines: it,
        dataType: nt,
        dataSize: 2 * nt,
        numBlocks: Math.ceil(h / it),
        numInputChannels: 4,
        numOutputChannels: 4,
        textureIndex: o.textureIndex || 0
    }
}
function buildInfoDT(d, o={}) {
    const c = d.image.width
      , h = d.image.height
      , _ = d.type
      , b = d.format
      , _e = d.colorSpace
      , nt = o.compression !== void 0 ? o.compression : ZIP_COMPRESSION
      , it = (o.type !== void 0 ? o.type : three_module.ix0) === three_module.RQf ? 2 : 1
      , at = {
        0: 1,
        2: 1,
        3: 16
    }[nt];
    return {
        width: c,
        height: h,
        type: _,
        format: b,
        colorSpace: _e,
        compression: nt,
        blockLines: at,
        dataType: it,
        dataSize: 2 * it,
        numBlocks: Math.ceil(h / at),
        numInputChannels: 4,
        numOutputChannels: 4,
        flipY: d.isDataTexture && d.flipY,
        textureIndex: o.textureIndex || 0
    }
}
function getPixelData(d, o, c) {
    let h;
    return h = c.type === three_module.RQf ? new Float32Array(c.width * c.height * c.numInputChannels) : new Uint16Array(c.width * c.height * c.numInputChannels),
    d.readRenderTargetPixels(o, 0, 0, c.width, c.height, h, void 0, c.textureIndex),
    h
}
function reorganizeDataBuffer(d, o) {
    const c = o.width
      , h = o.height
      , _ = {
        r: 0,
        g: 0,
        b: 0,
        a: 0
    }
      , b = {
        value: 0
    }
      , _e = o.numOutputChannels == 4 ? 1 : 0
      , nt = o.type == three_module.RQf ? getFloat32 : getFloat16
      , it = o.dataType == 1 ? setFloat16 : setFloat32
      , at = new Uint8Array(o.width * o.height * o.numOutputChannels * o.dataSize)
      , ut = new DataView(at.buffer);
    for (let pt = 0; pt < h; ++pt)
        for (let ht = 0; ht < c; ++ht) {
            const _t = pt * c * 4 + 4 * ht
              , vt = nt(d, _t)
              , bt = nt(d, _t + 1)
              , St = nt(d, _t + 2)
              , At = nt(d, _t + 3)
              , Et = (o.flipY ? pt : h - pt - 1) * c * (3 + _e) * o.dataSize;
            decodeLinear(_, vt, bt, St, At),
            b.value = Et + ht * o.dataSize,
            it(ut, _.a, b),
            b.value = Et + _e * c * o.dataSize + ht * o.dataSize,
            it(ut, _.b, b),
            b.value = Et + (1 + _e) * c * o.dataSize + ht * o.dataSize,
            it(ut, _.g, b),
            b.value = Et + (2 + _e) * c * o.dataSize + ht * o.dataSize,
            it(ut, _.r, b)
        }
    return at
}
function compressData(d, o) {
    let c, h, _ = 0;
    const b = {
        data: new Array,
        totalSize: 0
    }
      , _e = o.width * o.numOutputChannels * o.blockLines * o.dataSize;
    switch (o.compression) {
    case 0:
        c = compressNONE;
        break;
    case 2:
    case 3:
        c = compressZIP
    }
    o.compression !== 0 && (h = new Uint8Array(_e));
    for (let nt = 0; nt < o.numBlocks; ++nt) {
        const it = c(d.subarray(_e * nt, _e * (nt + 1)), h);
        _ += it.length,
        b.data.push({
            dataChunk: it,
            size: it.length
        })
    }
    return b.totalSize = _,
    b
}
function compressNONE(d) {
    return d
}
function compressZIP(d, o) {
    let c = 0
      , h = Math.floor((d.length + 1) / 2)
      , _ = 0;
    const b = d.length - 1;
    for (; !(_ > b || (o[c++] = d[_++],
    _ > b)); )
        o[h++] = d[_++];
    let _e = o[0];
    for (let nt = 1; nt < o.length; nt++) {
        const it = o[nt] - _e + 384;
        _e = o[nt],
        o[nt] = it
    }
    return fflate_module_zlibSync(o)
}
function fillHeader(d, o, c) {
    const h = {
        value: 0
    }
      , _ = new DataView(d.buffer);
    setUint32(_, 20000630, h),
    setUint32(_, 2, h),
    setString(_, "compression", h),
    setString(_, "compression", h),
    setUint32(_, 1, h),
    setUint8(_, c.compression, h),
    setString(_, "screenWindowCenter", h),
    setString(_, "v2f", h),
    setUint32(_, 8, h),
    setUint32(_, 0, h),
    setUint32(_, 0, h),
    setString(_, "screenWindowWidth", h),
    setString(_, "float", h),
    setUint32(_, 4, h),
    setFloat32(_, 1, h),
    setString(_, "pixelAspectRatio", h),
    setString(_, "float", h),
    setUint32(_, 4, h),
    setFloat32(_, 1, h),
    setString(_, "lineOrder", h),
    setString(_, "lineOrder", h),
    setUint32(_, 1, h),
    setUint8(_, 0, h),
    setString(_, "dataWindow", h),
    setString(_, "box2i", h),
    setUint32(_, 16, h),
    setUint32(_, 0, h),
    setUint32(_, 0, h),
    setUint32(_, c.width - 1, h),
    setUint32(_, c.height - 1, h),
    setString(_, "displayWindow", h),
    setString(_, "box2i", h),
    setUint32(_, 16, h),
    setUint32(_, 0, h),
    setUint32(_, 0, h),
    setUint32(_, c.width - 1, h),
    setUint32(_, c.height - 1, h),
    setString(_, "channels", h),
    setString(_, "chlist", h),
    setUint32(_, 18 * c.numOutputChannels + 1, h),
    setString(_, "A", h),
    setUint32(_, c.dataType, h),
    h.value += 4,
    setUint32(_, 1, h),
    setUint32(_, 1, h),
    setString(_, "B", h),
    setUint32(_, c.dataType, h),
    h.value += 4,
    setUint32(_, 1, h),
    setUint32(_, 1, h),
    setString(_, "G", h),
    setUint32(_, c.dataType, h),
    h.value += 4,
    setUint32(_, 1, h),
    setUint32(_, 1, h),
    setString(_, "R", h),
    setUint32(_, c.dataType, h),
    h.value += 4,
    setUint32(_, 1, h),
    setUint32(_, 1, h),
    setUint8(_, 0, h),
    setUint8(_, 0, h);
    let b = h.value + 8 * c.numBlocks;
    for (let _e = 0; _e < o.data.length; ++_e)
        setUint64(_, b, h),
        b += o.data[_e].size + 8
}
function fillData(d, o) {
    const c = 8 * o.numBlocks
      , h = 259 + 18 * o.numOutputChannels
      , _ = {
        value: h + c
    }
      , b = new Uint8Array(h + c + d.totalSize + 8 * o.numBlocks)
      , _e = new DataView(b.buffer);
    fillHeader(b, d, o);
    for (let nt = 0; nt < d.data.length; ++nt) {
        const it = d.data[nt].dataChunk
          , at = d.data[nt].size;
        setUint32(_e, nt * o.blockLines, _),
        setUint32(_e, at, _),
        b.set(it, _.value),
        _.value += at
    }
    return b
}
function decodeLinear(d, o, c, h, _) {
    d.r = o,
    d.g = c,
    d.b = h,
    d.a = _
}
function setUint8(d, o, c) {
    d.setUint8(c.value, o),
    c.value += 1
}
function setUint32(d, o, c) {
    d.setUint32(c.value, o, !0),
    c.value += 4
}
function setFloat16(d, o, c) {
    d.setUint16(c.value, three_module.GxU.toHalfFloat(o), !0),
    c.value += 2
}
function setFloat32(d, o, c) {
    d.setFloat32(c.value, o, !0),
    c.value += 4
}
function setUint64(d, o, c) {
    d.setBigUint64(c.value, BigInt(o), !0),
    c.value += 8
}
function setString(d, o, c) {
    const h = textEncoder.encode(o + "\0");
    for (let _ = 0; _ < h.length; ++_)
        setUint8(d, h[_], c)
}
function decodeFloat16(d) {
    const o = (31744 & d) >> 10
      , c = 1023 & d;
    return (d >> 15 ? -1 : 1) * (o ? o === 31 ? c ? NaN : 1 / 0 : Math.pow(2, o - 15) * (1 + c / 1024) : c / 1024 * 6103515625e-14)
}
function getFloat16(d, o) {
    return decodeFloat16(d[o])
}
function getFloat32(d, o) {
    return d[o]
}
class EXRExporter2 extends EXRExporter {
    async parseAsync(o, c) {
        const h = o;
        if (h.isWebGLRenderTarget && !o.renderer)
            throw new Error("No renderManager on renderTarget");
        if (!h.isWebGLRenderTarget && !o.isDataTexture)
            throw new Error("Invalid object type");
        h.isWebGLMultipleRenderTargets && c.textureIndex === void 0 && console.warn("No textureIndex specified for WebGLMultipleRenderTargets");
        const _ = h.isWebGLRenderTarget ? this.parse(o.renderer.rendererObject, h, c) : this.parse(o, c);
        return new Blob([_],{
            type: "image/x-exr"
        })
    }
}
class AssetExporter extends I$2 {
    get processors() {
        return this._processors
    }
    getExporter(...o) {
        return this.Exporters.find(c => c.ext.some(h => o.includes(h)))
    }
    constructor(o, c={}) {
        super(),
        this._processors = new ObjectProcessorMap,
        this.Exporters = [{
            ctor: () => new SimpleJSONExporter,
            ext: ["json"]
        }, {
            ctor: () => new SimpleTextExporter,
            ext: ["txt", "text"]
        }, {
            ctor: () => new EXRExporter2,
            ext: ["exr"]
        }],
        this._cachedParsers = [],
        addGLTFExporter(this, o)
    }
    async exportObject(o, c={}) {
        var h, _;
        if (!(o != null && o.assetType))
            return void console.error("Object has no asset type");
        !((h = o == null ? void 0 : o.userData) === null || h === void 0) && h.rootSceneModelRoot && c.viewerConfig === !1 && (o.userData.__exportViewerConfig = !1);
        const b = [];
        o.assetType === "model" && o.modelObject.traverse(nt => {
            nt.userData.excludeFromExport && nt.visible && (nt.visible = !1,
            b.push(nt))
        }
        );
        const _e = await this._exportFile(o, c);
        return o.assetType === "model" && b.forEach(nt => nt.visible = !0),
        !((_ = o == null ? void 0 : o.userData) === null || _ === void 0) && _.rootSceneModelRoot && c.viewerConfig === !1 && delete o.userData.__exportViewerConfig,
        _e
    }
    async _exportFile(o, c={}) {
        var h, _, b;
        let _e;
        this.dispatchEvent({
            type: "exportFile",
            obj: o,
            state: "processing"
        });
        try {
            const nt = await this.processBeforeExport(o, c)
              , it = (_ = (h = c.exportExt) !== null && h !== void 0 ? h : nt == null ? void 0 : nt.typeExt) !== null && _ !== void 0 ? _ : nt == null ? void 0 : nt.ext;
            if (!nt || !it)
                throw new Error(`Unable to preprocess before export ${it}`);
            const at = this._getParser(it);
            this.dispatchEvent({
                type: "exportFile",
                obj: o,
                state: "exporting"
            });
            const ut = await at.parseAsync(nt.obj, {
                exportExt: (b = nt.ext) !== null && b !== void 0 ? b : it,
                ...c
            });
            ut.ext = nt.ext,
            _e = ut
        } catch (nt) {
            return console.error("AssetExporter: Unable to Export file", o),
            console.error(nt),
            void this.dispatchEvent({
                type: "exportFile",
                obj: o,
                state: "error",
                error: nt
            })
        }
        return this.dispatchEvent({
            type: "exportFile",
            obj: o,
            state: "done"
        }),
        _e
    }
    _createParser(o) {
        const c = this.Exporters.find(_ => _.ext.includes(o));
        if (!c)
            throw new Error(`No exporter found for extension ${o}`);
        const h = c == null ? void 0 : c.ctor(this);
        if (!h)
            throw new Error(`Unable to create parser for extension ${o}`);
        return this._cachedParsers.push({
            ext: c.ext,
            parser: h
        }),
        this.dispatchEvent({
            type: "exporterCreate",
            exporter: c,
            parser: h
        }),
        h
    }
    _getParser(o) {
        var c, h;
        return (h = (c = this._cachedParsers.find(_ => _.ext.includes(o))) === null || c === void 0 ? void 0 : c.parser) !== null && h !== void 0 ? h : this._createParser(o)
    }
    async processBeforeExport(o, c={}) {
        if (o.assetType != null && o.assetType !== "renderTarget" && (o = await this._processors.process(o.assetType, o, c)),
        o.isWebGLRenderTarget)
            return {
                obj: o,
                ext: "exr"
            };
        switch (o.assetType) {
        case "light":
            return void console.error("AssetExporter: light export not implemented");
        case "model":
            return {
                obj: o,
                ext: "glb"
            };
        case "material":
            return {
                obj: o.toJSON(),
                ext: o.typeSlug || "json",
                typeExt: "json"
            };
        case "texture":
            return {
                obj: o.toJSON(),
                ext: "json"
            };
        case "renderTarget":
            return {
                obj: o,
                ext: "exr"
            };
        default:
            console.error("AssetExporter: unknown asset type", o.assetType)
        }
    }
    dispose() {
        var o;
        (o = this._processors) === null || o === void 0 || o.dispose()
    }
}
var AssetExporterPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, EncoderMethod;
(function(d) {
    d[d.EDGEBREAKER = 1] = "EDGEBREAKER",
    d[d.SEQUENTIAL = 0] = "SEQUENTIAL"
}
)(EncoderMethod || (EncoderMethod = {}));
class AssetExporterPlugin extends AViewerPlugin {
    constructor(o) {
        super(),
        this.enabled = !0,
        this.exportOptions = {
            compress: !1,
            name: "scene",
            viewerConfig: !0,
            encodeUint16Rgbe: !1,
            convertMeshToIndexed: !1,
            embedUrlImagePreviews: !1,
            embedUrlImages: !1,
            dracoOptions: {
                encodeSpeed: 5,
                method: EncoderMethod.EDGEBREAKER,
                quantizationVolume: "mesh",
                quantizationBits: {
                    POSITION: 14,
                    NORMAL: 10,
                    COLOR: 8,
                    TEX_COORD: 12,
                    GENERIC: 12
                }
            },
            encrypt: !1,
            encryptKey: "",
            ignoreInvalidMorphTargetTracks: !0,
            ignoreEmptyTextures: !0
        },
        this.exporter = o,
        this.exportScene = this.exportScene.bind(this)
    }
    async onAdded(o) {
        await super.onAdded(o),
        this.exporter || (this.exporter = new AssetExporter(o)),
        this.exporter.processors.add("model", {
            forAssetType: "model",
            processAsync: async (c, h) => {
                var _;
                return h.convertMeshToIndexed && ((_ = c.modelObject) === null || _ === void 0 || _.traverse(b => {
                    if (b.geometry && !b.geometry.attributes.index)
                        try {
                            const _e = toIndexedGeometry(b.geometry);
                            b.setGeometry && b.setGeometry(_e)
                        } catch (_e) {
                            console.error("AssetExporterPlugin.convertMeshToIndexed: Error converting geometry to indexed", _e)
                        }
                }
                )),
                c
            }
        })
    }
    async onRemove(o) {
        return super.onRemove(o)
    }
    async exportScene(o) {
        var c, h;
        return (c = this.exporter) === null || c === void 0 ? void 0 : c.exportObject((h = this._viewer) === null || h === void 0 ? void 0 : h.scene.modelRoot, o || {
            ...this.exportOptions
        })
    }
    async downloadSceneGlb() {
        const o = await this.exportScene(this.exportOptions);
        o && await this._downloadBlob(o, this.exportOptions.name + "." + o.ext)
    }
    async _downloadBlob(o, c) {
        var h, _;
        const b = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPluginByType("FileTransferPlugin");
        b ? await b.exportFile(o, c) : (_ = this._viewer) === null || _ === void 0 || _.console.error("FileTransferPlugin required to export/download file")
    }
    get uiConfig() {
        if (this._uiConfig)
            return this._uiConfig;
        const o = this._viewer;
        o.addEventListener("addPlugin", h => {
            var _;
            typeof ((_ = h.plugin) === null || _ === void 0 ? void 0 : _.toJSON) == "function" && console.error("Add all plugins before setting up the export UI, or use `toJSON: any = null` in the plugin ")
        }
        );
        const c = Object.entries(o.plugins).filter( ([h,_]) => typeof (_ == null ? void 0 : _.toJSON) == "function" && (_ == null ? void 0 : _.serializeWithViewer) !== !1).map( ([h,_]) => ({
            label: h,
            type: "checkbox",
            value: !0
        }));
        return this._uiConfig = {
            type: "folder",
            label: "Asset Export",
            limitedUi: !0,
            children: [{
                type: "input",
                property: [this.exportOptions, "name"],
                limitedUi: !0
            }, {
                type: "folder",
                label: "GLB Export",
                limitedUi: !0,
                children: [{
                    type: "checkbox",
                    label: "DRACO Compress",
                    property: [this.exportOptions, "compress"],
                    limitedUi: !0,
                    onChange: () => {
                        var h, _;
                        return (_ = (h = this._uiConfig) === null || h === void 0 ? void 0 : h.uiRefresh) === null || _ === void 0 ? void 0 : _.call(h, "postFrame", !0)
                    }
                }, this.exportOptions.dracoOptions ? {
                    type: "folder",
                    hidden: () => !this.exportOptions.compress,
                    label: "DRACO Options",
                    children: [{
                        type: "slider",
                        label: "Encode Speed",
                        bounds: [1, 10],
                        property: [this.exportOptions.dracoOptions, "encodeSpeed"]
                    }, {
                        type: "dropdown",
                        label: "Encoder Method",
                        property: [this.exportOptions.dracoOptions, "method"],
                        children: Object.entries(EncoderMethod).map( ([h,_]) => ({
                            label: h,
                            value: _
                        }))
                    }, {
                        type: "dropdown",
                        label: "Quantization Volume",
                        property: [this.exportOptions.dracoOptions, "quantizationVolume"],
                        children: ["mesh", "scene", "bbox"].map(h => ({
                            label: h
                        }))
                    }, {
                        type: "folder",
                        label: "Quantization Bits",
                        children: Object.keys(this.exportOptions.dracoOptions.quantizationBits).map(h => ({
                            type: "slider",
                            label: h,
                            bounds: [1, 16],
                            stepSize: 1,
                            property: [this.exportOptions.dracoOptions.quantizationBits, h]
                        }))
                    }]
                } : {}, {
                    type: "checkbox",
                    label: "Scene Settings",
                    property: [this.exportOptions, "viewerConfig"],
                    limitedUi: !0,
                    onChange: () => {
                        var h, _;
                        return (_ = (h = this._uiConfig) === null || h === void 0 ? void 0 : h.uiRefresh) === null || _ === void 0 ? void 0 : _.call(h, "postFrame", !0)
                    }
                }, {
                    type: "checkbox",
                    label: "Embed Image Previews",
                    property: [this.exportOptions, "embedUrlImagePreviews"]
                }, {
                    type: "checkbox",
                    label: "Encrypt",
                    property: [this.exportOptions, "encrypt"],
                    onChange: () => {
                        var h, _;
                        return (_ = (h = this._uiConfig) === null || h === void 0 ? void 0 : h.uiRefresh) === null || _ === void 0 ? void 0 : _.call(h, "postFrame", !0)
                    }
                }, {
                    type: "checkbox",
                    label: "Encrypt Password",
                    hidden: () => !this.exportOptions.encrypt,
                    property: [this.exportOptions, "encryptKey"]
                }, {
                    type: "checkbox",
                    label: "Compress hdr env maps",
                    hidden: () => !this.exportOptions.viewerConfig,
                    property: [this.exportOptions, "encodeUint16Rgbe"]
                }, {
                    type: "checkbox",
                    label: "Convert to indexed",
                    property: [this.exportOptions, "convertMeshToIndexed"]
                }, {
                    type: "checkbox",
                    label: "Ignore invalid animations",
                    property: [this.exportOptions, "ignoreInvalidMorphTargetTracks"]
                }, {
                    type: "checkbox",
                    label: "Ignore invalid textures",
                    property: [this.exportOptions, "ignoreInvalidTextures"]
                }, {
                    type: "button",
                    label: "Export GLB",
                    limitedUi: !0,
                    value: async () => this.downloadSceneGlb()
                }]
            }, {
                type: "folder",
                label: "Preset/Config export",
                children: [{
                    type: "folder",
                    label: "Plugins",
                    children: c
                }, {
                    type: "button",
                    label: "Select none",
                    value: () => {
                        c.forEach(h => {
                            var _;
                            h.value = !1,
                            (_ = h.uiRefresh) === null || _ === void 0 || _.call(h)
                        }
                        )
                    }
                }, {
                    type: "button",
                    label: "Select all",
                    value: () => {
                        c.forEach(h => {
                            var _;
                            h.value = !0,
                            (_ = h.uiRefresh) === null || _ === void 0 || _.call(h)
                        }
                        )
                    }
                }, {
                    type: "button",
                    label: "Export Plugins",
                    limitedUi: !0,
                    value: async () => {
                        const h = new Blob([JSON.stringify(o.getPlugin(AssetManagerPlugin).exportPluginPresets(c.filter(_ => !!_.value).map(_ => Ee$1(_.label) || "")), null, 2)],{
                            type: "application/json"
                        });
                        h && await this._downloadBlob(h, this.exportOptions.name + "." + AssetManagerPlugin.ViewerTypeSlug)
                    }
                }, {
                    type: "button",
                    label: "Export All Viewer Config",
                    limitedUi: !0,
                    value: async () => {
                        const h = new Blob([JSON.stringify(o.getPlugin(AssetManagerPlugin).exportViewerConfig(!1), null, 2)],{
                            type: "application/json"
                        });
                        h && await this._downloadBlob(h, this.exportOptions.name + "." + AssetManagerPlugin.ViewerTypeSlug)
                    }
                }]
            }]
        }
    }
}
AssetExporterPlugin.PluginType = "AssetExporterPlugin",
AssetExporterPlugin_decorate([serialize()], AssetExporterPlugin.prototype, "exportOptions", void 0);
class EventDispatcher {
    constructor() {
        this._listeners = {}
    }
    addEventListener(o, c) {
        const h = this._listeners;
        return h[o] === void 0 && (h[o] = []),
        h[o].indexOf(c) === -1 && h[o].push(c),
        this
    }
    removeEventListener(o, c) {
        const h = this._listeners[o];
        if (h !== void 0) {
            const _ = h.indexOf(c);
            _ !== -1 && h.splice(_, 1)
        }
        return this
    }
    dispatchEvent(o) {
        const c = this._listeners[o.type];
        if (c !== void 0) {
            const h = c.slice(0);
            for (let _ = 0, b = h.length; _ < b; _++)
                h[_].call(this, o)
        }
        return this
    }
    dispose() {
        for (const o in this._listeners)
            delete this._listeners[o]
    }
}
class GraphEdge {
    constructor(o, c, h, _={}) {
        if (this._name = void 0,
        this._parent = void 0,
        this._child = void 0,
        this._attributes = void 0,
        this._disposed = !1,
        this._name = o,
        this._parent = c,
        this._child = h,
        this._attributes = _,
        !c.isOnGraph(h))
            throw new Error("Cannot connect disconnected graphs.")
    }
    getName() {
        return this._name
    }
    getParent() {
        return this._parent
    }
    getChild() {
        return this._child
    }
    setChild(o) {
        return this._child = o,
        this
    }
    getAttributes() {
        return this._attributes
    }
    dispose() {
        this._disposed || (this._parent._destroyRef(this),
        this._disposed = !0)
    }
    isDisposed() {
        return this._disposed
    }
}
class Graph extends EventDispatcher {
    constructor(...o) {
        super(...o),
        this._emptySet = new Set,
        this._edges = new Set,
        this._parentEdges = new Map,
        this._childEdges = new Map
    }
    listEdges() {
        return Array.from(this._edges)
    }
    listParentEdges(o) {
        return Array.from(this._childEdges.get(o) || this._emptySet)
    }
    listParents(o) {
        const c = new Set;
        for (const h of this.listParentEdges(o))
            c.add(h.getParent());
        return Array.from(c)
    }
    listChildEdges(o) {
        return Array.from(this._parentEdges.get(o) || this._emptySet)
    }
    listChildren(o) {
        const c = new Set;
        for (const h of this.listChildEdges(o))
            c.add(h.getChild());
        return Array.from(c)
    }
    disconnectParents(o, c) {
        for (const h of this.listParentEdges(o))
            c && !c(h.getParent()) || h.dispose();
        return this
    }
    _createEdge(o, c, h, _) {
        const b = new GraphEdge(o,c,h,_);
        this._edges.add(b);
        const _e = b.getParent();
        this._parentEdges.has(_e) || this._parentEdges.set(_e, new Set),
        this._parentEdges.get(_e).add(b);
        const nt = b.getChild();
        return this._childEdges.has(nt) || this._childEdges.set(nt, new Set),
        this._childEdges.get(nt).add(b),
        b
    }
    _destroyEdge(o) {
        return this._edges.delete(o),
        this._parentEdges.get(o.getParent()).delete(o),
        this._childEdges.get(o.getChild()).delete(o),
        this
    }
}
function _extends() {
    return _extends = Object.assign || function(d) {
        for (var o = 1; o < arguments.length; o++) {
            var c = arguments[o];
            for (var h in c)
                Object.prototype.hasOwnProperty.call(c, h) && (d[h] = c[h])
        }
        return d
    }
    ,
    _extends.apply(this, arguments)
}
class RefList {
    constructor(o) {
        if (this.list = [],
        o)
            for (const c of o)
                this.list.push(c)
    }
    add(o) {
        this.list.push(o)
    }
    remove(o) {
        const c = this.list.indexOf(o);
        c >= 0 && this.list.splice(c, 1)
    }
    removeChild(o) {
        const c = [];
        for (const h of this.list)
            h.getChild() === o && c.push(h);
        for (const h of c)
            this.remove(h);
        return c
    }
    listRefsByChild(o) {
        const c = [];
        for (const h of this.list)
            h.getChild() === o && c.push(h);
        return c
    }
    values() {
        return this.list
    }
}
class RefSet {
    constructor(o) {
        if (this.set = new Set,
        this.map = new Map,
        o)
            for (const c of o)
                this.add(c)
    }
    add(o) {
        const c = o.getChild();
        this.removeChild(c),
        this.set.add(o),
        this.map.set(c, o)
    }
    remove(o) {
        this.set.delete(o),
        this.map.delete(o.getChild())
    }
    removeChild(o) {
        const c = this.map.get(o) || null;
        return c && this.remove(c),
        c
    }
    getRefByChild(o) {
        return this.map.get(o) || null
    }
    values() {
        return Array.from(this.set)
    }
}
class RefMap {
    constructor(o) {
        this.map = {},
        o && Object.assign(this.map, o)
    }
    set(o, c) {
        this.map[o] = c
    }
    delete(o) {
        delete this.map[o]
    }
    get(o) {
        return this.map[o] || null
    }
    keys() {
        return Object.keys(this.map)
    }
    values() {
        return Object.values(this.map)
    }
}
const $attributes = Symbol("attributes")
  , $immutableKeys = Symbol("immutableKeys");
class GraphNode extends EventDispatcher {
    constructor(o) {
        super(),
        this._disposed = !1,
        this.graph = void 0,
        this[$attributes] = void 0,
        this[$immutableKeys] = void 0,
        this.graph = o,
        this[$immutableKeys] = new Set,
        this[$attributes] = this._createAttributes()
    }
    getDefaults() {
        return {}
    }
    _createAttributes() {
        const o = this.getDefaults()
          , c = {};
        for (const h in o) {
            const _ = o[h];
            if (_ instanceof GraphNode) {
                const b = this.graph._createEdge(h, this, _);
                this[$immutableKeys].add(h),
                c[h] = b
            } else
                c[h] = _
        }
        return c
    }
    isOnGraph(o) {
        return this.graph === o.graph
    }
    isDisposed() {
        return this._disposed
    }
    dispose() {
        this._disposed || (this.graph.listChildEdges(this).forEach(o => o.dispose()),
        this.graph.disconnectParents(this),
        this._disposed = !0,
        this.dispatchEvent({
            type: "dispose"
        }))
    }
    detach() {
        return this.graph.disconnectParents(this),
        this
    }
    swap(o, c) {
        for (const h in this[$attributes]) {
            const _ = this[$attributes][h];
            if (_ instanceof GraphEdge) {
                const b = _;
                b.getChild() === o && this.setRef(h, c, b.getAttributes())
            } else if (_ instanceof RefList)
                for (const b of _.listRefsByChild(o)) {
                    const _e = b.getAttributes();
                    this.removeRef(h, o),
                    this.addRef(h, c, _e)
                }
            else if (_ instanceof RefSet) {
                const b = _.getRefByChild(o);
                if (b) {
                    const _e = b.getAttributes();
                    this.removeRef(h, o),
                    this.addRef(h, c, _e)
                }
            } else if (_ instanceof RefMap)
                for (const b of _.keys()) {
                    const _e = _.get(b);
                    _e.getChild() === o && this.setRefMap(h, b, c, _e.getAttributes())
                }
        }
        return this
    }
    get(o) {
        return this[$attributes][o]
    }
    set(o, c) {
        return this[$attributes][o] = c,
        this.dispatchEvent({
            type: "change",
            attribute: o
        })
    }
    getRef(o) {
        const c = this[$attributes][o];
        return c ? c.getChild() : null
    }
    setRef(o, c, h) {
        if (this[$immutableKeys].has(o))
            throw new Error(`Cannot overwrite immutable attribute, "${o}".`);
        const _ = this[$attributes][o];
        if (_ && _.dispose(),
        !c)
            return this;
        const b = this.graph._createEdge(o, this, c, h);
        return this[$attributes][o] = b,
        this.dispatchEvent({
            type: "change",
            attribute: o
        })
    }
    listRefs(o) {
        return this.assertRefList(o).values().map(c => c.getChild())
    }
    addRef(o, c, h) {
        const _ = this.graph._createEdge(o, this, c, h);
        return this.assertRefList(o).add(_),
        this.dispatchEvent({
            type: "change",
            attribute: o
        })
    }
    removeRef(o, c) {
        const h = this.assertRefList(o);
        if (h instanceof RefList)
            for (const _ of h.listRefsByChild(c))
                _.dispose();
        else {
            const _ = h.getRefByChild(c);
            _ && _.dispose()
        }
        return this
    }
    assertRefList(o) {
        const c = this[$attributes][o];
        if (c instanceof RefList || c instanceof RefSet)
            return c;
        throw new Error(`Expected RefList or RefSet for attribute "${o}"`)
    }
    listRefMapKeys(o) {
        return this.assertRefMap(o).keys()
    }
    listRefMapValues(o) {
        return this.assertRefMap(o).values().map(c => c.getChild())
    }
    getRefMap(o, c) {
        const h = this.assertRefMap(o).get(c);
        return h ? h.getChild() : null
    }
    setRefMap(o, c, h, _) {
        const b = this.assertRefMap(o)
          , _e = b.get(c);
        if (_e && _e.dispose(),
        !h)
            return this;
        _ = Object.assign(_ || {}, {
            key: c
        });
        const nt = this.graph._createEdge(o, this, h, _extends({}, _, {
            key: c
        }));
        return b.set(c, nt),
        this.dispatchEvent({
            type: "change",
            attribute: o,
            key: c
        })
    }
    assertRefMap(o) {
        const c = this[$attributes][o];
        if (c instanceof RefMap)
            return c;
        throw new Error(`Expected RefMap for attribute "${o}"`)
    }
    dispatchEvent(o) {
        return super.dispatchEvent(_extends({}, o, {
            target: this
        })),
        this.graph.dispatchEvent(_extends({}, o, {
            target: this,
            type: `node:${o.type}`
        })),
        this
    }
    _destroyRef(o) {
        const c = o.getName();
        if (this[$attributes][c] === o)
            this[$attributes][c] = null,
            this[$immutableKeys].has(c) && o.getChild().dispose();
        else if (this[$attributes][c]instanceof RefList)
            this[$attributes][c].remove(o);
        else if (this[$attributes][c]instanceof RefSet)
            this[$attributes][c].remove(o);
        else {
            if (!(this[$attributes][c]instanceof RefMap))
                return;
            {
                const h = this[$attributes][c];
                for (const _ of h.keys())
                    h.get(_) === o && h.delete(_)
            }
        }
        this.graph._destroyEdge(o),
        this.dispatchEvent({
            type: "change",
            attribute: c
        })
    }
}
const VERSION = "v4.1.1"
  , GLB_BUFFER = "@glb.bin";
var index_modern_PropertyType, VertexLayout, BufferViewUsage$1, index_modern_TextureChannel, Format;
(function(d) {
    d.ACCESSOR = "Accessor",
    d.ANIMATION = "Animation",
    d.ANIMATION_CHANNEL = "AnimationChannel",
    d.ANIMATION_SAMPLER = "AnimationSampler",
    d.BUFFER = "Buffer",
    d.CAMERA = "Camera",
    d.MATERIAL = "Material",
    d.MESH = "Mesh",
    d.PRIMITIVE = "Primitive",
    d.PRIMITIVE_TARGET = "PrimitiveTarget",
    d.NODE = "Node",
    d.ROOT = "Root",
    d.SCENE = "Scene",
    d.SKIN = "Skin",
    d.TEXTURE = "Texture",
    d.TEXTURE_INFO = "TextureInfo"
}
)(index_modern_PropertyType || (index_modern_PropertyType = {})),
function(d) {
    d.INTERLEAVED = "interleaved",
    d.SEPARATE = "separate"
}(VertexLayout || (VertexLayout = {})),
function(d) {
    d.ARRAY_BUFFER = "ARRAY_BUFFER",
    d.ELEMENT_ARRAY_BUFFER = "ELEMENT_ARRAY_BUFFER",
    d.INVERSE_BIND_MATRICES = "INVERSE_BIND_MATRICES",
    d.OTHER = "OTHER",
    d.SPARSE = "SPARSE"
}(BufferViewUsage$1 || (BufferViewUsage$1 = {})),
function(d) {
    d[d.R = 4096] = "R",
    d[d.G = 256] = "G",
    d[d.B = 16] = "B",
    d[d.A = 1] = "A"
}(index_modern_TextureChannel || (index_modern_TextureChannel = {})),
function(d) {
    d.GLTF = "GLTF",
    d.GLB = "GLB"
}(Format || (Format = {}));
const index_modern_ComponentTypeToTypedArray = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
};
var ARRAY_TYPE = typeof Float32Array < "u" ? Float32Array : Array, _Logger, Verbosity;
function create() {
    var d = new ARRAY_TYPE(3);
    return ARRAY_TYPE != Float32Array && (d[0] = 0,
    d[1] = 0,
    d[2] = 0),
    d
}
function index_modern_length(d) {
    var o = d[0]
      , c = d[1]
      , h = d[2];
    return Math.hypot(o, c, h)
}
function transformMat4(d, o, c) {
    var h = o[0]
      , _ = o[1]
      , b = o[2]
      , _e = c[3] * h + c[7] * _ + c[11] * b + c[15];
    return _e = _e || 1,
    d[0] = (c[0] * h + c[4] * _ + c[8] * b + c[12]) / _e,
    d[1] = (c[1] * h + c[5] * _ + c[9] * b + c[13]) / _e,
    d[2] = (c[2] * h + c[6] * _ + c[10] * b + c[14]) / _e,
    d
}
function getBounds(d) {
    const o = createBounds()
      , c = d.propertyType === index_modern_PropertyType.NODE ? [d] : d.listChildren();
    for (const h of c)
        h.traverse(_ => {
            const b = _.getMesh();
            if (!b)
                return;
            const _e = getMeshBounds(b, _.getWorldMatrix());
            _e.min.every(isFinite) && _e.max.every(isFinite) && (expandBounds(_e.min, o),
            expandBounds(_e.max, o))
        }
        );
    return o
}
function getMeshBounds(d, o) {
    const c = createBounds();
    for (const h of d.listPrimitives()) {
        const _ = h.getAttribute("POSITION")
          , b = h.getIndices();
        if (!_)
            continue;
        let _e = [0, 0, 0]
          , nt = [0, 0, 0];
        for (let it = 0, at = b ? b.getCount() : _.getCount(); it < at; it++) {
            const ut = b ? b.getScalar(it) : it;
            _e = _.getElement(ut, _e),
            nt = transformMat4(nt, _e, o),
            expandBounds(nt, c)
        }
    }
    return c
}
function expandBounds(d, o) {
    for (let c = 0; c < 3; c++)
        o.min[c] = Math.min(d[c], o.min[c]),
        o.max[c] = Math.max(d[c], o.max[c])
}
function createBounds() {
    return {
        min: [1 / 0, 1 / 0, 1 / 0],
        max: [-1 / 0, -1 / 0, -1 / 0]
    }
}
Math.hypot || (Math.hypot = function() {
    for (var d = 0, o = arguments.length; o--; )
        d += arguments[o] * arguments[o];
    return Math.sqrt(d)
}
),
create();
class index_modern_BufferUtils {
    static createBufferFromDataURI(o) {
        if (typeof Buffer > "u") {
            const c = atob(o.split(",")[1])
              , h = new Uint8Array(c.length);
            for (let _ = 0; _ < c.length; _++)
                h[_] = c.charCodeAt(_);
            return h
        }
        {
            const c = o.split(",")[1]
              , h = o.indexOf("base64") >= 0;
            return Buffer.from(c, h ? "base64" : "utf8")
        }
    }
    static encodeText(o) {
        return new TextEncoder().encode(o)
    }
    static decodeText(o) {
        return new TextDecoder().decode(o)
    }
    static concat(o) {
        let c = 0;
        for (const b of o)
            c += b.byteLength;
        const h = new Uint8Array(c);
        let _ = 0;
        for (const b of o)
            h.set(b, _),
            _ += b.byteLength;
        return h
    }
    static pad(o, c=0) {
        const h = this.padNumber(o.byteLength);
        if (h === o.byteLength)
            return o;
        const _ = new Uint8Array(h);
        if (_.set(o),
        c !== 0)
            for (let b = o.byteLength; b < h; b++)
                _[b] = c;
        return _
    }
    static padNumber(o) {
        return 4 * Math.ceil(o / 4)
    }
    static equals(o, c) {
        if (o === c)
            return !0;
        if (o.byteLength !== c.byteLength)
            return !1;
        let h = o.byteLength;
        for (; h--; )
            if (o[h] !== c[h])
                return !1;
        return !0
    }
    static toView(o, c=0, h=1 / 0) {
        return new Uint8Array(o.buffer,o.byteOffset + c,Math.min(o.byteLength, h))
    }
    static assertView(o) {
        if (o && !ArrayBuffer.isView(o))
            throw new Error(`Method requires Uint8Array parameter; received "${typeof o}".`);
        return o
    }
}
class JPEGImageUtils {
    match(o) {
        return o.length >= 3 && o[0] === 255 && o[1] === 216 && o[2] === 255
    }
    getSize(o) {
        let c, h, _ = new DataView(o.buffer,o.byteOffset + 4);
        for (; _.byteLength; ) {
            if (c = _.getUint16(0, !1),
            validateJPEGBuffer(_, c),
            h = _.getUint8(c + 1),
            h === 192 || h === 193 || h === 194)
                return [_.getUint16(c + 7, !1), _.getUint16(c + 5, !1)];
            _ = new DataView(o.buffer,_.byteOffset + c + 2)
        }
        throw new TypeError("Invalid JPG, no size found")
    }
    getChannels(o) {
        return 3
    }
}
class PNGImageUtils {
    match(o) {
        return o.length >= 8 && o[0] === 137 && o[1] === 80 && o[2] === 78 && o[3] === 71 && o[4] === 13 && o[5] === 10 && o[6] === 26 && o[7] === 10
    }
    getSize(o) {
        const c = new DataView(o.buffer,o.byteOffset);
        return index_modern_BufferUtils.decodeText(o.slice(12, 16)) === PNGImageUtils.PNG_FRIED_CHUNK_NAME ? [c.getUint32(32, !1), c.getUint32(36, !1)] : [c.getUint32(16, !1), c.getUint32(20, !1)]
    }
    getChannels(o) {
        return 4
    }
}
PNGImageUtils.PNG_FRIED_CHUNK_NAME = "CgBI";
class index_modern_ImageUtils {
    static registerFormat(o, c) {
        this.impls[o] = c
    }
    static getMimeType(o) {
        for (const c in this.impls)
            if (this.impls[c].match(o))
                return c;
        return null
    }
    static getSize(o, c) {
        return this.impls[c] ? this.impls[c].getSize(o) : null
    }
    static getChannels(o, c) {
        return this.impls[c] ? this.impls[c].getChannels(o) : null
    }
    static getVRAMByteLength(o, c) {
        if (!this.impls[c])
            return null;
        if (this.impls[c].getVRAMByteLength)
            return this.impls[c].getVRAMByteLength(o);
        let h = 0;
        const _ = this.getSize(o, c);
        if (!_)
            return null;
        for (; _[0] > 1 || _[1] > 1; )
            h += _[0] * _[1] * 4,
            _[0] = Math.max(Math.floor(_[0] / 2), 1),
            _[1] = Math.max(Math.floor(_[1] / 2), 1);
        return h += 4,
        h
    }
    static mimeTypeToExtension(o) {
        return o === "image/jpeg" ? "jpg" : o.split("/").pop()
    }
    static extensionToMimeType(o) {
        return o === "jpg" ? "image/jpeg" : o ? `image/${o}` : ""
    }
}
function validateJPEGBuffer(d, o) {
    if (o > d.byteLength)
        throw new TypeError("Corrupt JPG, exceeded buffer limits");
    if (d.getUint8(o) !== 255)
        throw new TypeError("Invalid JPG, marker table corrupted");
    return d
}
index_modern_ImageUtils.impls = {
    "image/jpeg": new JPEGImageUtils,
    "image/png": new PNGImageUtils
};
class index_modern_FileUtils {
    static basename(o) {
        const c = o.split(/[\\/]/).pop();
        return c.substring(0, c.lastIndexOf("."))
    }
    static extension(o) {
        if (o.startsWith("data:image/")) {
            const c = o.match(/data:(image\/\w+)/)[1];
            return index_modern_ImageUtils.mimeTypeToExtension(c)
        }
        return o.startsWith("data:model/gltf+json") ? "gltf" : o.startsWith("data:model/gltf-binary") ? "glb" : o.startsWith("data:application/") ? "bin" : o.split(/[\\/]/).pop().split(/[.]/).pop()
    }
}
function isObject(d) {
    return Object.prototype.toString.call(d) === "[object Object]"
}
function isPlainObject(d) {
    if (isObject(d) === !1)
        return !1;
    const o = d.constructor;
    if (o === void 0)
        return !0;
    const c = o.prototype;
    return isObject(c) !== !1 && Object.prototype.hasOwnProperty.call(c, "isPrototypeOf") !== !1
}
(function(d) {
    d[d.SILENT = 4] = "SILENT",
    d[d.ERROR = 3] = "ERROR",
    d[d.WARN = 2] = "WARN",
    d[d.INFO = 1] = "INFO",
    d[d.DEBUG = 0] = "DEBUG"
}
)(Verbosity || (Verbosity = {}));
class Logger {
    constructor(o) {
        this.verbosity = void 0,
        this.verbosity = o
    }
    debug(o) {
        this.verbosity <= Logger.Verbosity.DEBUG && console.debug(o)
    }
    info(o) {
        this.verbosity <= Logger.Verbosity.INFO && console.info(o)
    }
    warn(o) {
        this.verbosity <= Logger.Verbosity.WARN && console.warn(o)
    }
    error(o) {
        this.verbosity <= Logger.Verbosity.ERROR && console.error(o)
    }
}
function determinant(d) {
    var o = d[0]
      , c = d[1]
      , h = d[2]
      , _ = d[3]
      , b = d[4]
      , _e = d[5]
      , nt = d[6]
      , it = d[7]
      , at = d[8]
      , ut = d[9]
      , pt = d[10]
      , ht = d[11]
      , _t = d[12]
      , vt = d[13]
      , bt = d[14]
      , St = d[15];
    return (o * _e - c * b) * (pt * St - ht * bt) - (o * nt - h * b) * (ut * St - ht * vt) + (o * it - _ * b) * (ut * bt - pt * vt) + (c * nt - h * _e) * (at * St - ht * _t) - (c * it - _ * _e) * (at * bt - pt * _t) + (h * it - _ * nt) * (at * vt - ut * _t)
}
function multiply(d, o, c) {
    var h = o[0]
      , _ = o[1]
      , b = o[2]
      , _e = o[3]
      , nt = o[4]
      , it = o[5]
      , at = o[6]
      , ut = o[7]
      , pt = o[8]
      , ht = o[9]
      , _t = o[10]
      , vt = o[11]
      , bt = o[12]
      , St = o[13]
      , At = o[14]
      , Et = o[15]
      , Pt = c[0]
      , It = c[1]
      , Dt = c[2]
      , Gt = c[3];
    return d[0] = Pt * h + It * nt + Dt * pt + Gt * bt,
    d[1] = Pt * _ + It * it + Dt * ht + Gt * St,
    d[2] = Pt * b + It * at + Dt * _t + Gt * At,
    d[3] = Pt * _e + It * ut + Dt * vt + Gt * Et,
    Pt = c[4],
    It = c[5],
    Dt = c[6],
    Gt = c[7],
    d[4] = Pt * h + It * nt + Dt * pt + Gt * bt,
    d[5] = Pt * _ + It * it + Dt * ht + Gt * St,
    d[6] = Pt * b + It * at + Dt * _t + Gt * At,
    d[7] = Pt * _e + It * ut + Dt * vt + Gt * Et,
    Pt = c[8],
    It = c[9],
    Dt = c[10],
    Gt = c[11],
    d[8] = Pt * h + It * nt + Dt * pt + Gt * bt,
    d[9] = Pt * _ + It * it + Dt * ht + Gt * St,
    d[10] = Pt * b + It * at + Dt * _t + Gt * At,
    d[11] = Pt * _e + It * ut + Dt * vt + Gt * Et,
    Pt = c[12],
    It = c[13],
    Dt = c[14],
    Gt = c[15],
    d[12] = Pt * h + It * nt + Dt * pt + Gt * bt,
    d[13] = Pt * _ + It * it + Dt * ht + Gt * St,
    d[14] = Pt * b + It * at + Dt * _t + Gt * At,
    d[15] = Pt * _e + It * ut + Dt * vt + Gt * Et,
    d
}
function getScaling(d, o) {
    var c = o[0]
      , h = o[1]
      , _ = o[2]
      , b = o[4]
      , _e = o[5]
      , nt = o[6]
      , it = o[8]
      , at = o[9]
      , ut = o[10];
    return d[0] = Math.hypot(c, h, _),
    d[1] = Math.hypot(b, _e, nt),
    d[2] = Math.hypot(it, at, ut),
    d
}
function getRotation(d, o) {
    var c = new ARRAY_TYPE(3);
    getScaling(c, o);
    var h = 1 / c[0]
      , _ = 1 / c[1]
      , b = 1 / c[2]
      , _e = o[0] * h
      , nt = o[1] * _
      , it = o[2] * b
      , at = o[4] * h
      , ut = o[5] * _
      , pt = o[6] * b
      , ht = o[8] * h
      , _t = o[9] * _
      , vt = o[10] * b
      , bt = _e + ut + vt
      , St = 0;
    return bt > 0 ? (St = 2 * Math.sqrt(bt + 1),
    d[3] = .25 * St,
    d[0] = (pt - _t) / St,
    d[1] = (ht - it) / St,
    d[2] = (nt - at) / St) : _e > ut && _e > vt ? (St = 2 * Math.sqrt(1 + _e - ut - vt),
    d[3] = (pt - _t) / St,
    d[0] = .25 * St,
    d[1] = (nt + at) / St,
    d[2] = (ht + it) / St) : ut > vt ? (St = 2 * Math.sqrt(1 + ut - _e - vt),
    d[3] = (ht - it) / St,
    d[0] = (nt + at) / St,
    d[1] = .25 * St,
    d[2] = (pt + _t) / St) : (St = 2 * Math.sqrt(1 + vt - _e - ut),
    d[3] = (nt - at) / St,
    d[0] = (ht + it) / St,
    d[1] = (pt + _t) / St,
    d[2] = .25 * St),
    d
}
_Logger = Logger,
Logger.Verbosity = Verbosity,
Logger.DEFAULT_INSTANCE = new _Logger(_Logger.Verbosity.INFO);
class index_modern_MathUtils {
    static identity(o) {
        return o
    }
    static eq(o, c, h=1e-5) {
        if (o.length !== c.length)
            return !1;
        for (let _ = 0; _ < o.length; _++)
            if (Math.abs(o[_] - c[_]) > h)
                return !1;
        return !0
    }
    static clamp(o, c, h) {
        return o < c ? c : o > h ? h : o
    }
    static decodeNormalizedInt(o, c) {
        switch (c) {
        case 5126:
            return o;
        case 5123:
            return o / 65535;
        case 5121:
            return o / 255;
        case 5122:
            return Math.max(o / 32767, -1);
        case 5120:
            return Math.max(o / 127, -1);
        default:
            throw new Error("Invalid component type.")
        }
    }
    static encodeNormalizedInt(o, c) {
        switch (c) {
        case 5126:
            return o;
        case 5123:
            return Math.round(65535 * index_modern_MathUtils.clamp(o, 0, 1));
        case 5121:
            return Math.round(255 * index_modern_MathUtils.clamp(o, 0, 1));
        case 5122:
            return Math.round(32767 * index_modern_MathUtils.clamp(o, -1, 1));
        case 5120:
            return Math.round(127 * index_modern_MathUtils.clamp(o, -1, 1));
        default:
            throw new Error("Invalid component type.")
        }
    }
    static decompose(o, c, h, _) {
        let b = index_modern_length([o[0], o[1], o[2]]);
        const _e = index_modern_length([o[4], o[5], o[6]])
          , nt = index_modern_length([o[8], o[9], o[10]]);
        determinant(o) < 0 && (b = -b),
        c[0] = o[12],
        c[1] = o[13],
        c[2] = o[14];
        const it = o.slice()
          , at = 1 / b
          , ut = 1 / _e
          , pt = 1 / nt;
        it[0] *= at,
        it[1] *= at,
        it[2] *= at,
        it[4] *= ut,
        it[5] *= ut,
        it[6] *= ut,
        it[8] *= pt,
        it[9] *= pt,
        it[10] *= pt,
        getRotation(h, it),
        _[0] = b,
        _[1] = _e,
        _[2] = nt
    }
    static compose(o, c, h, _) {
        const b = _
          , _e = c[0]
          , nt = c[1]
          , it = c[2]
          , at = c[3]
          , ut = _e + _e
          , pt = nt + nt
          , ht = it + it
          , _t = _e * ut
          , vt = _e * pt
          , bt = _e * ht
          , St = nt * pt
          , At = nt * ht
          , Et = it * ht
          , Pt = at * ut
          , It = at * pt
          , Dt = at * ht
          , Gt = h[0]
          , Bt = h[1]
          , kt = h[2];
        return b[0] = (1 - (St + Et)) * Gt,
        b[1] = (vt + Dt) * Gt,
        b[2] = (bt - It) * Gt,
        b[3] = 0,
        b[4] = (vt - Dt) * Bt,
        b[5] = (1 - (_t + Et)) * Bt,
        b[6] = (At + Pt) * Bt,
        b[7] = 0,
        b[8] = (bt + It) * kt,
        b[9] = (At - Pt) * kt,
        b[10] = (1 - (_t + St)) * kt,
        b[11] = 0,
        b[12] = o[0],
        b[13] = o[1],
        b[14] = o[2],
        b[15] = 1,
        b
    }
}
function equalsRef(d, o) {
    if (!!d != !!o)
        return !1;
    const c = d.getChild()
      , h = o.getChild();
    return c === h || c.equals(h)
}
function equalsRefSet(d, o) {
    if (!!d != !!o)
        return !1;
    const c = d.values()
      , h = o.values();
    if (c.length !== h.length)
        return !1;
    for (let _ = 0; _ < c.length; _++) {
        const b = c[_]
          , _e = h[_];
        if (b.getChild() !== _e.getChild() && !b.getChild().equals(_e.getChild()))
            return !1
    }
    return !0
}
function equalsRefMap(d, o) {
    if (!!d != !!o)
        return !1;
    const c = d.keys()
      , h = o.keys();
    if (c.length !== h.length)
        return !1;
    for (const _ of c) {
        const b = d.get(_)
          , _e = o.get(_);
        if (!!b != !!_e)
            return !1;
        const nt = b.getChild()
          , it = _e.getChild();
        if (nt !== it && !nt.equals(it))
            return !1
    }
    return !0
}
function equalsArray(d, o) {
    if (d === o)
        return !0;
    if (!!d != !!o || !d || !o || d.length !== o.length)
        return !1;
    for (let c = 0; c < d.length; c++)
        if (d[c] !== o[c])
            return !1;
    return !0
}
function equalsObject(d, o) {
    if (d === o)
        return !0;
    if (!!d != !!o)
        return !1;
    if (!isPlainObject(d) || !isPlainObject(o))
        return d === o;
    const c = d
      , h = o;
    let _, b = 0, _e = 0;
    for (_ in c)
        b++;
    for (_ in h)
        _e++;
    if (b !== _e)
        return !1;
    for (_ in c) {
        const nt = c[_]
          , it = h[_];
        if (isArray(nt) && isArray(it)) {
            if (!equalsArray(nt, it))
                return !1
        } else if (isPlainObject(nt) && isPlainObject(it)) {
            if (!equalsObject(nt, it))
                return !1
        } else if (nt !== it)
            return !1
    }
    return !0
}
function isArray(d) {
    return Array.isArray(d) || ArrayBuffer.isView(d)
}
const ALPHABET = "23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ"
  , UNIQUE_RETRIES = 999
  , ID_LENGTH = 6
  , previousIDs = new Set
  , generateOne = function() {
    let d = "";
    for (let o = 0; o < ID_LENGTH; o++)
        d += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));
    return d
}
  , index_modern_uuid = function() {
    for (let d = 0; d < UNIQUE_RETRIES; d++) {
        const o = generateOne();
        if (!previousIDs.has(o))
            return previousIDs.add(o),
            o
    }
    return ""
}
  , NULL_DOMAIN = "https://null.example";
class HTTPUtils {
    static dirname(o) {
        const c = o.lastIndexOf("/");
        return c === -1 ? "./" : o.substring(0, c + 1)
    }
    static basename(o) {
        return index_modern_FileUtils.basename(new URL(o,NULL_DOMAIN).pathname)
    }
    static extension(o) {
        return index_modern_FileUtils.extension(new URL(o,NULL_DOMAIN).pathname)
    }
    static resolve(o, c) {
        if (!this.isRelativePath(c))
            return c;
        const h = o.split("/")
          , _ = c.split("/");
        h.pop();
        for (let b = 0; b < _.length; b++)
            _[b] !== "." && (_[b] === ".." ? h.pop() : h.push(_[b]));
        return h.join("/")
    }
    static isAbsoluteURL(o) {
        return this.PROTOCOL_REGEXP.test(o)
    }
    static isRelativePath(o) {
        return !/^(?:[a-zA-Z]+:)?\//.test(o)
    }
}
HTTPUtils.DEFAULT_INIT = {},
HTTPUtils.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;
const COPY_IDENTITY = d => d
  , EMPTY_SET = new Set;
class Property extends GraphNode {
    constructor(o, c="") {
        super(o),
        this[$attributes].name = c,
        this.init(),
        this.dispatchEvent({
            type: "create"
        })
    }
    getGraph() {
        return this.graph
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            name: "",
            extras: {}
        })
    }
    set(o, c) {
        return Array.isArray(c) && (c = c.slice()),
        super.set(o, c)
    }
    getName() {
        return this.get("name")
    }
    setName(o) {
        return this.set("name", o)
    }
    getExtras() {
        return this.get("extras")
    }
    setExtras(o) {
        return this.set("extras", o)
    }
    clone() {
        return new this.constructor(this.graph).copy(this, COPY_IDENTITY)
    }
    copy(o, c=COPY_IDENTITY) {
        for (const h in this[$attributes]) {
            const _ = this[$attributes][h];
            if (_ instanceof GraphEdge)
                this[$immutableKeys].has(h) || _.dispose();
            else if (_ instanceof RefList || _ instanceof RefSet)
                for (const b of _.values())
                    b.dispose();
            else if (_ instanceof RefMap)
                for (const b of _.values())
                    b.dispose()
        }
        for (const h in o[$attributes]) {
            const _ = this[$attributes][h]
              , b = o[$attributes][h];
            if (b instanceof GraphEdge)
                this[$immutableKeys].has(h) ? _.getChild().copy(c(b.getChild()), c) : this.setRef(h, c(b.getChild()), b.getAttributes());
            else if (b instanceof RefSet || b instanceof RefList)
                for (const _e of b.values())
                    this.addRef(h, c(_e.getChild()), _e.getAttributes());
            else if (b instanceof RefMap)
                for (const _e of b.keys()) {
                    const nt = b.get(_e);
                    this.setRefMap(h, _e, c(nt.getChild()), nt.getAttributes())
                }
            else
                isPlainObject(b) ? this[$attributes][h] = JSON.parse(JSON.stringify(b)) : Array.isArray(b) || b instanceof ArrayBuffer || ArrayBuffer.isView(b) ? this[$attributes][h] = b.slice() : this[$attributes][h] = b
        }
        return this
    }
    equals(o, c=EMPTY_SET) {
        if (this === o)
            return !0;
        if (this.propertyType !== o.propertyType)
            return !1;
        for (const h in this[$attributes]) {
            if (c.has(h))
                continue;
            const _ = this[$attributes][h]
              , b = o[$attributes][h];
            if (_ instanceof GraphEdge || b instanceof GraphEdge) {
                if (!equalsRef(_, b))
                    return !1
            } else if (_ instanceof RefSet || b instanceof RefSet || _ instanceof RefList || b instanceof RefList) {
                if (!equalsRefSet(_, b))
                    return !1
            } else if (_ instanceof RefMap || b instanceof RefMap) {
                if (!equalsRefMap(_, b))
                    return !1
            } else if (isPlainObject(_) || isPlainObject(b)) {
                if (!equalsObject(_, b))
                    return !1
            } else if (isArray(_) || isArray(b)) {
                if (!equalsArray(_, b))
                    return !1
            } else if (_ !== b)
                return !1
        }
        return !0
    }
    detach() {
        return this.graph.disconnectParents(this, o => o.propertyType !== "Root"),
        this
    }
    listParents() {
        return this.graph.listParents(this)
    }
}
class ExtensibleProperty extends Property {
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            extensions: new RefMap
        })
    }
    getExtension(o) {
        return this.getRefMap("extensions", o)
    }
    setExtension(o, c) {
        return c && c._validateParent(this),
        this.setRefMap("extensions", o, c)
    }
    listExtensions() {
        return this.listRefMapValues("extensions")
    }
}
class index_modern_Accessor extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.ACCESSOR
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            array: null,
            type: index_modern_Accessor.Type.SCALAR,
            componentType: index_modern_Accessor.ComponentType.FLOAT,
            normalized: !1,
            sparse: !1,
            buffer: null
        })
    }
    static getElementSize(o) {
        switch (o) {
        case index_modern_Accessor.Type.SCALAR:
            return 1;
        case index_modern_Accessor.Type.VEC2:
            return 2;
        case index_modern_Accessor.Type.VEC3:
            return 3;
        case index_modern_Accessor.Type.VEC4:
        case index_modern_Accessor.Type.MAT2:
            return 4;
        case index_modern_Accessor.Type.MAT3:
            return 9;
        case index_modern_Accessor.Type.MAT4:
            return 16;
        default:
            throw new Error("Unexpected type: " + o)
        }
    }
    static getComponentSize(o) {
        switch (o) {
        case index_modern_Accessor.ComponentType.BYTE:
        case index_modern_Accessor.ComponentType.UNSIGNED_BYTE:
            return 1;
        case index_modern_Accessor.ComponentType.SHORT:
        case index_modern_Accessor.ComponentType.UNSIGNED_SHORT:
            return 2;
        case index_modern_Accessor.ComponentType.UNSIGNED_INT:
        case index_modern_Accessor.ComponentType.FLOAT:
            return 4;
        default:
            throw new Error("Unexpected component type: " + o)
        }
    }
    getMinNormalized(o) {
        const c = this.getNormalized()
          , h = this.getElementSize()
          , _ = this.getComponentType();
        if (this.getMin(o),
        c)
            for (let b = 0; b < h; b++)
                o[b] = index_modern_MathUtils.decodeNormalizedInt(o[b], _);
        return o
    }
    getMin(o) {
        const c = this.getArray()
          , h = this.getCount()
          , _ = this.getElementSize();
        for (let b = 0; b < _; b++)
            o[b] = 1 / 0;
        for (let b = 0; b < h * _; b += _)
            for (let _e = 0; _e < _; _e++) {
                const nt = c[b + _e];
                Number.isFinite(nt) && (o[_e] = Math.min(o[_e], nt))
            }
        return o
    }
    getMaxNormalized(o) {
        const c = this.getNormalized()
          , h = this.getElementSize()
          , _ = this.getComponentType();
        if (this.getMax(o),
        c)
            for (let b = 0; b < h; b++)
                o[b] = index_modern_MathUtils.decodeNormalizedInt(o[b], _);
        return o
    }
    getMax(o) {
        const c = this.get("array")
          , h = this.getCount()
          , _ = this.getElementSize();
        for (let b = 0; b < _; b++)
            o[b] = -1 / 0;
        for (let b = 0; b < h * _; b += _)
            for (let _e = 0; _e < _; _e++) {
                const nt = c[b + _e];
                Number.isFinite(nt) && (o[_e] = Math.max(o[_e], nt))
            }
        return o
    }
    getCount() {
        const o = this.get("array");
        return o ? o.length / this.getElementSize() : 0
    }
    getType() {
        return this.get("type")
    }
    setType(o) {
        return this.set("type", o)
    }
    getElementSize() {
        return index_modern_Accessor.getElementSize(this.get("type"))
    }
    getComponentSize() {
        return this.get("array").BYTES_PER_ELEMENT
    }
    getComponentType() {
        return this.get("componentType")
    }
    getNormalized() {
        return this.get("normalized")
    }
    setNormalized(o) {
        return this.set("normalized", o)
    }
    getScalar(o) {
        const c = this.getElementSize()
          , h = this.getComponentType()
          , _ = this.getArray();
        return this.getNormalized() ? index_modern_MathUtils.decodeNormalizedInt(_[o * c], h) : _[o * c]
    }
    setScalar(o, c) {
        const h = this.getElementSize()
          , _ = this.getComponentType()
          , b = this.getArray();
        return this.getNormalized() ? b[o * h] = index_modern_MathUtils.encodeNormalizedInt(c, _) : b[o * h] = c,
        this
    }
    getElement(o, c) {
        const h = this.getNormalized()
          , _ = this.getElementSize()
          , b = this.getComponentType()
          , _e = this.getArray();
        for (let nt = 0; nt < _; nt++)
            c[nt] = h ? index_modern_MathUtils.decodeNormalizedInt(_e[o * _ + nt], b) : _e[o * _ + nt];
        return c
    }
    setElement(o, c) {
        const h = this.getNormalized()
          , _ = this.getElementSize()
          , b = this.getComponentType()
          , _e = this.getArray();
        for (let nt = 0; nt < _; nt++)
            _e[o * _ + nt] = h ? index_modern_MathUtils.encodeNormalizedInt(c[nt], b) : c[nt];
        return this
    }
    getSparse() {
        return this.get("sparse")
    }
    setSparse(o) {
        return this.set("sparse", o)
    }
    getBuffer() {
        return this.getRef("buffer")
    }
    setBuffer(o) {
        return this.setRef("buffer", o)
    }
    getArray() {
        return this.get("array")
    }
    setArray(o) {
        return this.set("componentType", o ? arrayToComponentType(o) : index_modern_Accessor.ComponentType.FLOAT),
        this.set("array", o),
        this
    }
    getByteLength() {
        const o = this.get("array");
        return o ? o.byteLength : 0
    }
}
function arrayToComponentType(d) {
    switch (d.constructor) {
    case Float32Array:
        return index_modern_Accessor.ComponentType.FLOAT;
    case Uint32Array:
        return index_modern_Accessor.ComponentType.UNSIGNED_INT;
    case Uint16Array:
        return index_modern_Accessor.ComponentType.UNSIGNED_SHORT;
    case Uint8Array:
        return index_modern_Accessor.ComponentType.UNSIGNED_BYTE;
    case Int16Array:
        return index_modern_Accessor.ComponentType.SHORT;
    case Int8Array:
        return index_modern_Accessor.ComponentType.BYTE;
    default:
        throw new Error("Unknown accessor componentType.")
    }
}
index_modern_Accessor.Type = {
    SCALAR: "SCALAR",
    VEC2: "VEC2",
    VEC3: "VEC3",
    VEC4: "VEC4",
    MAT2: "MAT2",
    MAT3: "MAT3",
    MAT4: "MAT4"
},
index_modern_Accessor.ComponentType = {
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_INT: 5125,
    FLOAT: 5126
};
class Animation extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.ANIMATION
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            channels: new RefSet,
            samplers: new RefSet
        })
    }
    addChannel(o) {
        return this.addRef("channels", o)
    }
    removeChannel(o) {
        return this.removeRef("channels", o)
    }
    listChannels() {
        return this.listRefs("channels")
    }
    addSampler(o) {
        return this.addRef("samplers", o)
    }
    removeSampler(o) {
        return this.removeRef("samplers", o)
    }
    listSamplers() {
        return this.listRefs("samplers")
    }
}
class index_modern_AnimationChannel extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.ANIMATION_CHANNEL
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            targetPath: null,
            targetNode: null,
            sampler: null
        })
    }
    getTargetPath() {
        return this.get("targetPath")
    }
    setTargetPath(o) {
        return this.set("targetPath", o)
    }
    getTargetNode() {
        return this.getRef("targetNode")
    }
    setTargetNode(o) {
        return this.setRef("targetNode", o)
    }
    getSampler() {
        return this.getRef("sampler")
    }
    setSampler(o) {
        return this.setRef("sampler", o)
    }
}
index_modern_AnimationChannel.TargetPath = {
    TRANSLATION: "translation",
    ROTATION: "rotation",
    SCALE: "scale",
    WEIGHTS: "weights"
};
class index_modern_AnimationSampler extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.ANIMATION_SAMPLER
    }
    getDefaultAttributes() {
        return Object.assign(super.getDefaults(), {
            interpolation: index_modern_AnimationSampler.Interpolation.LINEAR,
            input: null,
            output: null
        })
    }
    getInterpolation() {
        return this.get("interpolation")
    }
    setInterpolation(o) {
        return this.set("interpolation", o)
    }
    getInput() {
        return this.getRef("input")
    }
    setInput(o) {
        return this.setRef("input", o, {
            usage: BufferViewUsage$1.OTHER
        })
    }
    getOutput() {
        return this.getRef("output")
    }
    setOutput(o) {
        return this.setRef("output", o, {
            usage: BufferViewUsage$1.OTHER
        })
    }
}
index_modern_AnimationSampler.Interpolation = {
    LINEAR: "LINEAR",
    STEP: "STEP",
    CUBICSPLINE: "CUBICSPLINE"
};
class Buffer$1 extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.BUFFER
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            uri: ""
        })
    }
    getURI() {
        return this.get("uri")
    }
    setURI(o) {
        return this.set("uri", o)
    }
}
class Camera extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.CAMERA
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            type: Camera.Type.PERSPECTIVE,
            znear: .1,
            zfar: 100,
            aspectRatio: null,
            yfov: 2 * Math.PI * 50 / 360,
            xmag: 1,
            ymag: 1
        })
    }
    getType() {
        return this.get("type")
    }
    setType(o) {
        return this.set("type", o)
    }
    getZNear() {
        return this.get("znear")
    }
    setZNear(o) {
        return this.set("znear", o)
    }
    getZFar() {
        return this.get("zfar")
    }
    setZFar(o) {
        return this.set("zfar", o)
    }
    getAspectRatio() {
        return this.get("aspectRatio")
    }
    setAspectRatio(o) {
        return this.set("aspectRatio", o)
    }
    getYFov() {
        return this.get("yfov")
    }
    setYFov(o) {
        return this.set("yfov", o)
    }
    getXMag() {
        return this.get("xmag")
    }
    setXMag(o) {
        return this.set("xmag", o)
    }
    getYMag() {
        return this.get("ymag")
    }
    setYMag(o) {
        return this.set("ymag", o)
    }
}
Camera.Type = {
    PERSPECTIVE: "perspective",
    ORTHOGRAPHIC: "orthographic"
};
class index_modern_ExtensionProperty extends Property {
    _validateParent(o) {
        if (!this.parentTypes.includes(o.propertyType))
            throw new Error(`Parent "${o.propertyType}" invalid for child "${this.propertyType}".`)
    }
}
index_modern_ExtensionProperty.EXTENSION_NAME = void 0;
class index_modern_TextureInfo extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.TEXTURE_INFO
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            texCoord: 0,
            magFilter: null,
            minFilter: null,
            wrapS: index_modern_TextureInfo.WrapMode.REPEAT,
            wrapT: index_modern_TextureInfo.WrapMode.REPEAT
        })
    }
    getTexCoord() {
        return this.get("texCoord")
    }
    setTexCoord(o) {
        return this.set("texCoord", o)
    }
    getMagFilter() {
        return this.get("magFilter")
    }
    setMagFilter(o) {
        return this.set("magFilter", o)
    }
    getMinFilter() {
        return this.get("minFilter")
    }
    setMinFilter(o) {
        return this.set("minFilter", o)
    }
    getWrapS() {
        return this.get("wrapS")
    }
    setWrapS(o) {
        return this.set("wrapS", o)
    }
    getWrapT() {
        return this.get("wrapT")
    }
    setWrapT(o) {
        return this.set("wrapT", o)
    }
}
index_modern_TextureInfo.WrapMode = {
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    REPEAT: 10497
},
index_modern_TextureInfo.MagFilter = {
    NEAREST: 9728,
    LINEAR: 9729
},
index_modern_TextureInfo.MinFilter = {
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987
};
const {R: index_modern_R, G: index_modern_G, B: index_modern_B, A: index_modern_A} = index_modern_TextureChannel;
class index_modern_Material extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.MATERIAL
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            alphaMode: index_modern_Material.AlphaMode.OPAQUE,
            alphaCutoff: .5,
            doubleSided: !1,
            baseColorFactor: [1, 1, 1, 1],
            baseColorTexture: null,
            baseColorTextureInfo: new index_modern_TextureInfo(this.graph,"baseColorTextureInfo"),
            emissiveFactor: [0, 0, 0],
            emissiveTexture: null,
            emissiveTextureInfo: new index_modern_TextureInfo(this.graph,"emissiveTextureInfo"),
            normalScale: 1,
            normalTexture: null,
            normalTextureInfo: new index_modern_TextureInfo(this.graph,"normalTextureInfo"),
            occlusionStrength: 1,
            occlusionTexture: null,
            occlusionTextureInfo: new index_modern_TextureInfo(this.graph,"occlusionTextureInfo"),
            roughnessFactor: 1,
            metallicFactor: 1,
            metallicRoughnessTexture: null,
            metallicRoughnessTextureInfo: new index_modern_TextureInfo(this.graph,"metallicRoughnessTextureInfo")
        })
    }
    getDoubleSided() {
        return this.get("doubleSided")
    }
    setDoubleSided(o) {
        return this.set("doubleSided", o)
    }
    getAlpha() {
        return this.get("baseColorFactor")[3]
    }
    setAlpha(o) {
        const c = this.get("baseColorFactor").slice();
        return c[3] = o,
        this.set("baseColorFactor", c)
    }
    getAlphaMode() {
        return this.get("alphaMode")
    }
    setAlphaMode(o) {
        return this.set("alphaMode", o)
    }
    getAlphaCutoff() {
        return this.get("alphaCutoff")
    }
    setAlphaCutoff(o) {
        return this.set("alphaCutoff", o)
    }
    getBaseColorFactor() {
        return this.get("baseColorFactor")
    }
    setBaseColorFactor(o) {
        return this.set("baseColorFactor", o)
    }
    getBaseColorTexture() {
        return this.getRef("baseColorTexture")
    }
    getBaseColorTextureInfo() {
        return this.getRef("baseColorTexture") ? this.getRef("baseColorTextureInfo") : null
    }
    setBaseColorTexture(o) {
        return this.setRef("baseColorTexture", o, {
            channels: index_modern_R | index_modern_G | index_modern_B | index_modern_A,
            isColor: !0
        })
    }
    getEmissiveFactor() {
        return this.get("emissiveFactor")
    }
    setEmissiveFactor(o) {
        return this.set("emissiveFactor", o)
    }
    getEmissiveTexture() {
        return this.getRef("emissiveTexture")
    }
    getEmissiveTextureInfo() {
        return this.getRef("emissiveTexture") ? this.getRef("emissiveTextureInfo") : null
    }
    setEmissiveTexture(o) {
        return this.setRef("emissiveTexture", o, {
            channels: index_modern_R | index_modern_G | index_modern_B,
            isColor: !0
        })
    }
    getNormalScale() {
        return this.get("normalScale")
    }
    setNormalScale(o) {
        return this.set("normalScale", o)
    }
    getNormalTexture() {
        return this.getRef("normalTexture")
    }
    getNormalTextureInfo() {
        return this.getRef("normalTexture") ? this.getRef("normalTextureInfo") : null
    }
    setNormalTexture(o) {
        return this.setRef("normalTexture", o, {
            channels: index_modern_R | index_modern_G | index_modern_B
        })
    }
    getOcclusionStrength() {
        return this.get("occlusionStrength")
    }
    setOcclusionStrength(o) {
        return this.set("occlusionStrength", o)
    }
    getOcclusionTexture() {
        return this.getRef("occlusionTexture")
    }
    getOcclusionTextureInfo() {
        return this.getRef("occlusionTexture") ? this.getRef("occlusionTextureInfo") : null
    }
    setOcclusionTexture(o) {
        return this.setRef("occlusionTexture", o, {
            channels: index_modern_R
        })
    }
    getRoughnessFactor() {
        return this.get("roughnessFactor")
    }
    setRoughnessFactor(o) {
        return this.set("roughnessFactor", o)
    }
    getMetallicFactor() {
        return this.get("metallicFactor")
    }
    setMetallicFactor(o) {
        return this.set("metallicFactor", o)
    }
    getMetallicRoughnessTexture() {
        return this.getRef("metallicRoughnessTexture")
    }
    getMetallicRoughnessTextureInfo() {
        return this.getRef("metallicRoughnessTexture") ? this.getRef("metallicRoughnessTextureInfo") : null
    }
    setMetallicRoughnessTexture(o) {
        return this.setRef("metallicRoughnessTexture", o, {
            channels: index_modern_G | index_modern_B
        })
    }
}
index_modern_Material.AlphaMode = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
class index_modern_Mesh extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.MESH
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            weights: [],
            primitives: new RefSet
        })
    }
    addPrimitive(o) {
        return this.addRef("primitives", o)
    }
    removePrimitive(o) {
        return this.removeRef("primitives", o)
    }
    listPrimitives() {
        return this.listRefs("primitives")
    }
    getWeights() {
        return this.get("weights")
    }
    setWeights(o) {
        return this.set("weights", o)
    }
}
class index_modern_Node extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.NODE
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            translation: [0, 0, 0],
            rotation: [0, 0, 0, 1],
            scale: [1, 1, 1],
            weights: [],
            camera: null,
            mesh: null,
            skin: null,
            children: new RefSet
        })
    }
    copy(o, c=COPY_IDENTITY) {
        if (c === COPY_IDENTITY)
            throw new Error("Node cannot be copied.");
        return super.copy(o, c)
    }
    getTranslation() {
        return this.get("translation")
    }
    getRotation() {
        return this.get("rotation")
    }
    getScale() {
        return this.get("scale")
    }
    setTranslation(o) {
        return this.set("translation", o)
    }
    setRotation(o) {
        return this.set("rotation", o)
    }
    setScale(o) {
        return this.set("scale", o)
    }
    getMatrix() {
        return index_modern_MathUtils.compose(this.get("translation"), this.get("rotation"), this.get("scale"), [])
    }
    setMatrix(o) {
        const c = this.get("translation").slice()
          , h = this.get("rotation").slice()
          , _ = this.get("scale").slice();
        return index_modern_MathUtils.decompose(o, c, h, _),
        this.set("translation", c).set("rotation", h).set("scale", _)
    }
    getWorldTranslation() {
        const o = [0, 0, 0];
        return index_modern_MathUtils.decompose(this.getWorldMatrix(), o, [0, 0, 0, 1], [1, 1, 1]),
        o
    }
    getWorldRotation() {
        const o = [0, 0, 0, 1];
        return index_modern_MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], o, [1, 1, 1]),
        o
    }
    getWorldScale() {
        const o = [1, 1, 1];
        return index_modern_MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], o),
        o
    }
    getWorldMatrix() {
        const o = [];
        for (let _ = this; _ != null; _ = _.getParentNode())
            o.push(_);
        let c;
        const h = o.pop().getMatrix();
        for (; c = o.pop(); )
            multiply(h, h, c.getMatrix());
        return h
    }
    addChild(o) {
        const c = o.getParentNode();
        c && c.removeChild(o);
        for (const h of o.listParents())
            h.propertyType === index_modern_PropertyType.SCENE && h.removeChild(o);
        return this.addRef("children", o)
    }
    removeChild(o) {
        return this.removeRef("children", o)
    }
    listChildren() {
        return this.listRefs("children")
    }
    getParentNode() {
        for (const o of this.listParents())
            if (o.propertyType === index_modern_PropertyType.NODE)
                return o;
        return null
    }
    getMesh() {
        return this.getRef("mesh")
    }
    setMesh(o) {
        return this.setRef("mesh", o)
    }
    getCamera() {
        return this.getRef("camera")
    }
    setCamera(o) {
        return this.setRef("camera", o)
    }
    getSkin() {
        return this.getRef("skin")
    }
    setSkin(o) {
        return this.setRef("skin", o)
    }
    getWeights() {
        return this.get("weights")
    }
    setWeights(o) {
        return this.set("weights", o)
    }
    traverse(o) {
        o(this);
        for (const c of this.listChildren())
            c.traverse(o);
        return this
    }
}
class index_modern_Primitive extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.PRIMITIVE
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            mode: index_modern_Primitive.Mode.TRIANGLES,
            material: null,
            indices: null,
            attributes: new RefMap,
            targets: new RefSet
        })
    }
    getIndices() {
        return this.getRef("indices")
    }
    setIndices(o) {
        return this.setRef("indices", o, {
            usage: BufferViewUsage$1.ELEMENT_ARRAY_BUFFER
        })
    }
    getAttribute(o) {
        return this.getRefMap("attributes", o)
    }
    setAttribute(o, c) {
        return this.setRefMap("attributes", o, c, {
            usage: BufferViewUsage$1.ARRAY_BUFFER
        })
    }
    listAttributes() {
        return this.listRefMapValues("attributes")
    }
    listSemantics() {
        return this.listRefMapKeys("attributes")
    }
    getMaterial() {
        return this.getRef("material")
    }
    setMaterial(o) {
        return this.setRef("material", o)
    }
    getMode() {
        return this.get("mode")
    }
    setMode(o) {
        return this.set("mode", o)
    }
    listTargets() {
        return this.listRefs("targets")
    }
    addTarget(o) {
        return this.addRef("targets", o)
    }
    removeTarget(o) {
        return this.removeRef("targets", o)
    }
}
index_modern_Primitive.Mode = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
};
class index_modern_PrimitiveTarget extends Property {
    init() {
        this.propertyType = index_modern_PropertyType.PRIMITIVE_TARGET
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            attributes: new RefMap
        })
    }
    getAttribute(o) {
        return this.getRefMap("attributes", o)
    }
    setAttribute(o, c) {
        return this.setRefMap("attributes", o, c, {
            usage: BufferViewUsage$1.ARRAY_BUFFER
        })
    }
    listAttributes() {
        return this.listRefMapValues("attributes")
    }
    listSemantics() {
        return this.listRefMapKeys("attributes")
    }
}
function index_modern_extends() {
    return index_modern_extends = Object.assign ? Object.assign.bind() : function(d) {
        for (var o = 1; o < arguments.length; o++) {
            var c = arguments[o];
            for (var h in c)
                ({}).hasOwnProperty.call(c, h) && (d[h] = c[h])
        }
        return d
    }
    ,
    index_modern_extends.apply(null, arguments)
}
class index_modern_Scene extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.SCENE
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            children: new RefSet
        })
    }
    copy(o, c=COPY_IDENTITY) {
        if (c === COPY_IDENTITY)
            throw new Error("Scene cannot be copied.");
        return super.copy(o, c)
    }
    addChild(o) {
        const c = o.getParentNode();
        return c && c.removeChild(o),
        this.addRef("children", o)
    }
    removeChild(o) {
        return this.removeRef("children", o)
    }
    listChildren() {
        return this.listRefs("children")
    }
    traverse(o) {
        for (const c of this.listChildren())
            c.traverse(o);
        return this
    }
}
class Skin extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.SKIN
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            skeleton: null,
            inverseBindMatrices: null,
            joints: new RefSet
        })
    }
    getSkeleton() {
        return this.getRef("skeleton")
    }
    setSkeleton(o) {
        return this.setRef("skeleton", o)
    }
    getInverseBindMatrices() {
        return this.getRef("inverseBindMatrices")
    }
    setInverseBindMatrices(o) {
        return this.setRef("inverseBindMatrices", o, {
            usage: BufferViewUsage$1.INVERSE_BIND_MATRICES
        })
    }
    addJoint(o) {
        return this.addRef("joints", o)
    }
    removeJoint(o) {
        return this.removeRef("joints", o)
    }
    listJoints() {
        return this.listRefs("joints")
    }
}
class index_modern_Texture extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.TEXTURE
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            image: null,
            mimeType: "",
            uri: ""
        })
    }
    getMimeType() {
        return this.get("mimeType") || index_modern_ImageUtils.extensionToMimeType(index_modern_FileUtils.extension(this.get("uri")))
    }
    setMimeType(o) {
        return this.set("mimeType", o)
    }
    getURI() {
        return this.get("uri")
    }
    setURI(o) {
        this.set("uri", o);
        const c = index_modern_ImageUtils.extensionToMimeType(index_modern_FileUtils.extension(o));
        return c && this.set("mimeType", c),
        this
    }
    getImage() {
        return this.get("image")
    }
    setImage(o) {
        return this.set("image", index_modern_BufferUtils.assertView(o))
    }
    getSize() {
        const o = this.get("image");
        return o ? index_modern_ImageUtils.getSize(o, this.getMimeType()) : null
    }
}
class index_modern_Root extends ExtensibleProperty {
    init() {
        this.propertyType = index_modern_PropertyType.ROOT
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            asset: {
                generator: `glTF-Transform ${VERSION}`,
                version: "2.0"
            },
            defaultScene: null,
            accessors: new RefSet,
            animations: new RefSet,
            buffers: new RefSet,
            cameras: new RefSet,
            materials: new RefSet,
            meshes: new RefSet,
            nodes: new RefSet,
            scenes: new RefSet,
            skins: new RefSet,
            textures: new RefSet
        })
    }
    constructor(o) {
        super(o),
        this._extensions = new Set,
        o.addEventListener("node:create", c => {
            this._addChildOfRoot(c.target)
        }
        )
    }
    clone() {
        throw new Error("Root cannot be cloned.")
    }
    copy(o, c=COPY_IDENTITY) {
        if (c === COPY_IDENTITY)
            throw new Error("Root cannot be copied.");
        this.set("asset", index_modern_extends({}, o.get("asset"))),
        this.setName(o.getName()),
        this.setExtras(index_modern_extends({}, o.getExtras())),
        this.setDefaultScene(o.getDefaultScene() ? c(o.getDefaultScene()) : null);
        for (const h of o.listRefMapKeys("extensions")) {
            const _ = o.getExtension(h);
            this.setExtension(h, c(_))
        }
        return this
    }
    _addChildOfRoot(o) {
        return o instanceof index_modern_Scene ? this.addRef("scenes", o) : o instanceof index_modern_Node ? this.addRef("nodes", o) : o instanceof Camera ? this.addRef("cameras", o) : o instanceof Skin ? this.addRef("skins", o) : o instanceof index_modern_Mesh ? this.addRef("meshes", o) : o instanceof index_modern_Material ? this.addRef("materials", o) : o instanceof index_modern_Texture ? this.addRef("textures", o) : o instanceof Animation ? this.addRef("animations", o) : o instanceof index_modern_Accessor ? this.addRef("accessors", o) : o instanceof Buffer$1 && this.addRef("buffers", o),
        this
    }
    getAsset() {
        return this.get("asset")
    }
    listExtensionsUsed() {
        return Array.from(this._extensions)
    }
    listExtensionsRequired() {
        return this.listExtensionsUsed().filter(o => o.isRequired())
    }
    _enableExtension(o) {
        return this._extensions.add(o),
        this
    }
    _disableExtension(o) {
        return this._extensions.delete(o),
        this
    }
    listScenes() {
        return this.listRefs("scenes")
    }
    setDefaultScene(o) {
        return this.setRef("defaultScene", o)
    }
    getDefaultScene() {
        return this.getRef("defaultScene")
    }
    listNodes() {
        return this.listRefs("nodes")
    }
    listCameras() {
        return this.listRefs("cameras")
    }
    listSkins() {
        return this.listRefs("skins")
    }
    listMeshes() {
        return this.listRefs("meshes")
    }
    listMaterials() {
        return this.listRefs("materials")
    }
    listTextures() {
        return this.listRefs("textures")
    }
    listAnimations() {
        return this.listRefs("animations")
    }
    listAccessors() {
        return this.listRefs("accessors")
    }
    listBuffers() {
        return this.listRefs("buffers")
    }
}
class index_modern_Document {
    static fromGraph(o) {
        return index_modern_Document._GRAPH_DOCUMENTS.get(o) || null
    }
    constructor() {
        this._graph = new Graph,
        this._root = new index_modern_Root(this._graph),
        this._logger = Logger.DEFAULT_INSTANCE,
        index_modern_Document._GRAPH_DOCUMENTS.set(this._graph, this)
    }
    getRoot() {
        return this._root
    }
    getGraph() {
        return this._graph
    }
    getLogger() {
        return this._logger
    }
    setLogger(o) {
        return this._logger = o,
        this
    }
    clone() {
        throw new Error("Use 'cloneDocument(source)' from '@gltf-transform/functions'.")
    }
    merge(o) {
        throw new Error("Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.")
    }
    async transform(...o) {
        const c = o.map(h => h.name);
        for (const h of o)
            await h(this, {
                stack: c
            });
        return this
    }
    createExtension(o) {
        const c = o.EXTENSION_NAME;
        return this.getRoot().listExtensionsUsed().find(h => h.extensionName === c) || new o(this)
    }
    createScene(o="") {
        return new index_modern_Scene(this._graph,o)
    }
    createNode(o="") {
        return new index_modern_Node(this._graph,o)
    }
    createCamera(o="") {
        return new Camera(this._graph,o)
    }
    createSkin(o="") {
        return new Skin(this._graph,o)
    }
    createMesh(o="") {
        return new index_modern_Mesh(this._graph,o)
    }
    createPrimitive() {
        return new index_modern_Primitive(this._graph)
    }
    createPrimitiveTarget(o="") {
        return new index_modern_PrimitiveTarget(this._graph,o)
    }
    createMaterial(o="") {
        return new index_modern_Material(this._graph,o)
    }
    createTexture(o="") {
        return new index_modern_Texture(this._graph,o)
    }
    createAnimation(o="") {
        return new Animation(this._graph,o)
    }
    createAnimationChannel(o="") {
        return new index_modern_AnimationChannel(this._graph,o)
    }
    createAnimationSampler(o="") {
        return new index_modern_AnimationSampler(this._graph,o)
    }
    createAccessor(o="", c=null) {
        return c || (c = this.getRoot().listBuffers()[0]),
        new index_modern_Accessor(this._graph,o).setBuffer(c)
    }
    createBuffer(o="") {
        return new Buffer$1(this._graph,o)
    }
}
index_modern_Document._GRAPH_DOCUMENTS = new WeakMap;
class Extension {
    constructor(o) {
        this.extensionName = "",
        this.prereadTypes = [],
        this.prewriteTypes = [],
        this.readDependencies = [],
        this.writeDependencies = [],
        this.document = void 0,
        this.required = !1,
        this.properties = new Set,
        this._listener = void 0,
        this.document = o,
        o.getRoot()._enableExtension(this),
        this._listener = h => {
            const _ = h
              , b = _.target;
            b instanceof index_modern_ExtensionProperty && b.extensionName === this.extensionName && (_.type === "node:create" && this._addExtensionProperty(b),
            _.type === "node:dispose" && this._removeExtensionProperty(b))
        }
        ;
        const c = o.getGraph();
        c.addEventListener("node:create", this._listener),
        c.addEventListener("node:dispose", this._listener)
    }
    dispose() {
        this.document.getRoot()._disableExtension(this);
        const o = this.document.getGraph();
        o.removeEventListener("node:create", this._listener),
        o.removeEventListener("node:dispose", this._listener);
        for (const c of this.properties)
            c.dispose()
    }
    static register() {}
    isRequired() {
        return this.required
    }
    setRequired(o) {
        return this.required = o,
        this
    }
    listProperties() {
        return Array.from(this.properties)
    }
    _addExtensionProperty(o) {
        return this.properties.add(o),
        this
    }
    _removeExtensionProperty(o) {
        return this.properties.delete(o),
        this
    }
    install(o, c) {
        return this
    }
    preread(o, c) {
        return this
    }
    prewrite(o, c) {
        return this
    }
}
Extension.EXTENSION_NAME = void 0;
class ReaderContext {
    constructor(o) {
        this.jsonDoc = void 0,
        this.buffers = [],
        this.bufferViews = [],
        this.bufferViewBuffers = [],
        this.accessors = [],
        this.textures = [],
        this.textureInfos = new Map,
        this.materials = [],
        this.meshes = [],
        this.cameras = [],
        this.nodes = [],
        this.skins = [],
        this.animations = [],
        this.scenes = [],
        this.jsonDoc = o
    }
    setTextureInfo(o, c) {
        this.textureInfos.set(o, c),
        c.texCoord !== void 0 && o.setTexCoord(c.texCoord),
        c.extras !== void 0 && o.setExtras(c.extras);
        const h = this.jsonDoc.json.textures[c.index];
        if (h.sampler === void 0)
            return;
        const _ = this.jsonDoc.json.samplers[h.sampler];
        _.magFilter !== void 0 && o.setMagFilter(_.magFilter),
        _.minFilter !== void 0 && o.setMinFilter(_.minFilter),
        _.wrapS !== void 0 && o.setWrapS(_.wrapS),
        _.wrapT !== void 0 && o.setWrapT(_.wrapT)
    }
}
const index_modern_DEFAULT_OPTIONS = {
    logger: Logger.DEFAULT_INSTANCE,
    extensions: [],
    dependencies: {}
}
  , SUPPORTED_PREREAD_TYPES = new Set([index_modern_PropertyType.BUFFER, index_modern_PropertyType.TEXTURE, index_modern_PropertyType.MATERIAL, index_modern_PropertyType.MESH, index_modern_PropertyType.PRIMITIVE, index_modern_PropertyType.NODE, index_modern_PropertyType.SCENE]);
class GLTFReader {
    static read(o, c=index_modern_DEFAULT_OPTIONS) {
        const h = index_modern_extends({}, index_modern_DEFAULT_OPTIONS, c)
          , {json: _} = o
          , b = new index_modern_Document().setLogger(h.logger);
        this.validate(o, h);
        const _e = new ReaderContext(o)
          , nt = _.asset
          , it = b.getRoot().getAsset();
        nt.copyright && (it.copyright = nt.copyright),
        nt.extras && (it.extras = nt.extras),
        _.extras !== void 0 && b.getRoot().setExtras(index_modern_extends({}, _.extras));
        const at = _.extensionsUsed || []
          , ut = _.extensionsRequired || [];
        h.extensions.sort( (Bt, kt) => Bt.EXTENSION_NAME > kt.EXTENSION_NAME ? 1 : -1);
        for (const Bt of h.extensions)
            if (at.includes(Bt.EXTENSION_NAME)) {
                const kt = b.createExtension(Bt).setRequired(ut.includes(Bt.EXTENSION_NAME))
                  , Ut = kt.prereadTypes.filter(Ht => !SUPPORTED_PREREAD_TYPES.has(Ht));
                Ut.length && h.logger.warn(`Preread hooks for some types (${Ut.join()}), requested by extension ${kt.extensionName}, are unsupported. Please file an issue or a PR.`);
                for (const Ht of kt.readDependencies)
                    kt.install(Ht, h.dependencies[Ht])
            }
        const pt = _.buffers || [];
        b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.BUFFER)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.BUFFER)),
        _e.buffers = pt.map(Bt => {
            const kt = b.createBuffer(Bt.name);
            return Bt.extras && kt.setExtras(Bt.extras),
            Bt.uri && Bt.uri.indexOf("__") !== 0 && kt.setURI(Bt.uri),
            kt
        }
        );
        const ht = _.bufferViews || [];
        _e.bufferViewBuffers = ht.map( (Bt, kt) => {
            if (!_e.bufferViews[kt]) {
                const Ut = o.json.buffers[Bt.buffer]
                  , Ht = Ut.uri ? o.resources[Ut.uri] : o.resources[GLB_BUFFER]
                  , Kt = Bt.byteOffset || 0;
                _e.bufferViews[kt] = index_modern_BufferUtils.toView(Ht, Kt, Bt.byteLength)
            }
            return _e.buffers[Bt.buffer]
        }
        );
        const _t = _.accessors || [];
        _e.accessors = _t.map(Bt => {
            const kt = _e.bufferViewBuffers[Bt.bufferView]
              , Ut = b.createAccessor(Bt.name, kt).setType(Bt.type);
            return Bt.extras && Ut.setExtras(Bt.extras),
            Bt.normalized !== void 0 && Ut.setNormalized(Bt.normalized),
            Bt.bufferView === void 0 || Ut.setArray(getAccessorArray(Bt, _e)),
            Ut
        }
        );
        const vt = _.images || []
          , bt = _.textures || [];
        b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.TEXTURE)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.TEXTURE)),
        _e.textures = vt.map(Bt => {
            const kt = b.createTexture(Bt.name);
            if (Bt.extras && kt.setExtras(Bt.extras),
            Bt.bufferView !== void 0) {
                const Ut = _.bufferViews[Bt.bufferView]
                  , Ht = o.json.buffers[Ut.buffer]
                  , Kt = Ht.uri ? o.resources[Ht.uri] : o.resources[GLB_BUFFER]
                  , Jt = Ut.byteOffset || 0
                  , or = Ut.byteLength
                  , ir = Kt.slice(Jt, Jt + or);
                kt.setImage(ir)
            } else
                Bt.uri !== void 0 && (kt.setImage(o.resources[Bt.uri]),
                Bt.uri.indexOf("__") !== 0 && kt.setURI(Bt.uri));
            if (Bt.mimeType !== void 0)
                kt.setMimeType(Bt.mimeType);
            else if (Bt.uri) {
                const Ut = index_modern_FileUtils.extension(Bt.uri);
                kt.setMimeType(index_modern_ImageUtils.extensionToMimeType(Ut))
            }
            return kt
        }
        ),
        b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.MATERIAL)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.MATERIAL));
        const St = _.materials || [];
        _e.materials = St.map(Bt => {
            const kt = b.createMaterial(Bt.name);
            Bt.extras && kt.setExtras(Bt.extras),
            Bt.alphaMode !== void 0 && kt.setAlphaMode(Bt.alphaMode),
            Bt.alphaCutoff !== void 0 && kt.setAlphaCutoff(Bt.alphaCutoff),
            Bt.doubleSided !== void 0 && kt.setDoubleSided(Bt.doubleSided);
            const Ut = Bt.pbrMetallicRoughness || {};
            if (Ut.baseColorFactor !== void 0 && kt.setBaseColorFactor(Ut.baseColorFactor),
            Bt.emissiveFactor !== void 0 && kt.setEmissiveFactor(Bt.emissiveFactor),
            Ut.metallicFactor !== void 0 && kt.setMetallicFactor(Ut.metallicFactor),
            Ut.roughnessFactor !== void 0 && kt.setRoughnessFactor(Ut.roughnessFactor),
            Ut.baseColorTexture !== void 0) {
                const Ht = Ut.baseColorTexture
                  , Kt = _e.textures[bt[Ht.index].source];
                kt.setBaseColorTexture(Kt),
                _e.setTextureInfo(kt.getBaseColorTextureInfo(), Ht)
            }
            if (Bt.emissiveTexture !== void 0) {
                const Ht = Bt.emissiveTexture
                  , Kt = _e.textures[bt[Ht.index].source];
                kt.setEmissiveTexture(Kt),
                _e.setTextureInfo(kt.getEmissiveTextureInfo(), Ht)
            }
            if (Bt.normalTexture !== void 0) {
                const Ht = Bt.normalTexture
                  , Kt = _e.textures[bt[Ht.index].source];
                kt.setNormalTexture(Kt),
                _e.setTextureInfo(kt.getNormalTextureInfo(), Ht),
                Bt.normalTexture.scale !== void 0 && kt.setNormalScale(Bt.normalTexture.scale)
            }
            if (Bt.occlusionTexture !== void 0) {
                const Ht = Bt.occlusionTexture
                  , Kt = _e.textures[bt[Ht.index].source];
                kt.setOcclusionTexture(Kt),
                _e.setTextureInfo(kt.getOcclusionTextureInfo(), Ht),
                Bt.occlusionTexture.strength !== void 0 && kt.setOcclusionStrength(Bt.occlusionTexture.strength)
            }
            if (Ut.metallicRoughnessTexture !== void 0) {
                const Ht = Ut.metallicRoughnessTexture
                  , Kt = _e.textures[bt[Ht.index].source];
                kt.setMetallicRoughnessTexture(Kt),
                _e.setTextureInfo(kt.getMetallicRoughnessTextureInfo(), Ht)
            }
            return kt
        }
        ),
        b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.MESH)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.MESH));
        const At = _.meshes || [];
        b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.PRIMITIVE)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.PRIMITIVE)),
        _e.meshes = At.map(Bt => {
            const kt = b.createMesh(Bt.name);
            return Bt.extras && kt.setExtras(Bt.extras),
            Bt.weights !== void 0 && kt.setWeights(Bt.weights),
            (Bt.primitives || []).forEach(Ut => {
                const Ht = b.createPrimitive();
                Ut.extras && Ht.setExtras(Ut.extras),
                Ut.material !== void 0 && Ht.setMaterial(_e.materials[Ut.material]),
                Ut.mode !== void 0 && Ht.setMode(Ut.mode);
                for (const [Jt,or] of Object.entries(Ut.attributes || {}))
                    Ht.setAttribute(Jt, _e.accessors[or]);
                Ut.indices !== void 0 && Ht.setIndices(_e.accessors[Ut.indices]);
                const Kt = Bt.extras && Bt.extras.targetNames || [];
                (Ut.targets || []).forEach( (Jt, or) => {
                    const ir = Kt[or] || or.toString()
                      , lr = b.createPrimitiveTarget(ir);
                    for (const [ar,hr] of Object.entries(Jt))
                        lr.setAttribute(ar, _e.accessors[hr]);
                    Ht.addTarget(lr)
                }
                ),
                kt.addPrimitive(Ht)
            }
            ),
            kt
        }
        );
        const Et = _.cameras || [];
        _e.cameras = Et.map(Bt => {
            const kt = b.createCamera(Bt.name).setType(Bt.type);
            if (Bt.extras && kt.setExtras(Bt.extras),
            Bt.type === Camera.Type.PERSPECTIVE) {
                const Ut = Bt.perspective;
                kt.setYFov(Ut.yfov),
                kt.setZNear(Ut.znear),
                Ut.zfar !== void 0 && kt.setZFar(Ut.zfar),
                Ut.aspectRatio !== void 0 && kt.setAspectRatio(Ut.aspectRatio)
            } else {
                const Ut = Bt.orthographic;
                kt.setZNear(Ut.znear).setZFar(Ut.zfar).setXMag(Ut.xmag).setYMag(Ut.ymag)
            }
            return kt
        }
        );
        const Pt = _.nodes || [];
        b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.NODE)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.NODE)),
        _e.nodes = Pt.map(Bt => {
            const kt = b.createNode(Bt.name);
            if (Bt.extras && kt.setExtras(Bt.extras),
            Bt.translation !== void 0 && kt.setTranslation(Bt.translation),
            Bt.rotation !== void 0 && kt.setRotation(Bt.rotation),
            Bt.scale !== void 0 && kt.setScale(Bt.scale),
            Bt.matrix !== void 0) {
                const Ut = [0, 0, 0]
                  , Ht = [0, 0, 0, 1]
                  , Kt = [1, 1, 1];
                index_modern_MathUtils.decompose(Bt.matrix, Ut, Ht, Kt),
                kt.setTranslation(Ut),
                kt.setRotation(Ht),
                kt.setScale(Kt)
            }
            return Bt.weights !== void 0 && kt.setWeights(Bt.weights),
            kt
        }
        );
        const It = _.skins || [];
        _e.skins = It.map(Bt => {
            const kt = b.createSkin(Bt.name);
            Bt.extras && kt.setExtras(Bt.extras),
            Bt.inverseBindMatrices !== void 0 && kt.setInverseBindMatrices(_e.accessors[Bt.inverseBindMatrices]),
            Bt.skeleton !== void 0 && kt.setSkeleton(_e.nodes[Bt.skeleton]);
            for (const Ut of Bt.joints)
                kt.addJoint(_e.nodes[Ut]);
            return kt
        }
        ),
        Pt.map( (Bt, kt) => {
            const Ut = _e.nodes[kt];
            (Bt.children || []).forEach(Ht => Ut.addChild(_e.nodes[Ht])),
            Bt.mesh !== void 0 && Ut.setMesh(_e.meshes[Bt.mesh]),
            Bt.camera !== void 0 && Ut.setCamera(_e.cameras[Bt.camera]),
            Bt.skin !== void 0 && Ut.setSkin(_e.skins[Bt.skin])
        }
        );
        const Dt = _.animations || [];
        _e.animations = Dt.map(Bt => {
            const kt = b.createAnimation(Bt.name);
            Bt.extras && kt.setExtras(Bt.extras);
            const Ut = (Bt.samplers || []).map(Ht => {
                const Kt = b.createAnimationSampler().setInput(_e.accessors[Ht.input]).setOutput(_e.accessors[Ht.output]).setInterpolation(Ht.interpolation || index_modern_AnimationSampler.Interpolation.LINEAR);
                return Ht.extras && Kt.setExtras(Ht.extras),
                kt.addSampler(Kt),
                Kt
            }
            );
            return (Bt.channels || []).forEach(Ht => {
                const Kt = b.createAnimationChannel().setSampler(Ut[Ht.sampler]).setTargetPath(Ht.target.path);
                Ht.target.node !== void 0 && Kt.setTargetNode(_e.nodes[Ht.target.node]),
                Ht.extras && Kt.setExtras(Ht.extras),
                kt.addChannel(Kt)
            }
            ),
            kt
        }
        );
        const Gt = _.scenes || [];
        return b.getRoot().listExtensionsUsed().filter(Bt => Bt.prereadTypes.includes(index_modern_PropertyType.SCENE)).forEach(Bt => Bt.preread(_e, index_modern_PropertyType.SCENE)),
        _e.scenes = Gt.map(Bt => {
            const kt = b.createScene(Bt.name);
            return Bt.extras && kt.setExtras(Bt.extras),
            (Bt.nodes || []).map(Ut => _e.nodes[Ut]).forEach(Ut => kt.addChild(Ut)),
            kt
        }
        ),
        _.scene !== void 0 && b.getRoot().setDefaultScene(_e.scenes[_.scene]),
        b.getRoot().listExtensionsUsed().forEach(Bt => Bt.read(_e)),
        _t.forEach( (Bt, kt) => {
            const Ut = _e.accessors[kt]
              , Ht = !!Bt.sparse
              , Kt = !Bt.bufferView && !Ut.getArray();
            (Ht || Kt) && Ut.setSparse(!0).setArray(getSparseArray(Bt, _e))
        }
        ),
        b
    }
    static validate(o, c) {
        const h = o.json;
        if (h.asset.version !== "2.0")
            throw new Error(`Unsupported glTF version, "${h.asset.version}".`);
        if (h.extensionsRequired) {
            for (const _ of h.extensionsRequired)
                if (!c.extensions.find(b => b.EXTENSION_NAME === _))
                    throw new Error(`Missing required extension, "${_}".`)
        }
        if (h.extensionsUsed)
            for (const _ of h.extensionsUsed)
                c.extensions.find(b => b.EXTENSION_NAME === _) || c.logger.warn(`Missing optional extension, "${_}".`)
    }
}
function getInterleavedArray(d, o) {
    const c = o.jsonDoc
      , h = o.bufferViews[d.bufferView]
      , _ = c.json.bufferViews[d.bufferView]
      , b = index_modern_ComponentTypeToTypedArray[d.componentType]
      , _e = index_modern_Accessor.getElementSize(d.type)
      , nt = b.BYTES_PER_ELEMENT
      , it = d.byteOffset || 0
      , at = new b(d.count * _e)
      , ut = new DataView(h.buffer,h.byteOffset,h.byteLength)
      , pt = _.byteStride;
    for (let ht = 0; ht < d.count; ht++)
        for (let _t = 0; _t < _e; _t++) {
            const vt = it + ht * pt + _t * nt;
            let bt;
            switch (d.componentType) {
            case index_modern_Accessor.ComponentType.FLOAT:
                bt = ut.getFloat32(vt, !0);
                break;
            case index_modern_Accessor.ComponentType.UNSIGNED_INT:
                bt = ut.getUint32(vt, !0);
                break;
            case index_modern_Accessor.ComponentType.UNSIGNED_SHORT:
                bt = ut.getUint16(vt, !0);
                break;
            case index_modern_Accessor.ComponentType.UNSIGNED_BYTE:
                bt = ut.getUint8(vt);
                break;
            case index_modern_Accessor.ComponentType.SHORT:
                bt = ut.getInt16(vt, !0);
                break;
            case index_modern_Accessor.ComponentType.BYTE:
                bt = ut.getInt8(vt);
                break;
            default:
                throw new Error(`Unexpected componentType "${d.componentType}".`)
            }
            at[ht * _e + _t] = bt
        }
    return at
}
function getAccessorArray(d, o) {
    const c = o.jsonDoc
      , h = o.bufferViews[d.bufferView]
      , _ = c.json.bufferViews[d.bufferView]
      , b = index_modern_ComponentTypeToTypedArray[d.componentType]
      , _e = index_modern_Accessor.getElementSize(d.type)
      , nt = b.BYTES_PER_ELEMENT
      , it = _e * nt;
    if (_.byteStride !== void 0 && _.byteStride !== it)
        return getInterleavedArray(d, o);
    const at = h.byteOffset + (d.byteOffset || 0)
      , ut = d.count * _e * nt;
    return new b(h.buffer.slice(at, at + ut))
}
function getSparseArray(d, o) {
    const c = index_modern_ComponentTypeToTypedArray[d.componentType]
      , h = index_modern_Accessor.getElementSize(d.type);
    let _;
    _ = d.bufferView !== void 0 ? getAccessorArray(d, o) : new c(d.count * h);
    const b = d.sparse;
    if (!b)
        return _;
    const _e = b.count
      , nt = index_modern_extends({}, d, b.indices, {
        count: _e,
        type: "SCALAR"
    })
      , it = index_modern_extends({}, d, b.values, {
        count: _e
    })
      , at = getAccessorArray(nt, o)
      , ut = getAccessorArray(it, o);
    for (let pt = 0; pt < nt.count; pt++)
        for (let ht = 0; ht < h; ht++)
            _[at[pt] * h + ht] = ut[pt * h + ht];
    return _
}
var BufferViewTarget;
(function(d) {
    d[d.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
    d[d.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER"
}
)(BufferViewTarget || (BufferViewTarget = {}));
class WriterContext {
    constructor(o, c, h) {
        this._doc = void 0,
        this.jsonDoc = void 0,
        this.options = void 0,
        this.accessorIndexMap = new Map,
        this.animationIndexMap = new Map,
        this.bufferIndexMap = new Map,
        this.cameraIndexMap = new Map,
        this.skinIndexMap = new Map,
        this.materialIndexMap = new Map,
        this.meshIndexMap = new Map,
        this.nodeIndexMap = new Map,
        this.imageIndexMap = new Map,
        this.textureDefIndexMap = new Map,
        this.textureInfoDefMap = new Map,
        this.samplerDefIndexMap = new Map,
        this.sceneIndexMap = new Map,
        this.imageBufferViews = [],
        this.otherBufferViews = new Map,
        this.otherBufferViewsIndexMap = new Map,
        this.extensionData = {},
        this.bufferURIGenerator = void 0,
        this.imageURIGenerator = void 0,
        this.logger = void 0,
        this._accessorUsageMap = new Map,
        this.accessorUsageGroupedByParent = new Set(["ARRAY_BUFFER"]),
        this.accessorParents = new Map,
        this._doc = o,
        this.jsonDoc = c,
        this.options = h;
        const _ = o.getRoot()
          , b = _.listBuffers().length
          , _e = _.listTextures().length;
        this.bufferURIGenerator = new UniqueURIGenerator(b > 1, () => h.basename || "buffer"),
        this.imageURIGenerator = new UniqueURIGenerator(_e > 1,nt => getSlot(o, nt) || h.basename || "texture"),
        this.logger = o.getLogger()
    }
    createTextureInfoDef(o, c) {
        const h = {
            magFilter: c.getMagFilter() || void 0,
            minFilter: c.getMinFilter() || void 0,
            wrapS: c.getWrapS(),
            wrapT: c.getWrapT()
        }
          , _ = JSON.stringify(h);
        this.samplerDefIndexMap.has(_) || (this.samplerDefIndexMap.set(_, this.jsonDoc.json.samplers.length),
        this.jsonDoc.json.samplers.push(h));
        const b = {
            source: this.imageIndexMap.get(o),
            sampler: this.samplerDefIndexMap.get(_)
        }
          , _e = JSON.stringify(b);
        this.textureDefIndexMap.has(_e) || (this.textureDefIndexMap.set(_e, this.jsonDoc.json.textures.length),
        this.jsonDoc.json.textures.push(b));
        const nt = {
            index: this.textureDefIndexMap.get(_e)
        };
        return c.getTexCoord() !== 0 && (nt.texCoord = c.getTexCoord()),
        Object.keys(c.getExtras()).length > 0 && (nt.extras = c.getExtras()),
        this.textureInfoDefMap.set(c, nt),
        nt
    }
    createPropertyDef(o) {
        const c = {};
        return o.getName() && (c.name = o.getName()),
        Object.keys(o.getExtras()).length > 0 && (c.extras = o.getExtras()),
        c
    }
    createAccessorDef(o) {
        const c = this.createPropertyDef(o);
        return c.type = o.getType(),
        c.componentType = o.getComponentType(),
        c.count = o.getCount(),
        this._doc.getGraph().listParentEdges(o).some(h => h.getName() === "attributes" && h.getAttributes().key === "POSITION" || h.getName() === "input") && (c.max = o.getMax([]).map(Math.fround),
        c.min = o.getMin([]).map(Math.fround)),
        o.getNormalized() && (c.normalized = o.getNormalized()),
        c
    }
    createImageData(o, c, h) {
        if (this.options.format === Format.GLB)
            this.imageBufferViews.push(c),
            o.bufferView = this.jsonDoc.json.bufferViews.length,
            this.jsonDoc.json.bufferViews.push({
                buffer: 0,
                byteOffset: -1,
                byteLength: c.byteLength
            });
        else {
            const _ = index_modern_ImageUtils.mimeTypeToExtension(h.getMimeType());
            o.uri = this.imageURIGenerator.createURI(h, _),
            this.assignResourceURI(o.uri, c, !1)
        }
    }
    assignResourceURI(o, c, h) {
        const _ = this.jsonDoc.resources;
        if (!(o in _))
            return void (_[o] = c);
        if (c === _[o])
            return void this.logger.warn(`Duplicate resource URI, "${o}".`);
        const b = `Resource URI "${o}" already assigned to different data.`;
        if (h)
            throw new Error(b);
        this.logger.warn(b)
    }
    getAccessorUsage(o) {
        const c = this._accessorUsageMap.get(o);
        if (c)
            return c;
        if (o.getSparse())
            return BufferViewUsage$1.SPARSE;
        for (const h of this._doc.getGraph().listParentEdges(o)) {
            const {usage: _} = h.getAttributes();
            if (_)
                return _;
            h.getParent().propertyType !== index_modern_PropertyType.ROOT && this.logger.warn(`Missing attribute ".usage" on edge, "${h.getName()}".`)
        }
        return BufferViewUsage$1.OTHER
    }
    addAccessorToUsageGroup(o, c) {
        const h = this._accessorUsageMap.get(o);
        if (h && h !== c)
            throw new Error(`Accessor with usage "${h}" cannot be reused as "${c}".`);
        return this._accessorUsageMap.set(o, c),
        this
    }
}
WriterContext.BufferViewTarget = BufferViewTarget,
WriterContext.BufferViewUsage = BufferViewUsage$1,
WriterContext.USAGE_TO_TARGET = {
    [BufferViewUsage$1.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,
    [BufferViewUsage$1.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER
};
class UniqueURIGenerator {
    constructor(o, c) {
        this.multiple = void 0,
        this.basename = void 0,
        this.counter = {},
        this.multiple = o,
        this.basename = c
    }
    createURI(o, c) {
        if (o.getURI())
            return o.getURI();
        if (this.multiple) {
            const h = this.basename(o);
            return this.counter[h] = this.counter[h] || 1,
            `${h}_${this.counter[h]++}.${c}`
        }
        return `${this.basename(o)}.${c}`
    }
}
function getSlot(d, o) {
    const c = d.getGraph().listParentEdges(o).find(h => h.getParent() !== d.getRoot());
    return c ? c.getName().replace(/texture$/i, "") : ""
}
const {BufferViewUsage} = WriterContext
  , {UNSIGNED_INT, UNSIGNED_SHORT, UNSIGNED_BYTE} = index_modern_Accessor.ComponentType
  , SUPPORTED_PREWRITE_TYPES = new Set([index_modern_PropertyType.ACCESSOR, index_modern_PropertyType.BUFFER, index_modern_PropertyType.MATERIAL, index_modern_PropertyType.MESH]);
class index_modern_GLTFWriter {
    static write(o, c) {
        const h = o.getGraph()
          , _ = o.getRoot()
          , b = {
            asset: index_modern_extends({
                generator: `glTF-Transform ${VERSION}`
            }, _.getAsset()),
            extras: index_modern_extends({}, _.getExtras())
        }
          , _e = {
            json: b,
            resources: {}
        }
          , nt = new WriterContext(o,_e,c)
          , it = c.logger || Logger.DEFAULT_INSTANCE
          , at = new Set(c.extensions.map(St => St.EXTENSION_NAME))
          , ut = o.getRoot().listExtensionsUsed().filter(St => at.has(St.extensionName)).sort( (St, At) => St.extensionName > At.extensionName ? 1 : -1)
          , pt = o.getRoot().listExtensionsRequired().filter(St => at.has(St.extensionName)).sort( (St, At) => St.extensionName > At.extensionName ? 1 : -1);
        ut.length < o.getRoot().listExtensionsUsed().length && it.warn("Some extensions were not registered for I/O, and will not be written.");
        for (const St of ut) {
            const At = St.prewriteTypes.filter(Et => !SUPPORTED_PREWRITE_TYPES.has(Et));
            At.length && it.warn(`Prewrite hooks for some types (${At.join()}), requested by extension ${St.extensionName}, are unsupported. Please file an issue or a PR.`);
            for (const Et of St.writeDependencies)
                St.install(Et, c.dependencies[Et])
        }
        function ht(St, At, Et, Pt) {
            const It = [];
            let Dt = 0;
            for (const Bt of St) {
                const kt = nt.createAccessorDef(Bt);
                kt.bufferView = b.bufferViews.length;
                const Ut = Bt.getArray()
                  , Ht = index_modern_BufferUtils.pad(index_modern_BufferUtils.toView(Ut));
                kt.byteOffset = Dt,
                Dt += Ht.byteLength,
                It.push(Ht),
                nt.accessorIndexMap.set(Bt, b.accessors.length),
                b.accessors.push(kt)
            }
            const Gt = {
                buffer: At,
                byteOffset: Et,
                byteLength: index_modern_BufferUtils.concat(It).byteLength
            };
            return Pt && (Gt.target = Pt),
            b.bufferViews.push(Gt),
            {
                buffers: It,
                byteLength: Dt
            }
        }
        function _t(St, At, Et) {
            const Pt = St[0].getCount();
            let It = 0;
            for (const Ut of St) {
                const Ht = nt.createAccessorDef(Ut);
                Ht.bufferView = b.bufferViews.length,
                Ht.byteOffset = It;
                const Kt = Ut.getElementSize()
                  , Jt = Ut.getComponentSize();
                It += index_modern_BufferUtils.padNumber(Kt * Jt),
                nt.accessorIndexMap.set(Ut, b.accessors.length),
                b.accessors.push(Ht)
            }
            const Dt = Pt * It
              , Gt = new ArrayBuffer(Dt)
              , Bt = new DataView(Gt);
            for (let Ut = 0; Ut < Pt; Ut++) {
                let Ht = 0;
                for (const Kt of St) {
                    const Jt = Kt.getElementSize()
                      , or = Kt.getComponentSize()
                      , ir = Kt.getComponentType()
                      , lr = Kt.getArray();
                    for (let ar = 0; ar < Jt; ar++) {
                        const hr = Ut * It + Ht + ar * or
                          , gr = lr[Ut * Jt + ar];
                        switch (ir) {
                        case index_modern_Accessor.ComponentType.FLOAT:
                            Bt.setFloat32(hr, gr, !0);
                            break;
                        case index_modern_Accessor.ComponentType.BYTE:
                            Bt.setInt8(hr, gr);
                            break;
                        case index_modern_Accessor.ComponentType.SHORT:
                            Bt.setInt16(hr, gr, !0);
                            break;
                        case index_modern_Accessor.ComponentType.UNSIGNED_BYTE:
                            Bt.setUint8(hr, gr);
                            break;
                        case index_modern_Accessor.ComponentType.UNSIGNED_SHORT:
                            Bt.setUint16(hr, gr, !0);
                            break;
                        case index_modern_Accessor.ComponentType.UNSIGNED_INT:
                            Bt.setUint32(hr, gr, !0);
                            break;
                        default:
                            throw new Error("Unexpected component type: " + ir)
                        }
                    }
                    Ht += index_modern_BufferUtils.padNumber(Jt * or)
                }
            }
            const kt = {
                buffer: At,
                byteOffset: Et,
                byteLength: Dt,
                byteStride: It,
                target: WriterContext.BufferViewTarget.ARRAY_BUFFER
            };
            return b.bufferViews.push(kt),
            {
                byteLength: Dt,
                buffers: [new Uint8Array(Gt)]
            }
        }
        function vt(St, At, Et) {
            const Pt = [];
            let It = 0;
            const Dt = new Map;
            let Gt = -1 / 0
              , Bt = !1;
            for (const ir of St) {
                const lr = nt.createAccessorDef(ir);
                b.accessors.push(lr),
                nt.accessorIndexMap.set(ir, b.accessors.length - 1);
                const ar = []
                  , hr = []
                  , gr = []
                  , dr = new Array(ir.getElementSize()).fill(0);
                for (let Rr = 0, Cr = ir.getCount(); Rr < Cr; Rr++)
                    if (ir.getElement(Rr, gr),
                    !index_modern_MathUtils.eq(gr, dr, 0)) {
                        Gt = Math.max(Rr, Gt),
                        ar.push(Rr);
                        for (let tr = 0; tr < gr.length; tr++)
                            hr.push(gr[tr])
                    }
                const cr = ar.length
                  , Ar = {
                    accessorDef: lr,
                    count: cr
                };
                if (Dt.set(ir, Ar),
                cr === 0)
                    continue;
                cr > ir.getCount() / 2 && (Bt = !0);
                const wr = index_modern_ComponentTypeToTypedArray[ir.getComponentType()];
                Ar.indices = ar,
                Ar.values = new wr(hr)
            }
            if (!Number.isFinite(Gt))
                return {
                    buffers: Pt,
                    byteLength: It
                };
            Bt && it.warn("Some sparse accessors have >50% non-zero elements, which may increase file size.");
            const kt = Gt < 255 ? Uint8Array : Gt < 65535 ? Uint16Array : Uint32Array
              , Ut = Gt < 255 ? UNSIGNED_BYTE : Gt < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT
              , Ht = {
                buffer: At,
                byteOffset: Et + It,
                byteLength: 0
            };
            for (const ir of St) {
                const lr = Dt.get(ir);
                if (lr.count === 0)
                    continue;
                lr.indicesByteOffset = Ht.byteLength;
                const ar = index_modern_BufferUtils.pad(index_modern_BufferUtils.toView(new kt(lr.indices)));
                Pt.push(ar),
                It += ar.byteLength,
                Ht.byteLength += ar.byteLength
            }
            b.bufferViews.push(Ht);
            const Kt = b.bufferViews.length - 1
              , Jt = {
                buffer: At,
                byteOffset: Et + It,
                byteLength: 0
            };
            for (const ir of St) {
                const lr = Dt.get(ir);
                if (lr.count === 0)
                    continue;
                lr.valuesByteOffset = Jt.byteLength;
                const ar = index_modern_BufferUtils.pad(index_modern_BufferUtils.toView(lr.values));
                Pt.push(ar),
                It += ar.byteLength,
                Jt.byteLength += ar.byteLength
            }
            b.bufferViews.push(Jt);
            const or = b.bufferViews.length - 1;
            for (const ir of St) {
                const lr = Dt.get(ir);
                lr.count !== 0 && (lr.accessorDef.sparse = {
                    count: lr.count,
                    indices: {
                        bufferView: Kt,
                        byteOffset: lr.indicesByteOffset,
                        componentType: Ut
                    },
                    values: {
                        bufferView: or,
                        byteOffset: lr.valuesByteOffset
                    }
                })
            }
            return {
                buffers: Pt,
                byteLength: It
            }
        }
        if (b.accessors = [],
        b.bufferViews = [],
        b.samplers = [],
        b.textures = [],
        b.images = _.listTextures().map( (St, At) => {
            const Et = nt.createPropertyDef(St);
            St.getMimeType() && (Et.mimeType = St.getMimeType());
            const Pt = St.getImage();
            return Pt && nt.createImageData(Et, Pt, St),
            nt.imageIndexMap.set(St, At),
            Et
        }
        ),
        ut.filter(St => St.prewriteTypes.includes(index_modern_PropertyType.ACCESSOR)).forEach(St => St.prewrite(nt, index_modern_PropertyType.ACCESSOR)),
        _.listAccessors().forEach(St => {
            const At = nt.accessorUsageGroupedByParent
              , Et = nt.accessorParents;
            if (nt.accessorIndexMap.has(St))
                return;
            const Pt = nt.getAccessorUsage(St);
            if (nt.addAccessorToUsageGroup(St, Pt),
            At.has(Pt)) {
                const It = h.listParents(St).find(Dt => Dt.propertyType !== index_modern_PropertyType.ROOT);
                Et.set(St, It)
            }
        }
        ),
        ut.filter(St => St.prewriteTypes.includes(index_modern_PropertyType.BUFFER)).forEach(St => St.prewrite(nt, index_modern_PropertyType.BUFFER)),
        (_.listAccessors().length > 0 || nt.otherBufferViews.size > 0 || _.listTextures().length > 0 && c.format === Format.GLB) && _.listBuffers().length === 0)
            throw new Error("Buffer required for Document resources, but none was found.");
        b.buffers = [],
        _.listBuffers().forEach( (St, At) => {
            const Et = nt.createPropertyDef(St)
              , Pt = nt.accessorUsageGroupedByParent
              , It = St.listParents().filter(Jt => Jt instanceof index_modern_Accessor)
              , Dt = new Set(It.map(Jt => nt.accessorParents.get(Jt)))
              , Gt = new Map(Array.from(Dt).map( (Jt, or) => [Jt, or]))
              , Bt = {};
            for (const Jt of It) {
                var kt;
                if (nt.accessorIndexMap.has(Jt))
                    continue;
                const or = nt.getAccessorUsage(Jt);
                let ir = or;
                if (Pt.has(or)) {
                    const lr = nt.accessorParents.get(Jt);
                    ir += `:${Gt.get(lr)}`
                }
                Bt[kt = ir] || (Bt[kt] = {
                    usage: or,
                    accessors: []
                }),
                Bt[ir].accessors.push(Jt)
            }
            const Ut = []
              , Ht = b.buffers.length;
            let Kt = 0;
            for (const {usage: Jt, accessors: or} of Object.values(Bt))
                if (Jt === BufferViewUsage.ARRAY_BUFFER && c.vertexLayout === VertexLayout.INTERLEAVED) {
                    const ir = _t(or, Ht, Kt);
                    Kt += ir.byteLength;
                    for (const lr of ir.buffers)
                        Ut.push(lr)
                } else if (Jt === BufferViewUsage.ARRAY_BUFFER)
                    for (const ir of or) {
                        const lr = _t([ir], Ht, Kt);
                        Kt += lr.byteLength;
                        for (const ar of lr.buffers)
                            Ut.push(ar)
                    }
                else if (Jt === BufferViewUsage.SPARSE) {
                    const ir = vt(or, Ht, Kt);
                    Kt += ir.byteLength;
                    for (const lr of ir.buffers)
                        Ut.push(lr)
                } else if (Jt === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {
                    const ir = ht(or, Ht, Kt, WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER);
                    Kt += ir.byteLength;
                    for (const lr of ir.buffers)
                        Ut.push(lr)
                } else {
                    const ir = ht(or, Ht, Kt);
                    Kt += ir.byteLength;
                    for (const lr of ir.buffers)
                        Ut.push(lr)
                }
            if (nt.imageBufferViews.length && At === 0) {
                for (let Jt = 0; Jt < nt.imageBufferViews.length; Jt++)
                    if (b.bufferViews[b.images[Jt].bufferView].byteOffset = Kt,
                    Kt += nt.imageBufferViews[Jt].byteLength,
                    Ut.push(nt.imageBufferViews[Jt]),
                    Kt % 8) {
                        const or = 8 - Kt % 8;
                        Kt += or,
                        Ut.push(new Uint8Array(or))
                    }
            }
            if (nt.otherBufferViews.has(St))
                for (const Jt of nt.otherBufferViews.get(St))
                    b.bufferViews.push({
                        buffer: Ht,
                        byteOffset: Kt,
                        byteLength: Jt.byteLength
                    }),
                    nt.otherBufferViewsIndexMap.set(Jt, b.bufferViews.length - 1),
                    Kt += Jt.byteLength,
                    Ut.push(Jt);
            if (Kt) {
                let Jt;
                c.format === Format.GLB ? Jt = GLB_BUFFER : (Jt = nt.bufferURIGenerator.createURI(St, "bin"),
                Et.uri = Jt),
                Et.byteLength = Kt,
                nt.assignResourceURI(Jt, index_modern_BufferUtils.concat(Ut), !0)
            }
            b.buffers.push(Et),
            nt.bufferIndexMap.set(St, At)
        }
        ),
        _.listAccessors().find(St => !St.getBuffer()) && it.warn("Skipped writing one or more Accessors: no Buffer assigned."),
        ut.filter(St => St.prewriteTypes.includes(index_modern_PropertyType.MATERIAL)).forEach(St => St.prewrite(nt, index_modern_PropertyType.MATERIAL)),
        b.materials = _.listMaterials().map( (St, At) => {
            const Et = nt.createPropertyDef(St);
            if (St.getAlphaMode() !== index_modern_Material.AlphaMode.OPAQUE && (Et.alphaMode = St.getAlphaMode()),
            St.getAlphaMode() === index_modern_Material.AlphaMode.MASK && (Et.alphaCutoff = St.getAlphaCutoff()),
            St.getDoubleSided() && (Et.doubleSided = !0),
            Et.pbrMetallicRoughness = {},
            index_modern_MathUtils.eq(St.getBaseColorFactor(), [1, 1, 1, 1]) || (Et.pbrMetallicRoughness.baseColorFactor = St.getBaseColorFactor()),
            index_modern_MathUtils.eq(St.getEmissiveFactor(), [0, 0, 0]) || (Et.emissiveFactor = St.getEmissiveFactor()),
            St.getRoughnessFactor() !== 1 && (Et.pbrMetallicRoughness.roughnessFactor = St.getRoughnessFactor()),
            St.getMetallicFactor() !== 1 && (Et.pbrMetallicRoughness.metallicFactor = St.getMetallicFactor()),
            St.getBaseColorTexture()) {
                const Pt = St.getBaseColorTexture()
                  , It = St.getBaseColorTextureInfo();
                Et.pbrMetallicRoughness.baseColorTexture = nt.createTextureInfoDef(Pt, It)
            }
            if (St.getEmissiveTexture()) {
                const Pt = St.getEmissiveTexture()
                  , It = St.getEmissiveTextureInfo();
                Et.emissiveTexture = nt.createTextureInfoDef(Pt, It)
            }
            if (St.getNormalTexture()) {
                const Pt = St.getNormalTexture()
                  , It = St.getNormalTextureInfo()
                  , Dt = nt.createTextureInfoDef(Pt, It);
                St.getNormalScale() !== 1 && (Dt.scale = St.getNormalScale()),
                Et.normalTexture = Dt
            }
            if (St.getOcclusionTexture()) {
                const Pt = St.getOcclusionTexture()
                  , It = St.getOcclusionTextureInfo()
                  , Dt = nt.createTextureInfoDef(Pt, It);
                St.getOcclusionStrength() !== 1 && (Dt.strength = St.getOcclusionStrength()),
                Et.occlusionTexture = Dt
            }
            if (St.getMetallicRoughnessTexture()) {
                const Pt = St.getMetallicRoughnessTexture()
                  , It = St.getMetallicRoughnessTextureInfo();
                Et.pbrMetallicRoughness.metallicRoughnessTexture = nt.createTextureInfoDef(Pt, It)
            }
            return nt.materialIndexMap.set(St, At),
            Et
        }
        ),
        ut.filter(St => St.prewriteTypes.includes(index_modern_PropertyType.MESH)).forEach(St => St.prewrite(nt, index_modern_PropertyType.MESH)),
        b.meshes = _.listMeshes().map( (St, At) => {
            const Et = nt.createPropertyDef(St);
            let Pt = null;
            return Et.primitives = St.listPrimitives().map(It => {
                const Dt = {
                    attributes: {}
                };
                Dt.mode = It.getMode();
                const Gt = It.getMaterial();
                Gt && (Dt.material = nt.materialIndexMap.get(Gt)),
                Object.keys(It.getExtras()).length && (Dt.extras = It.getExtras());
                const Bt = It.getIndices();
                Bt && (Dt.indices = nt.accessorIndexMap.get(Bt));
                for (const kt of It.listSemantics())
                    Dt.attributes[kt] = nt.accessorIndexMap.get(It.getAttribute(kt));
                for (const kt of It.listTargets()) {
                    const Ut = {};
                    for (const Ht of kt.listSemantics())
                        Ut[Ht] = nt.accessorIndexMap.get(kt.getAttribute(Ht));
                    Dt.targets = Dt.targets || [],
                    Dt.targets.push(Ut)
                }
                return It.listTargets().length && !Pt && (Pt = It.listTargets().map(kt => kt.getName())),
                Dt
            }
            ),
            St.getWeights().length && (Et.weights = St.getWeights()),
            Pt && (Et.extras = Et.extras || {},
            Et.extras.targetNames = Pt),
            nt.meshIndexMap.set(St, At),
            Et
        }
        ),
        b.cameras = _.listCameras().map( (St, At) => {
            const Et = nt.createPropertyDef(St);
            if (Et.type = St.getType(),
            Et.type === Camera.Type.PERSPECTIVE) {
                Et.perspective = {
                    znear: St.getZNear(),
                    zfar: St.getZFar(),
                    yfov: St.getYFov()
                };
                const Pt = St.getAspectRatio();
                Pt !== null && (Et.perspective.aspectRatio = Pt)
            } else
                Et.orthographic = {
                    znear: St.getZNear(),
                    zfar: St.getZFar(),
                    xmag: St.getXMag(),
                    ymag: St.getYMag()
                };
            return nt.cameraIndexMap.set(St, At),
            Et
        }
        ),
        b.nodes = _.listNodes().map( (St, At) => {
            const Et = nt.createPropertyDef(St);
            return index_modern_MathUtils.eq(St.getTranslation(), [0, 0, 0]) || (Et.translation = St.getTranslation()),
            index_modern_MathUtils.eq(St.getRotation(), [0, 0, 0, 1]) || (Et.rotation = St.getRotation()),
            index_modern_MathUtils.eq(St.getScale(), [1, 1, 1]) || (Et.scale = St.getScale()),
            St.getWeights().length && (Et.weights = St.getWeights()),
            nt.nodeIndexMap.set(St, At),
            Et
        }
        ),
        b.skins = _.listSkins().map( (St, At) => {
            const Et = nt.createPropertyDef(St)
              , Pt = St.getInverseBindMatrices();
            Pt && (Et.inverseBindMatrices = nt.accessorIndexMap.get(Pt));
            const It = St.getSkeleton();
            return It && (Et.skeleton = nt.nodeIndexMap.get(It)),
            Et.joints = St.listJoints().map(Dt => nt.nodeIndexMap.get(Dt)),
            nt.skinIndexMap.set(St, At),
            Et
        }
        ),
        _.listNodes().forEach( (St, At) => {
            const Et = b.nodes[At]
              , Pt = St.getMesh();
            Pt && (Et.mesh = nt.meshIndexMap.get(Pt));
            const It = St.getCamera();
            It && (Et.camera = nt.cameraIndexMap.get(It));
            const Dt = St.getSkin();
            Dt && (Et.skin = nt.skinIndexMap.get(Dt)),
            St.listChildren().length > 0 && (Et.children = St.listChildren().map(Gt => nt.nodeIndexMap.get(Gt)))
        }
        ),
        b.animations = _.listAnimations().map( (St, At) => {
            const Et = nt.createPropertyDef(St)
              , Pt = new Map;
            return Et.samplers = St.listSamplers().map( (It, Dt) => {
                const Gt = nt.createPropertyDef(It);
                return Gt.input = nt.accessorIndexMap.get(It.getInput()),
                Gt.output = nt.accessorIndexMap.get(It.getOutput()),
                Gt.interpolation = It.getInterpolation(),
                Pt.set(It, Dt),
                Gt
            }
            ),
            Et.channels = St.listChannels().map(It => {
                const Dt = nt.createPropertyDef(It);
                return Dt.sampler = Pt.get(It.getSampler()),
                Dt.target = {
                    node: nt.nodeIndexMap.get(It.getTargetNode()),
                    path: It.getTargetPath()
                },
                Dt
            }
            ),
            nt.animationIndexMap.set(St, At),
            Et
        }
        ),
        b.scenes = _.listScenes().map( (St, At) => {
            const Et = nt.createPropertyDef(St);
            return Et.nodes = St.listChildren().map(Pt => nt.nodeIndexMap.get(Pt)),
            nt.sceneIndexMap.set(St, At),
            Et
        }
        );
        const bt = _.getDefaultScene();
        return bt && (b.scene = _.listScenes().indexOf(bt)),
        b.extensionsUsed = ut.map(St => St.extensionName),
        b.extensionsRequired = pt.map(St => St.extensionName),
        ut.forEach(St => St.write(nt)),
        index_modern_clean(b),
        _e
    }
}
function index_modern_clean(d) {
    const o = [];
    for (const c in d) {
        const h = d[c];
        (Array.isArray(h) && h.length === 0 || h === null || h === "" || h && typeof h == "object" && Object.keys(h).length === 0) && o.push(c)
    }
    for (const c of o)
        delete d[c]
}
var ChunkType;
(function(d) {
    d[d.JSON = 1313821514] = "JSON",
    d[d.BIN = 5130562] = "BIN"
}
)(ChunkType || (ChunkType = {}));
class PlatformIO {
    constructor() {
        this._logger = Logger.DEFAULT_INSTANCE,
        this._extensions = new Set,
        this._dependencies = {},
        this._vertexLayout = VertexLayout.INTERLEAVED,
        this.lastReadBytes = 0,
        this.lastWriteBytes = 0
    }
    setLogger(o) {
        return this._logger = o,
        this
    }
    registerExtensions(o) {
        for (const c of o)
            this._extensions.add(c),
            c.register();
        return this
    }
    registerDependencies(o) {
        return Object.assign(this._dependencies, o),
        this
    }
    setVertexLayout(o) {
        return this._vertexLayout = o,
        this
    }
    async read(o) {
        return await this.readJSON(await this.readAsJSON(o))
    }
    async readAsJSON(o) {
        const c = await this.readURI(o, "view");
        this.lastReadBytes = c.byteLength;
        const h = isGLB(c) ? this._binaryToJSON(c) : {
            json: JSON.parse(index_modern_BufferUtils.decodeText(c)),
            resources: {}
        };
        return await this._readResourcesExternal(h, this.dirname(o)),
        this._readResourcesInternal(h),
        h
    }
    async readJSON(o) {
        return o = this._copyJSON(o),
        this._readResourcesInternal(o),
        GLTFReader.read(o, {
            extensions: Array.from(this._extensions),
            dependencies: this._dependencies,
            logger: this._logger
        })
    }
    async binaryToJSON(o) {
        const c = this._binaryToJSON(index_modern_BufferUtils.assertView(o));
        this._readResourcesInternal(c);
        const h = c.json;
        if (h.buffers && h.buffers.some(_ => isExternalBuffer(c, _)))
            throw new Error("Cannot resolve external buffers with binaryToJSON().");
        if (h.images && h.images.some(_ => isExternalImage(c, _)))
            throw new Error("Cannot resolve external images with binaryToJSON().");
        return c
    }
    async readBinary(o) {
        return this.readJSON(await this.binaryToJSON(index_modern_BufferUtils.assertView(o)))
    }
    async writeJSON(o, c={}) {
        if (c.format === Format.GLB && o.getRoot().listBuffers().length > 1)
            throw new Error("GLB must have 0–1 buffers.");
        return index_modern_GLTFWriter.write(o, {
            format: c.format || Format.GLTF,
            basename: c.basename || "",
            logger: this._logger,
            vertexLayout: this._vertexLayout,
            dependencies: index_modern_extends({}, this._dependencies),
            extensions: Array.from(this._extensions)
        })
    }
    async writeBinary(o) {
        const {json: c, resources: h} = await this.writeJSON(o, {
            format: Format.GLB
        })
          , _ = new Uint32Array([1179937895, 2, 12])
          , b = JSON.stringify(c)
          , _e = index_modern_BufferUtils.pad(index_modern_BufferUtils.encodeText(b), 32)
          , nt = index_modern_BufferUtils.toView(new Uint32Array([_e.byteLength, 1313821514]))
          , it = index_modern_BufferUtils.concat([nt, _e]);
        _[_.length - 1] += it.byteLength;
        const at = Object.values(h)[0];
        if (!at || !at.byteLength)
            return index_modern_BufferUtils.concat([index_modern_BufferUtils.toView(_), it]);
        const ut = index_modern_BufferUtils.pad(at, 0)
          , pt = index_modern_BufferUtils.toView(new Uint32Array([ut.byteLength, 5130562]))
          , ht = index_modern_BufferUtils.concat([pt, ut]);
        return _[_.length - 1] += ht.byteLength,
        index_modern_BufferUtils.concat([index_modern_BufferUtils.toView(_), it, ht])
    }
    async _readResourcesExternal(o, c) {
        var h = this;
        const _ = [...o.json.images || [], ...o.json.buffers || []].map(async function(b) {
            const _e = b.uri;
            if (!_e || _e.match(/data:/))
                return Promise.resolve();
            o.resources[_e] = await h.readURI(h.resolve(c, _e), "view"),
            h.lastReadBytes += o.resources[_e].byteLength
        });
        await Promise.all(_)
    }
    _readResourcesInternal(o) {
        function c(h) {
            if (h.uri) {
                if (h.uri in o.resources)
                    index_modern_BufferUtils.assertView(o.resources[h.uri]);
                else if (h.uri.match(/data:/)) {
                    const _ = `__${index_modern_uuid()}.${index_modern_FileUtils.extension(h.uri)}`;
                    o.resources[_] = index_modern_BufferUtils.createBufferFromDataURI(h.uri),
                    h.uri = _
                }
            }
        }
        (o.json.images || []).forEach(h => {
            if (h.bufferView === void 0 && h.uri === void 0)
                throw new Error("Missing resource URI or buffer view.");
            c(h)
        }
        ),
        (o.json.buffers || []).forEach(c)
    }
    _copyJSON(o) {
        const {images: c, buffers: h} = o.json;
        return o = {
            json: index_modern_extends({}, o.json),
            resources: index_modern_extends({}, o.resources)
        },
        c && (o.json.images = c.map(_ => index_modern_extends({}, _))),
        h && (o.json.buffers = h.map(_ => index_modern_extends({}, _))),
        o
    }
    _binaryToJSON(o) {
        if (!isGLB(o))
            throw new Error("Invalid glTF 2.0 binary.");
        const c = new Uint32Array(o.buffer,o.byteOffset + 12,2);
        if (c[1] !== ChunkType.JSON)
            throw new Error("Missing required GLB JSON chunk.");
        const h = c[0]
          , _ = index_modern_BufferUtils.decodeText(index_modern_BufferUtils.toView(o, 20, h))
          , b = JSON.parse(_)
          , _e = 20 + h;
        if (o.byteLength <= _e)
            return {
                json: b,
                resources: {}
            };
        const nt = new Uint32Array(o.buffer,o.byteOffset + _e,2);
        if (nt[1] !== ChunkType.BIN)
            return {
                json: b,
                resources: {}
            };
        const it = nt[0]
          , at = index_modern_BufferUtils.toView(o, _e + 8, it);
        return {
            json: b,
            resources: {
                [GLB_BUFFER]: at
            }
        }
    }
}
function isExternalBuffer(d, o) {
    return o.uri !== void 0 && !(o.uri in d.resources)
}
function isExternalImage(d, o) {
    return o.uri !== void 0 && !(o.uri in d.resources) && o.bufferView === void 0
}
function isGLB(d) {
    if (d.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT)
        return !1;
    const o = new Uint32Array(d.buffer,d.byteOffset,3);
    return o[0] === 1179937895 && o[1] === 2
}
class WebIO extends PlatformIO {
    constructor(o=HTTPUtils.DEFAULT_INIT) {
        super(),
        this._fetchConfig = void 0,
        this._fetchConfig = o
    }
    async readURI(o, c) {
        const h = await fetch(o, this._fetchConfig);
        switch (c) {
        case "view":
            return new Uint8Array(await h.arrayBuffer());
        case "text":
            return h.text()
        }
    }
    resolve(o, c) {
        return HTTPUtils.resolve(o, c)
    }
    dirname(o) {
        return HTTPUtils.dirname(o)
    }
}
const KHR_SUPERCOMPRESSION_NONE = 0
  , KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0
  , KHR_DF_VENDORID_KHRONOS = 0
  , KHR_DF_VERSION = 2
  , KHR_DF_MODEL_UNSPECIFIED = 0
  , ktx_parse_modern_KHR_DF_MODEL_ETC1S = 163
  , ktx_parse_modern_KHR_DF_MODEL_UASTC = 166
  , KHR_DF_FLAG_ALPHA_STRAIGHT = 0
  , KHR_DF_TRANSFER_SRGB = 2
  , KHR_DF_PRIMARIES_BT709 = 1
  , KHR_DF_SAMPLE_DATATYPE_SIGNED = 64
  , VK_FORMAT_UNDEFINED = 0;
class KTX2Container {
    constructor() {
        this.vkFormat = VK_FORMAT_UNDEFINED,
        this.typeSize = 1,
        this.pixelWidth = 0,
        this.pixelHeight = 0,
        this.pixelDepth = 0,
        this.layerCount = 0,
        this.faceCount = 1,
        this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE,
        this.levels = [],
        this.dataFormatDescriptor = [{
            vendorId: KHR_DF_VENDORID_KHRONOS,
            descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,
            descriptorBlockSize: 0,
            versionNumber: KHR_DF_VERSION,
            colorModel: KHR_DF_MODEL_UNSPECIFIED,
            colorPrimaries: KHR_DF_PRIMARIES_BT709,
            transferFunction: KHR_DF_TRANSFER_SRGB,
            flags: KHR_DF_FLAG_ALPHA_STRAIGHT,
            texelBlockDimension: [0, 0, 0, 0],
            bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
            samples: []
        }],
        this.keyValue = {},
        this.globalData = null
    }
}
class BufferReader {
    constructor(o, c, h, _) {
        this._dataView = void 0,
        this._littleEndian = void 0,
        this._offset = void 0,
        this._dataView = new DataView(o.buffer,o.byteOffset + c,h),
        this._littleEndian = _,
        this._offset = 0
    }
    _nextUint8() {
        const o = this._dataView.getUint8(this._offset);
        return this._offset += 1,
        o
    }
    _nextUint16() {
        const o = this._dataView.getUint16(this._offset, this._littleEndian);
        return this._offset += 2,
        o
    }
    _nextUint32() {
        const o = this._dataView.getUint32(this._offset, this._littleEndian);
        return this._offset += 4,
        o
    }
    _nextUint64() {
        const o = this._dataView.getUint32(this._offset, this._littleEndian) + 4294967296 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
        return this._offset += 8,
        o
    }
    _nextInt32() {
        const o = this._dataView.getInt32(this._offset, this._littleEndian);
        return this._offset += 4,
        o
    }
    _skip(o) {
        return this._offset += o,
        this
    }
    _scan(o, c=0) {
        const h = this._offset;
        let _ = 0;
        for (; this._dataView.getUint8(this._offset) !== c && _ < o; )
            _++,
            this._offset++;
        return _ < o && this._offset++,
        new Uint8Array(this._dataView.buffer,this._dataView.byteOffset + h,_)
    }
}
const KTX2_ID = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function decodeText(d) {
    return typeof TextDecoder < "u" ? new TextDecoder().decode(d) : Buffer.from(d).toString("utf8")
}
function ktx_parse_modern_read(d) {
    const o = new Uint8Array(d.buffer,d.byteOffset,KTX2_ID.length);
    if (o[0] !== KTX2_ID[0] || o[1] !== KTX2_ID[1] || o[2] !== KTX2_ID[2] || o[3] !== KTX2_ID[3] || o[4] !== KTX2_ID[4] || o[5] !== KTX2_ID[5] || o[6] !== KTX2_ID[6] || o[7] !== KTX2_ID[7] || o[8] !== KTX2_ID[8] || o[9] !== KTX2_ID[9] || o[10] !== KTX2_ID[10] || o[11] !== KTX2_ID[11])
        throw new Error("Missing KTX 2.0 identifier.");
    const c = new KTX2Container
      , h = 17 * Uint32Array.BYTES_PER_ELEMENT
      , _ = new BufferReader(d,KTX2_ID.length,h,!0);
    c.vkFormat = _._nextUint32(),
    c.typeSize = _._nextUint32(),
    c.pixelWidth = _._nextUint32(),
    c.pixelHeight = _._nextUint32(),
    c.pixelDepth = _._nextUint32(),
    c.layerCount = _._nextUint32(),
    c.faceCount = _._nextUint32();
    const b = _._nextUint32();
    c.supercompressionScheme = _._nextUint32();
    const _e = _._nextUint32()
      , nt = _._nextUint32()
      , it = _._nextUint32()
      , at = _._nextUint32()
      , ut = _._nextUint64()
      , pt = _._nextUint64()
      , ht = 3 * b * 8
      , _t = new BufferReader(d,KTX2_ID.length + h,ht,!0);
    for (let gr = 0; gr < b; gr++)
        c.levels.push({
            levelData: new Uint8Array(d.buffer,d.byteOffset + _t._nextUint64(),_t._nextUint64()),
            uncompressedByteLength: _t._nextUint64()
        });
    const vt = new BufferReader(d,_e,nt,!0)
      , bt = {
        vendorId: vt._skip(4)._nextUint16(),
        descriptorType: vt._nextUint16(),
        versionNumber: vt._nextUint16(),
        descriptorBlockSize: vt._nextUint16(),
        colorModel: vt._nextUint8(),
        colorPrimaries: vt._nextUint8(),
        transferFunction: vt._nextUint8(),
        flags: vt._nextUint8(),
        texelBlockDimension: [vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8()],
        bytesPlane: [vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8()],
        samples: []
    }
      , St = (bt.descriptorBlockSize / 4 - 6) / 4;
    for (let gr = 0; gr < St; gr++) {
        const dr = {
            bitOffset: vt._nextUint16(),
            bitLength: vt._nextUint8(),
            channelType: vt._nextUint8(),
            samplePosition: [vt._nextUint8(), vt._nextUint8(), vt._nextUint8(), vt._nextUint8()],
            sampleLower: -1 / 0,
            sampleUpper: 1 / 0
        };
        dr.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED ? (dr.sampleLower = vt._nextInt32(),
        dr.sampleUpper = vt._nextInt32()) : (dr.sampleLower = vt._nextUint32(),
        dr.sampleUpper = vt._nextUint32()),
        bt.samples[gr] = dr
    }
    c.dataFormatDescriptor.length = 0,
    c.dataFormatDescriptor.push(bt);
    const At = new BufferReader(d,it,at,!0);
    for (; At._offset < at; ) {
        const gr = At._nextUint32()
          , dr = At._scan(gr)
          , cr = decodeText(dr)
          , Ar = At._scan(gr - dr.byteLength);
        c.keyValue[cr] = cr.match(/^ktx/i) ? decodeText(Ar) : Ar,
        At._offset % 4 && At._skip(4 - At._offset % 4)
    }
    if (pt <= 0)
        return c;
    const Et = new BufferReader(d,ut,pt,!0)
      , Pt = Et._nextUint16()
      , It = Et._nextUint16()
      , Dt = Et._nextUint32()
      , Gt = Et._nextUint32()
      , Bt = Et._nextUint32()
      , kt = Et._nextUint32()
      , Ut = [];
    for (let gr = 0; gr < b; gr++)
        Ut.push({
            imageFlags: Et._nextUint32(),
            rgbSliceByteOffset: Et._nextUint32(),
            rgbSliceByteLength: Et._nextUint32(),
            alphaSliceByteOffset: Et._nextUint32(),
            alphaSliceByteLength: Et._nextUint32()
        });
    const Ht = ut + Et._offset
      , Kt = Ht + Dt
      , Jt = Kt + Gt
      , or = Jt + Bt
      , ir = new Uint8Array(d.buffer,d.byteOffset + Ht,Dt)
      , lr = new Uint8Array(d.buffer,d.byteOffset + Kt,Gt)
      , ar = new Uint8Array(d.buffer,d.byteOffset + Jt,Bt)
      , hr = new Uint8Array(d.buffer,d.byteOffset + or,kt);
    return c.globalData = {
        endpointCount: Pt,
        selectorCount: It,
        imageDescs: Ut,
        endpointsData: ir,
        selectorsData: lr,
        tablesData: ar,
        extendedData: hr
    },
    c
}
const EXT_MESH_GPU_INSTANCING = "EXT_mesh_gpu_instancing"
  , EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression"
  , EXT_TEXTURE_WEBP = "EXT_texture_webp"
  , EXT_TEXTURE_AVIF = "EXT_texture_avif"
  , KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression"
  , KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual"
  , KHR_MATERIALS_ANISOTROPY = "KHR_materials_anisotropy"
  , KHR_MATERIALS_CLEARCOAT = "KHR_materials_clearcoat"
  , KHR_MATERIALS_DIFFUSE_TRANSMISSION = "KHR_materials_diffuse_transmission"
  , KHR_MATERIALS_DISPERSION = "KHR_materials_dispersion"
  , KHR_MATERIALS_EMISSIVE_STRENGTH = "KHR_materials_emissive_strength"
  , KHR_MATERIALS_IOR = "KHR_materials_ior"
  , KHR_MATERIALS_IRIDESCENCE = "KHR_materials_iridescence"
  , KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = "KHR_materials_pbrSpecularGlossiness"
  , KHR_MATERIALS_SHEEN = "KHR_materials_sheen"
  , KHR_MATERIALS_SPECULAR = "KHR_materials_specular"
  , KHR_MATERIALS_TRANSMISSION = "KHR_materials_transmission"
  , KHR_MATERIALS_UNLIT = "KHR_materials_unlit"
  , KHR_MATERIALS_VOLUME = "KHR_materials_volume"
  , KHR_MATERIALS_VARIANTS = "KHR_materials_variants"
  , index_modern_KHR_MESH_QUANTIZATION = "KHR_mesh_quantization"
  , index_modern_KHR_TEXTURE_BASISU = "KHR_texture_basisu"
  , KHR_TEXTURE_TRANSFORM = "KHR_texture_transform"
  , KHR_XMP_JSON_LD = "KHR_xmp_json_ld"
  , INSTANCE_ATTRIBUTE = "INSTANCE_ATTRIBUTE";
class InstancedMesh extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = EXT_MESH_GPU_INSTANCING,
        this.propertyType = "InstancedMesh",
        this.parentTypes = [index_modern_PropertyType.NODE]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            attributes: new RefMap
        })
    }
    getAttribute(o) {
        return this.getRefMap("attributes", o)
    }
    setAttribute(o, c) {
        return this.setRefMap("attributes", o, c, {
            usage: INSTANCE_ATTRIBUTE
        })
    }
    listAttributes() {
        return this.listRefMapValues("attributes")
    }
    listSemantics() {
        return this.listRefMapKeys("attributes")
    }
}
InstancedMesh.EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;
const NAME$o = EXT_MESH_GPU_INSTANCING;
class index_modern_EXTMeshGPUInstancing extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$o,
        this.provideTypes = [index_modern_PropertyType.NODE],
        this.prewriteTypes = [index_modern_PropertyType.ACCESSOR]
    }
    createInstancedMesh() {
        return new InstancedMesh(this.document.getGraph())
    }
    read(o) {
        return (o.jsonDoc.json.nodes || []).forEach( (c, h) => {
            if (!c.extensions || !c.extensions[NAME$o])
                return;
            const _ = c.extensions[NAME$o]
              , b = this.createInstancedMesh();
            for (const _e in _.attributes)
                b.setAttribute(_e, o.accessors[_.attributes[_e]]);
            o.nodes[h].setExtension(NAME$o, b)
        }
        ),
        this
    }
    prewrite(o) {
        o.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);
        for (const c of this.properties)
            for (const h of c.listAttributes())
                o.addAccessorToUsageGroup(h, INSTANCE_ATTRIBUTE);
        return this
    }
    write(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listNodes().forEach(h => {
            const _ = h.getExtension(NAME$o);
            if (_) {
                const b = o.nodeIndexMap.get(h)
                  , _e = c.json.nodes[b]
                  , nt = {
                    attributes: {}
                };
                _.listSemantics().forEach(it => {
                    const at = _.getAttribute(it);
                    nt.attributes[it] = o.accessorIndexMap.get(at)
                }
                ),
                _e.extensions = _e.extensions || {},
                _e.extensions[NAME$o] = nt
            }
        }
        ),
        this
    }
}
function dist_index_modern_extends() {
    return dist_index_modern_extends = Object.assign ? Object.assign.bind() : function(d) {
        for (var o = 1; o < arguments.length; o++) {
            var c = arguments[o];
            for (var h in c)
                ({}).hasOwnProperty.call(c, h) && (d[h] = c[h])
        }
        return d
    }
    ,
    dist_index_modern_extends.apply(null, arguments)
}
var EncoderMethod$1, MeshoptMode, MeshoptFilter;
index_modern_EXTMeshGPUInstancing.EXTENSION_NAME = NAME$o,
function(d) {
    d.QUANTIZE = "quantize",
    d.FILTER = "filter"
}(EncoderMethod$1 || (EncoderMethod$1 = {})),
function(d) {
    d.ATTRIBUTES = "ATTRIBUTES",
    d.TRIANGLES = "TRIANGLES",
    d.INDICES = "INDICES"
}(MeshoptMode || (MeshoptMode = {})),
function(d) {
    d.NONE = "NONE",
    d.OCTAHEDRAL = "OCTAHEDRAL",
    d.QUATERNION = "QUATERNION",
    d.EXPONENTIAL = "EXPONENTIAL"
}(MeshoptFilter || (MeshoptFilter = {}));
const {BYTE, SHORT, FLOAT} = index_modern_Accessor.ComponentType
  , {encodeNormalizedInt, decodeNormalizedInt} = index_modern_MathUtils;
function prepareAccessor(d, o, c, h) {
    const {filter: _, bits: b} = h
      , _e = {
        array: d.getArray(),
        byteStride: d.getElementSize() * d.getComponentSize(),
        componentType: d.getComponentType(),
        normalized: d.getNormalized()
    };
    if (c !== MeshoptMode.ATTRIBUTES)
        return _e;
    if (_ !== MeshoptFilter.NONE) {
        let nt = d.getNormalized() ? decodeNormalizedIntArray(d) : new Float32Array(_e.array);
        switch (_) {
        case MeshoptFilter.EXPONENTIAL:
            _e.byteStride = 4 * d.getElementSize(),
            _e.componentType = FLOAT,
            _e.normalized = !1,
            _e.array = o.encodeFilterExp(nt, d.getCount(), _e.byteStride, b);
            break;
        case MeshoptFilter.OCTAHEDRAL:
            _e.byteStride = b > 8 ? 8 : 4,
            _e.componentType = b > 8 ? SHORT : BYTE,
            _e.normalized = !0,
            nt = d.getElementSize() === 3 ? padNormals(nt) : nt,
            _e.array = o.encodeFilterOct(nt, d.getCount(), _e.byteStride, b);
            break;
        case MeshoptFilter.QUATERNION:
            _e.byteStride = 8,
            _e.componentType = SHORT,
            _e.normalized = !0,
            _e.array = o.encodeFilterQuat(nt, d.getCount(), _e.byteStride, b);
            break;
        default:
            throw new Error("Invalid filter.")
        }
        _e.min = d.getMin([]),
        _e.max = d.getMax([]),
        d.getNormalized() && (_e.min = _e.min.map(it => decodeNormalizedInt(it, d.getComponentType())),
        _e.max = _e.max.map(it => decodeNormalizedInt(it, d.getComponentType()))),
        _e.normalized && (_e.min = _e.min.map(it => encodeNormalizedInt(it, _e.componentType)),
        _e.max = _e.max.map(it => encodeNormalizedInt(it, _e.componentType)))
    } else
        _e.byteStride % 4 && (_e.array = padArrayElements(_e.array, d.getElementSize()),
        _e.byteStride = _e.array.byteLength / d.getCount());
    return _e
}
function decodeNormalizedIntArray(d) {
    const o = d.getComponentType()
      , c = d.getArray()
      , h = new Float32Array(c.length);
    for (let _ = 0; _ < c.length; _++)
        h[_] = decodeNormalizedInt(c[_], o);
    return h
}
function padArrayElements(d, o) {
    const c = index_modern_BufferUtils.padNumber(d.BYTES_PER_ELEMENT * o) / d.BYTES_PER_ELEMENT
      , h = d.length / o
      , _ = new d.constructor(h * c);
    for (let b = 0; b * o < d.length; b++)
        for (let _e = 0; _e < o; _e++)
            _[b * c + _e] = d[b * o + _e];
    return _
}
function padNormals(d) {
    const o = new Float32Array(4 * d.length / 3);
    for (let c = 0, h = d.length / 3; c < h; c++)
        o[4 * c] = d[3 * c],
        o[4 * c + 1] = d[3 * c + 1],
        o[4 * c + 2] = d[3 * c + 2];
    return o
}
function getMeshoptMode(d, o) {
    return o === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER ? d.listParents().some(c => c instanceof index_modern_Primitive && c.getMode() === index_modern_Primitive.Mode.TRIANGLES) ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES : MeshoptMode.ATTRIBUTES
}
function getMeshoptFilter(d, o) {
    const c = o.getGraph().listParentEdges(d).filter(h => !(h.getParent()instanceof index_modern_Root));
    for (const h of c) {
        const _ = h.getName()
          , b = h.getAttributes().key || ""
          , _e = h.getParent().propertyType === index_modern_PropertyType.PRIMITIVE_TARGET;
        if (_ === "indices")
            return {
                filter: MeshoptFilter.NONE
            };
        if (_ === "attributes") {
            if (b === "POSITION")
                return {
                    filter: MeshoptFilter.NONE
                };
            if (b === "TEXCOORD_0")
                return {
                    filter: MeshoptFilter.NONE
                };
            if (b.startsWith("JOINTS_"))
                return {
                    filter: MeshoptFilter.NONE
                };
            if (b.startsWith("WEIGHTS_"))
                return {
                    filter: MeshoptFilter.NONE
                };
            if (b === "NORMAL" || b === "TANGENT")
                return _e ? {
                    filter: MeshoptFilter.NONE
                } : {
                    filter: MeshoptFilter.OCTAHEDRAL,
                    bits: 8
                }
        }
        if (_ === "output") {
            const nt = getTargetPath(d);
            return nt === "rotation" ? {
                filter: MeshoptFilter.QUATERNION,
                bits: 16
            } : nt === "translation" || nt === "scale" ? {
                filter: MeshoptFilter.EXPONENTIAL,
                bits: 12
            } : {
                filter: MeshoptFilter.NONE
            }
        }
        if (_ === "input")
            return {
                filter: MeshoptFilter.NONE
            };
        if (_ === "inverseBindMatrices")
            return {
                filter: MeshoptFilter.NONE
            }
    }
    return {
        filter: MeshoptFilter.NONE
    }
}
function getTargetPath(d) {
    for (const o of d.listParents())
        if (o instanceof index_modern_AnimationSampler) {
            for (const c of o.listParents())
                if (c instanceof index_modern_AnimationChannel)
                    return c.getTargetPath()
        }
    return null
}
function isFallbackBuffer(d) {
    return !(!d.extensions || !d.extensions[EXT_MESHOPT_COMPRESSION]) && !!d.extensions[EXT_MESHOPT_COMPRESSION].fallback
}
const NAME$n = EXT_MESHOPT_COMPRESSION
  , DEFAULT_ENCODER_OPTIONS$1 = {
    method: EncoderMethod$1.QUANTIZE
};
class index_modern_EXTMeshoptCompression extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$n,
        this.prereadTypes = [index_modern_PropertyType.BUFFER, index_modern_PropertyType.PRIMITIVE],
        this.prewriteTypes = [index_modern_PropertyType.BUFFER, index_modern_PropertyType.ACCESSOR],
        this.readDependencies = ["meshopt.decoder"],
        this.writeDependencies = ["meshopt.encoder"],
        this._decoder = null,
        this._decoderFallbackBufferMap = new Map,
        this._encoder = null,
        this._encoderOptions = DEFAULT_ENCODER_OPTIONS$1,
        this._encoderFallbackBuffer = null,
        this._encoderBufferViews = {},
        this._encoderBufferViewData = {},
        this._encoderBufferViewAccessors = {}
    }
    install(o, c) {
        return o === "meshopt.decoder" && (this._decoder = c),
        o === "meshopt.encoder" && (this._encoder = c),
        this
    }
    setEncoderOptions(o) {
        return this._encoderOptions = dist_index_modern_extends({}, DEFAULT_ENCODER_OPTIONS$1, o),
        this
    }
    preread(o, c) {
        if (!this._decoder) {
            if (!this.isRequired())
                return this;
            throw new Error(`[${NAME$n}] Please install extension dependency, "meshopt.decoder".`)
        }
        if (!this._decoder.supported) {
            if (!this.isRequired())
                return this;
            throw new Error(`[${NAME$n}]: Missing WASM support.`)
        }
        return c === index_modern_PropertyType.BUFFER ? this._prereadBuffers(o) : c === index_modern_PropertyType.PRIMITIVE && this._prereadPrimitives(o),
        this
    }
    _prereadBuffers(o) {
        const c = o.jsonDoc;
        (c.json.bufferViews || []).forEach( (h, _) => {
            if (!h.extensions || !h.extensions[NAME$n])
                return;
            const b = h.extensions[NAME$n]
              , _e = b.byteOffset || 0
              , nt = b.byteLength || 0
              , it = b.count
              , at = b.byteStride
              , ut = new Uint8Array(it * at)
              , pt = c.json.buffers[b.buffer]
              , ht = pt.uri ? c.resources[pt.uri] : c.resources[GLB_BUFFER]
              , _t = index_modern_BufferUtils.toView(ht, _e, nt);
            this._decoder.decodeGltfBuffer(ut, it, at, _t, b.mode, b.filter),
            o.bufferViews[_] = ut
        }
        )
    }
    _prereadPrimitives(o) {
        const c = o.jsonDoc;
        (c.json.bufferViews || []).forEach(h => {
            if (!h.extensions || !h.extensions[NAME$n])
                return;
            const _ = h.extensions[NAME$n]
              , b = o.buffers[_.buffer]
              , _e = o.buffers[h.buffer];
            isFallbackBuffer(c.json.buffers[h.buffer]) && this._decoderFallbackBufferMap.set(_e, b)
        }
        )
    }
    read(o) {
        if (!this.isRequired())
            return this;
        for (const [c,h] of this._decoderFallbackBufferMap) {
            for (const _ of c.listParents())
                _ instanceof index_modern_Accessor && _.swap(c, h);
            c.dispose()
        }
        return this
    }
    prewrite(o, c) {
        return c === index_modern_PropertyType.ACCESSOR ? this._prewriteAccessors(o) : c === index_modern_PropertyType.BUFFER && this._prewriteBuffers(o),
        this
    }
    _prewriteAccessors(o) {
        const c = o.jsonDoc.json
          , h = this._encoder
          , _ = this._encoderOptions
          , b = this.document.getGraph()
          , _e = this.document.createBuffer()
          , nt = this.document.getRoot().listBuffers().indexOf(_e);
        let it = 1;
        const at = new Map
          , ut = pt => {
            for (const ht of b.listParents(pt)) {
                if (ht.propertyType === index_modern_PropertyType.ROOT)
                    continue;
                let _t = at.get(pt);
                return _t === void 0 && at.set(pt, _t = it++),
                _t
            }
            return -1
        }
        ;
        this._encoderFallbackBuffer = _e,
        this._encoderBufferViews = {},
        this._encoderBufferViewData = {},
        this._encoderBufferViewAccessors = {};
        for (const pt of this.document.getRoot().listAccessors()) {
            if (getTargetPath(pt) === "weights" || pt.getSparse())
                continue;
            const ht = o.getAccessorUsage(pt)
              , _t = o.accessorUsageGroupedByParent.has(ht) ? ut(pt) : null
              , vt = getMeshoptMode(pt, ht)
              , bt = _.method === EncoderMethod$1.FILTER ? getMeshoptFilter(pt, this.document) : {
                filter: MeshoptFilter.NONE
            }
              , St = prepareAccessor(pt, h, vt, bt)
              , {array: At, byteStride: Et} = St
              , Pt = pt.getBuffer();
            if (!Pt)
                throw new Error(`${NAME$n}: Missing buffer for accessor.`);
            const It = this.document.getRoot().listBuffers().indexOf(Pt)
              , Dt = [ht, _t, vt, bt.filter, Et, It].join(":");
            let Gt = this._encoderBufferViews[Dt]
              , Bt = this._encoderBufferViewData[Dt]
              , kt = this._encoderBufferViewAccessors[Dt];
            Gt && Bt || (kt = this._encoderBufferViewAccessors[Dt] = [],
            Bt = this._encoderBufferViewData[Dt] = [],
            Gt = this._encoderBufferViews[Dt] = {
                buffer: nt,
                target: WriterContext.USAGE_TO_TARGET[ht],
                byteOffset: 0,
                byteLength: 0,
                byteStride: ht === WriterContext.BufferViewUsage.ARRAY_BUFFER ? Et : void 0,
                extensions: {
                    [NAME$n]: {
                        buffer: It,
                        byteOffset: 0,
                        byteLength: 0,
                        mode: vt,
                        filter: bt.filter !== MeshoptFilter.NONE ? bt.filter : void 0,
                        byteStride: Et,
                        count: 0
                    }
                }
            });
            const Ut = o.createAccessorDef(pt);
            Ut.componentType = St.componentType,
            Ut.normalized = St.normalized,
            Ut.byteOffset = Gt.byteLength,
            Ut.min && St.min && (Ut.min = St.min),
            Ut.max && St.max && (Ut.max = St.max),
            o.accessorIndexMap.set(pt, c.accessors.length),
            c.accessors.push(Ut),
            kt.push(Ut),
            Bt.push(new Uint8Array(At.buffer,At.byteOffset,At.byteLength)),
            Gt.byteLength += At.byteLength,
            Gt.extensions.EXT_meshopt_compression.count += pt.getCount()
        }
    }
    _prewriteBuffers(o) {
        const c = this._encoder;
        for (const h in this._encoderBufferViews) {
            const _ = this._encoderBufferViews[h]
              , b = this._encoderBufferViewData[h]
              , _e = this.document.getRoot().listBuffers()[_.extensions[NAME$n].buffer]
              , nt = o.otherBufferViews.get(_e) || []
              , {count: it, byteStride: at, mode: ut} = _.extensions[NAME$n]
              , pt = index_modern_BufferUtils.concat(b)
              , ht = c.encodeGltfBuffer(pt, it, at, ut)
              , _t = index_modern_BufferUtils.pad(ht);
            _.extensions[NAME$n].byteLength = ht.byteLength,
            b.length = 0,
            b.push(_t),
            nt.push(_t),
            o.otherBufferViews.set(_e, nt)
        }
    }
    write(o) {
        let c = 0;
        for (const _e in this._encoderBufferViews) {
            const nt = this._encoderBufferViews[_e]
              , it = this._encoderBufferViewData[_e][0]
              , at = o.otherBufferViewsIndexMap.get(it)
              , ut = this._encoderBufferViewAccessors[_e];
            for (const _t of ut)
                _t.bufferView = at;
            const pt = o.jsonDoc.json.bufferViews[at]
              , ht = pt.byteOffset || 0;
            Object.assign(pt, nt),
            pt.byteOffset = c,
            pt.extensions[NAME$n].byteOffset = ht,
            c += index_modern_BufferUtils.padNumber(nt.byteLength)
        }
        const h = this._encoderFallbackBuffer
          , _ = o.bufferIndexMap.get(h)
          , b = o.jsonDoc.json.buffers[_];
        return b.byteLength = c,
        b.extensions = {
            [NAME$n]: {
                fallback: !0
            }
        },
        h.dispose(),
        this
    }
}
index_modern_EXTMeshoptCompression.EXTENSION_NAME = NAME$n,
index_modern_EXTMeshoptCompression.EncoderMethod = EncoderMethod$1;
const NAME$m = EXT_TEXTURE_AVIF;
class AVIFImageUtils {
    match(o) {
        return o.length >= 12 && index_modern_BufferUtils.decodeText(o.slice(4, 12)) === "ftypavif"
    }
    getSize(o) {
        if (!this.match(o))
            return null;
        const c = new DataView(o.buffer,o.byteOffset,o.byteLength);
        let h = unbox(c, 0);
        if (!h)
            return null;
        let _ = h.end;
        for (; h = unbox(c, _); )
            if (h.type === "meta")
                _ = h.start + 4;
            else if (h.type === "iprp" || h.type === "ipco")
                _ = h.start;
            else {
                if (h.type === "ispe")
                    return [c.getUint32(h.start + 4), c.getUint32(h.start + 8)];
                if (h.type === "mdat")
                    break;
                _ = h.end
            }
        return null
    }
    getChannels(o) {
        return 4
    }
}
class index_modern_EXTTextureAVIF extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$m,
        this.prereadTypes = [index_modern_PropertyType.TEXTURE]
    }
    static register() {
        index_modern_ImageUtils.registerFormat("image/avif", new AVIFImageUtils)
    }
    preread(o) {
        return (o.jsonDoc.json.textures || []).forEach(c => {
            c.extensions && c.extensions[NAME$m] && (c.source = c.extensions[NAME$m].source)
        }
        ),
        this
    }
    read(o) {
        return this
    }
    write(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listTextures().forEach(h => {
            if (h.getMimeType() === "image/avif") {
                const _ = o.imageIndexMap.get(h);
                (c.json.textures || []).forEach(b => {
                    b.source === _ && (b.extensions = b.extensions || {},
                    b.extensions[NAME$m] = {
                        source: b.source
                    },
                    delete b.source)
                }
                )
            }
        }
        ),
        this
    }
}
function unbox(d, o) {
    if (d.byteLength < 4 + o)
        return null;
    const c = d.getUint32(o);
    return d.byteLength < c + o || c < 8 ? null : {
        type: index_modern_BufferUtils.decodeText(new Uint8Array(d.buffer,d.byteOffset + o + 4,4)),
        start: o + 8,
        end: o + c
    }
}
index_modern_EXTTextureAVIF.EXTENSION_NAME = NAME$m;
const NAME$l = EXT_TEXTURE_WEBP;
class WEBPImageUtils {
    match(o) {
        return o.length >= 12 && o[8] === 87 && o[9] === 69 && o[10] === 66 && o[11] === 80
    }
    getSize(o) {
        const c = index_modern_BufferUtils.decodeText(o.slice(0, 4))
          , h = index_modern_BufferUtils.decodeText(o.slice(8, 12));
        if (c !== "RIFF" || h !== "WEBP")
            return null;
        const _ = new DataView(o.buffer,o.byteOffset);
        let b = 12;
        for (; b < _.byteLength; ) {
            const _e = index_modern_BufferUtils.decodeText(new Uint8Array([_.getUint8(b), _.getUint8(b + 1), _.getUint8(b + 2), _.getUint8(b + 3)]))
              , nt = _.getUint32(b + 4, !0);
            if (_e === "VP8 ")
                return [16383 & _.getInt16(b + 14, !0), 16383 & _.getInt16(b + 16, !0)];
            if (_e === "VP8L") {
                const it = _.getUint8(b + 9)
                  , at = _.getUint8(b + 10)
                  , ut = _.getUint8(b + 11);
                return [1 + ((63 & at) << 8 | it), 1 + ((15 & _.getUint8(b + 12)) << 10 | ut << 2 | (192 & at) >> 6)]
            }
            b += 8 + nt + nt % 2
        }
        return null
    }
    getChannels(o) {
        return 4
    }
}
class index_modern_EXTTextureWebP extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$l,
        this.prereadTypes = [index_modern_PropertyType.TEXTURE]
    }
    static register() {
        index_modern_ImageUtils.registerFormat("image/webp", new WEBPImageUtils)
    }
    preread(o) {
        return (o.jsonDoc.json.textures || []).forEach(c => {
            c.extensions && c.extensions[NAME$l] && (c.source = c.extensions[NAME$l].source)
        }
        ),
        this
    }
    read(o) {
        return this
    }
    write(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listTextures().forEach(h => {
            if (h.getMimeType() === "image/webp") {
                const _ = o.imageIndexMap.get(h);
                (c.json.textures || []).forEach(b => {
                    b.source === _ && (b.extensions = b.extensions || {},
                    b.extensions[NAME$l] = {
                        source: b.source
                    },
                    delete b.source)
                }
                )
            }
        }
        ),
        this
    }
}
index_modern_EXTTextureWebP.EXTENSION_NAME = NAME$l;
const NAME$k = KHR_DRACO_MESH_COMPRESSION;
let decoderModule, COMPONENT_ARRAY, DATA_TYPE, encoderModule;
function decodeGeometry(d, o) {
    const c = new decoderModule.DecoderBuffer;
    try {
        if (c.Init(o, o.length),
        d.GetEncodedGeometryType(c) !== decoderModule.TRIANGULAR_MESH)
            throw new Error(`[${NAME$k}] Unknown geometry type.`);
        const h = new decoderModule.Mesh;
        if (!d.DecodeBufferToMesh(c, h).ok() || h.ptr === 0)
            throw new Error(`[${NAME$k}] Decoding failure.`);
        return h
    } finally {
        decoderModule.destroy(c)
    }
}
function decodeIndex(d, o) {
    const c = 3 * o.num_faces();
    let h, _;
    if (o.num_points() <= 65534) {
        const b = c * Uint16Array.BYTES_PER_ELEMENT;
        h = decoderModule._malloc(b),
        d.GetTrianglesUInt16Array(o, b, h),
        _ = new Uint16Array(decoderModule.HEAPU16.buffer,h,c).slice()
    } else {
        const b = c * Uint32Array.BYTES_PER_ELEMENT;
        h = decoderModule._malloc(b),
        d.GetTrianglesUInt32Array(o, b, h),
        _ = new Uint32Array(decoderModule.HEAPU32.buffer,h,c).slice()
    }
    return decoderModule._free(h),
    _
}
function decodeAttribute(d, o, c, h) {
    const _ = DATA_TYPE[h.componentType]
      , b = COMPONENT_ARRAY[h.componentType]
      , _e = c.num_components()
      , nt = o.num_points() * _e
      , it = nt * b.BYTES_PER_ELEMENT
      , at = decoderModule._malloc(it);
    d.GetAttributeDataArrayForAllPoints(o, c, _, it, at);
    const ut = new b(decoderModule.HEAPF32.buffer,at,nt).slice();
    return decoderModule._free(at),
    ut
}
function initDecoderModule(d) {
    decoderModule = d,
    COMPONENT_ARRAY = {
        [index_modern_Accessor.ComponentType.FLOAT]: Float32Array,
        [index_modern_Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,
        [index_modern_Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,
        [index_modern_Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,
        [index_modern_Accessor.ComponentType.SHORT]: Int16Array,
        [index_modern_Accessor.ComponentType.BYTE]: Int8Array
    },
    DATA_TYPE = {
        [index_modern_Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,
        [index_modern_Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,
        [index_modern_Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,
        [index_modern_Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,
        [index_modern_Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,
        [index_modern_Accessor.ComponentType.BYTE]: decoderModule.DT_INT8
    }
}
var index_modern_EncoderMethod, AttributeEnum;
(function(d) {
    d[d.EDGEBREAKER = 1] = "EDGEBREAKER",
    d[d.SEQUENTIAL = 0] = "SEQUENTIAL"
}
)(index_modern_EncoderMethod || (index_modern_EncoderMethod = {})),
function(d) {
    d.POSITION = "POSITION",
    d.NORMAL = "NORMAL",
    d.COLOR = "COLOR",
    d.TEX_COORD = "TEX_COORD",
    d.GENERIC = "GENERIC"
}(AttributeEnum || (AttributeEnum = {}));
const DEFAULT_QUANTIZATION_BITS = {
    [AttributeEnum.POSITION]: 14,
    [AttributeEnum.NORMAL]: 10,
    [AttributeEnum.COLOR]: 8,
    [AttributeEnum.TEX_COORD]: 12,
    [AttributeEnum.GENERIC]: 12
}
  , DEFAULT_ENCODER_OPTIONS = {
    decodeSpeed: 5,
    encodeSpeed: 5,
    method: index_modern_EncoderMethod.EDGEBREAKER,
    quantizationBits: DEFAULT_QUANTIZATION_BITS,
    quantizationVolume: "mesh"
};
function initEncoderModule(d) {
    encoderModule = d
}
function encodeGeometry(d, o=DEFAULT_ENCODER_OPTIONS) {
    const c = dist_index_modern_extends({}, DEFAULT_ENCODER_OPTIONS, o);
    c.quantizationBits = dist_index_modern_extends({}, DEFAULT_QUANTIZATION_BITS, o.quantizationBits);
    const h = new encoderModule.MeshBuilder
      , _ = new encoderModule.Mesh
      , b = new encoderModule.ExpertEncoder(_)
      , _e = {}
      , nt = new encoderModule.DracoInt8Array
      , it = d.listTargets().length > 0;
    let at = !1;
    for (const bt of d.listSemantics()) {
        const St = d.getAttribute(bt);
        if (St.getSparse()) {
            at = !0;
            continue
        }
        const At = getAttributeEnum(bt)
          , Et = addAttribute(h, St.getComponentType(), _, encoderModule[At], St.getCount(), St.getElementSize(), St.getArray());
        if (Et === -1)
            throw new Error(`Error compressing "${bt}" attribute.`);
        if (_e[bt] = Et,
        c.quantizationVolume === "mesh" || bt !== "POSITION")
            b.SetAttributeQuantization(Et, c.quantizationBits[At]);
        else {
            if (typeof c.quantizationVolume != "object")
                throw new Error("Invalid quantization volume state.");
            {
                const {quantizationVolume: Pt} = c
                  , It = Math.max(Pt.max[0] - Pt.min[0], Pt.max[1] - Pt.min[1], Pt.max[2] - Pt.min[2]);
                b.SetAttributeExplicitQuantization(Et, c.quantizationBits[At], St.getElementSize(), Pt.min, It)
            }
        }
    }
    const ut = d.getIndices();
    if (!ut)
        throw new EncodingError("Primitive must have indices.");
    h.AddFacesToMesh(_, ut.getCount() / 3, ut.getArray()),
    b.SetSpeedOptions(c.encodeSpeed, c.decodeSpeed),
    b.SetTrackEncodedProperties(!0),
    c.method === index_modern_EncoderMethod.SEQUENTIAL || it || at ? b.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING) : b.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);
    const pt = b.EncodeToDracoBuffer(!(it || at), nt);
    if (pt <= 0)
        throw new EncodingError("Error applying Draco compression.");
    const ht = new Uint8Array(pt);
    for (let bt = 0; bt < pt; ++bt)
        ht[bt] = nt.GetValue(bt);
    const _t = b.GetNumberOfEncodedPoints()
      , vt = 3 * b.GetNumberOfEncodedFaces();
    return encoderModule.destroy(nt),
    encoderModule.destroy(_),
    encoderModule.destroy(h),
    encoderModule.destroy(b),
    {
        numVertices: _t,
        numIndices: vt,
        data: ht,
        attributeIDs: _e
    }
}
function getAttributeEnum(d) {
    return d === "POSITION" ? AttributeEnum.POSITION : d === "NORMAL" ? AttributeEnum.NORMAL : d.startsWith("COLOR_") ? AttributeEnum.COLOR : d.startsWith("TEXCOORD_") ? AttributeEnum.TEX_COORD : AttributeEnum.GENERIC
}
function addAttribute(d, o, c, h, _, b, _e) {
    switch (o) {
    case index_modern_Accessor.ComponentType.UNSIGNED_BYTE:
        return d.AddUInt8Attribute(c, h, _, b, _e);
    case index_modern_Accessor.ComponentType.BYTE:
        return d.AddInt8Attribute(c, h, _, b, _e);
    case index_modern_Accessor.ComponentType.UNSIGNED_SHORT:
        return d.AddUInt16Attribute(c, h, _, b, _e);
    case index_modern_Accessor.ComponentType.SHORT:
        return d.AddInt16Attribute(c, h, _, b, _e);
    case index_modern_Accessor.ComponentType.UNSIGNED_INT:
        return d.AddUInt32Attribute(c, h, _, b, _e);
    case index_modern_Accessor.ComponentType.FLOAT:
        return d.AddFloatAttribute(c, h, _, b, _e);
    default:
        throw new Error(`Unexpected component type, "${o}".`)
    }
}
class EncodingError extends Error {
}
const NAME$j = KHR_DRACO_MESH_COMPRESSION;
class index_modern_KHRDracoMeshCompression extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$j,
        this.prereadTypes = [index_modern_PropertyType.PRIMITIVE],
        this.prewriteTypes = [index_modern_PropertyType.ACCESSOR],
        this.readDependencies = ["draco3d.decoder"],
        this.writeDependencies = ["draco3d.encoder"],
        this._decoderModule = null,
        this._encoderModule = null,
        this._encoderOptions = {}
    }
    install(o, c) {
        return o === "draco3d.decoder" && (this._decoderModule = c,
        initDecoderModule(this._decoderModule)),
        o === "draco3d.encoder" && (this._encoderModule = c,
        initEncoderModule(this._encoderModule)),
        this
    }
    setEncoderOptions(o) {
        return this._encoderOptions = o,
        this
    }
    preread(o) {
        if (!this._decoderModule)
            throw new Error(`[${NAME$j}] Please install extension dependency, "draco3d.decoder".`);
        const c = this.document.getLogger()
          , h = o.jsonDoc
          , _ = new Map;
        try {
            const b = h.json.meshes || [];
            for (const _e of b)
                for (const nt of _e.primitives) {
                    if (!nt.extensions || !nt.extensions[NAME$j])
                        continue;
                    const it = nt.extensions[NAME$j];
                    let[at,ut] = _.get(it.bufferView) || [];
                    if (!ut || !at) {
                        const pt = h.json.bufferViews[it.bufferView]
                          , ht = h.json.buffers[pt.buffer]
                          , _t = ht.uri ? h.resources[ht.uri] : h.resources[GLB_BUFFER]
                          , vt = pt.byteOffset || 0
                          , bt = pt.byteLength
                          , St = index_modern_BufferUtils.toView(_t, vt, bt);
                        at = new this._decoderModule.Decoder,
                        ut = decodeGeometry(at, St),
                        _.set(it.bufferView, [at, ut]),
                        c.debug(`[${NAME$j}] Decompressed ${St.byteLength} bytes.`)
                    }
                    for (const pt in nt.attributes) {
                        const ht = o.jsonDoc.json.accessors[nt.attributes[pt]]
                          , _t = at.GetAttributeByUniqueId(ut, it.attributes[pt])
                          , vt = decodeAttribute(at, ut, _t, ht);
                        o.accessors[nt.attributes[pt]].setArray(vt)
                    }
                    nt.indices !== void 0 && o.accessors[nt.indices].setArray(decodeIndex(at, ut))
                }
        } finally {
            for (const [b,_e] of Array.from(_.values()))
                this._decoderModule.destroy(b),
                this._decoderModule.destroy(_e)
        }
        return this
    }
    read(o) {
        return this
    }
    prewrite(o, c) {
        if (!this._encoderModule)
            throw new Error(`[${NAME$j}] Please install extension dependency, "draco3d.encoder".`);
        const h = this.document.getLogger();
        h.debug(`[${NAME$j}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
        const _ = listDracoPrimitives(this.document)
          , b = new Map;
        let _e = "mesh";
        this._encoderOptions.quantizationVolume === "scene" && (this.document.getRoot().listScenes().length !== 1 ? h.warn(`[${NAME$j}]: quantizationVolume=scene requires exactly 1 scene.`) : _e = getBounds(this.document.getRoot().listScenes().pop()));
        for (const nt of Array.from(_.keys())) {
            const it = _.get(nt);
            if (!it)
                throw new Error("Unexpected primitive.");
            if (b.has(it)) {
                b.set(it, b.get(it));
                continue
            }
            const at = nt.getIndices()
              , ut = o.jsonDoc.json.accessors;
            let pt;
            try {
                pt = encodeGeometry(nt, dist_index_modern_extends({}, this._encoderOptions, {
                    quantizationVolume: _e
                }))
            } catch (vt) {
                if (vt instanceof EncodingError) {
                    h.warn(`[${NAME$j}]: ${vt.message} Skipping primitive compression.`);
                    continue
                }
                throw vt
            }
            b.set(it, pt);
            const ht = o.createAccessorDef(at);
            ht.count = pt.numIndices,
            o.accessorIndexMap.set(at, ut.length),
            ut.push(ht),
            pt.numVertices > 65534 && index_modern_Accessor.getComponentSize(ht.componentType) <= 2 ? ht.componentType = index_modern_Accessor.ComponentType.UNSIGNED_INT : pt.numVertices > 254 && index_modern_Accessor.getComponentSize(ht.componentType) <= 1 && (ht.componentType = index_modern_Accessor.ComponentType.UNSIGNED_SHORT);
            for (const vt of nt.listSemantics()) {
                const bt = nt.getAttribute(vt);
                if (pt.attributeIDs[vt] === void 0)
                    continue;
                const St = o.createAccessorDef(bt);
                St.count = pt.numVertices,
                o.accessorIndexMap.set(bt, ut.length),
                ut.push(St)
            }
            const _t = nt.getAttribute("POSITION").getBuffer() || this.document.getRoot().listBuffers()[0];
            o.otherBufferViews.has(_t) || o.otherBufferViews.set(_t, []),
            o.otherBufferViews.get(_t).push(pt.data)
        }
        return h.debug(`[${NAME$j}] Compressed ${_.size} primitives.`),
        o.extensionData[NAME$j] = {
            primitiveHashMap: _,
            primitiveEncodingMap: b
        },
        this
    }
    write(o) {
        const c = o.extensionData[NAME$j];
        for (const h of this.document.getRoot().listMeshes()) {
            const _ = o.jsonDoc.json.meshes[o.meshIndexMap.get(h)];
            for (let b = 0; b < h.listPrimitives().length; b++) {
                const _e = h.listPrimitives()[b]
                  , nt = _.primitives[b]
                  , it = c.primitiveHashMap.get(_e);
                if (!it)
                    continue;
                const at = c.primitiveEncodingMap.get(it);
                at && (nt.extensions = nt.extensions || {},
                nt.extensions[NAME$j] = {
                    bufferView: o.otherBufferViewsIndexMap.get(at.data),
                    attributes: at.attributeIDs
                })
            }
        }
        if (!c.primitiveHashMap.size) {
            const h = o.jsonDoc.json;
            h.extensionsUsed = (h.extensionsUsed || []).filter(_ => _ !== NAME$j),
            h.extensionsRequired = (h.extensionsRequired || []).filter(_ => _ !== NAME$j)
        }
        return this
    }
}
function listDracoPrimitives(d) {
    const o = d.getLogger()
      , c = new Set
      , h = new Set;
    let _ = 0
      , b = 0;
    for (const pt of d.getRoot().listMeshes())
        for (const ht of pt.listPrimitives())
            ht.getIndices() ? ht.getMode() !== index_modern_Primitive.Mode.TRIANGLES ? (h.add(ht),
            b++) : c.add(ht) : (h.add(ht),
            _++);
    _ > 0 && o.warn(`[${NAME$j}] Skipping Draco compression of ${_} non-indexed primitives.`),
    b > 0 && o.warn(`[${NAME$j}] Skipping Draco compression of ${b} non-TRIANGLES primitives.`);
    const _e = d.getRoot().listAccessors()
      , nt = new Map;
    for (let pt = 0; pt < _e.length; pt++)
        nt.set(_e[pt], pt);
    const it = new Map
      , at = new Set
      , ut = new Map;
    for (const pt of Array.from(c)) {
        let ht = createHashKey(pt, nt);
        if (at.has(ht))
            ut.set(pt, ht);
        else {
            if (it.has(pt.getIndices())) {
                const _t = pt.getIndices()
                  , vt = _t.clone();
                nt.set(vt, d.getRoot().listAccessors().length - 1),
                pt.swap(_t, vt)
            }
            for (const _t of pt.listAttributes())
                if (it.has(_t)) {
                    const vt = _t.clone();
                    nt.set(vt, d.getRoot().listAccessors().length - 1),
                    pt.swap(_t, vt)
                }
            ht = createHashKey(pt, nt),
            at.add(ht),
            ut.set(pt, ht),
            it.set(pt.getIndices(), ht);
            for (const _t of pt.listAttributes())
                it.set(_t, ht)
        }
    }
    for (const pt of Array.from(it.keys())) {
        const ht = new Set(pt.listParents().map(_t => _t.propertyType));
        if (ht.size !== 2 || !ht.has(index_modern_PropertyType.PRIMITIVE) || !ht.has(index_modern_PropertyType.ROOT))
            throw new Error(`[${NAME$j}] Compressed accessors must only be used as indices or vertex attributes.`)
    }
    for (const pt of Array.from(c)) {
        const ht = ut.get(pt)
          , _t = pt.getIndices();
        if (it.get(_t) !== ht || pt.listAttributes().some(vt => it.get(vt) !== ht))
            throw new Error(`[${NAME$j}] Draco primitives must share all, or no, accessors.`)
    }
    for (const pt of Array.from(h)) {
        const ht = pt.getIndices();
        if (it.has(ht) || pt.listAttributes().some(_t => it.has(_t)))
            throw new Error(`[${NAME$j}] Accessor cannot be shared by compressed and uncompressed primitives.`)
    }
    return ut
}
function createHashKey(d, o) {
    const c = []
      , h = d.getIndices();
    c.push(o.get(h));
    for (const _ of d.listAttributes())
        c.push(o.get(_));
    return c.sort().join("|")
}
index_modern_KHRDracoMeshCompression.EXTENSION_NAME = NAME$j,
index_modern_KHRDracoMeshCompression.EncoderMethod = index_modern_EncoderMethod;
class Light extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_LIGHTS_PUNCTUAL,
        this.propertyType = "Light",
        this.parentTypes = [index_modern_PropertyType.NODE]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            color: [1, 1, 1],
            intensity: 1,
            type: Light.Type.POINT,
            range: null,
            innerConeAngle: 0,
            outerConeAngle: Math.PI / 4
        })
    }
    getColor() {
        return this.get("color")
    }
    setColor(o) {
        return this.set("color", o)
    }
    getIntensity() {
        return this.get("intensity")
    }
    setIntensity(o) {
        return this.set("intensity", o)
    }
    getType() {
        return this.get("type")
    }
    setType(o) {
        return this.set("type", o)
    }
    getRange() {
        return this.get("range")
    }
    setRange(o) {
        return this.set("range", o)
    }
    getInnerConeAngle() {
        return this.get("innerConeAngle")
    }
    setInnerConeAngle(o) {
        return this.set("innerConeAngle", o)
    }
    getOuterConeAngle() {
        return this.get("outerConeAngle")
    }
    setOuterConeAngle(o) {
        return this.set("outerConeAngle", o)
    }
}
Light.EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL,
Light.Type = {
    POINT: "point",
    SPOT: "spot",
    DIRECTIONAL: "directional"
};
const NAME$i = KHR_LIGHTS_PUNCTUAL;
class KHRLightsPunctual extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$i
    }
    createLight(o="") {
        return new Light(this.document.getGraph(),o)
    }
    read(o) {
        const c = o.jsonDoc;
        if (!c.json.extensions || !c.json.extensions[NAME$i])
            return this;
        const h = (c.json.extensions[NAME$i].lights || []).map(_ => {
            var b, _e;
            const nt = this.createLight().setName(_.name || "").setType(_.type);
            return _.color !== void 0 && nt.setColor(_.color),
            _.intensity !== void 0 && nt.setIntensity(_.intensity),
            _.range !== void 0 && nt.setRange(_.range),
            ((b = _.spot) == null ? void 0 : b.innerConeAngle) !== void 0 && nt.setInnerConeAngle(_.spot.innerConeAngle),
            ((_e = _.spot) == null ? void 0 : _e.outerConeAngle) !== void 0 && nt.setOuterConeAngle(_.spot.outerConeAngle),
            nt
        }
        );
        return c.json.nodes.forEach( (_, b) => {
            if (!_.extensions || !_.extensions[NAME$i])
                return;
            const _e = _.extensions[NAME$i];
            o.nodes[b].setExtension(NAME$i, h[_e.light])
        }
        ),
        this
    }
    write(o) {
        const c = o.jsonDoc;
        if (this.properties.size === 0)
            return this;
        const h = []
          , _ = new Map;
        for (const b of this.properties) {
            const _e = b
              , nt = {
                type: _e.getType()
            };
            index_modern_MathUtils.eq(_e.getColor(), [1, 1, 1]) || (nt.color = _e.getColor()),
            _e.getIntensity() !== 1 && (nt.intensity = _e.getIntensity()),
            _e.getRange() != null && (nt.range = _e.getRange()),
            _e.getName() && (nt.name = _e.getName()),
            _e.getType() === Light.Type.SPOT && (nt.spot = {
                innerConeAngle: _e.getInnerConeAngle(),
                outerConeAngle: _e.getOuterConeAngle()
            }),
            h.push(nt),
            _.set(_e, h.length - 1)
        }
        return this.document.getRoot().listNodes().forEach(b => {
            const _e = b.getExtension(NAME$i);
            if (_e) {
                const nt = o.nodeIndexMap.get(b)
                  , it = c.json.nodes[nt];
                it.extensions = it.extensions || {},
                it.extensions[NAME$i] = {
                    light: _.get(_e)
                }
            }
        }
        ),
        c.json.extensions = c.json.extensions || {},
        c.json.extensions[NAME$i] = {
            lights: h
        },
        this
    }
}
KHRLightsPunctual.EXTENSION_NAME = NAME$i;
const {R: R$7, G: G$7, B: B$5} = index_modern_TextureChannel;
class Anisotropy extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_ANISOTROPY,
        this.propertyType = "Anisotropy",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            anisotropyStrength: 0,
            anisotropyRotation: 0,
            anisotropyTexture: null,
            anisotropyTextureInfo: new index_modern_TextureInfo(this.graph,"anisotropyTextureInfo")
        })
    }
    getAnisotropyStrength() {
        return this.get("anisotropyStrength")
    }
    setAnisotropyStrength(o) {
        return this.set("anisotropyStrength", o)
    }
    getAnisotropyRotation() {
        return this.get("anisotropyRotation")
    }
    setAnisotropyRotation(o) {
        return this.set("anisotropyRotation", o)
    }
    getAnisotropyTexture() {
        return this.getRef("anisotropyTexture")
    }
    getAnisotropyTextureInfo() {
        return this.getRef("anisotropyTexture") ? this.getRef("anisotropyTextureInfo") : null
    }
    setAnisotropyTexture(o) {
        return this.setRef("anisotropyTexture", o, {
            channels: R$7 | G$7 | B$5
        })
    }
}
Anisotropy.EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;
const NAME$h = KHR_MATERIALS_ANISOTROPY;
class KHRMaterialsAnisotropy extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$h,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createAnisotropy() {
        return new Anisotropy(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$h]) {
                const nt = this.createAnisotropy();
                o.materials[_e].setExtension(NAME$h, nt);
                const it = b.extensions[NAME$h];
                if (it.anisotropyStrength !== void 0 && nt.setAnisotropyStrength(it.anisotropyStrength),
                it.anisotropyRotation !== void 0 && nt.setAnisotropyRotation(it.anisotropyRotation),
                it.anisotropyTexture !== void 0) {
                    const at = it.anisotropyTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setAnisotropyTexture(ut),
                    o.setTextureInfo(nt.getAnisotropyTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$h);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$h] = {};
                if (_.getAnisotropyStrength() > 0 && (nt.anisotropyStrength = _.getAnisotropyStrength()),
                _.getAnisotropyRotation() !== 0 && (nt.anisotropyRotation = _.getAnisotropyRotation()),
                _.getAnisotropyTexture()) {
                    const it = _.getAnisotropyTexture()
                      , at = _.getAnisotropyTextureInfo();
                    nt.anisotropyTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsAnisotropy.EXTENSION_NAME = NAME$h;
const {R: R$6, G: G$6, B: B$4} = index_modern_TextureChannel;
class Clearcoat extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_CLEARCOAT,
        this.propertyType = "Clearcoat",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            clearcoatFactor: 0,
            clearcoatTexture: null,
            clearcoatTextureInfo: new index_modern_TextureInfo(this.graph,"clearcoatTextureInfo"),
            clearcoatRoughnessFactor: 0,
            clearcoatRoughnessTexture: null,
            clearcoatRoughnessTextureInfo: new index_modern_TextureInfo(this.graph,"clearcoatRoughnessTextureInfo"),
            clearcoatNormalScale: 1,
            clearcoatNormalTexture: null,
            clearcoatNormalTextureInfo: new index_modern_TextureInfo(this.graph,"clearcoatNormalTextureInfo")
        })
    }
    getClearcoatFactor() {
        return this.get("clearcoatFactor")
    }
    setClearcoatFactor(o) {
        return this.set("clearcoatFactor", o)
    }
    getClearcoatTexture() {
        return this.getRef("clearcoatTexture")
    }
    getClearcoatTextureInfo() {
        return this.getRef("clearcoatTexture") ? this.getRef("clearcoatTextureInfo") : null
    }
    setClearcoatTexture(o) {
        return this.setRef("clearcoatTexture", o, {
            channels: R$6
        })
    }
    getClearcoatRoughnessFactor() {
        return this.get("clearcoatRoughnessFactor")
    }
    setClearcoatRoughnessFactor(o) {
        return this.set("clearcoatRoughnessFactor", o)
    }
    getClearcoatRoughnessTexture() {
        return this.getRef("clearcoatRoughnessTexture")
    }
    getClearcoatRoughnessTextureInfo() {
        return this.getRef("clearcoatRoughnessTexture") ? this.getRef("clearcoatRoughnessTextureInfo") : null
    }
    setClearcoatRoughnessTexture(o) {
        return this.setRef("clearcoatRoughnessTexture", o, {
            channels: G$6
        })
    }
    getClearcoatNormalScale() {
        return this.get("clearcoatNormalScale")
    }
    setClearcoatNormalScale(o) {
        return this.set("clearcoatNormalScale", o)
    }
    getClearcoatNormalTexture() {
        return this.getRef("clearcoatNormalTexture")
    }
    getClearcoatNormalTextureInfo() {
        return this.getRef("clearcoatNormalTexture") ? this.getRef("clearcoatNormalTextureInfo") : null
    }
    setClearcoatNormalTexture(o) {
        return this.setRef("clearcoatNormalTexture", o, {
            channels: R$6 | G$6 | B$4
        })
    }
}
Clearcoat.EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;
const NAME$g = KHR_MATERIALS_CLEARCOAT;
class KHRMaterialsClearcoat extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$g,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createClearcoat() {
        return new Clearcoat(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$g]) {
                const nt = this.createClearcoat();
                o.materials[_e].setExtension(NAME$g, nt);
                const it = b.extensions[NAME$g];
                if (it.clearcoatFactor !== void 0 && nt.setClearcoatFactor(it.clearcoatFactor),
                it.clearcoatRoughnessFactor !== void 0 && nt.setClearcoatRoughnessFactor(it.clearcoatRoughnessFactor),
                it.clearcoatTexture !== void 0) {
                    const at = it.clearcoatTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setClearcoatTexture(ut),
                    o.setTextureInfo(nt.getClearcoatTextureInfo(), at)
                }
                if (it.clearcoatRoughnessTexture !== void 0) {
                    const at = it.clearcoatRoughnessTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setClearcoatRoughnessTexture(ut),
                    o.setTextureInfo(nt.getClearcoatRoughnessTextureInfo(), at)
                }
                if (it.clearcoatNormalTexture !== void 0) {
                    const at = it.clearcoatNormalTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setClearcoatNormalTexture(ut),
                    o.setTextureInfo(nt.getClearcoatNormalTextureInfo(), at),
                    at.scale !== void 0 && nt.setClearcoatNormalScale(at.scale)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$g);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$g] = {
                    clearcoatFactor: _.getClearcoatFactor(),
                    clearcoatRoughnessFactor: _.getClearcoatRoughnessFactor()
                };
                if (_.getClearcoatTexture()) {
                    const it = _.getClearcoatTexture()
                      , at = _.getClearcoatTextureInfo();
                    nt.clearcoatTexture = o.createTextureInfoDef(it, at)
                }
                if (_.getClearcoatRoughnessTexture()) {
                    const it = _.getClearcoatRoughnessTexture()
                      , at = _.getClearcoatRoughnessTextureInfo();
                    nt.clearcoatRoughnessTexture = o.createTextureInfoDef(it, at)
                }
                if (_.getClearcoatNormalTexture()) {
                    const it = _.getClearcoatNormalTexture()
                      , at = _.getClearcoatNormalTextureInfo();
                    nt.clearcoatNormalTexture = o.createTextureInfoDef(it, at),
                    _.getClearcoatNormalScale() !== 1 && (nt.clearcoatNormalTexture.scale = _.getClearcoatNormalScale())
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsClearcoat.EXTENSION_NAME = NAME$g;
const {R: R$5, G: G$5, B: B$3, A: A$3} = index_modern_TextureChannel;
class DiffuseTransmission extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION,
        this.propertyType = "DiffuseTransmission",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            diffuseTransmissionFactor: 0,
            diffuseTransmissionTexture: null,
            diffuseTransmissionTextureInfo: new index_modern_TextureInfo(this.graph,"diffuseTransmissionTextureInfo"),
            diffuseTransmissionColorFactor: [1, 1, 1],
            diffuseTransmissionColorTexture: null,
            diffuseTransmissionColorTextureInfo: new index_modern_TextureInfo(this.graph,"diffuseTransmissionColorTextureInfo")
        })
    }
    getDiffuseTransmissionFactor() {
        return this.get("diffuseTransmissionFactor")
    }
    setDiffuseTransmissionFactor(o) {
        return this.set("diffuseTransmissionFactor", o)
    }
    getDiffuseTransmissionTexture() {
        return this.getRef("diffuseTransmissionTexture")
    }
    getDiffuseTransmissionTextureInfo() {
        return this.getRef("diffuseTransmissionTexture") ? this.getRef("diffuseTransmissionTextureInfo") : null
    }
    setDiffuseTransmissionTexture(o) {
        return this.setRef("diffuseTransmissionTexture", o, {
            channels: A$3
        })
    }
    getDiffuseTransmissionColorFactor() {
        return this.get("diffuseTransmissionColorFactor")
    }
    setDiffuseTransmissionColorFactor(o) {
        return this.set("diffuseTransmissionColorFactor", o)
    }
    getDiffuseTransmissionColorTexture() {
        return this.getRef("diffuseTransmissionColorTexture")
    }
    getDiffuseTransmissionColorTextureInfo() {
        return this.getRef("diffuseTransmissionColorTexture") ? this.getRef("diffuseTransmissionColorTextureInfo") : null
    }
    setDiffuseTransmissionColorTexture(o) {
        return this.setRef("diffuseTransmissionColorTexture", o, {
            channels: R$5 | G$5 | B$3
        })
    }
}
DiffuseTransmission.EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
const NAME$f = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
class KHRMaterialsDiffuseTransmission extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$f
    }
    createDiffuseTransmission() {
        return new DiffuseTransmission(this.document.getGraph())
    }
    read(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$f]) {
                const nt = this.createDiffuseTransmission();
                o.materials[_e].setExtension(NAME$f, nt);
                const it = b.extensions[NAME$f];
                if (it.diffuseTransmissionFactor !== void 0 && nt.setDiffuseTransmissionFactor(it.diffuseTransmissionFactor),
                it.diffuseTransmissionColorFactor !== void 0 && nt.setDiffuseTransmissionColorFactor(it.diffuseTransmissionColorFactor),
                it.diffuseTransmissionTexture !== void 0) {
                    const at = it.diffuseTransmissionTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setDiffuseTransmissionTexture(ut),
                    o.setTextureInfo(nt.getDiffuseTransmissionTextureInfo(), at)
                }
                if (it.diffuseTransmissionColorTexture !== void 0) {
                    const at = it.diffuseTransmissionColorTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setDiffuseTransmissionColorTexture(ut),
                    o.setTextureInfo(nt.getDiffuseTransmissionColorTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    write(o) {
        const c = o.jsonDoc;
        for (const h of this.document.getRoot().listMaterials()) {
            const _ = h.getExtension(NAME$f);
            if (!_)
                continue;
            const b = o.materialIndexMap.get(h)
              , _e = c.json.materials[b];
            _e.extensions = _e.extensions || {};
            const nt = _e.extensions[NAME$f] = {
                diffuseTransmissionFactor: _.getDiffuseTransmissionFactor(),
                diffuseTransmissionColorFactor: _.getDiffuseTransmissionColorFactor()
            };
            if (_.getDiffuseTransmissionTexture()) {
                const it = _.getDiffuseTransmissionTexture()
                  , at = _.getDiffuseTransmissionTextureInfo();
                nt.diffuseTransmissionTexture = o.createTextureInfoDef(it, at)
            }
            if (_.getDiffuseTransmissionColorTexture()) {
                const it = _.getDiffuseTransmissionColorTexture()
                  , at = _.getDiffuseTransmissionColorTextureInfo();
                nt.diffuseTransmissionColorTexture = o.createTextureInfoDef(it, at)
            }
        }
        return this
    }
}
KHRMaterialsDiffuseTransmission.EXTENSION_NAME = NAME$f;
class Dispersion extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_DISPERSION,
        this.propertyType = "Dispersion",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            dispersion: 0
        })
    }
    getDispersion() {
        return this.get("dispersion")
    }
    setDispersion(o) {
        return this.set("dispersion", o)
    }
}
Dispersion.EXTENSION_NAME = KHR_MATERIALS_DISPERSION;
const NAME$e = KHR_MATERIALS_DISPERSION;
class KHRMaterialsDispersion extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$e,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createDispersion() {
        return new Dispersion(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        return (o.jsonDoc.json.materials || []).forEach( (c, h) => {
            if (c.extensions && c.extensions[NAME$e]) {
                const _ = this.createDispersion();
                o.materials[h].setExtension(NAME$e, _);
                const b = c.extensions[NAME$e];
                b.dispersion !== void 0 && _.setDispersion(b.dispersion)
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$e);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {},
                _e.extensions[NAME$e] = {
                    dispersion: _.getDispersion()
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsDispersion.EXTENSION_NAME = NAME$e;
class EmissiveStrength extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH,
        this.propertyType = "EmissiveStrength",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            emissiveStrength: 1
        })
    }
    getEmissiveStrength() {
        return this.get("emissiveStrength")
    }
    setEmissiveStrength(o) {
        return this.set("emissiveStrength", o)
    }
}
EmissiveStrength.EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;
const NAME$d = KHR_MATERIALS_EMISSIVE_STRENGTH;
class KHRMaterialsEmissiveStrength extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$d,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createEmissiveStrength() {
        return new EmissiveStrength(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        return (o.jsonDoc.json.materials || []).forEach( (c, h) => {
            if (c.extensions && c.extensions[NAME$d]) {
                const _ = this.createEmissiveStrength();
                o.materials[h].setExtension(NAME$d, _);
                const b = c.extensions[NAME$d];
                b.emissiveStrength !== void 0 && _.setEmissiveStrength(b.emissiveStrength)
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$d);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {},
                _e.extensions[NAME$d] = {
                    emissiveStrength: _.getEmissiveStrength()
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsEmissiveStrength.EXTENSION_NAME = NAME$d;
class IOR extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_IOR,
        this.propertyType = "IOR",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            ior: 1.5
        })
    }
    getIOR() {
        return this.get("ior")
    }
    setIOR(o) {
        return this.set("ior", o)
    }
}
IOR.EXTENSION_NAME = KHR_MATERIALS_IOR;
const NAME$c = KHR_MATERIALS_IOR;
class KHRMaterialsIOR extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$c,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createIOR() {
        return new IOR(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        return (o.jsonDoc.json.materials || []).forEach( (c, h) => {
            if (c.extensions && c.extensions[NAME$c]) {
                const _ = this.createIOR();
                o.materials[h].setExtension(NAME$c, _);
                const b = c.extensions[NAME$c];
                b.ior !== void 0 && _.setIOR(b.ior)
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$c);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {},
                _e.extensions[NAME$c] = {
                    ior: _.getIOR()
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsIOR.EXTENSION_NAME = NAME$c;
const {R: R$4, G: G$4} = index_modern_TextureChannel;
class Iridescence extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_IRIDESCENCE,
        this.propertyType = "Iridescence",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            iridescenceFactor: 0,
            iridescenceTexture: null,
            iridescenceTextureInfo: new index_modern_TextureInfo(this.graph,"iridescenceTextureInfo"),
            iridescenceIOR: 1.3,
            iridescenceThicknessMinimum: 100,
            iridescenceThicknessMaximum: 400,
            iridescenceThicknessTexture: null,
            iridescenceThicknessTextureInfo: new index_modern_TextureInfo(this.graph,"iridescenceThicknessTextureInfo")
        })
    }
    getIridescenceFactor() {
        return this.get("iridescenceFactor")
    }
    setIridescenceFactor(o) {
        return this.set("iridescenceFactor", o)
    }
    getIridescenceTexture() {
        return this.getRef("iridescenceTexture")
    }
    getIridescenceTextureInfo() {
        return this.getRef("iridescenceTexture") ? this.getRef("iridescenceTextureInfo") : null
    }
    setIridescenceTexture(o) {
        return this.setRef("iridescenceTexture", o, {
            channels: R$4
        })
    }
    getIridescenceIOR() {
        return this.get("iridescenceIOR")
    }
    setIridescenceIOR(o) {
        return this.set("iridescenceIOR", o)
    }
    getIridescenceThicknessMinimum() {
        return this.get("iridescenceThicknessMinimum")
    }
    setIridescenceThicknessMinimum(o) {
        return this.set("iridescenceThicknessMinimum", o)
    }
    getIridescenceThicknessMaximum() {
        return this.get("iridescenceThicknessMaximum")
    }
    setIridescenceThicknessMaximum(o) {
        return this.set("iridescenceThicknessMaximum", o)
    }
    getIridescenceThicknessTexture() {
        return this.getRef("iridescenceThicknessTexture")
    }
    getIridescenceThicknessTextureInfo() {
        return this.getRef("iridescenceThicknessTexture") ? this.getRef("iridescenceThicknessTextureInfo") : null
    }
    setIridescenceThicknessTexture(o) {
        return this.setRef("iridescenceThicknessTexture", o, {
            channels: G$4
        })
    }
}
Iridescence.EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;
const NAME$b = KHR_MATERIALS_IRIDESCENCE;
class KHRMaterialsIridescence extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$b,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createIridescence() {
        return new Iridescence(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$b]) {
                const nt = this.createIridescence();
                o.materials[_e].setExtension(NAME$b, nt);
                const it = b.extensions[NAME$b];
                if (it.iridescenceFactor !== void 0 && nt.setIridescenceFactor(it.iridescenceFactor),
                it.iridescenceIor !== void 0 && nt.setIridescenceIOR(it.iridescenceIor),
                it.iridescenceThicknessMinimum !== void 0 && nt.setIridescenceThicknessMinimum(it.iridescenceThicknessMinimum),
                it.iridescenceThicknessMaximum !== void 0 && nt.setIridescenceThicknessMaximum(it.iridescenceThicknessMaximum),
                it.iridescenceTexture !== void 0) {
                    const at = it.iridescenceTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setIridescenceTexture(ut),
                    o.setTextureInfo(nt.getIridescenceTextureInfo(), at)
                }
                if (it.iridescenceThicknessTexture !== void 0) {
                    const at = it.iridescenceThicknessTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setIridescenceThicknessTexture(ut),
                    o.setTextureInfo(nt.getIridescenceThicknessTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$b);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$b] = {};
                if (_.getIridescenceFactor() > 0 && (nt.iridescenceFactor = _.getIridescenceFactor()),
                _.getIridescenceIOR() !== 1.3 && (nt.iridescenceIor = _.getIridescenceIOR()),
                _.getIridescenceThicknessMinimum() !== 100 && (nt.iridescenceThicknessMinimum = _.getIridescenceThicknessMinimum()),
                _.getIridescenceThicknessMaximum() !== 400 && (nt.iridescenceThicknessMaximum = _.getIridescenceThicknessMaximum()),
                _.getIridescenceTexture()) {
                    const it = _.getIridescenceTexture()
                      , at = _.getIridescenceTextureInfo();
                    nt.iridescenceTexture = o.createTextureInfoDef(it, at)
                }
                if (_.getIridescenceThicknessTexture()) {
                    const it = _.getIridescenceThicknessTexture()
                      , at = _.getIridescenceThicknessTextureInfo();
                    nt.iridescenceThicknessTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsIridescence.EXTENSION_NAME = NAME$b;
const {R: R$3, G: G$3, B: B$2$1, A: A$2} = index_modern_TextureChannel;
class PBRSpecularGlossiness extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.propertyType = "PBRSpecularGlossiness",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            diffuseFactor: [1, 1, 1, 1],
            diffuseTexture: null,
            diffuseTextureInfo: new index_modern_TextureInfo(this.graph,"diffuseTextureInfo"),
            specularFactor: [1, 1, 1],
            glossinessFactor: 1,
            specularGlossinessTexture: null,
            specularGlossinessTextureInfo: new index_modern_TextureInfo(this.graph,"specularGlossinessTextureInfo")
        })
    }
    getDiffuseFactor() {
        return this.get("diffuseFactor")
    }
    setDiffuseFactor(o) {
        return this.set("diffuseFactor", o)
    }
    getDiffuseTexture() {
        return this.getRef("diffuseTexture")
    }
    getDiffuseTextureInfo() {
        return this.getRef("diffuseTexture") ? this.getRef("diffuseTextureInfo") : null
    }
    setDiffuseTexture(o) {
        return this.setRef("diffuseTexture", o, {
            channels: R$3 | G$3 | B$2$1 | A$2,
            isColor: !0
        })
    }
    getSpecularFactor() {
        return this.get("specularFactor")
    }
    setSpecularFactor(o) {
        return this.set("specularFactor", o)
    }
    getGlossinessFactor() {
        return this.get("glossinessFactor")
    }
    setGlossinessFactor(o) {
        return this.set("glossinessFactor", o)
    }
    getSpecularGlossinessTexture() {
        return this.getRef("specularGlossinessTexture")
    }
    getSpecularGlossinessTextureInfo() {
        return this.getRef("specularGlossinessTexture") ? this.getRef("specularGlossinessTextureInfo") : null
    }
    setSpecularGlossinessTexture(o) {
        return this.setRef("specularGlossinessTexture", o, {
            channels: R$3 | G$3 | B$2$1 | A$2
        })
    }
}
PBRSpecularGlossiness.EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
const NAME$a = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
class KHRMaterialsPBRSpecularGlossiness extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$a,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createPBRSpecularGlossiness() {
        return new PBRSpecularGlossiness(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$a]) {
                const nt = this.createPBRSpecularGlossiness();
                o.materials[_e].setExtension(NAME$a, nt);
                const it = b.extensions[NAME$a];
                if (it.diffuseFactor !== void 0 && nt.setDiffuseFactor(it.diffuseFactor),
                it.specularFactor !== void 0 && nt.setSpecularFactor(it.specularFactor),
                it.glossinessFactor !== void 0 && nt.setGlossinessFactor(it.glossinessFactor),
                it.diffuseTexture !== void 0) {
                    const at = it.diffuseTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setDiffuseTexture(ut),
                    o.setTextureInfo(nt.getDiffuseTextureInfo(), at)
                }
                if (it.specularGlossinessTexture !== void 0) {
                    const at = it.specularGlossinessTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setSpecularGlossinessTexture(ut),
                    o.setTextureInfo(nt.getSpecularGlossinessTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$a);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$a] = {
                    diffuseFactor: _.getDiffuseFactor(),
                    specularFactor: _.getSpecularFactor(),
                    glossinessFactor: _.getGlossinessFactor()
                };
                if (_.getDiffuseTexture()) {
                    const it = _.getDiffuseTexture()
                      , at = _.getDiffuseTextureInfo();
                    nt.diffuseTexture = o.createTextureInfoDef(it, at)
                }
                if (_.getSpecularGlossinessTexture()) {
                    const it = _.getSpecularGlossinessTexture()
                      , at = _.getSpecularGlossinessTextureInfo();
                    nt.specularGlossinessTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsPBRSpecularGlossiness.EXTENSION_NAME = NAME$a;
const {R: R$2$1, G: G$2$1, B: B$1$1, A: A$1$1} = index_modern_TextureChannel;
class Sheen extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_SHEEN,
        this.propertyType = "Sheen",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            sheenColorFactor: [0, 0, 0],
            sheenColorTexture: null,
            sheenColorTextureInfo: new index_modern_TextureInfo(this.graph,"sheenColorTextureInfo"),
            sheenRoughnessFactor: 0,
            sheenRoughnessTexture: null,
            sheenRoughnessTextureInfo: new index_modern_TextureInfo(this.graph,"sheenRoughnessTextureInfo")
        })
    }
    getSheenColorFactor() {
        return this.get("sheenColorFactor")
    }
    setSheenColorFactor(o) {
        return this.set("sheenColorFactor", o)
    }
    getSheenColorTexture() {
        return this.getRef("sheenColorTexture")
    }
    getSheenColorTextureInfo() {
        return this.getRef("sheenColorTexture") ? this.getRef("sheenColorTextureInfo") : null
    }
    setSheenColorTexture(o) {
        return this.setRef("sheenColorTexture", o, {
            channels: R$2$1 | G$2$1 | B$1$1,
            isColor: !0
        })
    }
    getSheenRoughnessFactor() {
        return this.get("sheenRoughnessFactor")
    }
    setSheenRoughnessFactor(o) {
        return this.set("sheenRoughnessFactor", o)
    }
    getSheenRoughnessTexture() {
        return this.getRef("sheenRoughnessTexture")
    }
    getSheenRoughnessTextureInfo() {
        return this.getRef("sheenRoughnessTexture") ? this.getRef("sheenRoughnessTextureInfo") : null
    }
    setSheenRoughnessTexture(o) {
        return this.setRef("sheenRoughnessTexture", o, {
            channels: A$1$1
        })
    }
}
Sheen.EXTENSION_NAME = KHR_MATERIALS_SHEEN;
const NAME$9 = KHR_MATERIALS_SHEEN;
class KHRMaterialsSheen extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$9,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createSheen() {
        return new Sheen(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$9]) {
                const nt = this.createSheen();
                o.materials[_e].setExtension(NAME$9, nt);
                const it = b.extensions[NAME$9];
                if (it.sheenColorFactor !== void 0 && nt.setSheenColorFactor(it.sheenColorFactor),
                it.sheenRoughnessFactor !== void 0 && nt.setSheenRoughnessFactor(it.sheenRoughnessFactor),
                it.sheenColorTexture !== void 0) {
                    const at = it.sheenColorTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setSheenColorTexture(ut),
                    o.setTextureInfo(nt.getSheenColorTextureInfo(), at)
                }
                if (it.sheenRoughnessTexture !== void 0) {
                    const at = it.sheenRoughnessTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setSheenRoughnessTexture(ut),
                    o.setTextureInfo(nt.getSheenRoughnessTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$9);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$9] = {
                    sheenColorFactor: _.getSheenColorFactor(),
                    sheenRoughnessFactor: _.getSheenRoughnessFactor()
                };
                if (_.getSheenColorTexture()) {
                    const it = _.getSheenColorTexture()
                      , at = _.getSheenColorTextureInfo();
                    nt.sheenColorTexture = o.createTextureInfoDef(it, at)
                }
                if (_.getSheenRoughnessTexture()) {
                    const it = _.getSheenRoughnessTexture()
                      , at = _.getSheenRoughnessTextureInfo();
                    nt.sheenRoughnessTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsSheen.EXTENSION_NAME = NAME$9;
const {R: R$1$1, G: G$1$1, B: dist_index_modern_B, A: dist_index_modern_A} = index_modern_TextureChannel;
class Specular extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_SPECULAR,
        this.propertyType = "Specular",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            specularFactor: 1,
            specularTexture: null,
            specularTextureInfo: new index_modern_TextureInfo(this.graph,"specularTextureInfo"),
            specularColorFactor: [1, 1, 1],
            specularColorTexture: null,
            specularColorTextureInfo: new index_modern_TextureInfo(this.graph,"specularColorTextureInfo")
        })
    }
    getSpecularFactor() {
        return this.get("specularFactor")
    }
    setSpecularFactor(o) {
        return this.set("specularFactor", o)
    }
    getSpecularColorFactor() {
        return this.get("specularColorFactor")
    }
    setSpecularColorFactor(o) {
        return this.set("specularColorFactor", o)
    }
    getSpecularTexture() {
        return this.getRef("specularTexture")
    }
    getSpecularTextureInfo() {
        return this.getRef("specularTexture") ? this.getRef("specularTextureInfo") : null
    }
    setSpecularTexture(o) {
        return this.setRef("specularTexture", o, {
            channels: dist_index_modern_A
        })
    }
    getSpecularColorTexture() {
        return this.getRef("specularColorTexture")
    }
    getSpecularColorTextureInfo() {
        return this.getRef("specularColorTexture") ? this.getRef("specularColorTextureInfo") : null
    }
    setSpecularColorTexture(o) {
        return this.setRef("specularColorTexture", o, {
            channels: R$1$1 | G$1$1 | dist_index_modern_B,
            isColor: !0
        })
    }
}
Specular.EXTENSION_NAME = KHR_MATERIALS_SPECULAR;
const NAME$8 = KHR_MATERIALS_SPECULAR;
class KHRMaterialsSpecular extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$8,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createSpecular() {
        return new Specular(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$8]) {
                const nt = this.createSpecular();
                o.materials[_e].setExtension(NAME$8, nt);
                const it = b.extensions[NAME$8];
                if (it.specularFactor !== void 0 && nt.setSpecularFactor(it.specularFactor),
                it.specularColorFactor !== void 0 && nt.setSpecularColorFactor(it.specularColorFactor),
                it.specularTexture !== void 0) {
                    const at = it.specularTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setSpecularTexture(ut),
                    o.setTextureInfo(nt.getSpecularTextureInfo(), at)
                }
                if (it.specularColorTexture !== void 0) {
                    const at = it.specularColorTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setSpecularColorTexture(ut),
                    o.setTextureInfo(nt.getSpecularColorTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$8);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$8] = {};
                if (_.getSpecularFactor() !== 1 && (nt.specularFactor = _.getSpecularFactor()),
                index_modern_MathUtils.eq(_.getSpecularColorFactor(), [1, 1, 1]) || (nt.specularColorFactor = _.getSpecularColorFactor()),
                _.getSpecularTexture()) {
                    const it = _.getSpecularTexture()
                      , at = _.getSpecularTextureInfo();
                    nt.specularTexture = o.createTextureInfoDef(it, at)
                }
                if (_.getSpecularColorTexture()) {
                    const it = _.getSpecularColorTexture()
                      , at = _.getSpecularColorTextureInfo();
                    nt.specularColorTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsSpecular.EXTENSION_NAME = NAME$8;
const {R: dist_index_modern_R} = index_modern_TextureChannel;
class Transmission extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_TRANSMISSION,
        this.propertyType = "Transmission",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            transmissionFactor: 0,
            transmissionTexture: null,
            transmissionTextureInfo: new index_modern_TextureInfo(this.graph,"transmissionTextureInfo")
        })
    }
    getTransmissionFactor() {
        return this.get("transmissionFactor")
    }
    setTransmissionFactor(o) {
        return this.set("transmissionFactor", o)
    }
    getTransmissionTexture() {
        return this.getRef("transmissionTexture")
    }
    getTransmissionTextureInfo() {
        return this.getRef("transmissionTexture") ? this.getRef("transmissionTextureInfo") : null
    }
    setTransmissionTexture(o) {
        return this.setRef("transmissionTexture", o, {
            channels: dist_index_modern_R
        })
    }
}
Transmission.EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;
const NAME$7 = KHR_MATERIALS_TRANSMISSION;
class KHRMaterialsTransmission extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$7,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createTransmission() {
        return new Transmission(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$7]) {
                const nt = this.createTransmission();
                o.materials[_e].setExtension(NAME$7, nt);
                const it = b.extensions[NAME$7];
                if (it.transmissionFactor !== void 0 && nt.setTransmissionFactor(it.transmissionFactor),
                it.transmissionTexture !== void 0) {
                    const at = it.transmissionTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setTransmissionTexture(ut),
                    o.setTextureInfo(nt.getTransmissionTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$7);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$7] = {
                    transmissionFactor: _.getTransmissionFactor()
                };
                if (_.getTransmissionTexture()) {
                    const it = _.getTransmissionTexture()
                      , at = _.getTransmissionTextureInfo();
                    nt.transmissionTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsTransmission.EXTENSION_NAME = NAME$7;
class Unlit extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_UNLIT,
        this.propertyType = "Unlit",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
}
Unlit.EXTENSION_NAME = KHR_MATERIALS_UNLIT;
const NAME$6 = KHR_MATERIALS_UNLIT;
class index_modern_KHRMaterialsUnlit extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$6,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createUnlit() {
        return new Unlit(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        return (o.jsonDoc.json.materials || []).forEach( (c, h) => {
            c.extensions && c.extensions[NAME$6] && o.materials[h].setExtension(NAME$6, this.createUnlit())
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            if (h.getExtension(NAME$6)) {
                const _ = o.materialIndexMap.get(h)
                  , b = c.json.materials[_];
                b.extensions = b.extensions || {},
                b.extensions[NAME$6] = {}
            }
        }
        ),
        this
    }
}
index_modern_KHRMaterialsUnlit.EXTENSION_NAME = NAME$6;
class Mapping extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_VARIANTS,
        this.propertyType = "Mapping",
        this.parentTypes = ["MappingList"]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            material: null,
            variants: new RefSet
        })
    }
    getMaterial() {
        return this.getRef("material")
    }
    setMaterial(o) {
        return this.setRef("material", o)
    }
    addVariant(o) {
        return this.addRef("variants", o)
    }
    removeVariant(o) {
        return this.removeRef("variants", o)
    }
    listVariants() {
        return this.listRefs("variants")
    }
}
Mapping.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
class MappingList extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_VARIANTS,
        this.propertyType = "MappingList",
        this.parentTypes = [index_modern_PropertyType.PRIMITIVE]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            mappings: new RefSet
        })
    }
    addMapping(o) {
        return this.addRef("mappings", o)
    }
    removeMapping(o) {
        return this.removeRef("mappings", o)
    }
    listMappings() {
        return this.listRefs("mappings")
    }
}
MappingList.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
class Variant extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_VARIANTS,
        this.propertyType = "Variant",
        this.parentTypes = ["MappingList"]
    }
}
Variant.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;
const NAME$5 = KHR_MATERIALS_VARIANTS;
class KHRMaterialsVariants extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$5
    }
    createMappingList() {
        return new MappingList(this.document.getGraph())
    }
    createVariant(o="") {
        return new Variant(this.document.getGraph(),o)
    }
    createMapping() {
        return new Mapping(this.document.getGraph())
    }
    listVariants() {
        return Array.from(this.properties).filter(o => o instanceof Variant)
    }
    read(o) {
        const c = o.jsonDoc;
        if (!c.json.extensions || !c.json.extensions[NAME$5])
            return this;
        const h = (c.json.extensions[NAME$5].variants || []).map(_ => this.createVariant().setName(_.name || ""));
        return (c.json.meshes || []).forEach( (_, b) => {
            const _e = o.meshes[b];
            (_.primitives || []).forEach( (nt, it) => {
                if (!nt.extensions || !nt.extensions[NAME$5])
                    return;
                const at = this.createMappingList()
                  , ut = nt.extensions[NAME$5];
                for (const pt of ut.mappings) {
                    const ht = this.createMapping();
                    pt.material !== void 0 && ht.setMaterial(o.materials[pt.material]);
                    for (const _t of pt.variants || [])
                        ht.addVariant(h[_t]);
                    at.addMapping(ht)
                }
                _e.listPrimitives()[it].setExtension(NAME$5, at)
            }
            )
        }
        ),
        this
    }
    write(o) {
        const c = o.jsonDoc
          , h = this.listVariants();
        if (!h.length)
            return this;
        const _ = []
          , b = new Map;
        for (const _e of h)
            b.set(_e, _.length),
            _.push(o.createPropertyDef(_e));
        for (const _e of this.document.getRoot().listMeshes()) {
            const nt = o.meshIndexMap.get(_e);
            _e.listPrimitives().forEach( (it, at) => {
                const ut = it.getExtension(NAME$5);
                if (!ut)
                    return;
                const pt = o.jsonDoc.json.meshes[nt].primitives[at]
                  , ht = ut.listMappings().map(_t => {
                    const vt = o.createPropertyDef(_t)
                      , bt = _t.getMaterial();
                    return bt && (vt.material = o.materialIndexMap.get(bt)),
                    vt.variants = _t.listVariants().map(St => b.get(St)),
                    vt
                }
                );
                pt.extensions = pt.extensions || {},
                pt.extensions[NAME$5] = {
                    mappings: ht
                }
            }
            )
        }
        return c.json.extensions = c.json.extensions || {},
        c.json.extensions[NAME$5] = {
            variants: _
        },
        this
    }
}
KHRMaterialsVariants.EXTENSION_NAME = NAME$5;
const {G: dist_index_modern_G} = index_modern_TextureChannel;
class Volume extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_MATERIALS_VOLUME,
        this.propertyType = "Volume",
        this.parentTypes = [index_modern_PropertyType.MATERIAL]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            thicknessFactor: 0,
            thicknessTexture: null,
            thicknessTextureInfo: new index_modern_TextureInfo(this.graph,"thicknessTexture"),
            attenuationDistance: 1 / 0,
            attenuationColor: [1, 1, 1]
        })
    }
    getThicknessFactor() {
        return this.get("thicknessFactor")
    }
    setThicknessFactor(o) {
        return this.set("thicknessFactor", o)
    }
    getThicknessTexture() {
        return this.getRef("thicknessTexture")
    }
    getThicknessTextureInfo() {
        return this.getRef("thicknessTexture") ? this.getRef("thicknessTextureInfo") : null
    }
    setThicknessTexture(o) {
        return this.setRef("thicknessTexture", o, {
            channels: dist_index_modern_G
        })
    }
    getAttenuationDistance() {
        return this.get("attenuationDistance")
    }
    setAttenuationDistance(o) {
        return this.set("attenuationDistance", o)
    }
    getAttenuationColor() {
        return this.get("attenuationColor")
    }
    setAttenuationColor(o) {
        return this.set("attenuationColor", o)
    }
}
Volume.EXTENSION_NAME = KHR_MATERIALS_VOLUME;
const NAME$4 = KHR_MATERIALS_VOLUME;
class KHRMaterialsVolume extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$4,
        this.prereadTypes = [index_modern_PropertyType.MESH],
        this.prewriteTypes = [index_modern_PropertyType.MESH]
    }
    createVolume() {
        return new Volume(this.document.getGraph())
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
    preread(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            if (b.extensions && b.extensions[NAME$4]) {
                const nt = this.createVolume();
                o.materials[_e].setExtension(NAME$4, nt);
                const it = b.extensions[NAME$4];
                if (it.thicknessFactor !== void 0 && nt.setThicknessFactor(it.thicknessFactor),
                it.attenuationDistance !== void 0 && nt.setAttenuationDistance(it.attenuationDistance),
                it.attenuationColor !== void 0 && nt.setAttenuationColor(it.attenuationColor),
                it.thicknessTexture !== void 0) {
                    const at = it.thicknessTexture
                      , ut = o.textures[_[at.index].source];
                    nt.setThicknessTexture(ut),
                    o.setTextureInfo(nt.getThicknessTextureInfo(), at)
                }
            }
        }
        ),
        this
    }
    prewrite(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(NAME$4);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = _e.extensions[NAME$4] = {};
                if (_.getThicknessFactor() > 0 && (nt.thicknessFactor = _.getThicknessFactor()),
                Number.isFinite(_.getAttenuationDistance()) && (nt.attenuationDistance = _.getAttenuationDistance()),
                index_modern_MathUtils.eq(_.getAttenuationColor(), [1, 1, 1]) || (nt.attenuationColor = _.getAttenuationColor()),
                _.getThicknessTexture()) {
                    const it = _.getThicknessTexture()
                      , at = _.getThicknessTextureInfo();
                    nt.thicknessTexture = o.createTextureInfoDef(it, at)
                }
            }
        }
        ),
        this
    }
}
KHRMaterialsVolume.EXTENSION_NAME = NAME$4;
const NAME$3 = index_modern_KHR_MESH_QUANTIZATION;
class index_modern_KHRMeshQuantization extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$3
    }
    read(o) {
        return this
    }
    write(o) {
        return this
    }
}
index_modern_KHRMeshQuantization.EXTENSION_NAME = NAME$3;
const NAME$2 = index_modern_KHR_TEXTURE_BASISU;
class KTX2ImageUtils {
    match(o) {
        return o[0] === 171 && o[1] === 75 && o[2] === 84 && o[3] === 88 && o[4] === 32 && o[5] === 50 && o[6] === 48 && o[7] === 187 && o[8] === 13 && o[9] === 10 && o[10] === 26 && o[11] === 10
    }
    getSize(o) {
        const c = ktx_parse_modern_read(o);
        return [c.pixelWidth, c.pixelHeight]
    }
    getChannels(o) {
        const c = ktx_parse_modern_read(o).dataFormatDescriptor[0];
        if (c.colorModel === ktx_parse_modern_KHR_DF_MODEL_ETC1S)
            return c.samples.length !== 2 || 15 & ~c.samples[1].channelType ? 3 : 4;
        if (c.colorModel === ktx_parse_modern_KHR_DF_MODEL_UASTC)
            return (15 & c.samples[0].channelType) == 3 ? 4 : 3;
        throw new Error(`Unexpected KTX2 colorModel, "${c.colorModel}".`)
    }
    getVRAMByteLength(o) {
        const c = ktx_parse_modern_read(o)
          , h = this.getChannels(o) > 3;
        let _ = 0;
        for (let b = 0; b < c.levels.length; b++) {
            const _e = c.levels[b];
            _e.uncompressedByteLength ? _ += _e.uncompressedByteLength : _ += Math.max(1, Math.floor(c.pixelWidth / Math.pow(2, b))) / 4 * (Math.max(1, Math.floor(c.pixelHeight / Math.pow(2, b))) / 4) * (h ? 16 : 8)
        }
        return _
    }
}
class KHRTextureBasisu extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$2,
        this.prereadTypes = [index_modern_PropertyType.TEXTURE]
    }
    static register() {
        index_modern_ImageUtils.registerFormat("image/ktx2", new KTX2ImageUtils)
    }
    preread(o) {
        return o.jsonDoc.json.textures.forEach(c => {
            if (c.extensions && c.extensions[NAME$2]) {
                const h = c.extensions[NAME$2];
                c.source = h.source
            }
        }
        ),
        this
    }
    read(o) {
        return this
    }
    write(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listTextures().forEach(h => {
            if (h.getMimeType() === "image/ktx2") {
                const _ = o.imageIndexMap.get(h);
                c.json.textures.forEach(b => {
                    b.source === _ && (b.extensions = b.extensions || {},
                    b.extensions[NAME$2] = {
                        source: b.source
                    },
                    delete b.source)
                }
                )
            }
        }
        ),
        this
    }
}
KHRTextureBasisu.EXTENSION_NAME = NAME$2;
class Transform extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_TEXTURE_TRANSFORM,
        this.propertyType = "Transform",
        this.parentTypes = [index_modern_PropertyType.TEXTURE_INFO]
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            offset: [0, 0],
            rotation: 0,
            scale: [1, 1],
            texCoord: null
        })
    }
    getOffset() {
        return this.get("offset")
    }
    setOffset(o) {
        return this.set("offset", o)
    }
    getRotation() {
        return this.get("rotation")
    }
    setRotation(o) {
        return this.set("rotation", o)
    }
    getScale() {
        return this.get("scale")
    }
    setScale(o) {
        return this.set("scale", o)
    }
    getTexCoord() {
        return this.get("texCoord")
    }
    setTexCoord(o) {
        return this.set("texCoord", o)
    }
}
Transform.EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;
const NAME$1 = KHR_TEXTURE_TRANSFORM;
class KHRTextureTransform extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME$1
    }
    createTransform() {
        return new Transform(this.document.getGraph())
    }
    read(o) {
        for (const [c,h] of Array.from(o.textureInfos.entries())) {
            if (!h.extensions || !h.extensions[NAME$1])
                continue;
            const _ = this.createTransform()
              , b = h.extensions[NAME$1];
            b.offset !== void 0 && _.setOffset(b.offset),
            b.rotation !== void 0 && _.setRotation(b.rotation),
            b.scale !== void 0 && _.setScale(b.scale),
            b.texCoord !== void 0 && _.setTexCoord(b.texCoord),
            c.setExtension(NAME$1, _)
        }
        return this
    }
    write(o) {
        const c = Array.from(o.textureInfoDefMap.entries());
        for (const [h,_] of c) {
            const b = h.getExtension(NAME$1);
            if (!b)
                continue;
            _.extensions = _.extensions || {};
            const _e = {}
              , nt = index_modern_MathUtils.eq;
            nt(b.getOffset(), [0, 0]) || (_e.offset = b.getOffset()),
            b.getRotation() !== 0 && (_e.rotation = b.getRotation()),
            nt(b.getScale(), [1, 1]) || (_e.scale = b.getScale()),
            b.getTexCoord() != null && (_e.texCoord = b.getTexCoord()),
            _.extensions[NAME$1] = _e
        }
        return this
    }
}
KHRTextureTransform.EXTENSION_NAME = NAME$1;
const PARENT_TYPES = [index_modern_PropertyType.ROOT, index_modern_PropertyType.SCENE, index_modern_PropertyType.NODE, index_modern_PropertyType.MESH, index_modern_PropertyType.MATERIAL, index_modern_PropertyType.TEXTURE, index_modern_PropertyType.ANIMATION];
class Packet extends index_modern_ExtensionProperty {
    init() {
        this.extensionName = KHR_XMP_JSON_LD,
        this.propertyType = "Packet",
        this.parentTypes = PARENT_TYPES
    }
    getDefaults() {
        return Object.assign(super.getDefaults(), {
            context: {},
            properties: {}
        })
    }
    getContext() {
        return this.get("context")
    }
    setContext(o) {
        return this.set("context", dist_index_modern_extends({}, o))
    }
    listProperties() {
        return Object.keys(this.get("properties"))
    }
    getProperty(o) {
        const c = this.get("properties");
        return o in c ? c[o] : null
    }
    setProperty(o, c) {
        this._assertContext(o);
        const h = dist_index_modern_extends({}, this.get("properties"));
        return c ? h[o] = c : delete h[o],
        this.set("properties", h)
    }
    toJSONLD() {
        return dist_index_modern_extends({
            "@context": copyJSON(this.get("context"))
        }, copyJSON(this.get("properties")))
    }
    fromJSONLD(o) {
        const c = (o = copyJSON(o))["@context"];
        return c && this.set("context", c),
        delete o["@context"],
        this.set("properties", o)
    }
    _assertContext(o) {
        if (!(o.split(":")[0]in this.get("context")))
            throw new Error(`${KHR_XMP_JSON_LD}: Missing context for term, "${o}".`)
    }
}
function copyJSON(d) {
    return JSON.parse(JSON.stringify(d))
}
Packet.EXTENSION_NAME = KHR_XMP_JSON_LD;
const NAME = KHR_XMP_JSON_LD;
class KHRXMP extends Extension {
    constructor(...o) {
        super(...o),
        this.extensionName = NAME
    }
    createPacket() {
        return new Packet(this.document.getGraph())
    }
    listPackets() {
        return Array.from(this.properties)
    }
    read(o) {
        var c;
        const h = (c = o.jsonDoc.json.extensions) == null ? void 0 : c[NAME];
        if (!h || !h.packets)
            return this;
        const _ = o.jsonDoc.json
          , b = this.document.getRoot()
          , _e = h.packets.map(at => this.createPacket().fromJSONLD(at))
          , nt = [[_.asset], _.scenes, _.nodes, _.meshes, _.materials, _.images, _.animations]
          , it = [[b], b.listScenes(), b.listNodes(), b.listMeshes(), b.listMaterials(), b.listTextures(), b.listAnimations()];
        for (let at = 0; at < nt.length; at++) {
            const ut = nt[at] || [];
            for (let pt = 0; pt < ut.length; pt++) {
                const ht = ut[pt];
                if (ht.extensions && ht.extensions[NAME]) {
                    const _t = ht.extensions[NAME];
                    it[at][pt].setExtension(NAME, _e[_t.packet])
                }
            }
        }
        return this
    }
    write(o) {
        const {json: c} = o.jsonDoc
          , h = [];
        for (const _ of this.properties) {
            h.push(_.toJSONLD());
            for (const b of _.listParents()) {
                let _e;
                switch (b.propertyType) {
                case index_modern_PropertyType.ROOT:
                    _e = c.asset;
                    break;
                case index_modern_PropertyType.SCENE:
                    _e = c.scenes[o.sceneIndexMap.get(b)];
                    break;
                case index_modern_PropertyType.NODE:
                    _e = c.nodes[o.nodeIndexMap.get(b)];
                    break;
                case index_modern_PropertyType.MESH:
                    _e = c.meshes[o.meshIndexMap.get(b)];
                    break;
                case index_modern_PropertyType.MATERIAL:
                    _e = c.materials[o.materialIndexMap.get(b)];
                    break;
                case index_modern_PropertyType.TEXTURE:
                    _e = c.images[o.imageIndexMap.get(b)];
                    break;
                case index_modern_PropertyType.ANIMATION:
                    _e = c.animations[o.animationIndexMap.get(b)];
                    break;
                default:
                    _e = null,
                    this.document.getLogger().warn(`[${NAME}]: Unsupported parent property, "${b.propertyType}"`)
                }
                _e && (_e.extensions = _e.extensions || {},
                _e.extensions[NAME] = {
                    packet: h.length - 1
                })
            }
        }
        return h.length > 0 && (c.extensions = c.extensions || {},
        c.extensions[NAME] = {
            packets: h
        }),
        this
    }
}
KHRXMP.EXTENSION_NAME = NAME;
const KHRONOS_EXTENSIONS = [index_modern_KHRDracoMeshCompression, KHRLightsPunctual, KHRMaterialsAnisotropy, KHRMaterialsClearcoat, KHRMaterialsDiffuseTransmission, KHRMaterialsDispersion, KHRMaterialsEmissiveStrength, KHRMaterialsIOR, KHRMaterialsIridescence, KHRMaterialsPBRSpecularGlossiness, KHRMaterialsSpecular, KHRMaterialsSheen, KHRMaterialsTransmission, index_modern_KHRMaterialsUnlit, KHRMaterialsVariants, KHRMaterialsVolume, index_modern_KHRMeshQuantization, KHRTextureBasisu, KHRTextureTransform, KHRXMP]
  , ALL_EXTENSIONS = [index_modern_EXTMeshGPUInstancing, index_modern_EXTMeshoptCompression, index_modern_EXTTextureAVIF, index_modern_EXTTextureWebP, ...KHRONOS_EXTENSIONS];
class GLTFDracoExporter extends GLTFExporter2 {
    constructor(o) {
        super(),
        this._loadedLibs = !1,
        o = o || {
            method: index_modern_KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER,
            encodeSpeed: 5
        },
        this._io = new WebIO().registerExtensions(ALL_EXTENSIONS).registerExtensions(ALL_WEBGI_EXTENSIONS),
        this._encoderOptions = o
    }
    preload() {
        return this._loadLibs(),
        this
    }
    async _loadLibs() {
        if (this._loadedLibs || !this.loader)
            return;
        const o = await Promise.all([this.loader.initEncoder(), this.loader.initDecoder()]);
        this._io.registerDependencies({
            "draco3d.encoder": o[0],
            "draco3d.decoder": o[1]
        }),
        this._loadedLibs = !0
    }
    async parseAsync(o, {compress: c=!1, dracoOptions: h, ..._}, b=!1) {
        if (!this.loader)
            return console.error("GLTFDracoExporter: No DRACOLoader2 instance provided"),
            super.parseAsync(o, _);
        await this._loadLibs();
        const _e = {
            ..._
        };
        c && (_e.externalImagesInExtras = !0);
        const nt = await new Promise( (at, ut) => this.parse(o, at, ut, _e))
          , it = await super.parseAsync(nt, _e);
        if (!c)
            return it;
        try {
            if (!nt)
                throw new Error("GLTFDracoExporter: gltf is null");
            let at = nt;
            const ut = at.byteLength || 1 / 0
              , pt = await (typeof at != "object" || at.byteLength ? this._io.readBinary(new Uint8Array(at)) : this._io.readJSON({
                json: at,
                resources: {}
            }));
            if (pt.createExtension(index_modern_KHRDracoMeshCompression).setRequired(!0).setEncoderOptions({
                ...this._encoderOptions,
                ...h ?? {}
            }),
            _e.exportExt === "glb")
                at = await this._io.writeBinary(pt),
                isFinite(ut) && console.log("DRACO Compression ratio: " + (at.byteLength / ut).toFixed(5));
            else {
                const _t = await this._io.writeJSON(pt);
                at = _t.json,
                Object.values(_t.resources).filter(vt => vt).length > 0 && (console.warn("DRACOExporter: extra resources in resources not supported properly"),
                at.resources = _t.resources)
            }
            at.__isGLTFOutput = !0;
            const ht = await super.parseAsync(at, _e);
            if (!ht)
                throw new Error("GLTFDracoExporter: blob is null");
            return ht.ext = "glb",
            ht.__uncompressed = it,
            ht
        } catch (at) {
            if (b)
                throw at;
            return console.error("Unable to compress glb with DRACO extension"),
            console.error(at),
            it
        }
    }
    addExtension(o) {
        return this._io.registerExtensions([o]),
        this
    }
    createAndAddExtension(o, c) {
        return this.addExtension(createGenericExtensionClass(o, c))
    }
}
function addGLTFDracoExporter(d, o, c) {
    return addGLTFExporter(d, o, GLTFDracoExporter, h => {
        const _ = esm_browser_v4() + ".drc"
          , b = h;
        b.loader = c.registerFile(_),
        b.loader.setDecoderConfig({
            type: "js"
        }),
        b.loader.preload(!0, !0)
    }
    )
}
class GLTFDracoExportPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin, AssetExporterPlugin]
    }
    async onAdded(o) {
        await super.onAdded(o);
        const c = o.getManager().importer
          , h = o.getManager().exporter;
        if (!c)
            throw new Error("GLTFDracoExportPlugin: AssetImporter not found");
        addGLTFDracoExporter(h, o, c)
    }
}
GLTFDracoExportPlugin.PluginType = "GLTFDracoExportPlugin";
class WebGIViewerExtensionProperty extends index_modern_ExtensionProperty {
    constructor() {
        super(...arguments),
        this.extensionName = viewerGLTFExtension,
        this.parentTypes = [index_modern_PropertyType.SCENE],
        this.propertyType = "ViewerJSON"
    }
    init() {}
}
class WebGIViewerExtension extends Extension {
    constructor() {
        super(...arguments),
        this.extensionName = viewerGLTFExtension,
        this._viewerConfig = {},
        this._texturesRef = [],
        this.required = !0
    }
    read(o) {
        var c;
        return this._viewerConfig = {},
        (c = o.jsonDoc.json.scenes) === null || c === void 0 || c.forEach( (h, _) => {
            if (h.extensions && h.extensions[viewerGLTFExtension]) {
                const b = new WebGIViewerExtensionProperty(this.document.getGraph());
                o.scenes[_].setExtension(viewerGLTFExtension, b),
                this._viewerConfig = h.extensions[viewerGLTFExtension]
            }
        }
        ),
        this
    }
    write(o) {
        return this.document.getRoot().listScenes().forEach(c => {
            var h;
            if (c.getExtension(viewerGLTFExtension)) {
                const _ = (h = o.jsonDoc.json.scenes) === null || h === void 0 ? void 0 : h[o.jsonDoc.json.scene || 0];
                _ && Object.keys(this._viewerConfig).length > 0 && (_.extensions = _.extensions || {},
                _.extensions[viewerGLTFExtension] = this._viewerConfig,
                this._texturesRef = [],
                this._viewerConfig = {})
            }
        }
        ),
        this
    }
}
WebGIViewerExtension.EXTENSION_NAME = viewerGLTFExtension;
class GenericExtensionProperty extends index_modern_ExtensionProperty {
    addTexture(o, c, h, _=4369) {
        this.setRef(o, h, {
            channels: _
        }),
        this.textures[o] = [c, h]
    }
    constructor(o, c, h) {
        super(o, c),
        this.parentTypes = [index_modern_PropertyType.MATERIAL, index_modern_PropertyType.MESH, index_modern_PropertyType.NODE, index_modern_PropertyType.SCENE],
        this.propertyType = "GenericExtension",
        this.textures = {},
        this.extensionName = h
    }
    init() {}
}
class GenericExtension extends Extension {
    constructor() {
        super(...arguments),
        this.textureChannels = {}
    }
    read(o) {
        const c = o.jsonDoc
          , h = c.json.materials || []
          , _ = c.json.textures || [];
        return h.forEach( (b, _e) => {
            var nt, it;
            if (b.extensions && b.extensions[this.extensionName]) {
                const at = new GenericExtensionProperty(this.document.getGraph(),"",this.extensionName);
                o.materials[_e].setExtension(this.extensionName, at);
                const ut = {
                    ...b.extensions[this.extensionName]
                };
                for (const [pt,ht] of Object.entries(ut))
                    if (typeof (ht == null ? void 0 : ht.index) == "number") {
                        const _t = ht
                          , vt = (nt = _[_t.index]) === null || nt === void 0 ? void 0 : nt.source;
                        if (typeof vt != "number") {
                            console.warn("GLTF Pipeline: source texture not found for texture info", _t);
                            continue
                        }
                        const bt = o.textures[vt]
                          , St = new index_modern_TextureInfo(this.document.getGraph())
                          , At = (it = this.textureChannels[pt]) !== null && it !== void 0 ? it : 4369;
                        at.addTexture(pt, St, bt, At),
                        o.setTextureInfo(St, _t),
                        delete ut[pt]
                    }
                at.setExtras(ut)
            }
        }
        ),
        (c.json.meshes || []).forEach( (b, _e) => {
            if (b.extensions && b.extensions[this.extensionName]) {
                const nt = new GenericExtensionProperty(this.document.getGraph(),"",this.extensionName);
                o.meshes[_e].setExtension(this.extensionName, nt);
                const it = b.extensions[this.extensionName];
                nt.setExtras(it)
            }
        }
        ),
        (c.json.nodes || []).forEach( (b, _e) => {
            if (b.extensions && b.extensions[this.extensionName]) {
                const nt = new GenericExtensionProperty(this.document.getGraph(),"",this.extensionName);
                o.nodes[_e].setExtension(this.extensionName, nt);
                const it = b.extensions[this.extensionName];
                nt.setExtras(it)
            }
        }
        ),
        (c.json.scenes || []).forEach( (b, _e) => {
            if (b.extensions && b.extensions[this.extensionName]) {
                const nt = new GenericExtensionProperty(this.document.getGraph(),"",this.extensionName);
                o.scenes[_e].setExtension(this.extensionName, nt);
                const it = b.extensions[this.extensionName];
                nt.setExtras(it)
            }
        }
        ),
        this
    }
    write(o) {
        const c = o.jsonDoc;
        return this.document.getRoot().listMaterials().forEach(h => {
            const _ = h.getExtension(this.extensionName);
            if (_) {
                const b = o.materialIndexMap.get(h)
                  , _e = c.json.materials[b];
                _e.extensions = _e.extensions || {};
                const nt = {
                    ..._.getExtras()
                };
                for (const [it,at] of Object.entries(_.textures)) {
                    const ut = at[0]
                      , pt = at[1];
                    pt && (nt[it] = o.createTextureInfoDef(pt, ut))
                }
                _e.extensions[this.extensionName] = nt
            }
        }
        ),
        this.document.getRoot().listMeshes().forEach(h => {
            const _ = h.getExtension(this.extensionName);
            if (_) {
                const b = o.meshIndexMap.get(h)
                  , _e = c.json.meshes[b];
                _e.extensions = _e.extensions || {},
                _e.extensions[this.extensionName] = _.getExtras()
            }
        }
        ),
        this.document.getRoot().listNodes().forEach(h => {
            const _ = h.getExtension(this.extensionName);
            if (_) {
                const b = o.nodeIndexMap.get(h)
                  , _e = c.json.nodes[b];
                _e.extensions = _e.extensions || {},
                _e.extensions[this.extensionName] = _.getExtras()
            }
        }
        ),
        this.document.getRoot().listScenes().forEach(h => {
            const _ = h.getExtension(this.extensionName);
            if (_) {
                const b = o.jsonDoc.json.scene || 0
                  , _e = c.json.scenes[b];
                if (!_e)
                    return;
                _e.extensions = _e.extensions || {},
                _e.extensions[this.extensionName] = _.getExtras()
            }
        }
        ),
        this
    }
}
function stringToChannel(d) {
    let o = 0;
    return d.includes("R") && (o |= index_modern_TextureChannel.R),
    d.includes("G") && (o |= index_modern_TextureChannel.G),
    d.includes("B") && (o |= index_modern_TextureChannel.B),
    d.includes("A") && (o |= index_modern_TextureChannel.A),
    o
}
function createGenericExtensionClass(d, o) {
    var c;
    return c = class extends GenericExtension {
        constructor() {
            super(...arguments),
            this.extensionName = d,
            this.textureChannels = o ? Object.fromEntries(Object.entries(o).map( ([h,_]) => [h, typeof _ == "number" ? _ : stringToChannel(_)])) : {}
        }
    }
    ,
    c.EXTENSION_NAME = d,
    c
}
class BumpMapMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = BumpMapMaterialExtension.EXTENSION_NAME,
        this.textureChannels = {
            bumpTexture: index_modern_TextureChannel.R
        }
    }
}
BumpMapMaterialExtension.EXTENSION_NAME = GLTFMaterialsBumpMapExtensionName;
class LightMapMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = LightMapMaterialExtension.EXTENSION_NAME,
        this.textureChannels = {
            lightMapTexture: index_modern_TextureChannel.R | index_modern_TextureChannel.G | index_modern_TextureChannel.B
        }
    }
}
LightMapMaterialExtension.EXTENSION_NAME = GLTFMaterialsLightMapExtensionName;
class AlphaMapMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = AlphaMapMaterialExtension.EXTENSION_NAME,
        this.textureChannels = {
            alphaTexture: index_modern_TextureChannel.G
        }
    }
}
AlphaMapMaterialExtension.EXTENSION_NAME = GLTFMaterialsAlphaMapExtensionName;
class DisplacementMapMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = DisplacementMapMaterialExtension.EXTENSION_NAME,
        this.textureChannels = {
            displacementTexture: index_modern_TextureChannel.R
        }
    }
}
DisplacementMapMaterialExtension.EXTENSION_NAME = GLTFMaterialsDisplacementMapExtensionName;
class DiamondMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = DiamondMaterialExtension.EXTENSION_NAME
    }
}
DiamondMaterialExtension.EXTENSION_NAME = DiamondPlugin.DIAMOND_GLTF_EXTENSION;
class AnimationMarkersExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = AnimationMarkersExtension.EXTENSION_NAME
    }
}
AnimationMarkersExtension.EXTENSION_NAME = GLTFAnimationPlugin.AnimationMarkersExtension;
class AnisotropyMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = AnisotropyMaterialExtension.EXTENSION_NAME,
        this.textureChannels = {
            anisotropyDirection: index_modern_TextureChannel.R | index_modern_TextureChannel.G | index_modern_TextureChannel.B
        }
    }
}
AnisotropyMaterialExtension.EXTENSION_NAME = AnisotropyPlugin.ANISOTROPY_GLTF_EXTENSION;
class CustomBumpMapMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = CustomBumpMapMaterialExtension.EXTENSION_NAME,
        this.textureChannels = {
            customBumpMap: index_modern_TextureChannel.R | index_modern_TextureChannel.G | index_modern_TextureChannel.B
        }
    }
}
CustomBumpMapMaterialExtension.EXTENSION_NAME = CustomBumpMapPlugin.CUSTOM_BUMP_MAP_GLTF_EXTENSION;
class LightExtrasExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = LightExtrasExtension.EXTENSION_NAME
    }
}
LightExtrasExtension.EXTENSION_NAME = webgiLightExtrasExtension;
class Object3DExtrasExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = Object3DExtrasExtension.EXTENSION_NAME
    }
}
Object3DExtrasExtension.EXTENSION_NAME = webgiObject3DExtrasExtension;
class MaterialExtrasExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = MaterialExtrasExtension.EXTENSION_NAME
    }
}
MaterialExtrasExtension.EXTENSION_NAME = webgiMaterialExtrasExtension;
class ClearcoatTintMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = ClearcoatTintMaterialExtension.EXTENSION_NAME
    }
}
ClearcoatTintMaterialExtension.EXTENSION_NAME = ClearcoatTintPlugin.CLEARCOAT_TINT_GLTF_EXTENSION;
class ThinFilmLayerMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = ThinFilmLayerMaterialExtension.EXTENSION_NAME
    }
}
ThinFilmLayerMaterialExtension.EXTENSION_NAME = ThinFilmLayerPlugin.THIN_FILM_LAYER_GLTF_EXTENSION;
class TriplanarMappingMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = TriplanarMappingMaterialExtension.EXTENSION_NAME
    }
}
TriplanarMappingMaterialExtension.EXTENSION_NAME = TriplanarUVMappingPlugin.TRIPLANAR_GLTF_EXTENSION;
class LayeredMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = LayeredMaterialExtension.EXTENSION_NAME
    }
}
LayeredMaterialExtension.EXTENSION_NAME = LayeredMaterialPlugin.LAYERED_MATERIAL_GLTF_EXTENSION;
class SSBevelMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = SSBevelMaterialExtension.EXTENSION_NAME
    }
}
SSBevelMaterialExtension.EXTENSION_NAME = SSBevelPlugin.SSBEVEL_GLTF_EXTENSION;
class NoiseBumpMaterialExtension extends GenericExtension {
    constructor() {
        super(...arguments),
        this.extensionName = NoiseBumpMaterialExtension.EXTENSION_NAME
    }
}
NoiseBumpMaterialExtension.EXTENSION_NAME = NoiseBumpMaterialPlugin.NOISE_BUMP_MATERIAL_GLTF_EXTENSION;
const ALL_WEBGI_EXTENSIONS = [WebGIViewerExtension, DiamondMaterialExtension, BumpMapMaterialExtension, LightMapMaterialExtension, AlphaMapMaterialExtension, AnimationMarkersExtension, AnisotropyMaterialExtension, CustomBumpMapMaterialExtension, LightExtrasExtension, Object3DExtrasExtension, MaterialExtrasExtension, ClearcoatTintMaterialExtension, ThinFilmLayerMaterialExtension, SSBevelMaterialExtension, TriplanarMappingMaterialExtension, NoiseBumpMaterialExtension, DisplacementMapMaterialExtension, LayeredMaterialExtension];
class PMREMGeneratorPlugin extends I$2 {
    constructor() {
        super(...arguments),
        this.processor = {
            forAssetType: "texture",
            process: (o, c) => o
        }
    }
    async onAdded(o) {}
    async onDispose(o) {}
    async onRemove(o) {
        this._pmrem = void 0
    }
}
PMREMGeneratorPlugin.PluginType = "PMREMGenerator";
const _position = new three_module.Pq0
  , _quaternion = new three_module.PTz
  , _scale = new three_module.Pq0;
class CSS3DObject extends three_module.B69 {
    constructor(o=document.createElement("div")) {
        super(),
        this.isCSS3DObject = !0,
        this.element = o,
        this.element.style.position = "absolute",
        this.element.style.pointerEvents = "auto",
        this.element.style.userSelect = "none",
        this.element.setAttribute("draggable", !1),
        this.addEventListener("removed", function() {
            this.traverse(function(c) {
                c.element instanceof Element && c.element.parentNode !== null && c.element.parentNode.removeChild(c.element)
            })
        })
    }
    copy(o, c) {
        return super.copy(o, c),
        this.element = o.element.cloneNode(!0),
        this
    }
}
const _matrix = new three_module.kn4
  , _matrix2 = new three_module.kn4;
class CSS3DRenderer {
    constructor(o={}) {
        const c = this;
        let h, _, b, _e;
        const nt = {
            camera: {
                fov: 0,
                style: ""
            },
            objects: new WeakMap
        }
          , it = o.element !== void 0 ? o.element : document.createElement("div");
        it.style.overflow = "hidden",
        this.domElement = it;
        const at = document.createElement("div");
        at.style.transformOrigin = "0 0",
        at.style.pointerEvents = "none",
        it.appendChild(at);
        const ut = document.createElement("div");
        function pt(bt) {
            return Math.abs(bt) < 1e-10 ? 0 : bt
        }
        function ht(bt) {
            const St = bt.elements;
            return "matrix3d(" + pt(St[0]) + "," + pt(-St[1]) + "," + pt(St[2]) + "," + pt(St[3]) + "," + pt(St[4]) + "," + pt(-St[5]) + "," + pt(St[6]) + "," + pt(St[7]) + "," + pt(St[8]) + "," + pt(-St[9]) + "," + pt(St[10]) + "," + pt(St[11]) + "," + pt(St[12]) + "," + pt(-St[13]) + "," + pt(St[14]) + "," + pt(St[15]) + ")"
        }
        function _t(bt) {
            const St = bt.elements;
            return "translate(-50%,-50%)matrix3d(" + pt(St[0]) + "," + pt(St[1]) + "," + pt(St[2]) + "," + pt(St[3]) + "," + pt(-St[4]) + "," + pt(-St[5]) + "," + pt(-St[6]) + "," + pt(-St[7]) + "," + pt(St[8]) + "," + pt(St[9]) + "," + pt(St[10]) + "," + pt(St[11]) + "," + pt(St[12]) + "," + pt(St[13]) + "," + pt(St[14]) + "," + pt(St[15]) + ")"
        }
        function vt(bt, St, At, Et) {
            if (bt.isCSS3DObject) {
                const Pt = bt.visible === !0 && bt.layers.test(At.layers) === !0;
                if (bt.element.style.display = Pt === !0 ? "" : "none",
                Pt === !0) {
                    let It;
                    bt.onBeforeRender(c, St, At),
                    bt.isCSS3DSprite ? (_matrix.copy(At.matrixWorldInverse),
                    _matrix.transpose(),
                    bt.rotation2D !== 0 && _matrix.multiply(_matrix2.makeRotationZ(bt.rotation2D)),
                    bt.matrixWorld.decompose(_position, _quaternion, _scale),
                    _matrix.setPosition(_position),
                    _matrix.scale(_scale),
                    _matrix.elements[3] = 0,
                    _matrix.elements[7] = 0,
                    _matrix.elements[11] = 0,
                    _matrix.elements[15] = 1,
                    It = _t(_matrix)) : It = _t(bt.matrixWorld);
                    const Dt = bt.element
                      , Gt = nt.objects.get(bt);
                    if (Gt === void 0 || Gt.style !== It) {
                        Dt.style.transform = It;
                        const Bt = {
                            style: It
                        };
                        nt.objects.set(bt, Bt)
                    }
                    Dt.parentNode !== ut && ut.appendChild(Dt),
                    bt.onAfterRender(c, St, At)
                }
            }
            for (let Pt = 0, It = bt.children.length; Pt < It; Pt++)
                vt(bt.children[Pt], St, At)
        }
        ut.style.transformStyle = "preserve-3d",
        at.appendChild(ut),
        this.getSize = function() {
            return {
                width: h,
                height: _
            }
        }
        ,
        this.render = function(bt, St) {
            const At = St.projectionMatrix.elements[5] * _e;
            let Et, Pt;
            nt.camera.fov !== At && (at.style.perspective = St.isPerspectiveCamera ? At + "px" : "",
            nt.camera.fov = At),
            St.view && St.view.enabled ? (at.style.transform = `translate( ${-St.view.offsetX * (h / St.view.width)}px, ${-St.view.offsetY * (_ / St.view.height)}px )`,
            at.style.transform += `scale( ${St.view.fullWidth / St.view.width}, ${St.view.fullHeight / St.view.height} )`) : at.style.transform = "",
            bt.matrixWorldAutoUpdate === !0 && bt.updateMatrixWorld(),
            St.parent === null && St.matrixWorldAutoUpdate === !0 && St.updateMatrixWorld(),
            St.isOrthographicCamera && (Et = -(St.right + St.left) / 2,
            Pt = (St.top + St.bottom) / 2);
            const It = St.view && St.view.enabled ? St.view.height / St.view.fullHeight : 1
              , Dt = St.isOrthographicCamera ? `scale( ${It} )scale(` + At + ")translate(" + pt(Et) + "px," + pt(Pt) + "px)" + ht(St.matrixWorldInverse) : `scale( ${It} )translateZ(` + At + "px)" + ht(St.matrixWorldInverse)
              , Gt = Dt + "translate(" + b + "px," + _e + "px)";
            nt.camera.style !== Gt && (ut.style.transform = Gt,
            nt.camera.style = Gt),
            vt(bt, bt, St)
        }
        ,
        this.setSize = function(bt, St) {
            h = bt,
            _ = St,
            b = h / 2,
            _e = _ / 2,
            it.style.width = bt + "px",
            it.style.height = St + "px",
            at.style.width = bt + "px",
            at.style.height = St + "px",
            ut.style.width = bt + "px",
            ut.style.height = St + "px"
        }
    }
}
var CSS3DRendererPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let CSS3DRendererPlugin = class extends AViewerPlugin {
    constructor(d=!0) {
        super(),
        this._scene = new three_module.Z58,
        this.overCanvas = !0,
        this._trackers = [],
        this.attachIFrameToSelected = async () => {
            var o, c, h, _, b;
            const _e = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
            if (!(_e != null && _e.geometry))
                return void await ((h = this._viewer) === null || h === void 0 ? void 0 : h.alert("No Geometry: Selected object must have a geometry to apply the iframe to"));
            const nt = await ((_ = this._viewer) === null || _ === void 0 ? void 0 : _.prompt("URL: Enter the url for the webpage. (Make sure its allowed to be embedded in an iframe.)", "https://webgi.xyz/", !1)) || "https://webgi.pixotronics.com/";
            if (!nt)
                return;
            const it = await ((b = this._viewer) === null || b === void 0 ? void 0 : b.prompt("Width: Enter the width for the object.", "512", !1)) || "512";
            it && this.attachIFrame(_e, nt, parseInt(it))
        }
        ,
        this._resizeObserver = new ResizeObserver( () => {
            var o;
            this.enabled && ((o = this._viewer) === null || o === void 0 || o.scene.setDirty({
                sceneUpdate: !0
            }))
        }
        ),
        this.enabled = d,
        this._refreshCanvasInDOM = this._refreshCanvasInDOM.bind(this),
        this._refreshEnabled = this._refreshEnabled.bind(this)
    }
    _refreshEnabled() {}
    _refreshCanvasInDOM() {
        const d = this._viewer;
        d && this._renderer && (d.canvas.remove(),
        this.overCanvas ? this._renderer.domElement.insertAdjacentElement("afterbegin", d.canvas) : this._renderer.domElement.appendChild(d.canvas))
    }
    _initialize() {
        if (this._renderer || !this._viewer)
            return;
        this._renderer = new CSS3DRenderer;
        const d = this._viewer.renderer.rendererObject.getSize(new three_module.I9Y);
        this._renderer.setSize(d.width, d.height);
        const o = document.createElement("div");
        o.style.position = "absolute",
        o.style.top = "0",
        o.style.zIndex = "0",
        o.appendChild(this._renderer.domElement),
        this._viewer.canvas.style.position = "absolute",
        this._viewer.canvas.style.top = "0",
        this._viewer.canvas.style.left = "0",
        this._viewer.canvas.style.zIndex = "0",
        this._viewer.container.appendChild(o),
        this._refreshCanvasInDOM(),
        this._viewer.renderer.addEventListener("resize", () => {
            if (!this._viewer || !this._renderer)
                return;
            const c = this._viewer.renderer.rendererObject.getSize(new three_module.I9Y);
            this._renderer.setSize(c.width, c.height)
        }
        )
    }
    async onAdded(d) {
        await super.onAdded(d);
        let o = !0
          , c = !0;
        d.addEventListener("postFrame", b => {
            var _e, nt;
            o && this.enabled && (this._renderer || this._initialize(),
            this._renderer && (c && this._trackers.forEach(it => {
                var at, ut;
                let pt = !0;
                const ht = it.modelObj.material.side;
                if (ht !== three_module.$EB) {
                    const _t = new three_module.Pq0(0,0,1).applyQuaternion(it.cssObj.quaternion)
                      , vt = (ut = (at = this._viewer) === null || at === void 0 ? void 0 : at.scene.activeCamera) === null || ut === void 0 ? void 0 : ut.cameraObject
                      , bt = _t.dot(vt.getWorldDirection(new three_module.Pq0));
                    pt = ht === three_module.hsX ? bt > 0 : bt < 0
                }
                it.cssObj.element.style.visibility = pt ? "visible" : "hidden"
            }
            ),
            this._trackers.filter(it => it.dirty).forEach(it => this._syncProperties(it)),
            (_e = this._renderer) === null || _e === void 0 || _e.render(this._scene, (nt = d.scene.activeCamera) === null || nt === void 0 ? void 0 : nt.cameraObject),
            o = !1))
        }
        ),
        d.addEventListener("update", b => {
            this.enabled && (o = this._trackers.length > 0)
        }
        ),
        d.scene.addEventListener("sceneUpdate", b => {
            this.enabled && (this._trackers.forEach(_e => _e.dirty = !0),
            o = this._trackers.length > 0)
        }
        ),
        d.scene.addEventListener("activeCameraUpdate", b => {
            this.enabled && (o = this._trackers.length > 0,
            c = !0)
        }
        );
        let h = !1;
        const _ = new three_module.tBo;
        d.container.addEventListener("mousemove", b => {
            if (!this.enabled || !this._viewer || this.overCanvas)
                return;
            const _e = this._viewer.canvas.getBoundingClientRect()
              , nt = (b.clientX - _e.x) / _e.width * 2 - 1
              , it = -(b.clientY - _e.y) / _e.height * 2 + 1;
            _.setFromCamera({
                x: nt,
                y: it
            }, this._viewer.scene.activeCamera.cameraObject);
            const at = this._trackers.map(pt => pt.modelObj)
              , ut = _.intersectObjects(at, !1);
            if (console.log(ut),
            ut.length)
                return this._viewer.canvas.style.pointerEvents = "none",
                h = !0,
                void console.log(this._viewer.canvas.style.pointerEvents);
            h && (this._viewer.canvas.style.pointerEvents = "auto",
            h = !1)
        }
        )
    }
    attachIFrame(d, o, c) {
        const h = computeGeometrySize(d.modelObject)
          , _ = createIFrameCSS3DObject(o, c, c * h.y / h.x, () => {
            var b;
            return (b = d.setDirty) === null || b === void 0 ? void 0 : b.call(d)
        }
        );
        return this.attachCSS3DObject(_, d),
        _
    }
    attachCSS3DObject(d, o) {
        var c, h, _, b, _e;
        if (this._trackers.push({
            cssObj: d,
            modelObj: o.modelObject,
            dirty: !0
        }),
        d.element && (this._resizeObserver.observe(d.element),
        d.element.__isCSS3DObjectElement = !0,
        console.log(d.element, d.element.__isCSS3DObjectElement)),
        o.userData.__oldMaterial = o.material,
        !o.setMaterial)
            throw "model not processed?";
        const nt = (c = this._viewer) === null || c === void 0 ? void 0 : c.createMaterial("basic", {
            opacity: 0,
            color: new three_module.Q1f("black"),
            blending: three_module.XIg,
            side: three_module.hB5
        });
        if (!nt)
            throw "cannot create mat";
        nt.userData.forcedLinearDepth = 0,
        (h = o.setMaterial) === null || h === void 0 || h.call(o, nt),
        computeAverageGeometryNormal(o.modelObject),
        computeGeometryCenter(o.modelObject),
        computeGeometrySize(o.modelObject),
        this._scene.add(d),
        (b = (_ = this.uiConfig) === null || _ === void 0 ? void 0 : _.uiRefresh) === null || b === void 0 || b.call(_),
        (_e = o.setDirty) === null || _e === void 0 || _e.call(o)
    }
    _syncProperties(d) {
        const o = d.modelObj
          , c = d.cssObj;
        o.updateMatrixWorld();
        const h = d.cssObj.element.clientWidth < 1.5 ? 0 : (d.cssObj.element.clientWidth - 1.5) / computeGeometrySize(o).x
          , _ = computeAverageGeometryNormal(o);
        c.quaternion.setFromUnitVectors(new three_module.Pq0(0,0,1), _),
        c.position.copy(computeGeometryCenter(o)),
        c.scale.set(1, 1, 1).multiplyScalar(1 / h),
        c.updateMatrixWorld(),
        c.applyMatrix4(o.matrixWorld),
        d.dirty = !1
    }
    async onDispose(d) {
        return this._resizeObserver.disconnect(),
        super.onDispose(d)
    }
}
;
function createIFrameCSS3DObject(d, o, c, h) {
    const _ = document.createElement("div");
    _.style.width = o.toString() + "px",
    _.style.height = c.toString() + "px",
    _.style.backgroundColor = "transparent";
    const b = document.createElement("iframe", {
        is: "x-frame-bypass"
    });
    b.style.width = "100%",
    b.style.height = "100%",
    b.style.border = "0px";
    const _e = () => {
        var nt, it;
        try {
            b.contentWindow.name
        } catch (at) {
            (typeof at == "string" ? at : (it = (nt = at == null ? void 0 : at.toString) === null || nt === void 0 ? void 0 : nt.call(at)) !== null && it !== void 0 ? it : "").includes("cross-origin") ? console.warn("Trying to load cross-origin scripts, Install chrome extension if not able to load: https://chrome.google.com/webstore/detail/ignore-x-frame-headers/gleekbfjekiniecknbkamfmkohkpodhe") : console.error(at)
        }
        h(),
        b.removeEventListener("load", _e)
    }
    ;
    return b.addEventListener("load", _e),
    b.src = d,
    _.appendChild(b),
    new CSS3DObject(_)
}
function computeAverageGeometryNormal(d) {
    if (d.geometry.userData.geometryNormal)
        return d.geometry.userData.geometryNormal;
    const o = d.geometry.attributes.normal
      , c = new three_module.Pq0
      , h = new three_module.Pq0;
    for (let _ = 0, b = o.count; _ < b; _++)
        c.fromBufferAttribute(o, _),
        h.add(c);
    return h.normalize(),
    d.geometry.userData.geometryNormal = h,
    h
}
function computeGeometryCenter(d) {
    if (d.geometry.userData.geometryCenter)
        return d.geometry.userData.geometryCenter;
    const o = d.geometry;
    if (!o)
        return new three_module.Pq0(0,0,0);
    o.boundingBox || o.computeBoundingBox();
    const c = o.boundingBox.getCenter(new three_module.Pq0);
    return d.geometry.userData.geometryCenter = c,
    c
}
function computeGeometrySize(d, o=new three_module.Pq0(0,0,1)) {
    if (d.geometry.userData.geometrySize)
        return d.geometry.userData.geometrySize;
    const c = d.geometry;
    if (!c)
        return new three_module.Pq0(0,0,0);
    const h = c.clone();
    h.applyMatrix4(new three_module.kn4().makeRotationFromQuaternion(new three_module.PTz().setFromUnitVectors(o, computeAverageGeometryNormal(d)).invert())),
    h.computeBoundingBox();
    const _ = h.boundingBox.getSize(new three_module.Pq0);
    return d.geometry.userData.geometrySize = _,
    h.dispose(),
    _
}
CSS3DRendererPlugin.PluginType = "CSS3DRenderer",
CSS3DRendererPlugin_decorate([uiToggle("Enabled"), x$1(CSS3DRendererPlugin.prototype._refreshEnabled), serialize()], CSS3DRendererPlugin.prototype, "enabled", void 0),
CSS3DRendererPlugin_decorate([uiToggle("Over canvas"), x$1(CSS3DRendererPlugin.prototype._refreshCanvasInDOM), serialize()], CSS3DRendererPlugin.prototype, "overCanvas", void 0),
CSS3DRendererPlugin_decorate([uiButton("Attach iframe")], CSS3DRendererPlugin.prototype, "attachIFrameToSelected", void 0),
CSS3DRendererPlugin = CSS3DRendererPlugin_decorate([uiFolder("CSS3D Renderer")], CSS3DRendererPlugin);
var outline = `uniform sampler2D outlineBuffer;uniform vec2 tDiffuseSize;uniform vec3 outlineColor;uniform float outlineThickness;uniform float outlineIntensity;uniform float highlightTransparency;uniform bool enableHighlight;uniform float dpr;float isSelected(vec2 uv){return 1.-texture2D(outlineBuffer,uv).b;}vec4 outline(in vec4 color){vec2 invSize=1./tDiffuseSize;
#if DEBUG_OUTLINE > 0
color=vec4(0.,0.,0.,1.);
#endif
vec3 finalColor=color.rgb;float c=isSelected(vUv);if(c>0.){vec4 uvOffset=1.5*dpr*outlineThickness*vec4(1.,0.,-1.,1.)*vec4(invSize,invSize);float c1=isSelected(vUv+uvOffset.xy);float c2=isSelected(vUv-uvOffset.xy);float c3=isSelected(vUv+uvOffset.yw);float c4=isSelected(vUv-uvOffset.yw);float diff1=(c1-c2)*0.5;float diff2=(c3-c4)*0.5;float d=length(vec2(diff1,diff2));vec4 highlightColor=enableHighlight?vec4(c*outlineColor,(1.-highlightTransparency)*c):vec4(0.);vec4 edgeColor=vec4(outlineColor,1.)*vec4(d);float gbufferDepth=getDepth(vUv);float outlineDepth=unpack16(texture2D(outlineBuffer,vUv).xy);outlineDepth*=outlineDepth;outlineDepth-=0.005;if(gbufferDepth<outlineDepth){highlightColor.rgb=highlightColor.rgb*0.3;edgeColor.rgb=edgeColor.rgb*0.5;}vec4 outColor=edgeColor+highlightColor*(1.-d);finalColor=mix(color.rgb,outlineIntensity*outColor.rgb,outColor.a);}else{finalColor.rgb=color.rgb;}return vec4(finalColor.rgb,color.a);}`;
class OutlineRenderPass extends RenderPass {
    constructor(o, c, h, _=new three_module.Q1f(1,1,1), b=1) {
        super(void 0, void 0, h, _, b),
        this._getSelectedObjectOrMaterial = o,
        this.target = c
    }
    render(o, c, h, _, b) {
        const _e = o.getRenderTarget()
          , nt = o.getActiveCubeFace()
          , it = o.getActiveMipmapLevel()
          , at = this._getSelectedObjectOrMaterial();
        if (at)
            this._renderSelectedObject(o, at, c, _, b);
        else {
            o.setRenderTarget(this.target);
            const ut = new three_module.Q1f;
            o.getClearColor(ut),
            o.setClearColor(new three_module.Q1f(16777215)),
            o.clear(!0, !0),
            o.setClearColor(ut)
        }
        o.setRenderTarget(_e, nt, it)
    }
    _renderSelectedObject(o, c, h, _, b) {
        if (!this.camera)
            return;
        const _e = (Array.isArray(c) ? c : [c]).map(at => at.isMaterial ? [...at.userData.__appliedMeshes.values()] : at).flat();
        _e.forEach(at => at.traverse(ut => {
            ut.layers.enable(6)
        }
        ));
        const nt = this.camera.layers.mask;
        this.camera.layers.set(6);
        const it = o.userData;
        it || console.error("threejs is not patched?"),
        it.transmissionRenderTarget = h,
        setThreeRendererMode(o, {
            shadowMapRender: !1,
            backgroundRender: !1,
            opaqueRender: !0,
            transparentRender: !0,
            transmissionRender: !0,
            mainRenderPass: !1
        }, () => super.render(o, h, this.target, _, b)),
        it.transmissionRenderTarget = void 0,
        _e.forEach(at => at.traverse(ut => {
            ut.layers.disable(6)
        }
        )),
        this.camera.layers.mask = nt
    }
}
var outlineDepthVert = `#ifdef USE_ALPHAMAP
#define USE_UV 
#endif
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec3 vViewPosition;void main(){
#include <skinbase_vertex>
#include <begin_vertex>
#include <morphtarget_vertex>
#include <skinning_vertex>
#include <displacementmap_vertex>
#include <project_vertex>
#include <logdepthbuf_vertex>
#include <clipping_planes_vertex>
vViewPosition=-mvPosition.xyz;}`
  , outlineDepthFrag = "uniform vec2 cameraNearFar;varying vec3 vViewPosition;vec2 pack16(float value){float sMax=65535.;int v=int(clamp(value,0.,1.)*sMax+0.5);int digit0=v/256;int digit1=v-digit0*256;return vec2(float(digit0)/255.,float(digit1)/255.);}float linstep(float edge0,float edge1,float value){return clamp((value-edge0)/(edge1-edge0),0.,1.);}void main(){float linearZ=linstep(-cameraNearFar.x,-cameraNearFar.y,-vViewPosition.z);vec2 packedZ=pack16(pow(max(0.,linearZ),0.5));gl_FragColor=vec4(packedZ.x,packedZ.y,0.,0.);}"
  , OutlinePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let OutlineExtension = class {
    constructor(d, o) {
        this.enabled = !0,
        this.enableHighlight = !1,
        this.enableDynamicSelection = !0,
        this.outlineIntensity = 2,
        this.highlightTransparency = .84,
        this.outlineColor = new three_module.Q1f(15305317),
        this.debugOutline = !1,
        this.highlightSelectedMaterials = !1,
        this.highlightMaterialSameNames = !1,
        this.transparency = 0,
        this._outlineThickness = 2,
        this.extraUniforms = {
            outlineIntensity: {
                value: 1
            },
            tDiffuseSize: {
                value: new three_module.I9Y(1,1)
            },
            outlineThickness: {
                value: 2
            },
            highlightTransparency: {
                value: 1
            },
            outlineColor: {
                value: new three_module.Q1f(15305317)
            },
            enableHighlight: {
                value: !0
            },
            outlineBuffer: {
                value: null
            },
            dpr: {
                value: 1
            }
        },
        this.extraDefines = {
            DEBUG_OUTLINE: "0"
        },
        this.parsFragmentSnippet = (c, h) => this.enabled ? fe$1`
            ${unpackGbuffer}
            ${outline}
        ` : "",
        this._combinedPostPlugin = d.getPlugin(CombinedPostPlugin),
        this._pickingPlugin = d.getPluginByType("Picking"),
        this._setDirty = this._setDirty.bind(this),
        o && (this.extraUniforms.outlineBuffer.value = o.texture),
        this._enable()
    }
    shaderExtender(d, o, c) {
        this.enabled && (d.fragmentShader = shaderReplaceString(d.fragmentShader, "#glMarker", ` 
            gl_FragColor = outline(gl_FragColor);
            #glMarker
        `))
    }
    getUiConfig() {
        return this.uiConfig
    }
    computeCacheKey(d) {
        return this.enabled ? "1" : "0"
    }
    isCompatible(d) {
        return !0
    }
    _setDirty() {
        this._combinedPostPlugin && this._combinedPostPlugin.reRender(),
        this.extraDefines && (this.extraDefines.DEBUG_OUTLINE = this.debugOutline ? "1" : "0"),
        this.extraUniforms && (this.extraUniforms.outlineIntensity.value = this.outlineIntensity,
        this.extraUniforms.outlineColor.value.copy(this.outlineColor),
        this.extraUniforms.outlineThickness.value = this._outlineThickness,
        this.extraUniforms.enableHighlight.value = this.enableHighlight,
        this.extraUniforms.highlightTransparency.value = this.transparency)
    }
    setDirty() {
        var d;
        (d = this.__setDirty) === null || d === void 0 || d.call(this),
        this._setDirty()
    }
    _enable() {
        var d;
        (d = this._pickingPlugin) === null || d === void 0 || d.enableWidget(!this.enabled),
        this._setDirty()
    }
}
;
OutlineExtension.PluginType = "Outline",
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._enable), uiToggle("Enable"), serialize()], OutlineExtension.prototype, "enabled", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiToggle("Highlight"), serialize()], OutlineExtension.prototype, "enableHighlight", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiToggle("DynamicSelection"), serialize()], OutlineExtension.prototype, "enableDynamicSelection", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiSlider("Intensity", [0, 2], .001, {
    limitedUi: !0
}), serialize()], OutlineExtension.prototype, "outlineIntensity", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiSlider("Transparency", [0, 1], .01, {
    limitedUi: !0
}), serialize()], OutlineExtension.prototype, "highlightTransparency", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiColor("Color"), serialize()], OutlineExtension.prototype, "outlineColor", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiToggle("Debug")], OutlineExtension.prototype, "debugOutline", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiToggle("Highlight Selected Materials")], OutlineExtension.prototype, "highlightSelectedMaterials", void 0),
OutlinePlugin_decorate([x$1(OutlineExtension.prototype._setDirty), uiToggle("Highlight Materials (same name)")], OutlineExtension.prototype, "highlightMaterialSameNames", void 0),
OutlineExtension = OutlinePlugin_decorate([uiFolder("Outline")], OutlineExtension);
class OutlinePlugin extends GenericExtensionPlugin {
    constructor() {
        super(),
        this._state = "in",
        this.mouseInOutAnimationEnabled = !0
    }
    generateExtension(o) {
        return new OutlineExtension(o,this._outlineTarget)
    }
    async onAdded(o) {
        this._outlineTarget = o.renderer.createTarget({
            sizeMultiplier: 1
        }),
        await super.onAdded(o);
        const c = o == null ? void 0 : o.getPluginByType("Picking");
        c || console.error("OutlinePlugin requires PickingPlugin to be added to the viewer"),
        o.addEventListener("preRender", () => {
            this._extension.extraUniforms.dpr.value = o.renderer.displayCanvasScaling
        }
        );
        const h = new three_module.BKk({
            uniforms: {
                cameraNearFar: {
                    value: new three_module.I9Y(.1,100)
                }
            },
            vertexShader: outlineDepthVert,
            fragmentShader: outlineDepthFrag,
            side: three_module.$EB
        })
          , _ = makeFilter(o, {
            passId: "outline",
            after: ["gbuffer"],
            before: ["render"],
            passObject: new OutlineRenderPass( () => {
                var b, _e;
                if (!((b = this._extension) === null || b === void 0) && b.highlightSelectedMaterials) {
                    const nt = (_e = c == null ? void 0 : c.getSelectedObject()) === null || _e === void 0 ? void 0 : _e.material;
                    if (this._extension.highlightMaterialSameNames && nt) {
                        const it = Array.isArray(nt) ? nt.map(ut => ut.name) : [nt.name]
                          , at = new Set;
                        return it.forEach(ut => {
                            var pt, ht;
                            const _t = (ht = (pt = o.assetManager) === null || pt === void 0 ? void 0 : pt.materials) === null || ht === void 0 ? void 0 : ht.findMaterialsByName(ut);
                            _t == null || _t.forEach(vt => at.add(vt))
                        }
                        ),
                        [...at]
                    }
                    return nt
                }
                return c == null ? void 0 : c.getSelectedObject()
            }
            ,this._outlineTarget,h),
            update() {
                o.scene.renderCamera.updateShaderProperties(this.passObject.overrideMaterial),
                _.passObject.scene = o.scene.modelObject,
                _.passObject.camera = o.scene.renderCamera.cameraObject
            }
        });
        o.renderer.registerPass(_),
        c == null || c.addEventListener("selectedObjectChanged", () => {
            !this._animationCallBack && this._extension && (c != null && c.getSelectedObject() ? this._extension.enableDynamicSelection ? (this._extension.transparency = 1,
            this._animationCallBack = this._startTransparencyAnimation(1, this._extension.highlightTransparency, 400)) : this._extension.transparency = this._extension.highlightTransparency : this._extension.transparency = 1)
        }
        ),
        document.addEventListener("mousemove", b => {
            if (!this._extension || !this.mouseInOutAnimationEnabled)
                return;
            const _e = c == null ? void 0 : c.getSelectedObject();
            _e && this._extension.enableDynamicSelection ? b.target !== o.canvas ? this._animationCallBack || this._state !== "in" || (this._animationCallBack = this._startTransparencyAnimation(this._extension.highlightTransparency, 1, 600),
            this._state = "out") : this._animationCallBack || this._state !== "out" || (this._animationCallBack = this._startTransparencyAnimation(1, this._extension.highlightTransparency, 600),
            this._state = "in") : this._extension.transparency = _e ? this._extension.highlightTransparency : 1
        }
        )
    }
    async _startTransparencyAnimation(o, c, h) {
        return animateTarget$1(this._extension, "transparency", {
            from: o,
            to: c,
            duration: h,
            onComplete: () => {
                this._animationCallBack = null
            }
        })
    }
}
OutlinePlugin.PluginType = "Outline";
const RADIUS = .2
  , LINE_WIDTH = .03
  , MAX_OPACITY = .75
  , SEGMENTS = 12
  , DELTA_PHI = Math.PI / (2 * SEGMENTS)
  , vector2 = new three_module.I9Y
  , addCorner = (d, o, c) => {
    let h = o > 0 ? c > 0 ? 0 : -Math.PI / 2 : c > 0 ? Math.PI / 2 : Math.PI;
    for (let _ = 0; _ <= SEGMENTS; ++_)
        d.push(o + (RADIUS - LINE_WIDTH) * Math.cos(h), c + (RADIUS - LINE_WIDTH) * Math.sin(h), 0, o + RADIUS * Math.cos(h), c + RADIUS * Math.sin(h), 0),
        h += DELTA_PHI
}
  , makeARBoxGeometry = (d, o) => {
    const c = new three_module.LoY
      , h = []
      , _ = []
      , b = d.getSize(new three_module.Pq0)
      , _e = b.x / 2
      , nt = (o ? b.y : b.z) / 2;
    addCorner(_, _e, nt),
    addCorner(_, -_e, nt),
    addCorner(_, -_e, -nt),
    addCorner(_, _e, -nt);
    const it = _.length / 3;
    for (let ut = 0; ut < it - 2; ut += 2)
        h.push(ut, ut + 1, ut + 3, ut, ut + 3, ut + 2);
    const at = it - 2;
    return h.push(at, at + 1, 1, at, 1, 0),
    c.setAttribute("position", new three_module.qtW(_,3)),
    c.setIndex(h),
    c
}
;
class ARPlacementBox extends three_module.eaF {
    constructor(o, c, h=!1) {
        super(makeARBoxGeometry(o, h)),
        this.boundingSize = new three_module.Pq0,
        this._raycaster = new three_module.tBo,
        this._camera = c,
        this._placeOnWall = h;
        const _ = this.material;
        _.side = three_module.hB5,
        _.color = new three_module.Q1f(16711935),
        _.opacity = 0,
        this.userData.bboxVisible = !1;
        const b = o.getSize(this.boundingSize)
          , _e = b.x / 2
          , nt = (h ? b.y : b.z) / 2;
        this.hitPlane = new three_module.eaF(new three_module.bdM(2 * (_e + RADIUS),2 * (nt + RADIUS))),
        this.hitPlane.visible = !1,
        this.add(this.hitPlane),
        o.getCenter(this.position),
        h ? (this.shadowHeight = o.min.z,
        this.position.z = this.shadowHeight) : (this.rotateX(-Math.PI / 2),
        this.shadowHeight = o.min.y,
        this.position.y = this.shadowHeight),
        this.offsetHeight = 0
    }
    getHit(o, c, h) {
        vector2.set(c, -h),
        this.hitPlane.visible = !0;
        const _ = this._positionAndNormalFromPoint(vector2, this.hitPlane);
        return this.hitPlane.visible = !1,
        _ == null ? null : _.position
    }
    getExpandedHit(o, c, h) {
        this.hitPlane.scale.set(1e3, 1e3, 1e3);
        const _ = this.getHit(o, c, h);
        return this.hitPlane.scale.set(1, 1, 1),
        _
    }
    set offsetHeight(o) {
        o -= .001,
        this._placeOnWall ? this.position.z = this.shadowHeight + o : this.position.y = this.shadowHeight + o
    }
    get offsetHeight() {
        return this._placeOnWall ? this.position.z - this.shadowHeight : this.position.y - this.shadowHeight
    }
    set show(o) {
        this.material.opacity = o ? MAX_OPACITY : 0
    }
    get show() {
        return this.material.opacity > .01
    }
    updateOpacity(o) {
        const c = this.material;
        this.visible = c.opacity > 0
    }
    dispose() {
        var o;
        const {geometry: c, material: h} = this.hitPlane;
        c.dispose(),
        h.dispose(),
        this.geometry.dispose(),
        this.material.dispose(),
        (o = this.parent) === null || o === void 0 || o.remove(this)
    }
    _positionAndNormalFromPoint(o, c) {
        if (!this._camera)
            return null;
        this._raycaster.setFromCamera(o, this._camera);
        const h = this._raycaster.intersectObject(c, !0);
        if (h.length === 0)
            return null;
        const _ = h[0];
        return _.face == null ? null : _.uv == null ? {
            position: _.point,
            normal: _.face.normal,
            uv: null
        } : (_.face.normal.applyNormalMatrix(new three_module.dwI().getNormalMatrix(_.object.matrixWorld)),
        {
            position: _.point,
            normal: _.face.normal,
            uv: _.uv
        })
    }
}
const ROTATION_RATE = 1.5
  , SCALE_SNAP_HIGH = 1.3
  , SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH
  , MAX_DISTANCE = 10
  , vector3 = new three_module.Pq0;
class ARTouchInputHelper {
    constructor() {
        this.inputSource = null,
        this.isTranslating = !1,
        this.isRotating = !1,
        this.isTwoFingering = !1,
        this.lastDragPosition = new three_module.Pq0,
        this.firstRatio = 0,
        this.lastAngle = 0,
        this.goalPosition = new three_module.Pq0,
        this.goalYaw = 0,
        this.goalScale = 1,
        this.presentedScene = null,
        this.placementBox = null,
        this.placeOnWall = !1,
        this.placementComplete = !1,
        this.xr = null,
        this.session = null,
        this._hitPosition = new three_module.Pq0,
        this._hitMatrix = new three_module.kn4,
        this.xDamper = new k$1,
        this.yDamper = new k$1,
        this.zDamper = new k$1,
        this.yawDamper = new k$1,
        this.scaleDamper = new k$1,
        this.onSelectStart = o => {
            const c = this.transientHitTestSource;
            if (c == null)
                return;
            const h = this.frame.getHitTestResultsForTransientInput(c)
              , _ = this.presentedScene
              , b = this.placementBox;
            if (h.length === 1) {
                this.inputSource = o.inputSource;
                const {axes: _e} = this.inputSource.gamepad || {
                    axes: [0, 0]
                }
                  , nt = b.getHit(_, _e[0], _e[1]);
                b.show = !0,
                nt != null ? (this.isTranslating = !0,
                this.lastDragPosition.copy(nt),
                this.presentedScene && (this.presentedScene.visible = !0)) : this.placeOnWall || (this.isRotating = !0,
                this.lastAngle = _e[0] * ROTATION_RATE)
            } else if (h.length === 2) {
                b.show = !0,
                this.isTwoFingering = !0;
                const {separation: _e} = this.fingerPolar(h);
                this.firstRatio = _e / _.scale.x
            }
        }
        ,
        this.onSelectEnd = () => {
            this.isTranslating = !1,
            this.isRotating = !1,
            this.isTwoFingering = !1,
            this.inputSource = null,
            this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x,
            this.placementBox.show = !1
        }
    }
    async setSession(o, c, h) {
        var _;
        this.transientHitTestSource = await ((_ = o.requestHitTestSourceForTransientInput) === null || _ === void 0 ? void 0 : _.call(o, {
            profile: "generic-touchscreen"
        })),
        this.presentedScene = c,
        this.placementBox = h,
        this.session = o,
        this.placementComplete = !1,
        this.goalPosition.copy(c.position),
        this.goalYaw = c.rotation.y,
        this.goalScale = c.scale.x,
        o.addEventListener("selectstart", this.onSelectStart),
        o.addEventListener("selectend", this.onSelectEnd)
    }
    cancel() {
        this.transientHitTestSource && (this.transientHitTestSource.cancel(),
        this.transientHitTestSource = void 0),
        this.presentedScene = null,
        this.placeOnWall = !1,
        this.frame = void 0,
        this.xr = null,
        this.placementBox && (this.placementBox.show = !1,
        this.placementBox = null),
        this.session && (this.session.removeEventListener("selectstart", this.onSelectStart),
        this.session.removeEventListener("selectend", this.onSelectEnd),
        this.session = null)
    }
    getHitPoint(o) {
        var c;
        const h = (c = this.xr) === null || c === void 0 ? void 0 : c.getReferenceSpace()
          , _ = h ? o.getPose(h) : null;
        return _ ? (this._hitMatrix.fromArray(_.transform.matrix),
        this.placeOnWall && (this.goalYaw = Math.atan2(this._hitMatrix.elements[4], this._hitMatrix.elements[6])),
        this._hitMatrix.elements[5] > .75 !== this.placeOnWall ? this._hitPosition.setFromMatrixPosition(this._hitMatrix) : null) : null
    }
    moveScene(o) {
        if (!this.session)
            return;
        const c = this.presentedScene
          , h = c.position
          , _ = c.rotation.y
          , b = this.placementBox
          , _e = Math.max(b.boundingSize.x, b.boundingSize.y, b.boundingSize.z) / 2
          , nt = this.goalPosition
          , it = c.scale.x;
        if (!nt.equals(h) || this.goalScale !== it) {
            let {x: at, y: ut, z: pt} = h;
            at = this.xDamper.update(at, nt.x, o, _e),
            ut = this.yDamper.update(ut, nt.y, o, _e),
            pt = this.zDamper.update(pt, nt.z, o, _e),
            h.set(at, ut, pt);
            const ht = this.scaleDamper.update(it, this.goalScale, o, 1);
            if (c.scale.set(ht, ht, ht),
            !this.isTranslating) {
                const _t = nt.y - ut;
                this.placementComplete && !this.placeOnWall ? b.offsetHeight = _t / ht : _t === 0 && (this.placementComplete = !0,
                b.show = !1)
            }
        }
        b.updateOpacity(o),
        c.rotation.y = this.yawDamper.update(_, this.goalYaw, o, Math.PI)
    }
    processInput(o) {
        var c;
        this.frame = o;
        const h = this.transientHitTestSource;
        if (!h || !this.isTranslating && !this.isTwoFingering && !this.isRotating)
            return;
        const _ = o.getHitTestResultsForTransientInput(h)
          , b = this.presentedScene
          , _e = b.scale.x;
        if (this.isTwoFingering)
            if (_.length < 2)
                this.isTwoFingering = !1;
            else {
                const {separation: nt, deltaYaw: it} = this.fingerPolar(_);
                if (this.placeOnWall || (this.goalYaw += it),
                !b.userData.__scaleDisabled) {
                    const at = nt / this.firstRatio;
                    this.goalScale = at < SCALE_SNAP_HIGH && at > SCALE_SNAP_LOW ? 1 : at
                }
            }
        else if (_.length !== 2)
            if (this.isRotating && (!((c = this.inputSource) === null || c === void 0) && c.gamepad)) {
                const nt = this.inputSource.gamepad.axes[0] * ROTATION_RATE;
                this.goalYaw += nt - this.lastAngle,
                this.lastAngle = nt
            } else
                this.isTranslating && (console.log("translating"),
                _.forEach(nt => {
                    if (nt.inputSource !== this.inputSource)
                        return;
                    let it = null;
                    if (nt.results.length > 0 && (it = this.getHitPoint(nt.results[0])),
                    it == null && (it = this.getTouchLocation()),
                    it != null) {
                        if (this.goalPosition.sub(this.lastDragPosition),
                        !this.placeOnWall) {
                            const at = it.y - this.lastDragPosition.y;
                            if (at < 0) {
                                this.placementBox.offsetHeight = at / _e;
                                const ut = vector3.copy(this.xr.getCamera().position)
                                  , pt = -at / (ut.y - it.y);
                                ut.multiplyScalar(pt),
                                it.multiplyScalar(1 - pt).add(ut)
                            }
                        }
                        this.goalPosition.add(it),
                        this.lastDragPosition.copy(it)
                    }
                }
                ));
        else {
            this.isTranslating = !1,
            this.isRotating = !1,
            this.isTwoFingering = !0;
            const {separation: nt} = this.fingerPolar(_);
            this.firstRatio = nt / _e
        }
    }
    getTouchLocation() {
        var o, c;
        const {axes: h} = (o = this.inputSource.gamepad) !== null && o !== void 0 ? o : {
            axes: [0, 0]
        }
          , _ = this.placementBox.getExpandedHit(this.presentedScene, h[0], h[1]);
        return _ != null && (vector3.copy(_).sub((c = this.xr) === null || c === void 0 ? void 0 : c.getCamera().position),
        vector3.length() > MAX_DISTANCE) ? null : _
    }
    fingerPolar(o) {
        var c, h, _, b, _e, nt;
        const it = (_ = (h = (c = o[0].inputSource) === null || c === void 0 ? void 0 : c.gamepad) === null || h === void 0 ? void 0 : h.axes) !== null && _ !== void 0 ? _ : [0, 0]
          , at = (nt = (_e = (b = o[1].inputSource) === null || b === void 0 ? void 0 : b.gamepad) === null || _e === void 0 ? void 0 : _e.axes) !== null && nt !== void 0 ? nt : [0, 0]
          , ut = at[0] - it[0]
          , pt = at[1] - it[1]
          , ht = Math.atan2(pt, ut);
        let _t = this.lastAngle - ht;
        return _t > Math.PI ? _t -= 2 * Math.PI : _t < -Math.PI && (_t += 2 * Math.PI),
        this.lastAngle = ht,
        {
            separation: Math.sqrt(ut * ut + pt * pt),
            deltaYaw: _t
        }
    }
}
class SessionLightProbe {
    constructor(o, c, h, _, b) {
        this.xrLight = o,
        this.renderer = c,
        this.lightProbe = h,
        this.xrWebGLBinding = null,
        this.estimationStartCallback = b,
        this.frameCallback = this.onXRFrame.bind(this);
        const _e = c.xr.getSession();
        if (_ && "XRWebGLBinding"in window) {
            const nt = new three_module.o6l(16);
            o.environment = nt.texture;
            const it = c.getContext();
            switch (_e.preferredReflectionFormat) {
            case "srgba8":
                it.getExtension("EXT_sRGB");
                break;
            case "rgba16f":
                it.getExtension("OES_texture_half_float")
            }
            this.xrWebGLBinding = new XRWebGLBinding(_e,it),
            this.lightProbe.addEventListener("reflectionchange", () => {
                this.updateReflection()
            }
            )
        }
        _e.requestAnimationFrame(this.frameCallback)
    }
    updateReflection() {
        const o = this.renderer.properties.get(this.xrLight.environment);
        if (o) {
            const c = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);
            c && (o.__webglTexture = c,
            this.xrLight.environment.needsPMREMUpdate = !0)
        }
    }
    onXRFrame(o, c) {
        if (!this.xrLight)
            return;
        c.session.requestAnimationFrame(this.frameCallback);
        const h = c.getLightEstimate(this.lightProbe);
        if (h) {
            this.xrLight.lightProbe.sh.fromArray(h.sphericalHarmonicsCoefficients),
            this.xrLight.lightProbe.intensity = 1;
            const _ = Math.max(1, Math.max(h.primaryLightIntensity.x, Math.max(h.primaryLightIntensity.y, h.primaryLightIntensity.z)));
            this.xrLight.directionalLight.color.setRGB(h.primaryLightIntensity.x / _, h.primaryLightIntensity.y / _, h.primaryLightIntensity.z / _),
            this.xrLight.directionalLight.intensity = _,
            this.xrLight.directionalLight.position.copy(h.primaryLightDirection),
            this.estimationStartCallback && (this.estimationStartCallback(),
            this.estimationStartCallback = null)
        }
    }
    dispose() {
        this.xrLight = null,
        this.renderer = null,
        this.lightProbe = null,
        this.xrWebGLBinding = null
    }
}
class XREstimatedLight extends three_module.YJl {
    constructor(o, c=!0) {
        super(),
        this.lightProbe = new three_module.FZo,
        this.lightProbe.intensity = 0,
        this.add(this.lightProbe),
        this.directionalLight = new three_module.ZyN,
        this.directionalLight.intensity = 0,
        this.add(this.directionalLight),
        this.environment = null;
        let h = null
          , _ = !1;
        o.xr.addEventListener("sessionstart", () => {
            const b = o.xr.getSession();
            "requestLightProbe"in b && b.requestLightProbe({
                reflectionFormat: b.preferredReflectionFormat
            }).then(_e => {
                h = new SessionLightProbe(this,o,_e,c, () => {
                    _ = !0,
                    this.dispatchEvent({
                        type: "estimationstart"
                    })
                }
                )
            }
            )
        }
        ),
        o.xr.addEventListener("sessionend", () => {
            h && (h.dispose(),
            h = null),
            _ && this.dispatchEvent({
                type: "estimationend"
            })
        }
        ),
        this.dispose = () => {
            h && (h.dispose(),
            h = null),
            this.remove(this.lightProbe),
            this.lightProbe = null,
            this.remove(this.directionalLight),
            this.directionalLight = null,
            this.environment = null
        }
    }
}
var ARPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, ARPlugin_1;
const HIT_ANGLE_DEG = 20;
let ARPlugin = ARPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this._touchInputHelper = new ARTouchInputHelper,
        this.dependencies = [GBufferPlugin],
        this.estimateLighting = !1,
        this.placeOnWall = !1,
        this.xrResolutionScale = 1,
        this.toJSON = void 0,
        this.enterAR = () => {
            var d;
            this.enabled && this._viewer && (navigator && navigator.xr ? this._xrSession ? console.warn("Already in AR") : this._xrManager ? (this._xrManager.enabled = !0,
            (d = this._xrManager) === null || d === void 0 || d.setFramebufferScaleFactor(this.xrResolutionScale),
            navigator.xr.requestSession("immersive-ar", {
                requiredFeatures: ["hit-test"],
                optionalFeatures: ["dom-overlay", "light-estimation"],
                domOverlay: this.domOverlay
            }).then(this._onSessionStarted)) : console.error("XR manager not found") : console.error("XR not supported"))
        }
        ,
        this.exitAR = () => {
            this._xrSession && this._xrSession.end()
        }
        ,
        this._preRender = () => {
            var d;
            if (!(this._dirty && this._viewer && this._xrManager && this._xrSession))
                return;
            this._viewer.renderer.defaultRenderToScreen = !1,
            this._xrManager.enabled = !1;
            const o = this._xrManager.getCamera()
              , c = ((d = o.cameras) === null || d === void 0 ? void 0 : d[0]) || o
              , h = this._viewer.scene.activeCamera;
            h.cameraObject.projectionMatrix.copy(c.projectionMatrix),
            h.cameraObject.projectionMatrixInverse.copy(h.cameraObject.projectionMatrix).invert()
        }
        ,
        this._postRender = () => {
            var d, o;
            if (!this._dirty || !this._viewer || !this._xrSession)
                return;
            this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
            const c = this._viewer.renderer
              , h = (o = (d = this._xrManager) === null || d === void 0 ? void 0 : d.getCamera()) === null || o === void 0 ? void 0 : o.cameras[0].viewport;
            h ? c.rendererObject.setViewport(h) : console.warn("no viewport for ar camera"),
            this._viewer.getPlugin(GBufferPlugin).updateShaderProperties(arCopyPass.material),
            arCopyPass.uniforms.tTransparentMap.value = this._viewer.renderFilter.passObject.transparentTarget.texture,
            setThreeRendererMode(c.rendererObject, {
                sceneRender: !0,
                opaqueRender: !0,
                shadowMapRender: !1,
                backgroundRender: !1,
                transparentRender: !1,
                transmissionRender: !1,
                screenSpaceRendering: !1
            }, () => {
                arCopyPass.render(c.rendererObject, null, c.composer.readBuffer, 0, !1)
            }
            ),
            this._xrManager.enabled = !0,
            this._viewer.renderer.defaultRenderToScreen = !0
        }
        ,
        this._frameCount = 0,
        this._isPresenting = !1,
        this._interactionsDisabled = !1,
        this._preFrame = ({xrFrame: d, deltaTime: o}) => {
            var c, h;
            if (this.dirty = !!d && ((c = this._xrManager) === null || c === void 0 ? void 0 : c.isPresenting) || !1,
            (this._dirty || this._interactionsDisabled) && (this._viewer.scene.activeCamera.setInteractions(!this._dirty, ARPlugin_1.PluginType),
            this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty,
            this._interactionsDisabled = this._dirty),
            !this._dirty || !d)
                return void (this._isPresenting && this._xrRenderingEnd());
            if (!this._xrSession)
                return console.error("no xr session found, shouldn't happen"),
                void (this.dirty = !1);
            this._isPresenting || console.log("webxr: AR session init"),
            this._frameCount++;
            const _ = this._xrManager.getReferenceSpace()
              , b = d.getViewerPose(_);
            if (b == null && this._frameCount,
            b == null || ((h = this._viewer) === null || h === void 0 ? void 0 : h.scene.modelRoot.children.length) === 0)
                return this.dirty = !1,
                void console.warn("no pose or no model");
            this._isPresenting || (this._isPresenting = !0,
            this._frameCount = 0,
            this._savePreXRState(),
            this._preSetupModel(),
            this._xrRenderingBegin());
            const _e = this._viewer.scene.activeCamera;
            this._xrManager.updateCamera(_e.cameraObject),
            _e.setDirty(),
            this.moveToFloor(d),
            this._touchInputHelper.processInput(d),
            this._touchInputHelper.moveScene(o),
            this._updateShadow()
        }
        ,
        this._preXRState = {
            viewerBg: null,
            viewerBgColor: void 0,
            modelScale: new three_module.Pq0(1,1,1),
            modelPosition: new three_module.Pq0,
            modelRotation: new three_module.PTz,
            cameraPosition: new three_module.Pq0(0,0,5),
            cameraTarget: new three_module.Pq0,
            cameraUp: new three_module.Pq0(0,1,0),
            cameraAspect: 1,
            cameraFov: 50,
            cameraZoom: 1,
            cameraNear: .01,
            cameraFar: 100,
            cameraProjectionMatrix: new three_module.kn4,
            cameraAutoNearFar: void 0,
            groundOffset: new three_module.Pq0,
            groundScale: 1,
            groundRotation: 0,
            groundRenderToDepth: !1,
            groundShadowBaker: !1,
            viewport: new three_module.I9Y,
            environment: void 0,
            preserveTransparentTarget: !0
        },
        this._savePreXRState = () => {
            var d;
            if (!this._viewer)
                return;
            this._preXRState.viewport.copy(this._viewer.renderer.renderSize),
            this._preXRState.viewerBg = this._viewer.scene.background,
            this._preXRState.viewerBgColor = (d = this._viewer.scene.backgroundColor) === null || d === void 0 ? void 0 : d.getHex();
            const o = this._viewer.scene.modelRoot
              , c = this._viewer.scene.activeCamera;
            o.updateMatrix(),
            o.updateMatrixWorld(!0),
            this._preXRState.modelScale.copy(o.scale),
            this._preXRState.modelPosition.copy(o.position),
            this._preXRState.modelRotation.copy(o.quaternion),
            this._preXRState.cameraPosition.copy(c.position),
            this._preXRState.cameraTarget.copy(c.target),
            this._preXRState.cameraUp.copy(c.cameraObject.up),
            c.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = c.cameraObject.fov,
            this._preXRState.cameraAspect = c.cameraObject.aspect),
            this._preXRState.cameraZoom = c.cameraObject.zoom,
            this._preXRState.cameraNear = c.cameraObject.near,
            this._preXRState.cameraFar = c.cameraObject.far,
            this._preXRState.cameraAutoNearFar = c.cameraObject.userData.autoNearFar,
            this._preXRState.cameraProjectionMatrix.copy(c.cameraObject.projectionMatrix);
            const h = this._viewer.getPluginByType("Ground");
            h != null && h.mesh && (this._preXRState.groundOffset.subVectors(o.position, h.mesh.modelObject.position),
            this._preXRState.groundScale = h.mesh.modelObject.scale.x,
            this._preXRState.groundRotation = h.mesh.modelObject.rotation.z,
            this._preXRState.groundRenderToDepth = h.renderToDepth,
            this._preXRState.groundShadowBaker = h.shadowBaker.enabled),
            this._preXRState.environment || (this._preXRState.environment = this._viewer.scene.getEnvironment()),
            this._preXRState.preserveTransparentTarget = this._viewer.renderFilter.passObject.preserveTransparentTarget
        }
        ,
        this._xrRenderingBegin = () => {
            if (!this._xrSession || !this._viewer)
                return;
            console.log("webxr: AR session start");
            const d = HIT_ANGLE_DEG * Math.PI / 180
              , o = this.placeOnWall ? void 0 : new window.XRRay(new DOMPoint(0,0,0),{
                x: 0,
                y: -Math.sin(d),
                z: -Math.cos(d)
            });
            this._viewer.renderer.useTotalFrameCount = !0,
            this._viewer.resize(),
            (async () => {
                var c, h;
                if (this._xrSession) {
                    this._touchInputHelper.placeOnWall = this.placeOnWall,
                    await this._touchInputHelper.setSession(this._xrSession, this._viewer.scene.modelRoot, this._placementBox);
                    const _ = await this._xrSession.requestReferenceSpace("viewer");
                    this._hitTestSource = await ((h = (c = this._xrSession).requestHitTestSource) === null || h === void 0 ? void 0 : h.call(c, {
                        space: _,
                        offsetRay: o
                    }))
                }
            }
            )()
        }
        ,
        this._xrRenderingEnd = () => {
            console.log("webxr: AR session end"),
            this._xrManager && (this._xrManager.enabled = !1),
            this._isPresenting = !1,
            this._frameCount = 0,
            this._xrSession = void 0,
            this._removePlacementBox(),
            this._cancelHitSources(),
            this._viewer && (this._viewer.renderer.stableNoise = !1),
            this._restorePreXRState()
        }
        ,
        this._onSessionStarted = async d => {
            d.addEventListener("end", this._onSessionEnded),
            this.estimateLighting && (this._xrLight = new XREstimatedLight(this._viewer.renderer.rendererObject),
            this._xrLight.addEventListener("estimationstart", () => {
                this._xrSession && this._xrLight && (this._viewer.scene.modelRoot.add(this._xrLight),
                this._preXRState.environment || (this._preXRState.environment = this._viewer.scene.getEnvironment()),
                this._viewer.scene.setEnvironment(this._xrLight.environment))
            }
            )),
            this._xrManager.setReferenceSpaceType("local"),
            await this._xrManager.setSession(d),
            this._xrSession = d
        }
        ,
        this._onSessionEnded = () => {
            this._xrSession && (this._xrSession.removeEventListener("end", this._onSessionEnded),
            this._xrLight && (this._xrLight.removeFromParent(),
            this._xrLight.dispose(),
            this._xrLight = void 0))
        }
    }
    async onAdded(d) {
        await super.onAdded(d);
        const o = d.renderer.rendererObject.xr;
        if (o.cameraAutoUpdate = !1,
        this._xrManager = o,
        this._touchInputHelper.xr = o,
        !this.domOverlay) {
            const c = document.getElementById("tweakpaneUiContainer");
            this.domOverlay = c ? {
                root: c
            } : void 0
        }
        if (d.addEventListener("preRender", this._preRender),
        d.addEventListener("postRender", this._postRender),
        d.addEventListener("preFrame", this._preFrame),
        !window.isSecureContext)
            return d.console.error("XR not supported in insecure context, try https://"),
            void (this.enabled = !1);
        navigator && "xr"in navigator && navigator.xr ? navigator.xr.isSessionSupported("immersive-ar").then(c => {
            if (!c)
                throw new Error("AR not supported")
        }
        ).catch(c => {
            d.console.error("AR not supported:", c),
            o.enabled = !1,
            this.enabled = !1
        }
        ) : (o.enabled = !1,
        this.enabled = !1)
    }
    _updateShadow() {
        var d, o;
        if (!this._viewer)
            return;
        const c = this._viewer.scene.modelRoot
          , h = (o = (d = this._viewer.getPluginByType("Ground")) === null || d === void 0 ? void 0 : d.mesh) === null || o === void 0 ? void 0 : o.modelObject;
        h && (h.rotation.z = this._viewer.scene.modelRoot.rotation.y,
        h.position.copy(this._preXRState.groundOffset).multiplyScalar(c.modelObject.scale.x).sub(c.modelObject.position).negate(),
        h.scale.setScalar(c.modelObject.scale.x * this._preXRState.groundScale))
    }
    moveToFloor(d) {
        if (!this._dirty || !this._hitTestSource || !this._xrManager)
            return;
        const o = d.getHitTestResults(this._hitTestSource);
        if (!o.length)
            return;
        const c = o[0];
        this._touchInputHelper.placeOnWall = this.placeOnWall;
        const h = this._touchInputHelper.getHitPoint(c);
        if (!h)
            return;
        this._placementBox.show = !0;
        const _ = this._viewer.scene.modelRoot;
        this._touchInputHelper.goalPosition.copy(h),
        _.position.copy(h),
        this._viewer.scene.modelRoot.visible = !0,
        this._hitTestSource.cancel(),
        this._hitTestSource = void 0
    }
    _removePlacementBox() {
        this._placementBox && (this._placementBox.removeFromParent(),
        this._placementBox = void 0)
    }
    _preSetupModel() {
        var d, o;
        const c = this._viewer.scene.modelRoot
          , h = this._viewer.scene.activeCamera
          , _ = (d = this._xrManager) === null || d === void 0 ? void 0 : d.getCamera()
          , b = _.cameras[0] || _;
        this._removePlacementBox();
        const _e = this._viewer.scene.getBounds(!0, !0);
        _e.getSize(new three_module.Pq0).length() > .01 && (this._placementBox = new ARPlacementBox(_e,_,this.placeOnWall),
        c.add(this._placementBox),
        this._placementBox.show = !1);
        const nt = _.getWorldDirection(new three_module.Pq0);
        c.rotation.y = Math.atan2(-nt.x, -nt.z) - 0,
        h.cameraObject.zoom = b.zoom,
        h.cameraObject.near = b.near,
        h.cameraObject.far = b.far,
        h.cameraObject.userData.autoNearFar = !1,
        h.cameraObject.isPerspectiveCamera ? (h.cameraObject.fov = b.fov,
        h.cameraObject.aspect = b.viewport.width / b.viewport.height) : console.warn("Perspective camera required."),
        h.cameraObject.updateProjectionMatrix();
        const it = c.userData.arScale || 1;
        c.scale.set(it, it, it),
        c.position.copy(_.position).add(nt.multiplyScalar(5)),
        c.visible = !0;
        const at = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("Ground");
        at != null && at.mesh && (at.shadowBaker.enabled = !1,
        at.renderToDepth = !1)
    }
    _restorePreXRState() {
        var d;
        if (!this._viewer)
            return;
        this._viewer.renderer.rendererObject.setSize(this._preXRState.viewport.x, this._preXRState.viewport.y),
        this._viewer.resize(),
        this._viewer.scene.activeCamera.setInteractions(!0, ARPlugin_1.PluginType),
        this._viewer.scene.activeCamera.autoLookAtTarget = !0,
        this._viewer.scene.background = this._preXRState.viewerBg,
        this._preXRState.viewerBgColor !== void 0 && ((d = this._viewer.scene.backgroundColor) === null || d === void 0 || d.set(this._preXRState.viewerBgColor)),
        this._preXRState.viewerBg = null;
        const o = this._viewer.scene.modelRoot;
        o.scale.copy(this._preXRState.modelScale),
        o.position.copy(this._preXRState.modelPosition),
        o.quaternion.copy(this._preXRState.modelRotation),
        o.updateMatrix(),
        o.updateMatrixWorld(!0),
        o.visible = !0;
        const c = this._viewer.scene.activeCamera;
        c.position.copy(this._preXRState.cameraPosition),
        c.target.copy(this._preXRState.cameraTarget),
        c.cameraObject.up.copy(this._preXRState.cameraUp),
        c.cameraObject.near = this._preXRState.cameraNear,
        c.cameraObject.far = this._preXRState.cameraFar,
        c.cameraObject.userData.autoNearFar = this._preXRState.cameraAutoNearFar,
        c.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov !== void 0 && (c.cameraObject.fov = this._preXRState.cameraFov),
        this._preXRState.cameraAspect !== void 0 && (c.cameraObject.aspect = this._preXRState.cameraAspect)),
        c.positionUpdated(!1),
        c.targetUpdated(!0),
        c.cameraObject.projectionMatrix.copy(this._preXRState.cameraProjectionMatrix),
        c.cameraObject.projectionMatrixInverse.copy(this._preXRState.cameraProjectionMatrix).invert(),
        c.cameraObject.updateMatrixWorld(!0),
        c.cameraObject.updateProjectionMatrix();
        const h = this._viewer.getPluginByType("Ground");
        h != null && h.mesh && (h.mesh.modelObject.position.subVectors(o.position, this._preXRState.groundOffset),
        h.mesh.modelObject.scale.setScalar(this._preXRState.groundScale),
        h.mesh.modelObject.rotation.z = this._preXRState.groundRotation,
        h.renderToDepth = this._preXRState.groundRenderToDepth,
        h.shadowBaker.enabled = this._preXRState.groundShadowBaker,
        h.refreshTransform()),
        this._viewer.scene.setEnvironment(this._preXRState.environment),
        this._preXRState.environment = void 0,
        this._viewer.renderFilter.passObject.preserveTransparentTarget = this._preXRState.preserveTransparentTarget
    }
    _cancelHitSources() {
        this._hitTestSource && (this._hitTestSource.cancel(),
        this._hitTestSource = void 0),
        this._touchInputHelper.cancel()
    }
}
;
ARPlugin.PluginType = "WEBXR_ARPlugin",
ARPlugin_decorate([uiToggle("Light Estimate")], ARPlugin.prototype, "estimateLighting", void 0),
ARPlugin_decorate([uiToggle("Place on Wall")], ARPlugin.prototype, "placeOnWall", void 0),
ARPlugin_decorate([uiSlider("Resilution scale", [.1, 1], .1)], ARPlugin.prototype, "xrResolutionScale", void 0),
ARPlugin_decorate([uiButton("Enter AR")], ARPlugin.prototype, "enterAR", void 0),
ARPlugin_decorate([uiButton("Exit AR")], ARPlugin.prototype, "exitAR", void 0),
ARPlugin = ARPlugin_1 = ARPlugin_decorate([uiFolder("WebXR AR")], ARPlugin);
const arCopyPass = new ShaderPass2({
    vertexShader: CopyShader.vertexShader,
    fragmentShader: `
        ${unpackGbuffer}
        
        uniform float opacity;

		uniform sampler2D tDiffuse;
		uniform sampler2D tTransparentMap;

		varying vec2 vUv;

		void main() {
		
            float depth = getDepth(vUv);
            vec4 texel;
            if(depth>0.9999) {
			    texel = texture2D( tTransparentMap, vUv );
                if(texel.a < 0.01) discard; // background
                // transparent objects with render to depth = false
            }else {
                texel = texture2D( tDiffuse, vUv );
			}
            gl_FragColor = texel;
            
		}
		`,
    uniforms: {
        ...CopyShader.uniforms,
        tNormalDepth: {
            value: null
        },
        tTransparentMap: {
            value: null
        }
    }
});
arCopyPass.renderToScreen = !1,
arCopyPass.useExistingRenderTarget = !0,
arCopyPass.clear = !1;
var VRPluginBasic_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, VRPluginBasic_1;
let VRPluginBasic = VRPluginBasic_1 = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.dependencies = [GBufferPlugin],
        this.xrResolutionScale = 1,
        this.toJSON = void 0,
        this.enterVR = () => {
            var d;
            this.enabled && this._viewer && (navigator && navigator.xr ? this._xrSession ? console.warn("Already inVR") : this._xrManager ? (this._xrManager.enabled = !0,
            (d = this._xrManager) === null || d === void 0 || d.setFramebufferScaleFactor(this.xrResolutionScale),
            navigator.xr.requestSession("immersive-vr", {
                optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"]
            }).then(this._onSessionStarted)) : console.error("XR manager not found") : console.error("XR not supported"))
        }
        ,
        this.exitVR = () => {
            this._xrSession && this._xrSession.end()
        }
        ,
        this._currentCameraIndex = 0,
        this._preRender = () => {
            var d;
            if (!(this._dirty && this._viewer && this._xrManager && this._xrSession))
                return;
            this._viewer.renderer.defaultRenderToScreen = !1,
            this._xrManager.enabled = !1;
            const o = this._xrManager.getCamera()
              , c = ((d = o.cameras) === null || d === void 0 ? void 0 : d[this._currentCameraIndex]) || o
              , h = this._viewer.scene.activeCamera;
            h.cameraObject.zoom = c.zoom,
            h.cameraObject.near = c.near,
            h.cameraObject.far = c.far,
            h.cameraObject.userData.autoNearFar = !1,
            h.cameraObject.isPerspectiveCamera ? (h.cameraObject.fov = c.fov,
            h.cameraObject.aspect = c.viewport.width / c.viewport.height) : console.warn("Perspective camera required."),
            h.cameraObject.position.copy(c.position),
            h.cameraObject.rotation.copy(c.rotation),
            h.cameraObject.updateMatrix(),
            h.cameraObject.updateProjectionMatrix(),
            h.cameraObject.projectionMatrix.copy(c.projectionMatrix),
            h.cameraObject.projectionMatrixInverse.copy(h.cameraObject.projectionMatrix).invert()
        }
        ,
        this._currentRt = null,
        this._postRender = () => {
            var d, o, c, h;
            if (!this._dirty || !this._viewer || !this._xrSession)
                return;
            this._viewer.scene.activeCamera.cameraObject.updateProjectionMatrix();
            const _ = this._viewer.renderer
              , b = (_.rendererObject.getViewport(new three_module.IUQ),
            (c = (o = (d = this._xrManager) === null || d === void 0 ? void 0 : d.getCamera()) === null || o === void 0 ? void 0 : o.cameras) !== null && c !== void 0 ? c : [])
              , _e = _.rendererObject.getRenderTarget()
              , nt = (h = b[this._currentCameraIndex]) === null || h === void 0 ? void 0 : h.viewport;
            nt ? _e && _.rendererObject.setViewport(nt) : console.warn("no viewport for vr camera index", this._currentCameraIndex),
            this._viewer.getPlugin(GBufferPlugin).updateShaderProperties(VRPluginBasic_arCopyPass.material),
            VRPluginBasic_arCopyPass.uniforms.tTransparentMap.value = this._viewer.renderFilter.passObject.transparentTarget.texture,
            setThreeRendererMode(_.rendererObject, {
                sceneRender: !0,
                opaqueRender: !0,
                shadowMapRender: !1,
                backgroundRender: !1,
                transparentRender: !1,
                transmissionRender: !1,
                screenSpaceRendering: !1
            }, () => {
                VRPluginBasic_arCopyPass.render(_.rendererObject, null, _.composer.readBuffer, 0, !1)
            }
            ),
            this._xrManager.enabled = !0,
            this._viewer.renderer.defaultRenderToScreen = !0,
            _e && _.rendererObject.setViewport(_e.viewport),
            this._currentCameraIndex++,
            this._currentCameraIndex >= b.length && (this._currentCameraIndex = 0)
        }
        ,
        this._frameCount = 0,
        this._isPresenting = !1,
        this._interactionsDisabled = !1,
        this._preFrame = ({xrFrame: d, deltaTime: o}) => {
            var c, h;
            if (this.dirty = !!d && ((c = this._xrManager) === null || c === void 0 ? void 0 : c.isPresenting) || !1,
            (this._dirty || this._interactionsDisabled) && (this._viewer.scene.activeCamera.setInteractions(!this._dirty, VRPluginBasic_1.PluginType),
            this._viewer.scene.activeCamera.autoLookAtTarget = !this._dirty,
            this._interactionsDisabled = this._dirty),
            !this._dirty || !d)
                return void (this._isPresenting && this._xrRenderingEnd());
            if (!this._xrSession)
                return console.error("no xr session found, shouldn't happen"),
                void (this.dirty = !1);
            this._isPresenting || console.log("webxr: VR session init"),
            this._frameCount++;
            const _ = this._xrManager.getReferenceSpace()
              , b = d.getViewerPose(_);
            if (b == null && this._frameCount,
            b == null || ((h = this._viewer) === null || h === void 0 ? void 0 : h.scene.modelRoot.children.length) === 0)
                return this.dirty = !1,
                void console.warn("no pose or no model");
            this._isPresenting || (this._isPresenting = !0,
            this._frameCount = 0,
            this._savePreXRState(),
            this._preSetupModel(),
            this._xrRenderingBegin());
            const _e = this._viewer.scene.activeCamera;
            this._xrManager.updateCamera(_e.cameraObject),
            _e.setDirty(),
            this._viewer.rendersPerFrame = b ? b.views.length : 1,
            this._updateShadow()
        }
        ,
        this._preXRState = {
            viewerBg: null,
            viewerBgColor: void 0,
            modelScale: new three_module.Pq0(1,1,1),
            modelPosition: new three_module.Pq0,
            modelRotation: new three_module.PTz,
            cameraPosition: new three_module.Pq0(0,0,5),
            cameraTarget: new three_module.Pq0,
            cameraUp: new three_module.Pq0(0,1,0),
            cameraAspect: 1,
            cameraFov: 50,
            cameraZoom: 1,
            cameraNear: .01,
            cameraFar: 100,
            cameraProjectioMatrix: new three_module.kn4,
            cameraAutoNearFar: void 0,
            groundOffset: new three_module.Pq0,
            groundScale: 1,
            groundRotation: 0,
            groundRenderToDepth: !1,
            groundShadowBaker: !1,
            viewport: new three_module.I9Y,
            environment: void 0,
            preserveTransparentTarget: !0
        },
        this._savePreXRState = () => {
            var d;
            if (!this._viewer)
                return;
            this._preXRState.viewport.copy(this._viewer.renderer.renderSize),
            this._preXRState.viewerBg = this._viewer.scene.background,
            this._preXRState.viewerBgColor = (d = this._viewer.scene.backgroundColor) === null || d === void 0 ? void 0 : d.getHex();
            const o = this._viewer.scene.modelRoot
              , c = this._viewer.scene.activeCamera;
            o.updateMatrix(),
            o.updateMatrixWorld(!0),
            this._preXRState.modelScale.copy(o.scale),
            this._preXRState.modelPosition.copy(o.position),
            this._preXRState.modelRotation.copy(o.quaternion),
            this._preXRState.cameraPosition.copy(c.position),
            this._preXRState.cameraTarget.copy(c.target),
            this._preXRState.cameraUp.copy(c.cameraObject.up),
            c.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov = c.cameraObject.fov,
            this._preXRState.cameraAspect = c.cameraObject.aspect),
            this._preXRState.cameraZoom = c.cameraObject.zoom,
            this._preXRState.cameraNear = c.cameraObject.near,
            this._preXRState.cameraFar = c.cameraObject.far,
            this._preXRState.cameraAutoNearFar = c.cameraObject.userData.autoNearFar,
            this._preXRState.cameraProjectioMatrix.copy(c.cameraObject.projectionMatrix);
            const h = this._viewer.getPluginByType("Ground");
            h != null && h.mesh && (this._preXRState.groundOffset.subVectors(o.position, h.mesh.modelObject.position),
            this._preXRState.groundScale = h.mesh.modelObject.scale.x,
            this._preXRState.groundRotation = h.mesh.modelObject.rotation.z,
            this._preXRState.groundRenderToDepth = h.renderToDepth,
            this._preXRState.groundShadowBaker = h.shadowBaker.enabled),
            this._preXRState.environment || (this._preXRState.environment = this._viewer.scene.environment),
            this._preXRState.preserveTransparentTarget = this._viewer.renderFilter.passObject.preserveTransparentTarget
        }
        ,
        this._xrRenderingBegin = () => {
            this._xrSession && this._viewer && (console.log("webxr: VR session start"),
            this._viewer.renderer.stableNoise = !0,
            this._viewer.resize())
        }
        ,
        this._xrRenderingEnd = () => {
            console.log("webxr: VR session end"),
            this._xrManager && (this._xrManager.enabled = !1),
            this._isPresenting = !1,
            this._frameCount = 0,
            this._xrSession = void 0,
            this._cancelHitSources(),
            this._viewer && (this._viewer.renderer.stableNoise = !1),
            this._restorePreXRState()
        }
        ,
        this._onSessionStarted = async d => {
            d.addEventListener("end", this._onSessionEnded),
            this._xrManager.setReferenceSpaceType("local"),
            await this._xrManager.setSession(d),
            this._xrSession = d
        }
        ,
        this._onSessionEnded = () => {
            this._xrSession && this._xrSession.removeEventListener("end", this._onSessionEnded)
        }
    }
    async onAdded(d) {
        await super.onAdded(d);
        const o = d.renderer.rendererObject.xr;
        if (o.cameraAutoUpdate = !1,
        this._xrManager = o,
        !this.domOverlay) {
            const c = document.getElementById("tweakpaneUiContainer");
            this.domOverlay = c ? {
                root: c
            } : void 0
        }
        if (d.addEventListener("preRender", this._preRender),
        d.addEventListener("postRender", this._postRender),
        d.addEventListener("preFrame", this._preFrame),
        !window.isSecureContext)
            return d.console.error("XR not supported in insecure context, try https://"),
            void (this.enabled = !1);
        navigator && "xr"in navigator && navigator.xr ? navigator.xr.isSessionSupported("immersive-vr").then(c => {
            if (!c)
                throw new Error("VR not supported")
        }
        ).catch(c => {
            d.console.error("VR not supported:", c),
            o.enabled = !1,
            this.enabled = !1
        }
        ) : (o.enabled = !1,
        this.enabled = !1)
    }
    _updateShadow() {
        var d, o;
        if (!this._viewer)
            return;
        const c = this._viewer.scene.modelRoot
          , h = (o = (d = this._viewer.getPluginByType("Ground")) === null || d === void 0 ? void 0 : d.mesh) === null || o === void 0 ? void 0 : o.modelObject;
        h && (h.rotation.z = this._viewer.scene.modelRoot.rotation.y,
        h.position.copy(this._preXRState.groundOffset).multiplyScalar(c.modelObject.scale.x).sub(c.modelObject.position).negate(),
        h.scale.setScalar(c.modelObject.scale.x * this._preXRState.groundScale))
    }
    _preSetupModel() {
        var d;
        const o = this._viewer.scene.modelRoot
          , c = o.userData.arScale || 1;
        o.scale.set(c, c, c),
        o.visible = !0;
        const h = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPluginByType("Ground");
        h != null && h.mesh && (h.shadowBaker.enabled = !1,
        h.renderToDepth = !1)
    }
    _restorePreXRState() {
        var d;
        if (!this._viewer)
            return;
        this._viewer.renderer.rendererObject.setSize(this._preXRState.viewport.x, this._preXRState.viewport.y),
        this._viewer.resize(),
        this._viewer.scene.activeCamera.setInteractions(!0, VRPluginBasic_1.PluginType),
        this._viewer.scene.activeCamera.autoLookAtTarget = !0,
        this._viewer.scene.background = this._preXRState.viewerBg,
        this._preXRState.viewerBgColor !== void 0 && ((d = this._viewer.scene.backgroundColor) === null || d === void 0 || d.set(this._preXRState.viewerBgColor)),
        this._preXRState.viewerBg = null;
        const o = this._viewer.scene.modelRoot;
        o.scale.copy(this._preXRState.modelScale),
        o.position.copy(this._preXRState.modelPosition),
        o.quaternion.copy(this._preXRState.modelRotation),
        o.updateMatrix(),
        o.updateMatrixWorld(!0),
        o.visible = !0;
        const c = this._viewer.scene.activeCamera;
        c.position.copy(this._preXRState.cameraPosition),
        c.target.copy(this._preXRState.cameraTarget),
        c.cameraObject.up.copy(this._preXRState.cameraUp),
        c.cameraObject.near = this._preXRState.cameraNear,
        c.cameraObject.far = this._preXRState.cameraFar,
        c.cameraObject.userData.autoNearFar = this._preXRState.cameraAutoNearFar,
        c.cameraObject.isPerspectiveCamera && (this._preXRState.cameraFov !== void 0 && (c.cameraObject.fov = this._preXRState.cameraFov),
        this._preXRState.cameraAspect !== void 0 && (c.cameraObject.aspect = this._preXRState.cameraAspect)),
        c.positionUpdated(!1),
        c.targetUpdated(!0),
        c.cameraObject.projectionMatrix.copy(this._preXRState.cameraProjectioMatrix),
        c.cameraObject.projectionMatrixInverse.copy(this._preXRState.cameraProjectioMatrix).invert(),
        c.cameraObject.updateMatrixWorld(!0),
        c.cameraObject.updateProjectionMatrix();
        const h = this._viewer.getPluginByType("Ground");
        h != null && h.mesh && (h.mesh.modelObject.position.subVectors(o.position, this._preXRState.groundOffset),
        h.mesh.modelObject.scale.setScalar(this._preXRState.groundScale),
        h.mesh.modelObject.rotation.z = this._preXRState.groundRotation,
        h.renderToDepth = this._preXRState.groundRenderToDepth,
        h.shadowBaker.enabled = this._preXRState.groundShadowBaker,
        h.refreshTransform()),
        this._viewer.scene.environment = this._preXRState.environment,
        this._preXRState.environment = void 0,
        this._viewer.renderFilter.passObject.preserveTransparentTarget = this._preXRState.preserveTransparentTarget
    }
    _cancelHitSources() {}
}
;
VRPluginBasic.PluginType = "WEBXR_VRPluginBasic",
VRPluginBasic_decorate([uiSlider("Resolution scale", [.1, 1], .1)], VRPluginBasic.prototype, "xrResolutionScale", void 0),
VRPluginBasic_decorate([uiButton("Enter VR")], VRPluginBasic.prototype, "enterVR", void 0),
VRPluginBasic_decorate([uiButton("Exit VR")], VRPluginBasic.prototype, "exitVR", void 0),
VRPluginBasic = VRPluginBasic_1 = VRPluginBasic_decorate([uiFolder("WebXR VR")], VRPluginBasic);
const VRPluginBasic_arCopyPass = new ShaderPass2({
    vertexShader: CopyShader.vertexShader,
    fragmentShader: `
        ${unpackGbuffer}
        
        uniform float opacity;

		uniform sampler2D tDiffuse;
		uniform sampler2D tTransparentMap;

		varying vec2 vUv;

		void main() {
		
            float depth = getDepth(vUv);
            vec4 texel;
            if(depth>0.9999) {
			    texel = texture2D( tTransparentMap, vUv );
                if(texel.a < 0.01) discard; // background
                // transparent objects with render to depth = false
            }else {
                texel = texture2D( tDiffuse, vUv );
			}
            gl_FragColor = texel;
            
		}
		`,
    uniforms: {
        ...CopyShader.uniforms,
        tNormalDepth: {
            value: null
        },
        tTransparentMap: {
            value: null
        }
    }
});
VRPluginBasic_arCopyPass.renderToScreen = !1,
VRPluginBasic_arCopyPass.useExistingRenderTarget = !0,
VRPluginBasic_arCopyPass.clear = !1;
class ACanvasRecorder extends I$2 {
    get state() {
        return this._state
    }
    setState(o, c) {
        this._state = o,
        this.dispatchEvent({
            type: o,
            ...c
        })
    }
    _setOptions(o) {
        Object.assign(this.options, o)
    }
    setOptions(o) {
        this._setOptions(o)
    }
    constructor(o, c) {
        super(),
        this._state = "stopped",
        this._console = console,
        this._currentRecording = [],
        this._frameCount = 0,
        this._ondataavailable = h => {
            h.data && h.data.size > 0 && this._currentRecording.push(h.data)
        }
        ,
        this._canvas = o,
        c == null || c.mimeType,
        this.options = {
            mimeType: "auto",
            frameRate: 30,
            stepMode: !1
        },
        this._setOptions(c || this.options)
    }
    isRecording() {
        return this._state === "recording"
    }
    requestFrame() {
        return this._state === "recording" && (this._frameCount++,
        !0)
    }
    dispose() {
        (this.isRecording() || this._state === "paused") && this.stop(o => {
            this._console.warn("disposed with blob", o),
            this.dispose()
        }
        )
    }
}
class ImageSequenceRecorder extends ACanvasRecorder {
    constructor() {
        super(...arguments),
        this._currentImages = [],
        this._onstop = o => {
            this._currentImages.length > 0 && (this._writeImages([...this._currentImages]),
            this._currentImages = []),
            this.setState("stopped")
        }
        ,
        this._onerror = o => {
            this.setState("error", {
                error: o
            }),
            this._console.error(o)
        }
    }
    start() {
        if (this.state !== "recording") {
            if (this.state === "error" && this._console.warn("Resetting from error state."),
            this.state === "paused")
                return this.setState("starting"),
                void this.setState("recording");
            this._currentRecording = [],
            this._currentImages = [],
            this._frameCount = 0,
            this.setState("starting"),
            window && window.showDirectoryPicker && window.showDirectoryPicker().then(async o => {
                const c = await (o == null ? void 0 : o.getDirectoryHandle("i-" + Math.floor(Date.now()), {
                    create: !0
                }));
                this._imgDirectory = c,
                this._frameCount = 0,
                this.setState("recording")
            }
            ).catch(o => {
                this._onerror({
                    detail: o
                })
            }
            )
        } else
            this._console.log("Already recording canvas")
    }
    requestFrame() {
        if (!super.requestFrame())
            return !1;
        const o = this.options.mimeType;
        return this._canvas.toBlob(c => {
            this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (o.includes("png") ? ".png" : ".jpg"), c])
        }
        , o, 90),
        this._currentImages.length > 60 && (this._writeImages([...this._currentImages]),
        this._currentImages = []),
        !0
    }
    pause() {
        this.state !== "paused" && this.state !== "stopped" && this.setState("paused")
    }
    stop(o) {
        this.state !== "stopped" && (this.state !== "error" ? (this._recordingCallback = o,
        this.setState("stopping"),
        this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."))
    }
    async _writeImages(o) {
        if (!this._imgDirectory)
            return;
        const c = [];
        for (const h of o) {
            const _ = await this._imgDirectory.getFileHandle(h[0], {
                create: !0
            });
            c.push($e$1(_, h[1]))
        }
        await Promise.all(c)
    }
}
class CanvasMediaRecorder extends ACanvasRecorder {
    _setOptions(o) {
        var c, h;
        super._setOptions(o),
        this.options.mimeType && this.options.mimeType !== "auto" || (this.options.mimeType = (c = CanvasMediaRecorder.GetSupportedMimeTypes([], ["h264"], !0)) !== null && c !== void 0 ? c : CanvasMediaRecorder.GetSupportedMimeTypes(void 0, void 0, !0)),
        this.options.mimeType && !(!((h = this.options.mimeType) === null || h === void 0) && h.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"),
        this.options.mimeType = "image/png"),
        this.options.mimeType || console.warn(new Error("No supported mimetype found"))
    }
    setOptions(o) {
        this._setOptions(o)
    }
    constructor(o, c) {
        super(o, c),
        this._resumeSyncTime = 0,
        this._onstop = h => {
            var _;
            if (this._recorder && this._currentRecording.length > 0) {
                const b = new Blob(this._currentRecording,{
                    type: this.options.mimeType
                });
                (_ = this._recordingCallback) === null || _ === void 0 || _.call(this, b)
            }
            this._recorder = void 0,
            this.setState("stopped")
        }
        ,
        this._onstart = h => {
            var _;
            this._frameCount = 0,
            this.options.stepMode && ((_ = this._recorder) === null || _ === void 0 || _.pause()),
            this.setState("recording")
        }
        ,
        this._onresume = h => {
            if (this.state !== "paused" && this.state !== "starting" && this.state !== "stopped" || this.setState("recording"),
            !this.options.stepMode)
                return;
            const _ = () => {
                var _e;
                this.state === "recording" && ((_e = this._recorder) === null || _e === void 0 || _e.pause())
            }
              , b = Math.min(this._resumeSyncTime - g(), 0) + 1e3 / this.options.frameRate;
            b > 0 ? X$2(b).then(_) : _()
        }
        ,
        this._onerror = h => {
            this.setState("error", {
                error: h
            }),
            this._console.error(h),
            this._recorder = void 0
        }
    }
    start() {
        var o, c, h;
        if (this.state === "recording")
            return void this._console.log("Already recording canvas");
        if (this.state === "error" && (this._recorder = void 0,
        this._console.warn("Resetting from error state.")),
        this._recorder)
            return this.state === "paused" ? (this.setState("starting"),
            void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this.state);
        const _ = {
            mimeType: this.options.mimeType,
            videoBitsPerSecond: this.options.videoBitsPerSecond
        };
        if (this._currentRecording = [],
        this._frameCount = 0,
        (o = _.mimeType) === null || o === void 0 ? void 0 : o.startsWith("video")) {
            if (!window.MediaRecorder)
                return this._console.error("MediaRecorder not supported, use image sequence"),
                void this.setState("error", {
                    error: new Error("MediaRecorder not supported")
                });
            {
                const b = this._canvas.captureStream(this.options.stepMode ? 0 : this.options.frameRate)
                  , _e = (c = b.getVideoTracks()) === null || c === void 0 ? void 0 : c[0];
                this._track = _e,
                this._recorder = new window.MediaRecorder(b,_),
                this._recorder.onstop = this._onstop,
                this._recorder.ondataavailable = this._ondataavailable,
                this._recorder.onerror = this._onerror,
                this._recorder.onresume = this._onresume,
                this._recorder.onstart = this._onstart
            }
        }
        this.setState("starting"),
        this._recorder && ((h = this._recorder) === null || h === void 0 || h.start())
    }
    requestFrame() {
        return !(!this._recorder || !super.requestFrame() || this._track && this.options.stepMode && (this._resumeSyncTime = g(),
        this._track.requestFrame(),
        this._recorder.resume(),
        0))
    }
    pause() {
        this.state !== "paused" && this.state !== "stopped" && (this.options.stepMode ? console.error("Pause not supported in stepMode") : this._recorder && (this._recorder.pause(),
        this.setState("paused")))
    }
    stop(o) {
        this.state !== "stopped" && (this.state !== "error" ? (this._recordingCallback = o,
        this.setState("stopping"),
        this._recorder && this._recorder.stop()) : this._console.error("Recorder in error state, cannot stop, call start again."))
    }
    dispose() {
        this._recorder && (super.dispose(),
        this._recorder = void 0)
    }
    static GetSupportedMimeTypes(o, c, h=!1) {
        if (!window.MediaRecorder)
            return h ? void 0 : [];
        const _ = ["webm", "ogg", "mp4", "x-matroska"].filter(nt => !o || o.length < 1 || o.includes(nt))
          , b = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter(nt => !c || c.length < 1 || c.includes(nt))
          , _e = [];
        return _.forEach(nt => {
            const it = `video/${nt}`;
            b.forEach(at => {
                [`${it};codecs=${at}`, `${it};codecs:${at}`, `${it};codecs=${at.toUpperCase()}`, `${it};codecs:${at.toUpperCase()}`, `${it}`].forEach(ut => {
                    MediaRecorder.isTypeSupported(ut) && _e.push(ut)
                }
                )
            }
            )
        }
        ),
        h ? _e.length > 0 ? _e[0] : void 0 : _e
    }
}
class FFMPEGRecorder extends ACanvasRecorder {
    constructor(o, c) {
        super(o, c),
        this._workerRunning = !1,
        this.ffmpegOptions = {
            imageType: "jpeg",
            bitrate: "10M",
            crf: 17,
            pixFmt: "yuv420p",
            preset: "ultrafast",
            colorTrc: "bt709",
            colorSpace: "bt709"
        },
        this.worker = new Worker(ct(FFMPEGRecorder.LIBRARY_PATH + "ffmpeg-worker-mp4.js", FFMPEGRecorder.LIBRARY_PATH + "ffmpeg-worker-mp4.wasm")),
        this.worker.onmessage = h => {
            var _;
            const b = h.data;
            switch (b.type) {
            case "stdout":
            case "stderr":
                if (b.data.indexOf("frame=") === 0) {
                    const _e = parseInt(b.data.split("frame=")[1].split("fps")[0].trim())
                      , nt = this._frameCount
                      , it = Math.round(_e / nt * 100);
                    this.dispatchEvent({
                        type: "encode-progress",
                        progress: it,
                        frame: _e,
                        totalFrames: nt
                    })
                }
                console.log(b.data + `
`);
                break;
            case "exit":
                console.log("Process exited with code " + b.data),
                parseInt(b.data);
                break;
            case "done":
                if (b.data.MEMFS[0].data === void 0)
                    return void console.log("video processing failed");
                this._workerRunning = !1,
                (_ = this._recordingCallback) === null || _ === void 0 || _.call(this, new Blob([b.data.MEMFS[0].data],{
                    type: "video/mp4"
                })),
                console.timeEnd("ffmpeg-record"),
                this.setState("stopped")
            }
        }
    }
    start() {
        this.state !== "recording" ? (this.state === "error" && console.warn("Resetting from error state."),
        this.state !== "paused" && (this._frameCount = 0),
        this.setState("starting"),
        this.setState("recording")) : console.log("Already recording canvas")
    }
    stop(o) {
        this.state !== "stopped" && (this.state !== "error" ? (this._recordingCallback = o,
        this.setState("stopping"),
        this._lastCanvasCapturePromise ? this._lastCanvasCapturePromise.then( () => this._onStop()) : this._onStop()) : console.error("FFMPEGRecorder: Recorder in error state, cannot stop, call start again."))
    }
    _onStop() {
        var o, c, h, _;
        const b = this._canvas.width % 2 == 0 ? this._canvas.width : this._canvas.width - 1;
        this._workerRunning = !0,
        console.time("ffmpeg-record");
        const _e = this.options.frameRate.toString()
          , nt = this.options.frameRate.toString()
          , it = ["-r", _e, "-an", "-i", `img%06d.${this._mime}`, "-frames:v", this._frameCount.toString(), "-c:v", "libx264", "-crf", Math.min(28, Math.max(1, (o = this.ffmpegOptions.crf) !== null && o !== void 0 ? o : 17)).toString(), "-filter:v", `scale=${b}:-2`, "-pix_fmt", (c = this.ffmpegOptions.pixFmt) !== null && c !== void 0 ? c : "yuv420p", "-b:v", (h = this.ffmpegOptions.bitrate) !== null && h !== void 0 ? h : "10M", "-preset", (_ = this.ffmpegOptions.preset) !== null && _ !== void 0 ? _ : "ultrafast", "-r", nt];
        this.ffmpegOptions.colorSpace && it.push("-colorspace", this.ffmpegOptions.colorSpace),
        this.ffmpegOptions.colorTrc && it.push("-color_trc", this.ffmpegOptions.colorTrc),
        it.push("out.mp4"),
        console.log(it),
        this.worker.postMessage({
            type: "run",
            arguments: it
        })
    }
    requestFrame() {
        return !!super.requestFrame() && (this.sendBlobToWorker(this._frameCount - 1),
        !0)
    }
    get _mime() {
        var o;
        let c = (o = this.ffmpegOptions.imageType) !== null && o !== void 0 ? o : "jpeg";
        return c && ["png", "jpeg", "webp"].includes(c) || (console.warn("FFMPEGRecorder: Unsupported mime type", this.ffmpegOptions.imageType),
        c = "jpeg"),
        c
    }
    sendBlobToWorker(o) {
        this._lastCanvasCapturePromise && console.warn("FFMPEGRecorder: Previous frame capture not complete", o - 1);
        const c = this._mime;
        this._lastCanvasCapturePromise = new Promise(h => {
            this._canvas.toBlob(_ => {
                this.worker.postMessage({
                    type: "image",
                    file: {
                        name: `img${o.toString().padStart(6, "0")}.${c}`,
                        data: _
                    }
                }),
                this._lastCanvasCapturePromise = void 0,
                h()
            }
            , `image/${c}`, 90)
        }
        )
    }
    pad(o, c) {
        return (o += "").length >= c ? o : new Array(c - o.length + 1).join("0") + o
    }
    pause() {
        this.state !== "paused" && this.state !== "stopped" && this.setState("paused")
    }
    setOptions(o) {
        super.setOptions(o)
    }
}
FFMPEGRecorder.LIBRARY_PATH = "https://cdn.jsdelivr.net/npm/@repalash/ffmpeg.js@4.2.9005/dist/";
var CanvasRecorderPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class CanvasRecorderPlugin extends AViewerPlugin {
    get recorder() {
        return this._recorder
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.convergeMode = !0,
        this.mimeType = "video/mp4",
        this.videoFrameRate = 30,
        this._recorders = {},
        this._renderToScreenDisabled = !1,
        this._preRender = () => {
            var o, c, h;
            if (this.convergeMode && (!((o = this._recorder) === null || o === void 0) && o.isRecording())) {
                const _ = this._viewer.renderer.composer.renderToScreen;
                this._viewer.renderer.composer.renderToScreen = ((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Progressive")) === null || h === void 0 ? void 0 : h.isConverged()) || !1,
                _ && !this._viewer.renderer.composer.renderToScreen && (this._renderToScreenDisabled = !0)
            }
        }
        ,
        this._postRender = () => {
            var o, c, h;
            if (!((o = this._recorder) === null || o === void 0) && o.isRecording() && (!this.convergeMode || !((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Progressive")) === null || h === void 0) && h.isConverged(!0))) {
                const _ = () => {
                    var b;
                    return (b = this._recorder) === null || b === void 0 ? void 0 : b.requestFrame()
                }
                ;
                this.convergeMode ? X$2(1).then(_) : _()
            }
            this._renderToScreenDisabled && (this._viewer.renderer.composer.renderToScreen = !0)
        }
        ,
        this._refreshUi = () => {
            var o;
            (o = this.uiConfig.children) === null || o === void 0 || o.map(c => Ee$1(c)).flat(2).forEach(c => {
                var h;
                return (h = c == null ? void 0 : c.uiRefresh) === null || h === void 0 ? void 0 : h.call(c)
            }
            )
        }
        ,
        this.endPaddingMs = 500,
        this._turntableAnimationAngle = 360,
        this._turntableAnimationDuration = 5,
        this._turntableAnimationEasing = "linear",
        this.uiConfig = {
            type: "folder",
            label: "Video Export",
            children: [{
                type: "slider",
                label: "Frame Rate",
                bounds: [1, 60],
                stepSize: 1,
                property: [this, "videoFrameRate"]
            }, {
                type: "checkbox",
                property: [this, "convergeMode"],
                onChange: () => {
                    var o, c;
                    return (c = (o = this.uiConfig).uiRefresh) === null || c === void 0 ? void 0 : c.call(o, "postFrame", !0)
                }
            }, {
                type: "dropdown",
                label: "Mime type",
                property: [this, "mimeType"],
                children: [["Auto Video (x264)", "auto"], ["PNG sequence", "image/png"], ["JPEG sequence", "image/jpeg"], ["WEBP sequence", "image/webp"], ["MP4 Video (ffmpeg)", "video/mp4"]].map(o => ({
                    label: o[0],
                    value: o[1]
                }))
            }, generateUiFolder("FFmpeg Options (Advanced)", () => this._recorder.ffmpegOptions, {}, "folder", !0), {
                type: "input",
                disabled: !0,
                label: "State",
                getValue: () => {
                    var o, c;
                    return (c = (o = this.recorder) === null || o === void 0 ? void 0 : o.state) !== null && c !== void 0 ? c : "not initialized"
                }
            }, {
                type: "button",
                label: () => this.isRecording() ? "Stop Recording" : "Start Recording",
                hidden: () => !this.isRecording() && this.convergeMode,
                value: () => {
                    this.isRecording() ? this.stopRecording().then(async o => {
                        if (o) {
                            const c = o.type.split(";")[0].split("/").pop() || "mp4";
                            await this._downloadBlob(o, c)
                        }
                    }
                    ) : this.startRecording()
                }
            }, {
                type: "button",
                label: "Record Camera Views",
                hidden: () => {
                    var o;
                    return this.isRecording() || !(!((o = this._viewer) === null || o === void 0) && o.getPluginByType("CameraViews"))
                }
                ,
                value: () => {
                    var o, c;
                    (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("CameraViews")) === null || c === void 0 || c.recordAllViews()
                }
            }, {
                type: "button",
                label: "Record Camera Views + GLTF Anim",
                hidden: () => {
                    var o, c, h;
                    return this.isRecording() || !(!((o = this._viewer) === null || o === void 0) && o.getPluginByType("CameraViews")) || !(!((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("GLTFAnimation")) === null || h === void 0) && h.animations.length)
                }
                ,
                value: () => {
                    var o, c, h, _;
                    const b = ((c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("GLTFAnimation")) === null || c === void 0 ? void 0 : c.animationState) === "playing";
                    (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPluginByType("CameraViews")) === null || _ === void 0 || _.recordAllViews( () => {
                        var _e, nt;
                        (nt = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.getPluginByType("GLTFAnimation")) === null || nt === void 0 || nt.playAnimation()
                    }
                    ).then( () => {
                        var _e, nt;
                        b || (nt = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.getPluginByType("GLTFAnimation")) === null || nt === void 0 || nt.stopAnimation()
                    }
                    )
                }
            }, {
                type: "button",
                label: "Record GLTF Anim",
                hidden: () => {
                    var o, c;
                    return this.isRecording() || !(!((c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("GLTFAnimation")) === null || c === void 0) && c.animations.length)
                }
                ,
                value: async () => {
                    var o;
                    if (this.isRecording())
                        return;
                    const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("GLTFAnimation");
                    if (!c)
                        return;
                    let h = !1;
                    c.loopAnimations && (h = !0),
                    h && (c.loopAnimations = !1);
                    const _ = await this.record(async () => c.playAnimation());
                    if (h && (c.loopAnimations = !0),
                    _) {
                        const b = _.type.split(";")[0].split("/").pop() || "mp4";
                        await this._downloadBlob(_, b)
                    }
                }
            }, {
                type: "number",
                label: "Turntable animation angle",
                disabled: () => this.isRecording(),
                property: [this, "_turntableAnimationAngle"]
            }, {
                type: "number",
                label: "Turntable animation time (sec)",
                disabled: () => this.isRecording(),
                property: [this, "_turntableAnimationDuration"]
            }, {
                type: "dropdown",
                label: "Turntable animation ease",
                children: Object.keys(EasingFunctions).map(o => ({
                    label: o
                })),
                disabled: () => this.isRecording(),
                property: [this, "_turntableAnimationEasing"]
            }, {
                type: "button",
                label: "Record turntable animation",
                hidden: () => this.isRecording(),
                value: async () => this.download360Recording(this._turntableAnimationDuration, !1, this._turntableAnimationAngle, EasingFunctions[this._turntableAnimationEasing])
            }, {
                type: "button",
                label: "Record turntable animation (CCW)",
                hidden: () => this.isRecording(),
                value: async () => this.download360Recording(this._turntableAnimationDuration, !0, this._turntableAnimationAngle, EasingFunctions[this._turntableAnimationEasing])
            }, {
                type: "number",
                label: "After recording wait time (ms)",
                disabled: () => this.isRecording(),
                property: [this, "endPaddingMs"]
            }]
        },
        this.refreshRecorderOptions = this.refreshRecorderOptions.bind(this)
    }
    isRecording() {
        var o, c;
        return (c = (o = this._recorder) === null || o === void 0 ? void 0 : o.isRecording()) !== null && c !== void 0 && c
    }
    refreshRecorderOptions() {
        var o, c;
        if (!this._viewer)
            return;
        let h = "image";
        this.mimeType === "video/mp4" ? h = "ffmpeg.js" : this.mimeType === "auto" ? h = "canvas-media" : this.mimeType.startsWith("image") && (h = "image"),
        this._recorder = this._getRecorder(h),
        this._recorder && (this._recorder.setOptions({
            frameRate: this.videoFrameRate,
            mimeType: this.mimeType,
            stepMode: this.convergeMode,
            internalMimeType: this.internalMimeType
        }),
        (c = (o = this.uiConfig).uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0))
    }
    async onAdded(o) {
        var c;
        await super.onAdded(o),
        o.addEventListener("preRender", this._preRender),
        o.addEventListener("postRender", this._postRender),
        o.scene.addEventListener("addSceneObject", this._refreshUi),
        this._recordIndicator = document.createElement("div"),
        this._recordIndicator.style.width = "20px",
        this._recordIndicator.style.height = "20px",
        this._recordIndicator.style.backgroundColor = "red",
        this._recordIndicator.style.top = "10px",
        this._recordIndicator.style.left = "10px",
        this._recordIndicator.style.position = "absolute",
        this._recordIndicator.style.borderRadius = "100%",
        this._recordIndicator.style.visibility = "hidden",
        (c = o.canvas.parentElement) === null || c === void 0 || c.appendChild(this._recordIndicator),
        this.refreshRecorderOptions()
    }
    _stateChange(o) {
        var c, h;
        this.dirty = o,
        (c = this._viewer) === null || c === void 0 || c.setDirty(),
        (h = this.uiConfig.children) === null || h === void 0 || h.map(_ => Ee$1(_)).flat(2).forEach(_ => {
            var b;
            return (b = _ == null ? void 0 : _.uiRefresh) === null || b === void 0 ? void 0 : b.call(_)
        }
        )
    }
    async onRemove(o) {
        var c;
        return o.removeEventListener("preRender", this._preRender),
        o.removeEventListener("preRender", this._postRender),
        o.scene.removeEventListener("addSceneObject", this._refreshUi),
        (c = this._recorder) === null || c === void 0 || c.dispose(),
        Object.values(this._recorders).forEach(h => {
            h == null || h.dispose()
        }
        ),
        super.onRemove(o)
    }
    async record(o, c) {
        var h, _;
        if (!this.enabled || !((h = this._recorder) === null || h === void 0) && h.isRecording())
            return;
        const b = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getPluginByType("Progressive")
          , _e = b == null ? void 0 : b.maxFrameCount;
        b && this.convergeMode && (b.maxFrameCount = Math.min(16, _e ?? 16)),
        await new Promise( (it, at) => {
            const ut = () => {
                this.removeEventListener("start", pt),
                this.removeEventListener("stop", ut),
                this.removeEventListener("error", ht)
            }
              , pt = async () => {
                ut(),
                c == null || c(),
                await o(),
                it()
            }
              , ht = async () => {
                ut(),
                at()
            }
            ;
            this.addEventListener("start", pt),
            this.addEventListener("stop", ut),
            this.addEventListener("error", ht),
            this.startRecording()
        }
        );
        const nt = await this.stopRecording();
        return b && this.convergeMode && (b.maxFrameCount = _e ?? 16),
        nt
    }
    startRecording() {
        var o;
        return !!this.enabled && ((o = this.recorder) === null || o === void 0 ? void 0 : o.isRecording()) === !1 && (this.recorder.options.stepMode = this.convergeMode,
        this.recorder.start(),
        !0)
    }
    async stopRecording() {
        var o, c;
        if (!((o = this.recorder) === null || o === void 0) && o.isRecording() && this._viewer) {
            if (await this._viewer.doOnce("postFrame"),
            this.convergeMode) {
                const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Progressive");
                if (h)
                    for (let b = 0; b < 10 && !h.isConverged(!0); b++)
                        await this._viewer.doOnce("postFrame")
            }
            return this.endPaddingMs && await X$2(this.endPaddingMs),
            new Promise( (h, _) => {
                var b;
                return (b = this.recorder) === null || b === void 0 ? void 0 : b.stop(h)
            }
            )
        }
    }
    async _downloadBlob(o, c) {
        var h, _, b;
        const _e = await ((h = this._viewer) === null || h === void 0 ? void 0 : h.prompt("Canvas Recorder: Save file as", "recording.mp4", !1))
          , nt = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getPluginByType("FileTransferPlugin");
        nt ? await nt.exportFile(o, _e || "recording.mp4") : (b = this._viewer) === null || b === void 0 || b.console.error("FileTransferPlugin required to export/download file")
    }
    async download360Recording(o=null, c=!1, h=360, _) {
        var b;
        if (!((b = this.recorder) === null || b === void 0) && b.isRecording() || !this._viewer)
            return;
        const _e = o || await this._viewer.prompt("Enter duration in seconds", "5", !0);
        if (_e === null)
            return;
        const nt = parseFloat(_e || "5");
        if (!isFinite(nt) || nt <= 0)
            return;
        const it = await this.recordCamera360(nt, c, h, _);
        if (it) {
            const at = it.type.split(";")[0].split("/").pop() || "mp4";
            await this._downloadBlob(it, at)
        }
    }
    async recordCamera360(o, c=!1, h=360, _) {
        var b;
        if (!((b = this.recorder) === null || b === void 0) && b.isRecording() || !this._viewer)
            return;
        const _e = this._viewer.scene.activeCamera;
        let nt = _e.interactionsEnabled
          , it = 0;
        for (; !(nt || (this._viewer.setDirty(),
        await this._viewer.doOnce("postFrame"),
        it % 30 == 0 && this._viewer.console.warn("CanvasRecorderPlugin: interactions are already disabled by something, waiting..."),
        nt = _e.interactionsEnabled,
        it > 5e3 / 30)); )
            it++;
        _e.setInteractions(!1, CanvasRecorderPlugin.PluginType);
        const at = _e.target.clone()
          , ut = _e.position.clone().sub(at)
          , pt = await this._viewer.getPluginByType("PopmotionPlugin");
        if (!pt)
            return void console.error("Popmotion plugin not found");
        const ht = new three_module.YHV().setFromVector3(ut);
        _e.position.setFromSpherical(ht).add(at),
        _e.positionUpdated(!0);
        const _t = _e.autoLookAtTarget;
        _e.autoLookAtTarget = !0;
        const vt = ht.theta
          , bt = await this.record(async () => pt.animate({
            from: vt,
            to: vt + (c ? -1 : 1) * h * Math.PI / 180,
            duration: 1e3 * o,
            ease: _ ?? EasingFunctions.linear,
            onUpdate: St => {
                ht.theta = St,
                _e.position.setFromSpherical(ht).add(at),
                _e.positionUpdated(!0)
            }
            ,
            onComplete: async () => {
                ht.theta = vt,
                _e.position.setFromSpherical(ht).add(at),
                _e.positionUpdated(!0)
            }
        }).promise);
        return _e.autoLookAtTarget = _t,
        _e.position.copy(ut).add(at),
        _e.positionUpdated(!0),
        _e.setInteractions(!0, CanvasRecorderPlugin.PluginType),
        bt
    }
    _getRecorder(o) {
        if (!this._viewer)
            throw new Error("No viewer");
        if (this._recorders[o])
            return this._recorders[o];
        let c;
        return c = o === "canvas-media" ? new CanvasMediaRecorder(this._viewer.canvas,{
            frameRate: this.videoFrameRate,
            mimeType: this.mimeType
        }) : o === "ffmpeg.js" ? new FFMPEGRecorder(this._viewer.canvas,{
            frameRate: this.videoFrameRate,
            mimeType: this.mimeType
        }) : new ImageSequenceRecorder(this._viewer.canvas,{
            frameRate: this.videoFrameRate,
            mimeType: this.mimeType
        }),
        c.addEventListener("starting", () => this._stateChange(!1)),
        c.addEventListener("recording", () => {
            this._recordIndicator.style.visibility = "visible",
            this._recordIndicator.style.backgroundColor = "red",
            this.dispatchEvent({
                type: "start"
            }),
            this._stateChange(!this.convergeMode)
        }
        ),
        c.addEventListener("error", () => {
            this.dispatchEvent({
                type: "error"
            })
        }
        ),
        c.addEventListener("paused", () => this._stateChange(!1)),
        c.addEventListener("stopped", () => {
            this._recordIndicator.style.visibility = "hidden",
            this.dispatchEvent({
                type: "stop"
            }),
            this._stateChange(!1)
        }
        ),
        c.addEventListener("encode-progress", h => {
            this.dispatchEvent({
                ...h
            })
        }
        ),
        this._recorders[o] = c,
        c
    }
}
function isSafari() {
    return navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome")
}
CanvasRecorderPlugin.PluginType = "CanvasRecorder",
CanvasRecorderPlugin_decorate([x$1(CanvasRecorderPlugin.prototype.refreshRecorderOptions), serialize()], CanvasRecorderPlugin.prototype, "convergeMode", void 0),
CanvasRecorderPlugin_decorate([x$1(CanvasRecorderPlugin.prototype.refreshRecorderOptions), serialize()], CanvasRecorderPlugin.prototype, "mimeType", void 0),
CanvasRecorderPlugin_decorate([x$1(CanvasRecorderPlugin.prototype.refreshRecorderOptions), serialize()], CanvasRecorderPlugin.prototype, "videoFrameRate", void 0),
CanvasRecorderPlugin_decorate([uiSlider("End padding (MS)", [0, 1e3], 1)], CanvasRecorderPlugin.prototype, "endPaddingMs", void 0);
class CanvasSnipper {
    static async GetClonedCanvas(o, {rect: c={
        x: 0,
        y: 0,
        width: o.width,
        height: o.height,
        assumeClientRect: !1,
        normalized: !1
    }, displayPixelRatio: h=1, scale: _=1}) {
        var b, _e, nt;
        c = {
            ...c
        };
        const it = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        c.normalized ? (c.x = Math.floor(c.x * o.width),
        c.y = Math.floor(c.y * o.height),
        c.width = Math.floor(c.width * o.width),
        c.height = Math.floor(c.height * o.height),
        c.assumeClientRect && console.warn("CanvasSnipper: rect.assumeClientRect is ignored when rect is normalized")) : c.assumeClientRect && (c.x = Math.floor(c.x * o.width / (h * o.clientWidth)),
        c.y = Math.floor(c.y * o.height / (h * o.clientHeight)),
        c.width = Math.floor(c.width * o.width / (h * o.clientWidth)),
        c.height = Math.floor(c.height * o.height / (h * o.clientHeight))),
        it.width = Math.floor(c.width * _ * h),
        it.height = Math.floor(c.height * _ * h);
        const at = it.getContext("2d");
        if (!at)
            return console.error("snapshot: cannot create context"),
            it;
        const ut = o.style.background || ((b = o.parentElement) === null || b === void 0 ? void 0 : b.style.background) || "";
        if (ut.includes("url")) {
            const pt = (_e = /url\("(.*)"\)/gi.exec(ut)) === null || _e === void 0 ? void 0 : _e[1];
            if (pt) {
                const ht = new Image;
                ht.src = pt,
                await new Promise( (_t, vt) => {
                    ht.onload = () => _t(),
                    ht.onerror = () => vt(),
                    ht.complete && _t()
                }
                ),
                at.drawImage(ht, Math.floor(ht.width * c.x * h / o.width), Math.floor(ht.height * c.y * h / o.height), Math.floor(ht.width * c.width * h / o.width), Math.floor(ht.height * c.height * h / o.height), 0, 0, it.width, it.height)
            }
        } else
            at.fillStyle = o.style.background || ((nt = o.parentElement) === null || nt === void 0 ? void 0 : nt.style.backgroundColor) || "#00000000",
            at.fillRect(0, 0, it.width, it.height);
        return at == null || at.drawImage(o, Math.floor(c.x * h), Math.floor(c.y * h), Math.floor(c.width * h), Math.floor(c.height * h), 0, 0, it.width, it.height),
        this.Debug && (document.body.appendChild(it),
        it.style.position = "absolute",
        it.style.top = "0",
        it.style.left = "0",
        it.style.borderWidth = "2px",
        it.style.borderColor = "#ff00ff",
        setTimeout( () => it.remove(), 5e3)),
        it
    }
    static async GetDataUrl(o, {mimeType: c="image/png", ...h}) {
        const _ = isSafari() || h.cloneCanvas || h.rect || h.scale || h.displayPixelRatio;
        !_ && (h.rect || h.scale || h.displayPixelRatio) && console.warn("rect, scale and displayPixelRatio are ignored when cloneCanvas is false");
        const b = _ ? await this.GetClonedCanvas(o, h) : o
          , _e = b.toDataURL(c);
        return this.Debug || b === o || b.remove(),
        _e
    }
    static async GetImage(o, {mimeType: c="image/png", ...h}={}) {
        const _ = await this.GetDataUrl(o, h);
        return new Promise( (b, _e) => {
            const nt = new Image;
            nt.onload = () => {
                b(nt)
            }
            ,
            nt.src = _
        }
        )
    }
    static async GetBlob(o, c={}) {
        const h = isSafari() || c.cloneCanvas || c.rect || c.scale || c.displayPixelRatio;
        !h && (c.rect || c.scale || c.displayPixelRatio) && console.warn("rect, scale and displayPixelRatio are ignored when cloneCanvas is false");
        const _ = h ? await this.GetClonedCanvas(o, c) : o
          , b = await new Promise( (_e, nt) => {
            var it;
            _.toBlob(at => {
                at ? _e(at) : nt("Unable to export")
            }
            , (it = c.mimeType) !== null && it !== void 0 ? it : "image/png")
        }
        );
        return this.Debug || _ === o || _.remove(),
        b
    }
    static async GetFile(o, c="image", h={}) {
        var _, b, _e;
        const nt = c + "." + ((b = (_ = h.mimeType) === null || _ === void 0 ? void 0 : _.split("/")[1]) !== null && b !== void 0 ? b : "png");
        return h.getDataUrl ? await this.GetDataUrl(o, h) : new File([await this.GetBlob(o, h)],nt,{
            type: (_e = h.mimeType) !== null && _e !== void 0 ? _e : "image/png",
            lastModified: g()
        })
    }
    static async GetTiledFiles(o, c="image", h=2, _=2, b={}) {
        var _e, nt, it;
        const at = (_e = b.rect) !== null && _e !== void 0 ? _e : {
            x: 0,
            y: 0,
            width: 1,
            height: 1,
            assumeClientRect: !1,
            normalized: !0
        }
          , ut = [];
        for (let pt = 0; pt < _; pt++)
            for (let ht = 0; ht < h; ht++) {
                const _t = (it = (nt = b.mimeType) === null || nt === void 0 ? void 0 : nt.split("/")[1]) !== null && it !== void 0 ? it : "png"
                  , vt = await this.GetFile(o, `${c}_${pt}_${ht}.${_t}`, {
                    rect: {
                        x: at.x + pt * at.width / _,
                        y: at.y + ht * at.height / h,
                        width: at.width / _,
                        height: at.height / h,
                        assumeClientRect: at.assumeClientRect,
                        normalized: at.normalized
                    }
                }).catch(bt => (console.error(`Error exporting file ${pt}, ${ht}`, bt),
                null));
                vt && ut.push(vt)
            }
        return ut
    }
}
CanvasSnipper.Debug = !1;
var CanvasSnipperPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, CanvasSnipperPlugin_1;
let CanvasSnipperPlugin = CanvasSnipperPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this.filename = "snapshot",
        this.progressiveFrames = 64,
        this.tileRows = 1,
        this.tileColumns = 1,
        this.rect = new three_module.IUQ(0,0,1,1),
        this._downloading = !1,
        this.downloadSnapshot = this.downloadSnapshot.bind(this)
    }
    async getFile(d, o={
        waitForProgressive: !0
    }) {
        var c;
        return await ((c = this.viewer) === null || c === void 0 ? void 0 : c.doOnce("postFrame")),
        await this._getFile(d || this.filename, {
            ...o,
            getDataUrl: !1
        })
    }
    async getDataUrl(d={}) {
        var o, c;
        return await ((o = this.viewer) === null || o === void 0 ? void 0 : o.doOnce("postFrame")),
        (c = await this._getFile("", {
            ...d,
            getDataUrl: !0
        })) !== null && c !== void 0 ? c : ""
    }
    async _getFile(d, o={}) {
        var c, h, _, b, _e, nt, it, at, ut, pt, ht, _t;
        const vt = (c = this._viewer) === null || c === void 0 ? void 0 : c.canvas;
        if (vt) {
            (h = this.viewer) === null || h === void 0 || h.scene.activeCamera.setInteractions(!1, CanvasSnipperPlugin_1.PluginType);
            const bt = this._viewer.renderer.displayCanvasScaling;
            o.displayPixelRatio !== void 0 && o.displayPixelRatio !== bt && (this._viewer.renderer.displayCanvasScaling = o.displayPixelRatio);
            const St = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getPlugin(ProgressivePlugin);
            let At = (b = o.waitForProgressive) !== null && b !== void 0 ? b : !!St;
            At && !St && (console.warn("CanvasSnipperPlugin: ProgressivePlugin required to wait for progressive rendering"),
            At = !1),
            o.progressiveFrames && !At && console.warn("CanvasSnipperPlugin: waitForProgressive must be true to use progressiveFrames");
            const Et = St == null ? void 0 : St.maxFrameCount;
            if (At && St)
                for (St.maxFrameCount = Math.max((_e = o.progressiveFrames) !== null && _e !== void 0 ? _e : 64, St.maxFrameCount),
                (nt = this.viewer) === null || nt === void 0 || nt.setDirty(),
                await ((it = this.viewer) === null || it === void 0 ? void 0 : it.doOnce("postFrame")); !St.isConverged(!0); )
                    await ((at = this.viewer) === null || at === void 0 ? void 0 : at.doOnce("postFrame"));
            let Pt;
            if (!o.timeout && At || ((ut = this.viewer) === null || ut === void 0 || ut.setDirty(),
            await ((pt = this.viewer) === null || pt === void 0 ? void 0 : pt.doOnce("postFrame")),
            await X$2((ht = o.timeout) !== null && ht !== void 0 ? ht : 200)),
            o.displayPixelRatio = 1,
            o.tileRows && o.tileRows > 1 || o.tileColumns && o.tileColumns > 1) {
                const It = await CanvasSnipper.GetTiledFiles(vt, d, Math.max(1, o.tileRows || 1), Math.max(1, o.tileColumns || 1), o);
                if (Array.isArray(It))
                    if (It.length === 1)
                        Pt = It[0];
                    else if (It.length === 0)
                        Pt = void 0;
                    else if (o.getDataUrl)
                        Pt = It;
                    else {
                        const Dt = {};
                        for (const Bt of It)
                            Dt[Bt.name] = new Uint8Array(await Bt.arrayBuffer());
                        const Gt = zipSync(Dt);
                        Pt = new File([Gt],d + ".zip",{
                            type: "application/zip",
                            lastModified: Date.now()
                        })
                    }
                else
                    Pt = It
            } else
                Pt = await CanvasSnipper.GetFile(vt, d, o);
            return o.displayPixelRatio = this._viewer.renderer.displayCanvasScaling,
            this._viewer.renderer.displayCanvasScaling = bt,
            St && Et !== void 0 && (St.maxFrameCount = Et),
            (_t = this.viewer) === null || _t === void 0 || _t.scene.activeCamera.setInteractions(!0, CanvasSnipperPlugin_1.PluginType),
            Pt
        }
    }
    async downloadSnapshot(d, o) {
        for (; this._downloading; )
            console.warn("CanvasSnipperPlugin: Another rendering already in progress, waiting..."),
            await X$2(200);
        this._downloading = !0;
        const c = await this.getFile(d, {
            progressiveFrames: this.progressiveFrames,
            waitForProgressive: !0,
            tileRows: this.tileRows,
            tileColumns: this.tileColumns,
            rect: {
                x: this.rect.x,
                y: this.rect.y,
                width: this.rect.z,
                height: this.rect.w,
                normalized: !0,
                assumeClientRect: !1
            },
            ...o
        }).catch(h => {
            var _;
            return (_ = this._viewer) === null || _ === void 0 || _.console.error("Error exporting file", h),
            null
        }
        );
        c && await this._downloadBlob(c, c.name),
        this._downloading = !1
    }
    async _downloadJpeg() {
        return this.downloadSnapshot(void 0, {
            mimeType: "image/jpeg"
        })
    }
    async _downloadWebp() {
        return this.downloadSnapshot(void 0, {
            mimeType: "image/webp"
        })
    }
    async _downloadBlob(d, o) {
        var c, h;
        const _ = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("FileTransferPlugin");
        _ ? await _.exportFile(d, o) : (h = this._viewer) === null || h === void 0 || h.console.error("FileTransferPlugin required to export/download file")
    }
}
;
CanvasSnipperPlugin.PluginType = "CanvasSnipper",
CanvasSnipperPlugin_decorate([uiInput("Filename"), serialize()], CanvasSnipperPlugin.prototype, "filename", void 0),
CanvasSnipperPlugin_decorate([uiInput("Frame Count"), serialize()], CanvasSnipperPlugin.prototype, "progressiveFrames", void 0),
CanvasSnipperPlugin_decorate([uiInput("Tile Rows"), serialize()], CanvasSnipperPlugin.prototype, "tileRows", void 0),
CanvasSnipperPlugin_decorate([uiInput("Tile Columns"), serialize()], CanvasSnipperPlugin.prototype, "tileColumns", void 0),
CanvasSnipperPlugin_decorate([uiVector("Crop Rect (x, y, w, h)", [0, 1], .001), serialize()], CanvasSnipperPlugin.prototype, "rect", void 0),
CanvasSnipperPlugin_decorate([uiButton("Download .png", {
    limitedUi: !0
})], CanvasSnipperPlugin.prototype, "downloadSnapshot", null),
CanvasSnipperPlugin_decorate([uiButton("Download .jpeg")], CanvasSnipperPlugin.prototype, "_downloadJpeg", null),
CanvasSnipperPlugin_decorate([uiButton("Download .webp")], CanvasSnipperPlugin.prototype, "_downloadWebp", null),
CanvasSnipperPlugin = CanvasSnipperPlugin_1 = CanvasSnipperPlugin_decorate([uiFolder("Image Export")], CanvasSnipperPlugin);
const HorizontalBlurShader = {
    name: "HorizontalBlurShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        h: {
            value: 1 / 512
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`
}
  , VerticalBlurShader = {
    name: "VerticalBlurShader",
    uniforms: {
        tDiffuse: {
            value: null
        },
        v: {
            value: 1 / 512
        }
    },
    vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`
};
var ContactShadowGroundPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const horizontalBlurMaterial = new three_module.BKk(HorizontalBlurShader);
horizontalBlurMaterial.depthTest = !1;
const verticalBlurMaterial = new three_module.BKk(VerticalBlurShader);
verticalBlurMaterial.depthTest = !1;
class ContactShadowGroundPlugin extends BaseGroundPlugin {
    constructor(o={}, c=!1) {
        super(o),
        this.contactShadows = !0,
        this.blurAmount = 1,
        this.shadowScale = 1,
        this.shadowHeight = 5,
        this.shadowCamera = new three_module.qUd(-1,1,1,-1,.001,this.shadowHeight),
        this._refreshShadowCameraFrustum = this._refreshShadowCameraFrustum.bind(this),
        this.refreshOptions = this.refreshOptions.bind(this),
        this._showDebug = c,
        c && this.dependencies.push(DebugPlugin)
    }
    async onAdded(o) {
        const c = o.renderer.createTarget({
            type: three_module.OUM,
            format: three_module.GWd,
            colorSpace: three_module.jf0,
            size: {
                width: 512,
                height: 512
            },
            generateMipmaps: !1,
            depthBuffer: !0,
            minFilter: three_module.k6q,
            magFilter: three_module.k6q
        });
        c.texture.name = "groundContactDepthTexture";
        const h = new three_module.CSG({
            depthPacking: three_module.Rkk
        });
        h.onBeforeCompile = function(b) {
            b.uniforms.opacity.value = 1,
            b.fragmentShader = `
						${b.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), 1.0 );")}
					`
        }
        ;
        const _ = new GBufferRenderPass(c,h,new three_module.Q1f(0,0,0),0);
        this._depthPass = _,
        await super.onAdded(o)
    }
    _postFrame() {
        super._postFrame(),
        this._viewer
    }
    _preRender() {
        if (super._preRender(),
        !this._viewer || !this._depthPass)
            return;
        this._depthPass.scene = this._viewer.scene.modelObject,
        this._depthPass.camera = this.shadowCamera,
        this._depthPass.render(this._viewer.renderer.rendererObject, null);
        const o = this._viewer.renderer.getTempTarget({
            type: three_module.OUM,
            format: three_module.GWd,
            colorSpace: three_module.jf0,
            size: {
                width: 1024,
                height: 1024
            },
            generateMipmaps: !1,
            depthBuffer: !1,
            minFilter: three_module.k6q,
            magFilter: three_module.k6q
        });
        this._blurShadow(o),
        this._blurShadow(o, .4),
        this._viewer.renderer.releaseTempTarget(o)
    }
    _blurShadow(o, c=1) {
        this._viewer && this._depthPass && (horizontalBlurMaterial.uniforms.h.value = c * this.blurAmount / 256,
        verticalBlurMaterial.uniforms.v.value = c * this.blurAmount / 256,
        this._viewer.renderer.blit(this._depthPass.target.texture, o, {
            material: horizontalBlurMaterial,
            clear: !0
        }),
        this._viewer.renderer.blit(o.texture, this._depthPass.target, {
            material: verticalBlurMaterial,
            clear: !0
        }))
    }
    async onDispose(o) {
        return super.onDispose(o)
    }
    async onRemove(o) {
        var c, h, _;
        const b = (c = this._depthPass) === null || c === void 0 ? void 0 : c.target;
        return b && ((h = this._viewer) === null || h === void 0 || h.renderer.disposeTarget(b)),
        (_ = this._depthPass) === null || _ === void 0 || _.dispose(),
        this._depthPass = void 0,
        super.onRemove(o)
    }
    _refreshTransform() {
        super._refreshTransform(),
        this._mesh && this._viewer && (this.shadowCamera.position.copy(this._mesh.getWorldPosition(new three_module.Pq0)),
        this.shadowCamera.setRotationFromEuler(new three_module.O9p(Math.PI / 2,0,0)),
        this.shadowCamera.updateMatrixWorld(),
        this._refreshShadowCameraFrustum(),
        this._mesh.scale.y = -this.size)
    }
    _refreshShadowCameraFrustum() {
        this.shadowCamera && (this.shadowCamera.left = -this.size / (2 * this.shadowScale),
        this.shadowCamera.right = this.size / (2 * this.shadowScale),
        this.shadowCamera.top = this.size / (2 * this.shadowScale),
        this.shadowCamera.bottom = -this.size / (2 * this.shadowScale),
        this.shadowCamera.far = this.shadowHeight,
        this.shadowCamera.updateProjectionMatrix(),
        this._setDirty())
    }
    _setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    _removeMaterial() {
        this._material && super._removeMaterial()
    }
    refreshOptions() {
        this._viewer && super.refreshOptions()
    }
    _refreshMaterial() {
        var o;
        if (!this._viewer)
            return !1;
        const c = super._refreshMaterial();
        return this._material && (this._material.alphaMap = ((o = this._depthPass) === null || o === void 0 ? void 0 : o.target.texture) || null,
        c && (this._material.roughness = 1,
        this._material.metalness = 0,
        this._material.color.set(1118481),
        this._material.transparent = !0,
        this._material.materialObject.userData.ssreflDisabled = !0,
        this._material.materialObject.userData.ssreflNonPhysical = !1)),
        c
    }
    _extraUiConfig() {
        return [{
            label: "Contact Shadows",
            type: "checkbox",
            property: [this, "contactShadows"]
        }, {
            label: "Shadow Scale",
            type: "slider",
            bounds: [0, 2],
            property: [this, "shadowScale"]
        }, {
            label: "Shadow Height",
            type: "slider",
            bounds: [0, 20],
            property: [this, "shadowHeight"]
        }, {
            label: "Blur Amount",
            type: "slider",
            bounds: [0, 10],
            property: [this, "blurAmount"]
        }, ...super._extraUiConfig()]
    }
}
function objectBeforeRender(d, o) {
    var c;
    o && (!((c = o.map) === null || c === void 0) && c.isTexture) && (o.extraUniformsToUpload || (o.extraUniformsToUpload = {}),
    o.extraUniformsToUpload.uvTransform || (o.extraUniformsToUpload.uvTransform = {
        value: new three_module.dwI
    }),
    o.extraUniformsToUpload.uvTransform.value.setUvTransform(o.map.offset.x * o.map.repeat.x * d.userData.cloneRotI / (d.userData.rotationCount || 1), o.map.offset.y * o.map.repeat.y * d.userData.cloneRotI / (d.userData.rotationCount || 1), o.map.repeat.x, o.map.repeat.y, o.map.rotation, o.map.center.x, o.map.center.y))
}
function setRotI(d, o, c, h) {
    d.traverse(_ => {
        _ && (_.userData.cloneRotI = o,
        _.userData.rotationCount = c,
        _.userData.rotationAxis = h,
        _.addEventListener("beforeRender", b => objectBeforeRender(_, b.material)))
    }
    )
}
function rotateDuplicatedMesh(d, o, c, h="x") {
    var _;
    if (d.userData.rotationCount > 1 && !d.userData.rotationRoot)
        return d;
    const b = d.parent;
    if (!b)
        throw new Error("No parent");
    if (d.userData.cloneParent) {
        const nt = d.userData.cloneParent;
        if (d = b.children.find(it => nt === it.uuid),
        !d)
            return console.error("Couldn't find clone root, cannot rotate. maybe a serialization issue?", nt, b),
            d
    }
    let _e = b.children.filter(nt => {
        var it;
        return ((it = nt.userData) === null || it === void 0 ? void 0 : it.cloneParent) === d.uuid
    }
    ).sort( (nt, it) => nt.userData.cloneRotI - it.userData.cloneRotI);
    if (d.userData.rotationCount === o && o === _e.length && c === void 0 && d.userData.rotationAxis === h)
        return d;
    if (c == null && (c = (_ = d.userData.rotationSkips) !== null && _ !== void 0 ? _ : []),
    c !== d.userData.rotationSkips && (d.userData.rotationSkips = [...c]),
    setRotI(d, 0, o, h),
    d.userData.rotationRoot = !0,
    d.visible = !0,
    o <= _e.length) {
        for (let nt = o - 1; nt < _e.length; nt++)
            b.remove(_e[nt]),
            _e[nt].traverse(it => it.userData = {
                __disposed: !0
            });
        _e = _e.slice(0, o)
    }
    for (let nt = 1; nt < o; nt++) {
        const it = nt <= _e.length ? _e[nt - 1] : d.clone();
        it.rotation.copy(d.rotation),
        it.rotation[h] += nt / o * Math.PI * 2,
        setRotI(it, nt, o, h),
        nt > _e.length && b.add(it),
        it.visible = !c.includes(nt)
    }
    return d.visible = !c.includes(0),
    d
}
ContactShadowGroundPlugin.PluginType = "ContactShadowGroundPlugin",
ContactShadowGroundPlugin_decorate([x$1(ContactShadowGroundPlugin.prototype.refreshOptions), serialize()], ContactShadowGroundPlugin.prototype, "contactShadows", void 0),
ContactShadowGroundPlugin_decorate([serialize(), x$1(ContactShadowGroundPlugin.prototype._setDirty)], ContactShadowGroundPlugin.prototype, "blurAmount", void 0),
ContactShadowGroundPlugin_decorate([serialize(), x$1(ContactShadowGroundPlugin.prototype._refreshShadowCameraFrustum)], ContactShadowGroundPlugin.prototype, "shadowScale", void 0),
ContactShadowGroundPlugin_decorate([serialize(), x$1(ContactShadowGroundPlugin.prototype._refreshShadowCameraFrustum)], ContactShadowGroundPlugin.prototype, "shadowHeight", void 0);
var ObjectRotationPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ObjectRotationPlugin = class extends AViewerPlugin {
    async onAdded(d) {
        var o;
        await super.onAdded(d),
        (o = d.getPluginByType("Picking")) === null || o === void 0 || o.addEventListener("selectedObjectChanged", this._selectedObjectChanged)
    }
    constructor(d=!0) {
        super(),
        this.rotations = 1,
        this.axis = "x",
        this.skips = "",
        this._selectedObjectChanged = this._selectedObjectChanged.bind(this),
        this.enabled = d
    }
    _selectedObjectChanged() {
        var d, o, c, h, _, b, _e, nt, it;
        if (!this.enabled)
            return;
        const at = (o = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPluginByType("Picking")) === null || o === void 0 ? void 0 : o.getSelectedObject();
        if (!at)
            return void ((h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0));
        const ut = at.userData.rotationRoot && (_ = at.userData.rotationCount) !== null && _ !== void 0 ? _ : 1;
        this.rotations = ut,
        this.skips = (_e = (b = at.userData.rotationSkips) === null || b === void 0 ? void 0 : b.join(",")) !== null && _e !== void 0 ? _e : "",
        this.axis = at.userData.rotationAxis || "x",
        (it = (nt = this.uiConfig).uiRefresh) === null || it === void 0 || it.call(nt, "postFrame", !0)
    }
    _paramsChanged() {
        var d, o, c, h, _, b;
        if (!this.enabled)
            return;
        const _e = (o = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPluginByType("Picking")) === null || o === void 0 ? void 0 : o.getSelectedObject();
        if (_e) {
            if (this.rotations > 1 || _e.userData.rotationCount) {
                const nt = _e.userData.rotationCount
                  , it = rotateDuplicatedMesh(_e, this.rotations, this.skips.split(",").map(ut => parseInt(ut)).filter(ut => isFinite(ut)), this.axis)
                  , at = it == null ? void 0 : it.userData.rotationCount;
                if (at && at !== nt) {
                    const ut = [];
                    it == null || it.traverseAncestors(pt => {
                        ut.push(pt)
                    }
                    );
                    for (const pt of ut)
                        if (pt.userData.autoScaled) {
                            autoScaleObject3D(pt),
                            (c = this._viewer) === null || c === void 0 || c.resetCamera({
                                rootObject: pt,
                                centerOffset: new three_module.Pq0(4,4,4)
                            });
                            break
                        }
                }
                _e.parent && !_e.userData.__disposed || (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPluginByType("Picking")) === null || _ === void 0 || _.setSelectedObject(it, !0)
            }
            (b = this._viewer) === null || b === void 0 || b.scene.setDirty({
                frameFade: !1,
                sceneUpdate: !0
            })
        }
    }
}
;
ObjectRotationPlugin.PluginType = "ObjectRotationPlugin",
ObjectRotationPlugin_decorate([serialize(), uiToggle("Enabled"), x$1(ObjectRotationPlugin.prototype._paramsChanged)], ObjectRotationPlugin.prototype, "enabled", void 0),
ObjectRotationPlugin_decorate([uiSlider("Rotation Count", [1, 100], 1, d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("Picking")) === null || c === void 0) && c.getSelectedObject()) || !d.rotations
    }
})), x$1(ObjectRotationPlugin.prototype._paramsChanged)], ObjectRotationPlugin.prototype, "rotations", void 0),
ObjectRotationPlugin_decorate([uiDropdown("Axis", ["x", "y", "z"].map(d => ({
    label: d
})), d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("Picking")) === null || c === void 0) && c.getSelectedObject()) || !d.rotations
    }
})), x$1(ObjectRotationPlugin.prototype._paramsChanged)], ObjectRotationPlugin.prototype, "axis", void 0),
ObjectRotationPlugin_decorate([uiInput("Rotation Skips", d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("Picking")) === null || c === void 0) && c.getSelectedObject()) || !d.rotations
    }
})), x$1(ObjectRotationPlugin.prototype._paramsChanged)], ObjectRotationPlugin.prototype, "skips", void 0),
ObjectRotationPlugin = ObjectRotationPlugin_decorate([uiFolder("Object Rotations")], ObjectRotationPlugin);
var reliefParallax = `#ifdef USE_BUMPMAP
mat3 mat3_inverse(mat3 A){mat3 M_t=mat3(vec3(A[0][0],A[1][0],A[2][0]),vec3(A[0][1],A[1][1],A[2][1]),vec3(A[0][2],A[1][2],A[2][2]));float det=dot(cross(M_t[0],M_t[1]),M_t[2]);mat3 adjugate=mat3(cross(M_t[1],M_t[2]),cross(M_t[2],M_t[0]),cross(M_t[0],M_t[1]));return adjugate/det;}float CalculateHeight(in vec2 texCoords){float height=texture2D(bumpMap,texCoords).x;return clamp(height,0.,1.);}const vec2 bumpMapSize=vec2(512,512);vec3 CalculateNormal(in vec2 texCoords){
#if defined( TANGENTSPACE_NORMALMAP ) && 0 
vec3 mapN=texture2D(normalMap,texCoords).xyz;mapN.xy*=normalScale;return normalize(mapN);
#else
vec2 texOffs=1./bumpMapSize;
#if PARALLAX_NORMAL_MAP_QUALITY > 0
float hx[9];hx[0]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,-1.)).r;hx[1]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;hx[2]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,-1.)).r;hx[3]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;hx[4]=texture2D(bumpMap,texCoords.st).r;hx[5]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;hx[6]=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,1.)).r;hx[7]=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;hx[8]=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,1.)).r;vec2 deltaH=vec2(hx[0]-hx[2]+2.*(hx[3]-hx[5])+hx[6]-hx[8],hx[0]-hx[6]+2.*(hx[1]-hx[7])+hx[2]-hx[8]);
#else
float h_xa=texture2D(bumpMap,texCoords.st+texOffs*vec2(-1.,0.)).r;float h_xb=texture2D(bumpMap,texCoords.st+texOffs*vec2(1.,0.)).r;float h_ya=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,-1.)).r;float h_yb=texture2D(bumpMap,texCoords.st+texOffs*vec2(0.,1.)).r;vec2 deltaH=vec2(h_xa-h_xb,h_ya-h_yb);
#endif
return normalize(vec3(deltaH/texOffs,1.));
#endif
}vec3 ReliefParallax(in float frontFace,in vec3 texDir3D,in vec2 texCoord){float surf_sign=frontFace;float back_face=step(0.,-surf_sign);vec2 texStep=surf_sign*texDir3D.xy/abs(texDir3D.z);vec2 texC=texCoord.st+surf_sign*texStep+back_face*texStep.xy;float mapHeight=1.;float bumpHeightStep=1./float(PARALLAX_MAP_STEPS);float bestBumpHeight=mapHeight+bumpHeightStep;
#pragma unroll_loop_start
for(int i=0;i<PARALLAX_MAP_STEPS;i++){if(mapHeight<bestBumpHeight){bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);}}
#pragma unroll_loop_end
bestBumpHeight+=bumpHeightStep;
#pragma unroll_loop_start
for(int i=0;i<PARALLAX_MAP_B_STEPS;i++){bumpHeightStep*=0.5;bestBumpHeight-=bumpHeightStep;mapHeight=back_face+surf_sign*CalculateHeight(texC.xy-bestBumpHeight*texStep.xy);bestBumpHeight+=(bestBumpHeight<mapHeight)?bumpHeightStep:0.;}
#pragma unroll_loop_end
bestBumpHeight-=bumpHeightStep*clamp((bestBumpHeight-mapHeight)/bumpHeightStep,0.,1.);mapHeight=bestBumpHeight;texC-=mapHeight*texStep;return vec3(texC.xy,mapHeight);}vec3 reliefParallaxPerturbNormal(in float faceDirection,inout vec3 normal){if(abs(bumpScale)<0.001)return vec3(vBumpMapUv,0.);float parallaxHeight;vec2 texCoords=vBumpMapUv;float face_sign=sign(dot(normal,vViewPosition));vec3 N=normalize(normal);vec3 dp1=dFdx(-vViewPosition);vec3 dp2=dFdy(-vViewPosition);vec2 duv1=dFdx(vBumpMapUv);vec2 duv2=dFdy(vBumpMapUv);vec3 dp2perp=cross(dp2,N);vec3 dp1perp=cross(N,dp1);vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;float invmax=inversesqrt(max(dot(T,T),dot(B,B)));mat3 tbnMat=mat3(T*invmax,B*invmax,N*bumpScale);vec3 tangentPos=normalize(mat3_inverse(tbnMat)*-vViewPosition);vec3 parallaxUv=ReliefParallax(face_sign,tangentPos,vBumpMapUv);tbnMat[2]=face_sign*N/bumpScale;normal=normalize(tbnMat*CalculateNormal(parallaxUv.xy).xyz);
#ifdef FLIP_SIDED
normal=-normal;
#endif
return parallaxUv;}
#endif 
`
  , ParallaxMappingPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ParallaxMappingPlugin = class extends AViewerPlugin {
    constructor(d=!0) {
        super(),
        this.enabled = !0,
        this.debugNormals = !1,
        this.debugHitHeight = !1,
        this._defines = {
            PARALLAX_NORMAL_MAP_QUALITY: 0
        },
        this.stepCount = 12,
        this.binaryStepCount = 3,
        this._bumpMapExtension = {
            shaderExtender: (o, c, h) => {
                if (c.materialObject.bumpMap && this.enabled) {
                    o.fragmentShader = o.fragmentShader.replace("#include <normal_fragment_begin>", ""),
                    o.fragmentShader = o.fragmentShader.replace("#include <normal_fragment_maps>", ""),
                    o.fragmentShader = o.fragmentShader.replace("#include <map_fragment>", `#include <normal_fragment_begin>
#include <normal_fragment_maps>
#include <map_fragment>`);
                    for (const _ of ["map_fragment", "alphamap_fragment", "roughnessmap_fragment", "metalnessmap_fragment", "emissivemap_fragment", "transmission_fragment"])
                        o.fragmentShader = shaderReplaceString(o.fragmentShader, `#include <${_}>`, three_module.vxI[_].replace(/\bv\w+Uv\b/g, "parallaxUv.xy", {
                            replaceAll: !0
                        }));
                    (this.debugNormals || this.debugHitHeight) && (o.fragmentShader = shaderReplaceString(o.fragmentShader, "texture2D( map, parallaxUv.xy )", this.debugNormals ? "vec4(normal, 1.); normal = nonPerturbedNormal" : "vec4(parallaxUv.z,0., 0., 1.)")),
                    o.fragmentShader = shaderReplaceString(o.fragmentShader, "#include <normal_fragment_maps>", shaderReplaceString(shaderReplaceString(three_module.vxI.normal_fragment_maps, "#elif defined( USE_NORMALMAP_TANGENTSPACE )", "#elif defined( USE_NORMALMAP_TANGENTSPACE ) && !defined( USE_BUMPMAP )"), "normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );", "vec3 parallaxUv = reliefParallaxPerturbNormal(faceDirection, normal);"))
                }
            }
            ,
            parsFragmentSnippet: () => this.enabled ? (reliefParallax + `
`).replaceAll("PARALLAX_MAP_STEPS", this._defines.PARALLAX_MAP_STEPS).replaceAll("PARALLAX_MAP_B_STEPS", this._defines.PARALLAX_MAP_B_STEPS) : "",
            isCompatible: o => o.isMeshStandardMaterial2,
            computeCacheKey: o => {
                var c;
                return this.enabled + " " + ((c = o.materialObject.bumpMap) === null || c === void 0 ? void 0 : c.uuid) + " " + this.debugNormals + " " + this.debugHitHeight + "  "
            }
            ,
            onObjectRender: (o, {materialObject: c}, h) => {
                if (this.enabled)
                    for (const [_,b] of Object.entries(this._defines)) {
                        const _e = typeof b == "number" ? b : b ? 1 : 0;
                        c.defines[_] !== _e && (c.defines[_] = _e,
                        c.needsUpdate = !0)
                    }
            }
        },
        this.dependencies = [AssetManagerPlugin],
        this.enabled = d,
        this._updateExtension = this._updateExtension.bind(this)
    }
    _updateExtension() {
        var d, o, c;
        (o = (d = this._bumpMapExtension) === null || d === void 0 ? void 0 : d.setDirty) === null || o === void 0 || o.call(d),
        (c = this._viewer) === null || c === void 0 || c.setDirty()
    }
    async onAdded(d) {
        var o, c;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.registerMaterialExtension(this._bumpMapExtension),
        super.onAdded(d)
    }
    async onRemove(d) {
        var o, c;
        return (c = (o = d.getPlugin(AssetManagerPlugin)) === null || o === void 0 ? void 0 : o.materials) === null || c === void 0 || c.unregisterMaterialExtension(this._bumpMapExtension),
        super.onRemove(d)
    }
}
;
ParallaxMappingPlugin.PluginType = "ReliefParallaxMapping",
ParallaxMappingPlugin_decorate([x$1(ParallaxMappingPlugin.prototype._updateExtension), serialize(), uiToggle("Enabled")], ParallaxMappingPlugin.prototype, "enabled", void 0),
ParallaxMappingPlugin_decorate([x$1(ParallaxMappingPlugin.prototype._updateExtension), uiToggle("Debug Normals")], ParallaxMappingPlugin.prototype, "debugNormals", void 0),
ParallaxMappingPlugin_decorate([x$1(ParallaxMappingPlugin.prototype._updateExtension), uiToggle("Debug Hit Height")], ParallaxMappingPlugin.prototype, "debugHitHeight", void 0),
ParallaxMappingPlugin_decorate([matDefine("PARALLAX_MAP_STEPS", void 0, !0, ParallaxMappingPlugin.prototype._updateExtension), uiSlider("Step count", [1, 32], 1), serialize()], ParallaxMappingPlugin.prototype, "stepCount", void 0),
ParallaxMappingPlugin_decorate([matDefine("PARALLAX_MAP_B_STEPS", void 0, !0, ParallaxMappingPlugin.prototype._updateExtension), uiSlider("Binary search steps", [1, 8], 1), serialize()], ParallaxMappingPlugin.prototype, "binaryStepCount", void 0),
ParallaxMappingPlugin = ParallaxMappingPlugin_decorate([uiFolder("Parallax Mapping")], ParallaxMappingPlugin);
class TubeShapeGeometry extends three_module.LoY {
    constructor(o, c, h=32, _=64, b=!1, _e=new three_module.I9Y(1,1), nt="shape") {
        super(),
        this.type = "TubeShapeGeometry",
        this.parameters = {
            path: c,
            shape: o,
            shapeSegments: h,
            tubularSegments: _,
            closed: b,
            primary: nt,
            shapeScale: _e.clone()
        };
        const it = c.computeFrenetFrames(_, b);
        this.frames = it;
        const at = new three_module.Pq0
          , ut = new three_module.Pq0
          , pt = new three_module.Pq0
          , ht = new three_module.I9Y;
        let _t = new three_module.Pq0;
        const vt = []
          , bt = []
          , St = []
          , At = o.getSpacedPoints(h);
        for (const It of At)
            It.multiply(_e);
        (function() {
            for (let It = 0; It < _; It++)
                Pt(It);
            Pt(b === !1 ? _ : 0),
            function() {
                for (let It = 0; It <= _; It++)
                    for (let Dt = 0; Dt <= h; Dt++)
                        ht.x = It / _,
                        ht.y = Dt / h,
                        bt.push(ht.x, ht.y)
            }(),
            function() {
                const It = nt === "shape"
                  , Dt = It ? h : _
                  , Gt = It ? _ : h;
                for (let Bt = 1; Bt <= Dt; Bt++)
                    for (let kt = 1; kt <= Gt; kt++) {
                        const [Ut,Ht] = It ? [kt, Bt] : [Bt, kt]
                          , Kt = (h + 1) * (Ut - 1) + (Ht - 1)
                          , Jt = (h + 1) * Ut + (Ht - 1)
                          , or = (h + 1) * Ut + Ht
                          , ir = (h + 1) * (Ut - 1) + Ht;
                        St.push(Kt, Jt, ir),
                        St.push(Jt, or, ir)
                    }
            }()
        }
        )(),
        this.setIndex(St),
        this.setAttribute("position", new three_module.qtW(vt,3)),
        this.setAttribute("uv", new three_module.qtW(bt,2)),
        this.computeVertexNormals();
        const Et = this.attributes.normal;
        function Pt(It) {
            _t = c.getPointAt(It / _, _t);
            const Dt = it.normals[It]
              , Gt = it.binormals[It];
            for (let Bt = 0; Bt <= h; Bt++) {
                const kt = At[Bt % h];
                ut.set(0, 0, 0).addScaledVector(Dt, kt.x).addScaledVector(Gt, kt.y),
                at.copy(_t).add(ut),
                vt.push(at.x, at.y, at.z)
            }
        }
        (function() {
            for (let Dt = 1; Dt < h; Dt++) {
                const Gt = Dt + _ * (h + 1);
                ut.fromBufferAttribute(Et, Dt),
                pt.fromBufferAttribute(Et, Gt),
                ut.add(pt).normalize(),
                Et.setXYZ(Dt, ut.x, ut.y, ut.z),
                Et.setXYZ(Gt, ut.x, ut.y, ut.z)
            }
            for (let Dt = 1; Dt < _; Dt++) {
                const Gt = Dt * (h + 1)
                  , Bt = Gt + h;
                ut.fromBufferAttribute(Et, Gt),
                pt.fromBufferAttribute(Et, Bt),
                ut.add(pt).normalize(),
                Et.setXYZ(Gt, ut.x, ut.y, ut.z),
                Et.setXYZ(Bt, ut.x, ut.y, ut.z)
            }
            ut.fromBufferAttribute(Et, 0),
            pt.fromBufferAttribute(Et, h),
            ut.add(pt);
            const It = _ * (h + 1);
            pt.fromBufferAttribute(Et, It),
            ut.add(pt),
            pt.fromBufferAttribute(Et, It + h),
            ut.add(pt),
            ut.normalize(),
            Et.setXYZ(0, ut.x, ut.y, ut.z),
            Et.setXYZ(h, ut.x, ut.y, ut.z),
            Et.setXYZ(It, ut.x, ut.y, ut.z),
            Et.setXYZ(It + h, ut.x, ut.y, ut.z),
            Et.needsUpdate = !0
        }
        )()
    }
    createSplits(o) {
        this.clearGroups();
        const c = this.parameters.primary === "shape" ? this.parameters.shapeSegments : this.parameters.tubularSegments
          , h = this.index.count
          , _ = [...o, 1].sort( (nt, it) => nt - it);
        let b = 0
          , _e = 0;
        for (const nt of _) {
            const it = Math.round(c * nt) * h / c;
            this.addGroup(b, it - b, _e++),
            b = it
        }
        return this.groups.length
    }
    toJSON() {
        const o = super.toJSON();
        return o.path = this.parameters.path.toJSON(),
        o.shape = this.parameters.shape.toJSON(),
        o
    }
}
var ShapeTubeExtrudePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, ShapeTubeExtrudePlugin_1;
let ShapeTubeExtrudePlugin = ShapeTubeExtrudePlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.shapeSegments = 32,
        this.tubularSegments = 32,
        this.shapeScale = new three_module.I9Y(1,1),
        this.materialSplits = "0.3, 0.6",
        this.horizontalSplits = !0,
        this.extrudeCirceTube = async () => {
            var d, o;
            const c = (o = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPlugin(PickingPlugin)) === null || o === void 0 ? void 0 : o.getSelectedObject();
            if (!c)
                return;
            let h = this._viewer.prompt("Radius: Radius for the circle", "1", !0);
            if (!h)
                return;
            h = parseFloat(h);
            const _ = new EllipseCurve3D(0,0,h,h,0,2 * Math.PI,!0,0);
            await this.extrudeObject(c, _)
        }
    }
    async onAdded(d) {
        await super.onAdded(d)
    }
    static CreateCurve(d, o) {
        var c, h;
        if (d === "circle")
            return new EllipseCurve3D(0,0,(c = o.radius) !== null && c !== void 0 ? c : 1,(h = o.radius) !== null && h !== void 0 ? h : 1,0,2 * Math.PI,!0,0);
        throw new Error("Unknown curve type")
    }
    async extrudeObject(d, o, c=this.shapeSegments, h=this.tubularSegments, _=this.shapeScale, b=this.materialSplits.split(",").map(nt => parseFloat(nt.trim())), _e=this.horizontalSplits) {
        var nt, it, at, ut, pt, ht, _t, vt;
        if (d.userData.isExtrudedTube,
        d.userData._extrudeSource) {
            const It = d.userData._extrudeSource;
            if (d = (nt = d.parent) === null || nt === void 0 ? void 0 : nt.children.find(Dt => It === Dt.uuid),
            !d)
                return void console.warn("Could not find extrude source with uuid", It)
        }
        if (d.userData.extrudedObject) {
            const It = d.userData.extrudedObject
              , Dt = (it = d.parent) === null || it === void 0 ? void 0 : it.children.find(Gt => It === Gt.uuid);
            Dt && (Dt.removeFromParent(),
            Dt.geometry.dispose(),
            Dt.geometry = null,
            Dt.material = null),
            delete d.userData.extrudedObject
        }
        const bt = d.geometry;
        if (!bt)
            return void ((at = this._viewer) === null || at === void 0 || at.alert("Extrude: No geometry to extrude"));
        const St = [d.material];
        let At;
        try {
            const It = ShapeTubeExtrudePlugin_1.ConvertGeometryToFlatShape(bt);
            At = new TubeShapeGeometry(It,o,c,h,!0,_,_e ? "shape" : "path"),
            At.computeBoundingBox(),
            At.createSplits(b)
        } catch (It) {
            return void ((ut = this._viewer) === null || ut === void 0 || ut.alert(typeof It == "string" ? It : It == null ? void 0 : It.message))
        }
        St[0].color.set(16777215);
        for (let It = St.length; It < At.groups.length; It++) {
            const Dt = St[0].clone();
            St.push(Dt),
            Dt.color.set(16777215 * Math.random())
        }
        const Et = new three_module.eaF(At,St);
        Et.userData._extrudeSource = d.uuid,
        Et.userData.isExtrudedTube = !0,
        d.visible = !1,
        d.userData.bboxVisible = !1,
        Et.name = d.name + "_extruded";
        const Pt = await ((_t = (ht = (pt = this._viewer) === null || pt === void 0 ? void 0 : pt.getManager()) === null || ht === void 0 ? void 0 : ht.importer) === null || _t === void 0 ? void 0 : _t.processImportedSingle(Et, {
            autoCenter: !1,
            autoScale: !1
        }));
        Pt && ((vt = d.parent) === null || vt === void 0 || vt.add(Pt.modelObject),
        d.userData.extrudedObject = Pt.modelObject.uuid,
        Pt.dispatchEvent({
            type: "select",
            ui: !0,
            value: Pt
        }))
    }
    static ExtrudeShape(d, o, c, h, _, b, _e, nt) {
        const it = new TubeShapeGeometry(d,h,o,c,!0,new three_module.I9Y(_,b),nt ? "shape" : "path");
        it.computeBoundingBox(),
        it.createSplits(_e);
        const at = new three_module.eaF(it,[]);
        return at.userData.isExtrudedTube = !0,
        at
    }
    static ConvertGeometryToFlatShape(d, o=!0) {
        if (d.userData.__planarShape)
            return d.userData.__planarShape;
        let c = d.attributes.position;
        if (!c)
            throw "no position attribute";
        if (c.count > 500)
            throw "too large to extrude";
        const h = d;
        c = h.attributes.position,
        h.boundingBox || h.computeBoundingBox();
        const _ = h.boundingBox.getSize(new three_module.Pq0)
          , b = _.x < .001 ? "x" : _.y < .001 ? "y" : _.z < .001 ? "z" : null;
        if (!b)
            throw "geometry is not axis aligned not planar";
        let _e = [];
        for (let it = 0; it < c.count; it++) {
            const at = new three_module.I9Y;
            b === "x" ? at.set(c.getY(it), c.getZ(it)) : b === "y" ? at.set(c.getX(it), c.getZ(it)) : at.set(c.getX(it), c.getY(it)),
            _e.push(at)
        }
        if (o) {
            let it = 0;
            for (let at = 0; at < _e.length; at++)
                (_e[at].x < _e[it].x || _e[at].x === _e[it].x && _e[at].y < _e[it].y) && (it = at);
            it !== 0 && (_e = _e.slice(it).concat(_e.slice(0, it)))
        }
        const nt = new three_module.ypk(_e);
        return d.userData.__planarShape = nt,
        nt
    }
}
;
ShapeTubeExtrudePlugin.PluginType = "ShapeTubeExtrudePlugin",
ShapeTubeExtrudePlugin_decorate([uiToggle("Enabled")], ShapeTubeExtrudePlugin.prototype, "enabled", void 0),
ShapeTubeExtrudePlugin_decorate([uiSlider("Shape Segments (X)", [1, 100], 1, d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0) && c.getSelectedObject())
    }
}))], ShapeTubeExtrudePlugin.prototype, "shapeSegments", void 0),
ShapeTubeExtrudePlugin_decorate([uiSlider("Tube Segments (Y)", [1, 100], 1, d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0) && c.getSelectedObject())
    }
}))], ShapeTubeExtrudePlugin.prototype, "tubularSegments", void 0),
ShapeTubeExtrudePlugin_decorate([uiVector("Shape scale", [.01, 10], .01, d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0) && c.getSelectedObject())
    }
}))], ShapeTubeExtrudePlugin.prototype, "shapeScale", void 0),
ShapeTubeExtrudePlugin_decorate([uiInput("Material Splits", d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0) && c.getSelectedObject())
    }
}))], ShapeTubeExtrudePlugin.prototype, "materialSplits", void 0),
ShapeTubeExtrudePlugin_decorate([uiToggle("Horizontal Splits", d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0) && c.getSelectedObject())
    }
}))], ShapeTubeExtrudePlugin.prototype, "horizontalSplits", void 0),
ShapeTubeExtrudePlugin_decorate([uiButton("Extrude Circle Tube", d => ({
    hidden: () => {
        var o, c;
        return !(!((c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0) && c.getSelectedObject())
    }
}))], ShapeTubeExtrudePlugin.prototype, "extrudeCirceTube", void 0),
ShapeTubeExtrudePlugin = ShapeTubeExtrudePlugin_1 = ShapeTubeExtrudePlugin_decorate([uiFolder("Extrude Tube Shapes")], ShapeTubeExtrudePlugin);
class EllipseCurve3D extends three_module.S20 {
    getPoint(o, c) {
        return super.getPoint(o, c || new three_module.Pq0)
    }
}
class PopmotionPlugin extends AViewerPlugin {
    constructor(o=!0) {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.fromJSON = void 0,
        this._lastFrameTime = 0,
        this._updaters = [],
        this.dependencies = [],
        this._fadeDisabled = !1,
        this.disableFrameFade = !0,
        this._postFrame = () => {
            var c, h;
            if (!this._viewer)
                return;
            if (!this.enabled || Object.keys(this.animations).length < 1)
                return this._lastFrameTime = 0,
                void (this._fadeDisabled && ((c = this._viewer.getPluginByType("FrameFade")) === null || c === void 0 || c.enable(PopmotionPlugin.PluginType),
                this._fadeDisabled = !1));
            const _ = g() / 1e3;
            this._lastFrameTime < 1 && (this._lastFrameTime = _ - 1 / 60);
            let b = _ - this._lastFrameTime;
            this._lastFrameTime = _;
            const _e = (h = this._viewer.getPluginByType("Progressive")) === null || h === void 0 ? void 0 : h.postFrameConvergedRecordingDelta();
            if (_e && _e > 0 && (b = _e),
            _e !== 0 && (b *= 1e3,
            !(b <= .001) && (this._updaters.forEach(nt => {
                let it = b;
                nt.time + it < 0 && (it = -nt.time),
                nt.time += it,
                Math.abs(it) > .001 && nt.u(it)
            }
            ),
            !this._fadeDisabled && this.disableFrameFade))) {
                const nt = this._viewer.getPluginByType("FrameFade");
                nt && (nt.disable(PopmotionPlugin.PluginType),
                this._fadeDisabled = !0)
            }
        }
        ,
        this.defaultDriver = c => ({
            start: () => this._updaters.push({
                u: c,
                time: 0
            }),
            stop: () => this._updaters.splice(this._updaters.findIndex(h => h.u === c), 1)
        }),
        this.animations = {},
        this.enabled = o,
        this._postFrame = this._postFrame.bind(this)
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.addEventListener("postFrame", this._postFrame)
    }
    async onRemove(o) {
        return o.removeEventListener("postFrame", this._postFrame),
        super.onRemove(o)
    }
    animate(o) {
        const c = esm_browser_v4()
          , h = {
            id: c,
            options: o,
            stop: () => {
                var _, b, _e;
                !((_ = this.animations[c]) === null || _ === void 0) && _._stop ? (_e = (b = this.animations[c]) === null || b === void 0 ? void 0 : b._stop) === null || _e === void 0 || _e.call(b) : console.warn("Animation not started")
            }
        };
        return this.animations[c] = h,
        h.promise = new Promise( (_, b) => {
            const _e = {
                driver: this.defaultDriver,
                ...o,
                onComplete: async () => {
                    var it;
                    try {
                        await ((it = o.onComplete) === null || it === void 0 ? void 0 : it.call(o))
                    } catch (at) {
                        return void b(at)
                    }
                    _()
                }
                ,
                onStop: async () => {
                    var it;
                    try {
                        await ((it = o.onStop) === null || it === void 0 ? void 0 : it.call(o))
                    } catch (at) {
                        return void b(at)
                    }
                    _()
                }
            }
              , nt = animate(_e);
            this.animations[c]._stop = nt.stop,
            this.animations[c].options = _e
        }
        ).then( () => (delete this.animations[c],
        c)),
        this.animations[c]
    }
    async animateAsync(o) {
        return this.animate(o).promise
    }
}
PopmotionPlugin.PluginType = "PopmotionPlugin";
var SimpleTextPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, TextSVGOptions_1, SimpleTextPlugin_1;
const onOpsChange = d => ({
    onChange: o => {
        o.last && d.onChange()
    }
});
let TextSVGOptions = TextSVGOptions_1 = class {
    constructor() {
        this.text = "Custom Text",
        this.fontSize = 100,
        this.width = 1024,
        this.height = 1024,
        this.xOffset = 0,
        this.yOffset = 0,
        this.boxWidth = 1024,
        this.boxHeight = 1024,
        this.textAnchor = "middle",
        this.fontFamily = "",
        this.fontPath = "",
        this.maskText = !1,
        this.innerShadow = !1,
        this.textColor = "#000000",
        this.bgFillColor = "#ffffff",
        this.svgBackground = "#ffffff",
        this.onChange = () => {}
    }
    set(d) {
        Object.assign(this, d)
    }
    reset() {
        const d = this.onChange;
        Object.assign(this, new TextSVGOptions_1),
        this.onChange = d
    }
    toJSON() {
        return {
            text: this.text,
            fontFamily: this.fontFamily,
            fontPath: this.fontPath,
            svgBackground: this.svgBackground,
            width: this.width,
            height: this.height,
            xOffset: this.xOffset,
            yOffset: this.yOffset,
            boxWidth: this.boxWidth,
            boxHeight: this.boxHeight,
            fontSize: this.fontSize,
            maskText: this.maskText,
            innerShadow: this.innerShadow,
            bgFillColor: this.bgFillColor,
            textColor: this.textColor,
            textAnchor: this.textAnchor
        }
    }
}
;
SimpleTextPlugin_decorate([uiInput("Text", onOpsChange)], TextSVGOptions.prototype, "text", void 0),
SimpleTextPlugin_decorate([uiSlider("Font Size", [2, 400], 1, onOpsChange)], TextSVGOptions.prototype, "fontSize", void 0),
SimpleTextPlugin_decorate([uiSlider("Width", [2, 4096], 1, onOpsChange)], TextSVGOptions.prototype, "width", void 0),
SimpleTextPlugin_decorate([uiSlider("Height", [2, 4096], 1, onOpsChange)], TextSVGOptions.prototype, "height", void 0),
SimpleTextPlugin_decorate([uiSlider("X Offset", [-1024, 1024], 1, onOpsChange)], TextSVGOptions.prototype, "xOffset", void 0),
SimpleTextPlugin_decorate([uiSlider("Y Offset", [-1024, 1024], 1, onOpsChange)], TextSVGOptions.prototype, "yOffset", void 0),
SimpleTextPlugin_decorate([uiSlider("V-Width", [2, 4096], 1, onOpsChange)], TextSVGOptions.prototype, "boxWidth", void 0),
SimpleTextPlugin_decorate([uiSlider("V-Height", [2, 4096], 1, onOpsChange)], TextSVGOptions.prototype, "boxHeight", void 0),
SimpleTextPlugin_decorate([uiDropdown("Text Anchor", ["start", "middle", "end"].map(d => ({
    label: d
})), onOpsChange)], TextSVGOptions.prototype, "textAnchor", void 0),
SimpleTextPlugin_decorate([uiInput("Font", onOpsChange)], TextSVGOptions.prototype, "fontFamily", void 0),
SimpleTextPlugin_decorate([uiInput("Font Url", onOpsChange)], TextSVGOptions.prototype, "fontPath", void 0),
SimpleTextPlugin_decorate([uiToggle("Mask Text", onOpsChange)], TextSVGOptions.prototype, "maskText", void 0),
SimpleTextPlugin_decorate([uiToggle("Inner Shadow", onOpsChange)], TextSVGOptions.prototype, "innerShadow", void 0),
SimpleTextPlugin_decorate([uiColor("Text Color", onOpsChange)], TextSVGOptions.prototype, "textColor", void 0),
SimpleTextPlugin_decorate([uiColor("BG Fill", onOpsChange)], TextSVGOptions.prototype, "bgFillColor", void 0),
SimpleTextPlugin_decorate([uiColor("SVG BG", onOpsChange)], TextSVGOptions.prototype, "svgBackground", void 0),
TextSVGOptions = TextSVGOptions_1 = SimpleTextPlugin_decorate([uiFolder("Text SVG Options")], TextSVGOptions);
const fontFormatExtensionMap = {
    woff: "woff",
    woff2: "woff2",
    ttf: "truetype",
    otf: "opentype",
    eot: "embedded-opentype"
}
  , inputHiddenParams = d => ({
    hidden: () => {
        const o = d.getSelected();
        return !o || !o.userData[SimpleTextPlugin.PluginType]
    }
});
let SimpleTextPlugin = SimpleTextPlugin_1 = class extends AViewerPlugin {
    async onAdded(d) {
        var o;
        await super.onAdded(d),
        (o = d.getPluginByType("Picking")) === null || o === void 0 || o.addEventListener("selectedObjectChanged", this._selectedObjectChanged)
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.getSelected = () => {
            var d, o;
            return (o = (d = this._viewer) === null || d === void 0 ? void 0 : d.getPluginByType("Picking")) === null || o === void 0 ? void 0 : o.getSelectedObject()
        }
        ,
        this.options = new TextSVGOptions,
        this.applyToMap = !0,
        this.applyToBumpMap = !1,
        this.applyToAlphaMap = !0,
        this.inverseAlphaMap = !1,
        this._lastMeta = void 0,
        this.fonts = {
            roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2"
        },
        this._assetLoadOptions = void 0,
        this._selectedObjectChanged = this._selectedObjectChanged.bind(this),
        this.addTextToSelected = this.addTextToSelected.bind(this),
        this._paramsChanged = this._paramsChanged.bind(this),
        this.options.onChange = this._paramsChanged
    }
    _selectedObjectChanged() {
        var d, o, c, h, _, b;
        if (!this.enabled)
            return;
        const _e = this.getSelected();
        if (!_e)
            return void ((o = (d = this.uiConfig).uiRefresh) === null || o === void 0 || o.call(d, "postFrame", !0));
        const nt = _e.userData[SimpleTextPlugin_1.PluginType];
        if (!nt)
            return this.options.reset(),
            this._lastMeta = void 0,
            void ((h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0));
        this._lastMeta !== nt && (this.options.set(nt),
        this._lastMeta = nt),
        (b = (_ = this.uiConfig).uiRefresh) === null || b === void 0 || b.call(_, "postFrame", !0)
    }
    _paramsChanged() {
        if (!this.enabled)
            return;
        const d = this.getSelected();
        d && d.isMesh && d.userData[SimpleTextPlugin_1.PluginType] && this.updateText(d, this.options.toJSON())
    }
    async addTextToSelected() {
        var d;
        const o = this.getSelected();
        o && o.isMesh ? o.material ? (o.userData[SimpleTextPlugin_1.PluginType] || !o.material.map || await ((d = this._viewer) === null || d === void 0 ? void 0 : d.confirm("Add Text: This mesh already has a texture. Adding text will replace the texture. Continue?"))) && await this.addText(o) : console.error("no material on mesh") : console.error("no mesh is selected")
    }
    async addText(d, o) {
        return this.updateText(d, Object.assign(this.options.toJSON(), o))
    }
    async updateText(d, o) {
        var c, h;
        if (!d.isMesh)
            return;
        if (!d.material)
            return void console.error("updateText: no material on mesh");
        let _ = d.userData[SimpleTextPlugin_1.PluginType];
        _ || (d.userData[SimpleTextPlugin_1.PluginType] = _ = {}),
        Object.assign(_, o);
        const b = d.material;
        b.map && (b.map._isSimpleTextTexture && b.map.dispose(),
        b.map = void 0),
        b.alphaMap && (b.alphaMap._isSimpleTextTexture && b.alphaMap.dispose(),
        b.alphaMap = void 0),
        b.bumpMap && (b.bumpMap._isSimpleTextTexture && b.bumpMap.dispose(),
        b.bumpMap = void 0);
        const _e = await this.makeTextSvg(_);
        this.applyToMap && (b.map = _e),
        this.applyToAlphaMap && (b.alphaMap = _e,
        b.transparent = !0),
        this.applyToBumpMap && (b.bumpMap = _e),
        b.userData.inverseAlphaMap = this.inverseAlphaMap,
        b.setDirty(),
        b.needsUpdate = !0,
        (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
    }
    async makeTextSvg(d) {
        const o = d.fontFamily || "Arial"
          , c = d.fontPath || this.fonts[o] || "";
        let h = d.style;
        if (c.length > 0) {
            const _e = c.split("?")[0].split(".").pop() || "woff";
            h += `
` + (c.length > 0 ? `
            @font-face {
                font-family: ${o};
                src: url(${c}) format(${fontFormatExtensionMap[_e] || _e});
            }` : "")
        }
        let _ = buildTextSvg({
            ...d,
            fontFamily: o,
            style: h
        });
        _ = await Ze$1(_, async _e => this._getAssetData(_e)),
        _ = B$2(_);
        const b = await this._viewer.getManager().importer.importSinglePath(_, {
            generateMipmaps: !1,
            minFilter: three_module.k6q
        });
        return b._isSimpleTextTexture = !0,
        b.flipY = !1,
        b.needsUpdate = !0,
        b
    }
    async _getAssetData(d) {
        var o, c;
        if (d.startsWith("http://www.w3.org"))
            return d;
        const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getManager()) === null || c === void 0 ? void 0 : c.importer;
        if (!h)
            throw new Error("no importer");
        this._assetLoadOptions = this._assetLoadOptions || {
            fileHandler: new DataUrlLoader(h.loadingManager),
            processImported: !1
        };
        try {
            return await h.importPath(d, this._assetLoadOptions)
        } catch (_) {
            return console.error(_),
            ""
        }
    }
}
;
function buildTextSvg({text: d="Custom Text", svgBackground: o="#ffffff", xOffset: c=0, yOffset: h=0, width: _=1024, height: b=1024, boxWidth: _e=1024, boxHeight: nt=1024, fontFamily: it="", fontSize: at=32, maskText: ut=!0, innerShadow: pt=!0, bgFillColor: ht="#000000", textColor: _t="#ffffff", textAnchor: vt="middle", style: bt=""}) {
    return `
<svg style="background-color:${o}" width="${_}" height="${b}" viewBox="0 0 ${_e} ${nt}"
 xmlns="http://www.w3.org/2000/svg"
 xmlns:xlink="http://www.w3.org/1999/xlink">
     <defs>
        <style>
        ${bt}
        </style>
    </defs>

    <g style="overflow:hidden; text-anchor: ${vt}; font-size: ${at}px; font-family: ${it || "Arial"}">
        <defs>

` + (ut ? `
<mask id="textMask">
<text style="fill:white; font-size: ${at}px;" x="${c + _e / 2}" y="${nt / 2 + h + at / 4}" > ${d} </text>
</mask>
` : "") + `

` + (pt ? `
<filter id="innerShadow" x="-20%" y="-20%" width="140%" height="140%">
<feGaussianBlur in="SourceGraphic" stdDeviation="0.5" result="blur"/>
<feOffset in="blur" dx="1.5" dy="1.5"/>
</filter>
` : "") + `

        </defs>

` + (ut ? `
        <g mask="url(#textMask)">
` : "") + `

        <rect x="0" y="0" width="${_e}" height="${nt}" style="fill:${ht}"/>
        <text style="${pt ? "filter: url(#innerShadow);" : ""} fill:${_t};" x="${c + _e / 2}" y="${nt / 2 + h + at / 4}"> ${d} </text>

` + (ut ? `
        </g>
` : "") + `

    </g>
</svg>
`
}
SimpleTextPlugin.PluginType = "SimpleTextPlugin",
SimpleTextPlugin_decorate([uiConfig(void 0, {
    params: inputHiddenParams
})], SimpleTextPlugin.prototype, "options", void 0),
SimpleTextPlugin_decorate([uiToggle("Apply Map", inputHiddenParams), x$1(SimpleTextPlugin.prototype._paramsChanged), serialize()], SimpleTextPlugin.prototype, "applyToMap", void 0),
SimpleTextPlugin_decorate([uiToggle("Apply Bump Map", inputHiddenParams), x$1(SimpleTextPlugin.prototype._paramsChanged), serialize()], SimpleTextPlugin.prototype, "applyToBumpMap", void 0),
SimpleTextPlugin_decorate([uiToggle("Apply Alpha Map", inputHiddenParams), x$1(SimpleTextPlugin.prototype._paramsChanged), serialize()], SimpleTextPlugin.prototype, "applyToAlphaMap", void 0),
SimpleTextPlugin_decorate([uiToggle("Invert Alpha Map", inputHiddenParams), x$1(SimpleTextPlugin.prototype._paramsChanged), serialize()], SimpleTextPlugin.prototype, "inverseAlphaMap", void 0),
SimpleTextPlugin_decorate([uiButton("Add Text", d => ({
    hidden: () => !d.getSelected()
}))], SimpleTextPlugin.prototype, "addTextToSelected", null),
SimpleTextPlugin = SimpleTextPlugin_1 = SimpleTextPlugin_decorate([uiFolder("Simple Text")], SimpleTextPlugin);
var SceneLoopPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let SceneLoopPlugin = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this.dependencies = [AssetManagerPlugin],
        this.scenes = [],
        this.assets = {},
        this.toJSON = void 0,
        this._isPlaying = !1,
        this._isPlayingLoop = !1,
        this._options = {},
        this.minSceneTime = 2e3,
        this.loadScenes = this.loadScenes.bind(this),
        this.play = this.play.bind(this),
        this.stop = this.stop.bind(this),
        this.downloadScenes = this.downloadScenes.bind(this),
        this.promptLoadScenes = this.promptLoadScenes.bind(this)
    }
    get loadedScenes() {
        return this.scenes.length
    }
    async promptLoadScenes() {
        const d = await ge$1(!0, !1, "model/gltf");
        await this.loadScenes(d)
    }
    async loadScenes(d) {
        var o, c;
        const h = await Promise.all(d.map(async _ => await _.arrayBuffer()));
        for (let _ = 0; _ < d.length; _++) {
            const b = d[_];
            this.scenes.push({
                [b.name]: new Uint8Array(h[_])
            }),
            this.assets[b.name] = {
                path: b.name,
                file: b
            }
        }
        (c = (o = this.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o)
    }
    async play() {
        var d, o;
        if (!this._viewer || this._isPlaying || this._isPlayingLoop)
            return;
        this._isPlaying = !0,
        this._isPlayingLoop = !0;
        const c = (d = this._viewer.getPluginByType("AssetManagerBasicPopupPlugin")) !== null && d !== void 0 ? d : this._viewer.getPluginByType("LoadingScreenPlugin");
        c == null || c.enabled,
        c && (c.enabled = !1);
        const h = this._viewer.getPluginByType("FrameFade")
          , _ = this._viewer.getPluginByType("GLTFAnimation")
          , b = this._viewer.getPluginByType("CameraViews");
        for (; this._isPlaying; )
            for (const _e of this.scenes) {
                if (!this._isPlaying)
                    break;
                const nt = Object.keys(_e);
                _ == null || _.stopAnimation(!1),
                await (b == null ? void 0 : b.stopAllAnimations()),
                this._viewer.scene.removeSceneModels(),
                this._viewer.renderEnabled = !1;
                for (const at of nt) {
                    let ut = this.assets[at];
                    ut || (ut = {
                        path: at,
                        file: new File([_e[at]],at)
                    },
                    this.assets[at] = ut),
                    await ((o = this._viewer.getManager()) === null || o === void 0 ? void 0 : o.addAssetSingle(ut, this._options))
                }
                if (!this._isPlaying)
                    break;
                this._viewer.renderEnabled = !0,
                c && (c.enabled = !1),
                h && (h.enabled = !0,
                await h.startTransition(1e3));
                const it = [X$2(this.minSceneTime)];
                _ && it.push(_.playAnimation()),
                b && it.push(b.animateAllViews()),
                await Promise.all(it)
            }
        this._isPlayingLoop = !1
    }
    stop() {
        this._isPlaying = !1
    }
    async downloadScenes() {
        const d = {};
        for (const c of this.scenes)
            for (const h of Object.keys(c)) {
                const _ = d[h] ? h + "_" : h;
                d[_] = c[_]
            }
        const o = zipSync(d);
        N$2(new Blob([o],{
            type: "application/zip"
        }), "scenes.glbloop")
    }
    async onAdded(d) {
        var o, c;
        await super.onAdded(d);
        const h = this;
        (c = (o = d.getManager()) === null || o === void 0 ? void 0 : o.importer) === null || c === void 0 || c.Importers.push(new Importer(class extends ZipLoader {
            load(_, b, _e, nt) {
                super.load(_, it => {
                    h.loadScenes([...it.values()]),
                    b == null || b(null),
                    X$2(100).then(h.play)
                }
                , _e, nt)
            }
        }
        ,["glbloop"],!0))
    }
}
;
SceneLoopPlugin.PluginType = "SceneLoopPlugin",
SceneLoopPlugin_decorate([uiMonitor("Loaded scenes")], SceneLoopPlugin.prototype, "loadedScenes", null),
SceneLoopPlugin_decorate([uiButton("Load Scenes")], SceneLoopPlugin.prototype, "promptLoadScenes", null),
SceneLoopPlugin_decorate([uiMonitor("Playing")], SceneLoopPlugin.prototype, "_isPlaying", void 0),
SceneLoopPlugin_decorate([uiInput("Min Scene Time")], SceneLoopPlugin.prototype, "minSceneTime", void 0),
SceneLoopPlugin_decorate([uiButton("Play")], SceneLoopPlugin.prototype, "play", null),
SceneLoopPlugin_decorate([uiButton("Stop")], SceneLoopPlugin.prototype, "stop", null),
SceneLoopPlugin_decorate([uiButton("Download Scenes")], SceneLoopPlugin.prototype, "downloadScenes", null),
SceneLoopPlugin = SceneLoopPlugin_decorate([uiFolder("Scene Loop")], SceneLoopPlugin);
class NBuf3 {
    constructor(o) {
        this.top = 0,
        this.array = new Float32Array(o)
    }
    write(o) {
        this.array[this.top++] = o.x,
        this.array[this.top++] = o.y,
        this.array[this.top++] = o.z
    }
}
class NBuf2 {
    constructor(o) {
        this.top = 0,
        this.array = new Float32Array(o)
    }
    write(o) {
        this.array[this.top++] = o.x,
        this.array[this.top++] = o.y
    }
}
class Node_Node {
    constructor(o) {
        this.plane = null,
        this.front = null,
        this.back = null,
        this.polygons = [],
        o && this.build(o)
    }
    clone() {
        const o = new Node_Node;
        return o.plane = this.plane && this.plane.clone(),
        o.front = this.front && this.front.clone(),
        o.back = this.back && this.back.clone(),
        o.polygons = this.polygons.map(c => c.clone()),
        o
    }
    invert() {
        for (let c = 0; c < this.polygons.length; c++)
            this.polygons[c].flip();
        this.plane && this.plane.flip(),
        this.front && this.front.invert(),
        this.back && this.back.invert();
        const o = this.front;
        this.front = this.back,
        this.back = o
    }
    clipPolygons(o) {
        if (!this.plane)
            return o.slice();
        let c = new Array
          , h = new Array;
        for (let _ = 0; _ < o.length; _++)
            this.plane.splitPolygon(o[_], c, h, c, h);
        return this.front && (c = this.front.clipPolygons(c)),
        h = this.back ? this.back.clipPolygons(h) : [],
        c.concat(h)
    }
    clipTo(o) {
        this.polygons = o.clipPolygons(this.polygons),
        this.front && this.front.clipTo(o),
        this.back && this.back.clipTo(o)
    }
    allPolygons() {
        let o = this.polygons.slice();
        return this.front && (o = o.concat(this.front.allPolygons())),
        this.back && (o = o.concat(this.back.allPolygons())),
        o
    }
    build(o) {
        if (!o.length)
            return;
        this.plane || (this.plane = o[0].plane.clone());
        const c = []
          , h = [];
        for (let _ = 0; _ < o.length; _++)
            this.plane.splitPolygon(o[_], this.polygons, this.polygons, c, h);
        c.length && (this.front || (this.front = new Node_Node),
        this.front.build(c)),
        h.length && (this.back || (this.back = new Node_Node),
        this.back.build(h))
    }
}
class Vector {
    constructor(o=0, c=0, h=0) {
        this.x = o,
        this.y = c,
        this.z = h
    }
    copy(o) {
        return this.x = o.x,
        this.y = o.y,
        this.z = o.z,
        this
    }
    clone() {
        return new Vector(this.x,this.y,this.z)
    }
    negate() {
        return this.x *= -1,
        this.y *= -1,
        this.z *= -1,
        this
    }
    add(o) {
        return this.x += o.x,
        this.y += o.y,
        this.z += o.z,
        this
    }
    sub(o) {
        return this.x -= o.x,
        this.y -= o.y,
        this.z -= o.z,
        this
    }
    times(o) {
        return this.x *= o,
        this.y *= o,
        this.z *= o,
        this
    }
    dividedBy(o) {
        return this.x /= o,
        this.y /= o,
        this.z /= o,
        this
    }
    lerp(o, c) {
        return this.add(new Vector().copy(o).sub(this).times(c))
    }
    unit() {
        return this.dividedBy(this.length())
    }
    length() {
        return Math.sqrt(Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2))
    }
    normalize() {
        return this.unit()
    }
    cross(o) {
        const c = this.clone()
          , h = c.x
          , _ = c.y
          , b = c.z
          , _e = o.x
          , nt = o.y
          , it = o.z;
        return this.x = _ * it - b * nt,
        this.y = b * _e - h * it,
        this.z = h * nt - _ * _e,
        this
    }
    dot(o) {
        return this.x * o.x + this.y * o.y + this.z * o.z
    }
    toVector3() {
        return new three_module.Pq0(this.x,this.y,this.z)
    }
}
class Plane {
    constructor(o, c) {
        this.normal = o,
        this.w = c,
        this.normal = o,
        this.w = c
    }
    clone() {
        return new Plane(this.normal.clone(),this.w)
    }
    flip() {
        this.normal.negate(),
        this.w = -this.w
    }
    splitPolygon(o, c, h, _, b) {
        let _e = 0;
        const nt = [];
        for (let it = 0; it < o.vertices.length; it++) {
            const at = this.normal.dot(o.vertices[it].pos) - this.w
              , ut = at < -Plane.EPSILON ? 2 : at > Plane.EPSILON ? 1 : 0;
            _e |= ut,
            nt.push(ut)
        }
        switch (_e) {
        case 0:
            (this.normal.dot(o.plane.normal) > 0 ? c : h).push(o);
            break;
        case 1:
            _.push(o);
            break;
        case 2:
            b.push(o);
            break;
        case 3:
            {
                const it = []
                  , at = [];
                for (let ut = 0; ut < o.vertices.length; ut++) {
                    const pt = (ut + 1) % o.vertices.length
                      , ht = nt[ut]
                      , _t = nt[pt]
                      , vt = o.vertices[ut]
                      , bt = o.vertices[pt];
                    if (ht != 2 && it.push(vt),
                    ht != 1 && at.push(ht != 2 ? vt.clone() : vt),
                    (ht | _t) == 3) {
                        const St = (this.w - this.normal.dot(vt.pos)) / this.normal.dot(new Vector().copy(bt.pos).sub(vt.pos))
                          , At = vt.interpolate(bt, St);
                        it.push(At),
                        at.push(At.clone())
                    }
                }
                it.length >= 3 && _.push(new Polygon(it,o.shared)),
                at.length >= 3 && b.push(new Polygon(at,o.shared));
                break
            }
        }
    }
    static fromPoints(o, c, h) {
        const _ = new Vector().copy(c).sub(o).cross(new Vector().copy(h).sub(o)).normalize();
        return new Plane(_.clone(),_.dot(o))
    }
}
Plane.EPSILON = 1e-5;
class Polygon {
    constructor(o, c) {
        this.vertices = o,
        this.shared = c,
        this.plane = Plane.fromPoints(o[0].pos, o[1].pos, o[2].pos)
    }
    clone() {
        return new Polygon(this.vertices.map(o => o.clone()),this.shared)
    }
    flip() {
        this.vertices.reverse().map(o => o.flip()),
        this.plane.flip()
    }
}
class Vertex {
    constructor(o, c, h, _) {
        this.pos = new Vector().copy(o),
        this.normal = new Vector().copy(c),
        this.uv = new Vector().copy(h),
        this.uv.z = 0,
        _ && (this.color = new Vector().copy(_))
    }
    clone() {
        return new Vertex(this.pos,this.normal,this.uv,this.color)
    }
    flip() {
        this.normal.negate()
    }
    interpolate(o, c) {
        return new Vertex(this.pos.clone().lerp(o.pos, c),this.normal.clone().lerp(o.normal, c),this.uv.clone().lerp(o.uv, c),this.color && o.color && this.color.clone().lerp(o.color, c))
    }
}
class CSG {
    constructor() {
        this.polygons = new Array
    }
    static fromPolygons(o) {
        const c = new CSG;
        return c.polygons = o,
        c
    }
    static fromGeometry(o, c) {
        let h = [];
        const _ = o.attributes.position
          , b = o.attributes.normal
          , _e = o.attributes.uv
          , nt = o.attributes.color
          , it = o.groups;
        let at;
        if (o.index)
            at = o.index.array;
        else {
            at = new Array(_.array.length / _.itemSize | 0);
            for (let pt = 0; pt < at.length; pt++)
                at[pt] = pt
        }
        const ut = at.length / 3 | 0;
        h = new Array(ut);
        for (let pt = 0, ht = 0, _t = at.length; pt < _t; pt += 3,
        ht++) {
            const vt = new Array(3);
            for (let bt = 0; bt < 3; bt++) {
                const St = at[pt + bt]
                  , At = 3 * St
                  , Et = 2 * St
                  , Pt = _.array[At]
                  , It = _.array[At + 1]
                  , Dt = _.array[At + 2]
                  , Gt = b.array[At]
                  , Bt = b.array[At + 1]
                  , kt = b.array[At + 2]
                  , Ut = _e == null ? void 0 : _e.array[Et]
                  , Ht = _e == null ? void 0 : _e.array[Et + 1];
                vt[bt] = new Vertex(new Vector(Pt,It,Dt),new Vector(Gt,Bt,kt),new Vector(Ut,Ht,0),nt && new Vector(nt.array[Et],nt.array[Et + 1],nt.array[Et + 2]))
            }
            if (c === void 0 && it && it.length > 0)
                for (const bt of it)
                    pt >= bt.start && pt < bt.start + bt.count && (h[ht] = new Polygon(vt,bt.materialIndex));
            else
                h[ht] = new Polygon(vt,c)
        }
        return CSG.fromPolygons(h.filter(pt => !isNaN(pt.plane.normal.x)))
    }
    static toGeometry(o, c) {
        let h = 0;
        const _ = o.polygons;
        for (const _t of _)
            h += _t.vertices.length - 2;
        const b = new three_module.LoY
          , _e = new NBuf3(3 * h * 3)
          , nt = new NBuf3(3 * h * 3)
          , it = new NBuf2(2 * h * 3);
        let at;
        const ut = []
          , pt = [];
        for (const _t of _) {
            const vt = _t.vertices
              , bt = vt.length;
            _t.shared !== void 0 && (ut[_t.shared] || (ut[_t.shared] = [])),
            bt && vt[0].color !== void 0 && (at || (at = new NBuf3(3 * h * 3)));
            for (let St = 3; St <= bt; St++)
                (_t.shared === void 0 ? pt : ut[_t.shared]).push(_e.top / 3, _e.top / 3 + 1, _e.top / 3 + 2),
                _e.write(vt[0].pos),
                _e.write(vt[St - 2].pos),
                _e.write(vt[St - 1].pos),
                nt.write(vt[0].normal),
                nt.write(vt[St - 2].normal),
                nt.write(vt[St - 1].normal),
                it && (it.write(vt[0].uv),
                it.write(vt[St - 2].uv),
                it.write(vt[St - 1].uv)),
                at && (at.write(vt[0].color),
                at.write(vt[St - 2].color),
                at.write(vt[St - 1].color))
        }
        b.setAttribute("position", new three_module.THS(_e.array,3)),
        b.setAttribute("normal", new three_module.THS(nt.array,3)),
        it && b.setAttribute("uv", new three_module.THS(it.array,2)),
        at && b.setAttribute("color", new three_module.THS(at.array,3));
        for (let _t = 0; _t < ut.length; _t++)
            ut[_t] === void 0 && (ut[_t] = []);
        if (ut.length) {
            let _t = []
              , vt = 0;
            for (let bt = 0; bt < ut.length; bt++)
                b.addGroup(vt, ut[bt].length, bt),
                vt += ut[bt].length,
                _t = _t.concat(ut[bt]);
            b.addGroup(vt, pt.length, ut.length),
            _t = _t.concat(pt),
            b.setIndex(_t)
        }
        const ht = new three_module.kn4().copy(c).invert();
        return b.applyMatrix4(ht),
        b.computeBoundingSphere(),
        b.computeBoundingBox(),
        b
    }
    static fromMesh(o, c) {
        const h = CSG.fromGeometry(o.geometry, c)
          , _ = new three_module.Pq0
          , b = new three_module.dwI;
        b.getNormalMatrix(o.matrix);
        for (let _e = 0; _e < h.polygons.length; _e++) {
            const nt = h.polygons[_e];
            for (let it = 0; it < nt.vertices.length; it++) {
                const at = nt.vertices[it];
                at.pos.copy(_.copy(at.pos.toVector3()).applyMatrix4(o.matrix)),
                at.normal.copy(_.copy(at.normal.toVector3()).applyMatrix3(b))
            }
        }
        return h
    }
    static toMesh(o, c, h) {
        const _ = CSG.toGeometry(o, c)
          , b = new three_module.eaF(_,h);
        return b.matrix.copy(c),
        b.matrix.decompose(b.position, b.quaternion, b.scale),
        b.rotation.setFromQuaternion(b.quaternion),
        b.updateMatrixWorld(),
        b.castShadow = b.receiveShadow = !0,
        b
    }
    static union(o, c) {
        const h = CSG.fromMesh(o)
          , _ = CSG.fromMesh(c);
        return CSG.toMesh(h.union(_), o.matrix, o.material)
    }
    static subtract(o, c) {
        const h = CSG.fromMesh(o)
          , _ = CSG.fromMesh(c);
        return CSG.toMesh(h.subtract(_), o.matrix, o.material)
    }
    static intersect(o, c) {
        const h = CSG.fromMesh(o)
          , _ = CSG.fromMesh(c);
        return CSG.toMesh(h.intersect(_), o.matrix, o.material)
    }
    clone() {
        const o = new CSG;
        return o.polygons = this.polygons.map(c => c.clone()).filter(c => Number.isFinite(c.plane.w)),
        o
    }
    toPolygons() {
        return this.polygons
    }
    union(o) {
        const c = new Node_Node(this.clone().polygons)
          , h = new Node_Node(o.clone().polygons);
        return c.clipTo(h),
        h.clipTo(c),
        h.invert(),
        h.clipTo(c),
        h.invert(),
        c.build(h.allPolygons()),
        CSG.fromPolygons(c.allPolygons())
    }
    subtract(o) {
        const c = new Node_Node(this.clone().polygons)
          , h = new Node_Node(o.clone().polygons);
        return c.invert(),
        c.clipTo(h),
        h.clipTo(c),
        h.invert(),
        h.clipTo(c),
        h.invert(),
        c.build(h.allPolygons()),
        c.invert(),
        CSG.fromPolygons(c.allPolygons())
    }
    intersect(o) {
        const c = new Node_Node(this.clone().polygons)
          , h = new Node_Node(o.clone().polygons);
        return c.invert(),
        h.clipTo(c),
        h.invert(),
        c.clipTo(h),
        h.clipTo(c),
        c.build(h.allPolygons()),
        c.invert(),
        CSG.fromPolygons(c.allPolygons())
    }
    inverse() {
        const o = this.clone();
        for (const c of o.polygons)
            c.flip();
        return o
    }
    toMesh(o, c) {
        return CSG.toMesh(this, o, c)
    }
    toGeometry(o) {
        return CSG.toGeometry(this, o)
    }
}
var CSGPluginBase_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const csgOperations = ["union", "subtract", "intersect"];
class CSGPluginBase extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.dependencies = [PickingPlugin],
        this.rootMesh = new three_module.eaF,
        this.showResult = !1,
        this.csgSelectedEnabled = !1,
        this.csgSelectedOperation = "union",
        this._csgNeedsUpdate = !1,
        this._csgVisible = !1,
        this._sceneUpdate = this._sceneUpdate.bind(this),
        this._preFrame = this._preFrame.bind(this),
        this.makeSelectedCSGBrush = this.makeSelectedCSGBrush.bind(this),
        this.refreshCSG = this.refreshCSG.bind(this),
        this._selectedObjectChanged = this._selectedObjectChanged.bind(this),
        this._updateSelectedProperties = this._updateSelectedProperties.bind(this),
        this.downloadObject = this.downloadObject.bind(this),
        this.exportObject = this.exportObject.bind(this)
    }
    async onAdded(o) {
        var c;
        await super.onAdded(o),
        this.rootObject = await o.createObject3D(),
        this.rootObject.modelObject.add(this.rootMesh),
        o.scene.addEventListener("sceneUpdate", this._sceneUpdate),
        o.addEventListener("preFrame", this._preFrame),
        (c = o.getPlugin(PickingPlugin)) === null || c === void 0 || c.addEventListener("selectedObjectChanged", this._selectedObjectChanged)
    }
    async makeSelectedCSGBrush() {
        var o, c;
        const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
        h && h.geometry && (h.userData._isCSGMesh || (h.userData.csgBrush || (h.userData.csgBrush = {
            enabled: !0,
            operation: "union"
        }),
        this._selectedObjectChanged()))
    }
    refreshCSG() {
        this._sceneUpdate()
    }
    async downloadObject() {
        const o = await this.exportObject();
        o && N$2(o, "csg." + o.ext)
    }
    async exportObject() {
        var o, c;
        const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("AssetExporterPlugin")) === null || c === void 0 ? void 0 : c.exporter;
        if (!h || !this.rootObject)
            return;
        const _ = this.rootMesh.visible;
        this.rootMesh.visible = !0;
        const b = await h.exportObject(this.rootObject.modelObject, {});
        return this.rootMesh.visible = _,
        b
    }
    _updateSelectedProperties() {
        var o, c;
        const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
        h && h.userData.csgBrush && (h.userData.csgBrush.enabled = this.csgSelectedEnabled,
        h.userData.csgBrush.operation = this.csgSelectedOperation)
    }
    _selectedObjectChanged() {
        var o, c, h, _, b, _e, nt, it;
        const at = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
        at && (this.csgSelectedEnabled = (_ = (h = at.userData.csgBrush) === null || h === void 0 ? void 0 : h.enabled) !== null && _ !== void 0 && _,
        this.csgSelectedOperation = (_e = (b = at.userData.csgBrush) === null || b === void 0 ? void 0 : b.operation) !== null && _e !== void 0 ? _e : "union"),
        (it = (nt = this.uiConfig) === null || nt === void 0 ? void 0 : nt.uiRefresh) === null || it === void 0 || it.call(nt, "postFrame", !0)
    }
    _preFrame() {
        var o, c, h;
        if (!this.rootObject || !this._csgNeedsUpdate && this._csgVisible === this.showResult)
            return;
        const _ = this._findCSGMeshes();
        this._csgNeedsUpdate && (this._csgNeedsUpdate = !1,
        (o = this.rootObject) === null || o === void 0 || o.modelObject.updateMatrixWorld(!0),
        ((c = this.rootMesh.userData.dispose) !== null && c !== void 0 ? c : this.rootMesh.removeFromParent)(),
        this.rootMesh = this._buildCSGMesh(_)),
        this.rootMesh && !this.rootMesh.parent && ((h = this.rootObject) === null || h === void 0 || h.modelObject.add(this.rootMesh)),
        this.showResult ? (_.forEach(b => {
            b[0].visible = !1
        }
        ),
        this.rootObject.visible = !0,
        this._csgVisible = !0,
        this.rootObject.setDirty()) : (_.forEach(b => {
            b[0].visible = !0
        }
        ),
        this.rootObject.visible = !1,
        this._csgVisible = !1,
        this.rootObject.setDirty())
    }
    _findCSGMeshes() {
        var o;
        const c = [];
        return (o = this._viewer) === null || o === void 0 || o.scene.traverse(h => {
            var _;
            h.isMesh && h.geometry && (!((_ = h.userData.csgBrush) === null || _ === void 0) && _.enabled) && c.push([h, h.userData.csgBrush.operation])
        }
        ),
        c
    }
    _sceneUpdate(o) {
        var c, h;
        !((h = (c = o == null ? void 0 : o.object) === null || c === void 0 ? void 0 : c.userData) === null || h === void 0) && h._isCSGMesh || (this._csgNeedsUpdate = !0)
    }
}
CSGPluginBase_decorate([uiToggle("Show Result", d => ({
    onChange: () => {
        var o;
        return (o = d._viewer) === null || o === void 0 ? void 0 : o.setDirty()
    }
}))], CSGPluginBase.prototype, "showResult", void 0),
CSGPluginBase_decorate([uiButton("Make CSG Brush", d => ({
    hidden: () => {
        var o, c;
        const h = (c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
        return !(h != null && h.userData) || !!h.userData.csgBrush || h.userData._isCSGMesh
    }
}))], CSGPluginBase.prototype, "makeSelectedCSGBrush", null),
CSGPluginBase_decorate([uiToggle("Enabled", d => ({
    hidden: () => {
        var o, c;
        const h = (c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
        return !h || !h.userData.csgBrush
    }
    ,
    onChange: d._updateSelectedProperties
}))], CSGPluginBase.prototype, "csgSelectedEnabled", void 0),
CSGPluginBase_decorate([uiDropdown("Operation", csgOperations.map(d => ({
    label: d
})), d => ({
    hidden: () => {
        var o, c;
        const h = (c = (o = d._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
        return !h || !h.userData.csgBrush
    }
    ,
    onChange: d._updateSelectedProperties
}))], CSGPluginBase.prototype, "csgSelectedOperation", void 0),
CSGPluginBase_decorate([uiButton("Refresh CSG")], CSGPluginBase.prototype, "refreshCSG", null),
CSGPluginBase_decorate([uiButton("Export Result", d => ({
    hidden: () => {
        var o;
        return !(!((o = d._viewer) === null || o === void 0) && o.getPluginByType("AssetExporterPlugin"))
    }
}))], CSGPluginBase.prototype, "downloadObject", null);
var CSGPluginBSP_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
function buildCSGMeshBSP(d, o) {
    let c = new CSG;
    const h = d.map(b => b[0].material).flatMap(b => b);
    d.forEach( ([b,_e]) => {
        if (!csgOperations.includes(_e))
            return void console.error(`Unknown operation ${_e}`);
        b.updateMatrix(),
        b.updateMatrixWorld();
        const nt = b.matrix;
        b.matrix = b.matrixWorld;
        let it = 0;
        it = Array.isArray(b.material) ? void 0 : h.indexOf(b.material),
        c = c[_e](CSG.fromMesh(b, it)),
        b.matrix = nt
    }
    );
    const _ = c.toMesh(o ?? new three_module.kn4().identity(), h);
    return _.userData._isCSGMesh = !0,
    _.geometry.groups = _.geometry.groups.filter(b => b.count > 0),
    _
}
let CSGPluginBSP = class extends CSGPluginBase {
    _buildCSGMesh(d) {
        return buildCSGMeshBSP(d)
    }
}
;
CSGPluginBSP.PluginType = "CSGPluginBSP",
CSGPluginBSP = CSGPluginBSP_decorate([uiFolder("CSG Plugin (BSP)")], CSGPluginBSP);
const ADDITION = 0
  , SUBTRACTION = 1
  , REVERSE_SUBTRACTION = 2
  , INTERSECTION = 3
  , DIFFERENCE = 4
  , HOLLOW_SUBTRACTION = 5
  , HOLLOW_INTERSECTION = 6;
class SeparatingAxisBounds {
    constructor() {
        this.min = 1 / 0,
        this.max = -1 / 0
    }
    setFromPointsField(o, c) {
        let h = 1 / 0
          , _ = -1 / 0;
        for (let b = 0, _e = o.length; b < _e; b++) {
            const nt = o[b][c];
            h = nt < h ? nt : h,
            _ = nt > _ ? nt : _
        }
        this.min = h,
        this.max = _
    }
    setFromPoints(o, c) {
        let h = 1 / 0
          , _ = -1 / 0;
        for (let b = 0, _e = c.length; b < _e; b++) {
            const nt = c[b]
              , it = o.dot(nt);
            h = it < h ? it : h,
            _ = it > _ ? it : _
        }
        this.min = h,
        this.max = _
    }
    isSeparated(o) {
        return this.min > o.max || o.min > this.max
    }
}
SeparatingAxisBounds.prototype.setFromBox = function() {
    const d = new three_module.Pq0;
    return function(o, c) {
        const h = c.min
          , _ = c.max;
        let b = 1 / 0
          , _e = -1 / 0;
        for (let nt = 0; nt <= 1; nt++)
            for (let it = 0; it <= 1; it++)
                for (let at = 0; at <= 1; at++) {
                    d.x = h.x * nt + _.x * (1 - nt),
                    d.y = h.y * it + _.y * (1 - it),
                    d.z = h.z * at + _.z * (1 - at);
                    const ut = o.dot(d);
                    b = Math.min(ut, b),
                    _e = Math.max(ut, _e)
                }
        this.min = b,
        this.max = _e
    }
}();
const closestPointLineToLine = function() {
    const d = new three_module.Pq0
      , o = new three_module.Pq0
      , c = new three_module.Pq0;
    return function(h, _, b) {
        const _e = h.start
          , nt = d
          , it = _.start
          , at = o;
        c.subVectors(_e, it),
        d.subVectors(h.end, h.start),
        o.subVectors(_.end, _.start);
        const ut = c.dot(at)
          , pt = at.dot(nt)
          , ht = at.dot(at)
          , _t = c.dot(nt)
          , vt = nt.dot(nt) * ht - pt * pt;
        let bt, St;
        bt = vt !== 0 ? (ut * pt - _t * ht) / vt : 0,
        St = (ut + bt * pt) / ht,
        b.x = bt,
        b.y = St
    }
}()
  , closestPointsSegmentToSegment = function() {
    const d = new three_module.I9Y
      , o = new three_module.Pq0
      , c = new three_module.Pq0;
    return function(h, _, b, _e) {
        closestPointLineToLine(h, _, d);
        let nt = d.x
          , it = d.y;
        if (nt >= 0 && nt <= 1 && it >= 0 && it <= 1)
            return h.at(nt, b),
            void _.at(it, _e);
        if (nt >= 0 && nt <= 1)
            return it < 0 ? _.at(0, _e) : _.at(1, _e),
            void h.closestPointToPoint(_e, !0, b);
        if (it >= 0 && it <= 1)
            return nt < 0 ? h.at(0, b) : h.at(1, b),
            void _.closestPointToPoint(b, !0, _e);
        {
            let at, ut;
            at = nt < 0 ? h.start : h.end,
            ut = it < 0 ? _.start : _.end;
            const pt = o
              , ht = c;
            return h.closestPointToPoint(ut, !0, o),
            _.closestPointToPoint(at, !0, c),
            pt.distanceToSquared(ut) <= ht.distanceToSquared(at) ? (b.copy(pt),
            void _e.copy(ut)) : (b.copy(at),
            void _e.copy(ht))
        }
    }
}()
  , sphereIntersectTriangle = function() {
    const d = new three_module.Pq0
      , o = new three_module.Pq0
      , c = new three_module.Zcv
      , h = new three_module.cZY;
    return function(_, b) {
        const {radius: _e, center: nt} = _
          , {a: it, b: at, c: ut} = b;
        if (h.start = it,
        h.end = at,
        h.closestPointToPoint(nt, !0, d).distanceTo(nt) <= _e || (h.start = it,
        h.end = ut,
        h.closestPointToPoint(nt, !0, d).distanceTo(nt) <= _e) || (h.start = at,
        h.end = ut,
        h.closestPointToPoint(nt, !0, d).distanceTo(nt) <= _e))
            return !0;
        const pt = b.getPlane(c);
        if (Math.abs(pt.distanceToPoint(nt)) <= _e) {
            const ht = pt.projectPoint(nt, o);
            if (b.containsPoint(ht))
                return !0
        }
        return !1
    }
}()
  , ZERO_EPSILON = 1e-15;
function isNearZero(d) {
    return Math.abs(d) < ZERO_EPSILON
}
class ExtendedTriangle extends three_module.lMl {
    constructor(...o) {
        super(...o),
        this.isExtendedTriangle = !0,
        this.satAxes = new Array(4).fill().map( () => new three_module.Pq0),
        this.satBounds = new Array(4).fill().map( () => new SeparatingAxisBounds),
        this.points = [this.a, this.b, this.c],
        this.sphere = new three_module.iyt,
        this.plane = new three_module.Zcv,
        this.needsUpdate = !0
    }
    intersectsSphere(o) {
        return sphereIntersectTriangle(o, this)
    }
    update() {
        const o = this.a
          , c = this.b
          , h = this.c
          , _ = this.points
          , b = this.satAxes
          , _e = this.satBounds
          , nt = b[0]
          , it = _e[0];
        this.getNormal(nt),
        it.setFromPoints(nt, _);
        const at = b[1]
          , ut = _e[1];
        at.subVectors(o, c),
        ut.setFromPoints(at, _);
        const pt = b[2]
          , ht = _e[2];
        pt.subVectors(c, h),
        ht.setFromPoints(pt, _);
        const _t = b[3]
          , vt = _e[3];
        _t.subVectors(h, o),
        vt.setFromPoints(_t, _),
        this.sphere.setFromPoints(this.points),
        this.plane.setFromNormalAndCoplanarPoint(nt, o),
        this.needsUpdate = !1
    }
}
ExtendedTriangle.prototype.closestPointToSegment = function() {
    const d = new three_module.Pq0
      , o = new three_module.Pq0
      , c = new three_module.cZY;
    return function(h, _=null, b=null) {
        const {start: _e, end: nt} = h
          , it = this.points;
        let at, ut = 1 / 0;
        for (let pt = 0; pt < 3; pt++) {
            const ht = (pt + 1) % 3;
            c.start.copy(it[pt]),
            c.end.copy(it[ht]),
            closestPointsSegmentToSegment(c, h, d, o),
            at = d.distanceToSquared(o),
            at < ut && (ut = at,
            _ && _.copy(d),
            b && b.copy(o))
        }
        return this.closestPointToPoint(_e, d),
        at = _e.distanceToSquared(d),
        at < ut && (ut = at,
        _ && _.copy(d),
        b && b.copy(_e)),
        this.closestPointToPoint(nt, d),
        at = nt.distanceToSquared(d),
        at < ut && (ut = at,
        _ && _.copy(d),
        b && b.copy(nt)),
        Math.sqrt(ut)
    }
}(),
ExtendedTriangle.prototype.intersectsTriangle = function() {
    const d = new ExtendedTriangle
      , o = new Array(3)
      , c = new Array(3)
      , h = new SeparatingAxisBounds
      , _ = new SeparatingAxisBounds
      , b = new three_module.Pq0
      , _e = new three_module.Pq0
      , nt = new three_module.Pq0
      , it = new three_module.Pq0
      , at = new three_module.Pq0
      , ut = new three_module.cZY
      , pt = new three_module.cZY
      , ht = new three_module.cZY
      , _t = new three_module.Pq0;
    function vt(bt, St, At) {
        const Et = bt.points;
        let Pt = 0
          , It = -1;
        for (let Dt = 0; Dt < 3; Dt++) {
            const {start: Gt, end: Bt} = ut;
            Gt.copy(Et[Dt]),
            Bt.copy(Et[(Dt + 1) % 3]),
            ut.delta(_e);
            const kt = isNearZero(St.distanceToPoint(Gt));
            if (isNearZero(St.normal.dot(_e)) && kt) {
                At.copy(ut),
                Pt = 2;
                break
            }
            const Ut = St.intersectLine(ut, _t);
            if (!Ut && kt && _t.copy(Gt),
            (Ut || kt) && !isNearZero(_t.distanceTo(Bt))) {
                if (Pt <= 1)
                    (Pt === 1 ? At.start : At.end).copy(_t),
                    kt && (It = Pt);
                else if (Pt >= 2) {
                    (It === 1 ? At.start : At.end).copy(_t),
                    Pt = 2;
                    break
                }
                if (Pt++,
                Pt === 2 && It === -1)
                    break
            }
        }
        return Pt
    }
    return function(bt, St=null, At=!1) {
        this.needsUpdate && this.update(),
        bt.isExtendedTriangle ? bt.needsUpdate && bt.update() : (d.copy(bt),
        d.update(),
        bt = d);
        const Et = this.plane
          , Pt = bt.plane;
        if (Math.abs(Et.normal.dot(Pt.normal)) > 1 - 1e-10) {
            const It = this.satBounds
              , Dt = this.satAxes;
            c[0] = bt.a,
            c[1] = bt.b,
            c[2] = bt.c;
            for (let kt = 0; kt < 4; kt++) {
                const Ut = It[kt]
                  , Ht = Dt[kt];
                if (h.setFromPoints(Ht, c),
                Ut.isSeparated(h))
                    return !1
            }
            const Gt = bt.satBounds
              , Bt = bt.satAxes;
            o[0] = this.a,
            o[1] = this.b,
            o[2] = this.c;
            for (let kt = 0; kt < 4; kt++) {
                const Ut = Gt[kt]
                  , Ht = Bt[kt];
                if (h.setFromPoints(Ht, o),
                Ut.isSeparated(h))
                    return !1
            }
            for (let kt = 0; kt < 4; kt++) {
                const Ut = Dt[kt];
                for (let Ht = 0; Ht < 4; Ht++) {
                    const Kt = Bt[Ht];
                    if (b.crossVectors(Ut, Kt),
                    h.setFromPoints(b, o),
                    _.setFromPoints(b, c),
                    h.isSeparated(_))
                        return !1
                }
            }
            return St && (At || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),
            St.start.set(0, 0, 0),
            St.end.set(0, 0, 0)),
            !0
        }
        {
            const It = vt(this, Pt, pt);
            if (It === 1 && bt.containsPoint(pt.end))
                return St && (St.start.copy(pt.end),
                St.end.copy(pt.end)),
                !0;
            if (It !== 2)
                return !1;
            const Dt = vt(bt, Et, ht);
            if (Dt === 1 && this.containsPoint(ht.end))
                return St && (St.start.copy(ht.end),
                St.end.copy(ht.end)),
                !0;
            if (Dt !== 2)
                return !1;
            if (pt.delta(nt),
            ht.delta(it),
            nt.dot(it) < 0) {
                let Ht = ht.start;
                ht.start = ht.end,
                ht.end = Ht
            }
            const Gt = pt.start.dot(nt)
              , Bt = pt.end.dot(nt)
              , kt = ht.start.dot(nt)
              , Ut = ht.end.dot(nt);
            return (Gt === Ut || kt === Bt || Bt < kt != Gt < Ut) && (St && (at.subVectors(pt.start, ht.start),
            at.dot(nt) > 0 ? St.start.copy(pt.start) : St.start.copy(ht.start),
            at.subVectors(pt.end, ht.end),
            at.dot(nt) < 0 ? St.end.copy(pt.end) : St.end.copy(ht.end)),
            !0)
        }
    }
}(),
ExtendedTriangle.prototype.distanceToPoint = function() {
    const d = new three_module.Pq0;
    return function(o) {
        return this.closestPointToPoint(o, d),
        o.distanceTo(d)
    }
}(),
ExtendedTriangle.prototype.distanceToTriangle = function() {
    const d = new three_module.Pq0
      , o = new three_module.Pq0
      , c = ["a", "b", "c"]
      , h = new three_module.cZY
      , _ = new three_module.cZY;
    return function(b, _e=null, nt=null) {
        const it = _e || nt ? h : null;
        if (this.intersectsTriangle(b, it))
            return (_e || nt) && (_e && it.getCenter(_e),
            nt && it.getCenter(nt)),
            0;
        let at = 1 / 0;
        for (let ut = 0; ut < 3; ut++) {
            let pt;
            const ht = c[ut]
              , _t = b[ht];
            this.closestPointToPoint(_t, d),
            pt = _t.distanceToSquared(d),
            pt < at && (at = pt,
            _e && _e.copy(d),
            nt && nt.copy(_t));
            const vt = this[ht];
            b.closestPointToPoint(vt, d),
            pt = vt.distanceToSquared(d),
            pt < at && (at = pt,
            _e && _e.copy(vt),
            nt && nt.copy(d))
        }
        for (let ut = 0; ut < 3; ut++) {
            const pt = c[ut]
              , ht = c[(ut + 1) % 3];
            h.set(this[pt], this[ht]);
            for (let _t = 0; _t < 3; _t++) {
                const vt = c[_t]
                  , bt = c[(_t + 1) % 3];
                _.set(b[vt], b[bt]),
                closestPointsSegmentToSegment(h, _, d, o);
                const St = d.distanceToSquared(o);
                St < at && (at = St,
                _e && _e.copy(d),
                nt && nt.copy(o))
            }
        }
        return Math.sqrt(at)
    }
}();
const EPSILON = 1e-14
  , _AB = new three_module.Pq0
  , _AC = new three_module.Pq0
  , _CB = new three_module.Pq0;
function isTriDegenerate(d, o=EPSILON) {
    _AB.subVectors(d.b, d.a),
    _AC.subVectors(d.c, d.a),
    _CB.subVectors(d.b, d.c);
    const c = _AB.angleTo(_AC)
      , h = _AB.angleTo(_CB)
      , _ = Math.PI - c - h;
    return Math.abs(c) < o || Math.abs(h) < o || Math.abs(_) < o || d.a.distanceToSquared(d.b) < o || d.a.distanceToSquared(d.c) < o || d.b.distanceToSquared(d.c) < o
}
const TriangleSplitter_EPSILON = 1e-10
  , COPLANAR_EPSILON = 1e-10
  , PARALLEL_EPSILON = 1e-10
  , _edge = new three_module.cZY
  , _foundEdge = new three_module.cZY
  , _vec = new three_module.Pq0
  , _triangleNormal = new three_module.Pq0
  , _planeNormal = new three_module.Pq0
  , TriangleSplitter_plane = new three_module.Zcv
  , _splittingTriangle = new ExtendedTriangle;
class TrianglePool {
    constructor() {
        this._pool = [],
        this._index = 0
    }
    getTriangle() {
        return this._index >= this._pool.length && this._pool.push(new three_module.lMl),
        this._pool[this._index++]
    }
    clear() {
        this._index = 0
    }
    reset() {
        this._pool.length = 0,
        this._index = 0
    }
}
class TriangleSplitter {
    constructor() {
        this.trianglePool = new TrianglePool,
        this.triangles = [],
        this.normal = new three_module.Pq0,
        this.coplanarTriangleUsed = !1
    }
    initialize(o) {
        this.reset();
        const {triangles: c, trianglePool: h, normal: _} = this;
        if (Array.isArray(o))
            for (let b = 0, _e = o.length; b < _e; b++) {
                const nt = o[b];
                if (b === 0)
                    nt.getNormal(_);
                else if (Math.abs(1 - nt.getNormal(_vec).dot(_)) > TriangleSplitter_EPSILON)
                    throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");
                const it = h.getTriangle();
                it.copy(nt),
                c.push(it)
            }
        else {
            o.getNormal(_);
            const b = h.getTriangle();
            b.copy(o),
            c.push(b)
        }
    }
    splitByTriangle(o) {
        const {normal: c, triangles: h} = this;
        if (o.getNormal(_triangleNormal).normalize(),
        Math.abs(1 - Math.abs(_triangleNormal.dot(c))) < PARALLEL_EPSILON) {
            this.coplanarTriangleUsed = !0;
            for (let b = 0, _e = h.length; b < _e; b++)
                h[b].coplanarCount = 0;
            const _ = [o.a, o.b, o.c];
            for (let b = 0; b < 3; b++) {
                const _e = (b + 1) % 3
                  , nt = _[b]
                  , it = _[_e];
                _vec.subVectors(it, nt).normalize(),
                _planeNormal.crossVectors(_triangleNormal, _vec),
                TriangleSplitter_plane.setFromNormalAndCoplanarPoint(_planeNormal, nt),
                this.splitByPlane(TriangleSplitter_plane, o)
            }
        } else
            o.getPlane(TriangleSplitter_plane),
            this.splitByPlane(TriangleSplitter_plane, o)
    }
    splitByPlane(o, c) {
        const {triangles: h, trianglePool: _} = this;
        _splittingTriangle.copy(c),
        _splittingTriangle.needsUpdate = !0;
        for (let b = 0, _e = h.length; b < _e; b++) {
            const nt = h[b];
            if (!_splittingTriangle.intersectsTriangle(nt, _edge, !0))
                continue;
            const {a: it, b: at, c: ut} = nt;
            let pt = 0
              , ht = -1
              , _t = !1
              , vt = []
              , bt = [];
            const St = [it, at, ut];
            for (let At = 0; At < 3; At++) {
                const Et = (At + 1) % 3;
                _edge.start.copy(St[At]),
                _edge.end.copy(St[Et]);
                const Pt = o.distanceToPoint(_edge.start)
                  , It = o.distanceToPoint(_edge.end);
                if (Math.abs(Pt) < COPLANAR_EPSILON && Math.abs(It) < COPLANAR_EPSILON) {
                    _t = !0;
                    break
                }
                if (Pt > 0 ? vt.push(At) : bt.push(At),
                Math.abs(Pt) < COPLANAR_EPSILON)
                    continue;
                let Dt = !!o.intersectLine(_edge, _vec);
                !Dt && Math.abs(It) < COPLANAR_EPSILON && (_vec.copy(_edge.end),
                Dt = !0),
                !Dt || _vec.distanceTo(_edge.start) < TriangleSplitter_EPSILON || (_vec.distanceTo(_edge.end) < TriangleSplitter_EPSILON && (ht = At),
                pt === 0 ? _foundEdge.start.copy(_vec) : _foundEdge.end.copy(_vec),
                pt++)
            }
            if (!_t && pt === 2 && _foundEdge.distance() > COPLANAR_EPSILON)
                if (ht !== -1) {
                    ht = (ht + 1) % 3;
                    let At = 0;
                    At === ht && (At = (At + 1) % 3);
                    let Et = At + 1;
                    Et === ht && (Et = (Et + 1) % 3);
                    const Pt = _.getTriangle();
                    Pt.a.copy(St[Et]),
                    Pt.b.copy(_foundEdge.end),
                    Pt.c.copy(_foundEdge.start),
                    isTriDegenerate(Pt) || h.push(Pt),
                    nt.a.copy(St[At]),
                    nt.b.copy(_foundEdge.start),
                    nt.c.copy(_foundEdge.end),
                    isTriDegenerate(nt) && (h.splice(b, 1),
                    b--,
                    _e--)
                } else {
                    const At = vt.length >= 2 ? bt[0] : vt[0];
                    if (At === 0) {
                        let Gt = _foundEdge.start;
                        _foundEdge.start = _foundEdge.end,
                        _foundEdge.end = Gt
                    }
                    const Et = (At + 1) % 3
                      , Pt = (At + 2) % 3
                      , It = _.getTriangle()
                      , Dt = _.getTriangle();
                    St[Et].distanceToSquared(_foundEdge.start) < St[Pt].distanceToSquared(_foundEdge.end) ? (It.a.copy(St[Et]),
                    It.b.copy(_foundEdge.start),
                    It.c.copy(_foundEdge.end),
                    Dt.a.copy(St[Et]),
                    Dt.b.copy(St[Pt]),
                    Dt.c.copy(_foundEdge.start)) : (It.a.copy(St[Pt]),
                    It.b.copy(_foundEdge.start),
                    It.c.copy(_foundEdge.end),
                    Dt.a.copy(St[Et]),
                    Dt.b.copy(St[Pt]),
                    Dt.c.copy(_foundEdge.end)),
                    nt.a.copy(St[At]),
                    nt.b.copy(_foundEdge.end),
                    nt.c.copy(_foundEdge.start),
                    isTriDegenerate(It) || h.push(It),
                    isTriDegenerate(Dt) || h.push(Dt),
                    isTriDegenerate(nt) && (h.splice(b, 1),
                    b--,
                    _e--)
                }
            else
                pt === 3 && console.warn("TriangleClipper: Coplanar clip not handled")
        }
    }
    reset() {
        this.triangles.length = 0,
        this.trianglePool.clear(),
        this.coplanarTriangleUsed = !1
    }
}
function areSharedArrayBuffersSupported() {
    return typeof SharedArrayBuffer < "u"
}
function convertToSharedArrayBuffer(d) {
    if (d.buffer instanceof SharedArrayBuffer)
        return d;
    const o = d.constructor
      , c = d.buffer
      , h = new SharedArrayBuffer(c.byteLength)
      , _ = new Uint8Array(c);
    return new Uint8Array(h).set(_, 0),
    new o(h)
}
function getIndexArray(d, o=ArrayBuffer) {
    return d > 65535 ? new Uint32Array(new o(4 * d)) : new Uint16Array(new o(2 * d))
}
function ensureIndex(d, o) {
    if (!d.index) {
        const c = d.attributes.position.count
          , h = getIndexArray(c, o.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
        d.setIndex(new three_module.THS(h,1));
        for (let _ = 0; _ < c; _++)
            h[_] = _
    }
}
function getVertexCount(d) {
    return d.index ? d.index.count : d.attributes.position.count
}
function getTriCount(d) {
    return getVertexCount(d) / 3
}
function ceilToFourByteStride(d) {
    return 4 + (d = ~~d) - d % 4
}
class TypeBackedArray {
    constructor(o, c=500) {
        this.expansionFactor = 1.5,
        this.type = o,
        this.length = 0,
        this.array = null,
        this.setSize(c)
    }
    setType(o) {
        if (this.length !== 0)
            throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");
        const c = this.array.buffer;
        this.array = new o(c),
        this.type = o
    }
    setSize(o) {
        if (this.array && o === this.array.length)
            return;
        const c = this.type
          , h = new c(new (areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer)(ceilToFourByteStride(o * c.BYTES_PER_ELEMENT)));
        this.array && h.set(this.array, 0),
        this.array = h
    }
    expand() {
        const {array: o, expansionFactor: c} = this;
        this.setSize(o.length * c)
    }
    push(...o) {
        let {array: c, length: h} = this;
        h + o.length > c.length && (this.expand(),
        c = this.array);
        for (let _ = 0, b = o.length; _ < b; _++)
            c[h + _] = o[_];
        this.length += o.length
    }
    clear() {
        this.length = 0
    }
}
class TypedAttributeData {
    constructor() {
        this.groupAttributes = [{}],
        this.groupCount = 0
    }
    getType(o) {
        return this.groupAttributes[0][o].type
    }
    getItemSize(o) {
        return this.groupAttributes[0][o].itemSize
    }
    getNormalized(o) {
        return this.groupAttributes[0][o].normalized
    }
    getCount(o) {
        if (this.groupCount <= o)
            return 0;
        const c = this.getGroupAttrArray("position", o);
        return c.length / c.itemSize
    }
    getTotalLength(o) {
        const {groupCount: c, groupAttributes: h} = this;
        let _ = 0;
        for (let b = 0; b < c; b++)
            _ += h[b][o].length;
        return _
    }
    getGroupAttrSet(o=0) {
        const {groupAttributes: c} = this;
        if (c[o])
            return this.groupCount = Math.max(this.groupCount, o + 1),
            c[o];
        const h = c[0];
        for (this.groupCount = Math.max(this.groupCount, o + 1); o >= c.length; ) {
            const _ = {};
            c.push(_);
            for (const b in h) {
                const _e = h[b]
                  , nt = new TypeBackedArray(_e.type);
                nt.itemSize = _e.itemSize,
                nt.normalized = _e.normalized,
                _[b] = nt
            }
        }
        return c[o]
    }
    getGroupAttrArray(o, c=0) {
        const {groupAttributes: h} = this;
        if (!h[0][o])
            throw new Error(`TypedAttributeData: Attribute with "${o}" has not been initialized`);
        return this.getGroupAttrSet(c)[o]
    }
    initializeArray(o, c, h, _) {
        const {groupAttributes: b} = this
          , _e = b[0][o];
        if (_e) {
            if (_e.type !== c)
                for (let nt = 0, it = b.length; nt < it; nt++) {
                    const at = b[nt][o];
                    at.setType(c),
                    at.itemSize = h,
                    at.normalized = _
                }
        } else
            for (let nt = 0, it = b.length; nt < it; nt++) {
                const at = new TypeBackedArray(c);
                at.itemSize = h,
                at.normalized = _,
                b[nt][o] = at
            }
    }
    clear() {
        this.groupCount = 0;
        const {groupAttributes: o} = this;
        o.forEach(c => {
            for (const h in c)
                c[h].clear()
        }
        )
    }
    delete(o) {
        this.groupAttributes.forEach(c => {
            delete c[o]
        }
        )
    }
    reset() {
        this.groupAttributes = [],
        this.groupCount = 0
    }
}
class IntersectionMap {
    constructor() {
        this.intersectionSet = {},
        this.ids = []
    }
    add(o, c) {
        const {intersectionSet: h, ids: _} = this;
        h[o] || (h[o] = [],
        _.push(o)),
        h[o].push(c)
    }
}
const operationsUtils_ray = new three_module.RlV
  , operationsUtils_matrix = new three_module.kn4
  , _tri = new three_module.lMl
  , _vec3 = new three_module.Pq0
  , _vec4a = new three_module.IUQ
  , _vec4b = new three_module.IUQ
  , _vec4c = new three_module.IUQ
  , _vec4_0 = new three_module.IUQ
  , _vec4_1 = new three_module.IUQ
  , _vec4_2 = new three_module.IUQ
  , operationsUtils_edge = new three_module.cZY
  , _normal = new three_module.Pq0
  , JITTER_EPSILON = 1e-8
  , OFFSET_EPSILON = 1e-15
  , BACK_SIDE = -1
  , FRONT_SIDE = 1
  , COPLANAR_OPPOSITE = -2
  , COPLANAR_ALIGNED = 2
  , INVERT_TRI = 0
  , ADD_TRI = 1
  , SKIP_TRI = 2
  , FLOATING_COPLANAR_EPSILON = 1e-14;
let _debugContext = null;
function setDebugContext(d) {
    _debugContext = d
}
function getHitSide(d, o) {
    d.getMidpoint(operationsUtils_ray.origin),
    d.getNormal(operationsUtils_ray.direction);
    const c = o.raycastFirst(operationsUtils_ray, three_module.$EB);
    return c && operationsUtils_ray.direction.dot(c.face.normal) > 0 ? BACK_SIDE : FRONT_SIDE
}
function getHitSideWithCoplanarCheck(d, o) {
    function c() {
        return Math.random() - .5
    }
    d.getNormal(_normal),
    operationsUtils_ray.direction.copy(_normal),
    d.getMidpoint(operationsUtils_ray.origin);
    let h = 0
      , _ = 1 / 0;
    for (let b = 0; b < 3; b++) {
        operationsUtils_ray.direction.x += c() * JITTER_EPSILON,
        operationsUtils_ray.direction.y += c() * JITTER_EPSILON,
        operationsUtils_ray.direction.z += c() * JITTER_EPSILON,
        operationsUtils_ray.direction.multiplyScalar(-1);
        const _e = o.raycastFirst(operationsUtils_ray, three_module.$EB);
        if (_e && operationsUtils_ray.direction.dot(_e.face.normal) > 0 && h++,
        _e !== null && (_ = Math.min(_, _e.distance)),
        _ <= OFFSET_EPSILON)
            return _e.face.normal.dot(_normal) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;
        if (h / 3 > .5 || (b - h + 1) / 3 > .5)
            break
    }
    return h / 3 > .5 ? BACK_SIDE : FRONT_SIDE
}
function collectIntersectingTriangles(d, o) {
    const c = new IntersectionMap
      , h = new IntersectionMap;
    return operationsUtils_matrix.copy(d.matrixWorld).invert().multiply(o.matrixWorld),
    d.geometry.boundsTree.bvhcast(o.geometry.boundsTree, operationsUtils_matrix, {
        intersectsTriangles(_, b, _e, nt) {
            if (!isTriDegenerate(_) && !isTriDegenerate(b)) {
                let it = _.intersectsTriangle(b, operationsUtils_edge, !0);
                if (!it) {
                    const at = _.plane
                      , ut = b.plane
                      , pt = at.normal
                      , ht = ut.normal;
                    pt.dot(ht) === 1 && Math.abs(at.constant - ut.constant) < FLOATING_COPLANAR_EPSILON && (it = !0)
                }
                if (it) {
                    let at = d.geometry.boundsTree.resolveTriangleIndex(_e)
                      , ut = o.geometry.boundsTree.resolveTriangleIndex(nt);
                    c.add(at, ut),
                    h.add(ut, at),
                    _debugContext && (_debugContext.addEdge(operationsUtils_edge),
                    _debugContext.addIntersectingTriangles(_e, _, nt, b))
                }
            }
            return !1
        }
    }),
    {
        aIntersections: c,
        bIntersections: h
    }
}
function appendAttributeFromTriangle(d, o, c, h, _, b, _e=!1) {
    const nt = c.attributes
      , it = c.index
      , at = 3 * d
      , ut = it.getX(at + 0)
      , pt = it.getX(at + 1)
      , ht = it.getX(at + 2);
    for (const _t in b) {
        const vt = nt[_t]
          , bt = b[_t];
        if (!(_t in nt))
            throw new Error(`CSG Operations: Attribute ${_t} not available on geometry.`);
        const St = vt.itemSize;
        _t === "position" ? (_tri.a.fromBufferAttribute(vt, ut).applyMatrix4(h),
        _tri.b.fromBufferAttribute(vt, pt).applyMatrix4(h),
        _tri.c.fromBufferAttribute(vt, ht).applyMatrix4(h),
        pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, o, 3, bt, _e)) : _t === "normal" ? (_tri.a.fromBufferAttribute(vt, ut).applyNormalMatrix(_),
        _tri.b.fromBufferAttribute(vt, pt).applyNormalMatrix(_),
        _tri.c.fromBufferAttribute(vt, ht).applyNormalMatrix(_),
        _e && (_tri.a.multiplyScalar(-1),
        _tri.b.multiplyScalar(-1),
        _tri.c.multiplyScalar(-1)),
        pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, o, 3, bt, _e, !0)) : (_vec4a.fromBufferAttribute(vt, ut),
        _vec4b.fromBufferAttribute(vt, pt),
        _vec4c.fromBufferAttribute(vt, ht),
        pushBarycoordInterpolatedValues(_vec4a, _vec4b, _vec4c, o, St, bt, _e))
    }
}
function appendAttributesFromIndices(d, o, c, h, _, b, _e, nt=!1) {
    appendAttributeFromIndex(d, h, _, b, _e, nt),
    appendAttributeFromIndex(nt ? c : o, h, _, b, _e, nt),
    appendAttributeFromIndex(nt ? o : c, h, _, b, _e, nt)
}
function getOperationAction(d, o, c=!1) {
    switch (d) {
    case ADDITION:
        if (o === FRONT_SIDE || o === COPLANAR_ALIGNED && !c)
            return ADD_TRI;
        break;
    case SUBTRACTION:
        if (c) {
            if (o === BACK_SIDE)
                return INVERT_TRI
        } else if (o === FRONT_SIDE || o === COPLANAR_OPPOSITE)
            return ADD_TRI;
        break;
    case REVERSE_SUBTRACTION:
        if (c) {
            if (o === FRONT_SIDE || o === COPLANAR_OPPOSITE)
                return ADD_TRI
        } else if (o === BACK_SIDE)
            return INVERT_TRI;
        break;
    case DIFFERENCE:
        if (o === BACK_SIDE)
            return INVERT_TRI;
        if (o === FRONT_SIDE)
            return ADD_TRI;
        break;
    case INTERSECTION:
        if (o === BACK_SIDE || o === COPLANAR_ALIGNED && !c)
            return ADD_TRI;
        break;
    case HOLLOW_SUBTRACTION:
        if (!c && (o === FRONT_SIDE || o === COPLANAR_OPPOSITE))
            return ADD_TRI;
        break;
    case HOLLOW_INTERSECTION:
        if (!c && (o === BACK_SIDE || o === COPLANAR_ALIGNED))
            return ADD_TRI;
        break;
    default:
        throw new Error(`Unrecognized CSG operation enum "${d}".`)
    }
    return SKIP_TRI
}
function pushBarycoordInterpolatedValues(d, o, c, h, _, b, _e=!1, nt=!1) {
    const it = at => {
        b.push(at.x),
        _ > 1 && b.push(at.y),
        _ > 2 && b.push(at.z),
        _ > 3 && b.push(at.w)
    }
    ;
    _vec4_0.set(0, 0, 0, 0).addScaledVector(d, h.a.x).addScaledVector(o, h.a.y).addScaledVector(c, h.a.z),
    _vec4_1.set(0, 0, 0, 0).addScaledVector(d, h.b.x).addScaledVector(o, h.b.y).addScaledVector(c, h.b.z),
    _vec4_2.set(0, 0, 0, 0).addScaledVector(d, h.c.x).addScaledVector(o, h.c.y).addScaledVector(c, h.c.z),
    nt && (_vec4_0.normalize(),
    _vec4_1.normalize(),
    _vec4_2.normalize()),
    it(_vec4_0),
    _e ? (it(_vec4_2),
    it(_vec4_1)) : (it(_vec4_1),
    it(_vec4_2))
}
function appendAttributeFromIndex(d, o, c, h, _, b=!1) {
    for (const _e in _) {
        const nt = o[_e]
          , it = _[_e];
        if (!(_e in o))
            throw new Error(`CSG Operations: Attribute ${_e} no available on geometry.`);
        const at = nt.itemSize;
        _e === "position" ? (_vec3.fromBufferAttribute(nt, d).applyMatrix4(c),
        it.push(_vec3.x, _vec3.y, _vec3.z)) : _e === "normal" ? (_vec3.fromBufferAttribute(nt, d).applyNormalMatrix(h),
        b && _vec3.multiplyScalar(-1),
        it.push(_vec3.x, _vec3.y, _vec3.z)) : (it.push(nt.getX(d)),
        at > 1 && it.push(nt.getY(d)),
        at > 2 && it.push(nt.getZ(d)),
        at > 3 && it.push(nt.getW(d)))
    }
}
class TriangleIntersectData {
    constructor(o) {
        this.triangle = new three_module.lMl().copy(o),
        this.intersects = {}
    }
    addTriangle(o, c) {
        this.intersects[o] = new three_module.lMl().copy(c)
    }
    getIntersectArray() {
        const o = []
          , {intersects: c} = this;
        for (const h in c)
            o.push(c[h]);
        return o
    }
}
class TriangleIntersectionSets {
    constructor() {
        this.data = {}
    }
    addTriangleIntersection(o, c, h, _) {
        const {data: b} = this;
        b[o] || (b[o] = new TriangleIntersectData(c)),
        b[o].addTriangle(h, _)
    }
    getTrianglesAsArray(o=null) {
        const {data: c} = this
          , h = [];
        if (o !== null)
            o in c && h.push(c[o].triangle);
        else
            for (const _ in c)
                h.push(c[_].triangle);
        return h
    }
    getTriangleIndices() {
        return Object.keys(this.data).map(o => parseInt(o))
    }
    getIntersectionIndices(o) {
        const {data: c} = this;
        return c[o] ? Object.keys(c[o].intersects).map(h => parseInt(h)) : []
    }
    getIntersectionsAsArray(o=null, c=null) {
        const {data: h} = this
          , _ = new Set
          , b = []
          , _e = nt => {
            if (h[nt])
                if (c !== null)
                    h[nt].intersects[c] && b.push(h[nt].intersects[c]);
                else {
                    const it = h[nt].intersects;
                    for (const at in it)
                        _.has(at) || (_.add(at),
                        b.push(it[at]))
                }
        }
        ;
        if (o !== null)
            _e(o);
        else
            for (const nt in h)
                _e(nt);
        return b
    }
    reset() {
        this.data = {}
    }
}
class OperationDebugData {
    constructor() {
        this.enabled = !1,
        this.triangleIntersectsA = new TriangleIntersectionSets,
        this.triangleIntersectsB = new TriangleIntersectionSets,
        this.intersectionEdges = []
    }
    addIntersectingTriangles(o, c, h, _) {
        const {triangleIntersectsA: b, triangleIntersectsB: _e} = this;
        b.addTriangleIntersection(o, c, h, _),
        _e.addTriangleIntersection(h, _, o, c)
    }
    addEdge(o) {
        this.intersectionEdges.push(o.clone())
    }
    reset() {
        this.triangleIntersectsA.reset(),
        this.triangleIntersectsB.reset(),
        this.intersectionEdges = []
    }
    init() {
        this.enabled && (this.reset(),
        setDebugContext(this))
    }
    complete() {
        this.enabled && setDebugContext(null)
    }
}
const operations_matrix = new three_module.kn4
  , _normalMatrix = new three_module.dwI
  , _triA = new three_module.lMl
  , _triB = new three_module.lMl
  , operations_tri = new three_module.lMl
  , _barycoordTri = new three_module.lMl
  , _attr = []
  , _actions = [];
function getFirstIdFromSet(d) {
    for (const o of d)
        return o
}
function performOperation(d, o, c, h, _, b={}) {
    const {useGroups: _e=!0} = b
      , {aIntersections: nt, bIntersections: it} = collectIntersectingTriangles(d, o);
    let at;
    return at = _e ? 0 : -1,
    performSplitTriangleOperations(d, o, nt, c, !1, h, _, at),
    performWholeTriangleOperations(d, o, nt, c, !1, _, at),
    c.findIndex(ut => ut !== HOLLOW_INTERSECTION && ut !== HOLLOW_SUBTRACTION) !== -1 && (at = _e ? d.geometry.groups.length || 1 : -1,
    performSplitTriangleOperations(o, d, it, c, !0, h, _, at),
    performWholeTriangleOperations(o, d, it, c, !0, _, at)),
    _attr.length = 0,
    _actions.length = 0,
    {
        groups: [],
        materials: null
    }
}
function performSplitTriangleOperations(d, o, c, h, _, b, _e, nt=0) {
    const it = d.matrixWorld.determinant() < 0;
    operations_matrix.copy(o.matrixWorld).invert().multiply(d.matrixWorld),
    _normalMatrix.getNormalMatrix(d.matrixWorld).multiplyScalar(it ? -1 : 1);
    const at = d.geometry.groupIndices
      , ut = d.geometry.index
      , pt = d.geometry.attributes.position
      , ht = o.geometry.boundsTree
      , _t = o.geometry.index
      , vt = o.geometry.attributes.position
      , bt = c.ids
      , St = c.intersectionSet;
    for (let At = 0, Et = bt.length; At < Et; At++) {
        const Pt = bt[At]
          , It = nt === -1 ? 0 : at[Pt] + nt
          , Dt = 3 * Pt
          , Gt = ut.getX(Dt + 0)
          , Bt = ut.getX(Dt + 1)
          , kt = ut.getX(Dt + 2);
        _triA.a.fromBufferAttribute(pt, Gt).applyMatrix4(operations_matrix),
        _triA.b.fromBufferAttribute(pt, Bt).applyMatrix4(operations_matrix),
        _triA.c.fromBufferAttribute(pt, kt).applyMatrix4(operations_matrix),
        b.reset(),
        b.initialize(_triA);
        const Ut = St[Pt];
        for (let Kt = 0, Jt = Ut.length; Kt < Jt; Kt++) {
            const or = 3 * Ut[Kt]
              , ir = _t.getX(or + 0)
              , lr = _t.getX(or + 1)
              , ar = _t.getX(or + 2);
            _triB.a.fromBufferAttribute(vt, ir),
            _triB.b.fromBufferAttribute(vt, lr),
            _triB.c.fromBufferAttribute(vt, ar),
            b.splitByTriangle(_triB)
        }
        const Ht = b.triangles;
        for (let Kt = 0, Jt = Ht.length; Kt < Jt; Kt++) {
            const or = Ht[Kt]
              , ir = b.coplanarTriangleUsed ? getHitSideWithCoplanarCheck(or, ht) : getHitSide(or, ht);
            _attr.length = 0,
            _actions.length = 0;
            for (let lr = 0, ar = h.length; lr < ar; lr++) {
                const hr = getOperationAction(h[lr], ir, _);
                hr !== SKIP_TRI && (_actions.push(hr),
                _attr.push(_e[lr].getGroupAttrSet(It)))
            }
            if (_attr.length !== 0) {
                _triA.getBarycoord(or.a, _barycoordTri.a),
                _triA.getBarycoord(or.b, _barycoordTri.b),
                _triA.getBarycoord(or.c, _barycoordTri.c);
                for (let lr = 0, ar = _attr.length; lr < ar; lr++) {
                    const hr = _attr[lr]
                      , gr = _actions[lr] === INVERT_TRI;
                    appendAttributeFromTriangle(Pt, _barycoordTri, d.geometry, d.matrixWorld, _normalMatrix, hr, it !== gr)
                }
            }
        }
    }
    return bt.length
}
function performWholeTriangleOperations(d, o, c, h, _, b, _e=0) {
    const nt = d.matrixWorld.determinant() < 0;
    operations_matrix.copy(o.matrixWorld).invert().multiply(d.matrixWorld),
    _normalMatrix.getNormalMatrix(d.matrixWorld).multiplyScalar(nt ? -1 : 1);
    const it = o.geometry.boundsTree
      , at = d.geometry.groupIndices
      , ut = d.geometry.index
      , pt = d.geometry.attributes
      , ht = pt.position
      , _t = []
      , vt = d.geometry.halfEdges
      , bt = new Set;
    for (let St = 0, At = getTriCount(d.geometry); St < At; St++)
        St in c.intersectionSet || bt.add(St);
    for (; bt.size > 0; ) {
        const St = getFirstIdFromSet(bt);
        bt.delete(St),
        _t.push(St);
        const At = 3 * St
          , Et = ut.getX(At + 0)
          , Pt = ut.getX(At + 1)
          , It = ut.getX(At + 2);
        operations_tri.a.fromBufferAttribute(ht, Et).applyMatrix4(operations_matrix),
        operations_tri.b.fromBufferAttribute(ht, Pt).applyMatrix4(operations_matrix),
        operations_tri.c.fromBufferAttribute(ht, It).applyMatrix4(operations_matrix);
        const Dt = getHitSide(operations_tri, it);
        _actions.length = 0,
        _attr.length = 0;
        for (let Gt = 0, Bt = h.length; Gt < Bt; Gt++) {
            const kt = getOperationAction(h[Gt], Dt, _);
            kt !== SKIP_TRI && (_actions.push(kt),
            _attr.push(b[Gt]))
        }
        for (; _t.length > 0; ) {
            const Gt = _t.pop();
            for (let Bt = 0; Bt < 3; Bt++) {
                const kt = vt.getSiblingTriangleIndex(Gt, Bt);
                kt !== -1 && bt.has(kt) && (_t.push(kt),
                bt.delete(kt))
            }
            if (_attr.length !== 0) {
                const Bt = 3 * Gt
                  , kt = ut.getX(Bt + 0)
                  , Ut = ut.getX(Bt + 1)
                  , Ht = ut.getX(Bt + 2)
                  , Kt = _e === -1 ? 0 : at[Gt] + _e;
                if (operations_tri.a.fromBufferAttribute(ht, kt),
                operations_tri.b.fromBufferAttribute(ht, Ut),
                operations_tri.c.fromBufferAttribute(ht, Ht),
                !isTriDegenerate(operations_tri))
                    for (let Jt = 0, or = _attr.length; Jt < or; Jt++) {
                        const ir = _actions[Jt]
                          , lr = _attr[Jt].getGroupAttrSet(Kt)
                          , ar = ir === INVERT_TRI;
                        appendAttributesFromIndices(kt, Ut, Ht, pt, d.matrixWorld, _normalMatrix, lr, ar !== nt)
                    }
            }
        }
    }
}
const CENTER = 0
  , AVERAGE = 1
  , SAH = 2
  , CONTAINED = 2
  , TRIANGLE_INTERSECT_COST = 1.25
  , TRAVERSAL_COST = 1
  , BYTES_PER_NODE = 32
  , IS_LEAFNODE_FLAG = 65535
  , FLOAT32_EPSILON = Math.pow(2, -24)
  , SKIP_GENERATION = Symbol("SKIP_GENERATION");
function geometryUtils_getVertexCount(d) {
    return d.index ? d.index.count : d.attributes.position.count
}
function geometryUtils_getTriCount(d) {
    return geometryUtils_getVertexCount(d) / 3
}
function geometryUtils_getIndexArray(d, o=ArrayBuffer) {
    return d > 65535 ? new Uint32Array(new o(4 * d)) : new Uint16Array(new o(2 * d))
}
function geometryUtils_ensureIndex(d, o) {
    if (!d.index) {
        const c = d.attributes.position.count
          , h = geometryUtils_getIndexArray(c, o.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
        d.setIndex(new three_module.THS(h,1));
        for (let _ = 0; _ < c; _++)
            h[_] = _
    }
}
function getFullGeometryRange(d) {
    const o = geometryUtils_getTriCount(d)
      , c = d.drawRange
      , h = c.start / 3
      , _ = (c.start + c.count) / 3
      , b = Math.max(0, h)
      , _e = Math.min(o, _) - b;
    return [{
        offset: Math.floor(b),
        count: Math.floor(_e)
    }]
}
function getRootIndexRanges(d) {
    if (!d.groups || !d.groups.length)
        return getFullGeometryRange(d);
    const o = []
      , c = new Set
      , h = d.drawRange
      , _ = h.start / 3
      , b = (h.start + h.count) / 3;
    for (const nt of d.groups) {
        const it = nt.start / 3
          , at = (nt.start + nt.count) / 3;
        c.add(Math.max(_, it)),
        c.add(Math.min(b, at))
    }
    const _e = Array.from(c.values()).sort( (nt, it) => nt - it);
    for (let nt = 0; nt < _e.length - 1; nt++) {
        const it = _e[nt]
          , at = _e[nt + 1];
        o.push({
            offset: Math.floor(it),
            count: Math.floor(at - it)
        })
    }
    return o
}
function hasGroupGaps(d) {
    if (d.groups.length === 0)
        return !1;
    const o = geometryUtils_getTriCount(d)
      , c = getRootIndexRanges(d).sort( (b, _e) => b.offset - _e.offset)
      , h = c[c.length - 1];
    h.count = Math.min(o - h.offset, h.count);
    let _ = 0;
    return c.forEach( ({count: b}) => _ += b),
    o !== _
}
function arrayToBox(d, o, c) {
    return c.min.x = o[d],
    c.min.y = o[d + 1],
    c.min.z = o[d + 2],
    c.max.x = o[d + 3],
    c.max.y = o[d + 4],
    c.max.z = o[d + 5],
    c
}
function makeEmptyBounds(d) {
    d[0] = d[1] = d[2] = 1 / 0,
    d[3] = d[4] = d[5] = -1 / 0
}
function getLongestEdgeIndex(d) {
    let o = -1
      , c = -1 / 0;
    for (let h = 0; h < 3; h++) {
        const _ = d[h + 3] - d[h];
        _ > c && (c = _,
        o = h)
    }
    return o
}
function copyBounds(d, o) {
    o.set(d)
}
function unionBounds(d, o, c) {
    let h, _;
    for (let b = 0; b < 3; b++) {
        const _e = b + 3;
        h = d[b],
        _ = o[b],
        c[b] = h < _ ? h : _,
        h = d[_e],
        _ = o[_e],
        c[_e] = h > _ ? h : _
    }
}
function expandByTriangleBounds(d, o, c) {
    for (let h = 0; h < 3; h++) {
        const _ = o[d + 2 * h]
          , b = o[d + 2 * h + 1]
          , _e = _ - b
          , nt = _ + b;
        _e < c[h] && (c[h] = _e),
        nt > c[h + 3] && (c[h + 3] = nt)
    }
}
function computeSurfaceArea(d) {
    const o = d[3] - d[0]
      , c = d[4] - d[1]
      , h = d[5] - d[2];
    return 2 * (o * c + c * h + h * o)
}
function computeBoundsUtils_getBounds(d, o, c, h, _=null) {
    let b = 1 / 0
      , _e = 1 / 0
      , nt = 1 / 0
      , it = -1 / 0
      , at = -1 / 0
      , ut = -1 / 0
      , pt = 1 / 0
      , ht = 1 / 0
      , _t = 1 / 0
      , vt = -1 / 0
      , bt = -1 / 0
      , St = -1 / 0;
    const At = _ !== null;
    for (let Et = 6 * o, Pt = 6 * (o + c); Et < Pt; Et += 6) {
        const It = d[Et + 0]
          , Dt = d[Et + 1]
          , Gt = It - Dt
          , Bt = It + Dt;
        Gt < b && (b = Gt),
        Bt > it && (it = Bt),
        At && It < pt && (pt = It),
        At && It > vt && (vt = It);
        const kt = d[Et + 2]
          , Ut = d[Et + 3]
          , Ht = kt - Ut
          , Kt = kt + Ut;
        Ht < _e && (_e = Ht),
        Kt > at && (at = Kt),
        At && kt < ht && (ht = kt),
        At && kt > bt && (bt = kt);
        const Jt = d[Et + 4]
          , or = d[Et + 5]
          , ir = Jt - or
          , lr = Jt + or;
        ir < nt && (nt = ir),
        lr > ut && (ut = lr),
        At && Jt < _t && (_t = Jt),
        At && Jt > St && (St = Jt)
    }
    h[0] = b,
    h[1] = _e,
    h[2] = nt,
    h[3] = it,
    h[4] = at,
    h[5] = ut,
    At && (_[0] = pt,
    _[1] = ht,
    _[2] = _t,
    _[3] = vt,
    _[4] = bt,
    _[5] = St)
}
function getCentroidBounds(d, o, c, h) {
    let _ = 1 / 0
      , b = 1 / 0
      , _e = 1 / 0
      , nt = -1 / 0
      , it = -1 / 0
      , at = -1 / 0;
    for (let ut = 6 * o, pt = 6 * (o + c); ut < pt; ut += 6) {
        const ht = d[ut + 0];
        ht < _ && (_ = ht),
        ht > nt && (nt = ht);
        const _t = d[ut + 2];
        _t < b && (b = _t),
        _t > it && (it = _t);
        const vt = d[ut + 4];
        vt < _e && (_e = vt),
        vt > at && (at = vt)
    }
    h[0] = _,
    h[1] = b,
    h[2] = _e,
    h[3] = nt,
    h[4] = it,
    h[5] = at
}
function computeTriangleBounds(d, o) {
    makeEmptyBounds(o);
    const c = d.attributes.position
      , h = d.index ? d.index.array : null
      , _ = geometryUtils_getTriCount(d)
      , b = new Float32Array(6 * _)
      , _e = c.normalized
      , nt = c.array
      , it = c.offset || 0;
    let at = 3;
    c.isInterleavedBufferAttribute && (at = c.data.stride);
    const ut = ["getX", "getY", "getZ"];
    for (let pt = 0; pt < _; pt++) {
        const ht = 3 * pt
          , _t = 6 * pt;
        let vt = ht + 0
          , bt = ht + 1
          , St = ht + 2;
        h && (vt = h[vt],
        bt = h[bt],
        St = h[St]),
        _e || (vt = vt * at + it,
        bt = bt * at + it,
        St = St * at + it);
        for (let At = 0; At < 3; At++) {
            let Et, Pt, It;
            _e ? (Et = c[ut[At]](vt),
            Pt = c[ut[At]](bt),
            It = c[ut[At]](St)) : (Et = nt[vt + At],
            Pt = nt[bt + At],
            It = nt[St + At]);
            let Dt = Et;
            Pt < Dt && (Dt = Pt),
            It < Dt && (Dt = It);
            let Gt = Et;
            Pt > Gt && (Gt = Pt),
            It > Gt && (Gt = It);
            const Bt = (Gt - Dt) / 2
              , kt = 2 * At;
            b[_t + kt + 0] = Dt + Bt,
            b[_t + kt + 1] = Bt + (Math.abs(Dt) + Bt) * FLOAT32_EPSILON,
            Dt < o[At] && (o[At] = Dt),
            Gt > o[At + 3] && (o[At + 3] = Gt)
        }
    }
    return b
}
const BIN_COUNT = 32
  , binsSort = (d, o) => d.candidate - o.candidate
  , sahBins = new Array(BIN_COUNT).fill().map( () => ({
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
}))
  , leftBounds = new Float32Array(6);
function getOptimalSplit(d, o, c, h, _, b) {
    let _e = -1
      , nt = 0;
    if (b === CENTER)
        _e = getLongestEdgeIndex(o),
        _e !== -1 && (nt = (o[_e] + o[_e + 3]) / 2);
    else if (b === AVERAGE)
        _e = getLongestEdgeIndex(d),
        _e !== -1 && (nt = getAverage(c, h, _, _e));
    else if (b === SAH) {
        const it = computeSurfaceArea(d);
        let at = TRIANGLE_INTERSECT_COST * _;
        const ut = 6 * h
          , pt = 6 * (h + _);
        for (let ht = 0; ht < 3; ht++) {
            const _t = o[ht]
              , vt = (o[ht + 3] - _t) / BIN_COUNT;
            if (_ < BIN_COUNT / 4) {
                const bt = [...sahBins];
                bt.length = _;
                let St = 0;
                for (let Et = ut; Et < pt; Et += 6,
                St++) {
                    const Pt = bt[St];
                    Pt.candidate = c[Et + 2 * ht],
                    Pt.count = 0;
                    const {bounds: It, leftCacheBounds: Dt, rightCacheBounds: Gt} = Pt;
                    for (let Bt = 0; Bt < 3; Bt++)
                        Gt[Bt] = 1 / 0,
                        Gt[Bt + 3] = -1 / 0,
                        Dt[Bt] = 1 / 0,
                        Dt[Bt + 3] = -1 / 0,
                        It[Bt] = 1 / 0,
                        It[Bt + 3] = -1 / 0;
                    expandByTriangleBounds(Et, c, It)
                }
                bt.sort(binsSort);
                let At = _;
                for (let Et = 0; Et < At; Et++) {
                    const Pt = bt[Et];
                    for (; Et + 1 < At && bt[Et + 1].candidate === Pt.candidate; )
                        bt.splice(Et + 1, 1),
                        At--
                }
                for (let Et = ut; Et < pt; Et += 6) {
                    const Pt = c[Et + 2 * ht];
                    for (let It = 0; It < At; It++) {
                        const Dt = bt[It];
                        Pt >= Dt.candidate ? expandByTriangleBounds(Et, c, Dt.rightCacheBounds) : (expandByTriangleBounds(Et, c, Dt.leftCacheBounds),
                        Dt.count++)
                    }
                }
                for (let Et = 0; Et < At; Et++) {
                    const Pt = bt[Et]
                      , It = Pt.count
                      , Dt = _ - Pt.count
                      , Gt = Pt.leftCacheBounds
                      , Bt = Pt.rightCacheBounds;
                    let kt = 0;
                    It !== 0 && (kt = computeSurfaceArea(Gt) / it);
                    let Ut = 0;
                    Dt !== 0 && (Ut = computeSurfaceArea(Bt) / it);
                    const Ht = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (kt * It + Ut * Dt);
                    Ht < at && (_e = ht,
                    at = Ht,
                    nt = Pt.candidate)
                }
            } else {
                for (let At = 0; At < BIN_COUNT; At++) {
                    const Et = sahBins[At];
                    Et.count = 0,
                    Et.candidate = _t + vt + At * vt;
                    const Pt = Et.bounds;
                    for (let It = 0; It < 3; It++)
                        Pt[It] = 1 / 0,
                        Pt[It + 3] = -1 / 0
                }
                for (let At = ut; At < pt; At += 6) {
                    let Et = ~~((c[At + 2 * ht] - _t) / vt);
                    Et >= BIN_COUNT && (Et = BIN_COUNT - 1);
                    const Pt = sahBins[Et];
                    Pt.count++,
                    expandByTriangleBounds(At, c, Pt.bounds)
                }
                const bt = sahBins[BIN_COUNT - 1];
                copyBounds(bt.bounds, bt.rightCacheBounds);
                for (let At = BIN_COUNT - 2; At >= 0; At--) {
                    const Et = sahBins[At]
                      , Pt = sahBins[At + 1];
                    unionBounds(Et.bounds, Pt.rightCacheBounds, Et.rightCacheBounds)
                }
                let St = 0;
                for (let At = 0; At < BIN_COUNT - 1; At++) {
                    const Et = sahBins[At]
                      , Pt = Et.count
                      , It = Et.bounds
                      , Dt = sahBins[At + 1].rightCacheBounds;
                    Pt !== 0 && (St === 0 ? copyBounds(It, leftBounds) : unionBounds(It, leftBounds, leftBounds)),
                    St += Pt;
                    let Gt = 0
                      , Bt = 0;
                    St !== 0 && (Gt = computeSurfaceArea(leftBounds) / it);
                    const kt = _ - St;
                    kt !== 0 && (Bt = computeSurfaceArea(Dt) / it);
                    const Ut = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (Gt * St + Bt * kt);
                    Ut < at && (_e = ht,
                    at = Ut,
                    nt = Et.candidate)
                }
            }
        }
    } else
        console.warn(`MeshBVH: Invalid build strategy value ${b} used.`);
    return {
        axis: _e,
        pos: nt
    }
}
function getAverage(d, o, c, h) {
    let _ = 0;
    for (let b = o, _e = o + c; b < _e; b++)
        _ += d[6 * b + 2 * h];
    return _ / c
}
class MeshBVHNode {
    constructor() {}
}
function partition(d, o, c, h, _, b) {
    let _e = h
      , nt = h + _ - 1;
    const it = b.pos
      , at = 2 * b.axis;
    for (; ; ) {
        for (; _e <= nt && c[6 * _e + at] < it; )
            _e++;
        for (; _e <= nt && c[6 * nt + at] >= it; )
            nt--;
        if (!(_e < nt))
            return _e;
        for (let ut = 0; ut < 3; ut++) {
            let pt = o[3 * _e + ut];
            o[3 * _e + ut] = o[3 * nt + ut],
            o[3 * nt + ut] = pt
        }
        for (let ut = 0; ut < 6; ut++) {
            let pt = c[6 * _e + ut];
            c[6 * _e + ut] = c[6 * nt + ut],
            c[6 * nt + ut] = pt
        }
        _e++,
        nt--
    }
}
function partition_indirect(d, o, c, h, _, b) {
    let _e = h
      , nt = h + _ - 1;
    const it = b.pos
      , at = 2 * b.axis;
    for (; ; ) {
        for (; _e <= nt && c[6 * _e + at] < it; )
            _e++;
        for (; _e <= nt && c[6 * nt + at] >= it; )
            nt--;
        if (!(_e < nt))
            return _e;
        {
            let ut = d[_e];
            d[_e] = d[nt],
            d[nt] = ut;
            for (let pt = 0; pt < 6; pt++) {
                let ht = c[6 * _e + pt];
                c[6 * _e + pt] = c[6 * nt + pt],
                c[6 * nt + pt] = ht
            }
            _e++,
            nt--
        }
    }
}
function generateIndirectBuffer(d, o) {
    const c = (d.index ? d.index.count : d.attributes.position.count) / 3
      , h = c > 65536
      , _ = h ? 4 : 2
      , b = o ? new SharedArrayBuffer(c * _) : new ArrayBuffer(c * _)
      , _e = h ? new Uint32Array(b) : new Uint16Array(b);
    for (let nt = 0, it = _e.length; nt < it; nt++)
        _e[nt] = nt;
    return _e
}
function buildTree(d, o) {
    const c = d.geometry
      , h = c.index ? c.index.array : null
      , _ = o.maxDepth
      , b = o.verbose
      , _e = o.maxLeafTris
      , nt = o.strategy
      , it = o.onProgress
      , at = geometryUtils_getTriCount(c)
      , ut = d._indirectBuffer;
    let pt = !1;
    const ht = new Float32Array(6)
      , _t = new Float32Array(6)
      , vt = computeTriangleBounds(c, ht)
      , bt = o.indirect ? partition_indirect : partition
      , St = []
      , At = o.indirect ? getFullGeometryRange(c) : getRootIndexRanges(c);
    if (At.length === 1) {
        const It = At[0]
          , Dt = new MeshBVHNode;
        Dt.boundingData = ht,
        getCentroidBounds(vt, It.offset, It.count, _t),
        Pt(Dt, It.offset, It.count, _t),
        St.push(Dt)
    } else
        for (let It of At) {
            const Dt = new MeshBVHNode;
            Dt.boundingData = new Float32Array(6),
            computeBoundsUtils_getBounds(vt, It.offset, It.count, Dt.boundingData, _t),
            Pt(Dt, It.offset, It.count, _t),
            St.push(Dt)
        }
    return St;
    function Et(It) {
        it && it(It / at)
    }
    function Pt(It, Dt, Gt, Bt=null, kt=0) {
        if (!pt && kt >= _ && (pt = !0,
        b && (console.warn(`MeshBVH: Max depth of ${_} reached when generating BVH. Consider increasing maxDepth.`),
        console.warn(c))),
        Gt <= _e || kt >= _)
            return Et(Dt + Gt),
            It.offset = Dt,
            It.count = Gt,
            It;
        const Ut = getOptimalSplit(It.boundingData, Bt, vt, Dt, Gt, nt);
        if (Ut.axis === -1)
            return Et(Dt + Gt),
            It.offset = Dt,
            It.count = Gt,
            It;
        const Ht = bt(ut, h, vt, Dt, Gt, Ut);
        if (Ht === Dt || Ht === Dt + Gt)
            Et(Dt + Gt),
            It.offset = Dt,
            It.count = Gt;
        else {
            It.splitAxis = Ut.axis;
            const Kt = new MeshBVHNode
              , Jt = Dt
              , or = Ht - Dt;
            It.left = Kt,
            Kt.boundingData = new Float32Array(6),
            computeBoundsUtils_getBounds(vt, Jt, or, Kt.boundingData, _t),
            Pt(Kt, Jt, or, _t, kt + 1);
            const ir = new MeshBVHNode
              , lr = Ht
              , ar = Gt - or;
            It.right = ir,
            ir.boundingData = new Float32Array(6),
            computeBoundsUtils_getBounds(vt, lr, ar, ir.boundingData, _t),
            Pt(ir, lr, ar, _t, kt + 1)
        }
        return It
    }
}
function buildPackedTree(d, o) {
    const c = d.geometry;
    o.indirect && (d._indirectBuffer = generateIndirectBuffer(c, o.useSharedArrayBuffer),
    hasGroupGaps(c) && !o.verbose && console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),
    d._indirectBuffer || geometryUtils_ensureIndex(c, o);
    const h = buildTree(d, o);
    let _, b, _e;
    const nt = []
      , it = o.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    for (let pt = 0; pt < h.length; pt++) {
        const ht = h[pt];
        let _t = at(ht);
        const vt = new it(BYTES_PER_NODE * _t);
        _ = new Float32Array(vt),
        b = new Uint32Array(vt),
        _e = new Uint16Array(vt),
        ut(0, ht),
        nt.push(vt)
    }
    return void (d._roots = nt);
    function at(pt) {
        return pt.count ? 1 : 1 + at(pt.left) + at(pt.right)
    }
    function ut(pt, ht) {
        const _t = pt / 4
          , vt = pt / 2
          , bt = !!ht.count
          , St = ht.boundingData;
        for (let At = 0; At < 6; At++)
            _[_t + At] = St[At];
        if (bt) {
            const At = ht.offset
              , Et = ht.count;
            return b[_t + 6] = At,
            _e[vt + 14] = Et,
            _e[vt + 15] = IS_LEAFNODE_FLAG,
            pt + BYTES_PER_NODE
        }
        {
            const At = ht.left
              , Et = ht.right
              , Pt = ht.splitAxis;
            let It;
            if (It = ut(pt + BYTES_PER_NODE, At),
            It / 4 > Math.pow(2, 32))
                throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
            return b[_t + 6] = It / 4,
            It = ut(It, Et),
            b[_t + 7] = Pt,
            It
        }
    }
}
class OrientedBox {
    constructor(o, c, h) {
        this.isOrientedBox = !0,
        this.min = new three_module.Pq0,
        this.max = new three_module.Pq0,
        this.matrix = new three_module.kn4,
        this.invMatrix = new three_module.kn4,
        this.points = new Array(8).fill().map( () => new three_module.Pq0),
        this.satAxes = new Array(3).fill().map( () => new three_module.Pq0),
        this.satBounds = new Array(3).fill().map( () => new SeparatingAxisBounds),
        this.alignedSatBounds = new Array(3).fill().map( () => new SeparatingAxisBounds),
        this.needsUpdate = !1,
        o && this.min.copy(o),
        c && this.max.copy(c),
        h && this.matrix.copy(h)
    }
    set(o, c, h) {
        this.min.copy(o),
        this.max.copy(c),
        this.matrix.copy(h),
        this.needsUpdate = !0
    }
    copy(o) {
        this.min.copy(o.min),
        this.max.copy(o.max),
        this.matrix.copy(o.matrix),
        this.needsUpdate = !0
    }
}
OrientedBox.prototype.update = function() {
    const d = this.matrix
      , o = this.min
      , c = this.max
      , h = this.points;
    for (let it = 0; it <= 1; it++)
        for (let at = 0; at <= 1; at++)
            for (let ut = 0; ut <= 1; ut++) {
                const pt = h[1 * it | 2 * at | 4 * ut];
                pt.x = it ? c.x : o.x,
                pt.y = at ? c.y : o.y,
                pt.z = ut ? c.z : o.z,
                pt.applyMatrix4(d)
            }
    const _ = this.satBounds
      , b = this.satAxes
      , _e = h[0];
    for (let it = 0; it < 3; it++) {
        const at = b[it]
          , ut = _[it]
          , pt = h[1 << it];
        at.subVectors(_e, pt),
        ut.setFromPoints(at, h)
    }
    const nt = this.alignedSatBounds;
    nt[0].setFromPointsField(h, "x"),
    nt[1].setFromPointsField(h, "y"),
    nt[2].setFromPointsField(h, "z"),
    this.invMatrix.copy(this.matrix).invert(),
    this.needsUpdate = !1
}
,
OrientedBox.prototype.intersectsBox = function() {
    const d = new SeparatingAxisBounds;
    return function(o) {
        this.needsUpdate && this.update();
        const c = o.min
          , h = o.max
          , _ = this.satBounds
          , b = this.satAxes
          , _e = this.alignedSatBounds;
        if (d.min = c.x,
        d.max = h.x,
        _e[0].isSeparated(d) || (d.min = c.y,
        d.max = h.y,
        _e[1].isSeparated(d)) || (d.min = c.z,
        d.max = h.z,
        _e[2].isSeparated(d)))
            return !1;
        for (let nt = 0; nt < 3; nt++) {
            const it = b[nt]
              , at = _[nt];
            if (d.setFromBox(it, o),
            at.isSeparated(d))
                return !1
        }
        return !0
    }
}(),
OrientedBox.prototype.intersectsTriangle = function() {
    const d = new ExtendedTriangle
      , o = new Array(3)
      , c = new SeparatingAxisBounds
      , h = new SeparatingAxisBounds
      , _ = new three_module.Pq0;
    return function(b) {
        this.needsUpdate && this.update(),
        b.isExtendedTriangle ? b.needsUpdate && b.update() : (d.copy(b),
        d.update(),
        b = d);
        const _e = this.satBounds
          , nt = this.satAxes;
        o[0] = b.a,
        o[1] = b.b,
        o[2] = b.c;
        for (let pt = 0; pt < 3; pt++) {
            const ht = _e[pt]
              , _t = nt[pt];
            if (c.setFromPoints(_t, o),
            ht.isSeparated(c))
                return !1
        }
        const it = b.satBounds
          , at = b.satAxes
          , ut = this.points;
        for (let pt = 0; pt < 3; pt++) {
            const ht = it[pt]
              , _t = at[pt];
            if (c.setFromPoints(_t, ut),
            ht.isSeparated(c))
                return !1
        }
        for (let pt = 0; pt < 3; pt++) {
            const ht = nt[pt];
            for (let _t = 0; _t < 4; _t++) {
                const vt = at[_t];
                if (_.crossVectors(ht, vt),
                c.setFromPoints(_, o),
                h.setFromPoints(_, ut),
                c.isSeparated(h))
                    return !1
            }
        }
        return !0
    }
}(),
OrientedBox.prototype.closestPointToPoint = function(d, o) {
    return this.needsUpdate && this.update(),
    o.copy(d).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix),
    o
}
,
OrientedBox.prototype.distanceToPoint = function() {
    const d = new three_module.Pq0;
    return function(o) {
        return this.closestPointToPoint(o, d),
        o.distanceTo(d)
    }
}(),
OrientedBox.prototype.distanceToBox = function() {
    const d = ["x", "y", "z"]
      , o = new Array(12).fill().map( () => new three_module.cZY)
      , c = new Array(12).fill().map( () => new three_module.cZY)
      , h = new three_module.Pq0
      , _ = new three_module.Pq0;
    return function(b, _e=0, nt=null, it=null) {
        if (this.needsUpdate && this.update(),
        this.intersectsBox(b))
            return (nt || it) && (b.getCenter(_),
            this.closestPointToPoint(_, h),
            b.closestPointToPoint(h, _),
            nt && nt.copy(h),
            it && it.copy(_)),
            0;
        const at = _e * _e
          , ut = b.min
          , pt = b.max
          , ht = this.points;
        let _t = 1 / 0;
        for (let bt = 0; bt < 8; bt++) {
            const St = ht[bt];
            _.copy(St).clamp(ut, pt);
            const At = St.distanceToSquared(_);
            if (At < _t && (_t = At,
            nt && nt.copy(St),
            it && it.copy(_),
            At < at))
                return Math.sqrt(At)
        }
        let vt = 0;
        for (let bt = 0; bt < 3; bt++)
            for (let St = 0; St <= 1; St++)
                for (let At = 0; At <= 1; At++) {
                    const Et = (bt + 1) % 3
                      , Pt = (bt + 2) % 3
                      , It = 1 << bt | St << Et | At << Pt
                      , Dt = ht[St << Et | At << Pt]
                      , Gt = ht[It];
                    o[vt].set(Dt, Gt);
                    const Bt = d[bt]
                      , kt = d[Et]
                      , Ut = d[Pt]
                      , Ht = c[vt]
                      , Kt = Ht.start
                      , Jt = Ht.end;
                    Kt[Bt] = ut[Bt],
                    Kt[kt] = St ? ut[kt] : pt[kt],
                    Kt[Ut] = At ? ut[Ut] : pt[kt],
                    Jt[Bt] = pt[Bt],
                    Jt[kt] = St ? ut[kt] : pt[kt],
                    Jt[Ut] = At ? ut[Ut] : pt[kt],
                    vt++
                }
        for (let bt = 0; bt <= 1; bt++)
            for (let St = 0; St <= 1; St++)
                for (let At = 0; At <= 1; At++) {
                    _.x = bt ? pt.x : ut.x,
                    _.y = St ? pt.y : ut.y,
                    _.z = At ? pt.z : ut.z,
                    this.closestPointToPoint(_, h);
                    const Et = _.distanceToSquared(h);
                    if (Et < _t && (_t = Et,
                    nt && nt.copy(h),
                    it && it.copy(_),
                    Et < at))
                        return Math.sqrt(Et)
                }
        for (let bt = 0; bt < 12; bt++) {
            const St = o[bt];
            for (let At = 0; At < 12; At++) {
                const Et = c[At];
                closestPointsSegmentToSegment(St, Et, h, _);
                const Pt = h.distanceToSquared(_);
                if (Pt < _t && (_t = Pt,
                nt && nt.copy(h),
                it && it.copy(_),
                Pt < at))
                    return Math.sqrt(Pt)
            }
        }
        return Math.sqrt(_t)
    }
}();
class PrimitivePool {
    constructor(o) {
        this._getNewPrimitive = o,
        this._primitives = []
    }
    getPrimitive() {
        const o = this._primitives;
        return o.length === 0 ? this._getNewPrimitive() : o.pop()
    }
    releasePrimitive(o) {
        this._primitives.push(o)
    }
}
class ExtendedTrianglePoolBase extends PrimitivePool {
    constructor() {
        super( () => new ExtendedTriangle)
    }
}
const ExtendedTrianglePool = new ExtendedTrianglePoolBase;
function IS_LEAF(d, o) {
    return o[d + 15] === 65535
}
function OFFSET(d, o) {
    return o[d + 6]
}
function COUNT(d, o) {
    return o[d + 14]
}
function LEFT_NODE(d) {
    return d + 8
}
function RIGHT_NODE(d, o) {
    return o[d + 6]
}
function SPLIT_AXIS(d, o) {
    return o[d + 7]
}
function BOUNDING_DATA_INDEX(d) {
    return d
}
class _BufferStack {
    constructor() {
        this.float32Array = null,
        this.uint16Array = null,
        this.uint32Array = null;
        const o = [];
        let c = null;
        this.setBuffer = h => {
            c && o.push(c),
            c = h,
            this.float32Array = new Float32Array(h),
            this.uint16Array = new Uint16Array(h),
            this.uint32Array = new Uint32Array(h)
        }
        ,
        this.clearBuffer = () => {
            c = null,
            this.float32Array = null,
            this.uint16Array = null,
            this.uint32Array = null,
            o.length !== 0 && this.setBuffer(o.pop())
        }
    }
}
const BufferStack = new _BufferStack;
let _box1, _box2;
const boxStack = []
  , boxPool = new PrimitivePool( () => new three_module.NRn);
function shapecast(d, o, c, h, _, b) {
    _box1 = boxPool.getPrimitive(),
    _box2 = boxPool.getPrimitive(),
    boxStack.push(_box1, _box2),
    BufferStack.setBuffer(d._roots[o]);
    const _e = shapecastTraverse(0, d.geometry, c, h, _, b);
    BufferStack.clearBuffer(),
    boxPool.releasePrimitive(_box1),
    boxPool.releasePrimitive(_box2),
    boxStack.pop(),
    boxStack.pop();
    const nt = boxStack.length;
    return nt > 0 && (_box2 = boxStack[nt - 1],
    _box1 = boxStack[nt - 2]),
    _e
}
function shapecastTraverse(d, o, c, h, _=null, b=0, _e=0) {
    const {float32Array: nt, uint16Array: it, uint32Array: at} = BufferStack;
    let ut = 2 * d;
    if (IS_LEAF(ut, it)) {
        const pt = OFFSET(d, at)
          , ht = COUNT(ut, it);
        return arrayToBox(d, nt, _box1),
        h(pt, ht, !1, _e, b + d, _box1)
    }
    {
        let Bt = function(Ut) {
            const {uint16Array: Ht, uint32Array: Kt} = BufferStack;
            let Jt = 2 * Ut;
            for (; !IS_LEAF(Jt, Ht); )
                Jt = 2 * (Ut = LEFT_NODE(Ut));
            return OFFSET(Ut, Kt)
        }
          , kt = function(Ut) {
            const {uint16Array: Ht, uint32Array: Kt} = BufferStack;
            let Jt = 2 * Ut;
            for (; !IS_LEAF(Jt, Ht); )
                Jt = 2 * (Ut = RIGHT_NODE(Ut, Kt));
            return OFFSET(Ut, Kt) + COUNT(Jt, Ht)
        };
        const pt = LEFT_NODE(d)
          , ht = RIGHT_NODE(d, at);
        let _t, vt, bt, St, At = pt, Et = ht;
        if (_ && (bt = _box1,
        St = _box2,
        arrayToBox(At, nt, bt),
        arrayToBox(Et, nt, St),
        _t = _(bt),
        vt = _(St),
        vt < _t)) {
            At = ht,
            Et = pt;
            const Ut = _t;
            _t = vt,
            vt = Ut,
            bt = St
        }
        bt || (bt = _box1,
        arrayToBox(At, nt, bt));
        const Pt = c(bt, IS_LEAF(2 * At, it), _t, _e + 1, b + At);
        let It;
        if (Pt === CONTAINED) {
            const Ut = Bt(At);
            It = h(Ut, kt(At) - Ut, !0, _e + 1, b + At, bt)
        } else
            It = Pt && shapecastTraverse(At, o, c, h, _, b, _e + 1);
        if (It)
            return !0;
        St = _box2,
        arrayToBox(Et, nt, St);
        const Dt = c(St, IS_LEAF(2 * Et, it), vt, _e + 1, b + Et);
        let Gt;
        if (Dt === CONTAINED) {
            const Ut = Bt(Et);
            Gt = h(Ut, kt(Et) - Ut, !0, _e + 1, b + Et, St)
        } else
            Gt = Dt && shapecastTraverse(Et, o, c, h, _, b, _e + 1);
        return !!Gt
    }
}
const temp = new three_module.Pq0
  , temp1 = new three_module.Pq0;
function closestPointToPoint(d, o, c={}, h=0, _=1 / 0) {
    const b = h * h
      , _e = _ * _;
    let nt = 1 / 0
      , it = null;
    if (d.shapecast({
        boundsTraverseOrder: ut => (temp.copy(o).clamp(ut.min, ut.max),
        temp.distanceToSquared(o)),
        intersectsBounds: (ut, pt, ht) => ht < nt && ht < _e,
        intersectsTriangle: (ut, pt) => {
            ut.closestPointToPoint(o, temp);
            const ht = o.distanceToSquared(temp);
            return ht < nt && (temp1.copy(temp),
            nt = ht,
            it = pt),
            ht < b
        }
    }),
    nt === 1 / 0)
        return null;
    const at = Math.sqrt(nt);
    return c.point ? c.point.copy(temp1) : c.point = temp1.clone(),
    c.distance = at,
    c.faceIndex = it,
    c
}
const ThreeRayIntersectUtilities_vA = new three_module.Pq0
  , ThreeRayIntersectUtilities_vB = new three_module.Pq0
  , ThreeRayIntersectUtilities_vC = new three_module.Pq0
  , _uvA = new three_module.I9Y
  , _uvB = new three_module.I9Y
  , _uvC = new three_module.I9Y
  , _normalA = new three_module.Pq0
  , _normalB = new three_module.Pq0
  , _normalC = new three_module.Pq0
  , _intersectionPoint = new three_module.Pq0;
function checkIntersection(d, o, c, h, _, b) {
    let _e;
    return _e = b === three_module.hsX ? d.intersectTriangle(h, c, o, !0, _) : d.intersectTriangle(o, c, h, b !== three_module.$EB, _),
    _e === null ? null : {
        distance: d.origin.distanceTo(_),
        point: _.clone()
    }
}
function checkBufferGeometryIntersection(d, o, c, h, _, b, _e, nt, it) {
    ThreeRayIntersectUtilities_vA.fromBufferAttribute(o, b),
    ThreeRayIntersectUtilities_vB.fromBufferAttribute(o, _e),
    ThreeRayIntersectUtilities_vC.fromBufferAttribute(o, nt);
    const at = checkIntersection(d, ThreeRayIntersectUtilities_vA, ThreeRayIntersectUtilities_vB, ThreeRayIntersectUtilities_vC, _intersectionPoint, it);
    if (at) {
        h && (_uvA.fromBufferAttribute(h, b),
        _uvB.fromBufferAttribute(h, _e),
        _uvC.fromBufferAttribute(h, nt),
        at.uv = three_module.lMl.getInterpolation(_intersectionPoint, ThreeRayIntersectUtilities_vA, ThreeRayIntersectUtilities_vB, ThreeRayIntersectUtilities_vC, _uvA, _uvB, _uvC, new three_module.I9Y)),
        _ && (_uvA.fromBufferAttribute(_, b),
        _uvB.fromBufferAttribute(_, _e),
        _uvC.fromBufferAttribute(_, nt),
        at.uv1 = three_module.lMl.getInterpolation(_intersectionPoint, ThreeRayIntersectUtilities_vA, ThreeRayIntersectUtilities_vB, ThreeRayIntersectUtilities_vC, _uvA, _uvB, _uvC, new three_module.I9Y)),
        c && (_normalA.fromBufferAttribute(c, b),
        _normalB.fromBufferAttribute(c, _e),
        _normalC.fromBufferAttribute(c, nt),
        at.normal = three_module.lMl.getInterpolation(_intersectionPoint, ThreeRayIntersectUtilities_vA, ThreeRayIntersectUtilities_vB, ThreeRayIntersectUtilities_vC, _normalA, _normalB, _normalC, new three_module.Pq0),
        at.normal.dot(d.direction) > 0 && at.normal.multiplyScalar(-1));
        const ut = {
            a: b,
            b: _e,
            c: nt,
            normal: new three_module.Pq0,
            materialIndex: 0
        };
        three_module.lMl.getNormal(ThreeRayIntersectUtilities_vA, ThreeRayIntersectUtilities_vB, ThreeRayIntersectUtilities_vC, ut.normal),
        at.face = ut,
        at.faceIndex = b
    }
    return at
}
function intersectTri(d, o, c, h, _) {
    const b = 3 * h;
    let _e = b + 0
      , nt = b + 1
      , it = b + 2;
    const at = d.index;
    d.index && (_e = at.getX(_e),
    nt = at.getX(nt),
    it = at.getX(it));
    const {position: ut, normal: pt, uv: ht, uv1: _t} = d.attributes
      , vt = checkBufferGeometryIntersection(c, ut, pt, ht, _t, _e, nt, it, o);
    return vt ? (vt.faceIndex = h,
    _ && _.push(vt),
    vt) : null
}
function setTriangle(d, o, c, h) {
    const _ = d.a
      , b = d.b
      , _e = d.c;
    let nt = o
      , it = o + 1
      , at = o + 2;
    c && (nt = c.getX(nt),
    it = c.getX(it),
    at = c.getX(at)),
    _.x = h.getX(nt),
    _.y = h.getY(nt),
    _.z = h.getZ(nt),
    b.x = h.getX(it),
    b.y = h.getY(it),
    b.z = h.getZ(it),
    _e.x = h.getX(at),
    _e.y = h.getY(at),
    _e.z = h.getZ(at)
}
new three_module.Pq0;
new three_module.Pq0;
new three_module.Pq0;
new three_module.I9Y;
new three_module.I9Y;
new three_module.I9Y;
function intersectTris(d, o, c, h, _, b) {
    const {geometry: _e, _indirectBuffer: nt} = d;
    for (let it = h, at = h + _; it < at; it++)
        intersectTri(_e, o, c, it, b)
}
function intersectClosestTri(d, o, c, h, _) {
    const {geometry: b, _indirectBuffer: _e} = d;
    let nt = 1 / 0
      , it = null;
    for (let at = h, ut = h + _; at < ut; at++) {
        let pt;
        pt = intersectTri(b, o, c, at),
        pt && pt.distance < nt && (it = pt,
        nt = pt.distance)
    }
    return it
}
function iterateOverTriangles(d, o, c, h, _, b, _e) {
    const {geometry: nt} = c
      , {index: it} = nt
      , at = nt.attributes.position;
    for (let ut = d, pt = o + d; ut < pt; ut++) {
        let ht;
        if (ht = ut,
        setTriangle(_e, 3 * ht, it, at),
        _e.needsUpdate = !0,
        h(_e, ht, _, b))
            return !0
    }
    return !1
}
function refit(d, o=null) {
    o && Array.isArray(o) && (o = new Set(o));
    const c = d.geometry
      , h = c.index ? c.index.array : null
      , _ = c.attributes.position;
    let b, _e, nt, it, at = 0;
    const ut = d._roots;
    for (let ht = 0, _t = ut.length; ht < _t; ht++)
        b = ut[ht],
        _e = new Uint32Array(b),
        nt = new Uint16Array(b),
        it = new Float32Array(b),
        pt(0, at),
        at += b.byteLength;
    function pt(ht, _t, vt=!1) {
        const bt = 2 * ht;
        if (nt[bt + 15] === IS_LEAFNODE_FLAG) {
            const St = _e[ht + 6];
            let At = 1 / 0
              , Et = 1 / 0
              , Pt = 1 / 0
              , It = -1 / 0
              , Dt = -1 / 0
              , Gt = -1 / 0;
            for (let Bt = 3 * St, kt = 3 * (St + nt[bt + 14]); Bt < kt; Bt++) {
                let Ut = h[Bt];
                const Ht = _.getX(Ut)
                  , Kt = _.getY(Ut)
                  , Jt = _.getZ(Ut);
                Ht < At && (At = Ht),
                Ht > It && (It = Ht),
                Kt < Et && (Et = Kt),
                Kt > Dt && (Dt = Kt),
                Jt < Pt && (Pt = Jt),
                Jt > Gt && (Gt = Jt)
            }
            return (it[ht + 0] !== At || it[ht + 1] !== Et || it[ht + 2] !== Pt || it[ht + 3] !== It || it[ht + 4] !== Dt || it[ht + 5] !== Gt) && (it[ht + 0] = At,
            it[ht + 1] = Et,
            it[ht + 2] = Pt,
            it[ht + 3] = It,
            it[ht + 4] = Dt,
            it[ht + 5] = Gt,
            !0)
        }
        {
            const St = ht + 8
              , At = _e[ht + 6]
              , Et = St + _t
              , Pt = At + _t;
            let It = vt
              , Dt = !1
              , Gt = !1;
            o ? It || (Dt = o.has(Et),
            Gt = o.has(Pt),
            It = !Dt && !Gt) : (Dt = !0,
            Gt = !0);
            const Bt = It || Gt;
            let kt = !1;
            (It || Dt) && (kt = pt(St, _t, It));
            let Ut = !1;
            Bt && (Ut = pt(At, _t, It));
            const Ht = kt || Ut;
            if (Ht)
                for (let Kt = 0; Kt < 3; Kt++) {
                    const Jt = St + Kt
                      , or = At + Kt
                      , ir = it[Jt]
                      , lr = it[Jt + 3]
                      , ar = it[or]
                      , hr = it[or + 3];
                    it[ht + Kt] = ir < ar ? ir : ar,
                    it[ht + Kt + 3] = lr > hr ? lr : hr
                }
            return Ht
        }
    }
}
const _boundingBox = new three_module.NRn;
function intersectRay(d, o, c, h) {
    return arrayToBox(d, o, _boundingBox),
    c.intersectBox(_boundingBox, h)
}
const _boxIntersection = new three_module.Pq0;
function raycast(d, o, c, h, _) {
    BufferStack.setBuffer(d._roots[o]),
    _raycast(0, d, c, h, _),
    BufferStack.clearBuffer()
}
function _raycast(d, o, c, h, _) {
    const {float32Array: b, uint16Array: _e, uint32Array: nt} = BufferStack
      , it = 2 * d;
    if (IS_LEAF(it, _e))
        intersectTris(o, c, h, OFFSET(d, nt), COUNT(it, _e), _);
    else {
        const at = LEFT_NODE(d);
        intersectRay(at, b, h, _boxIntersection) && _raycast(at, o, c, h, _);
        const ut = RIGHT_NODE(d, nt);
        intersectRay(ut, b, h, _boxIntersection) && _raycast(ut, o, c, h, _)
    }
}
const raycastFirst_generated_boxIntersection = new three_module.Pq0
  , _xyzFields = ["x", "y", "z"];
function raycastFirst(d, o, c, h) {
    BufferStack.setBuffer(d._roots[o]);
    const _ = _raycastFirst(0, d, c, h);
    return BufferStack.clearBuffer(),
    _
}
function _raycastFirst(d, o, c, h) {
    const {float32Array: _, uint16Array: b, uint32Array: _e} = BufferStack;
    let nt = 2 * d;
    if (IS_LEAF(nt, b))
        return intersectClosestTri(o, c, h, OFFSET(d, _e), COUNT(nt, b));
    {
        const it = SPLIT_AXIS(d, _e)
          , at = _xyzFields[it]
          , ut = h.direction[at] >= 0;
        let pt, ht;
        ut ? (pt = LEFT_NODE(d),
        ht = RIGHT_NODE(d, _e)) : (pt = RIGHT_NODE(d, _e),
        ht = LEFT_NODE(d));
        const _t = intersectRay(pt, _, h, raycastFirst_generated_boxIntersection) ? _raycastFirst(pt, o, c, h) : null;
        if (_t) {
            const bt = _t.point[at];
            if (ut ? bt <= _[ht + it] : bt >= _[ht + it + 3])
                return _t
        }
        const vt = intersectRay(ht, _, h, raycastFirst_generated_boxIntersection) ? _raycastFirst(ht, o, c, h) : null;
        return _t && vt ? _t.distance <= vt.distance ? _t : vt : _t || vt || null
    }
}
const boundingBox = new three_module.NRn
  , triangle = new ExtendedTriangle
  , triangle2 = new ExtendedTriangle
  , invertedMat = new three_module.kn4
  , obb = new OrientedBox
  , obb2 = new OrientedBox;
function intersectsGeometry(d, o, c, h) {
    BufferStack.setBuffer(d._roots[o]);
    const _ = _intersectsGeometry(0, d, c, h);
    return BufferStack.clearBuffer(),
    _
}
function _intersectsGeometry(d, o, c, h, _=null) {
    const {float32Array: b, uint16Array: _e, uint32Array: nt} = BufferStack;
    let it = 2 * d;
    if (_ === null && (c.boundingBox || c.computeBoundingBox(),
    obb.set(c.boundingBox.min, c.boundingBox.max, h),
    _ = obb),
    !IS_LEAF(it, _e)) {
        const at = d + 8
          , ut = nt[d + 6];
        return arrayToBox(at, b, boundingBox),
        _.intersectsBox(boundingBox) && _intersectsGeometry(at, o, c, h, _) ? !0 : (arrayToBox(ut, b, boundingBox),
        !(!_.intersectsBox(boundingBox) || !_intersectsGeometry(ut, o, c, h, _)))
    }
    {
        const at = o.geometry
          , ut = at.index
          , pt = at.attributes.position
          , ht = c.index
          , _t = c.attributes.position
          , vt = OFFSET(d, nt)
          , bt = COUNT(it, _e);
        if (invertedMat.copy(h).invert(),
        c.boundsTree)
            return arrayToBox(d, b, obb2),
            obb2.matrix.copy(invertedMat),
            obb2.needsUpdate = !0,
            c.boundsTree.shapecast({
                intersectsBounds: At => obb2.intersectsBox(At),
                intersectsTriangle: At => {
                    At.a.applyMatrix4(h),
                    At.b.applyMatrix4(h),
                    At.c.applyMatrix4(h),
                    At.needsUpdate = !0;
                    for (let Et = 3 * vt, Pt = 3 * (bt + vt); Et < Pt; Et += 3)
                        if (setTriangle(triangle2, Et, ut, pt),
                        triangle2.needsUpdate = !0,
                        At.intersectsTriangle(triangle2))
                            return !0;
                    return !1
                }
            });
        for (let St = 3 * vt, At = 3 * (bt + vt); St < At; St += 3) {
            setTriangle(triangle, St, ut, pt),
            triangle.a.applyMatrix4(invertedMat),
            triangle.b.applyMatrix4(invertedMat),
            triangle.c.applyMatrix4(invertedMat),
            triangle.needsUpdate = !0;
            for (let Et = 0, Pt = ht.count; Et < Pt; Et += 3)
                if (setTriangle(triangle2, Et, ht, _t),
                triangle2.needsUpdate = !0,
                triangle.intersectsTriangle(triangle2))
                    return !0
        }
    }
}
const tempMatrix = new three_module.kn4
  , closestPointToGeometry_generated_obb = new OrientedBox
  , closestPointToGeometry_generated_obb2 = new OrientedBox
  , closestPointToGeometry_generated_temp1 = new three_module.Pq0
  , temp2 = new three_module.Pq0
  , temp3 = new three_module.Pq0
  , temp4 = new three_module.Pq0;
function closestPointToGeometry(d, o, c, h={}, _={}, b=0, _e=1 / 0) {
    o.boundingBox || o.computeBoundingBox(),
    closestPointToGeometry_generated_obb.set(o.boundingBox.min, o.boundingBox.max, c),
    closestPointToGeometry_generated_obb.needsUpdate = !0;
    const nt = d.geometry
      , it = nt.attributes.position
      , at = nt.index
      , ut = o.attributes.position
      , pt = o.index
      , ht = ExtendedTrianglePool.getPrimitive()
      , _t = ExtendedTrianglePool.getPrimitive();
    let vt = closestPointToGeometry_generated_temp1
      , bt = temp2
      , St = null
      , At = null;
    _ && (St = temp3,
    At = temp4);
    let Et = 1 / 0
      , Pt = null
      , It = null;
    return tempMatrix.copy(c).invert(),
    closestPointToGeometry_generated_obb2.matrix.copy(tempMatrix),
    d.shapecast({
        boundsTraverseOrder: Dt => closestPointToGeometry_generated_obb.distanceToBox(Dt),
        intersectsBounds: (Dt, Gt, Bt) => Bt < Et && Bt < _e && (Gt && (closestPointToGeometry_generated_obb2.min.copy(Dt.min),
        closestPointToGeometry_generated_obb2.max.copy(Dt.max),
        closestPointToGeometry_generated_obb2.needsUpdate = !0),
        !0),
        intersectsRange: (Dt, Gt) => {
            if (o.boundsTree)
                return o.boundsTree.shapecast({
                    boundsTraverseOrder: Bt => closestPointToGeometry_generated_obb2.distanceToBox(Bt),
                    intersectsBounds: (Bt, kt, Ut) => Ut < Et && Ut < _e,
                    intersectsRange: (Bt, kt) => {
                        for (let Ut = Bt, Ht = Bt + kt; Ut < Ht; Ut++) {
                            setTriangle(_t, 3 * Ut, pt, ut),
                            _t.a.applyMatrix4(c),
                            _t.b.applyMatrix4(c),
                            _t.c.applyMatrix4(c),
                            _t.needsUpdate = !0;
                            for (let Kt = Dt, Jt = Dt + Gt; Kt < Jt; Kt++) {
                                setTriangle(ht, 3 * Kt, at, it),
                                ht.needsUpdate = !0;
                                const or = ht.distanceToTriangle(_t, vt, St);
                                if (or < Et && (bt.copy(vt),
                                At && At.copy(St),
                                Et = or,
                                Pt = Kt,
                                It = Ut),
                                or < b)
                                    return !0
                            }
                        }
                    }
                });
            for (let Bt = 0, kt = geometryUtils_getTriCount(o); Bt < kt; Bt++) {
                setTriangle(_t, 3 * Bt, pt, ut),
                _t.a.applyMatrix4(c),
                _t.b.applyMatrix4(c),
                _t.c.applyMatrix4(c),
                _t.needsUpdate = !0;
                for (let Ut = Dt, Ht = Dt + Gt; Ut < Ht; Ut++) {
                    setTriangle(ht, 3 * Ut, at, it),
                    ht.needsUpdate = !0;
                    const Kt = ht.distanceToTriangle(_t, vt, St);
                    if (Kt < Et && (bt.copy(vt),
                    At && At.copy(St),
                    Et = Kt,
                    Pt = Ut,
                    It = Bt),
                    Kt < b)
                        return !0
                }
            }
        }
    }),
    ExtendedTrianglePool.releasePrimitive(ht),
    ExtendedTrianglePool.releasePrimitive(_t),
    Et === 1 / 0 ? null : (h.point ? h.point.copy(bt) : h.point = bt.clone(),
    h.distance = Et,
    h.faceIndex = Pt,
    _ && (_.point ? _.point.copy(At) : _.point = At.clone(),
    _.point.applyMatrix4(tempMatrix),
    bt.applyMatrix4(tempMatrix),
    _.distance = bt.sub(_.point).length(),
    _.faceIndex = It),
    h)
}
function intersectTris_indirect(d, o, c, h, _, b) {
    const {geometry: _e, _indirectBuffer: nt} = d;
    for (let it = h, at = h + _; it < at; it++)
        intersectTri(_e, o, c, nt ? nt[it] : it, b)
}
function intersectClosestTri_indirect(d, o, c, h, _) {
    const {geometry: b, _indirectBuffer: _e} = d;
    let nt = 1 / 0
      , it = null;
    for (let at = h, ut = h + _; at < ut; at++) {
        let pt;
        pt = intersectTri(b, o, c, _e ? _e[at] : at),
        pt && pt.distance < nt && (it = pt,
        nt = pt.distance)
    }
    return it
}
function iterateOverTriangles_indirect(d, o, c, h, _, b, _e) {
    const {geometry: nt} = c
      , {index: it} = nt
      , at = nt.attributes.position;
    for (let ut = d, pt = o + d; ut < pt; ut++) {
        let ht;
        if (ht = c.resolveTriangleIndex(ut),
        setTriangle(_e, 3 * ht, it, at),
        _e.needsUpdate = !0,
        h(_e, ht, _, b))
            return !0
    }
    return !1
}
function refit_indirect(d, o=null) {
    o && Array.isArray(o) && (o = new Set(o));
    const c = d.geometry
      , h = c.index ? c.index.array : null
      , _ = c.attributes.position;
    let b, _e, nt, it, at = 0;
    const ut = d._roots;
    for (let ht = 0, _t = ut.length; ht < _t; ht++)
        b = ut[ht],
        _e = new Uint32Array(b),
        nt = new Uint16Array(b),
        it = new Float32Array(b),
        pt(0, at),
        at += b.byteLength;
    function pt(ht, _t, vt=!1) {
        const bt = 2 * ht;
        if (nt[bt + 15] === IS_LEAFNODE_FLAG) {
            const St = _e[ht + 6];
            let At = 1 / 0
              , Et = 1 / 0
              , Pt = 1 / 0
              , It = -1 / 0
              , Dt = -1 / 0
              , Gt = -1 / 0;
            for (let Bt = St, kt = St + nt[bt + 14]; Bt < kt; Bt++) {
                const Ut = 3 * d.resolveTriangleIndex(Bt);
                for (let Ht = 0; Ht < 3; Ht++) {
                    let Kt = Ut + Ht;
                    Kt = h ? h[Kt] : Kt;
                    const Jt = _.getX(Kt)
                      , or = _.getY(Kt)
                      , ir = _.getZ(Kt);
                    Jt < At && (At = Jt),
                    Jt > It && (It = Jt),
                    or < Et && (Et = or),
                    or > Dt && (Dt = or),
                    ir < Pt && (Pt = ir),
                    ir > Gt && (Gt = ir)
                }
            }
            return (it[ht + 0] !== At || it[ht + 1] !== Et || it[ht + 2] !== Pt || it[ht + 3] !== It || it[ht + 4] !== Dt || it[ht + 5] !== Gt) && (it[ht + 0] = At,
            it[ht + 1] = Et,
            it[ht + 2] = Pt,
            it[ht + 3] = It,
            it[ht + 4] = Dt,
            it[ht + 5] = Gt,
            !0)
        }
        {
            const St = ht + 8
              , At = _e[ht + 6]
              , Et = St + _t
              , Pt = At + _t;
            let It = vt
              , Dt = !1
              , Gt = !1;
            o ? It || (Dt = o.has(Et),
            Gt = o.has(Pt),
            It = !Dt && !Gt) : (Dt = !0,
            Gt = !0);
            const Bt = It || Gt;
            let kt = !1;
            (It || Dt) && (kt = pt(St, _t, It));
            let Ut = !1;
            Bt && (Ut = pt(At, _t, It));
            const Ht = kt || Ut;
            if (Ht)
                for (let Kt = 0; Kt < 3; Kt++) {
                    const Jt = St + Kt
                      , or = At + Kt
                      , ir = it[Jt]
                      , lr = it[Jt + 3]
                      , ar = it[or]
                      , hr = it[or + 3];
                    it[ht + Kt] = ir < ar ? ir : ar,
                    it[ht + Kt + 3] = lr > hr ? lr : hr
                }
            return Ht
        }
    }
}
const raycast_indirect_generated_boxIntersection = new three_module.Pq0;
function raycast_indirect(d, o, c, h, _) {
    BufferStack.setBuffer(d._roots[o]),
    raycast_indirect_generated_raycast(0, d, c, h, _),
    BufferStack.clearBuffer()
}
function raycast_indirect_generated_raycast(d, o, c, h, _) {
    const {float32Array: b, uint16Array: _e, uint32Array: nt} = BufferStack
      , it = 2 * d;
    if (IS_LEAF(it, _e))
        intersectTris_indirect(o, c, h, OFFSET(d, nt), COUNT(it, _e), _);
    else {
        const at = LEFT_NODE(d);
        intersectRay(at, b, h, raycast_indirect_generated_boxIntersection) && raycast_indirect_generated_raycast(at, o, c, h, _);
        const ut = RIGHT_NODE(d, nt);
        intersectRay(ut, b, h, raycast_indirect_generated_boxIntersection) && raycast_indirect_generated_raycast(ut, o, c, h, _)
    }
}
const raycastFirst_indirect_generated_boxIntersection = new three_module.Pq0
  , raycastFirst_indirect_generated_xyzFields = ["x", "y", "z"];
function raycastFirst_indirect(d, o, c, h) {
    BufferStack.setBuffer(d._roots[o]);
    const _ = raycastFirst_indirect_generated_raycastFirst(0, d, c, h);
    return BufferStack.clearBuffer(),
    _
}
function raycastFirst_indirect_generated_raycastFirst(d, o, c, h) {
    const {float32Array: _, uint16Array: b, uint32Array: _e} = BufferStack;
    let nt = 2 * d;
    if (IS_LEAF(nt, b))
        return intersectClosestTri_indirect(o, c, h, OFFSET(d, _e), COUNT(nt, b));
    {
        const it = SPLIT_AXIS(d, _e)
          , at = raycastFirst_indirect_generated_xyzFields[it]
          , ut = h.direction[at] >= 0;
        let pt, ht;
        ut ? (pt = LEFT_NODE(d),
        ht = RIGHT_NODE(d, _e)) : (pt = RIGHT_NODE(d, _e),
        ht = LEFT_NODE(d));
        const _t = intersectRay(pt, _, h, raycastFirst_indirect_generated_boxIntersection) ? raycastFirst_indirect_generated_raycastFirst(pt, o, c, h) : null;
        if (_t) {
            const bt = _t.point[at];
            if (ut ? bt <= _[ht + it] : bt >= _[ht + it + 3])
                return _t
        }
        const vt = intersectRay(ht, _, h, raycastFirst_indirect_generated_boxIntersection) ? raycastFirst_indirect_generated_raycastFirst(ht, o, c, h) : null;
        return _t && vt ? _t.distance <= vt.distance ? _t : vt : _t || vt || null
    }
}
const intersectsGeometry_indirect_generated_boundingBox = new three_module.NRn
  , intersectsGeometry_indirect_generated_triangle = new ExtendedTriangle
  , intersectsGeometry_indirect_generated_triangle2 = new ExtendedTriangle
  , intersectsGeometry_indirect_generated_invertedMat = new three_module.kn4
  , intersectsGeometry_indirect_generated_obb = new OrientedBox
  , intersectsGeometry_indirect_generated_obb2 = new OrientedBox;
function intersectsGeometry_indirect(d, o, c, h) {
    BufferStack.setBuffer(d._roots[o]);
    const _ = intersectsGeometry_indirect_generated_intersectsGeometry(0, d, c, h);
    return BufferStack.clearBuffer(),
    _
}
function intersectsGeometry_indirect_generated_intersectsGeometry(d, o, c, h, _=null) {
    const {float32Array: b, uint16Array: _e, uint32Array: nt} = BufferStack;
    let it = 2 * d;
    if (_ === null && (c.boundingBox || c.computeBoundingBox(),
    intersectsGeometry_indirect_generated_obb.set(c.boundingBox.min, c.boundingBox.max, h),
    _ = intersectsGeometry_indirect_generated_obb),
    !IS_LEAF(it, _e)) {
        const at = d + 8
          , ut = nt[d + 6];
        return arrayToBox(at, b, intersectsGeometry_indirect_generated_boundingBox),
        _.intersectsBox(intersectsGeometry_indirect_generated_boundingBox) && intersectsGeometry_indirect_generated_intersectsGeometry(at, o, c, h, _) ? !0 : (arrayToBox(ut, b, intersectsGeometry_indirect_generated_boundingBox),
        !(!_.intersectsBox(intersectsGeometry_indirect_generated_boundingBox) || !intersectsGeometry_indirect_generated_intersectsGeometry(ut, o, c, h, _)))
    }
    {
        const at = o.geometry
          , ut = at.index
          , pt = at.attributes.position
          , ht = c.index
          , _t = c.attributes.position
          , vt = OFFSET(d, nt)
          , bt = COUNT(it, _e);
        if (intersectsGeometry_indirect_generated_invertedMat.copy(h).invert(),
        c.boundsTree)
            return arrayToBox(d, b, intersectsGeometry_indirect_generated_obb2),
            intersectsGeometry_indirect_generated_obb2.matrix.copy(intersectsGeometry_indirect_generated_invertedMat),
            intersectsGeometry_indirect_generated_obb2.needsUpdate = !0,
            c.boundsTree.shapecast({
                intersectsBounds: At => intersectsGeometry_indirect_generated_obb2.intersectsBox(At),
                intersectsTriangle: At => {
                    At.a.applyMatrix4(h),
                    At.b.applyMatrix4(h),
                    At.c.applyMatrix4(h),
                    At.needsUpdate = !0;
                    for (let Et = vt, Pt = bt + vt; Et < Pt; Et++)
                        if (setTriangle(intersectsGeometry_indirect_generated_triangle2, 3 * o.resolveTriangleIndex(Et), ut, pt),
                        intersectsGeometry_indirect_generated_triangle2.needsUpdate = !0,
                        At.intersectsTriangle(intersectsGeometry_indirect_generated_triangle2))
                            return !0;
                    return !1
                }
            });
        for (let St = vt, At = bt + vt; St < At; St++) {
            const Et = o.resolveTriangleIndex(St);
            setTriangle(intersectsGeometry_indirect_generated_triangle, 3 * Et, ut, pt),
            intersectsGeometry_indirect_generated_triangle.a.applyMatrix4(intersectsGeometry_indirect_generated_invertedMat),
            intersectsGeometry_indirect_generated_triangle.b.applyMatrix4(intersectsGeometry_indirect_generated_invertedMat),
            intersectsGeometry_indirect_generated_triangle.c.applyMatrix4(intersectsGeometry_indirect_generated_invertedMat),
            intersectsGeometry_indirect_generated_triangle.needsUpdate = !0;
            for (let Pt = 0, It = ht.count; Pt < It; Pt += 3)
                if (setTriangle(intersectsGeometry_indirect_generated_triangle2, Pt, ht, _t),
                intersectsGeometry_indirect_generated_triangle2.needsUpdate = !0,
                intersectsGeometry_indirect_generated_triangle.intersectsTriangle(intersectsGeometry_indirect_generated_triangle2))
                    return !0
        }
    }
}
const closestPointToGeometry_indirect_generated_tempMatrix = new three_module.kn4
  , closestPointToGeometry_indirect_generated_obb = new OrientedBox
  , closestPointToGeometry_indirect_generated_obb2 = new OrientedBox
  , closestPointToGeometry_indirect_generated_temp1 = new three_module.Pq0
  , closestPointToGeometry_indirect_generated_temp2 = new three_module.Pq0
  , closestPointToGeometry_indirect_generated_temp3 = new three_module.Pq0
  , closestPointToGeometry_indirect_generated_temp4 = new three_module.Pq0;
function closestPointToGeometry_indirect(d, o, c, h={}, _={}, b=0, _e=1 / 0) {
    o.boundingBox || o.computeBoundingBox(),
    closestPointToGeometry_indirect_generated_obb.set(o.boundingBox.min, o.boundingBox.max, c),
    closestPointToGeometry_indirect_generated_obb.needsUpdate = !0;
    const nt = d.geometry
      , it = nt.attributes.position
      , at = nt.index
      , ut = o.attributes.position
      , pt = o.index
      , ht = ExtendedTrianglePool.getPrimitive()
      , _t = ExtendedTrianglePool.getPrimitive();
    let vt = closestPointToGeometry_indirect_generated_temp1
      , bt = closestPointToGeometry_indirect_generated_temp2
      , St = null
      , At = null;
    _ && (St = closestPointToGeometry_indirect_generated_temp3,
    At = closestPointToGeometry_indirect_generated_temp4);
    let Et = 1 / 0
      , Pt = null
      , It = null;
    return closestPointToGeometry_indirect_generated_tempMatrix.copy(c).invert(),
    closestPointToGeometry_indirect_generated_obb2.matrix.copy(closestPointToGeometry_indirect_generated_tempMatrix),
    d.shapecast({
        boundsTraverseOrder: Dt => closestPointToGeometry_indirect_generated_obb.distanceToBox(Dt),
        intersectsBounds: (Dt, Gt, Bt) => Bt < Et && Bt < _e && (Gt && (closestPointToGeometry_indirect_generated_obb2.min.copy(Dt.min),
        closestPointToGeometry_indirect_generated_obb2.max.copy(Dt.max),
        closestPointToGeometry_indirect_generated_obb2.needsUpdate = !0),
        !0),
        intersectsRange: (Dt, Gt) => {
            if (o.boundsTree) {
                const Bt = o.boundsTree;
                return Bt.shapecast({
                    boundsTraverseOrder: kt => closestPointToGeometry_indirect_generated_obb2.distanceToBox(kt),
                    intersectsBounds: (kt, Ut, Ht) => Ht < Et && Ht < _e,
                    intersectsRange: (kt, Ut) => {
                        for (let Ht = kt, Kt = kt + Ut; Ht < Kt; Ht++) {
                            const Jt = Bt.resolveTriangleIndex(Ht);
                            setTriangle(_t, 3 * Jt, pt, ut),
                            _t.a.applyMatrix4(c),
                            _t.b.applyMatrix4(c),
                            _t.c.applyMatrix4(c),
                            _t.needsUpdate = !0;
                            for (let or = Dt, ir = Dt + Gt; or < ir; or++) {
                                const lr = d.resolveTriangleIndex(or);
                                setTriangle(ht, 3 * lr, at, it),
                                ht.needsUpdate = !0;
                                const ar = ht.distanceToTriangle(_t, vt, St);
                                if (ar < Et && (bt.copy(vt),
                                At && At.copy(St),
                                Et = ar,
                                Pt = or,
                                It = Ht),
                                ar < b)
                                    return !0
                            }
                        }
                    }
                })
            }
            for (let Bt = 0, kt = geometryUtils_getTriCount(o); Bt < kt; Bt++) {
                setTriangle(_t, 3 * Bt, pt, ut),
                _t.a.applyMatrix4(c),
                _t.b.applyMatrix4(c),
                _t.c.applyMatrix4(c),
                _t.needsUpdate = !0;
                for (let Ut = Dt, Ht = Dt + Gt; Ut < Ht; Ut++) {
                    const Kt = d.resolveTriangleIndex(Ut);
                    setTriangle(ht, 3 * Kt, at, it),
                    ht.needsUpdate = !0;
                    const Jt = ht.distanceToTriangle(_t, vt, St);
                    if (Jt < Et && (bt.copy(vt),
                    At && At.copy(St),
                    Et = Jt,
                    Pt = Ut,
                    It = Bt),
                    Jt < b)
                        return !0
                }
            }
        }
    }),
    ExtendedTrianglePool.releasePrimitive(ht),
    ExtendedTrianglePool.releasePrimitive(_t),
    Et === 1 / 0 ? null : (h.point ? h.point.copy(bt) : h.point = bt.clone(),
    h.distance = Et,
    h.faceIndex = Pt,
    _ && (_.point ? _.point.copy(At) : _.point = At.clone(),
    _.point.applyMatrix4(closestPointToGeometry_indirect_generated_tempMatrix),
    bt.applyMatrix4(closestPointToGeometry_indirect_generated_tempMatrix),
    _.distance = bt.sub(_.point).length(),
    _.faceIndex = It),
    h)
}
function isSharedArrayBufferSupported() {
    return typeof SharedArrayBuffer < "u"
}
const _bufferStack1 = new BufferStack.constructor
  , _bufferStack2 = new BufferStack.constructor
  , _boxPool = new PrimitivePool( () => new three_module.NRn)
  , _leftBox1 = new three_module.NRn
  , _rightBox1 = new three_module.NRn
  , _leftBox2 = new three_module.NRn
  , _rightBox2 = new three_module.NRn;
let _active = !1;
function bvhcast(d, o, c, h) {
    if (_active)
        throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
    _active = !0;
    const _ = d._roots
      , b = o._roots;
    let _e, nt = 0, it = 0;
    const at = new three_module.kn4().copy(c).invert();
    for (let ut = 0, pt = _.length; ut < pt; ut++) {
        _bufferStack1.setBuffer(_[ut]),
        it = 0;
        const ht = _boxPool.getPrimitive();
        arrayToBox(0, _bufferStack1.float32Array, ht),
        ht.applyMatrix4(at);
        for (let _t = 0, vt = b.length; _t < vt && (_bufferStack2.setBuffer(b[ut]),
        _e = _traverse(0, 0, c, at, h, nt, it, 0, 0, ht),
        _bufferStack2.clearBuffer(),
        it += b[_t].length,
        !_e); _t++)
            ;
        if (_boxPool.releasePrimitive(ht),
        _bufferStack1.clearBuffer(),
        nt += _[ut].length,
        _e)
            break
    }
    return _active = !1,
    _e
}
function _traverse(d, o, c, h, _, b=0, _e=0, nt=0, it=0, at=null, ut=!1) {
    let pt, ht;
    ut ? (pt = _bufferStack2,
    ht = _bufferStack1) : (pt = _bufferStack1,
    ht = _bufferStack2);
    const _t = pt.float32Array
      , vt = pt.uint32Array
      , bt = pt.uint16Array
      , St = ht.float32Array
      , At = ht.uint32Array
      , Et = ht.uint16Array
      , Pt = 2 * o
      , It = IS_LEAF(2 * d, bt)
      , Dt = IS_LEAF(Pt, Et);
    let Gt = !1;
    if (Dt && It)
        Gt = ut ? _(OFFSET(o, At), COUNT(2 * o, Et), OFFSET(d, vt), COUNT(2 * d, bt), it, _e + o, nt, b + d) : _(OFFSET(d, vt), COUNT(2 * d, bt), OFFSET(o, At), COUNT(2 * o, Et), nt, b + d, it, _e + o);
    else if (Dt) {
        const Bt = _boxPool.getPrimitive();
        arrayToBox(o, St, Bt),
        Bt.applyMatrix4(c);
        const kt = LEFT_NODE(d)
          , Ut = RIGHT_NODE(d, vt);
        arrayToBox(kt, _t, _leftBox1),
        arrayToBox(Ut, _t, _rightBox1);
        const Ht = Bt.intersectsBox(_leftBox1)
          , Kt = Bt.intersectsBox(_rightBox1);
        Gt = Ht && _traverse(o, kt, h, c, _, _e, b, it, nt + 1, Bt, !ut) || Kt && _traverse(o, Ut, h, c, _, _e, b, it, nt + 1, Bt, !ut),
        _boxPool.releasePrimitive(Bt)
    } else {
        const Bt = LEFT_NODE(o)
          , kt = RIGHT_NODE(o, At);
        arrayToBox(Bt, St, _leftBox2),
        arrayToBox(kt, St, _rightBox2);
        const Ut = at.intersectsBox(_leftBox2)
          , Ht = at.intersectsBox(_rightBox2);
        if (Ut && Ht)
            Gt = _traverse(d, Bt, c, h, _, b, _e, nt, it + 1, at, ut) || _traverse(d, kt, c, h, _, b, _e, nt, it + 1, at, ut);
        else if (Ut)
            if (It)
                Gt = _traverse(d, Bt, c, h, _, b, _e, nt, it + 1, at, ut);
            else {
                const Kt = _boxPool.getPrimitive();
                Kt.copy(_leftBox2).applyMatrix4(c);
                const Jt = LEFT_NODE(d)
                  , or = RIGHT_NODE(d, vt);
                arrayToBox(Jt, _t, _leftBox1),
                arrayToBox(or, _t, _rightBox1);
                const ir = Kt.intersectsBox(_leftBox1)
                  , lr = Kt.intersectsBox(_rightBox1);
                Gt = ir && _traverse(Bt, Jt, h, c, _, _e, b, it, nt + 1, Kt, !ut) || lr && _traverse(Bt, or, h, c, _, _e, b, it, nt + 1, Kt, !ut),
                _boxPool.releasePrimitive(Kt)
            }
        else if (Ht)
            if (It)
                Gt = _traverse(d, kt, c, h, _, b, _e, nt, it + 1, at, ut);
            else {
                const Kt = _boxPool.getPrimitive();
                Kt.copy(_rightBox2).applyMatrix4(c);
                const Jt = LEFT_NODE(d)
                  , or = RIGHT_NODE(d, vt);
                arrayToBox(Jt, _t, _leftBox1),
                arrayToBox(or, _t, _rightBox1);
                const ir = Kt.intersectsBox(_leftBox1)
                  , lr = Kt.intersectsBox(_rightBox1);
                Gt = ir && _traverse(kt, Jt, h, c, _, _e, b, it, nt + 1, Kt, !ut) || lr && _traverse(kt, or, h, c, _, _e, b, it, nt + 1, Kt, !ut),
                _boxPool.releasePrimitive(Kt)
            }
    }
    return Gt
}
const MeshBVH_obb = new OrientedBox
  , tempBox = new three_module.NRn;
class MeshBVH {
    static serialize(o, c={}) {
        c = {
            cloneBuffers: !0,
            ...c
        };
        const h = o.geometry
          , _ = o._roots
          , b = o._indirectBuffer
          , _e = h.getIndex();
        let nt;
        return nt = c.cloneBuffers ? {
            roots: _.map(it => it.slice()),
            index: _e.array.slice(),
            indirectBuffer: b ? b.slice() : null
        } : {
            roots: _,
            index: _e.array,
            indirectBuffer: b
        },
        nt
    }
    static deserialize(o, c, h={}) {
        h = {
            setIndex: !0,
            indirect: !!o.indirectBuffer,
            ...h
        };
        const {index: _, roots: b, indirectBuffer: _e} = o
          , nt = new MeshBVH(c,{
            ...h,
            [SKIP_GENERATION]: !0
        });
        if (nt._roots = b,
        nt._indirectBuffer = _e || null,
        h.setIndex) {
            const it = c.getIndex();
            if (it === null) {
                const at = new three_module.THS(o.index,1,!1);
                c.setIndex(at)
            } else
                it.array !== _ && (it.array.set(_),
                it.needsUpdate = !0)
        }
        return nt
    }
    get indirect() {
        return !!this._indirectBuffer
    }
    constructor(o, c={}) {
        if (!o.isBufferGeometry)
            throw new Error("MeshBVH: Only BufferGeometries are supported.");
        if (o.index && o.index.isInterleavedBufferAttribute)
            throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
        if ((c = Object.assign({
            strategy: CENTER,
            maxDepth: 40,
            maxLeafTris: 10,
            verbose: !0,
            useSharedArrayBuffer: !1,
            setBoundingBox: !0,
            onProgress: null,
            indirect: !1,
            [SKIP_GENERATION]: !1
        }, c)).useSharedArrayBuffer && !isSharedArrayBufferSupported())
            throw new Error("MeshBVH: SharedArrayBuffer is not available.");
        this.geometry = o,
        this._roots = null,
        this._indirectBuffer = null,
        c[SKIP_GENERATION] || (buildPackedTree(this, c),
        !o.boundingBox && c.setBoundingBox && (o.boundingBox = this.getBoundingBox(new three_module.NRn)));
        const {_indirectBuffer: h} = this;
        this.resolveTriangleIndex = c.indirect ? _ => h[_] : _ => _
    }
    refit(o=null) {
        return (this.indirect ? refit_indirect : refit)(this, o)
    }
    traverse(o, c=0) {
        const h = this._roots[c]
          , _ = new Uint32Array(h)
          , b = new Uint16Array(h);
        (function _e(nt, it=0) {
            const at = 2 * nt
              , ut = b[at + 15] === IS_LEAFNODE_FLAG;
            if (ut) {
                const pt = _[nt + 6]
                  , ht = b[at + 14];
                o(it, ut, new Float32Array(h,4 * nt,6), pt, ht)
            } else {
                const pt = nt + BYTES_PER_NODE / 4
                  , ht = _[nt + 6]
                  , _t = _[nt + 7];
                o(it, ut, new Float32Array(h,4 * nt,6), _t) || (_e(pt, it + 1),
                _e(ht, it + 1))
            }
        }
        )(0)
    }
    raycast(o, c=three_module.hB5) {
        const h = this._roots
          , _ = this.geometry
          , b = []
          , _e = c.isMaterial
          , nt = Array.isArray(c)
          , it = _.groups
          , at = _e ? c.side : c
          , ut = this.indirect ? raycast_indirect : raycast;
        for (let pt = 0, ht = h.length; pt < ht; pt++) {
            const _t = nt ? c[it[pt].materialIndex].side : at
              , vt = b.length;
            if (ut(this, pt, _t, o, b),
            nt) {
                const bt = it[pt].materialIndex;
                for (let St = vt, At = b.length; St < At; St++)
                    b[St].face.materialIndex = bt
            }
        }
        return b
    }
    raycastFirst(o, c=three_module.hB5) {
        const h = this._roots
          , _ = this.geometry
          , b = c.isMaterial
          , _e = Array.isArray(c);
        let nt = null;
        const it = _.groups
          , at = b ? c.side : c
          , ut = this.indirect ? raycastFirst_indirect : raycastFirst;
        for (let pt = 0, ht = h.length; pt < ht; pt++) {
            const _t = ut(this, pt, _e ? c[it[pt].materialIndex].side : at, o);
            _t != null && (nt == null || _t.distance < nt.distance) && (nt = _t,
            _e && (_t.face.materialIndex = it[pt].materialIndex))
        }
        return nt
    }
    intersectsGeometry(o, c) {
        let h = !1;
        const _ = this._roots
          , b = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
        for (let _e = 0, nt = _.length; _e < nt && (h = b(this, _e, o, c),
        !h); _e++)
            ;
        return h
    }
    shapecast(o) {
        const c = ExtendedTrianglePool.getPrimitive()
          , h = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
        let {boundsTraverseOrder: _, intersectsBounds: b, intersectsRange: _e, intersectsTriangle: nt} = o;
        if (_e && nt) {
            const pt = _e;
            _e = (ht, _t, vt, bt, St) => !!pt(ht, _t, vt, bt, St) || h(ht, _t, this, nt, vt, bt, c)
        } else
            _e || (_e = nt ? (pt, ht, _t, vt) => h(pt, ht, this, nt, _t, vt, c) : (pt, ht, _t) => _t);
        let it = !1
          , at = 0;
        const ut = this._roots;
        for (let pt = 0, ht = ut.length; pt < ht; pt++) {
            const _t = ut[pt];
            if (it = shapecast(this, pt, b, _e, _, at),
            it)
                break;
            at += _t.byteLength
        }
        return ExtendedTrianglePool.releasePrimitive(c),
        it
    }
    bvhcast(o, c, h) {
        let {intersectsRanges: _, intersectsTriangles: b} = h;
        const _e = ExtendedTrianglePool.getPrimitive()
          , nt = this.geometry.index
          , it = this.geometry.attributes.position
          , at = this.indirect ? vt => {
            const bt = this.resolveTriangleIndex(vt);
            setTriangle(_e, 3 * bt, nt, it)
        }
        : vt => {
            setTriangle(_e, 3 * vt, nt, it)
        }
          , ut = ExtendedTrianglePool.getPrimitive()
          , pt = o.geometry.index
          , ht = o.geometry.attributes.position
          , _t = o.indirect ? vt => {
            const bt = o.resolveTriangleIndex(vt);
            setTriangle(ut, 3 * bt, pt, ht)
        }
        : vt => {
            setTriangle(ut, 3 * vt, pt, ht)
        }
        ;
        if (b) {
            const vt = (bt, St, At, Et, Pt, It, Dt, Gt) => {
                for (let Bt = At, kt = At + Et; Bt < kt; Bt++) {
                    _t(Bt),
                    ut.a.applyMatrix4(c),
                    ut.b.applyMatrix4(c),
                    ut.c.applyMatrix4(c),
                    ut.needsUpdate = !0;
                    for (let Ut = bt, Ht = bt + St; Ut < Ht; Ut++)
                        if (at(Ut),
                        _e.needsUpdate = !0,
                        b(_e, ut, Ut, Bt, Pt, It, Dt, Gt))
                            return !0
                }
                return !1
            }
            ;
            if (_) {
                const bt = _;
                _ = function(St, At, Et, Pt, It, Dt, Gt, Bt) {
                    return !!bt(St, At, Et, Pt, It, Dt, Gt, Bt) || vt(St, At, Et, Pt, It, Dt, Gt, Bt)
                }
            } else
                _ = vt
        }
        return bvhcast(this, o, c, _)
    }
    intersectsBox(o, c) {
        return MeshBVH_obb.set(o.min, o.max, c),
        MeshBVH_obb.needsUpdate = !0,
        this.shapecast({
            intersectsBounds: h => MeshBVH_obb.intersectsBox(h),
            intersectsTriangle: h => MeshBVH_obb.intersectsTriangle(h)
        })
    }
    intersectsSphere(o) {
        return this.shapecast({
            intersectsBounds: c => o.intersectsBox(c),
            intersectsTriangle: c => c.intersectsSphere(o)
        })
    }
    closestPointToGeometry(o, c, h={}, _={}, b=0, _e=1 / 0) {
        return (this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry)(this, o, c, h, _, b, _e)
    }
    closestPointToPoint(o, c={}, h=0, _=1 / 0) {
        return closestPointToPoint(this, o, c, h, _)
    }
    getBoundingBox(o) {
        return o.makeEmpty(),
        this._roots.forEach(c => {
            arrayToBox(0, new Float32Array(c), tempBox),
            o.union(tempBox)
        }
        ),
        o
    }
}
const HASH_WIDTH = 1e-6
  , HASH_HALF_WIDTH = .5 * HASH_WIDTH
  , HASH_MULTIPLIER = Math.pow(10, -Math.log10(HASH_WIDTH))
  , HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;
function hashNumber(d) {
    return ~~(d * HASH_MULTIPLIER + HASH_ADDITION)
}
function hashVertex2(d) {
    return `${hashNumber(d.x)},${hashNumber(d.y)}`
}
function hashVertex3(d) {
    return `${hashNumber(d.x)},${hashNumber(d.y)},${hashNumber(d.z)}`
}
function hashVertex4(d) {
    return `${hashNumber(d.x)},${hashNumber(d.y)},${hashNumber(d.z)},${hashNumber(d.w)}`
}
function toNormalizedRay(d, o, c) {
    c.direction.subVectors(o, d).normalize();
    const h = d.dot(c.direction);
    return c.origin.copy(d).addScaledVector(c.direction, -h),
    c
}
const DEGENERATE_EPSILON = 1e-8
  , _tempVec = new three_module.Pq0;
function toTriIndex(d) {
    return ~~(d / 3)
}
function toEdgeIndex(d) {
    return d % 3
}
function sortEdgeFunc(d, o) {
    return d.start - o.start
}
function getProjectedDistance(d, o) {
    return _tempVec.subVectors(o, d.origin).dot(d.direction)
}
function matchEdges(d, o, c, h=DEGENERATE_EPSILON) {
    d.sort(sortEdgeFunc),
    o.sort(sortEdgeFunc);
    for (let nt = 0; nt < d.length; nt++) {
        const it = d[nt];
        for (let at = 0; at < o.length; at++) {
            const ut = o[at];
            if (!(ut.start > it.end)) {
                if (it.end < ut.start || ut.end < it.start)
                    continue;
                if (it.start <= ut.start && it.end >= ut.end)
                    b(ut.end, it.end) || d.splice(nt + 1, 0, {
                        start: ut.end,
                        end: it.end,
                        index: it.index
                    }),
                    it.end = ut.start,
                    ut.start = 0,
                    ut.end = 0;
                else if (it.start >= ut.start && it.end <= ut.end)
                    b(it.end, ut.end) || o.splice(at + 1, 0, {
                        start: it.end,
                        end: ut.end,
                        index: ut.index
                    }),
                    ut.end = it.start,
                    it.start = 0,
                    it.end = 0;
                else if (it.start <= ut.start && it.end <= ut.end) {
                    const pt = it.end;
                    it.end = ut.start,
                    ut.start = pt
                } else {
                    if (!(it.start >= ut.start && it.end >= ut.end))
                        throw new Error;
                    {
                        const pt = ut.end;
                        ut.end = it.start,
                        it.start = pt
                    }
                }
            }
            if (c.has(it.index) || c.set(it.index, []),
            c.has(ut.index) || c.set(ut.index, []),
            c.get(it.index).push(ut.index),
            c.get(ut.index).push(it.index),
            _e(ut) && (o.splice(at, 1),
            at--),
            _e(it)) {
                d.splice(nt, 1),
                nt--;
                break
            }
        }
    }
    function _(nt) {
        for (let it = 0; it < nt.length; it++)
            _e(nt[it]) && (nt.splice(it, 1),
            it--)
    }
    function b(nt, it) {
        return Math.abs(it - nt) < h
    }
    function _e(nt) {
        return Math.abs(nt.end - nt.start) < h
    }
    _(d),
    _(o)
}
const DIST_EPSILON = 1e-5
  , ANGLE_EPSILON = 1e-4;
class RaySet {
    constructor() {
        this._rays = []
    }
    addRay(o) {
        this._rays.push(o)
    }
    findClosestRay(o) {
        const c = this._rays
          , h = o.clone();
        h.direction.multiplyScalar(-1);
        let _ = 1 / 0
          , b = null;
        for (let it = 0, at = c.length; it < at; it++) {
            const ut = c[it];
            if (_e(ut, o) && _e(ut, h))
                continue;
            const pt = nt(ut, o)
              , ht = nt(ut, h)
              , _t = Math.min(pt, ht);
            _t < _ && (_ = _t,
            b = ut)
        }
        return b;
        function _e(it, at) {
            const ut = it.origin.distanceTo(at.origin) > DIST_EPSILON;
            return it.direction.angleTo(at.direction) > ANGLE_EPSILON || ut
        }
        function nt(it, at) {
            const ut = it.origin.distanceTo(at.origin)
              , pt = it.direction.angleTo(at.direction);
            return ut / DIST_EPSILON + pt / ANGLE_EPSILON
        }
    }
}
const _v0 = new three_module.Pq0
  , _v1 = new three_module.Pq0
  , computeDisjointEdges_ray = new three_module.RlV;
function computeDisjointEdges(d, o, c) {
    const h = d.attributes
      , _ = d.index
      , b = h.position
      , _e = new Map
      , nt = new Map
      , it = Array.from(o)
      , at = new RaySet;
    for (let ut = 0, pt = it.length; ut < pt; ut++) {
        const ht = it[ut]
          , _t = toTriIndex(ht)
          , vt = toEdgeIndex(ht);
        let bt, St = 3 * _t + vt, At = 3 * _t + (vt + 1) % 3;
        _ && (St = _.getX(St),
        At = _.getX(At)),
        _v0.fromBufferAttribute(b, St),
        _v1.fromBufferAttribute(b, At),
        toNormalizedRay(_v0, _v1, computeDisjointEdges_ray);
        let Et = at.findClosestRay(computeDisjointEdges_ray);
        Et === null && (Et = computeDisjointEdges_ray.clone(),
        at.addRay(Et)),
        nt.has(Et) || nt.set(Et, {
            forward: [],
            reverse: [],
            ray: Et
        }),
        bt = nt.get(Et);
        let Pt = getProjectedDistance(Et, _v0)
          , It = getProjectedDistance(Et, _v1);
        Pt > It && ([Pt,It] = [It, Pt]),
        computeDisjointEdges_ray.direction.dot(Et.direction) < 0 ? bt.reverse.push({
            start: Pt,
            end: It,
            index: ht
        }) : bt.forward.push({
            start: Pt,
            end: It,
            index: ht
        })
    }
    return nt.forEach( ({forward: ut, reverse: pt}, ht) => {
        matchEdges(ut, pt, _e, c),
        ut.length === 0 && pt.length === 0 && nt.delete(ht)
    }
    ),
    {
        disjointConnectivityMap: _e,
        fragmentMap: nt
    }
}
const _vec2 = new three_module.I9Y
  , HalfEdgeMap_vec3 = new three_module.Pq0
  , _vec4 = new three_module.IUQ
  , _hashes = ["", "", ""];
class HalfEdgeMap {
    constructor(o=null) {
        this.data = null,
        this.disjointConnections = null,
        this.unmatchedDisjointEdges = null,
        this.unmatchedEdges = -1,
        this.matchedEdges = -1,
        this.useDrawRange = !0,
        this.useAllAttributes = !1,
        this.matchDisjointEdges = !1,
        this.degenerateEpsilon = 1e-8,
        o && this.updateFrom(o)
    }
    getSiblingTriangleIndex(o, c) {
        const h = this.data[3 * o + c];
        return h === -1 ? -1 : ~~(h / 3)
    }
    getSiblingEdgeIndex(o, c) {
        const h = this.data[3 * o + c];
        return h === -1 ? -1 : h % 3
    }
    getDisjointSiblingTriangleIndices(o, c) {
        const h = 3 * o + c
          , _ = this.disjointConnections.get(h);
        return _ ? _.map(b => ~~(b / 3)) : []
    }
    getDisjointSiblingEdgeIndices(o, c) {
        const h = 3 * o + c
          , _ = this.disjointConnections.get(h);
        return _ ? _.map(b => b % 3) : []
    }
    isFullyConnected() {
        return this.unmatchedEdges === 0
    }
    updateFrom(o) {
        const {useAllAttributes: c, useDrawRange: h, matchDisjointEdges: _, degenerateEpsilon: b} = this
          , _e = c ? function(Et) {
            let Pt = "";
            for (let It = 0, Dt = at.length; It < Dt; It++) {
                const Gt = it[at[It]];
                let Bt;
                switch (Gt.itemSize) {
                case 1:
                    Bt = hashNumber(Gt.getX(Et));
                    break;
                case 2:
                    Bt = hashVertex2(_vec2.fromBufferAttribute(Gt, Et));
                    break;
                case 3:
                    Bt = hashVertex3(HalfEdgeMap_vec3.fromBufferAttribute(Gt, Et));
                    break;
                case 4:
                    Bt = hashVertex4(_vec4.fromBufferAttribute(Gt, Et))
                }
                Pt !== "" && (Pt += "|"),
                Pt += Bt
            }
            return Pt
        }
        : function(Et) {
            return HalfEdgeMap_vec3.fromBufferAttribute(pt, Et),
            hashVertex3(HalfEdgeMap_vec3)
        }
          , nt = new Map
          , {attributes: it} = o
          , at = c ? Object.keys(it) : null
          , ut = o.index
          , pt = it.position;
        let ht = getTriCount(o);
        const _t = ht;
        let vt = 0;
        h && (vt = o.drawRange.start,
        o.drawRange.count !== 1 / 0 && (ht = ~~(o.drawRange.count / 3)));
        let bt = this.data;
        (!bt || bt.length < 3 * _t) && (bt = new Int32Array(3 * _t)),
        bt.fill(-1);
        let St = 0
          , At = new Set;
        for (let Et = vt, Pt = 3 * ht + vt; Et < Pt; Et += 3) {
            const It = Et;
            for (let Dt = 0; Dt < 3; Dt++) {
                let Gt = It + Dt;
                ut && (Gt = ut.getX(Gt)),
                _hashes[Dt] = _e(Gt)
            }
            for (let Dt = 0; Dt < 3; Dt++) {
                const Gt = (Dt + 1) % 3
                  , Bt = _hashes[Dt]
                  , kt = _hashes[Gt]
                  , Ut = `${kt}_${Bt}`;
                if (nt.has(Ut)) {
                    const Ht = It + Dt
                      , Kt = nt.get(Ut);
                    bt[Ht] = Kt,
                    bt[Kt] = Ht,
                    nt.delete(Ut),
                    St += 2,
                    At.delete(Kt)
                } else {
                    const Ht = `${Bt}_${kt}`
                      , Kt = It + Dt;
                    nt.set(Ht, Kt),
                    At.add(Kt)
                }
            }
        }
        if (_) {
            const {fragmentMap: Et, disjointConnectivityMap: Pt} = computeDisjointEdges(o, At, b);
            At.clear(),
            Et.forEach( ({forward: It, reverse: Dt}) => {
                It.forEach( ({index: Gt}) => At.add(Gt)),
                Dt.forEach( ({index: Gt}) => At.add(Gt))
            }
            ),
            this.unmatchedDisjointEdges = Et,
            this.disjointConnections = Pt,
            St = 3 * ht - At.size
        }
        this.matchedEdges = St,
        this.unmatchedEdges = At.size,
        this.data = bt
    }
}
class Brush extends three_module.eaF {
    constructor(...o) {
        super(...o),
        this.isBrush = !0,
        this._previousMatrix = new three_module.kn4,
        this._previousMatrix.elements.fill(0)
    }
    markUpdated() {
        this._previousMatrix.copy(this.matrix)
    }
    isDirty() {
        const {matrix: o, _previousMatrix: c} = this
          , h = o.elements
          , _ = c.elements;
        for (let b = 0; b < 16; b++)
            if (h[b] !== _[b])
                return !0;
        return !1
    }
    prepareGeometry() {
        const o = this.geometry
          , c = o.attributes
          , h = areSharedArrayBuffersSupported();
        if (h)
            for (const _ in c) {
                const b = c[_];
                if (b.isInterleavedBufferAttribute)
                    throw new Error("Brush: InterleavedBufferAttributes are not supported.");
                b.array = convertToSharedArrayBuffer(b.array)
            }
        if (o.boundsTree || (ensureIndex(o, {
            useSharedArrayBuffer: h
        }),
        o.boundsTree = new MeshBVH(o,{
            maxLeafTris: 3,
            indirect: !0,
            useSharedArrayBuffer: h
        })),
        o.halfEdges || (o.halfEdges = new HalfEdgeMap(o)),
        !o.groupIndices) {
            const _ = getTriCount(o)
              , b = new Uint16Array(_)
              , _e = o.groups;
            for (let nt = 0, it = _e.length; nt < it; nt++) {
                const {start: at, count: ut} = _e[nt];
                for (let pt = at / 3, ht = (at + ut) / 3; pt < ht; pt++)
                    b[pt] = nt
            }
            o.groupIndices = b
        }
    }
    disposeCacheData() {
        const {geometry: o} = this;
        o.halfEdges = null,
        o.boundsTree = null,
        o.groupIndices = null
    }
}
function joinGroups(d) {
    for (let o = 0; o < d.length - 1; o++) {
        const c = d[o]
          , h = d[o + 1];
        if (c.materialIndex === h.materialIndex) {
            const _ = c.start
              , b = h.start + h.count;
            h.start = _,
            h.count = b - _,
            d.splice(o, 1),
            o--
        }
    }
}
function prepareAttributesData(d, o, c, h) {
    c.clear();
    const _ = d.attributes;
    for (let b = 0, _e = h.length; b < _e; b++) {
        const nt = h[b]
          , it = _[nt];
        c.initializeArray(nt, it.array.constructor, it.itemSize, it.normalized)
    }
    for (const b in c.attributes)
        h.includes(b) || c.delete(b);
    for (const b in o.attributes)
        h.includes(b) || (o.deleteAttribute(b),
        o.dispose())
}
function assignBufferData(d, o, c) {
    let h = !1
      , _ = -1;
    const b = d.attributes
      , _e = o.groupAttributes[0];
    for (const it in _e) {
        const at = o.getTotalLength(it)
          , ut = o.getType(it)
          , pt = o.getItemSize(it)
          , ht = o.getNormalized(it);
        let _t = b[it];
        (!_t || _t.array.length < at) && (_t = new three_module.THS(new ut(at),pt,ht),
        d.setAttribute(it, _t),
        h = !0);
        let vt = 0;
        for (let bt = 0, St = Math.min(c.length, o.groupCount); bt < St; bt++) {
            const At = c[bt].index
              , {array: Et, type: Pt, length: It} = o.groupAttributes[At][it]
              , Dt = new Pt(Et.buffer,0,It);
            _t.array.set(Dt, vt),
            vt += Dt.length
        }
        _t.needsUpdate = !0,
        _ = at / _t.itemSize
    }
    if (d.index) {
        const it = d.index.array;
        if (it.length < _)
            d.index = null,
            h = !0;
        else
            for (let at = 0, ut = it.length; at < ut; at++)
                it[at] = at
    }
    let nt = 0;
    d.clearGroups();
    for (let it = 0, at = Math.min(c.length, o.groupCount); it < at; it++) {
        const {index: ut, materialIndex: pt} = c[it]
          , ht = o.getCount(ut);
        ht !== 0 && (d.addGroup(nt, ht, pt),
        nt += ht)
    }
    d.setDrawRange(0, _),
    d.boundsTree = null,
    h && d.dispose()
}
function getMaterialList(d, o) {
    let c = o;
    return Array.isArray(o) || (c = [],
    d.forEach(h => {
        c[h.materialIndex] = o
    }
    )),
    c
}
class Evaluator {
    constructor() {
        this.triangleSplitter = new TriangleSplitter,
        this.attributeData = [],
        this.attributes = ["position", "uv", "normal"],
        this.useGroups = !0,
        this.consolidateGroups = !0,
        this.debug = new OperationDebugData
    }
    getGroupRanges(o) {
        return this.useGroups && o.groups.length !== 0 ? o.groups.map(c => ({
            ...c
        })) : [{
            start: 0,
            count: 1 / 0,
            materialIndex: 0
        }]
    }
    evaluate(o, c, h, _=new Brush) {
        let b = !0;
        if (Array.isArray(h) || (h = [h]),
        Array.isArray(_) || (_ = [_],
        b = !1),
        _.length !== h.length)
            throw new Error("Evaluator: operations and target array passed as different sizes.");
        o.prepareGeometry(),
        c.prepareGeometry();
        const {triangleSplitter: _e, attributeData: nt, attributes: it, useGroups: at, consolidateGroups: ut, debug: pt} = this;
        for (; nt.length < _.length; )
            nt.push(new TypedAttributeData);
        _.forEach( (At, Et) => {
            prepareAttributesData(o.geometry, At.geometry, nt[Et], it)
        }
        ),
        pt.init(),
        performOperation(o, c, h, _e, nt, {
            useGroups: at
        }),
        pt.complete();
        const ht = this.getGroupRanges(o.geometry)
          , _t = getMaterialList(ht, o.material)
          , vt = this.getGroupRanges(c.geometry)
          , bt = getMaterialList(vt, c.material);
        vt.forEach(At => At.materialIndex += _t.length);
        let St = [...ht, ...vt].map( (At, Et) => ({
            ...At,
            index: Et
        }));
        if (at) {
            const At = [..._t, ...bt];
            ut && (St = St.map(Pt => {
                const It = At[Pt.materialIndex];
                return Pt.materialIndex = At.indexOf(It),
                Pt
            }
            ).sort( (Pt, It) => Pt.materialIndex - It.materialIndex));
            const Et = [];
            for (let Pt = 0, It = At.length; Pt < It; Pt++) {
                let Dt = !1;
                for (let Gt = 0, Bt = St.length; Gt < Bt; Gt++) {
                    const kt = St[Gt];
                    kt.materialIndex === Pt && (Dt = !0,
                    kt.materialIndex = Et.length)
                }
                Dt && Et.push(At[Pt])
            }
            _.forEach(Pt => {
                Pt.material = Et
            }
            )
        } else
            St = [{
                start: 0,
                count: 1 / 0,
                index: 0,
                materialIndex: 0
            }],
            _.forEach(At => {
                At.material = _t[0]
            }
            );
        return _.forEach( (At, Et) => {
            const Pt = At.geometry;
            assignBufferData(Pt, nt[Et], St),
            ut && joinGroups(Pt.groups)
        }
        ),
        b ? _ : _[0]
    }
    evaluateHierarchy(o, c=new Brush) {
        o.updateMatrixWorld(!0);
        const h = (b, _e) => {
            const nt = b.children;
            for (let it = 0, at = nt.length; it < at; it++) {
                const ut = nt[it];
                ut.isOperationGroup ? h(ut, _e) : _e(ut)
            }
        }
          , _ = b => {
            const _e = b.children;
            let nt = !1;
            for (let at = 0, ut = _e.length; at < ut; at++) {
                const pt = _e[at];
                nt = _(pt) || nt
            }
            const it = b.isDirty();
            if (it && b.markUpdated(),
            nt && !b.isOperationGroup) {
                let at;
                return h(b, ut => {
                    at = at ? this.evaluate(at, ut, ut.operation) : this.evaluate(b, ut, ut.operation)
                }
                ),
                b._cachedGeometry = at.geometry,
                b._cachedMaterials = at.material,
                !0
            }
            return nt || it
        }
        ;
        return _(o),
        c.geometry = o._cachedGeometry,
        c.material = o._cachedMaterials,
        c
    }
    reset() {
        this.triangleSplitter.reset()
    }
}
var CSGPluginBVH_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const operations = {
    union: ADDITION,
    subtract: SUBTRACTION,
    intersect: INTERSECTION,
    difference: DIFFERENCE
};
function buildCSGMeshBVH(d, o) {
    const c = new Evaluator;
    c.useGroups = !0,
    c.attributes = ["position", "normal", "uv"],
    d.forEach(b => {
        for (const _e of [...c.attributes])
            b[0].geometry.getAttribute(_e) || c.attributes.splice(c.attributes.indexOf(_e), 1)
    }
    );
    let h = new Brush(new three_module.bdM(.01,.01,2,2));
    d.forEach( ([b,_e]) => {
        if (!Object.keys(operations).includes(_e))
            return void console.error(`Unknown operation ${_e}`);
        b.updateMatrix(),
        b.updateMatrixWorld();
        const nt = new Brush;
        nt.geometry = b.geometry,
        nt.material = b.material,
        b.matrixWorld.decompose(nt.position, nt.quaternion, nt.scale),
        nt.updateMatrix(),
        nt.updateMatrixWorld(),
        h = c.evaluate(h, nt, operations[_e])
    }
    );
    const _ = h;
    return _.userData._isCSGMesh = !0,
    _
}
let CSGPluginBVH = class extends CSGPluginBase {
    _buildCSGMesh(d) {
        return buildCSGMeshBVH(d)
    }
}
;
CSGPluginBVH.PluginType = "CSGPluginBVH",
CSGPluginBVH = CSGPluginBVH_decorate([uiFolder("CSG Plugin (BVH)")], CSGPluginBVH);
class ACameraControlsPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this._cameraChanged = o => {
            var c, h, _, b;
            (h = (c = o.lastCamera) === null || c === void 0 ? void 0 : c.removeControlsCtor) === null || h === void 0 || h.call(c, this.controlsKey),
            (b = (_ = o.camera) === null || _ === void 0 ? void 0 : _.setControlsCtor) === null || b === void 0 || b.call(_, this.controlsKey, this._controlsCtor)
        }
    }
    async onAdded(o) {
        await super.onAdded(o),
        this._cameraChanged({
            camera: o.scene.activeCamera
        }),
        o.scene.addEventListener("activeCameraChange", this._cameraChanged)
    }
    async onRemove(o) {
        return this._cameraChanged({
            lastCamera: o.scene.activeCamera
        }),
        o.scene.removeEventListener("activeCameraChange", this._cameraChanged),
        super.onRemove(o)
    }
}
var DeviceOrientationControl_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const _zee = new three_module.Pq0(0,0,1)
  , _euler = new three_module.O9p
  , _q0 = new three_module.PTz
  , _q1 = new three_module.PTz(-Math.sqrt(.5),0,0,Math.sqrt(.5))
  , _q2 = new three_module.PTz
  , DeviceOrientationControl_changeEvent = {
    type: "change"
}
  , EPS = 1e-6;
let DeviceOrientationControls2 = class extends three_module.Qev {
    constructor(d) {
        super(),
        this.enabled = !1,
        this.lastOrder = "XYZ",
        this.dampingFactor = .05,
        this.lastQuaternion = new three_module.PTz,
        this.onDeviceOrientationChangeEvent = o => {
            this.deviceOrientation = o
        }
        ,
        this.onScreenOrientationChangeEvent = () => {
            this.screenOrientation = screen.orientation
        }
        ,
        this._initQuaternion = new three_module.PTz,
        this._initQuaternionInvert = new three_module.PTz,
        this._initQuaternionDest = new three_module.PTz,
        this._lastTime = -1,
        window.isSecureContext === !1 && console.error("DeviceOrientationControls2: DeviceOrientationEvent is only available in secure contexts (https)"),
        this.object = d,
        this.lastOrder = this.object.rotation.order,
        this.object.rotation.reorder("YXZ"),
        this.connect()
    }
    connect() {
        this.onScreenOrientationChangeEvent(),
        window.DeviceOrientationEvent !== void 0 && typeof window.DeviceOrientationEvent.requestPermission == "function" ? window.DeviceOrientationEvent.requestPermission().then(d => {
            d == "granted" && (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent),
            window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent))
        }
        ).catch(d => {
            console.error("DeviceOrientationControls2: Unable to use DeviceOrientation API:", d)
        }
        ) : (window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent),
        window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent)),
        this.enabled = !0,
        this._initQuaternion.copy(this.object.quaternion),
        this._initQuaternionInvert.copy(this.object.quaternion).invert()
    }
    disconnect() {
        window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent),
        window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent),
        this._initQuaternion.identity(),
        this._initQuaternionInvert.identity(),
        this._initQuaternionDest = new three_module.PTz,
        this.object.rotation.reorder(this.lastOrder),
        this.lastOrder = "XYZ",
        this.enabled = !1
    }
    update() {
        if (!this.enabled)
            return;
        const d = this.deviceOrientation;
        if (d) {
            const o = d.alpha !== null ? three_module.cj9.degToRad(d.alpha) : 0
              , c = d.beta !== null ? three_module.cj9.degToRad(d.beta) : 0
              , h = d.gamma !== null ? three_module.cj9.degToRad(d.gamma) : 0
              , _ = this.screenOrientation ? three_module.cj9.degToRad(this.screenOrientation.angle) : 0;
            this.setObjectQuaternion(o, c, h, _),
            8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > EPS && (this.lastQuaternion.copy(this.object.quaternion),
            this.dispatchEvent(DeviceOrientationControl_changeEvent))
        }
    }
    dispose() {
        this.disconnect()
    }
    setObjectQuaternion(d, o, c, h) {
        const _ = g() / 1e3;
        _euler.set(o, d, -c, "YXZ"),
        _q2.setFromEuler(_euler),
        _q2.multiply(_q1),
        _q2.multiply(_q0.setFromAxisAngle(_zee, -h)),
        this._initQuaternionDest.__init || (this._initQuaternionDest.copy(_q2).invert(),
        this._initQuaternionDest.__init = !0),
        _q2.premultiply(this._initQuaternionDest),
        this.object.quaternion.slerp(_q2, this.dampingFactor / (Math.min(1, _ - this._lastTime) / (1 / 60))),
        this._lastTime = _
    }
}
;
DeviceOrientationControl_decorate([serialize(), uiSlider("Damping", [0, 1], .01)], DeviceOrientationControls2.prototype, "dampingFactor", void 0),
DeviceOrientationControls2 = DeviceOrientationControl_decorate([uiPanel("Device Orientation Controls")], DeviceOrientationControls2);
class DeviceOrientationControlsPlugin extends ACameraControlsPlugin {
    constructor() {
        super(...arguments),
        this.controlsKey = "deviceOrientation",
        this._controlsCtor = (o, c) => new DeviceOrientationControls2(o)
    }
}
DeviceOrientationControlsPlugin.PluginType = "DeviceOrientationControlsPlugin";
var FirstPersonControls2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const _lookDirection = new three_module.Pq0
  , _spherical = new three_module.YHV
  , _target = new three_module.Pq0
  , FirstPersonControls2_changeEvent = {
    type: "change"
};
let FirstPersonControls2 = class extends three_module.Qev {
    constructor(d, o) {
        super(),
        this.enabled = !0,
        this.enableKeys = !0,
        this.movementSpeed = 1,
        this.lookSpeed = .005,
        this.lookVertical = !0,
        this.autoForward = !1,
        this.activeLook = !0,
        this.heightSpeed = !1,
        this.heightCoef = 1,
        this.heightMin = 0,
        this.heightMax = 1,
        this.constrainVertical = !1,
        this.verticalMin = 0,
        this.verticalMax = Math.PI,
        this.mouseDragOn = !1,
        this.autoSpeedFactor = 0,
        this.pointerX = 0,
        this.pointerY = 0,
        this.moveForward = !1,
        this.moveBackward = !1,
        this.moveLeft = !1,
        this.moveRight = !1,
        this.moveUp = !1,
        this.moveDown = !1,
        this.viewHalfX = 0,
        this.viewHalfY = 0,
        this.lat = 0,
        this.lon = 0,
        this.targetPosition = new three_module.Pq0,
        this._lastTime = -1,
        this.object = d,
        this.domElement = o,
        this.onPointerMove = this.onPointerMove.bind(this),
        this.onPointerDown = this.onPointerDown.bind(this),
        this.onPointerUp = this.onPointerUp.bind(this),
        this.onKeyDown = this.onKeyDown.bind(this),
        this.onKeyUp = this.onKeyUp.bind(this),
        this.onContextMenu = this.onContextMenu.bind(this),
        this.domElement.addEventListener("contextmenu", this.onContextMenu),
        this.domElement.addEventListener("pointermove", this.onPointerMove),
        this.domElement.addEventListener("pointerdown", this.onPointerDown),
        this.domElement.addEventListener("pointerup", this.onPointerUp),
        window.addEventListener("keydown", this.onKeyDown),
        window.addEventListener("keyup", this.onKeyUp),
        this.handleResize(),
        this.setOrientation()
    }
    setOrientation() {
        const d = this.object.quaternion;
        _lookDirection.set(0, 0, -1).applyQuaternion(d),
        _spherical.setFromVector3(_lookDirection),
        this.lat = 90 - three_module.cj9.radToDeg(_spherical.phi),
        this.lon = three_module.cj9.radToDeg(_spherical.theta)
    }
    handleResize() {
        this.domElement === document ? (this.viewHalfX = window.innerWidth / 2,
        this.viewHalfY = window.innerHeight / 2) : (this.viewHalfX = this.domElement.offsetWidth / 2,
        this.viewHalfY = this.domElement.offsetHeight / 2)
    }
    onPointerDown(d) {
        if (this.domElement !== document && this.domElement.focus(),
        this.activeLook)
            switch (d.button) {
            case 0:
                this.moveForward = !0;
                break;
            case 2:
                this.moveBackward = !0
            }
        this.mouseDragOn = !0
    }
    onPointerUp(d) {
        if (this.activeLook)
            switch (d.button) {
            case 0:
                this.moveForward = !1;
                break;
            case 2:
                this.moveBackward = !1
            }
        this.mouseDragOn = !1
    }
    onPointerMove(d) {
        this.domElement === document ? (this.pointerX = d.pageX - this.viewHalfX,
        this.pointerY = d.pageY - this.viewHalfY) : (this.pointerX = d.pageX - this.domElement.offsetLeft - this.viewHalfX,
        this.pointerY = d.pageY - this.domElement.offsetTop - this.viewHalfY)
    }
    onKeyDown(d) {
        if (this.enableKeys)
            switch (d.code) {
            case "ArrowUp":
            case "KeyW":
                this.moveForward = !0;
                break;
            case "ArrowLeft":
            case "KeyA":
                this.moveLeft = !0;
                break;
            case "ArrowDown":
            case "KeyS":
                this.moveBackward = !0;
                break;
            case "ArrowRight":
            case "KeyD":
                this.moveRight = !0;
                break;
            case "KeyR":
                this.moveUp = !0;
                break;
            case "KeyF":
                this.moveDown = !0
            }
    }
    onKeyUp(d) {
        if (this.enableKeys)
            switch (d.code) {
            case "ArrowUp":
            case "KeyW":
                this.moveForward = !1;
                break;
            case "ArrowLeft":
            case "KeyA":
                this.moveLeft = !1;
                break;
            case "ArrowDown":
            case "KeyS":
                this.moveBackward = !1;
                break;
            case "ArrowRight":
            case "KeyD":
                this.moveRight = !1;
                break;
            case "KeyR":
                this.moveUp = !1;
                break;
            case "KeyF":
                this.moveDown = !1
            }
    }
    lookAt(d, o, c) {
        return d.isVector3 ? _target.copy(d) : o === void 0 || c === void 0 ? console.error("FirstPersonControls2.lookAt: y and z parameters are required") : _target.set(d, o, c),
        this.object.lookAt(_target),
        this.setOrientation(),
        this
    }
    update() {
        const d = g()
          , o = (this._lastTime < 0 ? 16 : Math.min(d - this._lastTime, 1e3)) / 1e3;
        if (this._lastTime = d,
        !this.enabled)
            return;
        if (this.heightSpeed) {
            const it = three_module.cj9.clamp(this.object.position.y, this.heightMin, this.heightMax) - this.heightMin;
            this.autoSpeedFactor = o * (it * this.heightCoef)
        } else
            this.autoSpeedFactor = 0;
        const c = o * this.movementSpeed;
        (this.moveForward || this.autoForward && !this.moveBackward) && this.object.translateZ(-(c + this.autoSpeedFactor)),
        this.moveBackward && this.object.translateZ(c),
        this.moveLeft && this.object.translateX(-c),
        this.moveRight && this.object.translateX(c),
        this.moveUp && this.object.translateY(c),
        this.moveDown && this.object.translateY(-c);
        let h = o * this.lookSpeed;
        this.activeLook || (h = 0);
        let _ = 1;
        this.constrainVertical && (_ = Math.PI / (this.verticalMax - this.verticalMin)),
        this.lon -= this.pointerX * h,
        this.lookVertical && (this.lat -= this.pointerY * h * _),
        this.lat = Math.max(-85, Math.min(85, this.lat));
        let b = three_module.cj9.degToRad(90 - this.lat);
        const _e = three_module.cj9.degToRad(this.lon);
        this.constrainVertical && (b = three_module.cj9.mapLinear(b, 0, Math.PI, this.verticalMin, this.verticalMax));
        const nt = this.object.position;
        this.targetPosition.setFromSphericalCoords(1, b, _e).add(nt),
        this.object.lookAt(this.targetPosition),
        this.dispatchEvent(FirstPersonControls2_changeEvent)
    }
    dispose() {
        this.domElement.removeEventListener("contextmenu", this.onContextMenu),
        this.domElement.removeEventListener("pointerdown", this.onPointerDown),
        this.domElement.removeEventListener("pointermove", this.onPointerMove),
        this.domElement.removeEventListener("pointerup", this.onPointerUp),
        window.removeEventListener("keydown", this.onKeyDown),
        window.removeEventListener("keyup", this.onKeyUp)
    }
    onContextMenu(d) {
        this.enableKeys && d.preventDefault()
    }
}
;
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "enabled", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "enableKeys", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "movementSpeed", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "lookSpeed", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "lookVertical", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "autoForward", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "activeLook", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "heightSpeed", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "heightCoef", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "heightMin", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "heightMax", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "constrainVertical", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "verticalMin", void 0),
FirstPersonControls2_decorate([serialize(), uiInput()], FirstPersonControls2.prototype, "verticalMax", void 0),
FirstPersonControls2_decorate([serialize(), uiToggle()], FirstPersonControls2.prototype, "mouseDragOn", void 0),
FirstPersonControls2 = FirstPersonControls2_decorate([uiFolder("First Person Controls")], FirstPersonControls2);
class FirstPersonControlsPlugin extends ACameraControlsPlugin {
    constructor() {
        super(...arguments),
        this.controlsKey = "firstPerson",
        this._controlsCtor = (o, c) => new FirstPersonControls2(o,c)
    }
}
FirstPersonControlsPlugin.PluginType = "FirstPersonControlsPlugin";
var PointerLockControls2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
const PointerLockControls2_euler = new three_module.O9p(0,0,0,"YXZ")
  , PointerLockControls2_vector = new three_module.Pq0
  , PointerLockControls2_changeEvent = {
    type: "change"
}
  , _lockEvent = {
    type: "lock"
}
  , _unlockEvent = {
    type: "unlock"
}
  , _PI_2 = Math.PI / 2;
let PointerLockControls2 = class extends three_module.Qev {
    constructor(d, o) {
        super(),
        this.isLocked = !1,
        this.enabled = !0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.pointerSpeed = 1,
        this.autoLockOnClick = !0,
        this._movementX = 0,
        this._movementY = 0,
        this._forwardDirection = new three_module.Pq0(0,0,-1),
        this.domElement = o,
        this.object = d,
        this.onElementClick = this.onElementClick.bind(this),
        this.onMouseMove = this.onMouseMove.bind(this),
        this.onPointerlockChange = this.onPointerlockChange.bind(this),
        this.onPointerlockError = this.onPointerlockError.bind(this),
        this.connect()
    }
    onElementClick(d) {
        this.isLocked || this.autoLockOnClick && (d.preventDefault(),
        this.lock())
    }
    onMouseMove(d) {
        this.isLocked && (this._movementX += d.movementX || d.mozMovementX || d.webkitMovementX || 0,
        this._movementY += d.movementY || d.mozMovementY || d.webkitMovementY || 0)
    }
    onPointerlockChange() {
        this.domElement.ownerDocument.pointerLockElement === this.domElement ? (this.dispatchEvent(_lockEvent),
        this.isLocked = !0) : (this.dispatchEvent(_unlockEvent),
        this.isLocked = !1)
    }
    onPointerlockError() {
        console.error("THREE.PointerLockControls: Unable to use Pointer Lock API")
    }
    connect() {
        this.domElement.ownerDocument.addEventListener("mousemove", this.onMouseMove),
        this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange),
        this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError),
        this.domElement.addEventListener("click", this.onElementClick)
    }
    disconnect() {
        this.domElement.ownerDocument.removeEventListener("mousemove", this.onMouseMove),
        this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange),
        this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError),
        this.domElement.removeEventListener("click", this.onElementClick)
    }
    dispose() {
        this.disconnect()
    }
    getDirection(d) {
        return d.copy(this._forwardDirection).applyQuaternion(this.object.quaternion)
    }
    moveForward(d) {
        PointerLockControls2_vector.setFromMatrixColumn(this.object.matrix, 0),
        PointerLockControls2_vector.crossVectors(this.object.up, PointerLockControls2_vector),
        this.object.position.addScaledVector(PointerLockControls2_vector, d)
    }
    moveRight(d) {
        PointerLockControls2_vector.setFromMatrixColumn(this.object.matrix, 0),
        this.object.position.addScaledVector(PointerLockControls2_vector, d)
    }
    lock() {
        this.domElement.requestPointerLock()
    }
    unlock() {
        this.domElement.ownerDocument.exitPointerLock()
    }
    update() {
        Math.abs(this._movementX) < 1e-4 && Math.abs(this._movementY) < 1e-4 || (PointerLockControls2_euler.setFromQuaternion(this.object.quaternion),
        PointerLockControls2_euler.y -= .002 * this._movementX * this.pointerSpeed,
        PointerLockControls2_euler.x -= .002 * this._movementY * this.pointerSpeed,
        this._movementX = 0,
        this._movementY = 0,
        PointerLockControls2_euler.x = Math.max(_PI_2 - this.maxPolarAngle, Math.min(_PI_2 - this.minPolarAngle, PointerLockControls2_euler.x)),
        this.object.quaternion.setFromEuler(PointerLockControls2_euler),
        this.dispatchEvent(PointerLockControls2_changeEvent))
    }
}
;
PointerLockControls2_decorate([uiToggle(), serialize()], PointerLockControls2.prototype, "enabled", void 0),
PointerLockControls2_decorate([uiInput(), serialize()], PointerLockControls2.prototype, "minPolarAngle", void 0),
PointerLockControls2_decorate([uiInput(), serialize()], PointerLockControls2.prototype, "maxPolarAngle", void 0),
PointerLockControls2_decorate([uiInput(), serialize()], PointerLockControls2.prototype, "pointerSpeed", void 0),
PointerLockControls2_decorate([uiToggle(), serialize()], PointerLockControls2.prototype, "autoLockOnClick", void 0),
PointerLockControls2 = PointerLockControls2_decorate([uiPanel("Pointer Lock Controls")], PointerLockControls2);
class PointerLockControlsPlugin extends ACameraControlsPlugin {
    constructor() {
        super(...arguments),
        this.controlsKey = "pointerLock",
        this._controlsCtor = (o, c) => new PointerLockControls2(o,c.ownerDocument ? c : c.documentElement)
    }
}
PointerLockControlsPlugin.PluginType = "PointerLockControlsPlugin";
const TrackballControls_changeEvent = {
    type: "change"
}
  , TrackballControls_startEvent = {
    type: "start"
}
  , TrackballControls_endEvent = {
    type: "end"
};
class TrackballControls extends three_module.Qev {
    constructor(o, c) {
        super();
        const h = this
          , _ = -1;
        this.object = o,
        this.domElement = c,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        },
        this.rotateSpeed = 1,
        this.zoomSpeed = 1.2,
        this.panSpeed = .3,
        this.noRotate = !1,
        this.noZoom = !1,
        this.noPan = !1,
        this.staticMoving = !1,
        this.dynamicDampingFactor = .2,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.keys = ["KeyA", "KeyS", "KeyD"],
        this.mouseButtons = {
            LEFT: three_module.kBv.ROTATE,
            MIDDLE: three_module.kBv.DOLLY,
            RIGHT: three_module.kBv.PAN
        },
        this.target = new three_module.Pq0;
        const b = 1e-6
          , _e = new three_module.Pq0;
        let nt = 1
          , it = _
          , at = _
          , ut = 0
          , pt = 0
          , ht = 0;
        const _t = new three_module.Pq0
          , vt = new three_module.I9Y
          , bt = new three_module.I9Y
          , St = new three_module.Pq0
          , At = new three_module.I9Y
          , Et = new three_module.I9Y
          , Pt = new three_module.I9Y
          , It = new three_module.I9Y
          , Dt = []
          , Gt = {};
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.up0 = this.object.up.clone(),
        this.zoom0 = this.object.zoom,
        this.handleResize = function() {
            const dr = h.domElement.getBoundingClientRect()
              , cr = h.domElement.ownerDocument.documentElement;
            h.screen.left = dr.left + window.pageXOffset - cr.clientLeft,
            h.screen.top = dr.top + window.pageYOffset - cr.clientTop,
            h.screen.width = dr.width,
            h.screen.height = dr.height
        }
        ;
        const Bt = function() {
            const dr = new three_module.I9Y;
            return function(cr, Ar) {
                return dr.set((cr - h.screen.left) / h.screen.width, (Ar - h.screen.top) / h.screen.height),
                dr
            }
        }()
          , kt = function() {
            const dr = new three_module.I9Y;
            return function(cr, Ar) {
                return dr.set((cr - .5 * h.screen.width - h.screen.left) / (.5 * h.screen.width), (h.screen.height + 2 * (h.screen.top - Ar)) / h.screen.width),
                dr
            }
        }();
        function Ut(dr) {
            h.enabled !== !1 && (Dt.length === 0 && (h.domElement.setPointerCapture(dr.pointerId),
            h.domElement.addEventListener("pointermove", Ht),
            h.domElement.addEventListener("pointerup", Kt)),
            function(cr) {
                Dt.push(cr)
            }(dr),
            dr.pointerType === "touch" ? function(cr) {
                if (gr(cr),
                Dt.length === 1)
                    it = 3,
                    bt.copy(kt(Dt[0].pageX, Dt[0].pageY)),
                    vt.copy(bt);
                else {
                    it = 4;
                    const Ar = Dt[0].pageX - Dt[1].pageX
                      , wr = Dt[0].pageY - Dt[1].pageY;
                    pt = ut = Math.sqrt(Ar * Ar + wr * wr);
                    const Rr = (Dt[0].pageX + Dt[1].pageX) / 2
                      , Cr = (Dt[0].pageY + Dt[1].pageY) / 2;
                    Pt.copy(Bt(Rr, Cr)),
                    It.copy(Pt)
                }
                h.dispatchEvent(TrackballControls_startEvent)
            }(dr) : function(cr) {
                if (it === _)
                    switch (cr.button) {
                    case h.mouseButtons.LEFT:
                        it = 0;
                        break;
                    case h.mouseButtons.MIDDLE:
                        it = 1;
                        break;
                    case h.mouseButtons.RIGHT:
                        it = 2
                    }
                const Ar = at !== _ ? at : it;
                Ar !== 0 || h.noRotate ? Ar !== 1 || h.noZoom ? Ar !== 2 || h.noPan || (Pt.copy(Bt(cr.pageX, cr.pageY)),
                It.copy(Pt)) : (At.copy(Bt(cr.pageX, cr.pageY)),
                Et.copy(At)) : (bt.copy(kt(cr.pageX, cr.pageY)),
                vt.copy(bt)),
                h.dispatchEvent(TrackballControls_startEvent)
            }(dr))
        }
        function Ht(dr) {
            h.enabled !== !1 && (dr.pointerType === "touch" ? function(cr) {
                if (gr(cr),
                Dt.length === 1)
                    vt.copy(bt),
                    bt.copy(kt(cr.pageX, cr.pageY));
                else {
                    const Ar = function(fr) {
                        const vr = fr.pointerId === Dt[0].pointerId ? Dt[1] : Dt[0];
                        return Gt[vr.pointerId]
                    }(cr)
                      , wr = cr.pageX - Ar.x
                      , Rr = cr.pageY - Ar.y;
                    pt = Math.sqrt(wr * wr + Rr * Rr);
                    const Cr = (cr.pageX + Ar.x) / 2
                      , tr = (cr.pageY + Ar.y) / 2;
                    It.copy(Bt(Cr, tr))
                }
            }(dr) : function(cr) {
                const Ar = at !== _ ? at : it;
                Ar !== 0 || h.noRotate ? Ar !== 1 || h.noZoom ? Ar !== 2 || h.noPan || It.copy(Bt(cr.pageX, cr.pageY)) : Et.copy(Bt(cr.pageX, cr.pageY)) : (vt.copy(bt),
                bt.copy(kt(cr.pageX, cr.pageY)))
            }(dr))
        }
        function Kt(dr) {
            h.enabled !== !1 && (dr.pointerType === "touch" ? function(cr) {
                switch (Dt.length) {
                case 0:
                    it = _;
                    break;
                case 1:
                    it = 3,
                    bt.copy(kt(cr.pageX, cr.pageY)),
                    vt.copy(bt);
                    break;
                case 2:
                    it = 4;
                    for (let Ar = 0; Ar < Dt.length; Ar++)
                        if (Dt[Ar].pointerId !== cr.pointerId) {
                            const wr = Gt[Dt[Ar].pointerId];
                            bt.copy(kt(wr.x, wr.y)),
                            vt.copy(bt);
                            break
                        }
                }
                h.dispatchEvent(TrackballControls_endEvent)
            }(dr) : (it = _,
            h.dispatchEvent(TrackballControls_endEvent)),
            hr(dr),
            Dt.length === 0 && (h.domElement.releasePointerCapture(dr.pointerId),
            h.domElement.removeEventListener("pointermove", Ht),
            h.domElement.removeEventListener("pointerup", Kt)))
        }
        function Jt(dr) {
            hr(dr)
        }
        function or(dr) {
            h.enabled !== !1 && (window.removeEventListener("keydown", or),
            at === _ && (dr.code !== h.keys[0] || h.noRotate ? dr.code !== h.keys[1] || h.noZoom ? dr.code !== h.keys[2] || h.noPan || (at = 2) : at = 1 : at = 0))
        }
        function ir() {
            h.enabled !== !1 && (at = _,
            window.addEventListener("keydown", or))
        }
        function lr(dr) {
            if (h.enabled !== !1 && h.noZoom !== !0) {
                switch (dr.preventDefault(),
                dr.deltaMode) {
                case 2:
                    At.y -= .025 * dr.deltaY;
                    break;
                case 1:
                    At.y -= .01 * dr.deltaY;
                    break;
                default:
                    At.y -= 25e-5 * dr.deltaY
                }
                h.dispatchEvent(TrackballControls_startEvent),
                h.dispatchEvent(TrackballControls_endEvent)
            }
        }
        function ar(dr) {
            h.enabled !== !1 && dr.preventDefault()
        }
        function hr(dr) {
            delete Gt[dr.pointerId];
            for (let cr = 0; cr < Dt.length; cr++)
                if (Dt[cr].pointerId == dr.pointerId)
                    return void Dt.splice(cr, 1)
        }
        function gr(dr) {
            let cr = Gt[dr.pointerId];
            cr === void 0 && (cr = new three_module.I9Y,
            Gt[dr.pointerId] = cr),
            cr.set(dr.pageX, dr.pageY)
        }
        this.rotateCamera = function() {
            const dr = new three_module.Pq0
              , cr = new three_module.PTz
              , Ar = new three_module.Pq0
              , wr = new three_module.Pq0
              , Rr = new three_module.Pq0
              , Cr = new three_module.Pq0;
            return function() {
                Cr.set(bt.x - vt.x, bt.y - vt.y, 0);
                let tr = Cr.length();
                tr ? (_t.copy(h.object.position).sub(h.target),
                Ar.copy(_t).normalize(),
                wr.copy(h.object.up).normalize(),
                Rr.crossVectors(wr, Ar).normalize(),
                wr.setLength(bt.y - vt.y),
                Rr.setLength(bt.x - vt.x),
                Cr.copy(wr.add(Rr)),
                dr.crossVectors(Cr, _t).normalize(),
                tr *= h.rotateSpeed,
                cr.setFromAxisAngle(dr, tr),
                _t.applyQuaternion(cr),
                h.object.up.applyQuaternion(cr),
                St.copy(dr),
                ht = tr) : !h.staticMoving && ht && (ht *= Math.sqrt(1 - h.dynamicDampingFactor),
                _t.copy(h.object.position).sub(h.target),
                cr.setFromAxisAngle(St, ht),
                _t.applyQuaternion(cr),
                h.object.up.applyQuaternion(cr)),
                vt.copy(bt)
            }
        }(),
        this.zoomCamera = function() {
            let dr;
            it === 4 ? (dr = ut / pt,
            ut = pt,
            h.object.isPerspectiveCamera ? _t.multiplyScalar(dr) : h.object.isOrthographicCamera ? (h.object.zoom = three_module.cj9.clamp(h.object.zoom / dr, h.minZoom, h.maxZoom),
            nt !== h.object.zoom && h.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (dr = 1 + (Et.y - At.y) * h.zoomSpeed,
            dr !== 1 && dr > 0 && (h.object.isPerspectiveCamera ? _t.multiplyScalar(dr) : h.object.isOrthographicCamera ? (h.object.zoom = three_module.cj9.clamp(h.object.zoom / dr, h.minZoom, h.maxZoom),
            nt !== h.object.zoom && h.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")),
            h.staticMoving ? At.copy(Et) : At.y += (Et.y - At.y) * this.dynamicDampingFactor)
        }
        ,
        this.panCamera = function() {
            const dr = new three_module.I9Y
              , cr = new three_module.Pq0
              , Ar = new three_module.Pq0;
            return function() {
                if (dr.copy(It).sub(Pt),
                dr.lengthSq()) {
                    if (h.object.isOrthographicCamera) {
                        const wr = (h.object.right - h.object.left) / h.object.zoom / h.domElement.clientWidth
                          , Rr = (h.object.top - h.object.bottom) / h.object.zoom / h.domElement.clientWidth;
                        dr.x *= wr,
                        dr.y *= Rr
                    }
                    dr.multiplyScalar(_t.length() * h.panSpeed),
                    Ar.copy(_t).cross(h.object.up).setLength(dr.x),
                    Ar.add(cr.copy(h.object.up).setLength(dr.y)),
                    h.object.position.add(Ar),
                    h.target.add(Ar),
                    h.staticMoving ? Pt.copy(It) : Pt.add(dr.subVectors(It, Pt).multiplyScalar(h.dynamicDampingFactor))
                }
            }
        }(),
        this.checkDistances = function() {
            h.noZoom && h.noPan || (_t.lengthSq() > h.maxDistance * h.maxDistance && (h.object.position.addVectors(h.target, _t.setLength(h.maxDistance)),
            At.copy(Et)),
            _t.lengthSq() < h.minDistance * h.minDistance && (h.object.position.addVectors(h.target, _t.setLength(h.minDistance)),
            At.copy(Et)))
        }
        ,
        this.update = function() {
            _t.subVectors(h.object.position, h.target),
            h.noRotate || h.rotateCamera(),
            h.noZoom || h.zoomCamera(),
            h.noPan || h.panCamera(),
            h.object.position.addVectors(h.target, _t),
            h.object.isPerspectiveCamera ? (h.checkDistances(),
            h.object.lookAt(h.target),
            _e.distanceToSquared(h.object.position) > b && (h.dispatchEvent(TrackballControls_changeEvent),
            _e.copy(h.object.position))) : h.object.isOrthographicCamera ? (h.object.lookAt(h.target),
            (_e.distanceToSquared(h.object.position) > b || nt !== h.object.zoom) && (h.dispatchEvent(TrackballControls_changeEvent),
            _e.copy(h.object.position),
            nt = h.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type")
        }
        ,
        this.reset = function() {
            it = _,
            at = _,
            h.target.copy(h.target0),
            h.object.position.copy(h.position0),
            h.object.up.copy(h.up0),
            h.object.zoom = h.zoom0,
            h.object.updateProjectionMatrix(),
            _t.subVectors(h.object.position, h.target),
            h.object.lookAt(h.target),
            h.dispatchEvent(TrackballControls_changeEvent),
            _e.copy(h.object.position),
            nt = h.object.zoom
        }
        ,
        this.dispose = function() {
            h.domElement.removeEventListener("contextmenu", ar),
            h.domElement.removeEventListener("pointerdown", Ut),
            h.domElement.removeEventListener("pointercancel", Jt),
            h.domElement.removeEventListener("wheel", lr),
            h.domElement.removeEventListener("pointermove", Ht),
            h.domElement.removeEventListener("pointerup", Kt),
            window.removeEventListener("keydown", or),
            window.removeEventListener("keyup", ir)
        }
        ,
        this.domElement.addEventListener("contextmenu", ar),
        this.domElement.addEventListener("pointerdown", Ut),
        this.domElement.addEventListener("pointercancel", Jt),
        this.domElement.addEventListener("wheel", lr, {
            passive: !1
        }),
        window.addEventListener("keydown", or),
        window.addEventListener("keyup", ir),
        this.handleResize(),
        this.update()
    }
}
var TrackballControls2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let TrackballControls2 = class extends TrackballControls {
    constructor(d, o) {
        super(d, o),
        this.type = "TrackballControls",
        this.enabled = !0,
        this.rotateSpeed = 1,
        this.zoomSpeed = 1.2,
        this.panSpeed = .3,
        this.noRotate = !1,
        this.noZoom = !1,
        this.noPan = !1,
        this.noRoll = !1,
        this.staticMoving = !1,
        this.dynamicDampingFactor = .2,
        this.minDistance = 0,
        this.maxDistance = 999999,
        this.minZoom = 0,
        this.maxZoom = 999999,
        this.object = d
    }
}
;
TrackballControls2_decorate([serialize()], TrackballControls2.prototype, "type", void 0),
TrackballControls2_decorate([uiToggle()], TrackballControls2.prototype, "enabled", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "rotateSpeed", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "zoomSpeed", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "panSpeed", void 0),
TrackballControls2_decorate([uiToggle(), serialize()], TrackballControls2.prototype, "noRotate", void 0),
TrackballControls2_decorate([uiToggle(), serialize()], TrackballControls2.prototype, "noZoom", void 0),
TrackballControls2_decorate([uiToggle(), serialize()], TrackballControls2.prototype, "noPan", void 0),
TrackballControls2_decorate([uiToggle(), serialize()], TrackballControls2.prototype, "noRoll", void 0),
TrackballControls2_decorate([uiToggle(), serialize()], TrackballControls2.prototype, "staticMoving", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "dynamicDampingFactor", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "minDistance", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "maxDistance", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "minZoom", void 0),
TrackballControls2_decorate([uiInput(), serialize()], TrackballControls2.prototype, "maxZoom", void 0),
TrackballControls2 = TrackballControls2_decorate([uiPanel("Track Ball")], TrackballControls2);
class TrackballControlsPlugin extends ACameraControlsPlugin {
    constructor() {
        super(...arguments),
        this.controlsKey = "trackball",
        this._controlsCtor = (o, c) => new TrackballControls2(o,c.ownerDocument ? c : c.documentElement)
    }
}
TrackballControlsPlugin.PluginType = "TrackballControlsPlugin";
var SimplifyModifierPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class SimplifyModifierPlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.simplifyFactor = .5
    }
    get initialized() {
        return !0
    }
    async initialize() {}
    async onAdded(o) {
        await super.onAdded(o),
        this._pickingPlugin = o.getPlugin(PickingPlugin)
    }
    simplifyGeometries(o, c) {
        var h;
        if (!o) {
            const b = (h = this._pickingPlugin) === null || h === void 0 ? void 0 : h.getSelectedObject()
              , _e = [];
            if (b == null || b.traverse(nt => {
                nt.geometry && !_e.includes(nt.geometry) && _e.push(nt.geometry)
            }
            ),
            !(o = _e) || !o.length)
                return
        }
        Array.isArray(o) || (o = [o]);
        const _ = [];
        for (const b of o)
            _.push(this.simplifyGeometry(b, c));
        return _
    }
    simplifyGeometry(o, {factor: c, count: h, replace: _=!0, disposeOnReplace: b=!1}={}) {
        var _e, nt, it;
        if (!o) {
            const At = (_e = this._pickingPlugin) === null || _e === void 0 ? void 0 : _e.getSelectedObject();
            if (!(o = At == null ? void 0 : At.geometry))
                return
        }
        if (!o.attributes.position)
            return (nt = this._viewer) === null || nt === void 0 || nt.console.error("SimplifyModifierPlugin: Geometry does not have position attribute", o),
            o;
        c = c || this.simplifyFactor,
        h = h || o.attributes.position.count * c,
        o.boundingBox || o.computeBoundingBox();
        const at = this._simplify(o, h);
        at.computeBoundingBox(),
        at.computeBoundingSphere(),
        at.computeVertexNormals();
        const ut = at.boundingBox
          , pt = ut.getSize(new three_module.Pq0);
        if (!isFinite(pt.x) || !isFinite(pt.y) || !isFinite(pt.z))
            return (it = this._viewer) === null || it === void 0 || it.console.error("SimplifyModifierPlugin: Unable to simplify", o, at, pt),
            o;
        const ht = o.boundingBox
          , _t = ht.getSize(new three_module.Pq0)
          , vt = pt.clone().sub(_t)
          , bt = vt.clone().divide(_t);
        if (bt.lengthSq() > .001 && console.warn("Simplify", o, at, ut, ht, pt, _t, vt, bt),
        !_)
            return at;
        const St = o.userData.__appliedMeshes;
        if (!St)
            return console.error("No meshes found for geometry, cannot replace", o),
            at;
        for (const At of St)
            At.setGeometry ? At.setGeometry(at) : At.geometry = at;
        return b && o.dispose(!0),
        at
    }
    async simplifyAll(o, c) {
        var h;
        if (!o && this._viewer && (o = this._viewer.scene.modelRoot),
        !o)
            return void console.error("SimplifyModifierPlugin: No root found");
        if (!this.initialized && (await this.initialize(),
        !this.initialized))
            return void ((h = this._viewer) === null || h === void 0 || h.console.error("SimplifyModifierPlugin cannot be initialized"));
        const _ = [];
        if (o.modelObject.traverse(b => {
            b.geometry && !_.includes(b.geometry) && _.push(b.geometry)
        }
        ),
        _.length)
            return this.simplifyGeometries(_, c);
        console.error("SimplifyModifierPlugin: No geometries found")
    }
    async simplifySelected() {
        var o;
        if (!this._viewer)
            return;
        if (!this.initialized && (await this.initialize(),
        !this.initialized))
            return void await this._viewer.alert("Simplify: SimplifyModifierPlugin cannot be initialized");
        const c = (o = this._pickingPlugin) === null || o === void 0 ? void 0 : o.getSelectedObject();
        if (!c)
            return void await this._viewer.alert("Simplify: Nothing Selected");
        let h = !1;
        c.geometry ? c.children.length === 0 && (h = !0) : h = !0,
        h || await this._viewer.confirm("Simplify: Simplify all in hierarchy?") && (h = !0),
        h ? this.simplifyGeometries() : this.simplifyGeometry(c.geometry)
    }
}
SimplifyModifierPlugin.PluginType = "SimplifyModifierPlugin",
SimplifyModifierPlugin_decorate([uiSlider("Simplify Factor", [0, 1])], SimplifyModifierPlugin.prototype, "simplifyFactor", void 0),
SimplifyModifierPlugin_decorate([uiButton("Simplify All", {
    sendArgs: !1
})], SimplifyModifierPlugin.prototype, "simplifyAll", null),
SimplifyModifierPlugin_decorate([uiButton("Simplify Selected")], SimplifyModifierPlugin.prototype, "simplifySelected", null);
var MeshOptSimplifyModifierPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, MeshOptSimplifyModifierPlugin_1;
let MeshOptSimplifyModifierPlugin = MeshOptSimplifyModifierPlugin_1 = class extends SimplifyModifierPlugin {
    constructor(d=!0, o=document.head) {
        super(),
        this.rootNode = o,
        this._initializing = void 0,
        this.errorThreshold = .5,
        this.lockBorder = !1,
        d && this.initialize()
    }
    get initialized() {
        return !!window.MeshoptSimplifier
    }
    async initialize() {
        if (this.initialized)
            return;
        if (this._initializing)
            return await this._initializing;
        const d = document.createElement("script");
        d.type = "module";
        const o = Math.random().toString(36).substring(7);
        return d.innerHTML = `
import { MeshoptSimplifier } from '${MeshOptSimplifyModifierPlugin_1.SIMPLIFIER_URL}';
MeshoptSimplifier.ready.then(() => {
window.MeshoptSimplifier = MeshoptSimplifier;
window.dispatchEvent(new CustomEvent('${o}'))
});
`,
        this._initializing = new Promise(c => {
            window.addEventListener(o, () => c(), {
                once: !0
            }),
            this.rootNode.appendChild(d),
            this._script = d
        }
        ),
        await this._initializing
    }
    dispose() {
        this._script && (this._script.remove(),
        delete window.MeshoptSimplifier),
        this._script = void 0
    }
    _simplify(d, o) {
        if (!this.initialized)
            throw new Error("MeshOptSimplifyModifierPlugin not initialized");
        const c = (d = d.index ? d.clone() : toIndexedGeometry(d)).index.array
          , h = d.attributes.position.array
          , _ = o / d.attributes.position.count
          , b = 3 * Math.floor(_ * c.length / 3)
          , [_e,nt] = window.MeshoptSimplifier.simplify(c, h, 3, b, this.errorThreshold, this.lockBorder ? ["LockBorder"] : []);
        return console.log("srcCount", c.length / 3, "destCount", _e.length / 3),
        nt && console.log("Simplify error", nt),
        d.setIndex(new three_module.THS(new Uint32Array(_e),1)),
        d
    }
}
;
MeshOptSimplifyModifierPlugin.PluginType = "MeshOptSimplifyModifierPlugin",
MeshOptSimplifyModifierPlugin.SIMPLIFIER_URL = "https://unpkg.com/meshoptimizer@0.20.0/meshopt_simplifier.module.js",
MeshOptSimplifyModifierPlugin_decorate([uiInput()], MeshOptSimplifyModifierPlugin.prototype, "errorThreshold", void 0),
MeshOptSimplifyModifierPlugin_decorate([uiToggle()], MeshOptSimplifyModifierPlugin.prototype, "lockBorder", void 0),
MeshOptSimplifyModifierPlugin = MeshOptSimplifyModifierPlugin_1 = MeshOptSimplifyModifierPlugin_decorate([uiFolder("Simplify Modifier (meshopt)")], MeshOptSimplifyModifierPlugin);
class CustomAnimationHelper {
    constructor() {
        this._animations = [],
        this._playingAnimations = new Set,
        this._clock = new three_module.zD7
    }
    loadModel(o) {
        this._model = o,
        this.mixer = new three_module.Iw4(o),
        o && (this._animations = [...o.animations])
    }
    get getMixer() {
        return this.mixer
    }
    get getAnimationClips() {
        return this._animations
    }
    async playAllAnimations(o) {
        var c;
        const h = [];
        (c = this._animations) === null || c === void 0 || c.forEach(_ => {
            h.push(this.playClip(_, o))
        }
        ),
        await Promise.all(h)
    }
    async reverseAllAnimation(o) {
        var c;
        const h = [];
        (c = this._animations) === null || c === void 0 || c.forEach(_ => {
            h.push(this.playClip(_, o, 1, !0))
        }
        ),
        await Promise.all(h)
    }
    async playClip(o, c, h=1, _=!1, b=!1) {
        if (!this.mixer)
            return;
        const _e = this.mixer.clipAction(o);
        return this._playingAnimations.has(_e) && this.mixer.dispatchEvent({
            type: "canceled",
            action: _e
        }),
        b && (this.mixer.setTime(0),
        this.mixer.stopAllAction()),
        _ ? (_e.paused = !1,
        _e.timeScale = -h) : (_e.reset(),
        _e.timeScale = h),
        _e.loop = c ? three_module.aMy : three_module.G3T,
        _e.clampWhenFinished = !0,
        new Promise(nt => {
            const it = async at => {
                at.action === _e && (this.mixer.removeEventListener("finished", it),
                this.mixer.removeEventListener("canceled", it),
                this._playingAnimations.delete(_e),
                nt())
            }
            ;
            this.mixer.addEventListener("finished", it),
            this.mixer.addEventListener("canceled", it),
            this._playingAnimations.add(_e),
            _e.play()
        }
        )
    }
    playClipByName(o, c, h=1, _=!1) {
        let b;
        this._animations.forEach(_e => {
            _e.name === o && (b = _e)
        }
        ),
        b && this.playClip(b, c, h, _)
    }
    update() {
        const o = this._clock.getDelta();
        return this._playingAnimations.size > 0 && (this.mixer.update(o),
        !0)
    }
}
class CustomAnimationHelperPlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.helperIdentities = new Map
    }
    async onAdded(o) {
        var c;
        await super.onAdded(o),
        (c = this._viewer) === null || c === void 0 || c.addEventListener("postFrame", () => {
            this.helperIdentities.forEach(h => {
                var _;
                h.update() && ((_ = this._viewer) === null || _ === void 0 || _.setDirty())
            }
            )
        }
        )
    }
    createHelper(o, c) {
        var h;
        if (this.helperIdentities.has(o))
            (h = this._viewer) === null || h === void 0 || h.console.warn("Helper with this id already exists");
        else {
            const _ = new CustomAnimationHelper;
            _.loadModel(c),
            this.helperIdentities.set(o, _)
        }
    }
    getAnimationClips(o) {
        if (this.helperIdentities.has(o))
            return this.helperIdentities.get(o).getAnimationClips
    }
    async playClip(o, c, h, _=1, b=!1, _e=!1) {
        this.helperIdentities.has(o) && await this.helperIdentities.get(o).playClip(c, h, _, b, _e)
    }
    async playAllAnimations(o, c) {
        this.helperIdentities.has(o) && await this.helperIdentities.get(o).playAllAnimations(c)
    }
    async playAllAnimationsInReverse(o, c) {
        this.helperIdentities.has(o) && await this.helperIdentities.get(o).reverseAllAnimation(c)
    }
    async playAnimationByName(o, c, h, _=1, b=!1) {
        this.helperIdentities.has(o) && await this.helperIdentities.get(o).playClipByName(c, h, _, b)
    }
}
CustomAnimationHelperPlugin.PluginType = "AnimationHelperPlugin";
class FileTransferPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this.defaultActions = {
            exportFile: async (o, c, h) => {
                N$2(o, c)
            }
        },
        this.actions = {
            ...this.defaultActions
        }
    }
    async exportFile(o, c) {
        c = c || o.name || "file_export",
        this.dispatchEvent({
            type: "transferFile",
            path: c,
            state: "exporting"
        }),
        await this.actions.exportFile(o, c, ({state: h, progress: _}) => {
            this.dispatchEvent({
                type: "transferFile",
                path: c,
                state: h ?? "exporting",
                progress: _
            })
        }
        ),
        this.dispatchEvent({
            type: "transferFile",
            path: c,
            state: "done"
        })
    }
}
FileTransferPlugin.PluginType = "FileTransferPlugin";
var CameraViewControlPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class CameraViewControlPlugin extends AViewerPlugin {
    _onEnabledChanged1() {
        this._onEnabledChanged()
    }
    _onEnabledChanged() {
        this._viewer && (this._viewer.scene.activeCamera.interactionsEnabled = !this.enabled);
        const o = this._cameraViews.length;
        this._oldState = o < 2 ? 0 : three_module.cj9.clamp(this._currentState, 0, o - 1.001),
        this.enabled && this._animateCameraToView(),
        this.dispatchEvent({
            type: "enableChanged",
            enabled: this.enabled
        })
    }
    constructor(o=!0) {
        super(),
        this.enabled = !0,
        this.animEase = "easeInOutSine",
        this.interpolateMode = "spherical",
        this.enableDamping = !0,
        this.damping = .04,
        this.initAnimationTime = 1,
        this.dependencies = [CameraViewPlugin],
        this._currentState = 0,
        this._oldState = 0,
        this._overrideTime = 0,
        this._preFrame1 = c => {
            this._preFrame(c)
        }
        ,
        this.enabled = o,
        this._onEnabledChanged1 = this._onEnabledChanged1.bind(this)
    }
    get _cameraViews() {
        var o, c, h;
        return (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(CameraViewPlugin)) === null || c === void 0 ? void 0 : c.camViews) !== null && h !== void 0 ? h : []
    }
    setState(o) {
        this._currentState = o
    }
    async onAdded(o) {
        await super.onAdded(o),
        this.enabled && this._onEnabledChanged(),
        o.addEventListener("preFrame", this._preFrame1)
    }
    async onRemove(o) {
        return o.removeEventListener("preFrame", this._preFrame1),
        this.enabled = !1,
        super.onRemove(o)
    }
    _preFrame(o) {
        var c;
        if (!this.enabled)
            return;
        const h = this._cameraViews;
        if (h.length <= 1 || !this._overrideStartView && Math.abs(this._currentState - this._oldState) < .001)
            return;
        this.enableDamping ? this._oldState = three_module.cj9.lerp(this._oldState, this._currentState, this.damping) : this._oldState = this._currentState,
        this._oldState = three_module.cj9.clamp(this._oldState, 0, h.length - 1.001);
        const _ = Math.floor(this._oldState)
          , b = this._overrideStartView || h[_]
          , _e = this._overrideEndView || h[_ + 1];
        let nt, it = this._overrideStartView ? this._overrideTime : this._oldState - _;
        it = EasingFunctions[this.animEase](it),
        nt = this.interpolateMode === "spherical" ? this._lerpViewsSpherical(b, _e, it) : this._lerpViewsLinear(b, _e, it);
        const at = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.activeCamera;
        at && (at.position.copy(nt[0]),
        at.target.copy(nt[1]),
        at.positionTargetUpdated(!0)),
        this._overrideStartView && (this._overrideTime += o.deltaTime / 1e3,
        this._overrideTime >= this.initAnimationTime && (this._overrideTime = 0,
        this._overrideStartView = void 0,
        this._overrideEndView = void 0))
    }
    _lerpViewsLinear(o, c, h) {
        const _ = new three_module.Pq0
          , b = new three_module.Pq0;
        return b.lerpVectors(o.position, c.position, h),
        _.lerpVectors(o.target, c.target, h),
        [b, _]
    }
    _lerpViewsSpherical(o, c, h) {
        const _ = o.target.clone()
          , b = new three_module.Pq0
          , _e = new three_module.Pq0
          , nt = sphericalFromObject(o, o.target)
          , it = sphericalFromObject(c, c.target)
          , at = new three_module.YHV;
        return at.phi = lerpAngle(nt.phi, it.phi, h),
        at.theta = lerpAngle(nt.theta, it.theta, h),
        at.radius = three_module.cj9.lerp(nt.radius, it.radius, h),
        b.copy(_).lerp(c.target, h),
        _e.setFromSpherical(at),
        _e.add(b),
        [_e, b]
    }
    _animateCameraToView() {
        const o = this._cameraViews;
        if (!this._viewer || o.length < 2 || !this.enabled)
            return;
        this._overrideStartView = new CameraView(this._viewer.scene.activeCamera.position,this._viewer.scene.activeCamera.target);
        const c = Math.floor(this._oldState)
          , h = this._oldState - c;
        let _;
        _ = this.interpolateMode === "spherical" ? this._lerpViewsSpherical(o[c], o[c + 1], h) : this._lerpViewsLinear(o[c], o[c + 1], h),
        this._overrideEndView = new CameraView(_[0],_[1]),
        this._overrideTime = 0
    }
}
CameraViewControlPlugin.PluginType = "CameraViewControlPlugin",
CameraViewControlPlugin_decorate([uiToggle("Enabled"), x$1(CameraViewControlPlugin.prototype._onEnabledChanged1), serialize()], CameraViewControlPlugin.prototype, "enabled", void 0),
CameraViewControlPlugin_decorate([serialize(), uiDropdown("Ease", Object.keys(EasingFunctions).map(d => ({
    label: d
})))], CameraViewControlPlugin.prototype, "animEase", void 0),
CameraViewControlPlugin_decorate([serialize(), uiDropdown("Interpolation", ["spherical", "linear"].map(d => ({
    label: d
})))], CameraViewControlPlugin.prototype, "interpolateMode", void 0),
CameraViewControlPlugin_decorate([uiToggle("Enable Damping"), serialize()], CameraViewControlPlugin.prototype, "enableDamping", void 0),
CameraViewControlPlugin_decorate([uiSlider("Damping", [.01, 1], .001), serialize()], CameraViewControlPlugin.prototype, "damping", void 0),
CameraViewControlPlugin_decorate([uiSlider("Init Anim Time", [.01, 5], .001), serialize()], CameraViewControlPlugin.prototype, "initAnimationTime", void 0);
class ScrollableCameraViewPlugin extends CameraViewControlPlugin {
    constructor(o=document.body, c=!0) {
        super(c),
        this.wrapper = document.createElement("div"),
        this.toJSON = void 0,
        this.uiConfig = {
            type: "folder",
            label: "Scrollable Camera Views",
            children: [...generateUiConfig(this)]
        },
        typeof o == "string" ? (this.parent = document.getElementById(o),
        this.parent || (console.error("parent doesn't exist"),
        this.parent = document.body)) : this.parent = o
    }
    _preFrame(o) {
        var c;
        if (this.enabled && !(this._cameraViews.length <= 1))
            try {
                const h = this._findActiveView()
                  , _ = this._getScroll(h);
                this.setState(_ + h),
                super._preFrame(o)
            } catch (h) {
                return void (((c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("Debug")) && console.error(h))
            }
    }
    _getScroll(o) {
        var c, h;
        if (o >= this._cameraViews.length - 1)
            return 0;
        const _ = (c = this.parent.querySelector(this._cameraViews[o].name)) !== null && c !== void 0 ? c : this.parent.getElementsByTagName("section")[o]
          , b = (h = this.parent.querySelector(this._cameraViews[o + 1].name)) !== null && h !== void 0 ? h : this.parent.getElementsByTagName("section")[o + 1]
          , _e = this.parent.getBoundingClientRect();
        if (!_ || !b)
            return 0;
        const nt = _.getBoundingClientRect()
          , it = b.getBoundingClientRect()
          , at = this.parent === document.body ? 0 : _e.top;
        return three_module.cj9.clamp((at - nt.top) / Math.max(it.top - nt.top, 1e-4), 0, 1)
    }
    _findActiveView() {
        var o, c;
        for (let h = this._cameraViews.length - 1; h >= 0; h--) {
            const _ = (o = this.parent.querySelector(this._cameraViews[h].name)) !== null && o !== void 0 ? o : this.parent.getElementsByTagName("section")[h]
              , b = this.parent.getBoundingClientRect();
            if (_) {
                if (_.getBoundingClientRect().top < (this.parent === document.body ? 0 : b.top))
                    return h
            } else
                !((c = this._cameraViews[h].name) === null || c === void 0) && c.startsWith("#") && console.error("section with id " + this._cameraViews[h].name + " doesn't exist!")
        }
        return 0
    }
}
ScrollableCameraViewPlugin.PluginType = "ScrollableCameraViewPlugin";
var ScrollableCameraViewPreviewPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let ScrollableCameraViewPreviewPlugin = class extends ScrollableCameraViewPlugin {
    generateCode() {
        var d;
        const o = document.createElement("div");
        o.style.position = "absolute",
        o.style.top = "0",
        o.style.width = "100%",
        o.style.height = "100%",
        o.style.display = "flex",
        o.style.flexDirection = "column",
        o.style.justifyContent = "center",
        o.style.alignItems = "center",
        o.style.zIndex = "200";
        const c = document.createElement("textarea");
        c.rows = 20,
        c.style.border = "3px solid #27223a",
        c.style.borderRadius = "5px",
        c.style.width = "30%",
        c.style.padding = "5px",
        c.style.zIndex = "1000";
        const h = document.createElement("div");
        h.textContent = "X",
        h.style.color = "red",
        h.style.width = "20px",
        h.style.height = "20px",
        h.style.padding = "2",
        h.style.textAlign = "center",
        h.style.backgroundColor = "white",
        h.style.borderRadius = "100%",
        h.style.border = "2px solid #27223a",
        h.style.cursor = "pointer",
        h.addEventListener("click", () => {
            var b;
            (b = this._viewer) === null || b === void 0 || b.container.removeChild(o)
        }
        );
        const _ = document.createElement("div");
        _.textContent = "Update",
        _.style.marginTop = "10px",
        _.style.color = "white",
        _.style.padding = "4px 10px 4px 10px",
        _.style.justifyContent = "center",
        _.style.alignItems = "center",
        _.style.backgroundColor = "green",
        _.style.borderRadius = "10px",
        _.style.border = "2px solid #fff",
        _.style.cursor = "pointer",
        _.addEventListener("click", () => {
            var b, _e;
            const nt = this.parent.innerHTML;
            this.parent.innerHTML = c.value;
            let it = 0;
            for (; it < this._cameraViews.length; it++) {
                let at;
                try {
                    at = (b = this.parent.querySelector(this._cameraViews[it].name)) !== null && b !== void 0 ? b : this.parent.getElementsByTagName("section")[it]
                } catch {
                    at = null
                }
                if (!at && it < 2) {
                    alert("you need to add 2 sections at least");
                    break
                }
                if (!at) {
                    const ut = ((_e = this._cameraViews[it].name) === null || _e === void 0 || _e.startsWith("#"),
                    this._cameraViews[it].name.replace(/^#/, ""));
                    c.value += ut,
                    c.value = this._format(c.value)
                }
            }
            it < 2 ? this.parent.innerHTML = nt : setInnerHTMLWithScripts(this.parent, c.value)
        }
        ),
        o.appendChild(h),
        o.appendChild(c),
        o.appendChild(_),
        c.value = this._format(this.parent.innerHTML),
        (d = this._viewer) === null || d === void 0 || d.container.appendChild(o)
    }
    _onEnabledChanged() {
        super._onEnabledChanged(),
        this._togglePreview()
    }
    _togglePreview() {
        this.wrapper && (this.wrapper.style.zIndex = this.canvasUp ? "-100" : "100",
        this.wrapper.style.visibility = this.enabled ? "visible" : "hidden",
        this._viewer && (this._viewer.canvas.style.pointerEvents = this.enabled && this.canvasUp ? "none" : "auto"))
    }
    constructor(d=document.body, o=!1) {
        super(d, o),
        this.canvasUp = !1,
        this._togglePreview = this._togglePreview.bind(this),
        this.generateCode = this.generateCode.bind(this)
    }
    async onAdded(d) {
        var o, c, h, _, b, _e;
        this.parent = this.wrapper,
        await super.onAdded(d),
        this._addWrapper(),
        this._togglePreview(),
        this.deserialize = this.deserialize.bind(this),
        this.addView = this.addView.bind(this),
        this.deleteView = this.deleteView.bind(this),
        (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(CameraViewPlugin)) === null || c === void 0 || c.addEventListener("viewDelete", this.deleteView),
        (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPlugin(CameraViewPlugin)) === null || _ === void 0 || _.addEventListener("deserialize", this.deserialize),
        (_e = (b = this._viewer) === null || b === void 0 ? void 0 : b.getPlugin(CameraViewPlugin)) === null || _e === void 0 || _e.addEventListener("viewAdd", this.addView)
    }
    deserialize(d) {
        this._cameraViews.forEach(o => {
            this._createSection(o.name)
        }
        )
    }
    _addWrapper() {
        var d;
        this.wrapper.style.width = "100%",
        this.wrapper.style.height = "100%",
        this.wrapper.style.zIndex = "-100",
        this.wrapper.style.position = "absolute",
        this.wrapper.style.top = "0",
        this.wrapper.id = "parentWrapper",
        this.wrapper.style.borderRadius = "10px",
        this.wrapper.style.overflowY = "scroll",
        this.wrapper.style.overflowX = "hidden",
        (d = this._viewer) === null || d === void 0 || d.container.appendChild(this.wrapper)
    }
    _createSection(d) {
        const o = document.createElement("section");
        o.style.width = "100%",
        o.style.height = "100%",
        o.style.opacity = "50%",
        o.style.backgroundColor = "black",
        o.style.zIndex = "100",
        o.style.top = "0",
        o.textContent = d,
        o.style.color = "white",
        o.style.fontSize = "100px",
        o.style.display = "flex",
        o.style.alignItems = "center",
        o.style.justifyContent = "center",
        o.id = d,
        this.parent.appendChild(o)
    }
    addView(d) {
        this._cameraViews.forEach( (o, c) => {
            var h, _;
            let b;
            try {
                b = (h = this.parent.querySelector(o.name)) !== null && h !== void 0 ? h : this.parent.getElementsByTagName("section")[c]
            } catch {
                b = null
            }
            if (!b) {
                const _e = `<section id="${!((_ = o.name) === null || _ === void 0) && _.startsWith("#") ? o.name.replace(/^#/, "") : ""}" style="width: 100%; height: 100%; opacity: 0.5; background-color: black; z-index: 100; top: 0px; color: white; font-size: 100px; display: flex; align-items: center; justify-content: center;">
                    ${o.name}
                    </section>`;
                this.parent.innerHTML += _e
            }
        }
        )
    }
    deleteView(d) {
        var o;
        try {
            const c = (o = this.parent.querySelector(d.view.name)) !== null && o !== void 0 ? o : this.parent.getElementsByTagName("section").namedItem(d.view.name);
            c == null || c.remove()
        } catch {
            return
        }
    }
    _format(d) {
        let o = ""
          , c = "";
        return d.split(/>\s*</).forEach(function(h) {
            h.match(/^\/\w/) && (c = c.substring(1)),
            o += c + "<" + h + `>\r
`,
            h.match(/^<?\w[^>]*[^/]$/) && !h.startsWith("input") && (c += "	")
        }),
        o.substring(1, o.length - 3)
    }
}
;
ScrollableCameraViewPreviewPlugin_decorate([uiButton("Show/Edit Code")], ScrollableCameraViewPreviewPlugin.prototype, "generateCode", null),
ScrollableCameraViewPreviewPlugin_decorate([uiToggle("Canvas on top"), x$1(ScrollableCameraViewPreviewPlugin.prototype._togglePreview)], ScrollableCameraViewPreviewPlugin.prototype, "canvasUp", void 0),
ScrollableCameraViewPreviewPlugin = ScrollableCameraViewPreviewPlugin_decorate([uiFolder("Scrollable Camera View Preview (Dev)")], ScrollableCameraViewPreviewPlugin);
var build_e = {
    d: (d, o) => {
        for (var c in o)
            build_e.o(o, c) && !build_e.o(d, c) && Object.defineProperty(d, c, {
                enumerable: !0,
                get: o[c]
            })
    }
    ,
    o: (d, o) => Object.prototype.hasOwnProperty.call(d, o)
}
  , build_t = {};
build_e.d(build_t, {
    e: () => build_R
});
var build_n = function(d, o, c, h) {
    return new (c || (c = Promise))(function(_, b) {
        function _e(at) {
            try {
                it(h.next(at))
            } catch (ut) {
                b(ut)
            }
        }
        function nt(at) {
            try {
                it(h.throw(at))
            } catch (ut) {
                b(ut)
            }
        }
        function it(at) {
            var ut;
            at.done ? _(at.value) : (ut = at.value,
            ut instanceof c ? ut : new c(function(pt) {
                pt(ut)
            }
            )).then(_e, nt)
        }
        it((h = h.apply(d, [])).next())
    }
    )
};
class build_r {
    constructor(o, c={
        resolution: 2048
    }, h={}, _=!1, b=!1, _e=!1) {
        this.THREE = o,
        this.packOptions = c,
        this.chartOptions = h,
        this.useNormals = _,
        this.timeUnwrap = b,
        this.logProgress = _e,
        this._libraryLoaded = !1,
        this._isUnwrapping = !1,
        this.xAtlas = this._createXAtlas()
    }
    loadLibrary(o, c, h) {
        return build_n(this, void 0, void 0, function*() {
            if (!this._libraryLoaded) {
                for (yield new Promise( (_, b) => {
                    try {
                        this.xAtlas.init(_, o, c, h)
                    } catch (_e) {
                        b(_e)
                    }
                }
                ); !this.xAtlas.api || !(yield this.xAtlas.api.loaded); )
                    yield new Promise(_ => setTimeout(_, 100));
                this._libraryLoaded = !0
            }
        })
    }
    packAtlas(o, c="uv2", h="uv") {
        return build_n(this, void 0, void 0, function*() {
            if (!this._libraryLoaded)
                throw new Error("xatlas-three: library not loaded");
            if (!o)
                throw new Error("xatlas-three: nodeList argument not provided");
            if (o.length < 1)
                throw new Error("xatlas-three: nodeList must have non-zero length");
            const _ = this.chartOptions.useInputMeshUvs;
            for (; this._isUnwrapping; )
                console.log("xatlas-three: unwrapping another mesh, waiting 100 ms"),
                yield new Promise(at => setTimeout(at, 100));
            this._isUnwrapping = !0,
            yield this.xAtlas.api.setProgressLogging(this.logProgress),
            yield this.xAtlas.api.createAtlas();
            let b = []
              , _e = "";
            for (let at of o) {
                let {uuid: ut, index: pt, attributes: ht} = at;
                const _t = at.userData.worldScale || 1;
                b.push(ut),
                pt && ht.position && ht.position.itemSize === 3 ? (_e = "Mesh" + b.length + " added to atlas: " + ut,
                this.timeUnwrap && console.time(_e),
                yield this.xAtlas.api.addMesh(pt.array, ht.position.array, ht.normal ? ht.normal.array : void 0, ht.uv ? ht.uv.array : void 0, ut, this.useNormals, _, _t),
                this.timeUnwrap && console.timeEnd(_e)) : console.warn("xatlas-three: Geometry not supported: ", at)
            }
            _e = "Generated atlas with " + b.length + " meshes",
            this.timeUnwrap && console.time(_e);
            const nt = yield this.xAtlas.api.generateAtlas(this.chartOptions, this.packOptions, !0);
            this.timeUnwrap && console.timeEnd(_e);
            let it = [];
            for (let at of nt.meshes) {
                let ut = o.find(_t => _t.uuid === at.mesh);
                if (!ut) {
                    console.error("xatlas-three: Geometry not found: ", at.mesh);
                    continue
                }
                at.vertex.vertices && ut.setAttribute("position", new this.THREE.BufferAttribute(at.vertex.vertices,3,!1)),
                at.vertex.normals && ut.setAttribute("normal", new this.THREE.BufferAttribute(at.vertex.normals,3,!0)),
                at.vertex.coords1 && ut.setAttribute(c, new this.THREE.BufferAttribute(at.vertex.coords1,2,!1)),
                at.vertex.coords && c !== h && ut.setAttribute(h, new this.THREE.BufferAttribute(at.vertex.coords,2,!1)),
                at.index && ut.setIndex(new this.THREE.BufferAttribute(at.index,1,!1)),
                at.subMeshes && (ut.userData.xAtlasSubMeshes = structuredClone(at.subMeshes));
                const pt = at.oldIndexes
                  , ht = ut.attributes;
                for (const _t in ht) {
                    if (_t === "position" || _t === "normal" || _t === c || _t === h)
                        continue;
                    const vt = ht[_t]
                      , bt = vt.array.constructor
                      , St = vt.itemSize
                      , At = vt.array
                      , Et = new bt(pt.length * St)
                      , Pt = new this.THREE.BufferAttribute(Et,St,vt.normalized);
                    Pt.gpuType = vt.gpuType;
                    for (let It = 0, Dt = pt.length; It < Dt; It++) {
                        const Gt = pt[It];
                        for (let Bt = 0; Bt < St; Bt++)
                            Et[It * St + Bt] = At[Gt * St + Bt]
                    }
                    ut.setAttribute(_t, Pt)
                }
                it.push(ut)
            }
            return yield this.xAtlas.api.destroyAtlas(),
            this._isUnwrapping = !1,
            {
                width: nt.width,
                height: nt.height,
                atlasCount: nt.atlasCount,
                meshCount: nt.meshCount,
                texelsPerUnit: nt.texelsPerUnit,
                geometries: it,
                meshes: nt.meshes
            }
        })
    }
    unwrapGeometry(o, c="uv", h="uv2") {
        return build_n(this, void 0, void 0, function*() {
            return this.packAtlas([o], c, h)
        })
    }
}
class build_s {
}
const build_i = Symbol("Comlink.proxy")
  , build_a = Symbol("Comlink.endpoint")
  , build_o = Symbol("Comlink.releaseProxy")
  , build_l = Symbol("Comlink.finalizer")
  , build_u = Symbol("Comlink.thrown")
  , build_c = d => typeof d == "object" && d !== null || typeof d == "function"
  , build_h = new Map([["proxy", {
    canHandle: d => build_c(d) && d[build_i],
    serialize(d) {
        const {port1: o, port2: c} = new MessageChannel;
        return build_p(d, o),
        [c, [c]]
    },
    deserialize: d => (d.start(),
    build_f(d))
}], ["throw", {
    canHandle: d => build_c(d) && build_u in d,
    serialize({value: d}) {
        let o;
        return o = d instanceof Error ? {
            isError: !0,
            value: {
                message: d.message,
                name: d.name,
                stack: d.stack
            }
        } : {
            isError: !1,
            value: d
        },
        [o, []]
    },
    deserialize(d) {
        throw d.isError ? Object.assign(new Error(d.value.message), d.value) : d.value
    }
}]]);
function build_p(d, o=globalThis, c=["*"]) {
    o.addEventListener("message", function h(_) {
        if (!_ || !_.data)
            return;
        if (!function(ut, pt) {
            for (const ht of ut)
                if (pt === ht || ht === "*" || ht instanceof RegExp && ht.test(pt))
                    return !0;
            return !1
        }(c, _.origin))
            return void console.warn(`Invalid origin '${_.origin}' for comlink proxy`);
        const {id: b, type: _e, path: nt} = Object.assign({
            path: []
        }, _.data)
          , it = (_.data.argumentList || []).map(build_L);
        let at;
        try {
            const ut = nt.slice(0, -1).reduce( (ht, _t) => ht[_t], d)
              , pt = nt.reduce( (ht, _t) => ht[_t], d);
            switch (_e) {
            case "GET":
                at = pt;
                break;
            case "SET":
                ut[nt.slice(-1)[0]] = build_L(_.data.value),
                at = !0;
                break;
            case "APPLY":
                at = pt.apply(ut, it);
                break;
            case "CONSTRUCT":
                at = build_x(new pt(...it));
                break;
            case "ENDPOINT":
                {
                    const {port1: ht, port2: _t} = new MessageChannel;
                    build_p(d, _t),
                    at = function(vt, bt) {
                        return build_E.set(vt, bt),
                        vt
                    }(ht, [ht])
                }
                break;
            case "RELEASE":
                at = void 0;
                break;
            default:
                return
            }
        } catch (ut) {
            at = {
                value: ut,
                [build_u]: 0
            }
        }
        Promise.resolve(at).catch(ut => ({
            value: ut,
            [build_u]: 0
        })).then(ut => {
            const [pt,ht] = build_A(ut);
            o.postMessage(Object.assign(Object.assign({}, pt), {
                id: b
            }), ht),
            _e === "RELEASE" && (o.removeEventListener("message", h),
            build_d(o),
            build_l in d && typeof d[build_l] == "function" && d[build_l]())
        }
        ).catch(ut => {
            const [pt,ht] = build_A({
                value: new TypeError("Unserializable return value"),
                [build_u]: 0
            });
            o.postMessage(Object.assign(Object.assign({}, pt), {
                id: b
            }), ht)
        }
        )
    }),
    o.start && o.start()
}
function build_d(d) {
    (function(o) {
        return o.constructor.name === "MessagePort"
    }
    )(d) && d.close()
}
function build_f(d, o) {
    return build_v(d, [], o)
}
function build_m(d) {
    if (d)
        throw new Error("Proxy has been released and is not useable")
}
function build_g(d) {
    return build_P(d, {
        type: "RELEASE"
    }).then( () => {
        build_d(d)
    }
    )
}
const build_y = new WeakMap
  , build_w = "FinalizationRegistry"in globalThis && new FinalizationRegistry(d => {
    const o = (build_y.get(d) || 0) - 1;
    build_y.set(d, o),
    o === 0 && build_g(d)
}
);
function build_v(d, o=[], c=function() {}
) {
    let h = !1;
    const _ = new Proxy(c,{
        get(b, _e) {
            if (build_m(h),
            _e === build_o)
                return () => {
                    (function(nt) {
                        build_w && build_w.unregister(nt)
                    }
                    )(_),
                    build_g(d),
                    h = !0
                }
                ;
            if (_e === "then") {
                if (o.length === 0)
                    return {
                        then: () => _
                    };
                const nt = build_P(d, {
                    type: "GET",
                    path: o.map(it => it.toString())
                }).then(build_L);
                return nt.then.bind(nt)
            }
            return build_v(d, [...o, _e])
        },
        set(b, _e, nt) {
            build_m(h);
            const [it,at] = build_A(nt);
            return build_P(d, {
                type: "SET",
                path: [...o, _e].map(ut => ut.toString()),
                value: it
            }, at).then(build_L)
        },
        apply(b, _e, nt) {
            build_m(h);
            const it = o[o.length - 1];
            if (it === build_a)
                return build_P(d, {
                    type: "ENDPOINT"
                }).then(build_L);
            if (it === "bind")
                return build_v(d, o.slice(0, -1));
            const [at,ut] = build_b(nt);
            return build_P(d, {
                type: "APPLY",
                path: o.map(pt => pt.toString()),
                argumentList: at
            }, ut).then(build_L)
        },
        construct(b, _e) {
            build_m(h);
            const [nt,it] = build_b(_e);
            return build_P(d, {
                type: "CONSTRUCT",
                path: o.map(at => at.toString()),
                argumentList: nt
            }, it).then(build_L)
        }
    });
    return function(b, _e) {
        const nt = (build_y.get(_e) || 0) + 1;
        build_y.set(_e, nt),
        build_w && build_w.register(b, _e, b)
    }(_, d),
    _
}
function build_b(d) {
    const o = d.map(build_A);
    return [o.map(h => h[0]), (c = o.map(h => h[1]),
    Array.prototype.concat.apply([], c))];
    var c
}
const build_E = new WeakMap;
function build_x(d) {
    return Object.assign(d, {
        [build_i]: !0
    })
}
function build_A(d) {
    for (const [o,c] of build_h)
        if (c.canHandle(d)) {
            const [h,_] = c.serialize(d);
            return [{
                type: "HANDLER",
                name: o,
                value: h
            }, _]
        }
    return [{
        type: "RAW",
        value: d
    }, build_E.get(d) || []]
}
function build_L(d) {
    switch (d.type) {
    case "HANDLER":
        return build_h.get(d.name).deserialize(d.value);
    case "RAW":
        return d.value
    }
}
function build_P(d, o, c) {
    return new Promise(h => {
        const _ = new Array(4).fill(0).map( () => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join("-");
        d.addEventListener("message", function b(_e) {
            _e.data && _e.data.id && _e.data.id === _ && (d.removeEventListener("message", b),
            h(_e.data))
        }),
        d.start && d.start(),
        d.postMessage(Object.assign({
            id: _
        }, o), c)
    }
    )
}
class build_T extends build_s {
    init(o, c, h, _) {
        if (!this.api) {
            if (!_)
                throw new Error("workerFilePath is required");
            ( () => {
                var b, _e, nt;
                b = this,
                nt = function*() {
                    const it = yield fetch(_).then(pt => pt.blob())
                      , at = URL.createObjectURL(it)
                      , ut = new Worker(at,{
                        type: "module"
                    });
                    this.api = yield new (build_f(ut))(build_x( () => {
                        o(),
                        URL.revokeObjectURL(at)
                    }
                    ),build_x( (pt, ht) => pt === "xatlas.wasm" ? h : pt + ht),build_x(c))
                }
                ,
                new ((_e = void 0) || (_e = Promise))(function(it, at) {
                    function ut(_t) {
                        try {
                            ht(nt.next(_t))
                        } catch (vt) {
                            at(vt)
                        }
                    }
                    function pt(_t) {
                        try {
                            ht(nt.throw(_t))
                        } catch (vt) {
                            at(vt)
                        }
                    }
                    function ht(_t) {
                        var vt;
                        _t.done ? it(_t.value) : (vt = _t.value,
                        vt instanceof _e ? vt : new _e(function(bt) {
                            bt(vt)
                        }
                        )).then(ut, pt)
                    }
                    ht((nt = nt.apply(b, [])).next())
                }
                )
            }
            )()
        }
    }
}
class build_R extends build_r {
    _createXAtlas() {
        return new build_T
    }
}
var build_k = build_t.e, XAtlasPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, XAtlasPlugin_1;
let UChartOptions = class {
    constructor() {
        this.fixWinding = !1,
        this.maxBoundaryLength = 0,
        this.maxChartArea = 0,
        this.maxCost = 2,
        this.maxIterations = 1,
        this.normalDeviationWeight = 2,
        this.normalSeamWeight = 4,
        this.roundnessWeight = .009999999776482582,
        this.straightnessWeight = 6,
        this.textureSeamWeight = .5,
        this.useInputMeshUvs = !1
    }
}
;
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "fixWinding", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "maxBoundaryLength", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "maxChartArea", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "maxCost", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "maxIterations", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "normalDeviationWeight", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "normalSeamWeight", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "roundnessWeight", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "straightnessWeight", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "textureSeamWeight", void 0),
XAtlasPlugin_decorate([serialize()], UChartOptions.prototype, "useInputMeshUvs", void 0),
UChartOptions = XAtlasPlugin_decorate([uiFolder("Chart Options"), serializable("UChartOptions")], UChartOptions);
let UPackOptions = class {
    constructor() {
        this.bilinear = !0,
        this.blockAlign = !1,
        this.bruteForce = !1,
        this.createImage = !1,
        this.maxChartSize = 0,
        this.padding = 0,
        this.resolution = 0,
        this.rotateCharts = !0,
        this.rotateChartsToAxis = !0,
        this.texelsPerUnit = 0
    }
}
;
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "bilinear", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "blockAlign", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "bruteForce", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "createImage", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "maxChartSize", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "padding", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "resolution", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "rotateCharts", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "rotateChartsToAxis", void 0),
XAtlasPlugin_decorate([serialize()], UPackOptions.prototype, "texelsPerUnit", void 0),
UPackOptions = XAtlasPlugin_decorate([uiFolder("Pack Options"), serializable("UPackOptions")], UPackOptions);
let XAtlasPlugin = XAtlasPlugin_1 = class extends AViewerPlugin {
    constructor(d=!1) {
        super(),
        this.enabled = !0,
        this.useNormals = !0,
        this.chartOptions = new UChartOptions,
        this.packOptions = new UPackOptions,
        this._loaded = !1,
        this._unwrapProgress = (o, c) => {
            console.log("Unwrapping", o, c)
        }
        ,
        this.unwrapSelected = async () => {
            var o, c, h, _, b;
            const _e = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.getSelectedObject();
            if (_e)
                if (_e.geometry) {
                    if (_e.geometry.attributes.uv && !await ((b = this._viewer) === null || b === void 0 ? void 0 : b.confirm("Unwrap: Geometry already has UVs. Overwrite?")))
                        return;
                    await this.unwrapGeometry(_e.geometry)
                } else
                    (_ = this._viewer) === null || _ === void 0 || _.alert("Unwrap: Selected object has no geometry");
            else
                (h = this._viewer) === null || h === void 0 || h.alert("Unwrap: No object selected")
        }
        ,
        d && this.loadLibrary()
    }
    async loadLibrary() {
        if (this._unwrapper)
            for (; !this._loaded; )
                await X$2(100);
        else
            this._unwrapper = new build_k({
                BufferAttribute: three_module.THS
            },this.packOptions,this.chartOptions,this.useNormals),
            await this._unwrapper.loadLibrary(this._unwrapProgress, XAtlasPlugin_1.LIBRARY_PATH + "xatlas.wasm", XAtlasPlugin_1.LIBRARY_PATH + "xatlas.js"),
            console.log("xatlas loaded"),
            this._loaded = !0
    }
    async unwrapGeometry(d, o="uv", c="uv") {
        var h;
        await this.loadLibrary(),
        await ((h = this._unwrapper) === null || h === void 0 ? void 0 : h.unwrapGeometry(d, o, c))
    }
    async packAtlas(d, o=!0, c="uv2", h="uv") {
        var _;
        await this.loadLibrary(),
        Array.isArray(d) || (d = [d]);
        const b = [];
        o ? d.forEach(_e => _e.traverse(nt => {
            nt.geometry && b.push(nt.geometry)
        }
        )) : d.forEach(_e => {
            _e.geometry && b.push(_e.geometry)
        }
        ),
        await ((_ = this._unwrapper) === null || _ === void 0 ? void 0 : _.packAtlas(b, c, h))
    }
    _useNormalsChanged() {
        this._unwrapper && (this._unwrapper.useNormals = this.useNormals)
    }
}
;
XAtlasPlugin.PluginType = "XAtlasPlugin",
XAtlasPlugin.LIBRARY_PATH = "https://cdn.jsdelivr.net/npm/xatlasjs@0.1.0/dist/",
XAtlasPlugin_decorate([x$1(XAtlasPlugin.prototype._useNormalsChanged), serialize()], XAtlasPlugin.prototype, "useNormals", void 0),
XAtlasPlugin_decorate([serialize()], XAtlasPlugin.prototype, "chartOptions", void 0),
XAtlasPlugin_decorate([serialize()], XAtlasPlugin.prototype, "packOptions", void 0),
XAtlasPlugin_decorate([uiButton("Unwrap Selected Geometry")], XAtlasPlugin.prototype, "unwrapSelected", void 0),
XAtlasPlugin = XAtlasPlugin_1 = XAtlasPlugin_decorate([uiFolder("UV Unwrapping (xAtlas)")], XAtlasPlugin);
class VariationConfiguratorPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.dependencies = [AssetManagerPlugin],
        this.enabled = !0,
        this.serializeWithViewer = !1,
        this.baseUrl = "",
        this.variations = {
            objects: [],
            materials: []
        },
        this.autoDispose = !0,
        this._ty = ["objects", "materials"],
        this._extForType = {
            objects: ["glb", "fbx", "obj", "gltf", "stl", "3dm", "json", "vjson"],
            materials: ["pmat", "dmat"],
            images: ["png", "jpg", "jpeg", "gif", "bmp", "webp", "svg"]
        },
        this.utils = {
            getName: o => o.name || o.prefix.replace(/^\//, "").replace(/\/$/, "").replaceAll("/", "_"),
            getTitle: o => o.title || this.utils.getName(o),
            getIcon: (o, c) => {
                let h = o.icon;
                return (h && /^(\w+)\(([^)]*)\)/.exec(h) || /^#([A-Fa-f\d]+)$/.exec(h)) && (h = Je$1(h)),
                h && h.startsWith("http") && h.startsWith("data:") || (h = this.utils.pathToIcon(this.baseUrl + c + "/" + o.prefix + (h || ""))),
                h
            }
            ,
            getItemIcon: (o, c, h) => {
                const _ = o.iconFiles[c];
                if (_)
                    return URL.createObjectURL(_);
                let b = o.icons[c];
                return (b && /^(\w+)\(([^)]*)\)/.exec(b) || /^#([A-Fa-f\d]+)$/.exec(b)) && (b = Je$1(b)),
                b || (b = this.utils.pathToIcon(o.items[c])),
                !b || b.startsWith("http") || b.startsWith("data:") || (b = this.baseUrl + h + "/" + o.prefix + b),
                b
            }
            ,
            getItemTitle: (o, c) => o.titles[c] || this.utils.pathToTitle(o.items[c]),
            getItemPath: (o, c, h) => o.items[c].startsWith("http") ? o.items[c] : `${this.baseUrl}${h}/${o.prefix}${o.items[c]}`,
            pathToTitle: o => o.split("/").pop().replace(/\.[^.]*$/, ""),
            pathToIcon: o => o.replace(/\/$/, "").replace(/\.[^/.]+$/, "") + ".webp"
        },
        this.toJSON = void 0
    }
    _getVariationId(o) {
        return this.utils.getName(o)
    }
    async applyVariation(o, c, h, _=!1) {
        var b, _e;
        if (!this._viewer)
            return;
        const nt = this._getVariationId(o);
        typeof c == "number" && (c = o.items[c]);
        const it = o.items.indexOf(c);
        if (it === -1)
            return void this._viewer.console.warn(`Item ${c} not found`);
        const at = o.itemFiles[it]
          , ut = o.selected;
        if (!_ && ut === it)
            return;
        o.selected = it;
        const pt = this._viewer.getManager()
          , ht = this.utils.getItemPath(o, it, h);
        if (h === "objects") {
            let _t = this._viewer.scene.findObjectsByName(nt).map(Et => Et.modelObject);
            _t.length === 0 && (_t = [(await this._viewer.createObject3D()).modelObject],
            _t[0].name = nt),
            this._viewer.renderEnabled = !1;
            for (const Et of _t)
                [...Et.children].forEach(Pt => Pt.dispose && this.autoDispose ? Pt.dispose() : Pt.removeFromParent());
            const vt = await this._loadObject(ht, at);
            if (!vt.length)
                return void (ht.endsWith("json") || this._viewer.console.warn(`Object ${ht} not found`));
            let bt = !1;
            for (const Et of _t) {
                [...Et.children].forEach(Pt => Pt.dispose && this.autoDispose ? Pt.dispose() : Pt.removeFromParent());
                for (const Pt of vt)
                    bt ? Et.add(Pt.modelObject.clone()) : Et.add(Pt.modelObject);
                bt = !0
            }
            const St = []
              , At = this.variations.materials.filter(Et => Et && typeof Et.selected == "number");
            for (const Et of At)
                St.push(this.applyVariation(Et, Et.selected, "materials", !0));
            await Promise.all(St),
            this._viewer.renderEnabled = !0
        }
        if (h === "materials") {
            const _t = await this._loadMaterial(ht, at);
            if (!_t)
                return void this._viewer.console.warn(`Material ${ht} not found`);
            _t.userData.__isVariation = !0;
            const vt = this._viewer.scene.findObjectsByName(nt)
              , bt = St => {
                var At, Et, Pt, It;
                St.material && (!((At = o.data) === null || At === void 0) && At.matType) && (Array.isArray(St.material) ? St.material.length !== 0 && ((Et = o.data) === null || Et === void 0 ? void 0 : Et.matType) !== St.material[0].typeSlug : ((Pt = o.data) === null || Pt === void 0 ? void 0 : Pt.matType) !== St.material.typeSlug) || (It = St == null ? void 0 : St.setMaterial) === null || It === void 0 || It.call(St, _t)
            }
            ;
            for (const St of vt)
                !((b = o.data) === null || b === void 0) && b.traverse ? St.traverse(bt) : bt(St);
            (_e = pt.materials) === null || _e === void 0 || _e.applyMaterial(_t, nt)
        }
    }
    clearVariations() {
        const o = this.variations.objects;
        if (this.variations.materials,
        this.variations = {
            objects: [],
            materials: []
        },
        this._viewer)
            for (const c of o) {
                const h = this._getVariationId(c)
                  , _ = this._viewer.scene.findObjectsByName(h);
                for (const b of _)
                    [...b.children].forEach(_e => {
                        var nt;
                        return ((nt = _e.dispose) !== null && nt !== void 0 ? nt : _e.removeFromParent)()
                    }
                    )
            }
    }
    async _loadMaterial(o, c) {
        var h, _, b;
        return (b = (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getManager()) === null || _ === void 0 ? void 0 : _.importer) === null || b === void 0 ? void 0 : b.importSinglePath(o, {
            importedFile: c
        })
    }
    async _loadObject(o, c) {
        var h, _, b;
        return (b = (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.getManager()) === null || _ === void 0 ? void 0 : _.importer) === null || b === void 0 ? void 0 : b.importPath(o, {
            importedFile: c,
            reimportDisposed: !0
        })
    }
    importConfig(o, c) {
        var h, _;
        typeof o == "string" && (o = JSON.parse(o)),
        o.baseUrl !== void 0 && (this.baseUrl = o.baseUrl),
        !c && o.folder && (c = typeof o.folder == "object" ? o.folder : typeof o.folder == "string" ? unzipSync(strToU8(o.folder)) : unzipSync(o.folder));
        for (const b of this._ty)
            if (o[b])
                for (const _e of o[b]) {
                    const nt = {
                        items: _e.items,
                        prefix: _e.prefix,
                        name: _e.name,
                        title: _e.title || "",
                        icon: _e.icon || "",
                        icons: (h = _e.icons) !== null && h !== void 0 ? h : _e.items.map( () => ""),
                        titles: (_ = _e.titles) !== null && _ !== void 0 ? _ : _e.items.map( () => ""),
                        itemFiles: [],
                        iconFiles: [],
                        data: {
                            ..._e.data
                        }
                    };
                    if (c)
                        for (let it = 0; it < _e.items.length; it++) {
                            const at = _e.items[it]
                              , ut = c[b + "/" + _e.prefix + at];
                            nt.itemFiles[it] = ut ? new File([ut],at) : void 0;
                            const pt = _e.icons[it];
                            if (!pt)
                                continue;
                            const ht = c[b + "/" + _e.prefix + pt];
                            nt.iconFiles[it] = ht ? new File([ht],pt) : void 0
                        }
                    this.variations[b].push(nt)
                }
    }
    async importPath(o) {
        var c, h;
        if (o.endsWith(".json")) {
            const _ = await ((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getManager().importer) === null || h === void 0 ? void 0 : h.importSinglePath(o, {
                processImported: !1
            }))
              , b = o.split("?")[0];
            return this.baseUrl || (this.baseUrl = b.substring(0, b.lastIndexOf("/") + 1)),
            this.importConfig(_)
        }
        o.endsWith(".zip") ? alert("not implemented") : alert("not supported")
    }
    getMaterials(o) {
        var c;
        return ((c = this.variations.materials.find(h => this.utils.getName(h) === o)) === null || c === void 0 ? void 0 : c.items) || []
    }
    getObjects(o) {
        var c;
        return ((c = this.variations.objects.find(h => this.utils.getName(h) === o)) === null || c === void 0 ? void 0 : c.items) || []
    }
    getMaterialVariations() {
        return this.variations.materials.map(o => this.utils.getName(o))
    }
    getObjectVariations() {
        return this.variations.objects.map(o => this.utils.getName(o))
    }
    async onRemove(o) {
        return super.onRemove(o)
    }
    fromJSON(o) {
        return super.fromJSON(o) ? (this.importConfig(o),
        this) : null
    }
    async _exportConfiguratorState() {
        var o;
        let c = {
            objects: {},
            materials: {}
        };
        const h = {
            objects: [],
            materials: [],
            type: VariationConfiguratorPlugin.PluginType
        };
        this.baseUrl && (h.baseUrl = this.baseUrl);
        let _ = !1;
        for (const b of this._ty)
            for (const _e of this.variations[b]) {
                const nt = {
                    ..._e
                };
                nt.data = {
                    ...nt.data
                },
                delete nt.itemFiles,
                delete nt.iconFiles,
                h[b].push(nt);
                const it = _e.prefix.replace(/^\//, "")
                  , at = it.trimEnd().endsWith("/") ? "" : it.split("/").pop() || ""
                  , ut = it.replace(at, "").trimEnd().replace(/\/$/, "")
                  , pt = {};
                let ht = !1;
                for (let bt = 0; bt < _e.items.length; bt++) {
                    const St = _e.items[bt]
                      , At = _e.itemFiles[bt]
                      , Et = _e.iconFiles[bt]
                      , Pt = _e.icons[bt];
                    At ? (pt[at + St] = new Uint8Array(await At.arrayBuffer()),
                    Et && !Pt && ((o = this._viewer) === null || o === void 0 || o.console.error("Icon file without icon name")),
                    Et && Pt && (pt[at + Pt] = new Uint8Array(await Et.arrayBuffer())),
                    ht = !0) : Et && alert("Icon file without model/material file not supported")
                }
                if (!ht)
                    continue;
                _ = !0;
                const _t = ut.split("/");
                let vt = c[b];
                for (const bt of _t) {
                    vt[bt] || (vt[bt] = {});
                    const St = vt[bt];
                    if (typeof St != "object")
                        throw new Error("Invalid prefix: " + _e.prefix);
                    vt = St
                }
                Object.assign(vt, pt)
            }
        return _ || (c = void 0),
        {
            folder: c,
            config: h
        }
    }
}
VariationConfiguratorPlugin.PluginType = "VariationConfiguratorPlugin";
class VariationConfiguratorGridUiPlugin extends VariationConfiguratorPlugin {
    constructor() {
        super(),
        this._uiNeedRefresh = !1,
        this._refreshUi = this._refreshUi.bind(this)
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.addEventListener("preFrame", this._refreshUi)
    }
    async onRemove(o) {
        return o.removeEventListener("preFrame", this._refreshUi),
        super.onRemove(o)
    }
    refreshUi() {
        this.enabled && (this._uiNeedRefresh = !0)
    }
    async _refreshUi() {
        if (!this.enabled || !this._viewer || !this._uiNeedRefresh)
            return !1;
        this._uiNeedRefresh = !1,
        CustomContextGrid.RemoveAll(VariationConfiguratorGridUiPlugin.PluginType);
        for (const o of ["objects", "materials"])
            for (const c of this.variations[o])
                CustomContextGrid.Create(VariationConfiguratorGridUiPlugin.PluginType, this.utils.getTitle(c), 5, 20, 0, c.items.map( (h, _) => ({
                    id: h,
                    image: this.utils.getItemIcon(c, _, o),
                    onClick: async b => this.applyVariation(c, b, o, !1),
                    tooltip: this.utils.getItemTitle(c, _)
                })), (h, _) => tippy_esm(h, {
                    placement: "bottom",
                    content: _.tooltip
                }));
        return CustomContextGrid.RebuildUi(this._viewer.container),
        !0
    }
}
VariationConfiguratorGridUiPlugin.PluginType = "VariationConfiguratorPlugin";
class VariationConfiguratorEditorUiPlugin extends VariationConfiguratorGridUiPlugin {
    constructor() {
        super(...arguments),
        this._uiExpandedState = {},
        this.uiConfig = {
            type: "folder",
            label: "Configurator",
            children: [{
                type: "input",
                label: "Base URL",
                property: [this, "baseUrl"]
            }, ...this._ty.map(o => ({
                type: "folder",
                expanded: this._uiExpandedState["__/" + o],
                onExpand: () => this._uiExpandedState["__/" + o] = !0,
                onCollapse: () => this._uiExpandedState["__/" + o] = !1,
                label: o,
                children: [ () => this.variations[o].map(c => ({
                    type: "folder",
                    expanded: this._uiExpandedState[c.name],
                    onExpand: () => this._uiExpandedState[c.name] = !0,
                    onCollapse: () => this._uiExpandedState[c.name] = !1,
                    label: () => this.utils.getName(c),
                    children: [{
                        type: "input",
                        placeholder: () => this.utils.getName(c),
                        property: [c, "name"]
                    }, {
                        type: "input",
                        property: [c, "prefix"]
                    }, {
                        type: "input",
                        placeholder: () => this.utils.pathToTitle(this.utils.getName(c)),
                        property: [c, "title"]
                    }, {
                        type: "input",
                        placeholder: () => this.utils.pathToIcon(this.baseUrl + c.prefix),
                        property: [c, "icon"]
                    }, {
                        type: "folder",
                        label: "items",
                        children: c.items.map( (h, _) => ({
                            type: "folder",
                            label: () => c.items[_],
                            children: [{
                                type: "input",
                                label: "File/URL",
                                isMonitor: !c.itemFiles[_],
                                getValue: () => c.items[_],
                                setValue: b => {
                                    c.items[_] = b
                                }
                            }, {
                                type: "input",
                                label: "Icon/Image",
                                placeholder: this.utils.pathToIcon(c.items[_]),
                                getValue: () => c.icons[_],
                                setValue: b => {
                                    c.icons[_] = b
                                }
                            }, {
                                type: "input",
                                label: "Title",
                                placeholder: this.utils.pathToTitle(c.items[_]),
                                getValue: () => c.titles[_],
                                setValue: b => {
                                    c.titles[_] = b
                                }
                            }, {
                                type: "button",
                                label: "Apply",
                                value: async () => this.applyVariation(c, _, o)
                            }, c.itemFiles[_] ? [{
                                type: "button",
                                label: "Remove",
                                value: () => {
                                    c.items.splice(_, 1),
                                    c.itemFiles.splice(_, 1),
                                    this.refreshUi()
                                }
                            }, {
                                type: "button",
                                label: "Replace",
                                value: async () => {
                                    const b = await ge$1(!1, !1);
                                    b.length !== 0 && (c.itemFiles[_] = b[0],
                                    c.items[_] = b[0].name,
                                    this.refreshUi())
                                }
                            }, {
                                type: "button",
                                label: "Download",
                                value: async () => {
                                    const b = c.itemFiles[_];
                                    N$2(b, b.name)
                                }
                            }] : {}]
                        }))
                    }, {
                        type: "button",
                        label: "Add item (local)",
                        value: async () => {
                            var h, _, b;
                            const _e = await ge$1(!0, !1);
                            if (_e.length !== 0) {
                                for (const nt of _e) {
                                    if (!this._extForType[o].includes((h = nt.name.split(".").pop()) !== null && h !== void 0 ? h : "")) {
                                        await ((_ = this._viewer) === null || _ === void 0 ? void 0 : _.alert(`Invalid file: ${nt.name} is not a valid ${o} file`));
                                        continue
                                    }
                                    if (c.items.includes(nt.name)) {
                                        await ((b = this._viewer) === null || b === void 0 ? void 0 : b.alert(`Already exists: Item with name ${nt.name} already exists`));
                                        continue
                                    }
                                    const it = c.items.push(nt.name) - 1;
                                    c.icons[it] = "",
                                    c.titles[it] = "",
                                    c.itemFiles[it] = nt
                                }
                                this.refreshUi()
                            }
                        }
                    }, {
                        type: "button",
                        label: "Add item (url)",
                        value: async () => {
                            var h, _, b, _e, nt;
                            const it = await ((h = this._viewer) === null || h === void 0 ? void 0 : h.prompt("URL: Enter the url of the object/material"));
                            if (!it)
                                return;
                            if (!it.startsWith("http") && !this.baseUrl.startsWith("http"))
                                return void await ((_ = this._viewer) === null || _ === void 0 ? void 0 : _.alert(`Invalid url: ${it} should be a valid HTTP(S) url. If you are passing a relative path, set the baseURL first`));
                            if (!this._extForType[o].includes((b = it.split(".").pop()) !== null && b !== void 0 ? b : ""))
                                return void await ((_e = this._viewer) === null || _e === void 0 ? void 0 : _e.alert(`Invalid url: ${it} should be of a material ending with mat`));
                            c.items.includes(it) && await ((nt = this._viewer) === null || nt === void 0 ? void 0 : nt.alert(`Already exists: Item with url ${it} already exists`)),
                            c.items.push(it);
                            const at = c.items.length - 1;
                            c.icons[at] = "",
                            c.titles[at] = "",
                            this.refreshUi()
                        }
                    }, {
                        type: "button",
                        label: () => "Remove " + this.utils.getName(c),
                        value: async () => {
                            var h;
                            await ((h = this._viewer) === null || h === void 0 ? void 0 : h.confirm(`Delete Group: Are you sure you want to remove ${this.utils.getName(c)}?`)) && (this.variations[o].splice(this.variations[o].indexOf(c), 1),
                            this.refreshUi())
                        }
                    }]
                })), {
                    type: "button",
                    label: `Add ${o} group (empty)`,
                    value: async () => {
                        var c;
                        const h = await ((c = this._viewer) === null || c === void 0 ? void 0 : c.prompt("Name: Enter the name of the object/material"));
                        h && (this.variations[o].push({
                            items: [],
                            itemFiles: [],
                            icons: [],
                            iconFiles: [],
                            titles: [],
                            prefix: h + "/",
                            name: h,
                            icon: "",
                            title: ""
                        }),
                        this.refreshUi())
                    }
                }, {
                    type: "button",
                    label: `Add ${o} group (local folder)`,
                    value: async () => {
                        var c, h, _, b;
                        const _e = await ge$1(!1, !0);
                        if (_e.length === 0)
                            return;
                        const nt = []
                          , it = []
                          , at = []
                          , ut = [];
                        for (const bt of _e) {
                            if (bt.name.startsWith("."))
                                continue;
                            const St = (c = bt.name.split(".").pop()) !== null && c !== void 0 ? c : "";
                            St ? this._extForType[o].includes(St) ? (nt.push(bt.webkitRelativePath.replace(/^\//, "")),
                            it.push(bt)) : this._extForType.images.includes(St) ? (at.push(bt.webkitRelativePath.replace(/^\//, "")),
                            ut.push(bt)) : await ((_ = this._viewer) === null || _ === void 0 ? void 0 : _.alert(`Invalid file: ${bt.name} is not a valid ${o} file`)) : await ((h = this._viewer) === null || h === void 0 ? void 0 : h.alert(`Invalid file: ${bt.name} has no extension`))
                        }
                        const pt = he$1(nt)
                          , ht = this.utils.getName({
                            prefix: pt
                        });
                        let _t = await ((b = this._viewer) === null || b === void 0 ? void 0 : b.prompt("Name: Enter the name of the object/material", ht, !0));
                        if (_t === null)
                            return;
                        _t = _t || ht;
                        const vt = nt.map(bt => {
                            var St;
                            const At = bt.replace(pt, "")
                              , Et = (St = At.split(".").pop()) !== null && St !== void 0 ? St : ""
                              , Pt = At.replace("." + Et, "") + "."
                              , It = at.findIndex(Dt => Dt.replace(pt, "").startsWith(Pt));
                            return It < 0 ? ["", void 0] : [at[It].replace(pt, ""), ut[It] || void 0]
                        }
                        );
                        this.variations[o].push({
                            items: nt.map(bt => bt.replace(pt, "")),
                            icons: vt.map(bt => bt[0]),
                            iconFiles: vt.map(bt => bt[1]),
                            titles: nt.map( () => ""),
                            itemFiles: it,
                            prefix: pt,
                            name: _t,
                            icon: "",
                            title: ""
                        }),
                        this.refreshUi()
                    }
                }]
            })), {
                type: "button",
                label: "Download JSON/Zip",
                value: async () => {
                    var o, c;
                    try {
                        const {folder: h, config: _} = await this._exportConfiguratorState()
                          , b = JSON.stringify(_, null, 4);
                        if (h) {
                            h["config.json"] = strToU8(b);
                            const _e = await zipSync(h);
                            N$2(new Blob([_e],{
                                type: "application/zip"
                            }), "configurator.zip")
                        } else
                            N$2(new Blob([b],{
                                type: "application/json"
                            }), "config.json")
                    } catch (h) {
                        return (o = this._viewer) === null || o === void 0 || o.console.error(h),
                        void await ((c = this._viewer) === null || c === void 0 ? void 0 : c.alert("Error: " + ((h == null ? void 0 : h.message) || h)))
                    }
                }
            }, {
                type: "button",
                label: "Load JSON/Zip",
                value: async () => {
                    var o, c, h;
                    const _ = await ge$1(!1, !1, "application/zip,application/json");
                    if (_.length === 0)
                        return;
                    const b = _[0];
                    if (b.name.endsWith(".zip")) {
                        const _e = unzipSync(new Uint8Array(await b.arrayBuffer()));
                        if (!_e["config.json"])
                            return void await ((o = this._viewer) === null || o === void 0 ? void 0 : o.alert("Invalid zip: config.json not found"));
                        const nt = JSON.parse(strFromU8(_e["config.json"]));
                        this.importConfig(nt, _e)
                    } else {
                        if (!b.name.endsWith(".json"))
                            return void await ((c = this._viewer) === null || c === void 0 ? void 0 : c.alert("Invalid file: " + b.name));
                        {
                            const _e = JSON.parse(await b.text());
                            this.importConfig(_e)
                        }
                    }
                    await ((h = this._viewer) === null || h === void 0 ? void 0 : h.alert("Imported successfully")),
                    this.refreshUi()
                }
            }, {
                type: "button",
                label: "Import Path",
                value: async () => {
                    var o, c;
                    const h = await ((o = this._viewer) === null || o === void 0 ? void 0 : o.prompt("URL: Enter the url of the json file."));
                    h && (await this.importPath(h),
                    await ((c = this._viewer) === null || c === void 0 ? void 0 : c.alert("Imported successfully")),
                    this.refreshUi())
                }
            }, {
                type: "button",
                label: "Refresh UI",
                value: () => {
                    this.refreshUi()
                }
            }, {
                type: "button",
                label: "Clear All",
                value: async () => {
                    var o;
                    await ((o = this._viewer) === null || o === void 0 ? void 0 : o.confirm("Clear: Are you sure you want to clear the configuration ?")) && (this.variations.objects = [],
                    this.variations.materials = [],
                    this.refreshUi())
                }
            }]
        }
    }
    _refreshUiConfig() {
        var o, c;
        (c = (o = this.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0)
    }
    refreshUi() {
        this._refreshUiConfig(),
        super.refreshUi()
    }
    async _loadObject(o, c) {
        const h = await super._loadObject(o, c);
        for (const _ of h)
            (_.modelObject || _).userData.excludeFromExport = !0;
        return h
    }
}
VariationConfiguratorEditorUiPlugin.PluginType = "VariationConfiguratorPlugin";
class TransformAnimationPlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.toJSON = void 0,
        this.enabled = !0,
        this._addSceneObject = o => {
            const c = o.object;
            c != null && c.traverse && c.traverse(h => {
                var _, b;
                if (h.isWidget)
                    return;
                h.userData[TransformAnimationPlugin.PluginType] === void 0 && (h.userData[TransformAnimationPlugin.PluginType] = {
                    transforms: []
                });
                const _e = {
                    type: "folder",
                    label: "Transform Animation",
                    children: [{
                        type: "button",
                        label: "Add Current Transform",
                        value: () => {
                            var nt;
                            this.addTransform(h),
                            (nt = _e == null ? void 0 : _e.uiRefresh) === null || nt === void 0 || nt.call(_e)
                        }
                    }, () => {
                        var nt;
                        return (nt = h.userData[TransformAnimationPlugin.PluginType]) === null || nt === void 0 ? void 0 : nt.transforms.map( (it, at) => ({
                            type: "folder",
                            label: `Transform ${at}`,
                            children: [{
                                type: "vec3",
                                label: "Position",
                                property: [it, "position"]
                            }, {
                                type: "vec3",
                                label: "Quaternion",
                                property: [it, "quaternion"]
                            }, {
                                type: "vec3",
                                label: "Scale",
                                property: [it, "scale"]
                            }, {
                                type: "button",
                                label: "Set",
                                value: () => {
                                    this.setTransform(h, it)
                                }
                            }, {
                                type: "button",
                                label: "Animate",
                                value: () => {
                                    this.animateTransform(h, it)
                                }
                            }]
                        }))
                    }
                    ]
                };
                (b = (_ = h.uiConfig) === null || _ === void 0 ? void 0 : _.children) === null || b === void 0 || b.push(_e)
            }
            )
        }
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("addSceneObject", this._addSceneObject)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("addSceneObject", this._addSceneObject),
        super.onRemove(o)
    }
    addTransform(o) {
        o.userData[TransformAnimationPlugin.PluginType].transforms.push({
            position: o.position.clone(),
            quaternion: o.quaternion.clone(),
            scale: o.scale.clone()
        })
    }
    setTransform(o, c) {
        var h, _, b, _e;
        o.position.copy(c.position),
        o.quaternion.copy(c.quaternion),
        o.scale.copy(c.scale),
        (_ = (h = o.userData).setDirty) === null || _ === void 0 || _.call(h),
        (_e = (b = o.uiConfig) === null || b === void 0 ? void 0 : b.uiRefresh) === null || _e === void 0 || _e.call(b)
    }
    animateTransform(o, c, h=2e3) {
        var _, b;
        const _e = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getPluginByType("PopmotionPlugin");
        _e || (b = this._viewer) === null || b === void 0 || b.console.error("PopmotionPlugin required for animation");
        const nt = typeof c == "number" ? o.userData[TransformAnimationPlugin.PluginType].transforms[c] : c
          , it = new three_module.Pq0
          , at = new three_module.PTz
          , ut = new three_module.Pq0
          , pt = o.position.clone()
          , ht = o.quaternion.clone()
          , _t = o.scale.clone()
          , vt = nt.position
          , bt = nt.quaternion
          , St = nt.scale;
        return _e == null ? void 0 : _e.animate({
            from: 0,
            to: 1,
            duration: h,
            onUpdate: At => {
                var Et, Pt;
                it.lerpVectors(pt, vt, At),
                at.slerpQuaternions(ht, bt, At),
                ut.lerpVectors(_t, St, At),
                o.position.copy(it),
                o.quaternion.copy(at),
                o.scale.copy(ut),
                (Et = this._viewer) === null || Et === void 0 || Et.setDirty(),
                (Pt = this._viewer) === null || Pt === void 0 || Pt.renderer.resetShadows()
            }
            ,
            onStop: () => {
                var At, Et, Pt, It;
                o.position.copy(nt.position),
                o.quaternion.copy(nt.quaternion),
                o.scale.copy(nt.scale),
                (Et = (At = o.userData).setDirty) === null || Et === void 0 || Et.call(At),
                (It = (Pt = o.uiConfig) === null || Pt === void 0 ? void 0 : Pt.uiRefresh) === null || It === void 0 || It.call(Pt)
            }
        })
    }
}
TransformAnimationPlugin.PluginType = "TransformAnimationPlugin";
var VirtualCamerasPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let VirtualCamerasPlugin = class extends AViewerPlugin {
    constructor(d=!0) {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.cameras = [],
        this._preRender = () => {
            if (this.enabled && this._viewer)
                for (const o of this.cameras) {
                    if (!o.enabled)
                        continue;
                    const c = this._viewer
                      , h = o.camera;
                    try {
                        this.dispatchEvent({
                            type: "preRenderCamera",
                            camera: o
                        }),
                        c.scene.renderCamera = h,
                        c.renderer.render(!1);
                        const _ = c.renderer.composer.readBuffer;
                        this.dispatchEvent({
                            type: "preBlitCamera",
                            camera: o,
                            readBuffer: _
                        }),
                        c.renderer.blit(_.texture, o.target),
                        this.dispatchEvent({
                            type: "postRenderCamera",
                            camera: o
                        })
                    } catch (_) {
                        console.error(_),
                        o.enabled = !1
                    }
                }
        }
        ,
        this.enabled = d
    }
    async onAdded(d) {
        await super.onAdded(d),
        d.addEventListener("preRender", this._preRender)
    }
    addCamera(d) {
        if (!this._viewer)
            throw "Plugin not added to viewer";
        const o = {
            camera: d,
            target: this._viewer.renderer.composerTarget.clone(!0),
            enabled: !0
        };
        return this.cameras.push(o),
        o
    }
}
;
function updateAttribute(d, o, c, h, _) {
    const b = d.getAttribute(o)
      , _e = h.length / c;
    return b && b.count === _e ? (b.set(h),
    b.needsUpdate = !0) : d.setAttribute(o, new three_module.qtW(h,c)),
    b
}
function updateIndices(d, o) {
    const c = d.index;
    c && c.count === o.length ? (c.set(o),
    c.needsUpdate = !0) : d.setIndex(o)
}
function updateUi(d, o) {
    var c, h, _;
    if (!d.uiConfig)
        return;
    let b = (c = d.uiConfig.children) === null || c === void 0 ? void 0 : c.find(_e => {
        var nt;
        return (nt = _e.tags) === null || nt === void 0 ? void 0 : nt.includes("generatedGeometry")
    }
    );
    b || (b = {
        type: "folder",
        label: "Generation Params",
        tags: ["generatedGeometry"],
        children: []
    },
    (h = d.uiConfig.children) === null || h === void 0 || h.push(b)),
    d.userData.__generationParamsUiType !== d.userData.generationParams.type && (b.children = o(),
    d.userData.__generationParamsUiType = d.userData.generationParams.type,
    (_ = b.uiRefresh) === null || _ === void 0 || _.call(b, "postFrame", !0))
}
VirtualCamerasPlugin.PluginType = "VirtualCamerasPlugin",
VirtualCamerasPlugin_decorate([uiToggle()], VirtualCamerasPlugin.prototype, "enabled", void 0),
VirtualCamerasPlugin = VirtualCamerasPlugin_decorate([uiFolder("Virtual Cameras")], VirtualCamerasPlugin);
class AGeometryGenerator {
    constructor(o) {
        this.type = o
    }
    createUiConfig(o) {
        const c = generateUiConfig(o.userData.generationParams).filter(h => {
            var _;
            return ((_ = Ee$1(h.property)) === null || _ === void 0 ? void 0 : _[1]) !== "type"
        }
        );
        return c.forEach(h => {
            h.onChange = () => this.generate(o)
        }
        ),
        c
    }
    generate(o, c={}) {
        const h = o ?? new three_module.LoY;
        if (h.userData.generationParams || (h.userData.generationParams = {
            type: this.type
        }),
        h.userData.generationParams.type = this.type,
        c.type)
            return console.error("Cannot set type parameter here, use the plugin instead"),
            h;
        const _ = {
            ...this.defaultParams,
            ...h.userData.generationParams,
            ...c
        }
          , {indices: b, vertices: _e, normals: nt, uvs: it, groups: at} = this._generateData(_);
        if (updateIndices(h, b),
        updateAttribute(h, "position", 3, _e),
        updateAttribute(h, "normal", 3, nt),
        updateAttribute(h, "uv", 2, it),
        at) {
            h.clearGroups();
            for (const ut of at)
                h.addGroup(ut.start, ut.count, ut.materialIndex)
        }
        return h.computeBoundingBox(),
        h.computeBoundingSphere(),
        Object.assign(h.userData.generationParams, _),
        updateUi(h, () => this.createUiConfig(h)),
        h.dispatchEvent({
            type: "geometryUpdate"
        }),
        h
    }
}
class SphereGeometryGenerator extends AGeometryGenerator {
    constructor() {
        super(...arguments),
        this.defaultParams = {
            radius: 1,
            widthSegments: 32,
            heightSegments: 16,
            phiStart: 0,
            phiLength: 2 * Math.PI,
            thetaStart: 0,
            thetaLength: Math.PI
        }
    }
    _generateData(o) {
        const {radius: c, phiStart: h, phiLength: _, thetaStart: b, thetaLength: _e} = o;
        let {widthSegments: nt, heightSegments: it} = o;
        nt = Math.max(3, Math.floor(nt)),
        it = Math.max(2, Math.floor(it));
        const at = Math.min(b + _e, Math.PI);
        let ut = 0;
        const pt = []
          , ht = new three_module.Pq0
          , _t = new three_module.Pq0
          , vt = []
          , bt = []
          , St = []
          , At = [];
        for (let Et = 0; Et <= it; Et++) {
            const Pt = []
              , It = Et / it;
            let Dt = 0;
            Et === 0 && b === 0 ? Dt = .5 / nt : Et === it && at === Math.PI && (Dt = -.5 / nt);
            for (let Gt = 0; Gt <= nt; Gt++) {
                const Bt = Gt / nt;
                ht.x = -c * Math.cos(h + Bt * _) * Math.sin(b + It * _e),
                ht.y = c * Math.cos(b + It * _e),
                ht.z = c * Math.sin(h + Bt * _) * Math.sin(b + It * _e),
                bt.push(ht.x, ht.y, ht.z),
                _t.copy(ht).normalize(),
                St.push(_t.x, _t.y, _t.z),
                At.push(Bt + Dt, 1 - It),
                Pt.push(ut++)
            }
            pt.push(Pt)
        }
        for (let Et = 0; Et < it; Et++)
            for (let Pt = 0; Pt < nt; Pt++) {
                const It = pt[Et][Pt + 1]
                  , Dt = pt[Et][Pt]
                  , Gt = pt[Et + 1][Pt]
                  , Bt = pt[Et + 1][Pt + 1];
                (Et !== 0 || b > 0) && vt.push(It, Dt, Bt),
                (Et !== it - 1 || at < Math.PI) && vt.push(Dt, Gt, Bt)
            }
        return {
            indices: vt,
            vertices: bt,
            normals: St,
            uvs: At
        }
    }
}
class PlaneGeometryGenerator extends AGeometryGenerator {
    constructor() {
        super(...arguments),
        this.defaultParams = {
            width: 1,
            height: 1,
            widthSegments: 2,
            heightSegments: 2
        }
    }
    _generateData(o) {
        const c = o.width / 2
          , h = o.height / 2
          , _ = Math.floor(o.widthSegments)
          , b = Math.floor(o.heightSegments)
          , _e = _ + 1
          , nt = b + 1
          , it = o.width / _
          , at = o.height / b
          , ut = []
          , pt = []
          , ht = []
          , _t = [];
        for (let vt = 0; vt < nt; vt++) {
            const bt = vt * at - h;
            for (let St = 0; St < _e; St++) {
                const At = St * it - c;
                pt.push(At, -bt, 0),
                ht.push(0, 0, 1),
                _t.push(St / _),
                _t.push(1 - vt / b)
            }
        }
        for (let vt = 0; vt < b; vt++)
            for (let bt = 0; bt < _; bt++) {
                const St = bt + _e * vt
                  , At = bt + _e * (vt + 1)
                  , Et = bt + 1 + _e * (vt + 1)
                  , Pt = bt + 1 + _e * vt;
                ut.push(St, At, Pt),
                ut.push(At, Et, Pt)
            }
        return {
            indices: ut,
            vertices: pt,
            normals: ht,
            uvs: _t
        }
    }
}
class CircleGeometryGenerator extends AGeometryGenerator {
    constructor() {
        super(...arguments),
        this.defaultParams = {
            radius: 1,
            segments: 32,
            thetaStart: 0,
            thetaLength: 2 * Math.PI
        }
    }
    _generateData(o) {
        const {radius: c, thetaStart: h, thetaLength: _} = o
          , b = Math.max(3, o.segments)
          , _e = []
          , nt = []
          , it = []
          , at = []
          , ut = new three_module.Pq0
          , pt = new three_module.I9Y;
        nt.push(0, 0, 0),
        it.push(0, 0, 1),
        at.push(.5, .5);
        for (let ht = 0, _t = 3; ht <= b; ht++,
        _t += 3) {
            const vt = h + ht / b * _;
            ut.x = c * Math.cos(vt),
            ut.y = c * Math.sin(vt),
            nt.push(ut.x, ut.y, ut.z),
            it.push(0, 0, 1),
            pt.x = (nt[_t] / c + 1) / 2,
            pt.y = (nt[_t + 1] / c + 1) / 2,
            at.push(pt.x, pt.y)
        }
        for (let ht = 1; ht <= b; ht++)
            _e.push(ht, ht + 1, 0);
        return {
            indices: _e,
            vertices: nt,
            normals: it,
            uvs: at
        }
    }
}
class TorusGeometryGenerator extends AGeometryGenerator {
    constructor() {
        super(...arguments),
        this.defaultParams = {
            radius: 1,
            tube: .4,
            radialSegments: 12,
            tubularSegments: 48,
            arc: 2 * Math.PI
        }
    }
    _generateData(o) {
        const {radius: c, tube: h, arc: _} = o;
        let {radialSegments: b, tubularSegments: _e} = o;
        b = Math.floor(b),
        _e = Math.floor(_e);
        const nt = []
          , it = []
          , at = []
          , ut = []
          , pt = new three_module.Pq0
          , ht = new three_module.Pq0
          , _t = new three_module.Pq0;
        for (let vt = 0; vt <= b; vt++)
            for (let bt = 0; bt <= _e; bt++) {
                const St = bt / _e * _
                  , At = vt / b * Math.PI * 2;
                ht.x = (c + h * Math.cos(At)) * Math.cos(St),
                ht.y = (c + h * Math.cos(At)) * Math.sin(St),
                ht.z = h * Math.sin(At),
                it.push(ht.x, ht.y, ht.z),
                pt.x = c * Math.cos(St),
                pt.y = c * Math.sin(St),
                _t.subVectors(ht, pt).normalize(),
                at.push(_t.x, _t.y, _t.z),
                ut.push(bt / _e),
                ut.push(vt / b)
            }
        for (let vt = 1; vt <= b; vt++)
            for (let bt = 1; bt <= _e; bt++) {
                const St = (_e + 1) * vt + bt - 1
                  , At = (_e + 1) * (vt - 1) + bt - 1
                  , Et = (_e + 1) * (vt - 1) + bt
                  , Pt = (_e + 1) * vt + bt;
                nt.push(St, At, Pt),
                nt.push(At, Et, Pt)
            }
        return {
            indices: nt,
            vertices: it,
            normals: at,
            uvs: ut
        }
    }
}
class CylinderGeometryGenerator extends AGeometryGenerator {
    constructor() {
        super(...arguments),
        this.defaultParams = {
            radiusTop: 1,
            radiusBottom: 1,
            height: 1,
            radialSegments: 32,
            heightSegments: 1,
            openEnded: !1,
            thetaStart: 0,
            thetaLength: 2 * Math.PI
        }
    }
    _generateTorso(o) {
        const {radiusTop: c, radiusBottom: h, height: _, radialSegments: b, heightSegments: _e, thetaStart: nt, thetaLength: it, indexArray: at, indices: ut, groups: pt, vertices: ht, normals: _t, uvs: vt, groupStart: bt, halfHeight: St} = o
          , At = new three_module.Pq0
          , Et = new three_module.Pq0;
        let Pt = 0;
        const It = (h - c) / _;
        for (let Dt = 0; Dt <= _e; Dt++) {
            const Gt = []
              , Bt = Dt / _e
              , kt = Bt * (h - c) + c;
            for (let Ut = 0; Ut <= b; Ut++) {
                const Ht = Ut / b
                  , Kt = Ht * it + nt
                  , Jt = Math.sin(Kt)
                  , or = Math.cos(Kt);
                Et.x = kt * Jt,
                Et.y = -Bt * _ + St,
                Et.z = kt * or,
                ht.push(Et.x, Et.y, Et.z),
                At.set(Jt, It, or).normalize(),
                _t.push(At.x, At.y, At.z),
                vt.push(Ht, 1 - Bt),
                Gt.push(o.index++)
            }
            at.push(Gt)
        }
        for (let Dt = 0; Dt < b; Dt++)
            for (let Gt = 0; Gt < _e; Gt++) {
                const Bt = at[Gt][Dt]
                  , kt = at[Gt + 1][Dt]
                  , Ut = at[Gt + 1][Dt + 1]
                  , Ht = at[Gt][Dt + 1];
                ut.push(Bt, kt, Ht),
                ut.push(kt, Ut, Ht),
                Pt += 6
            }
        pt.push({
            start: bt,
            count: Pt,
            materialIndex: 0
        }),
        o.groupStart += Pt
    }
    _generateCap(o, c) {
        const {radiusTop: h, radiusBottom: _, radialSegments: b, thetaStart: _e, thetaLength: nt, indices: it, groups: at, vertices: ut, normals: pt, uvs: ht, groupStart: _t, halfHeight: vt} = o
          , bt = o.index
          , St = new three_module.I9Y
          , At = new three_module.Pq0;
        let Et = 0;
        const Pt = c === !0 ? h : _
          , It = c === !0 ? 1 : -1;
        for (let Gt = 1; Gt <= b; Gt++)
            ut.push(0, vt * It, 0),
            pt.push(0, It, 0),
            ht.push(.5, .5),
            o.index++;
        const Dt = o.index;
        for (let Gt = 0; Gt <= b; Gt++) {
            const Bt = Gt / b * nt + _e
              , kt = Math.cos(Bt)
              , Ut = Math.sin(Bt);
            At.x = Pt * Ut,
            At.y = vt * It,
            At.z = Pt * kt,
            ut.push(At.x, At.y, At.z),
            pt.push(0, It, 0),
            St.x = .5 * kt + .5,
            St.y = .5 * Ut * It + .5,
            ht.push(St.x, St.y),
            o.index++
        }
        for (let Gt = 0; Gt < b; Gt++) {
            const Bt = bt + Gt
              , kt = Dt + Gt;
            c === !0 ? it.push(kt, kt + 1, Bt) : it.push(kt + 1, kt, Bt),
            Et += 3
        }
        at.push({
            start: _t,
            count: Et,
            materialIndex: c === !0 ? 1 : 2
        }),
        o.groupStart += Et
    }
    _generateData(o) {
        let {radialSegments: c, heightSegments: h} = o;
        c = Math.floor(c),
        h = Math.floor(h);
        const _ = {
            indices: [],
            vertices: [],
            normals: [],
            uvs: [],
            numberOfVertices: 0,
            groupStart: 0,
            groups: [],
            index: 0,
            indexArray: [],
            halfHeight: o.height / 2,
            ...o,
            radialSegments: c,
            heightSegments: h
        };
        return this._generateTorso(_),
        o.openEnded === !1 && (o.radiusTop > 0 && this._generateCap(_, !0),
        o.radiusBottom > 0 && this._generateCap(_, !1)),
        _
    }
}
class BoxGeometryGenerator extends AGeometryGenerator {
    constructor() {
        super(...arguments),
        this.defaultParams = {
            width: 1,
            height: 1,
            depth: 1,
            widthSegments: 1,
            heightSegments: 1,
            depthSegments: 1
        }
    }
    _buildPlane(o, c, h, _, b, _e, nt, it, at, ut, pt, ht) {
        const {indices: _t, vertices: vt, normals: bt, uvs: St, numberOfVertices: At, groupStart: Et, groups: Pt} = o
          , It = nt / ut
          , Dt = it / pt
          , Gt = nt / 2
          , Bt = it / 2
          , kt = at / 2
          , Ut = ut + 1
          , Ht = pt + 1;
        let Kt = 0
          , Jt = 0;
        const or = new three_module.Pq0;
        for (let ir = 0; ir < Ht; ir++) {
            const lr = ir * Dt - Bt;
            for (let ar = 0; ar < Ut; ar++) {
                const hr = ar * It - Gt;
                or[c] = hr * b,
                or[h] = lr * _e,
                or[_] = kt,
                vt.push(or.x, or.y, or.z),
                or[c] = 0,
                or[h] = 0,
                or[_] = at > 0 ? 1 : -1,
                bt.push(or.x, or.y, or.z),
                St.push(ar / ut),
                St.push(1 - ir / pt),
                Kt += 1
            }
        }
        for (let ir = 0; ir < pt; ir++)
            for (let lr = 0; lr < ut; lr++) {
                const ar = At + lr + Ut * ir
                  , hr = At + lr + Ut * (ir + 1)
                  , gr = At + (lr + 1) + Ut * (ir + 1)
                  , dr = At + (lr + 1) + Ut * ir;
                _t.push(ar, hr, dr),
                _t.push(hr, gr, dr),
                Jt += 6
            }
        Pt.push({
            start: Et,
            count: Jt,
            materialIndex: ht
        }),
        o.groupStart += Jt,
        o.numberOfVertices += Kt
    }
    _generateData(o) {
        const {width: c, height: h, depth: _} = o;
        let {widthSegments: b, heightSegments: _e, depthSegments: nt} = o;
        b = Math.floor(b),
        _e = Math.floor(_e),
        nt = Math.floor(nt);
        const it = {
            indices: [],
            vertices: [],
            normals: [],
            uvs: [],
            numberOfVertices: 0,
            groupStart: 0,
            groups: []
        };
        return this._buildPlane(it, "z", "y", "x", -1, -1, _, h, c, nt, _e, 0),
        this._buildPlane(it, "z", "y", "x", 1, -1, _, h, -c, nt, _e, 1),
        this._buildPlane(it, "x", "z", "y", 1, 1, c, _, h, b, nt, 2),
        this._buildPlane(it, "x", "z", "y", 1, -1, c, _, -h, b, nt, 3),
        this._buildPlane(it, "x", "y", "z", 1, -1, c, h, _, b, _e, 4),
        this._buildPlane(it, "x", "y", "z", -1, -1, c, h, -_, b, _e, 5),
        it
    }
}
class GeometryGeneratorPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this.generators = {
            plane: new PlaneGeometryGenerator("plane"),
            sphere: new SphereGeometryGenerator("sphere"),
            box: new BoxGeometryGenerator("box"),
            circle: new CircleGeometryGenerator("circle"),
            torus: new TorusGeometryGenerator("torus"),
            cylinder: new CylinderGeometryGenerator("cylinder")
        },
        this._sceneUpdate = o => {
            var c;
            if (o.hierarchyChanged) {
                const h = o.object || ((c = this._viewer) === null || c === void 0 ? void 0 : c.scene.modelRoot);
                h && h.traverse(_ => {
                    var b, _e, nt;
                    const it = (nt = (_e = (b = _.geometry) === null || b === void 0 ? void 0 : b.userData) === null || _e === void 0 ? void 0 : _e.generationParams) === null || nt === void 0 ? void 0 : nt.type;
                    it && updateUi(_.geometry, () => {
                        var at;
                        const ut = this.generators[it];
                        return ut != null && ut.createUiConfig && (at = ut.createUiConfig(_.geometry)) !== null && at !== void 0 ? at : []
                    }
                    )
                }
                )
            }
        }
        ,
        this.uiConfig = {
            type: "folder",
            label: "Generate Geometry",
            children: [ () => Object.keys(this.generators).map(o => ({
                type: "button",
                label: "Generate " + o,
                value: async () => {
                    (await this.generateObject(o)).name = o
                }
            }))]
        }
    }
    async generateObject(o) {
        var c, h;
        const _ = this.generators[o];
        if (!_)
            throw new Error("Unknown generator type: " + o);
        const b = await ((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getManager()) === null || h === void 0 ? void 0 : h.addImportedSingle(new three_module.eaF(new three_module.LoY,new MeshStandardMaterial2({
            color: 16711680
        })), {
            autoScale: !1,
            autoCenter: !1
        }));
        return _.generate(b.modelObject.geometry),
        b.name = o,
        b.geometry.name = "Generated " + o,
        b.modelObject
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("sceneUpdate", this._sceneUpdate)
    }
}
GeometryGeneratorPlugin.PluginType = "GeometryGeneratorPlugin";
var MaterialPresetPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let MaterialPresetPlugin$1 = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.serializeWithViewer = !1,
        this.enabled = !0,
        this.mapping = [],
        this.presets = {},
        this.getMaterialPresetByName = o => this.presets && this.presets.length != 0 ? this.presets[o.type].find(c => c.path.split("/").pop() == o.name) : null,
        this.applyOnLoad = !0,
        this.replaceMaterial = !0
    }
    async onAdded(o) {
        await super.onAdded(o)
    }
    loadPresets(o, c) {
        this.presets = o,
        this.basePath = c,
        this.dispatchEvent({
            type: "loadPresets"
        })
    }
    async fromJSON(o, c) {
        return o && o.materials && !o.mapping && (o.mapping = o.materials,
        delete o.materials),
        super.fromJSON(o, c) ? (this.applyOnLoad && await this.applyAll(),
        this) : null
    }
    async applyAll() {
        var o;
        const c = [];
        for (const h of this.mapping)
            c.push(this._apply(h.name, h.path, (o = h.regex) === null || o === void 0 || o));
        await Promise.all(c)
    }
    async _apply(o, c, h=!0) {
        var _, b, _e, nt, it;
        const at = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.getManager();
        if (!c || !o || !at)
            return;
        c = (b = (c = (c != null && c.startsWith("https://") ? "" : this.basePath || "") + c) == null ? void 0 : c.replace) === null || b === void 0 ? void 0 : b.call(c, /(https?:\/\/)|(\/)+/g, (ht, _t) => _t || "/");
        let ut = await ((_e = at.importer) === null || _e === void 0 ? void 0 : _e.importSinglePath(c));
        if (!ut)
            return void console.warn("MaterialPresetPlugin: Material not found", c);
        this.replaceMaterial && (ut = ut.clone ? ut.clone() : ut),
        ut.name = o;
        const pt = new Set;
        (it = (nt = this._viewer) === null || nt === void 0 ? void 0 : nt.scene) === null || it === void 0 || it.traverse(ht => {
            ht.material && (h ? ht.material.name.match("^" + o + "$") : ht.material.name === o) && pt.add(ht)
        }
        ),
        pt.forEach(ht => {
            var _t, vt, bt;
            if (this.replaceMaterial || !ht.material) {
                const St = ((_t = ht.material) === null || _t === void 0 ? void 0 : _t.name) || ht.name;
                (vt = ht == null ? void 0 : ht.setMaterial) === null || vt === void 0 || vt.call(ht, ut),
                ht.material.name = St
            } else {
                const St = Array.isArray(ht.material) ? ht.material : [ht.material];
                for (const At of St)
                    (bt = at.materials) === null || bt === void 0 || bt.copyMaterialProps(At, ut)
            }
        }
        )
    }
    async addMapping(o, c, h=!0) {
        if (!o || !c)
            return;
        const _ = this.mapping.findIndex(b => b.name === o);
        return _ !== -1 ? this.mapping[_] = {
            name: o,
            path: c
        } : this.mapping.push({
            name: o,
            path: c
        }),
        h ? this._apply(o, c) : void 0
    }
}
;
MaterialPresetPlugin$1.PluginType = "MaterialPresetPlugin",
MaterialPresetPlugin_decorate([serialize()], MaterialPresetPlugin$1.prototype, "mapping", void 0);
var TransfrSharePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let TransfrSharePlugin = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.toJSON = null,
        this.enabled = !0,
        this.dependencies = [AssetExporterPlugin],
        this._exporting = !1
    }
    async exportObject(d) {
        var o, c;
        const h = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(AssetExporterPlugin);
        if (!h)
            throw new Error("AssetExporterPlugin not found");
        return d ? (c = h.exporter) === null || c === void 0 ? void 0 : c.exportObject(d, {
            format: "glb"
        }) : h.exportScene(h.exportOptions)
    }
    async getLink(d) {
        var o;
        const c = await this.exportObject(d);
        if (!c)
            throw new Error("Failed to export object or scene");
        const h = await fetch("https://bee.transfr.one/model.glb", {
            method: "PUT",
            body: c
        });
        if (h.status !== 200)
            throw new Error("Failed to upload file");
        const _ = (o = await h.text()) === null || o === void 0 ? void 0 : o.trim();
        console.log(_);
        try {
            new URL(_)
        } catch {
            throw new Error("Invalid URL " + _)
        }
        return _
    }
    async shareLink(d, o="m") {
        var c;
        if (this._exporting)
            return;
        this._exporting = !0;
        let h = await this.getLink().catch(_ => {
            var b, _e;
            return (b = this._viewer) === null || b === void 0 || b.console.error(_),
            (_e = this._viewer) === null || _e === void 0 || _e.alert(`Error: Failed to share scene: 
` + _.message),
            null
        }
        );
        if (h) {
            if (d) {
                const b = typeof d == "string" ? new URL(d) : d;
                b.searchParams.set(o ?? "m", h),
                h = b.href
            }
            let _ = !1;
            try {
                window && window.navigator && navigator.clipboard && (await navigator.clipboard.writeText(h),
                _ = !0)
            } catch (b) {
                console.error("Failed to copy link", b)
            }
            (c = this._viewer) === null || c === void 0 || c.alert("Link" + (_ ? " Copied: " : ": " + h) + `

Note: File will be deleted in 7 days`)
        }
        return this._exporting = !1,
        h
    }
    async shareEditorLink() {
        const d = new URL(window.location.href);
        return this.shareLink(d)
    }
    async shareViewerLink() {
        const d = new URL(window.location.href);
        return d.pathname = d.pathname.replace(/editor\.html$/, "viewer.html"),
        this.shareLink(d)
    }
}
;
TransfrSharePlugin.PluginType = "TransfrSharePlugin",
TransfrSharePlugin_decorate([uiButton("Share editor link")], TransfrSharePlugin.prototype, "shareEditorLink", null),
TransfrSharePlugin_decorate([uiButton("Share viewer link")], TransfrSharePlugin.prototype, "shareViewerLink", null),
TransfrSharePlugin = TransfrSharePlugin_decorate([uiFolder("Share Link")], TransfrSharePlugin);
var ndarray_ndarray = __webpackgi_require__(881)
  , ndarray_ops = __webpackgi_require__(49);
function getPixelsInternal(d, o) {
    if (!(d instanceof Uint8Array))
        throw new Error("[ndarray-pixels] Input must be Uint8Array or Buffer.");
    const c = new Blob([d],{
        type: o
    })
      , h = URL.createObjectURL(c);
    return new Promise( (_, b) => {
        const _e = new Image;
        _e.crossOrigin = "anonymous",
        _e.onload = function() {
            URL.revokeObjectURL(h);
            const nt = new OffscreenCanvas(_e.width,_e.height).getContext("2d");
            nt.drawImage(_e, 0, 0);
            const it = nt.getImageData(0, 0, _e.width, _e.height);
            _(ndarray_ndarray(new Uint8Array(it.data), [_e.width, _e.height, 4], [4, 4 * _e.width, 1], 0))
        }
        ,
        _e.onerror = nt => {
            URL.revokeObjectURL(h),
            b(nt)
        }
        ,
        _e.src = h
    }
    )
}
function putPixelData(d, o, c=-1) {
    if (d.shape.length === 4)
        return putPixelData(d.pick(c), o, 0);
    if (d.shape.length === 3)
        if (d.shape[2] === 3)
            ndarray_ops.assign(ndarray_ndarray(o, [d.shape[0], d.shape[1], 3], [4, 4 * d.shape[0], 1]), d),
            ndarray_ops.assigns(ndarray_ndarray(o, [d.shape[0] * d.shape[1]], [4], 3), 255);
        else if (d.shape[2] === 4)
            ndarray_ops.assign(ndarray_ndarray(o, [d.shape[0], d.shape[1], 4], [4, 4 * d.shape[0], 1]), d);
        else {
            if (d.shape[2] !== 1)
                throw new Error("[ndarray-pixels] Incompatible array shape.");
            ndarray_ops.assign(ndarray_ndarray(o, [d.shape[0], d.shape[1], 3], [4, 4 * d.shape[0], 1]), ndarray_ndarray(d.data, [d.shape[0], d.shape[1], 3], [d.stride[0], d.stride[1], 0], d.offset)),
            ndarray_ops.assigns(ndarray_ndarray(o, [d.shape[0] * d.shape[1]], [4], 3), 255)
        }
    else {
        if (d.shape.length !== 2)
            throw new Error("[ndarray-pixels] Incompatible array shape.");
        ndarray_ops.assign(ndarray_ndarray(o, [d.shape[0], d.shape[1], 3], [4, 4 * d.shape[0], 1]), ndarray_ndarray(d.data, [d.shape[0], d.shape[1], 3], [d.stride[0], d.stride[1], 0], d.offset)),
        ndarray_ops.assigns(ndarray_ndarray(o, [d.shape[0] * d.shape[1]], [4], 3), 255)
    }
    return o
}
async function savePixelsInternal(d, o) {
    const c = new OffscreenCanvas(d.shape[0],d.shape[1])
      , h = c.getContext("2d")
      , _ = h.getImageData(0, 0, c.width, c.height);
    return putPixelData(d, _.data),
    h.putImageData(_, 0, 0),
    streamCanvas(c, o)
}
async function streamCanvas(d, o) {
    const c = await d.convertToBlob(o)
      , h = await c.arrayBuffer();
    return new Uint8Array(h)
}
async function ndarray_pixels_browser_modern_getPixels(d, o) {
    return getPixelsInternal(d, o)
}
async function ndarray_pixels_browser_modern_savePixels(d, o) {
    let c;
    return c = {
        type: o,
        quality: void 0
    },
    savePixelsInternal(d, c)
}
function functions_modern_extends() {
    return functions_modern_extends = Object.assign ? Object.assign.bind() : function(d) {
        for (var o = 1; o < arguments.length; o++) {
            var c = arguments[o];
            for (var h in c)
                ({}).hasOwnProperty.call(c, h) && (d[h] = c[h])
        }
        return d
    }
    ,
    functions_modern_extends.apply(null, arguments)
}
index_modern_Primitive.Mode;
function createTransform(d, o) {
    return Object.defineProperty(o, "name", {
        value: d
    }),
    o
}
async function rewriteTexture(d, o, c) {
    if (!d)
        return null;
    const h = d.getImage();
    if (!h)
        return null;
    const _ = await ndarray_pixels_browser_modern_getPixels(h, d.getMimeType());
    for (let _e = 0; _e < _.shape[0]; ++_e)
        for (let nt = 0; nt < _.shape[1]; ++nt)
            c(_, _e, nt);
    const b = await ndarray_pixels_browser_modern_savePixels(_, "image/png");
    return o.setImage(b).setMimeType("image/png")
}
var functions_modern_ARRAY_TYPE = typeof Float32Array < "u" ? Float32Array : Array;
function create$1() {
    var d = new functions_modern_ARRAY_TYPE(3);
    return functions_modern_ARRAY_TYPE != Float32Array && (d[0] = 0,
    d[1] = 0,
    d[2] = 0),
    d
}
Math.hypot || (Math.hypot = function() {
    for (var d = 0, o = arguments.length; o--; )
        d += arguments[o] * arguments[o];
    return Math.sqrt(d)
}
);
create$1();
index_modern_PropertyType.ACCESSOR,
index_modern_PropertyType.MESH,
index_modern_PropertyType.TEXTURE,
index_modern_PropertyType.MATERIAL,
index_modern_PropertyType.SKIN;
function functions_modern_create() {
    var d = new functions_modern_ARRAY_TYPE(4);
    return functions_modern_ARRAY_TYPE != Float32Array && (d[0] = 0,
    d[1] = 0,
    d[2] = 0,
    d[3] = 0),
    d
}
functions_modern_create();
index_modern_PropertyType.NODE,
index_modern_PropertyType.SKIN,
index_modern_PropertyType.MESH,
index_modern_PropertyType.CAMERA,
index_modern_PropertyType.PRIMITIVE,
index_modern_PropertyType.PRIMITIVE_TARGET,
index_modern_PropertyType.ANIMATION,
index_modern_PropertyType.MATERIAL,
index_modern_PropertyType.TEXTURE,
index_modern_PropertyType.ACCESSOR,
index_modern_PropertyType.BUFFER;
var VertexCountMethod;
(function(d) {
    d.RENDER = "render",
    d.RENDER_CACHED = "render-cached",
    d.UPLOAD = "upload",
    d.UPLOAD_NAIVE = "upload-naive",
    d.DISTINCT = "distinct",
    d.DISTINCT_POSITION = "distinct-position",
    d.UNUSED = "unused"
}
)(VertexCountMethod || (VertexCountMethod = {}));
index_modern_Accessor.ComponentType;
index_modern_Primitive.Mode;
index_modern_Primitive.Mode;
index_modern_AnimationChannel.TargetPath;
const QUANTIZE_DEFAULTS = {
    pattern: /.*/,
    quantizationVolume: "mesh",
    quantizePosition: 14,
    quantizeNormal: 10,
    quantizeTexcoord: 12,
    quantizeColor: 8,
    quantizeWeight: 8,
    quantizeGeneric: 12,
    normalizeWeights: !0,
    cleanup: !0
};
functions_modern_extends({
    level: "high"
}, QUANTIZE_DEFAULTS);
const functions_modern_NAME$d = "metalRough"
  , METALROUGH_DEFAULTS = {};
function metalRough(d=METALROUGH_DEFAULTS) {
    return createTransform(functions_modern_NAME$d, async o => {
        const c = o.getLogger();
        if (!o.getRoot().listExtensionsUsed().map(nt => nt.extensionName).includes("KHR_materials_pbrSpecularGlossiness"))
            return void c.warn(`${functions_modern_NAME$d}: KHR_materials_pbrSpecularGlossiness not found on document.`);
        const h = o.createExtension(KHRMaterialsIOR)
          , _ = o.createExtension(KHRMaterialsSpecular)
          , b = o.createExtension(KHRMaterialsPBRSpecularGlossiness)
          , _e = new Set;
        for (const nt of o.getRoot().listMaterials()) {
            const it = nt.getExtension("KHR_materials_pbrSpecularGlossiness");
            if (!it)
                continue;
            const at = _.createSpecular().setSpecularFactor(1).setSpecularColorFactor(it.getSpecularFactor());
            _e.add(it.getSpecularGlossinessTexture()),
            _e.add(nt.getBaseColorTexture()),
            _e.add(nt.getMetallicRoughnessTexture()),
            nt.setBaseColorFactor(it.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior", h.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular", at);
            const ut = it.getDiffuseTexture();
            ut && (nt.setBaseColorTexture(ut),
            nt.getBaseColorTextureInfo().copy(it.getDiffuseTextureInfo()));
            const pt = it.getSpecularGlossinessTexture();
            if (pt) {
                const ht = it.getSpecularGlossinessTextureInfo()
                  , _t = o.createTexture();
                await rewriteTexture(pt, _t, (St, At, Et) => {
                    St.set(At, Et, 3, 255)
                }
                ),
                at.setSpecularTexture(_t),
                at.setSpecularColorTexture(_t),
                at.getSpecularTextureInfo().copy(ht),
                at.getSpecularColorTextureInfo().copy(ht);
                const vt = it.getGlossinessFactor()
                  , bt = o.createTexture();
                await rewriteTexture(pt, bt, (St, At, Et) => {
                    const Pt = 255 - Math.round(St.get(At, Et, 3) * vt);
                    St.set(At, Et, 0, 0),
                    St.set(At, Et, 1, Pt),
                    St.set(At, Et, 2, 0),
                    St.set(At, Et, 3, 255)
                }
                ),
                nt.setMetallicRoughnessTexture(bt),
                nt.getMetallicRoughnessTextureInfo().copy(ht)
            } else
                at.setSpecularColorFactor(it.getSpecularFactor()),
                nt.setRoughnessFactor(1 - it.getGlossinessFactor());
            nt.setExtension("KHR_materials_pbrSpecularGlossiness", null)
        }
        b.dispose();
        for (const nt of _e)
            nt && nt.listParents().length === 1 && nt.dispose();
        c.debug(`${functions_modern_NAME$d}: Complete.`)
    }
    )
}
var InterpolationInternal;
(function(d) {
    d[d.STEP = 0] = "STEP",
    d[d.LERP = 1] = "LERP",
    d[d.SLERP = 2] = "SLERP"
}
)(InterpolationInternal || (InterpolationInternal = {}));
const functions_modern_EPSILON = 1e-6;
function resampleDebug(d, o, c, h=1e-4) {
    const _ = o.length / d.length
      , b = new Array(_).fill(0)
      , _e = new Array(_).fill(0)
      , nt = new Array(_).fill(0)
      , it = new Array(_).fill(0)
      , at = d.length - 1;
    let ut = 1;
    for (let pt = 1; pt < at; ++pt) {
        const ht = d[ut - 1]
          , _t = d[pt]
          , vt = d[pt + 1]
          , bt = (_t - ht) / (vt - ht);
        let St = !1;
        if (_t !== vt && (pt !== 1 || _t !== d[0]))
            if (getElement(o, ut - 1, it),
            getElement(o, pt, _e),
            getElement(o, pt + 1, nt),
            c === "slerp") {
                const At = functions_modern_slerp(b, it, nt, bt)
                  , Et = getAngle(it, _e) + getAngle(_e, nt);
                St = !eq(_e, At, h) || Et + Number.EPSILON >= Math.PI
            } else
                c === "lerp" ? St = !eq(_e, vlerp(b, it, nt, bt), h) : c === "step" && (St = !eq(_e, it) || !eq(_e, nt));
        St && (pt !== ut && (d[ut] = d[pt],
        setElement(o, ut, getElement(o, pt, b))),
        ut++)
    }
    return at > 0 && (d[ut] = d[at],
    setElement(o, ut, getElement(o, at, b)),
    ut++),
    ut
}
function getElement(d, o, c) {
    for (let h = 0, _ = c.length; h < _; h++)
        c[h] = d[o * _ + h];
    return c
}
function setElement(d, o, c) {
    for (let h = 0, _ = c.length; h < _; h++)
        d[o * _ + h] = c[h]
}
function eq(d, o, c=0) {
    if (d.length !== o.length)
        return !1;
    for (let h = 0; h < d.length; h++)
        if (Math.abs(d[h] - o[h]) > c)
            return !1;
    return !0
}
function lerp(d, o, c) {
    return d * (1 - c) + o * c
}
function vlerp(d, o, c, h) {
    for (let _ = 0; _ < o.length; _++)
        d[_] = lerp(o[_], c[_], h);
    return d
}
function functions_modern_slerp(d, o, c, h) {
    let _, b, _e, nt, it, at = o[0], ut = o[1], pt = o[2], ht = o[3], _t = c[0], vt = c[1], bt = c[2], St = c[3];
    return b = at * _t + ut * vt + pt * bt + ht * St,
    b < 0 && (b = -b,
    _t = -_t,
    vt = -vt,
    bt = -bt,
    St = -St),
    1 - b > functions_modern_EPSILON ? (_ = Math.acos(b),
    _e = Math.sin(_),
    nt = Math.sin((1 - h) * _) / _e,
    it = Math.sin(h * _) / _e) : (nt = 1 - h,
    it = h),
    d[0] = nt * at + it * _t,
    d[1] = nt * ut + it * vt,
    d[2] = nt * pt + it * bt,
    d[3] = nt * ht + it * St,
    d
}
function getAngle(d, o) {
    const c = dot(d, o);
    return Math.acos(2 * c * c - 1)
}
function dot(d, o) {
    return d[0] * o[0] + d[1] * o[1] + d[2] * o[2] + d[3] * o[3]
}
Promise.resolve();
index_modern_Primitive.Mode;
var TextureResizeFilter;
(function(d) {
    d.LANCZOS3 = "lanczos3",
    d.LANCZOS2 = "lanczos2"
}
)(TextureResizeFilter || (TextureResizeFilter = {}));
TextureResizeFilter.LANCZOS3;
const gltfKhrPbrSpecularGlossinessConverter = d => o => ({
    name: "KHR_materials_pbrSpecularGlossiness",
    beforeRoot: async () => {
        var c, h;
        try {
            if (!o.json.extensionsUsed.includes("KHR_materials_pbrSpecularGlossiness") || d && !await d("Convert KHR_materials_pbrSpecularGlossiness to KHR_materials_pbrMetallicRoughness?"))
                return;
            const _ = o.json
              , b = new WebIO().registerExtensions(ALL_EXTENSIONS).registerExtensions(ALL_WEBGI_EXTENSIONS);
            if (o.extensions.KHR_draco_mesh_compression) {
                const at = o.extensions.KHR_draco_mesh_compression.dracoLoader;
                if (!at.isDRACOLoader2)
                    return void console.error("DRACOLoader2 required for gltfKhrPbrSpecularGlossinessConverter");
                const ut = await at.initDecoder();
                b.registerDependencies({
                    "draco3d.decoder": ut
                })
            }
            const _e = await b.readJSON({
                json: _,
                resources: {
                    "@glb.bin": new Uint8Array((c = o.extensions.KHR_binary_glTF) === null || c === void 0 ? void 0 : c.body)
                }
            });
            await _e.transform(metalRough()),
            o.extensions.KHR_draco_mesh_compression && ((h = _e.getRoot().listExtensionsUsed().find(at => at.extensionName === "KHR_draco_mesh_compression")) === null || h === void 0 || h.dispose());
            const nt = await b.writeBinary(_e)
              , it = new GLTFBinaryExtension(nt.buffer);
            o.extensions.KHR_binary_glTF = it,
            o.json = JSON.parse(it.content)
        } catch (_) {
            return void console.error(_)
        }
    }
});
class GLTFSpecGlossinessConverterPlugin extends AViewerPlugin {
    _loaderCreate({loader: o}) {
        o.isGLTFLoader2 && o.register(gltfKhrPbrSpecularGlossinessConverter(async c => {
            var h, _;
            return !!this.enabled && (!this.confirm || (_ = (h = this._viewer) === null || h === void 0 ? void 0 : h.confirm(this.confirmMessage || c)) === null || _ === void 0 || _)
        }
        ))
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.dependencies = [AssetManagerPlugin],
        this.confirm = !0,
        this.confirmMessage = "GLTF Load: This file includes specular glossiness materials, do you want to convert it to metallic roughness before load?",
        this._loaderCreate = this._loaderCreate.bind(this)
    }
    async onAdded(o) {
        var c;
        await super.onAdded(o);
        const h = o.getPlugin(AssetManagerPlugin);
        (c = h == null ? void 0 : h.importer) === null || c === void 0 || c.addEventListener("loaderCreate", this._loaderCreate)
    }
    async onRemove(o) {
        var c, h;
        return (h = (c = o.getPlugin(AssetManagerPlugin)) === null || c === void 0 ? void 0 : c.importer) === null || h === void 0 || h.removeEventListener("loaderCreate", this._loaderCreate),
        super.onRemove(o)
    }
}
GLTFSpecGlossinessConverterPlugin.PluginType = "GLTFSpecGlossinessConverterPlugin";
var RainbowDiamondPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let RainbowDiamondPlugin = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this.prefix = "",
        this.count = 50,
        this.loops = 1,
        this.color = new three_module.Q1f().setHSL(0, .8, .5)
    }
    colorItems() {
        if (!this._viewer)
            return;
        const d = this._viewer.scene.modelRoot;
        let o = 0;
        const c = this.color.getHSL({
            h: 0,
            s: 0,
            l: 0
        });
        d.traverse(h => {
            const _ = h.material && h.material.isDiamondMaterial
              , b = _ && h.name.startsWith(this.prefix);
            if (_ && console.log("Found Diamond, name = ", h.name, ", coloring = ", b),
            b) {
                let _e = h.name.replace(this.prefix, "");
                _e = parseFloat(_e) / this.count;
                const nt = new three_module.Q1f().setHSL((this.loops * _e + c.h) % 1, c.s, c.l);
                h.material = h.material.userData.isColoredClone ? h.material : h.material.clone(),
                h.material.color.set(nt),
                h.material.boostFactors.set(1, 1, 1),
                h.material.userData.isColoredClone = !0,
                o++
            }
        }
        ),
        console.log("total", o),
        this._viewer.setDirty()
    }
}
;
RainbowDiamondPlugin.PluginType = "RainbowDiamondPlugin",
RainbowDiamondPlugin_decorate([uiInput("Object name prefix")], RainbowDiamondPlugin.prototype, "prefix", void 0),
RainbowDiamondPlugin_decorate([uiInput("Count")], RainbowDiamondPlugin.prototype, "count", void 0),
RainbowDiamondPlugin_decorate([uiInput("Loops")], RainbowDiamondPlugin.prototype, "loops", void 0),
RainbowDiamondPlugin_decorate([uiColor("First Color")], RainbowDiamondPlugin.prototype, "color", void 0),
RainbowDiamondPlugin_decorate([uiButton("Color All Items")], RainbowDiamondPlugin.prototype, "colorItems", null),
RainbowDiamondPlugin = RainbowDiamondPlugin_decorate([uiFolder("Rainbow Diamond Coloring")], RainbowDiamondPlugin);
class BeringRingAnimation extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = null,
        this.ringSlots = [],
        this.dependencies = [AssetManagerPlugin, PopmotionPlugin],
        this._animating = !1,
        this._runningAnimations = [],
        this.uiConfig = {
            type: "folder",
            label: "Bering Animation",
            children: [{
                label: "Play Animation",
                type: "button",
                value: () => {
                    this.startRingAnimation(!1)
                }
            }, {
                label: "Record Animation",
                type: "button",
                value: async () => {
                    var o;
                    const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("CanvasRecorder");
                    if (!c || c.isRecording())
                        return;
                    this.animating && this.stopRingAnimation(!1),
                    await X$2(500);
                    const h = await c.record(async () => {
                        console.log("start"),
                        await this.startRingAnimation(!1),
                        console.log("finish")
                    }
                    );
                    h && (console.log("recorded", h),
                    N$2(h, "animation.mp4"))
                }
            }]
        }
    }
    get animating() {
        return this._animating
    }
    set animating(o) {
        var c, h;
        if (this._animating === o)
            return;
        this._animating = o;
        const _ = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(FrameFadePlugin);
        _ && (o ? _.disable("bering") : _.enable("bering"));
        const b = (h = this._viewer) === null || h === void 0 ? void 0 : h.getPlugin(TemporalAAPlugin);
        b && (b.enabled = !o)
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("addSceneObject", c => {
            var h, _, b, _e, nt;
            if (!(!((_ = (h = c.options) === null || h === void 0 ? void 0 : h.allImported) === null || _ === void 0) && _.length) || !c.object || !c.object.__importedViewerConfig && !(!((b = c.object.modelObject) === null || b === void 0) && b.__importedViewerConfig) || !(!((_e = c.options) === null || _e === void 0) && _e.allImported))
                return;
            let it = 0;
            const at = (nt = c.options) === null || nt === void 0 ? void 0 : nt.allImported.filter(ut => !!(ut && ut.modelObject && ut.name.endsWith("bmod"))).reverse();
            at.forEach(ut => {
                this.loadRingBMod(ut, ut.name, it, at.length - 1),
                it++
            }
            )
        }
        )
    }
    loadRingBMod(o, c, h, _) {
        var b, _e, nt;
        if (!c)
            return;
        if (!(!((b = this._viewer) === null || b === void 0) && b.getPlugin(AssetManagerPlugin)))
            throw new Error("no asset manager");
        this._runningAnimations && this.stopRingAnimation(),
        c.endsWith(".bmod") || (c += ".bmod");
        const it = o == null ? void 0 : o.modelObject;
        if (!it || !o)
            throw new Error("no model");
        it.userData.__ringSlot = h,
        this.ringSlots[h] = o;
        const at = [];
        it.traverse(pt => {
            pt.userData.rotationCount > 1 && at.push(pt)
        }
        ),
        new Box3B().expandByObjects(at, !0, !0),
        c.toLowerCase().includes("x3") || c.toLowerCase().includes("x4");
        const ut = parseInt(c.split("-").pop().toLowerCase().replace("x", "").replace(".bmod", "")) + 1;
        return it.userData.__ringWidth = ut,
        it.userData.__ringTotalSlots = _,
        (nt = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.scene) === null || nt === void 0 || nt.setDirty({
            sceneUpdate: !0,
            frameFade: !1
        }),
        o
    }
    clearAllSlots() {
        this.ringSlots.forEach(o => {
            o.modelObject.removeFromParent()
        }
        ),
        this.ringSlots = []
    }
    stopRingAnimation(o=!0) {
        var c, h;
        if (this._runningAnimations.length !== 0) {
            for (const _ of this._runningAnimations)
                _.stop();
            this._runningAnimations = [],
            o && ((h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(FrameFadePlugin)) === null || h === void 0 || h.startTransition(1200))
        }
    }
    async startRingAnimation(o=!0) {
        if (this.animating || !this._viewer)
            return;
        this.stopRingAnimation(),
        this.animating = !0;
        let c = 0;
        const h = [];
        await new Promise(_ => {
            var b, _e, nt;
            if (!this._viewer)
                return;
            const it = () => {
                c += 1,
                c < h.length || _()
            }
              , at = 2500
              , ut = this._viewer.getPlugin(PopmotionPlugin)
              , pt = this.ringSlots[0];
            if (pt) {
                const ht = pt.modelObject
                  , _t = {
                    left: [],
                    right: [],
                    rem: []
                };
                ht.traverse(St => {
                    const At = (St == null ? void 0 : St.name.trim().toLowerCase().replace(/[0-9]/g, "")) || "";
                    At.endsWith("-s") ? _t.left.push(St) : At.endsWith("-l") ? _t.right.push(St) : At.startsWith("testlogo") && _t.rem.push(St)
                }
                );
                const vt = [];
                for (const St of _t.left) {
                    const At = ((b = St.parent) === null || b === void 0 ? void 0 : b.children) || [];
                    vt.push(...At)
                }
                for (const St of _t.right) {
                    const At = ((_e = St.parent) === null || _e === void 0 ? void 0 : _e.children) || [];
                    vt.push(...At)
                }
                for (const St of vt)
                    _t.left.includes(St) || _t.right.includes(St) || _t.rem.includes(St) || _t.rem.push(St);
                for (const St of _t.rem)
                    new Box3B().expandByObject(St, !1, !0).getCenter(new three_module.Pq0).x <= 0 ? _t.left.push(St) : _t.right.push(St);
                for (const St of [..._t.left, ..._t.right])
                    St.userData.__initX = St.position.x,
                    St.userData.__initRotX = St.rotation.x;
                const bt = (nt = this._viewer) === null || nt === void 0 ? void 0 : nt.getPluginByType("Ground");
                if (_t.left.length > 0 && _t.right.length > 0) {
                    const St = Et => Pt => {
                        var It, Dt, Gt;
                        for (const Bt of _t[Et])
                            Bt.position.x = Pt + Bt.userData.__initX;
                        (Dt = (It = this._viewer) === null || It === void 0 ? void 0 : It.scene) === null || Dt === void 0 || Dt.setDirty({
                            sceneUpdate: !1,
                            frameFade: !1
                        }),
                        o && ((Gt = bt == null ? void 0 : bt.shadowBaker) === null || Gt === void 0 || Gt.reset())
                    }
                      , At = Et => Pt => {
                        var It, Dt;
                        for (const Gt of _t[Et])
                            Gt.rotation.x = Pt + Gt.userData.__initRotX;
                        (Dt = (It = this._viewer) === null || It === void 0 ? void 0 : It.scene) === null || Dt === void 0 || Dt.setDirty({
                            sceneUpdate: !1,
                            frameFade: !1
                        })
                    }
                    ;
                    h.push(ut.animate({
                        from: 0,
                        to: -.75,
                        onUpdate: St("left"),
                        onStop: () => {
                            St("left")(0),
                            it()
                        }
                        ,
                        onComplete: it,
                        duration: at,
                        ease: EasingFunctions.easeInOut,
                        repeat: 1,
                        repeatDelay: 250,
                        repeatType: "mirror"
                    })),
                    h.push(ut.animate({
                        from: 0,
                        to: .75,
                        onUpdate: St("right"),
                        onStop: () => {
                            St("right")(0),
                            it()
                        }
                        ,
                        onComplete: it,
                        duration: at,
                        ease: EasingFunctions.easeInOut,
                        repeat: 1,
                        repeatDelay: 250,
                        repeatType: "mirror"
                    })),
                    h.push(ut.animate({
                        from: 0,
                        to: 1.5 * -Math.PI,
                        onUpdate: At("left"),
                        onStop: () => {
                            At("left")(0),
                            it()
                        }
                        ,
                        onComplete: it,
                        duration: 1250,
                        ease: EasingFunctions.easeInOut,
                        repeat: 1,
                        repeatDelay: 2750,
                        repeatType: "mirror"
                    }))
                }
            }
            this.ringSlots.forEach(ht => {
                if (pt === ht)
                    return;
                const _t = ht.modelObject.userData.__ringSlot
                  , vt = ht.modelObject.userData.__ringTotalSlots
                  , bt = ht.modelObject.userData.__ringWidth
                  , St = ht.modelObject.position.x;
                h.push(ut.animate({
                    from: St,
                    to: St + .75 - 1.5 * (1 - (_t + 1) / (vt + 1 + (2 - bt))),
                    onUpdate: At => {
                        var Et, Pt;
                        ht.modelObject.position.x = At,
                        (Pt = (Et = this._viewer) === null || Et === void 0 ? void 0 : Et.scene) === null || Pt === void 0 || Pt.setDirty({
                            sceneUpdate: !1,
                            frameFade: !1
                        })
                    }
                    ,
                    onStop: () => {
                        ht.modelObject.position.x = St,
                        it()
                    }
                    ,
                    onComplete: it,
                    duration: at,
                    ease: EasingFunctions.easeInOut,
                    repeat: 1,
                    repeatDelay: 250,
                    repeatType: "mirror"
                }))
            }
            ),
            h.length > 0 ? this._runningAnimations = h : (this.animating = !1,
            _())
        }
        ),
        this.animating = !1;
        for (const _ of this._runningAnimations)
            _.stop();
        this._runningAnimations = [],
        console.log("animation end")
    }
}
BeringRingAnimation.PluginType = "BeringRingAnimation";
class Mat3 {
    constructor(o) {
        o === void 0 && (o = [0, 0, 0, 0, 0, 0, 0, 0, 0]),
        this.elements = o
    }
    identity() {
        const o = this.elements;
        o[0] = 1,
        o[1] = 0,
        o[2] = 0,
        o[3] = 0,
        o[4] = 1,
        o[5] = 0,
        o[6] = 0,
        o[7] = 0,
        o[8] = 1
    }
    setZero() {
        const o = this.elements;
        o[0] = 0,
        o[1] = 0,
        o[2] = 0,
        o[3] = 0,
        o[4] = 0,
        o[5] = 0,
        o[6] = 0,
        o[7] = 0,
        o[8] = 0
    }
    setTrace(o) {
        const c = this.elements;
        c[0] = o.x,
        c[4] = o.y,
        c[8] = o.z
    }
    getTrace(o) {
        o === void 0 && (o = new Vec3);
        const c = this.elements;
        return o.x = c[0],
        o.y = c[4],
        o.z = c[8],
        o
    }
    vmult(o, c) {
        c === void 0 && (c = new Vec3);
        const h = this.elements
          , _ = o.x
          , b = o.y
          , _e = o.z;
        return c.x = h[0] * _ + h[1] * b + h[2] * _e,
        c.y = h[3] * _ + h[4] * b + h[5] * _e,
        c.z = h[6] * _ + h[7] * b + h[8] * _e,
        c
    }
    smult(o) {
        for (let c = 0; c < this.elements.length; c++)
            this.elements[c] *= o
    }
    mmult(o, c) {
        c === void 0 && (c = new Mat3);
        const h = this.elements
          , _ = o.elements
          , b = c.elements
          , _e = h[0]
          , nt = h[1]
          , it = h[2]
          , at = h[3]
          , ut = h[4]
          , pt = h[5]
          , ht = h[6]
          , _t = h[7]
          , vt = h[8]
          , bt = _[0]
          , St = _[1]
          , At = _[2]
          , Et = _[3]
          , Pt = _[4]
          , It = _[5]
          , Dt = _[6]
          , Gt = _[7]
          , Bt = _[8];
        return b[0] = _e * bt + nt * Et + it * Dt,
        b[1] = _e * St + nt * Pt + it * Gt,
        b[2] = _e * At + nt * It + it * Bt,
        b[3] = at * bt + ut * Et + pt * Dt,
        b[4] = at * St + ut * Pt + pt * Gt,
        b[5] = at * At + ut * It + pt * Bt,
        b[6] = ht * bt + _t * Et + vt * Dt,
        b[7] = ht * St + _t * Pt + vt * Gt,
        b[8] = ht * At + _t * It + vt * Bt,
        c
    }
    scale(o, c) {
        c === void 0 && (c = new Mat3);
        const h = this.elements
          , _ = c.elements;
        for (let b = 0; b !== 3; b++)
            _[3 * b + 0] = o.x * h[3 * b + 0],
            _[3 * b + 1] = o.y * h[3 * b + 1],
            _[3 * b + 2] = o.z * h[3 * b + 2];
        return c
    }
    solve(o, c) {
        c === void 0 && (c = new Vec3);
        const h = [];
        let _, b;
        for (_ = 0; _ < 12; _++)
            h.push(0);
        for (_ = 0; _ < 3; _++)
            for (b = 0; b < 3; b++)
                h[_ + 4 * b] = this.elements[_ + 3 * b];
        h[3] = o.x,
        h[7] = o.y,
        h[11] = o.z;
        let _e = 3;
        const nt = _e;
        let it, at;
        do {
            if (_ = nt - _e,
            h[_ + 4 * _] === 0) {
                for (b = _ + 1; b < nt; b++)
                    if (h[_ + 4 * b] !== 0) {
                        it = 4;
                        do
                            at = 4 - it,
                            h[at + 4 * _] += h[at + 4 * b];
                        while (--it);
                        break
                    }
            }
            if (h[_ + 4 * _] !== 0)
                for (b = _ + 1; b < nt; b++) {
                    const ut = h[_ + 4 * b] / h[_ + 4 * _];
                    it = 4;
                    do
                        at = 4 - it,
                        h[at + 4 * b] = at <= _ ? 0 : h[at + 4 * b] - h[at + 4 * _] * ut;
                    while (--it)
                }
        } while (--_e);
        if (c.z = h[11] / h[10],
        c.y = (h[7] - h[6] * c.z) / h[5],
        c.x = (h[3] - h[2] * c.z - h[1] * c.y) / h[0],
        isNaN(c.x) || isNaN(c.y) || isNaN(c.z) || c.x === 1 / 0 || c.y === 1 / 0 || c.z === 1 / 0)
            throw `Could not solve equation! Got x=[${c.toString()}], b=[${o.toString()}], A=[${this.toString()}]`;
        return c
    }
    e(o, c, h) {
        if (h === void 0)
            return this.elements[c + 3 * o];
        this.elements[c + 3 * o] = h
    }
    copy(o) {
        for (let c = 0; c < o.elements.length; c++)
            this.elements[c] = o.elements[c];
        return this
    }
    toString() {
        let o = "";
        for (let c = 0; c < 9; c++)
            o += this.elements[c] + ",";
        return o
    }
    reverse(o) {
        o === void 0 && (o = new Mat3);
        const c = reverse_eqns;
        let h, _;
        for (h = 0; h < 3; h++)
            for (_ = 0; _ < 3; _++)
                c[h + 6 * _] = this.elements[h + 3 * _];
        c[3] = 1,
        c[9] = 0,
        c[15] = 0,
        c[4] = 0,
        c[10] = 1,
        c[16] = 0,
        c[5] = 0,
        c[11] = 0,
        c[17] = 1;
        let b = 3;
        const _e = b;
        let nt, it;
        do {
            if (h = _e - b,
            c[h + 6 * h] === 0) {
                for (_ = h + 1; _ < _e; _++)
                    if (c[h + 6 * _] !== 0) {
                        nt = 6;
                        do
                            it = 6 - nt,
                            c[it + 6 * h] += c[it + 6 * _];
                        while (--nt);
                        break
                    }
            }
            if (c[h + 6 * h] !== 0)
                for (_ = h + 1; _ < _e; _++) {
                    const at = c[h + 6 * _] / c[h + 6 * h];
                    nt = 6;
                    do
                        it = 6 - nt,
                        c[it + 6 * _] = it <= h ? 0 : c[it + 6 * _] - c[it + 6 * h] * at;
                    while (--nt)
                }
        } while (--b);
        h = 2;
        do {
            _ = h - 1;
            do {
                const at = c[h + 6 * _] / c[h + 6 * h];
                nt = 6;
                do
                    it = 6 - nt,
                    c[it + 6 * _] = c[it + 6 * _] - c[it + 6 * h] * at;
                while (--nt)
            } while (_--)
        } while (--h);
        h = 2;
        do {
            const at = 1 / c[h + 6 * h];
            nt = 6;
            do
                it = 6 - nt,
                c[it + 6 * h] = c[it + 6 * h] * at;
            while (--nt)
        } while (h--);
        h = 2;
        do {
            _ = 2;
            do {
                if (it = c[3 + _ + 6 * h],
                isNaN(it) || it === 1 / 0)
                    throw `Could not reverse! A=[${this.toString()}]`;
                o.e(h, _, it)
            } while (_--)
        } while (h--);
        return o
    }
    setRotationFromQuaternion(o) {
        const c = o.x
          , h = o.y
          , _ = o.z
          , b = o.w
          , _e = c + c
          , nt = h + h
          , it = _ + _
          , at = c * _e
          , ut = c * nt
          , pt = c * it
          , ht = h * nt
          , _t = h * it
          , vt = _ * it
          , bt = b * _e
          , St = b * nt
          , At = b * it
          , Et = this.elements;
        return Et[0] = 1 - (ht + vt),
        Et[1] = ut - At,
        Et[2] = pt + St,
        Et[3] = ut + At,
        Et[4] = 1 - (at + vt),
        Et[5] = _t - bt,
        Et[6] = pt - St,
        Et[7] = _t + bt,
        Et[8] = 1 - (at + ht),
        this
    }
    transpose(o) {
        o === void 0 && (o = new Mat3);
        const c = this.elements
          , h = o.elements;
        let _;
        return h[0] = c[0],
        h[4] = c[4],
        h[8] = c[8],
        _ = c[1],
        h[1] = c[3],
        h[3] = _,
        _ = c[2],
        h[2] = c[6],
        h[6] = _,
        _ = c[5],
        h[5] = c[7],
        h[7] = _,
        o
    }
}
const reverse_eqns = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class Vec3 {
    constructor(o, c, h) {
        o === void 0 && (o = 0),
        c === void 0 && (c = 0),
        h === void 0 && (h = 0),
        this.x = o,
        this.y = c,
        this.z = h
    }
    cross(o, c) {
        c === void 0 && (c = new Vec3);
        const h = o.x
          , _ = o.y
          , b = o.z
          , _e = this.x
          , nt = this.y
          , it = this.z;
        return c.x = nt * b - it * _,
        c.y = it * h - _e * b,
        c.z = _e * _ - nt * h,
        c
    }
    set(o, c, h) {
        return this.x = o,
        this.y = c,
        this.z = h,
        this
    }
    setZero() {
        this.x = this.y = this.z = 0
    }
    vadd(o, c) {
        if (!c)
            return new Vec3(this.x + o.x,this.y + o.y,this.z + o.z);
        c.x = o.x + this.x,
        c.y = o.y + this.y,
        c.z = o.z + this.z
    }
    vsub(o, c) {
        if (!c)
            return new Vec3(this.x - o.x,this.y - o.y,this.z - o.z);
        c.x = this.x - o.x,
        c.y = this.y - o.y,
        c.z = this.z - o.z
    }
    crossmat() {
        return new Mat3([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0])
    }
    normalize() {
        const o = this.x
          , c = this.y
          , h = this.z
          , _ = Math.sqrt(o * o + c * c + h * h);
        if (_ > 0) {
            const b = 1 / _;
            this.x *= b,
            this.y *= b,
            this.z *= b
        } else
            this.x = 0,
            this.y = 0,
            this.z = 0;
        return _
    }
    unit(o) {
        o === void 0 && (o = new Vec3);
        const c = this.x
          , h = this.y
          , _ = this.z;
        let b = Math.sqrt(c * c + h * h + _ * _);
        return b > 0 ? (b = 1 / b,
        o.x = c * b,
        o.y = h * b,
        o.z = _ * b) : (o.x = 1,
        o.y = 0,
        o.z = 0),
        o
    }
    length() {
        const o = this.x
          , c = this.y
          , h = this.z;
        return Math.sqrt(o * o + c * c + h * h)
    }
    lengthSquared() {
        return this.dot(this)
    }
    distanceTo(o) {
        const c = this.x
          , h = this.y
          , _ = this.z
          , b = o.x
          , _e = o.y
          , nt = o.z;
        return Math.sqrt((b - c) * (b - c) + (_e - h) * (_e - h) + (nt - _) * (nt - _))
    }
    distanceSquared(o) {
        const c = this.x
          , h = this.y
          , _ = this.z
          , b = o.x
          , _e = o.y
          , nt = o.z;
        return (b - c) * (b - c) + (_e - h) * (_e - h) + (nt - _) * (nt - _)
    }
    scale(o, c) {
        c === void 0 && (c = new Vec3);
        const h = this.x
          , _ = this.y
          , b = this.z;
        return c.x = o * h,
        c.y = o * _,
        c.z = o * b,
        c
    }
    vmul(o, c) {
        return c === void 0 && (c = new Vec3),
        c.x = o.x * this.x,
        c.y = o.y * this.y,
        c.z = o.z * this.z,
        c
    }
    addScaledVector(o, c, h) {
        return h === void 0 && (h = new Vec3),
        h.x = this.x + o * c.x,
        h.y = this.y + o * c.y,
        h.z = this.z + o * c.z,
        h
    }
    dot(o) {
        return this.x * o.x + this.y * o.y + this.z * o.z
    }
    isZero() {
        return this.x === 0 && this.y === 0 && this.z === 0
    }
    negate(o) {
        return o === void 0 && (o = new Vec3),
        o.x = -this.x,
        o.y = -this.y,
        o.z = -this.z,
        o
    }
    tangents(o, c) {
        const h = this.length();
        if (h > 0) {
            const _ = Vec3_tangents_n
              , b = 1 / h;
            _.set(this.x * b, this.y * b, this.z * b);
            const _e = Vec3_tangents_randVec;
            Math.abs(_.x) < .9 ? (_e.set(1, 0, 0),
            _.cross(_e, o)) : (_e.set(0, 1, 0),
            _.cross(_e, o)),
            _.cross(o, c)
        } else
            o.set(1, 0, 0),
            c.set(0, 1, 0)
    }
    toString() {
        return `${this.x},${this.y},${this.z}`
    }
    toArray() {
        return [this.x, this.y, this.z]
    }
    copy(o) {
        return this.x = o.x,
        this.y = o.y,
        this.z = o.z,
        this
    }
    lerp(o, c, h) {
        const _ = this.x
          , b = this.y
          , _e = this.z;
        h.x = _ + (o.x - _) * c,
        h.y = b + (o.y - b) * c,
        h.z = _e + (o.z - _e) * c
    }
    almostEquals(o, c) {
        return c === void 0 && (c = 1e-6),
        !(Math.abs(this.x - o.x) > c || Math.abs(this.y - o.y) > c || Math.abs(this.z - o.z) > c)
    }
    almostZero(o) {
        return o === void 0 && (o = 1e-6),
        !(Math.abs(this.x) > o || Math.abs(this.y) > o || Math.abs(this.z) > o)
    }
    isAntiparallelTo(o, c) {
        return this.negate(antip_neg),
        antip_neg.almostEquals(o, c)
    }
    clone() {
        return new Vec3(this.x,this.y,this.z)
    }
}
Vec3.ZERO = new Vec3(0,0,0),
Vec3.UNIT_X = new Vec3(1,0,0),
Vec3.UNIT_Y = new Vec3(0,1,0),
Vec3.UNIT_Z = new Vec3(0,0,1);
const Vec3_tangents_n = new Vec3
  , Vec3_tangents_randVec = new Vec3
  , antip_neg = new Vec3;
class AABB {
    constructor(o) {
        o === void 0 && (o = {}),
        this.lowerBound = new Vec3,
        this.upperBound = new Vec3,
        o.lowerBound && this.lowerBound.copy(o.lowerBound),
        o.upperBound && this.upperBound.copy(o.upperBound)
    }
    setFromPoints(o, c, h, _) {
        const b = this.lowerBound
          , _e = this.upperBound
          , nt = h;
        b.copy(o[0]),
        nt && nt.vmult(b, b),
        _e.copy(b);
        for (let it = 1; it < o.length; it++) {
            let at = o[it];
            nt && (nt.vmult(at, tmp$1),
            at = tmp$1),
            at.x > _e.x && (_e.x = at.x),
            at.x < b.x && (b.x = at.x),
            at.y > _e.y && (_e.y = at.y),
            at.y < b.y && (b.y = at.y),
            at.z > _e.z && (_e.z = at.z),
            at.z < b.z && (b.z = at.z)
        }
        return c && (c.vadd(b, b),
        c.vadd(_e, _e)),
        _ && (b.x -= _,
        b.y -= _,
        b.z -= _,
        _e.x += _,
        _e.y += _,
        _e.z += _),
        this
    }
    copy(o) {
        return this.lowerBound.copy(o.lowerBound),
        this.upperBound.copy(o.upperBound),
        this
    }
    clone() {
        return new AABB().copy(this)
    }
    extend(o) {
        this.lowerBound.x = Math.min(this.lowerBound.x, o.lowerBound.x),
        this.upperBound.x = Math.max(this.upperBound.x, o.upperBound.x),
        this.lowerBound.y = Math.min(this.lowerBound.y, o.lowerBound.y),
        this.upperBound.y = Math.max(this.upperBound.y, o.upperBound.y),
        this.lowerBound.z = Math.min(this.lowerBound.z, o.lowerBound.z),
        this.upperBound.z = Math.max(this.upperBound.z, o.upperBound.z)
    }
    overlaps(o) {
        const c = this.lowerBound
          , h = this.upperBound
          , _ = o.lowerBound
          , b = o.upperBound
          , _e = _.x <= h.x && h.x <= b.x || c.x <= b.x && b.x <= h.x
          , nt = _.y <= h.y && h.y <= b.y || c.y <= b.y && b.y <= h.y
          , it = _.z <= h.z && h.z <= b.z || c.z <= b.z && b.z <= h.z;
        return _e && nt && it
    }
    volume() {
        const o = this.lowerBound
          , c = this.upperBound;
        return (c.x - o.x) * (c.y - o.y) * (c.z - o.z)
    }
    contains(o) {
        const c = this.lowerBound
          , h = this.upperBound
          , _ = o.lowerBound
          , b = o.upperBound;
        return c.x <= _.x && h.x >= b.x && c.y <= _.y && h.y >= b.y && c.z <= _.z && h.z >= b.z
    }
    getCorners(o, c, h, _, b, _e, nt, it) {
        const at = this.lowerBound
          , ut = this.upperBound;
        o.copy(at),
        c.set(ut.x, at.y, at.z),
        h.set(ut.x, ut.y, at.z),
        _.set(at.x, ut.y, ut.z),
        b.set(ut.x, at.y, ut.z),
        _e.set(at.x, ut.y, at.z),
        nt.set(at.x, at.y, ut.z),
        it.copy(ut)
    }
    toLocalFrame(o, c) {
        const h = transformIntoFrame_corners
          , _ = h[0]
          , b = h[1]
          , _e = h[2]
          , nt = h[3]
          , it = h[4]
          , at = h[5]
          , ut = h[6]
          , pt = h[7];
        this.getCorners(_, b, _e, nt, it, at, ut, pt);
        for (let ht = 0; ht !== 8; ht++) {
            const _t = h[ht];
            o.pointToLocal(_t, _t)
        }
        return c.setFromPoints(h)
    }
    toWorldFrame(o, c) {
        const h = transformIntoFrame_corners
          , _ = h[0]
          , b = h[1]
          , _e = h[2]
          , nt = h[3]
          , it = h[4]
          , at = h[5]
          , ut = h[6]
          , pt = h[7];
        this.getCorners(_, b, _e, nt, it, at, ut, pt);
        for (let ht = 0; ht !== 8; ht++) {
            const _t = h[ht];
            o.pointToWorld(_t, _t)
        }
        return c.setFromPoints(h)
    }
    overlapsRay(o) {
        const {direction: c, from: h} = o
          , _ = 1 / c.x
          , b = 1 / c.y
          , _e = 1 / c.z
          , nt = (this.lowerBound.x - h.x) * _
          , it = (this.upperBound.x - h.x) * _
          , at = (this.lowerBound.y - h.y) * b
          , ut = (this.upperBound.y - h.y) * b
          , pt = (this.lowerBound.z - h.z) * _e
          , ht = (this.upperBound.z - h.z) * _e
          , _t = Math.max(Math.max(Math.min(nt, it), Math.min(at, ut)), Math.min(pt, ht))
          , vt = Math.min(Math.min(Math.max(nt, it), Math.max(at, ut)), Math.max(pt, ht));
        return !(vt < 0 || _t > vt)
    }
}
const tmp$1 = new Vec3
  , transformIntoFrame_corners = [new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3];
class ArrayCollisionMatrix {
    constructor() {
        this.matrix = []
    }
    get(o, c) {
        let {index: h} = o
          , {index: _} = c;
        if (_ > h) {
            const b = _;
            _ = h,
            h = b
        }
        return this.matrix[(h * (h + 1) >> 1) + _ - 1]
    }
    set(o, c, h) {
        let {index: _} = o
          , {index: b} = c;
        if (b > _) {
            const _e = b;
            b = _,
            _ = _e
        }
        this.matrix[(_ * (_ + 1) >> 1) + b - 1] = h ? 1 : 0
    }
    reset() {
        for (let o = 0, c = this.matrix.length; o !== c; o++)
            this.matrix[o] = 0
    }
    setNumObjects(o) {
        this.matrix.length = o * (o - 1) >> 1
    }
}
class EventTarget {
    addEventListener(o, c) {
        this._listeners === void 0 && (this._listeners = {});
        const h = this._listeners;
        return h[o] === void 0 && (h[o] = []),
        h[o].includes(c) || h[o].push(c),
        this
    }
    hasEventListener(o, c) {
        if (this._listeners === void 0)
            return !1;
        const h = this._listeners;
        return !(h[o] === void 0 || !h[o].includes(c))
    }
    hasAnyEventListener(o) {
        return this._listeners !== void 0 && this._listeners[o] !== void 0
    }
    removeEventListener(o, c) {
        if (this._listeners === void 0)
            return this;
        const h = this._listeners;
        if (h[o] === void 0)
            return this;
        const _ = h[o].indexOf(c);
        return _ !== -1 && h[o].splice(_, 1),
        this
    }
    dispatchEvent(o) {
        if (this._listeners === void 0)
            return this;
        const c = this._listeners[o.type];
        if (c !== void 0) {
            o.target = this;
            for (let h = 0, _ = c.length; h < _; h++)
                c[h].call(this, o)
        }
        return this
    }
}
class Quaternion {
    constructor(o, c, h, _) {
        o === void 0 && (o = 0),
        c === void 0 && (c = 0),
        h === void 0 && (h = 0),
        _ === void 0 && (_ = 1),
        this.x = o,
        this.y = c,
        this.z = h,
        this.w = _
    }
    set(o, c, h, _) {
        return this.x = o,
        this.y = c,
        this.z = h,
        this.w = _,
        this
    }
    toString() {
        return `${this.x},${this.y},${this.z},${this.w}`
    }
    toArray() {
        return [this.x, this.y, this.z, this.w]
    }
    setFromAxisAngle(o, c) {
        const h = Math.sin(.5 * c);
        return this.x = o.x * h,
        this.y = o.y * h,
        this.z = o.z * h,
        this.w = Math.cos(.5 * c),
        this
    }
    toAxisAngle(o) {
        o === void 0 && (o = new Vec3),
        this.normalize();
        const c = 2 * Math.acos(this.w)
          , h = Math.sqrt(1 - this.w * this.w);
        return h < .001 ? (o.x = this.x,
        o.y = this.y,
        o.z = this.z) : (o.x = this.x / h,
        o.y = this.y / h,
        o.z = this.z / h),
        [o, c]
    }
    setFromVectors(o, c) {
        if (o.isAntiparallelTo(c)) {
            const h = sfv_t1
              , _ = sfv_t2;
            o.tangents(h, _),
            this.setFromAxisAngle(h, Math.PI)
        } else {
            const h = o.cross(c);
            this.x = h.x,
            this.y = h.y,
            this.z = h.z,
            this.w = Math.sqrt(o.length() ** 2 * c.length() ** 2) + o.dot(c),
            this.normalize()
        }
        return this
    }
    mult(o, c) {
        c === void 0 && (c = new Quaternion);
        const h = this.x
          , _ = this.y
          , b = this.z
          , _e = this.w
          , nt = o.x
          , it = o.y
          , at = o.z
          , ut = o.w;
        return c.x = h * ut + _e * nt + _ * at - b * it,
        c.y = _ * ut + _e * it + b * nt - h * at,
        c.z = b * ut + _e * at + h * it - _ * nt,
        c.w = _e * ut - h * nt - _ * it - b * at,
        c
    }
    inverse(o) {
        o === void 0 && (o = new Quaternion);
        const c = this.x
          , h = this.y
          , _ = this.z
          , b = this.w;
        this.conjugate(o);
        const _e = 1 / (c * c + h * h + _ * _ + b * b);
        return o.x *= _e,
        o.y *= _e,
        o.z *= _e,
        o.w *= _e,
        o
    }
    conjugate(o) {
        return o === void 0 && (o = new Quaternion),
        o.x = -this.x,
        o.y = -this.y,
        o.z = -this.z,
        o.w = this.w,
        o
    }
    normalize() {
        let o = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        return o === 0 ? (this.x = 0,
        this.y = 0,
        this.z = 0,
        this.w = 0) : (o = 1 / o,
        this.x *= o,
        this.y *= o,
        this.z *= o,
        this.w *= o),
        this
    }
    normalizeFast() {
        const o = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
        return o === 0 ? (this.x = 0,
        this.y = 0,
        this.z = 0,
        this.w = 0) : (this.x *= o,
        this.y *= o,
        this.z *= o,
        this.w *= o),
        this
    }
    vmult(o, c) {
        c === void 0 && (c = new Vec3);
        const h = o.x
          , _ = o.y
          , b = o.z
          , _e = this.x
          , nt = this.y
          , it = this.z
          , at = this.w
          , ut = at * h + nt * b - it * _
          , pt = at * _ + it * h - _e * b
          , ht = at * b + _e * _ - nt * h
          , _t = -_e * h - nt * _ - it * b;
        return c.x = ut * at + _t * -_e + pt * -it - ht * -nt,
        c.y = pt * at + _t * -nt + ht * -_e - ut * -it,
        c.z = ht * at + _t * -it + ut * -nt - pt * -_e,
        c
    }
    copy(o) {
        return this.x = o.x,
        this.y = o.y,
        this.z = o.z,
        this.w = o.w,
        this
    }
    toEuler(o, c) {
        let h, _, b;
        c === void 0 && (c = "YZX");
        const _e = this.x
          , nt = this.y
          , it = this.z
          , at = this.w;
        if (c !== "YZX")
            throw new Error(`Euler order ${c} not supported yet.`);
        {
            const ut = _e * nt + it * at;
            if (ut > .499 && (h = 2 * Math.atan2(_e, at),
            _ = Math.PI / 2,
            b = 0),
            ut < -.499 && (h = -2 * Math.atan2(_e, at),
            _ = -Math.PI / 2,
            b = 0),
            h === void 0) {
                const pt = _e * _e
                  , ht = nt * nt
                  , _t = it * it;
                h = Math.atan2(2 * nt * at - 2 * _e * it, 1 - 2 * ht - 2 * _t),
                _ = Math.asin(2 * ut),
                b = Math.atan2(2 * _e * at - 2 * nt * it, 1 - 2 * pt - 2 * _t)
            }
        }
        o.y = h,
        o.z = _,
        o.x = b
    }
    setFromEuler(o, c, h, _) {
        _ === void 0 && (_ = "XYZ");
        const b = Math.cos(o / 2)
          , _e = Math.cos(c / 2)
          , nt = Math.cos(h / 2)
          , it = Math.sin(o / 2)
          , at = Math.sin(c / 2)
          , ut = Math.sin(h / 2);
        return _ === "XYZ" ? (this.x = it * _e * nt + b * at * ut,
        this.y = b * at * nt - it * _e * ut,
        this.z = b * _e * ut + it * at * nt,
        this.w = b * _e * nt - it * at * ut) : _ === "YXZ" ? (this.x = it * _e * nt + b * at * ut,
        this.y = b * at * nt - it * _e * ut,
        this.z = b * _e * ut - it * at * nt,
        this.w = b * _e * nt + it * at * ut) : _ === "ZXY" ? (this.x = it * _e * nt - b * at * ut,
        this.y = b * at * nt + it * _e * ut,
        this.z = b * _e * ut + it * at * nt,
        this.w = b * _e * nt - it * at * ut) : _ === "ZYX" ? (this.x = it * _e * nt - b * at * ut,
        this.y = b * at * nt + it * _e * ut,
        this.z = b * _e * ut - it * at * nt,
        this.w = b * _e * nt + it * at * ut) : _ === "YZX" ? (this.x = it * _e * nt + b * at * ut,
        this.y = b * at * nt + it * _e * ut,
        this.z = b * _e * ut - it * at * nt,
        this.w = b * _e * nt - it * at * ut) : _ === "XZY" && (this.x = it * _e * nt - b * at * ut,
        this.y = b * at * nt - it * _e * ut,
        this.z = b * _e * ut + it * at * nt,
        this.w = b * _e * nt + it * at * ut),
        this
    }
    clone() {
        return new Quaternion(this.x,this.y,this.z,this.w)
    }
    slerp(o, c, h) {
        h === void 0 && (h = new Quaternion);
        const _ = this.x
          , b = this.y
          , _e = this.z
          , nt = this.w;
        let it, at, ut, pt, ht, _t = o.x, vt = o.y, bt = o.z, St = o.w;
        return at = _ * _t + b * vt + _e * bt + nt * St,
        at < 0 && (at = -at,
        _t = -_t,
        vt = -vt,
        bt = -bt,
        St = -St),
        1 - at > 1e-6 ? (it = Math.acos(at),
        ut = Math.sin(it),
        pt = Math.sin((1 - c) * it) / ut,
        ht = Math.sin(c * it) / ut) : (pt = 1 - c,
        ht = c),
        h.x = pt * _ + ht * _t,
        h.y = pt * b + ht * vt,
        h.z = pt * _e + ht * bt,
        h.w = pt * nt + ht * St,
        h
    }
    integrate(o, c, h, _) {
        _ === void 0 && (_ = new Quaternion);
        const b = o.x * h.x
          , _e = o.y * h.y
          , nt = o.z * h.z
          , it = this.x
          , at = this.y
          , ut = this.z
          , pt = this.w
          , ht = .5 * c;
        return _.x += ht * (b * pt + _e * ut - nt * at),
        _.y += ht * (_e * pt + nt * it - b * ut),
        _.z += ht * (nt * pt + b * at - _e * it),
        _.w += ht * (-b * it - _e * at - nt * ut),
        _
    }
}
const sfv_t1 = new Vec3
  , sfv_t2 = new Vec3
  , SHAPE_TYPES = {
    SPHERE: 1,
    PLANE: 2,
    BOX: 4,
    COMPOUND: 8,
    CONVEXPOLYHEDRON: 16,
    HEIGHTFIELD: 32,
    PARTICLE: 64,
    CYLINDER: 128,
    TRIMESH: 256
};
class Shape {
    constructor(o) {
        o === void 0 && (o = {}),
        this.id = Shape.idCounter++,
        this.type = o.type || 0,
        this.boundingSphereRadius = 0,
        this.collisionResponse = !o.collisionResponse || o.collisionResponse,
        this.collisionFilterGroup = o.collisionFilterGroup !== void 0 ? o.collisionFilterGroup : 1,
        this.collisionFilterMask = o.collisionFilterMask !== void 0 ? o.collisionFilterMask : -1,
        this.material = o.material ? o.material : null,
        this.body = null
    }
    updateBoundingSphereRadius() {
        throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`
    }
    volume() {
        throw `volume() not implemented for shape type ${this.type}`
    }
    calculateLocalInertia(o, c) {
        throw `calculateLocalInertia() not implemented for shape type ${this.type}`
    }
    calculateWorldAABB(o, c, h, _) {
        throw `calculateWorldAABB() not implemented for shape type ${this.type}`
    }
}
Shape.idCounter = 0,
Shape.types = SHAPE_TYPES;
class cannon_es_Transform {
    constructor(o) {
        o === void 0 && (o = {}),
        this.position = new Vec3,
        this.quaternion = new Quaternion,
        o.position && this.position.copy(o.position),
        o.quaternion && this.quaternion.copy(o.quaternion)
    }
    pointToLocal(o, c) {
        return cannon_es_Transform.pointToLocalFrame(this.position, this.quaternion, o, c)
    }
    pointToWorld(o, c) {
        return cannon_es_Transform.pointToWorldFrame(this.position, this.quaternion, o, c)
    }
    vectorToWorldFrame(o, c) {
        return c === void 0 && (c = new Vec3),
        this.quaternion.vmult(o, c),
        c
    }
    static pointToLocalFrame(o, c, h, _) {
        return _ === void 0 && (_ = new Vec3),
        h.vsub(o, _),
        c.conjugate(tmpQuat$1),
        tmpQuat$1.vmult(_, _),
        _
    }
    static pointToWorldFrame(o, c, h, _) {
        return _ === void 0 && (_ = new Vec3),
        c.vmult(h, _),
        _.vadd(o, _),
        _
    }
    static vectorToWorldFrame(o, c, h) {
        return h === void 0 && (h = new Vec3),
        o.vmult(c, h),
        h
    }
    static vectorToLocalFrame(o, c, h, _) {
        return _ === void 0 && (_ = new Vec3),
        c.w *= -1,
        c.vmult(h, _),
        c.w *= -1,
        _
    }
}
const tmpQuat$1 = new Quaternion;
class ConvexPolyhedron extends Shape {
    constructor(o) {
        o === void 0 && (o = {});
        const {vertices: c=[], faces: h=[], normals: _=[], axes: b, boundingSphereRadius: _e} = o;
        super({
            type: Shape.types.CONVEXPOLYHEDRON
        }),
        this.vertices = c,
        this.faces = h,
        this.faceNormals = _,
        this.faceNormals.length === 0 && this.computeNormals(),
        _e ? this.boundingSphereRadius = _e : this.updateBoundingSphereRadius(),
        this.worldVertices = [],
        this.worldVerticesNeedsUpdate = !0,
        this.worldFaceNormals = [],
        this.worldFaceNormalsNeedsUpdate = !0,
        this.uniqueAxes = b ? b.slice() : null,
        this.uniqueEdges = [],
        this.computeEdges()
    }
    computeEdges() {
        const o = this.faces
          , c = this.vertices
          , h = this.uniqueEdges;
        h.length = 0;
        const _ = new Vec3;
        for (let b = 0; b !== o.length; b++) {
            const _e = o[b]
              , nt = _e.length;
            for (let it = 0; it !== nt; it++) {
                const at = (it + 1) % nt;
                c[_e[it]].vsub(c[_e[at]], _),
                _.normalize();
                let ut = !1;
                for (let pt = 0; pt !== h.length; pt++)
                    if (h[pt].almostEquals(_) || h[pt].almostEquals(_)) {
                        ut = !0;
                        break
                    }
                ut || h.push(_.clone())
            }
        }
    }
    computeNormals() {
        this.faceNormals.length = this.faces.length;
        for (let o = 0; o < this.faces.length; o++) {
            for (let _ = 0; _ < this.faces[o].length; _++)
                if (!this.vertices[this.faces[o][_]])
                    throw new Error(`Vertex ${this.faces[o][_]} not found!`);
            const c = this.faceNormals[o] || new Vec3;
            this.getFaceNormal(o, c),
            c.negate(c),
            this.faceNormals[o] = c;
            const h = this.vertices[this.faces[o][0]];
            if (c.dot(h) < 0) {
                console.error(`.faceNormals[${o}] = Vec3(${c.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);
                for (let _ = 0; _ < this.faces[o].length; _++)
                    console.warn(`.vertices[${this.faces[o][_]}] = Vec3(${this.vertices[this.faces[o][_]].toString()})`)
            }
        }
    }
    getFaceNormal(o, c) {
        const h = this.faces[o]
          , _ = this.vertices[h[0]]
          , b = this.vertices[h[1]]
          , _e = this.vertices[h[2]];
        ConvexPolyhedron.computeNormal(_, b, _e, c)
    }
    static computeNormal(o, c, h, _) {
        const b = new Vec3
          , _e = new Vec3;
        c.vsub(o, _e),
        h.vsub(c, b),
        b.cross(_e, _),
        _.isZero() || _.normalize()
    }
    clipAgainstHull(o, c, h, _, b, _e, nt, it, at) {
        const ut = new Vec3;
        let pt = -1
          , ht = -Number.MAX_VALUE;
        for (let vt = 0; vt < h.faces.length; vt++) {
            ut.copy(h.faceNormals[vt]),
            b.vmult(ut, ut);
            const bt = ut.dot(_e);
            bt > ht && (ht = bt,
            pt = vt)
        }
        const _t = [];
        for (let vt = 0; vt < h.faces[pt].length; vt++) {
            const bt = h.vertices[h.faces[pt][vt]]
              , St = new Vec3;
            St.copy(bt),
            b.vmult(St, St),
            _.vadd(St, St),
            _t.push(St)
        }
        pt >= 0 && this.clipFaceAgainstHull(_e, o, c, _t, nt, it, at)
    }
    findSeparatingAxis(o, c, h, _, b, _e, nt, it) {
        const at = new Vec3
          , ut = new Vec3
          , pt = new Vec3
          , ht = new Vec3
          , _t = new Vec3
          , vt = new Vec3;
        let bt = Number.MAX_VALUE;
        const St = this;
        if (St.uniqueAxes)
            for (let At = 0; At !== St.uniqueAxes.length; At++) {
                h.vmult(St.uniqueAxes[At], at);
                const Et = St.testSepAxis(at, o, c, h, _, b);
                if (Et === !1)
                    return !1;
                Et < bt && (bt = Et,
                _e.copy(at))
            }
        else {
            const At = nt ? nt.length : St.faces.length;
            for (let Et = 0; Et < At; Et++) {
                const Pt = nt ? nt[Et] : Et;
                at.copy(St.faceNormals[Pt]),
                h.vmult(at, at);
                const It = St.testSepAxis(at, o, c, h, _, b);
                if (It === !1)
                    return !1;
                It < bt && (bt = It,
                _e.copy(at))
            }
        }
        if (o.uniqueAxes)
            for (let At = 0; At !== o.uniqueAxes.length; At++) {
                b.vmult(o.uniqueAxes[At], ut);
                const Et = St.testSepAxis(ut, o, c, h, _, b);
                if (Et === !1)
                    return !1;
                Et < bt && (bt = Et,
                _e.copy(ut))
            }
        else {
            const At = it ? it.length : o.faces.length;
            for (let Et = 0; Et < At; Et++) {
                const Pt = it ? it[Et] : Et;
                ut.copy(o.faceNormals[Pt]),
                b.vmult(ut, ut);
                const It = St.testSepAxis(ut, o, c, h, _, b);
                if (It === !1)
                    return !1;
                It < bt && (bt = It,
                _e.copy(ut))
            }
        }
        for (let At = 0; At !== St.uniqueEdges.length; At++) {
            h.vmult(St.uniqueEdges[At], ht);
            for (let Et = 0; Et !== o.uniqueEdges.length; Et++)
                if (b.vmult(o.uniqueEdges[Et], _t),
                ht.cross(_t, vt),
                !vt.almostZero()) {
                    vt.normalize();
                    const Pt = St.testSepAxis(vt, o, c, h, _, b);
                    if (Pt === !1)
                        return !1;
                    Pt < bt && (bt = Pt,
                    _e.copy(vt))
                }
        }
        return _.vsub(c, pt),
        pt.dot(_e) > 0 && _e.negate(_e),
        !0
    }
    testSepAxis(o, c, h, _, b, _e) {
        ConvexPolyhedron.project(this, o, h, _, maxminA),
        ConvexPolyhedron.project(c, o, b, _e, maxminB);
        const nt = maxminA[0]
          , it = maxminA[1]
          , at = maxminB[0]
          , ut = maxminB[1];
        if (nt < ut || at < it)
            return !1;
        const pt = nt - ut
          , ht = at - it;
        return pt < ht ? pt : ht
    }
    calculateLocalInertia(o, c) {
        const h = new Vec3
          , _ = new Vec3;
        this.computeLocalAABB(_, h);
        const b = h.x - _.x
          , _e = h.y - _.y
          , nt = h.z - _.z;
        c.x = 1 / 12 * o * (2 * _e * 2 * _e + 2 * nt * 2 * nt),
        c.y = 1 / 12 * o * (2 * b * 2 * b + 2 * nt * 2 * nt),
        c.z = 1 / 12 * o * (2 * _e * 2 * _e + 2 * b * 2 * b)
    }
    getPlaneConstantOfFace(o) {
        const c = this.faces[o]
          , h = this.faceNormals[o]
          , _ = this.vertices[c[0]];
        return -h.dot(_)
    }
    clipFaceAgainstHull(o, c, h, _, b, _e, nt) {
        const it = new Vec3
          , at = new Vec3
          , ut = new Vec3
          , pt = new Vec3
          , ht = new Vec3
          , _t = new Vec3
          , vt = new Vec3
          , bt = new Vec3
          , St = this
          , At = _
          , Et = [];
        let Pt = -1
          , It = Number.MAX_VALUE;
        for (let Ut = 0; Ut < St.faces.length; Ut++) {
            it.copy(St.faceNormals[Ut]),
            h.vmult(it, it);
            const Ht = it.dot(o);
            Ht < It && (It = Ht,
            Pt = Ut)
        }
        if (Pt < 0)
            return;
        const Dt = St.faces[Pt];
        Dt.connectedFaces = [];
        for (let Ut = 0; Ut < St.faces.length; Ut++)
            for (let Ht = 0; Ht < St.faces[Ut].length; Ht++)
                Dt.indexOf(St.faces[Ut][Ht]) !== -1 && Ut !== Pt && Dt.connectedFaces.indexOf(Ut) === -1 && Dt.connectedFaces.push(Ut);
        const Gt = Dt.length;
        for (let Ut = 0; Ut < Gt; Ut++) {
            const Ht = St.vertices[Dt[Ut]]
              , Kt = St.vertices[Dt[(Ut + 1) % Gt]];
            Ht.vsub(Kt, at),
            ut.copy(at),
            h.vmult(ut, ut),
            c.vadd(ut, ut),
            pt.copy(this.faceNormals[Pt]),
            h.vmult(pt, pt),
            c.vadd(pt, pt),
            ut.cross(pt, ht),
            ht.negate(ht),
            _t.copy(Ht),
            h.vmult(_t, _t),
            c.vadd(_t, _t);
            const Jt = Dt.connectedFaces[Ut];
            vt.copy(this.faceNormals[Jt]);
            const or = this.getPlaneConstantOfFace(Jt);
            bt.copy(vt),
            h.vmult(bt, bt);
            const ir = or - bt.dot(c);
            for (this.clipFaceAgainstPlane(At, Et, bt, ir); At.length; )
                At.shift();
            for (; Et.length; )
                At.push(Et.shift())
        }
        vt.copy(this.faceNormals[Pt]);
        const Bt = this.getPlaneConstantOfFace(Pt);
        bt.copy(vt),
        h.vmult(bt, bt);
        const kt = Bt - bt.dot(c);
        for (let Ut = 0; Ut < At.length; Ut++) {
            let Ht = bt.dot(At[Ut]) + kt;
            if (Ht <= b && (console.log(`clamped: depth=${Ht} to minDist=${b}`),
            Ht = b),
            Ht <= _e) {
                const Kt = At[Ut];
                if (Ht <= 1e-6) {
                    const Jt = {
                        point: Kt,
                        normal: bt,
                        depth: Ht
                    };
                    nt.push(Jt)
                }
            }
        }
    }
    clipFaceAgainstPlane(o, c, h, _) {
        let b, _e;
        const nt = o.length;
        if (nt < 2)
            return c;
        let it = o[o.length - 1]
          , at = o[0];
        b = h.dot(it) + _;
        for (let ut = 0; ut < nt; ut++) {
            if (at = o[ut],
            _e = h.dot(at) + _,
            b < 0)
                if (_e < 0) {
                    const pt = new Vec3;
                    pt.copy(at),
                    c.push(pt)
                } else {
                    const pt = new Vec3;
                    it.lerp(at, b / (b - _e), pt),
                    c.push(pt)
                }
            else if (_e < 0) {
                const pt = new Vec3;
                it.lerp(at, b / (b - _e), pt),
                c.push(pt),
                c.push(at)
            }
            it = at,
            b = _e
        }
        return c
    }
    computeWorldVertices(o, c) {
        for (; this.worldVertices.length < this.vertices.length; )
            this.worldVertices.push(new Vec3);
        const h = this.vertices
          , _ = this.worldVertices;
        for (let b = 0; b !== this.vertices.length; b++)
            c.vmult(h[b], _[b]),
            o.vadd(_[b], _[b]);
        this.worldVerticesNeedsUpdate = !1
    }
    computeLocalAABB(o, c) {
        const h = this.vertices;
        o.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),
        c.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        for (let _ = 0; _ < this.vertices.length; _++) {
            const b = h[_];
            b.x < o.x ? o.x = b.x : b.x > c.x && (c.x = b.x),
            b.y < o.y ? o.y = b.y : b.y > c.y && (c.y = b.y),
            b.z < o.z ? o.z = b.z : b.z > c.z && (c.z = b.z)
        }
    }
    computeWorldFaceNormals(o) {
        const c = this.faceNormals.length;
        for (; this.worldFaceNormals.length < c; )
            this.worldFaceNormals.push(new Vec3);
        const h = this.faceNormals
          , _ = this.worldFaceNormals;
        for (let b = 0; b !== c; b++)
            o.vmult(h[b], _[b]);
        this.worldFaceNormalsNeedsUpdate = !1
    }
    updateBoundingSphereRadius() {
        let o = 0;
        const c = this.vertices;
        for (let h = 0; h !== c.length; h++) {
            const _ = c[h].lengthSquared();
            _ > o && (o = _)
        }
        this.boundingSphereRadius = Math.sqrt(o)
    }
    calculateWorldAABB(o, c, h, _) {
        const b = this.vertices;
        let _e, nt, it, at, ut, pt, ht = new Vec3;
        for (let _t = 0; _t < b.length; _t++) {
            ht.copy(b[_t]),
            c.vmult(ht, ht),
            o.vadd(ht, ht);
            const vt = ht;
            (_e === void 0 || vt.x < _e) && (_e = vt.x),
            (at === void 0 || vt.x > at) && (at = vt.x),
            (nt === void 0 || vt.y < nt) && (nt = vt.y),
            (ut === void 0 || vt.y > ut) && (ut = vt.y),
            (it === void 0 || vt.z < it) && (it = vt.z),
            (pt === void 0 || vt.z > pt) && (pt = vt.z)
        }
        h.set(_e, nt, it),
        _.set(at, ut, pt)
    }
    volume() {
        return 4 * Math.PI * this.boundingSphereRadius / 3
    }
    getAveragePointLocal(o) {
        o === void 0 && (o = new Vec3);
        const c = this.vertices;
        for (let h = 0; h < c.length; h++)
            o.vadd(c[h], o);
        return o.scale(1 / c.length, o),
        o
    }
    transformAllPoints(o, c) {
        const h = this.vertices.length
          , _ = this.vertices;
        if (c) {
            for (let b = 0; b < h; b++) {
                const _e = _[b];
                c.vmult(_e, _e)
            }
            for (let b = 0; b < this.faceNormals.length; b++) {
                const _e = this.faceNormals[b];
                c.vmult(_e, _e)
            }
        }
        if (o)
            for (let b = 0; b < h; b++) {
                const _e = _[b];
                _e.vadd(o, _e)
            }
    }
    pointIsInside(o) {
        const c = this.vertices
          , h = this.faces
          , _ = this.faceNormals
          , b = new Vec3;
        this.getAveragePointLocal(b);
        for (let _e = 0; _e < this.faces.length; _e++) {
            let nt = _[_e];
            const it = c[h[_e][0]]
              , at = new Vec3;
            o.vsub(it, at);
            const ut = nt.dot(at)
              , pt = new Vec3;
            b.vsub(it, pt);
            const ht = nt.dot(pt);
            if (ut < 0 && ht > 0 || ut > 0 && ht < 0)
                return !1
        }
        return -1
    }
    static project(o, c, h, _, b) {
        const _e = o.vertices.length
          , nt = project_localAxis;
        let it = 0
          , at = 0;
        const ut = project_localOrigin
          , pt = o.vertices;
        ut.setZero(),
        cannon_es_Transform.vectorToLocalFrame(h, _, c, nt),
        cannon_es_Transform.pointToLocalFrame(h, _, ut, ut);
        const ht = ut.dot(nt);
        at = it = pt[0].dot(nt);
        for (let _t = 1; _t < _e; _t++) {
            const vt = pt[_t].dot(nt);
            vt > it && (it = vt),
            vt < at && (at = vt)
        }
        if (at -= ht,
        it -= ht,
        at > it) {
            const _t = at;
            at = it,
            it = _t
        }
        b[0] = it,
        b[1] = at
    }
}
const maxminA = []
  , maxminB = [];
new Vec3;
const project_localAxis = new Vec3
  , project_localOrigin = new Vec3;
class Box extends Shape {
    constructor(o) {
        super({
            type: Shape.types.BOX
        }),
        this.halfExtents = o,
        this.convexPolyhedronRepresentation = null,
        this.updateConvexPolyhedronRepresentation(),
        this.updateBoundingSphereRadius()
    }
    updateConvexPolyhedronRepresentation() {
        const o = this.halfExtents.x
          , c = this.halfExtents.y
          , h = this.halfExtents.z
          , _ = Vec3
          , b = [new _(-o,-c,-h), new _(o,-c,-h), new _(o,c,-h), new _(-o,c,-h), new _(-o,-c,h), new _(o,-c,h), new _(o,c,h), new _(-o,c,h)]
          , _e = [new _(0,0,1), new _(0,1,0), new _(1,0,0)]
          , nt = new ConvexPolyhedron({
            vertices: b,
            faces: [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]],
            axes: _e
        });
        this.convexPolyhedronRepresentation = nt,
        nt.material = this.material
    }
    calculateLocalInertia(o, c) {
        return c === void 0 && (c = new Vec3),
        Box.calculateInertia(this.halfExtents, o, c),
        c
    }
    static calculateInertia(o, c, h) {
        const _ = o;
        h.x = 1 / 12 * c * (2 * _.y * 2 * _.y + 2 * _.z * 2 * _.z),
        h.y = 1 / 12 * c * (2 * _.x * 2 * _.x + 2 * _.z * 2 * _.z),
        h.z = 1 / 12 * c * (2 * _.y * 2 * _.y + 2 * _.x * 2 * _.x)
    }
    getSideNormals(o, c) {
        const h = o
          , _ = this.halfExtents;
        if (h[0].set(_.x, 0, 0),
        h[1].set(0, _.y, 0),
        h[2].set(0, 0, _.z),
        h[3].set(-_.x, 0, 0),
        h[4].set(0, -_.y, 0),
        h[5].set(0, 0, -_.z),
        c !== void 0)
            for (let b = 0; b !== h.length; b++)
                c.vmult(h[b], h[b]);
        return h
    }
    volume() {
        return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z
    }
    updateBoundingSphereRadius() {
        this.boundingSphereRadius = this.halfExtents.length()
    }
    forEachWorldCorner(o, c, h) {
        const _ = this.halfExtents
          , b = [[_.x, _.y, _.z], [-_.x, _.y, _.z], [-_.x, -_.y, _.z], [-_.x, -_.y, -_.z], [_.x, -_.y, -_.z], [_.x, _.y, -_.z], [-_.x, _.y, -_.z], [_.x, -_.y, _.z]];
        for (let _e = 0; _e < b.length; _e++)
            worldCornerTempPos.set(b[_e][0], b[_e][1], b[_e][2]),
            c.vmult(worldCornerTempPos, worldCornerTempPos),
            o.vadd(worldCornerTempPos, worldCornerTempPos),
            h(worldCornerTempPos.x, worldCornerTempPos.y, worldCornerTempPos.z)
    }
    calculateWorldAABB(o, c, h, _) {
        const b = this.halfExtents;
        worldCornersTemp[0].set(b.x, b.y, b.z),
        worldCornersTemp[1].set(-b.x, b.y, b.z),
        worldCornersTemp[2].set(-b.x, -b.y, b.z),
        worldCornersTemp[3].set(-b.x, -b.y, -b.z),
        worldCornersTemp[4].set(b.x, -b.y, -b.z),
        worldCornersTemp[5].set(b.x, b.y, -b.z),
        worldCornersTemp[6].set(-b.x, b.y, -b.z),
        worldCornersTemp[7].set(b.x, -b.y, b.z);
        const _e = worldCornersTemp[0];
        c.vmult(_e, _e),
        o.vadd(_e, _e),
        _.copy(_e),
        h.copy(_e);
        for (let nt = 1; nt < 8; nt++) {
            const it = worldCornersTemp[nt];
            c.vmult(it, it),
            o.vadd(it, it);
            const at = it.x
              , ut = it.y
              , pt = it.z;
            at > _.x && (_.x = at),
            ut > _.y && (_.y = ut),
            pt > _.z && (_.z = pt),
            at < h.x && (h.x = at),
            ut < h.y && (h.y = ut),
            pt < h.z && (h.z = pt)
        }
    }
}
const worldCornerTempPos = new Vec3
  , worldCornersTemp = [new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3]
  , BODY_TYPES = {
    DYNAMIC: 1,
    STATIC: 2,
    KINEMATIC: 4
}
  , BODY_SLEEP_STATES = {
    AWAKE: 0,
    SLEEPY: 1,
    SLEEPING: 2
};
class Body extends EventTarget {
    constructor(o) {
        o === void 0 && (o = {}),
        super(),
        this.id = Body.idCounter++,
        this.index = -1,
        this.world = null,
        this.vlambda = new Vec3,
        this.collisionFilterGroup = typeof o.collisionFilterGroup == "number" ? o.collisionFilterGroup : 1,
        this.collisionFilterMask = typeof o.collisionFilterMask == "number" ? o.collisionFilterMask : -1,
        this.collisionResponse = typeof o.collisionResponse != "boolean" || o.collisionResponse,
        this.position = new Vec3,
        this.previousPosition = new Vec3,
        this.interpolatedPosition = new Vec3,
        this.initPosition = new Vec3,
        o.position && (this.position.copy(o.position),
        this.previousPosition.copy(o.position),
        this.interpolatedPosition.copy(o.position),
        this.initPosition.copy(o.position)),
        this.velocity = new Vec3,
        o.velocity && this.velocity.copy(o.velocity),
        this.initVelocity = new Vec3,
        this.force = new Vec3;
        const c = typeof o.mass == "number" ? o.mass : 0;
        this.mass = c,
        this.invMass = c > 0 ? 1 / c : 0,
        this.material = o.material || null,
        this.linearDamping = typeof o.linearDamping == "number" ? o.linearDamping : .01,
        this.type = c <= 0 ? Body.STATIC : Body.DYNAMIC,
        typeof o.type == typeof Body.STATIC && (this.type = o.type),
        this.allowSleep = o.allowSleep === void 0 || o.allowSleep,
        this.sleepState = Body.AWAKE,
        this.sleepSpeedLimit = o.sleepSpeedLimit !== void 0 ? o.sleepSpeedLimit : .1,
        this.sleepTimeLimit = o.sleepTimeLimit !== void 0 ? o.sleepTimeLimit : 1,
        this.timeLastSleepy = 0,
        this.wakeUpAfterNarrowphase = !1,
        this.torque = new Vec3,
        this.quaternion = new Quaternion,
        this.initQuaternion = new Quaternion,
        this.previousQuaternion = new Quaternion,
        this.interpolatedQuaternion = new Quaternion,
        o.quaternion && (this.quaternion.copy(o.quaternion),
        this.initQuaternion.copy(o.quaternion),
        this.previousQuaternion.copy(o.quaternion),
        this.interpolatedQuaternion.copy(o.quaternion)),
        this.angularVelocity = new Vec3,
        o.angularVelocity && this.angularVelocity.copy(o.angularVelocity),
        this.initAngularVelocity = new Vec3,
        this.shapes = [],
        this.shapeOffsets = [],
        this.shapeOrientations = [],
        this.inertia = new Vec3,
        this.invInertia = new Vec3,
        this.invInertiaWorld = new Mat3,
        this.invMassSolve = 0,
        this.invInertiaSolve = new Vec3,
        this.invInertiaWorldSolve = new Mat3,
        this.fixedRotation = o.fixedRotation !== void 0 && o.fixedRotation,
        this.angularDamping = o.angularDamping !== void 0 ? o.angularDamping : .01,
        this.linearFactor = new Vec3(1,1,1),
        o.linearFactor && this.linearFactor.copy(o.linearFactor),
        this.angularFactor = new Vec3(1,1,1),
        o.angularFactor && this.angularFactor.copy(o.angularFactor),
        this.aabb = new AABB,
        this.aabbNeedsUpdate = !0,
        this.boundingRadius = 0,
        this.wlambda = new Vec3,
        this.isTrigger = !!o.isTrigger,
        o.shape && this.addShape(o.shape),
        this.updateMassProperties()
    }
    wakeUp() {
        const o = this.sleepState;
        this.sleepState = Body.AWAKE,
        this.wakeUpAfterNarrowphase = !1,
        o === Body.SLEEPING && this.dispatchEvent(Body.wakeupEvent)
    }
    sleep() {
        this.sleepState = Body.SLEEPING,
        this.velocity.set(0, 0, 0),
        this.angularVelocity.set(0, 0, 0),
        this.wakeUpAfterNarrowphase = !1
    }
    sleepTick(o) {
        if (this.allowSleep) {
            const c = this.sleepState
              , h = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared()
              , _ = this.sleepSpeedLimit ** 2;
            c === Body.AWAKE && h < _ ? (this.sleepState = Body.SLEEPY,
            this.timeLastSleepy = o,
            this.dispatchEvent(Body.sleepyEvent)) : c === Body.SLEEPY && h > _ ? this.wakeUp() : c === Body.SLEEPY && o - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(),
            this.dispatchEvent(Body.sleepEvent))
        }
    }
    updateSolveMassProperties() {
        this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC ? (this.invMassSolve = 0,
        this.invInertiaSolve.setZero(),
        this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass,
        this.invInertiaSolve.copy(this.invInertia),
        this.invInertiaWorldSolve.copy(this.invInertiaWorld))
    }
    pointToLocalFrame(o, c) {
        return c === void 0 && (c = new Vec3),
        o.vsub(this.position, c),
        this.quaternion.conjugate().vmult(c, c),
        c
    }
    vectorToLocalFrame(o, c) {
        return c === void 0 && (c = new Vec3),
        this.quaternion.conjugate().vmult(o, c),
        c
    }
    pointToWorldFrame(o, c) {
        return c === void 0 && (c = new Vec3),
        this.quaternion.vmult(o, c),
        c.vadd(this.position, c),
        c
    }
    vectorToWorldFrame(o, c) {
        return c === void 0 && (c = new Vec3),
        this.quaternion.vmult(o, c),
        c
    }
    addShape(o, c, h) {
        const _ = new Vec3
          , b = new Quaternion;
        return c && _.copy(c),
        h && b.copy(h),
        this.shapes.push(o),
        this.shapeOffsets.push(_),
        this.shapeOrientations.push(b),
        this.updateMassProperties(),
        this.updateBoundingRadius(),
        this.aabbNeedsUpdate = !0,
        o.body = this,
        this
    }
    removeShape(o) {
        const c = this.shapes.indexOf(o);
        return c === -1 ? (console.warn("Shape does not belong to the body"),
        this) : (this.shapes.splice(c, 1),
        this.shapeOffsets.splice(c, 1),
        this.shapeOrientations.splice(c, 1),
        this.updateMassProperties(),
        this.updateBoundingRadius(),
        this.aabbNeedsUpdate = !0,
        o.body = null,
        this)
    }
    updateBoundingRadius() {
        const o = this.shapes
          , c = this.shapeOffsets
          , h = o.length;
        let _ = 0;
        for (let b = 0; b !== h; b++) {
            const _e = o[b];
            _e.updateBoundingSphereRadius();
            const nt = c[b].length()
              , it = _e.boundingSphereRadius;
            nt + it > _ && (_ = nt + it)
        }
        this.boundingRadius = _
    }
    updateAABB() {
        const o = this.shapes
          , c = this.shapeOffsets
          , h = this.shapeOrientations
          , _ = o.length
          , b = tmpVec
          , _e = tmpQuat
          , nt = this.quaternion
          , it = this.aabb
          , at = updateAABB_shapeAABB;
        for (let ut = 0; ut !== _; ut++) {
            const pt = o[ut];
            nt.vmult(c[ut], b),
            b.vadd(this.position, b),
            nt.mult(h[ut], _e),
            pt.calculateWorldAABB(b, _e, at.lowerBound, at.upperBound),
            ut === 0 ? it.copy(at) : it.extend(at)
        }
        this.aabbNeedsUpdate = !1
    }
    updateInertiaWorld(o) {
        const c = this.invInertia;
        if (c.x !== c.y || c.y !== c.z || o) {
            const h = uiw_m1
              , _ = uiw_m2;
            h.setRotationFromQuaternion(this.quaternion),
            h.transpose(_),
            h.scale(c, h),
            h.mmult(_, this.invInertiaWorld)
        }
    }
    applyForce(o, c) {
        if (c === void 0 && (c = new Vec3),
        this.type !== Body.DYNAMIC)
            return;
        this.sleepState === Body.SLEEPING && this.wakeUp();
        const h = Body_applyForce_rotForce;
        c.cross(o, h),
        this.force.vadd(o, this.force),
        this.torque.vadd(h, this.torque)
    }
    applyLocalForce(o, c) {
        if (c === void 0 && (c = new Vec3),
        this.type !== Body.DYNAMIC)
            return;
        const h = Body_applyLocalForce_worldForce
          , _ = Body_applyLocalForce_relativePointWorld;
        this.vectorToWorldFrame(o, h),
        this.vectorToWorldFrame(c, _),
        this.applyForce(h, _)
    }
    applyTorque(o) {
        this.type === Body.DYNAMIC && (this.sleepState === Body.SLEEPING && this.wakeUp(),
        this.torque.vadd(o, this.torque))
    }
    applyImpulse(o, c) {
        if (c === void 0 && (c = new Vec3),
        this.type !== Body.DYNAMIC)
            return;
        this.sleepState === Body.SLEEPING && this.wakeUp();
        const h = c
          , _ = Body_applyImpulse_velo;
        _.copy(o),
        _.scale(this.invMass, _),
        this.velocity.vadd(_, this.velocity);
        const b = Body_applyImpulse_rotVelo;
        h.cross(o, b),
        this.invInertiaWorld.vmult(b, b),
        this.angularVelocity.vadd(b, this.angularVelocity)
    }
    applyLocalImpulse(o, c) {
        if (c === void 0 && (c = new Vec3),
        this.type !== Body.DYNAMIC)
            return;
        const h = Body_applyLocalImpulse_worldImpulse
          , _ = Body_applyLocalImpulse_relativePoint;
        this.vectorToWorldFrame(o, h),
        this.vectorToWorldFrame(c, _),
        this.applyImpulse(h, _)
    }
    updateMassProperties() {
        const o = Body_updateMassProperties_halfExtents;
        this.invMass = this.mass > 0 ? 1 / this.mass : 0;
        const c = this.inertia
          , h = this.fixedRotation;
        this.updateAABB(),
        o.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2),
        Box.calculateInertia(o, this.mass, c),
        this.invInertia.set(c.x > 0 && !h ? 1 / c.x : 0, c.y > 0 && !h ? 1 / c.y : 0, c.z > 0 && !h ? 1 / c.z : 0),
        this.updateInertiaWorld(!0)
    }
    getVelocityAtWorldPoint(o, c) {
        const h = new Vec3;
        return o.vsub(this.position, h),
        this.angularVelocity.cross(h, c),
        this.velocity.vadd(c, c),
        c
    }
    integrate(o, c, h) {
        if (this.previousPosition.copy(this.position),
        this.previousQuaternion.copy(this.quaternion),
        this.type !== Body.DYNAMIC && this.type !== Body.KINEMATIC || this.sleepState === Body.SLEEPING)
            return;
        const _ = this.velocity
          , b = this.angularVelocity
          , _e = this.position
          , nt = this.force
          , it = this.torque
          , at = this.quaternion
          , ut = this.invMass
          , pt = this.invInertiaWorld
          , ht = this.linearFactor
          , _t = ut * o;
        _.x += nt.x * _t * ht.x,
        _.y += nt.y * _t * ht.y,
        _.z += nt.z * _t * ht.z;
        const vt = pt.elements
          , bt = this.angularFactor
          , St = it.x * bt.x
          , At = it.y * bt.y
          , Et = it.z * bt.z;
        b.x += o * (vt[0] * St + vt[1] * At + vt[2] * Et),
        b.y += o * (vt[3] * St + vt[4] * At + vt[5] * Et),
        b.z += o * (vt[6] * St + vt[7] * At + vt[8] * Et),
        _e.x += _.x * o,
        _e.y += _.y * o,
        _e.z += _.z * o,
        at.integrate(this.angularVelocity, o, this.angularFactor, at),
        c && (h ? at.normalizeFast() : at.normalize()),
        this.aabbNeedsUpdate = !0,
        this.updateInertiaWorld()
    }
}
Body.idCounter = 0,
Body.COLLIDE_EVENT_NAME = "collide",
Body.DYNAMIC = BODY_TYPES.DYNAMIC,
Body.STATIC = BODY_TYPES.STATIC,
Body.KINEMATIC = BODY_TYPES.KINEMATIC,
Body.AWAKE = BODY_SLEEP_STATES.AWAKE,
Body.SLEEPY = BODY_SLEEP_STATES.SLEEPY,
Body.SLEEPING = BODY_SLEEP_STATES.SLEEPING,
Body.wakeupEvent = {
    type: "wakeup"
},
Body.sleepyEvent = {
    type: "sleepy"
},
Body.sleepEvent = {
    type: "sleep"
};
const tmpVec = new Vec3
  , tmpQuat = new Quaternion
  , updateAABB_shapeAABB = new AABB
  , uiw_m1 = new Mat3
  , uiw_m2 = new Mat3;
new Mat3;
const Body_applyForce_rotForce = new Vec3
  , Body_applyLocalForce_worldForce = new Vec3
  , Body_applyLocalForce_relativePointWorld = new Vec3
  , Body_applyImpulse_velo = new Vec3
  , Body_applyImpulse_rotVelo = new Vec3
  , Body_applyLocalImpulse_worldImpulse = new Vec3
  , Body_applyLocalImpulse_relativePoint = new Vec3
  , Body_updateMassProperties_halfExtents = new Vec3;
class Broadphase {
    constructor() {
        this.world = null,
        this.useBoundingBoxes = !1,
        this.dirty = !0
    }
    collisionPairs(o, c, h) {
        throw new Error("collisionPairs not implemented for this BroadPhase class!")
    }
    needBroadphaseCollision(o, c) {
        return !(!(o.collisionFilterGroup & c.collisionFilterMask && c.collisionFilterGroup & o.collisionFilterMask) || (o.type & Body.STATIC || o.sleepState === Body.SLEEPING) && (c.type & Body.STATIC || c.sleepState === Body.SLEEPING))
    }
    intersectionTest(o, c, h, _) {
        this.useBoundingBoxes ? this.doBoundingBoxBroadphase(o, c, h, _) : this.doBoundingSphereBroadphase(o, c, h, _)
    }
    doBoundingSphereBroadphase(o, c, h, _) {
        const b = Broadphase_collisionPairs_r;
        c.position.vsub(o.position, b);
        const _e = (o.boundingRadius + c.boundingRadius) ** 2;
        b.lengthSquared() < _e && (h.push(o),
        _.push(c))
    }
    doBoundingBoxBroadphase(o, c, h, _) {
        o.aabbNeedsUpdate && o.updateAABB(),
        c.aabbNeedsUpdate && c.updateAABB(),
        o.aabb.overlaps(c.aabb) && (h.push(o),
        _.push(c))
    }
    makePairsUnique(o, c) {
        const h = Broadphase_makePairsUnique_temp
          , _ = Broadphase_makePairsUnique_p1
          , b = Broadphase_makePairsUnique_p2
          , _e = o.length;
        for (let nt = 0; nt !== _e; nt++)
            _[nt] = o[nt],
            b[nt] = c[nt];
        o.length = 0,
        c.length = 0;
        for (let nt = 0; nt !== _e; nt++) {
            const it = _[nt].id
              , at = b[nt].id
              , ut = it < at ? `${it},${at}` : `${at},${it}`;
            h[ut] = nt,
            h.keys.push(ut)
        }
        for (let nt = 0; nt !== h.keys.length; nt++) {
            const it = h.keys.pop()
              , at = h[it];
            o.push(_[at]),
            c.push(b[at]),
            delete h[it]
        }
    }
    setWorld(o) {}
    static boundingSphereCheck(o, c) {
        const h = new Vec3;
        o.position.vsub(c.position, h);
        const _ = o.shapes[0]
          , b = c.shapes[0];
        return Math.pow(_.boundingSphereRadius + b.boundingSphereRadius, 2) > h.lengthSquared()
    }
    aabbQuery(o, c, h) {
        return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),
        []
    }
}
const Broadphase_collisionPairs_r = new Vec3;
new Vec3,
new Quaternion,
new Vec3;
const Broadphase_makePairsUnique_temp = {
    keys: []
}
  , Broadphase_makePairsUnique_p1 = []
  , Broadphase_makePairsUnique_p2 = [];
new Vec3;
new Vec3;
new Vec3;
class NaiveBroadphase extends Broadphase {
    constructor() {
        super()
    }
    collisionPairs(o, c, h) {
        const _ = o.bodies
          , b = _.length;
        let _e, nt;
        for (let it = 0; it !== b; it++)
            for (let at = 0; at !== it; at++)
                _e = _[it],
                nt = _[at],
                this.needBroadphaseCollision(_e, nt) && this.intersectionTest(_e, nt, c, h)
    }
    aabbQuery(o, c, h) {
        h === void 0 && (h = []);
        for (let _ = 0; _ < o.bodies.length; _++) {
            const b = o.bodies[_];
            b.aabbNeedsUpdate && b.updateAABB(),
            b.aabb.overlaps(c) && h.push(b)
        }
        return h
    }
}
class RaycastResult {
    constructor() {
        this.rayFromWorld = new Vec3,
        this.rayToWorld = new Vec3,
        this.hitNormalWorld = new Vec3,
        this.hitPointWorld = new Vec3,
        this.hasHit = !1,
        this.shape = null,
        this.body = null,
        this.hitFaceIndex = -1,
        this.distance = -1,
        this.shouldStop = !1
    }
    reset() {
        this.rayFromWorld.setZero(),
        this.rayToWorld.setZero(),
        this.hitNormalWorld.setZero(),
        this.hitPointWorld.setZero(),
        this.hasHit = !1,
        this.shape = null,
        this.body = null,
        this.hitFaceIndex = -1,
        this.distance = -1,
        this.shouldStop = !1
    }
    abort() {
        this.shouldStop = !0
    }
    set(o, c, h, _, b, _e, nt) {
        this.rayFromWorld.copy(o),
        this.rayToWorld.copy(c),
        this.hitNormalWorld.copy(h),
        this.hitPointWorld.copy(_),
        this.shape = b,
        this.body = _e,
        this.distance = nt
    }
}
let _Shape$types$SPHERE, _Shape$types$PLANE, _Shape$types$BOX, _Shape$types$CYLINDER, _Shape$types$CONVEXPO, _Shape$types$HEIGHTFI, _Shape$types$TRIMESH;
const RAY_MODES = {
    CLOSEST: 1,
    ANY: 2,
    ALL: 4
};
_Shape$types$SPHERE = Shape.types.SPHERE,
_Shape$types$PLANE = Shape.types.PLANE,
_Shape$types$BOX = Shape.types.BOX,
_Shape$types$CYLINDER = Shape.types.CYLINDER,
_Shape$types$CONVEXPO = Shape.types.CONVEXPOLYHEDRON,
_Shape$types$HEIGHTFI = Shape.types.HEIGHTFIELD,
_Shape$types$TRIMESH = Shape.types.TRIMESH;
class Ray {
    get[_Shape$types$SPHERE]() {
        return this._intersectSphere
    }
    get[_Shape$types$PLANE]() {
        return this._intersectPlane
    }
    get[_Shape$types$BOX]() {
        return this._intersectBox
    }
    get[_Shape$types$CYLINDER]() {
        return this._intersectConvex
    }
    get[_Shape$types$CONVEXPO]() {
        return this._intersectConvex
    }
    get[_Shape$types$HEIGHTFI]() {
        return this._intersectHeightfield
    }
    get[_Shape$types$TRIMESH]() {
        return this._intersectTrimesh
    }
    constructor(o, c) {
        o === void 0 && (o = new Vec3),
        c === void 0 && (c = new Vec3),
        this.from = o.clone(),
        this.to = c.clone(),
        this.direction = new Vec3,
        this.precision = 1e-4,
        this.checkCollisionResponse = !0,
        this.skipBackfaces = !1,
        this.collisionFilterMask = -1,
        this.collisionFilterGroup = -1,
        this.mode = Ray.ANY,
        this.result = new RaycastResult,
        this.hasHit = !1,
        this.callback = h => {}
    }
    intersectWorld(o, c) {
        return this.mode = c.mode || Ray.ANY,
        this.result = c.result || new RaycastResult,
        this.skipBackfaces = !!c.skipBackfaces,
        this.collisionFilterMask = c.collisionFilterMask !== void 0 ? c.collisionFilterMask : -1,
        this.collisionFilterGroup = c.collisionFilterGroup !== void 0 ? c.collisionFilterGroup : -1,
        this.checkCollisionResponse = c.checkCollisionResponse === void 0 || c.checkCollisionResponse,
        c.from && this.from.copy(c.from),
        c.to && this.to.copy(c.to),
        this.callback = c.callback || ( () => {}
        ),
        this.hasHit = !1,
        this.result.reset(),
        this.updateDirection(),
        this.getAABB(tmpAABB$1),
        tmpArray.length = 0,
        o.broadphase.aabbQuery(o, tmpAABB$1, tmpArray),
        this.intersectBodies(tmpArray),
        this.hasHit
    }
    intersectBody(o, c) {
        c && (this.result = c,
        this.updateDirection());
        const h = this.checkCollisionResponse;
        if (h && !o.collisionResponse || !(this.collisionFilterGroup & o.collisionFilterMask && o.collisionFilterGroup & this.collisionFilterMask))
            return;
        const _ = intersectBody_xi
          , b = intersectBody_qi;
        for (let _e = 0, nt = o.shapes.length; _e < nt; _e++) {
            const it = o.shapes[_e];
            if ((!h || it.collisionResponse) && (o.quaternion.mult(o.shapeOrientations[_e], b),
            o.quaternion.vmult(o.shapeOffsets[_e], _),
            _.vadd(o.position, _),
            this.intersectShape(it, b, _, o),
            this.result.shouldStop))
                break
        }
    }
    intersectBodies(o, c) {
        c && (this.result = c,
        this.updateDirection());
        for (let h = 0, _ = o.length; !this.result.shouldStop && h < _; h++)
            this.intersectBody(o[h])
    }
    updateDirection() {
        this.to.vsub(this.from, this.direction),
        this.direction.normalize()
    }
    intersectShape(o, c, h, _) {
        if (distanceFromIntersection(this.from, this.direction, h) > o.boundingSphereRadius)
            return;
        const b = this[o.type];
        b && b.call(this, o, c, h, _, o)
    }
    _intersectBox(o, c, h, _, b) {
        return this._intersectConvex(o.convexPolyhedronRepresentation, c, h, _, b)
    }
    _intersectPlane(o, c, h, _, b) {
        const _e = this.from
          , nt = this.to
          , it = this.direction
          , at = new Vec3(0,0,1);
        c.vmult(at, at);
        const ut = new Vec3;
        _e.vsub(h, ut);
        const pt = ut.dot(at);
        if (nt.vsub(h, ut),
        pt * ut.dot(at) > 0 || _e.distanceTo(nt) < pt)
            return;
        const ht = at.dot(it);
        if (Math.abs(ht) < this.precision)
            return;
        const _t = new Vec3
          , vt = new Vec3
          , bt = new Vec3;
        _e.vsub(h, _t);
        const St = -at.dot(_t) / ht;
        it.scale(St, vt),
        _e.vadd(vt, bt),
        this.reportIntersection(at, bt, b, _, -1)
    }
    getAABB(o) {
        const {lowerBound: c, upperBound: h} = o
          , _ = this.to
          , b = this.from;
        c.x = Math.min(_.x, b.x),
        c.y = Math.min(_.y, b.y),
        c.z = Math.min(_.z, b.z),
        h.x = Math.max(_.x, b.x),
        h.y = Math.max(_.y, b.y),
        h.z = Math.max(_.z, b.z)
    }
    _intersectHeightfield(o, c, h, _, b) {
        o.data,
        o.elementSize;
        const _e = intersectHeightfield_localRay;
        _e.from.copy(this.from),
        _e.to.copy(this.to),
        cannon_es_Transform.pointToLocalFrame(h, c, _e.from, _e.from),
        cannon_es_Transform.pointToLocalFrame(h, c, _e.to, _e.to),
        _e.updateDirection();
        const nt = intersectHeightfield_index;
        let it, at, ut, pt;
        it = at = 0,
        ut = pt = o.data.length - 1;
        const ht = new AABB;
        _e.getAABB(ht),
        o.getIndexOfPosition(ht.lowerBound.x, ht.lowerBound.y, nt, !0),
        it = Math.max(it, nt[0]),
        at = Math.max(at, nt[1]),
        o.getIndexOfPosition(ht.upperBound.x, ht.upperBound.y, nt, !0),
        ut = Math.min(ut, nt[0] + 1),
        pt = Math.min(pt, nt[1] + 1);
        for (let _t = it; _t < ut; _t++)
            for (let vt = at; vt < pt; vt++) {
                if (this.result.shouldStop)
                    return;
                if (o.getAabbAtIndex(_t, vt, ht),
                ht.overlapsRay(_e)) {
                    if (o.getConvexTrianglePillar(_t, vt, !1),
                    cannon_es_Transform.pointToWorldFrame(h, c, o.pillarOffset, worldPillarOffset),
                    this._intersectConvex(o.pillarConvex, c, worldPillarOffset, _, b, intersectConvexOptions),
                    this.result.shouldStop)
                        return;
                    o.getConvexTrianglePillar(_t, vt, !0),
                    cannon_es_Transform.pointToWorldFrame(h, c, o.pillarOffset, worldPillarOffset),
                    this._intersectConvex(o.pillarConvex, c, worldPillarOffset, _, b, intersectConvexOptions)
                }
            }
    }
    _intersectSphere(o, c, h, _, b) {
        const _e = this.from
          , nt = this.to
          , it = o.radius
          , at = (nt.x - _e.x) ** 2 + (nt.y - _e.y) ** 2 + (nt.z - _e.z) ** 2
          , ut = 2 * ((nt.x - _e.x) * (_e.x - h.x) + (nt.y - _e.y) * (_e.y - h.y) + (nt.z - _e.z) * (_e.z - h.z))
          , pt = ut ** 2 - 4 * at * ((_e.x - h.x) ** 2 + (_e.y - h.y) ** 2 + (_e.z - h.z) ** 2 - it ** 2)
          , ht = Ray_intersectSphere_intersectionPoint
          , _t = Ray_intersectSphere_normal;
        if (!(pt < 0))
            if (pt === 0)
                _e.lerp(nt, pt, ht),
                ht.vsub(h, _t),
                _t.normalize(),
                this.reportIntersection(_t, ht, b, _, -1);
            else {
                const vt = (-ut - Math.sqrt(pt)) / (2 * at)
                  , bt = (-ut + Math.sqrt(pt)) / (2 * at);
                if (vt >= 0 && vt <= 1 && (_e.lerp(nt, vt, ht),
                ht.vsub(h, _t),
                _t.normalize(),
                this.reportIntersection(_t, ht, b, _, -1)),
                this.result.shouldStop)
                    return;
                bt >= 0 && bt <= 1 && (_e.lerp(nt, bt, ht),
                ht.vsub(h, _t),
                _t.normalize(),
                this.reportIntersection(_t, ht, b, _, -1))
            }
    }
    _intersectConvex(o, c, h, _, b, _e) {
        const nt = intersectConvex_normal
          , it = intersectConvex_vector
          , at = _e && _e.faceList || null
          , ut = o.faces
          , pt = o.vertices
          , ht = o.faceNormals
          , _t = this.direction
          , vt = this.from
          , bt = this.to
          , St = vt.distanceTo(bt)
          , At = at ? at.length : ut.length
          , Et = this.result;
        for (let Pt = 0; !Et.shouldStop && Pt < At; Pt++) {
            const It = at ? at[Pt] : Pt
              , Dt = ut[It]
              , Gt = ht[It]
              , Bt = c
              , kt = h;
            it.copy(pt[Dt[0]]),
            Bt.vmult(it, it),
            it.vadd(kt, it),
            it.vsub(vt, it),
            Bt.vmult(Gt, nt);
            const Ut = _t.dot(nt);
            if (Math.abs(Ut) < this.precision)
                continue;
            const Ht = nt.dot(it) / Ut;
            if (!(Ht < 0)) {
                _t.scale(Ht, intersectPoint),
                intersectPoint.vadd(vt, intersectPoint),
                cannon_es_a.copy(pt[Dt[0]]),
                Bt.vmult(cannon_es_a, cannon_es_a),
                kt.vadd(cannon_es_a, cannon_es_a);
                for (let Kt = 1; !Et.shouldStop && Kt < Dt.length - 1; Kt++) {
                    cannon_es_b.copy(pt[Dt[Kt]]),
                    cannon_es_c.copy(pt[Dt[Kt + 1]]),
                    Bt.vmult(cannon_es_b, cannon_es_b),
                    Bt.vmult(cannon_es_c, cannon_es_c),
                    kt.vadd(cannon_es_b, cannon_es_b),
                    kt.vadd(cannon_es_c, cannon_es_c);
                    const Jt = intersectPoint.distanceTo(vt);
                    !Ray.pointInTriangle(intersectPoint, cannon_es_a, cannon_es_b, cannon_es_c) && !Ray.pointInTriangle(intersectPoint, cannon_es_b, cannon_es_a, cannon_es_c) || Jt > St || this.reportIntersection(nt, intersectPoint, b, _, It)
                }
            }
        }
    }
    _intersectTrimesh(o, c, h, _, b, _e) {
        const nt = intersectTrimesh_normal
          , it = intersectTrimesh_triangles
          , at = intersectTrimesh_treeTransform
          , ut = intersectConvex_vector
          , pt = intersectTrimesh_localDirection
          , ht = intersectTrimesh_localFrom
          , _t = intersectTrimesh_localTo
          , vt = intersectTrimesh_worldIntersectPoint
          , bt = intersectTrimesh_worldNormal
          , St = o.indices;
        o.vertices;
        const At = this.from
          , Et = this.to
          , Pt = this.direction;
        at.position.copy(h),
        at.quaternion.copy(c),
        cannon_es_Transform.vectorToLocalFrame(h, c, Pt, pt),
        cannon_es_Transform.pointToLocalFrame(h, c, At, ht),
        cannon_es_Transform.pointToLocalFrame(h, c, Et, _t),
        _t.x *= o.scale.x,
        _t.y *= o.scale.y,
        _t.z *= o.scale.z,
        ht.x *= o.scale.x,
        ht.y *= o.scale.y,
        ht.z *= o.scale.z,
        _t.vsub(ht, pt),
        pt.normalize();
        const It = ht.distanceSquared(_t);
        o.tree.rayQuery(this, at, it);
        for (let Dt = 0, Gt = it.length; !this.result.shouldStop && Dt !== Gt; Dt++) {
            const Bt = it[Dt];
            o.getNormal(Bt, nt),
            o.getVertex(St[3 * Bt], cannon_es_a),
            cannon_es_a.vsub(ht, ut);
            const kt = pt.dot(nt)
              , Ut = nt.dot(ut) / kt;
            if (Ut < 0)
                continue;
            pt.scale(Ut, intersectPoint),
            intersectPoint.vadd(ht, intersectPoint),
            o.getVertex(St[3 * Bt + 1], cannon_es_b),
            o.getVertex(St[3 * Bt + 2], cannon_es_c);
            const Ht = intersectPoint.distanceSquared(ht);
            !Ray.pointInTriangle(intersectPoint, cannon_es_b, cannon_es_a, cannon_es_c) && !Ray.pointInTriangle(intersectPoint, cannon_es_a, cannon_es_b, cannon_es_c) || Ht > It || (cannon_es_Transform.vectorToWorldFrame(c, nt, bt),
            cannon_es_Transform.pointToWorldFrame(h, c, intersectPoint, vt),
            this.reportIntersection(bt, vt, b, _, Bt))
        }
        it.length = 0
    }
    reportIntersection(o, c, h, _, b) {
        const _e = this.from
          , nt = this.to
          , it = _e.distanceTo(c)
          , at = this.result;
        if (!(this.skipBackfaces && o.dot(this.direction) > 0))
            switch (at.hitFaceIndex = b !== void 0 ? b : -1,
            this.mode) {
            case Ray.ALL:
                this.hasHit = !0,
                at.set(_e, nt, o, c, h, _, it),
                at.hasHit = !0,
                this.callback(at);
                break;
            case Ray.CLOSEST:
                (it < at.distance || !at.hasHit) && (this.hasHit = !0,
                at.hasHit = !0,
                at.set(_e, nt, o, c, h, _, it));
                break;
            case Ray.ANY:
                this.hasHit = !0,
                at.hasHit = !0,
                at.set(_e, nt, o, c, h, _, it),
                at.shouldStop = !0
            }
    }
    static pointInTriangle(o, c, h, _) {
        _.vsub(c, v0),
        h.vsub(c, v1),
        o.vsub(c, v2);
        const b = v0.dot(v0)
          , _e = v0.dot(v1)
          , nt = v0.dot(v2)
          , it = v1.dot(v1)
          , at = v1.dot(v2);
        let ut, pt;
        return (ut = it * nt - _e * at) >= 0 && (pt = b * at - _e * nt) >= 0 && ut + pt < b * it - _e * _e
    }
}
Ray.CLOSEST = RAY_MODES.CLOSEST,
Ray.ANY = RAY_MODES.ANY,
Ray.ALL = RAY_MODES.ALL;
const tmpAABB$1 = new AABB
  , tmpArray = []
  , v1 = new Vec3
  , v2 = new Vec3
  , intersectBody_xi = new Vec3
  , intersectBody_qi = new Quaternion
  , intersectPoint = new Vec3
  , cannon_es_a = new Vec3
  , cannon_es_b = new Vec3
  , cannon_es_c = new Vec3;
new Vec3,
new RaycastResult;
const intersectConvexOptions = {
    faceList: [0]
}
  , worldPillarOffset = new Vec3
  , intersectHeightfield_localRay = new Ray
  , intersectHeightfield_index = []
  , Ray_intersectSphere_intersectionPoint = new Vec3
  , Ray_intersectSphere_normal = new Vec3
  , intersectConvex_normal = new Vec3;
new Vec3;
new Vec3;
const intersectConvex_vector = new Vec3
  , intersectTrimesh_normal = new Vec3
  , intersectTrimesh_localDirection = new Vec3
  , intersectTrimesh_localFrom = new Vec3
  , intersectTrimesh_localTo = new Vec3
  , intersectTrimesh_worldNormal = new Vec3
  , intersectTrimesh_worldIntersectPoint = new Vec3;
new AABB;
const intersectTrimesh_triangles = []
  , intersectTrimesh_treeTransform = new cannon_es_Transform
  , v0 = new Vec3
  , intersect = new Vec3;
function distanceFromIntersection(d, o, c) {
    c.vsub(d, v0);
    const h = v0.dot(o);
    return o.scale(h, intersect),
    intersect.vadd(d, intersect),
    c.distanceTo(intersect)
}
class Utils {
    static defaults(o, c) {
        o === void 0 && (o = {});
        for (let h in c)
            h in o || (o[h] = c[h]);
        return o
    }
}
class Constraint {
    constructor(o, c, h) {
        h === void 0 && (h = {}),
        h = Utils.defaults(h, {
            collideConnected: !0,
            wakeUpBodies: !0
        }),
        this.equations = [],
        this.bodyA = o,
        this.bodyB = c,
        this.id = Constraint.idCounter++,
        this.collideConnected = h.collideConnected,
        h.wakeUpBodies && (o && o.wakeUp(),
        c && c.wakeUp())
    }
    update() {
        throw new Error("method update() not implmemented in this Constraint subclass!")
    }
    enable() {
        const o = this.equations;
        for (let c = 0; c < o.length; c++)
            o[c].enabled = !0
    }
    disable() {
        const o = this.equations;
        for (let c = 0; c < o.length; c++)
            o[c].enabled = !1
    }
}
Constraint.idCounter = 0;
class JacobianElement {
    constructor() {
        this.spatial = new Vec3,
        this.rotational = new Vec3
    }
    multiplyElement(o) {
        return o.spatial.dot(this.spatial) + o.rotational.dot(this.rotational)
    }
    multiplyVectors(o, c) {
        return o.dot(this.spatial) + c.dot(this.rotational)
    }
}
class Equation {
    constructor(o, c, h, _) {
        h === void 0 && (h = -1e6),
        _ === void 0 && (_ = 1e6),
        this.id = Equation.idCounter++,
        this.minForce = h,
        this.maxForce = _,
        this.bi = o,
        this.bj = c,
        this.a = 0,
        this.b = 0,
        this.eps = 0,
        this.jacobianElementA = new JacobianElement,
        this.jacobianElementB = new JacobianElement,
        this.enabled = !0,
        this.multiplier = 0,
        this.setSpookParams(1e7, 4, 1 / 60)
    }
    setSpookParams(o, c, h) {
        const _ = c
          , b = o
          , _e = h;
        this.a = 4 / (_e * (1 + 4 * _)),
        this.b = 4 * _ / (1 + 4 * _),
        this.eps = 4 / (_e * _e * b * (1 + 4 * _))
    }
    computeB(o, c, h) {
        const _ = this.computeGW();
        return -this.computeGq() * o - _ * c - this.computeGiMf() * h
    }
    computeGq() {
        const o = this.jacobianElementA
          , c = this.jacobianElementB
          , h = this.bi
          , _ = this.bj
          , b = h.position
          , _e = _.position;
        return o.spatial.dot(b) + c.spatial.dot(_e)
    }
    computeGW() {
        const o = this.jacobianElementA
          , c = this.jacobianElementB
          , h = this.bi
          , _ = this.bj
          , b = h.velocity
          , _e = _.velocity
          , nt = h.angularVelocity
          , it = _.angularVelocity;
        return o.multiplyVectors(b, nt) + c.multiplyVectors(_e, it)
    }
    computeGWlambda() {
        const o = this.jacobianElementA
          , c = this.jacobianElementB
          , h = this.bi
          , _ = this.bj
          , b = h.vlambda
          , _e = _.vlambda
          , nt = h.wlambda
          , it = _.wlambda;
        return o.multiplyVectors(b, nt) + c.multiplyVectors(_e, it)
    }
    computeGiMf() {
        const o = this.jacobianElementA
          , c = this.jacobianElementB
          , h = this.bi
          , _ = this.bj
          , b = h.force
          , _e = h.torque
          , nt = _.force
          , it = _.torque
          , at = h.invMassSolve
          , ut = _.invMassSolve;
        return b.scale(at, iMfi),
        nt.scale(ut, iMfj),
        h.invInertiaWorldSolve.vmult(_e, invIi_vmult_taui),
        _.invInertiaWorldSolve.vmult(it, invIj_vmult_tauj),
        o.multiplyVectors(iMfi, invIi_vmult_taui) + c.multiplyVectors(iMfj, invIj_vmult_tauj)
    }
    computeGiMGt() {
        const o = this.jacobianElementA
          , c = this.jacobianElementB
          , h = this.bi
          , _ = this.bj
          , b = h.invMassSolve
          , _e = _.invMassSolve
          , nt = h.invInertiaWorldSolve
          , it = _.invInertiaWorldSolve;
        let at = b + _e;
        return nt.vmult(o.rotational, tmp),
        at += tmp.dot(o.rotational),
        it.vmult(c.rotational, tmp),
        at += tmp.dot(c.rotational),
        at
    }
    addToWlambda(o) {
        const c = this.jacobianElementA
          , h = this.jacobianElementB
          , _ = this.bi
          , b = this.bj
          , _e = addToWlambda_temp;
        _.vlambda.addScaledVector(_.invMassSolve * o, c.spatial, _.vlambda),
        b.vlambda.addScaledVector(b.invMassSolve * o, h.spatial, b.vlambda),
        _.invInertiaWorldSolve.vmult(c.rotational, _e),
        _.wlambda.addScaledVector(o, _e, _.wlambda),
        b.invInertiaWorldSolve.vmult(h.rotational, _e),
        b.wlambda.addScaledVector(o, _e, b.wlambda)
    }
    computeC() {
        return this.computeGiMGt() + this.eps
    }
}
Equation.idCounter = 0;
const iMfi = new Vec3
  , iMfj = new Vec3
  , invIi_vmult_taui = new Vec3
  , invIj_vmult_tauj = new Vec3
  , tmp = new Vec3
  , addToWlambda_temp = new Vec3;
class ContactEquation extends Equation {
    constructor(o, c, h) {
        h === void 0 && (h = 1e6),
        super(o, c, 0, h),
        this.restitution = 0,
        this.ri = new Vec3,
        this.rj = new Vec3,
        this.ni = new Vec3
    }
    computeB(o) {
        const c = this.a
          , h = this.b
          , _ = this.bi
          , b = this.bj
          , _e = this.ri
          , nt = this.rj
          , it = ContactEquation_computeB_temp1
          , at = ContactEquation_computeB_temp2
          , ut = _.velocity
          , pt = _.angularVelocity;
        _.force,
        _.torque;
        const ht = b.velocity
          , _t = b.angularVelocity;
        b.force,
        b.torque;
        const vt = ContactEquation_computeB_temp3
          , bt = this.jacobianElementA
          , St = this.jacobianElementB
          , At = this.ni;
        _e.cross(At, it),
        nt.cross(At, at),
        At.negate(bt.spatial),
        it.negate(bt.rotational),
        St.spatial.copy(At),
        St.rotational.copy(at),
        vt.copy(b.position),
        vt.vadd(nt, vt),
        vt.vsub(_.position, vt),
        vt.vsub(_e, vt);
        const Et = At.dot(vt)
          , Pt = this.restitution + 1;
        return -Et * c - (Pt * ht.dot(At) - Pt * ut.dot(At) + _t.dot(at) - pt.dot(it)) * h - o * this.computeGiMf()
    }
    getImpactVelocityAlongNormal() {
        const o = ContactEquation_getImpactVelocityAlongNormal_vi
          , c = ContactEquation_getImpactVelocityAlongNormal_vj
          , h = ContactEquation_getImpactVelocityAlongNormal_xi
          , _ = ContactEquation_getImpactVelocityAlongNormal_xj
          , b = ContactEquation_getImpactVelocityAlongNormal_relVel;
        return this.bi.position.vadd(this.ri, h),
        this.bj.position.vadd(this.rj, _),
        this.bi.getVelocityAtWorldPoint(h, o),
        this.bj.getVelocityAtWorldPoint(_, c),
        o.vsub(c, b),
        this.ni.dot(b)
    }
}
const ContactEquation_computeB_temp1 = new Vec3
  , ContactEquation_computeB_temp2 = new Vec3
  , ContactEquation_computeB_temp3 = new Vec3
  , ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3
  , ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3
  , ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3
  , ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3
  , ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3;
class PointToPointConstraint extends Constraint {
    constructor(o, c, h, _, b) {
        c === void 0 && (c = new Vec3),
        _ === void 0 && (_ = new Vec3),
        b === void 0 && (b = 1e6),
        super(o, h),
        this.pivotA = c.clone(),
        this.pivotB = _.clone();
        const _e = this.equationX = new ContactEquation(o,h)
          , nt = this.equationY = new ContactEquation(o,h)
          , it = this.equationZ = new ContactEquation(o,h);
        this.equations.push(_e, nt, it),
        _e.minForce = nt.minForce = it.minForce = -b,
        _e.maxForce = nt.maxForce = it.maxForce = b,
        _e.ni.set(1, 0, 0),
        nt.ni.set(0, 1, 0),
        it.ni.set(0, 0, 1)
    }
    update() {
        const o = this.bodyA
          , c = this.bodyB
          , h = this.equationX
          , _ = this.equationY
          , b = this.equationZ;
        o.quaternion.vmult(this.pivotA, h.ri),
        c.quaternion.vmult(this.pivotB, h.rj),
        _.ri.copy(h.ri),
        _.rj.copy(h.rj),
        b.ri.copy(h.ri),
        b.rj.copy(h.rj)
    }
}
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3,
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
class FrictionEquation extends Equation {
    constructor(o, c, h) {
        super(o, c, -h, h),
        this.ri = new Vec3,
        this.rj = new Vec3,
        this.t = new Vec3
    }
    computeB(o) {
        this.a;
        const c = this.b;
        this.bi,
        this.bj;
        const h = this.ri
          , _ = this.rj
          , b = FrictionEquation_computeB_temp1
          , _e = FrictionEquation_computeB_temp2
          , nt = this.t;
        h.cross(nt, b),
        _.cross(nt, _e);
        const it = this.jacobianElementA
          , at = this.jacobianElementB;
        return nt.negate(it.spatial),
        b.negate(it.rotational),
        at.spatial.copy(nt),
        at.rotational.copy(_e),
        -this.computeGW() * c - o * this.computeGiMf()
    }
}
const FrictionEquation_computeB_temp1 = new Vec3
  , FrictionEquation_computeB_temp2 = new Vec3;
class ContactMaterial {
    constructor(o, c, h) {
        h = Utils.defaults(h, {
            friction: .3,
            restitution: .3,
            contactEquationStiffness: 1e7,
            contactEquationRelaxation: 3,
            frictionEquationStiffness: 1e7,
            frictionEquationRelaxation: 3
        }),
        this.id = ContactMaterial.idCounter++,
        this.materials = [o, c],
        this.friction = h.friction,
        this.restitution = h.restitution,
        this.contactEquationStiffness = h.contactEquationStiffness,
        this.contactEquationRelaxation = h.contactEquationRelaxation,
        this.frictionEquationStiffness = h.frictionEquationStiffness,
        this.frictionEquationRelaxation = h.frictionEquationRelaxation
    }
}
ContactMaterial.idCounter = 0;
class cannon_es_Material {
    constructor(o) {
        o === void 0 && (o = {});
        let c = "";
        typeof o == "string" && (c = o,
        o = {}),
        this.name = c,
        this.id = cannon_es_Material.idCounter++,
        this.friction = o.friction !== void 0 ? o.friction : -1,
        this.restitution = o.restitution !== void 0 ? o.restitution : -1
    }
}
cannon_es_Material.idCounter = 0;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3,
new Vec3,
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Ray,
new Vec3;
new Vec3;
new Vec3;
new Vec3(1,0,0),
new Vec3(0,1,0),
new Vec3(0,0,1);
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
class Sphere extends Shape {
    constructor(o) {
        if (super({
            type: Shape.types.SPHERE
        }),
        this.radius = o !== void 0 ? o : 1,
        this.radius < 0)
            throw new Error("The sphere radius cannot be negative.");
        this.updateBoundingSphereRadius()
    }
    calculateLocalInertia(o, c) {
        c === void 0 && (c = new Vec3);
        const h = 2 * o * this.radius * this.radius / 5;
        return c.x = h,
        c.y = h,
        c.z = h,
        c
    }
    volume() {
        return 4 * Math.PI * Math.pow(this.radius, 3) / 3
    }
    updateBoundingSphereRadius() {
        this.boundingSphereRadius = this.radius
    }
    calculateWorldAABB(o, c, h, _) {
        const b = this.radius
          , _e = ["x", "y", "z"];
        for (let nt = 0; nt < _e.length; nt++) {
            const it = _e[nt];
            h[it] = o[it] - b,
            _[it] = o[it] + b
        }
    }
}
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
class Cylinder extends ConvexPolyhedron {
    constructor(o, c, h, _) {
        if (o === void 0 && (o = 1),
        c === void 0 && (c = 1),
        h === void 0 && (h = 1),
        _ === void 0 && (_ = 8),
        o < 0)
            throw new Error("The cylinder radiusTop cannot be negative.");
        if (c < 0)
            throw new Error("The cylinder radiusBottom cannot be negative.");
        const b = _
          , _e = []
          , nt = []
          , it = []
          , at = []
          , ut = []
          , pt = Math.cos
          , ht = Math.sin;
        _e.push(new Vec3(-c * ht(0),.5 * -h,c * pt(0))),
        at.push(0),
        _e.push(new Vec3(-o * ht(0),.5 * h,o * pt(0))),
        ut.push(1);
        for (let vt = 0; vt < b; vt++) {
            const bt = 2 * Math.PI / b * (vt + 1)
              , St = 2 * Math.PI / b * (vt + .5);
            vt < b - 1 ? (_e.push(new Vec3(-c * ht(bt),.5 * -h,c * pt(bt))),
            at.push(2 * vt + 2),
            _e.push(new Vec3(-o * ht(bt),.5 * h,o * pt(bt))),
            ut.push(2 * vt + 3),
            it.push([2 * vt, 2 * vt + 1, 2 * vt + 3, 2 * vt + 2])) : it.push([2 * vt, 2 * vt + 1, 1, 0]),
            (b % 2 == 1 || vt < b / 2) && nt.push(new Vec3(-ht(St),0,pt(St)))
        }
        it.push(at),
        nt.push(new Vec3(0,1,0));
        const _t = [];
        for (let vt = 0; vt < ut.length; vt++)
            _t.push(ut[ut.length - vt - 1]);
        it.push(_t),
        super({
            vertices: _e,
            faces: it,
            axes: nt
        }),
        this.type = Shape.types.CYLINDER,
        this.radiusTop = o,
        this.radiusBottom = c,
        this.height = h,
        this.numSegments = _
    }
}
class cannon_es_Plane extends Shape {
    constructor() {
        super({
            type: Shape.types.PLANE
        }),
        this.worldNormal = new Vec3,
        this.worldNormalNeedsUpdate = !0,
        this.boundingSphereRadius = Number.MAX_VALUE
    }
    computeWorldNormal(o) {
        const c = this.worldNormal;
        c.set(0, 0, 1),
        o.vmult(c, c),
        this.worldNormalNeedsUpdate = !1
    }
    calculateLocalInertia(o, c) {
        return c === void 0 && (c = new Vec3),
        c
    }
    volume() {
        return Number.MAX_VALUE
    }
    calculateWorldAABB(o, c, h, _) {
        tempNormal.set(0, 0, 1),
        c.vmult(tempNormal, tempNormal);
        const b = Number.MAX_VALUE;
        h.set(-b, -b, -b),
        _.set(b, b, b),
        tempNormal.x === 1 ? _.x = o.x : tempNormal.x === -1 && (h.x = o.x),
        tempNormal.y === 1 ? _.y = o.y : tempNormal.y === -1 && (h.y = o.y),
        tempNormal.z === 1 ? _.z = o.z : tempNormal.z === -1 && (h.z = o.z)
    }
    updateBoundingSphereRadius() {
        this.boundingSphereRadius = Number.MAX_VALUE
    }
}
const tempNormal = new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
new Vec3;
class OctreeNode {
    constructor(o) {
        o === void 0 && (o = {}),
        this.root = o.root || null,
        this.aabb = o.aabb ? o.aabb.clone() : new AABB,
        this.data = [],
        this.children = []
    }
    reset() {
        this.children.length = this.data.length = 0
    }
    insert(o, c, h) {
        h === void 0 && (h = 0);
        const _ = this.data;
        if (!this.aabb.contains(o))
            return !1;
        const b = this.children;
        if (h < (this.maxDepth || this.root.maxDepth)) {
            let _e = !1;
            b.length || (this.subdivide(),
            _e = !0);
            for (let nt = 0; nt !== 8; nt++)
                if (b[nt].insert(o, c, h + 1))
                    return !0;
            _e && (b.length = 0)
        }
        return _.push(c),
        !0
    }
    subdivide() {
        const o = this.aabb
          , c = o.lowerBound
          , h = o.upperBound
          , _ = this.children;
        _.push(new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(0,0,0)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(1,0,0)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(1,1,0)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(1,1,1)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(0,1,1)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(0,0,1)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(1,0,1)
            })
        }), new OctreeNode({
            aabb: new AABB({
                lowerBound: new Vec3(0,1,0)
            })
        })),
        h.vsub(c, halfDiagonal),
        halfDiagonal.scale(.5, halfDiagonal);
        const b = this.root || this;
        for (let _e = 0; _e !== 8; _e++) {
            const nt = _[_e];
            nt.root = b;
            const it = nt.aabb.lowerBound;
            it.x *= halfDiagonal.x,
            it.y *= halfDiagonal.y,
            it.z *= halfDiagonal.z,
            it.vadd(c, it),
            it.vadd(halfDiagonal, nt.aabb.upperBound)
        }
    }
    aabbQuery(o, c) {
        this.data,
        this.children;
        const h = [this];
        for (; h.length; ) {
            const _ = h.pop();
            _.aabb.overlaps(o) && Array.prototype.push.apply(c, _.data),
            Array.prototype.push.apply(h, _.children)
        }
        return c
    }
    rayQuery(o, c, h) {
        return o.getAABB(tmpAABB),
        tmpAABB.toLocalFrame(c, tmpAABB),
        this.aabbQuery(tmpAABB, h),
        h
    }
    removeEmptyNodes() {
        for (let o = this.children.length - 1; o >= 0; o--)
            this.children[o].removeEmptyNodes(),
            this.children[o].children.length || this.children[o].data.length || this.children.splice(o, 1)
    }
}
class Octree extends OctreeNode {
    constructor(o, c) {
        c === void 0 && (c = {}),
        super({
            root: null,
            aabb: o
        }),
        this.maxDepth = c.maxDepth !== void 0 ? c.maxDepth : 8
    }
}
const halfDiagonal = new Vec3
  , tmpAABB = new AABB;
class Trimesh extends Shape {
    constructor(o, c) {
        super({
            type: Shape.types.TRIMESH
        }),
        this.vertices = new Float32Array(o),
        this.indices = new Int16Array(c),
        this.normals = new Float32Array(c.length),
        this.aabb = new AABB,
        this.edges = null,
        this.scale = new Vec3(1,1,1),
        this.tree = new Octree,
        this.updateEdges(),
        this.updateNormals(),
        this.updateAABB(),
        this.updateBoundingSphereRadius(),
        this.updateTree()
    }
    updateTree() {
        const o = this.tree;
        o.reset(),
        o.aabb.copy(this.aabb);
        const c = this.scale;
        o.aabb.lowerBound.x *= 1 / c.x,
        o.aabb.lowerBound.y *= 1 / c.y,
        o.aabb.lowerBound.z *= 1 / c.z,
        o.aabb.upperBound.x *= 1 / c.x,
        o.aabb.upperBound.y *= 1 / c.y,
        o.aabb.upperBound.z *= 1 / c.z;
        const h = new AABB
          , _ = new Vec3
          , b = new Vec3
          , _e = new Vec3
          , nt = [_, b, _e];
        for (let it = 0; it < this.indices.length / 3; it++) {
            const at = 3 * it;
            this._getUnscaledVertex(this.indices[at], _),
            this._getUnscaledVertex(this.indices[at + 1], b),
            this._getUnscaledVertex(this.indices[at + 2], _e),
            h.setFromPoints(nt),
            o.insert(h, it)
        }
        o.removeEmptyNodes()
    }
    getTrianglesInAABB(o, c) {
        unscaledAABB.copy(o);
        const h = this.scale
          , _ = h.x
          , b = h.y
          , _e = h.z
          , nt = unscaledAABB.lowerBound
          , it = unscaledAABB.upperBound;
        return nt.x /= _,
        nt.y /= b,
        nt.z /= _e,
        it.x /= _,
        it.y /= b,
        it.z /= _e,
        this.tree.aabbQuery(unscaledAABB, c)
    }
    setScale(o) {
        const c = this.scale.x === this.scale.y && this.scale.y === this.scale.z
          , h = o.x === o.y && o.y === o.z;
        c && h || this.updateNormals(),
        this.scale.copy(o),
        this.updateAABB(),
        this.updateBoundingSphereRadius()
    }
    updateNormals() {
        const o = computeNormals_n
          , c = this.normals;
        for (let h = 0; h < this.indices.length / 3; h++) {
            const _ = 3 * h
              , b = this.indices[_]
              , _e = this.indices[_ + 1]
              , nt = this.indices[_ + 2];
            this.getVertex(b, va$1),
            this.getVertex(_e, vb$1),
            this.getVertex(nt, vc$1),
            Trimesh.computeNormal(vb$1, va$1, vc$1, o),
            c[_] = o.x,
            c[_ + 1] = o.y,
            c[_ + 2] = o.z
        }
    }
    updateEdges() {
        const o = {}
          , c = (_, b) => {
            o[_ < b ? `${_}_${b}` : `${b}_${_}`] = !0
        }
        ;
        for (let _ = 0; _ < this.indices.length / 3; _++) {
            const b = 3 * _
              , _e = this.indices[b]
              , nt = this.indices[b + 1]
              , it = this.indices[b + 2];
            c(_e, nt),
            c(nt, it),
            c(it, _e)
        }
        const h = Object.keys(o);
        this.edges = new Int16Array(2 * h.length);
        for (let _ = 0; _ < h.length; _++) {
            const b = h[_].split("_");
            this.edges[2 * _] = parseInt(b[0], 10),
            this.edges[2 * _ + 1] = parseInt(b[1], 10)
        }
    }
    getEdgeVertex(o, c, h) {
        const _ = this.edges[2 * o + (c ? 1 : 0)];
        this.getVertex(_, h)
    }
    getEdgeVector(o, c) {
        const h = getEdgeVector_va
          , _ = getEdgeVector_vb;
        this.getEdgeVertex(o, 0, h),
        this.getEdgeVertex(o, 1, _),
        _.vsub(h, c)
    }
    static computeNormal(o, c, h, _) {
        c.vsub(o, ab$1),
        h.vsub(c, cannon_es_cb),
        cannon_es_cb.cross(ab$1, _),
        _.isZero() || _.normalize()
    }
    getVertex(o, c) {
        const h = this.scale;
        return this._getUnscaledVertex(o, c),
        c.x *= h.x,
        c.y *= h.y,
        c.z *= h.z,
        c
    }
    _getUnscaledVertex(o, c) {
        const h = 3 * o
          , _ = this.vertices;
        return c.set(_[h], _[h + 1], _[h + 2])
    }
    getWorldVertex(o, c, h, _) {
        return this.getVertex(o, _),
        cannon_es_Transform.pointToWorldFrame(c, h, _, _),
        _
    }
    getTriangleVertices(o, c, h, _) {
        const b = 3 * o;
        this.getVertex(this.indices[b], c),
        this.getVertex(this.indices[b + 1], h),
        this.getVertex(this.indices[b + 2], _)
    }
    getNormal(o, c) {
        const h = 3 * o;
        return c.set(this.normals[h], this.normals[h + 1], this.normals[h + 2])
    }
    calculateLocalInertia(o, c) {
        this.computeLocalAABB(cli_aabb);
        const h = cli_aabb.upperBound.x - cli_aabb.lowerBound.x
          , _ = cli_aabb.upperBound.y - cli_aabb.lowerBound.y
          , b = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
        return c.set(1 / 12 * o * (2 * _ * 2 * _ + 2 * b * 2 * b), 1 / 12 * o * (2 * h * 2 * h + 2 * b * 2 * b), 1 / 12 * o * (2 * _ * 2 * _ + 2 * h * 2 * h))
    }
    computeLocalAABB(o) {
        const c = o.lowerBound
          , h = o.upperBound
          , _ = this.vertices.length;
        this.vertices;
        const b = computeLocalAABB_worldVert;
        this.getVertex(0, b),
        c.copy(b),
        h.copy(b);
        for (let _e = 0; _e !== _; _e++)
            this.getVertex(_e, b),
            b.x < c.x ? c.x = b.x : b.x > h.x && (h.x = b.x),
            b.y < c.y ? c.y = b.y : b.y > h.y && (h.y = b.y),
            b.z < c.z ? c.z = b.z : b.z > h.z && (h.z = b.z)
    }
    updateAABB() {
        this.computeLocalAABB(this.aabb)
    }
    updateBoundingSphereRadius() {
        let o = 0;
        const c = this.vertices
          , h = new Vec3;
        for (let _ = 0, b = c.length / 3; _ !== b; _++) {
            this.getVertex(_, h);
            const _e = h.lengthSquared();
            _e > o && (o = _e)
        }
        this.boundingSphereRadius = Math.sqrt(o)
    }
    calculateWorldAABB(o, c, h, _) {
        const b = calculateWorldAABB_frame
          , _e = calculateWorldAABB_aabb;
        b.position = o,
        b.quaternion = c,
        this.aabb.toWorldFrame(b, _e),
        h.copy(_e.lowerBound),
        _.copy(_e.upperBound)
    }
    volume() {
        return 4 * Math.PI * this.boundingSphereRadius / 3
    }
    static createTorus(o, c, h, _, b) {
        o === void 0 && (o = 1),
        c === void 0 && (c = .5),
        h === void 0 && (h = 8),
        _ === void 0 && (_ = 6),
        b === void 0 && (b = 2 * Math.PI);
        const _e = []
          , nt = [];
        for (let it = 0; it <= h; it++)
            for (let at = 0; at <= _; at++) {
                const ut = at / _ * b
                  , pt = it / h * Math.PI * 2
                  , ht = (o + c * Math.cos(pt)) * Math.cos(ut)
                  , _t = (o + c * Math.cos(pt)) * Math.sin(ut)
                  , vt = c * Math.sin(pt);
                _e.push(ht, _t, vt)
            }
        for (let it = 1; it <= h; it++)
            for (let at = 1; at <= _; at++) {
                const ut = (_ + 1) * it + at - 1
                  , pt = (_ + 1) * (it - 1) + at - 1
                  , ht = (_ + 1) * (it - 1) + at
                  , _t = (_ + 1) * it + at;
                nt.push(ut, pt, _t),
                nt.push(pt, ht, _t)
            }
        return new Trimesh(_e,nt)
    }
}
const computeNormals_n = new Vec3
  , unscaledAABB = new AABB
  , getEdgeVector_va = new Vec3
  , getEdgeVector_vb = new Vec3
  , cannon_es_cb = new Vec3
  , ab$1 = new Vec3
  , va$1 = new Vec3
  , vb$1 = new Vec3
  , vc$1 = new Vec3
  , cli_aabb = new AABB
  , computeLocalAABB_worldVert = new Vec3
  , calculateWorldAABB_frame = new cannon_es_Transform
  , calculateWorldAABB_aabb = new AABB;
class Solver {
    constructor() {
        this.equations = []
    }
    solve(o, c) {
        return 0
    }
    addEquation(o) {
        !o.enabled || o.bi.isTrigger || o.bj.isTrigger || this.equations.push(o)
    }
    removeEquation(o) {
        const c = this.equations
          , h = c.indexOf(o);
        h !== -1 && c.splice(h, 1)
    }
    removeAllEquations() {
        this.equations.length = 0
    }
}
class GSSolver extends Solver {
    constructor() {
        super(),
        this.iterations = 10,
        this.tolerance = 1e-7
    }
    solve(o, c) {
        let h = 0;
        const _ = this.iterations
          , b = this.tolerance * this.tolerance
          , _e = this.equations
          , nt = _e.length
          , it = c.bodies
          , at = it.length
          , ut = o;
        let pt, ht, _t, vt, bt, St;
        if (nt !== 0)
            for (let It = 0; It !== at; It++)
                it[It].updateSolveMassProperties();
        const At = GSSolver_solve_invCs
          , Et = GSSolver_solve_Bs
          , Pt = GSSolver_solve_lambda;
        At.length = nt,
        Et.length = nt,
        Pt.length = nt;
        for (let It = 0; It !== nt; It++) {
            const Dt = _e[It];
            Pt[It] = 0,
            Et[It] = Dt.computeB(ut),
            At[It] = 1 / Dt.computeC()
        }
        if (nt !== 0) {
            for (let Gt = 0; Gt !== at; Gt++) {
                const Bt = it[Gt]
                  , kt = Bt.vlambda
                  , Ut = Bt.wlambda;
                kt.set(0, 0, 0),
                Ut.set(0, 0, 0)
            }
            for (h = 0; h !== _; h++) {
                vt = 0;
                for (let Gt = 0; Gt !== nt; Gt++) {
                    const Bt = _e[Gt];
                    pt = Et[Gt],
                    ht = At[Gt],
                    St = Pt[Gt],
                    bt = Bt.computeGWlambda(),
                    _t = ht * (pt - bt - Bt.eps * St),
                    St + _t < Bt.minForce ? _t = Bt.minForce - St : St + _t > Bt.maxForce && (_t = Bt.maxForce - St),
                    Pt[Gt] += _t,
                    vt += _t > 0 ? _t : -_t,
                    Bt.addToWlambda(_t)
                }
                if (vt * vt < b)
                    break
            }
            for (let Gt = 0; Gt !== at; Gt++) {
                const Bt = it[Gt]
                  , kt = Bt.velocity
                  , Ut = Bt.angularVelocity;
                Bt.vlambda.vmul(Bt.linearFactor, Bt.vlambda),
                kt.vadd(Bt.vlambda, kt),
                Bt.wlambda.vmul(Bt.angularFactor, Bt.wlambda),
                Ut.vadd(Bt.wlambda, Ut)
            }
            let It = _e.length;
            const Dt = 1 / ut;
            for (; It--; )
                _e[It].multiplier = Pt[It] * Dt
        }
        return h
    }
}
const GSSolver_solve_lambda = []
  , GSSolver_solve_invCs = []
  , GSSolver_solve_Bs = [];
Body.STATIC;
class Pool {
    constructor() {
        this.objects = [],
        this.type = Object
    }
    release() {
        const o = arguments.length;
        for (let c = 0; c !== o; c++)
            this.objects.push(c < 0 || arguments.length <= c ? void 0 : arguments[c]);
        return this
    }
    get() {
        return this.objects.length === 0 ? this.constructObject() : this.objects.pop()
    }
    constructObject() {
        throw new Error("constructObject() not implemented in this Pool subclass yet!")
    }
    resize(o) {
        const c = this.objects;
        for (; c.length > o; )
            c.pop();
        for (; c.length < o; )
            c.push(this.constructObject());
        return this
    }
}
class Vec3Pool extends Pool {
    constructor() {
        super(...arguments),
        this.type = Vec3
    }
    constructObject() {
        return new Vec3
    }
}
const COLLISION_TYPES = {
    sphereSphere: Shape.types.SPHERE,
    spherePlane: Shape.types.SPHERE | Shape.types.PLANE,
    boxBox: Shape.types.BOX | Shape.types.BOX,
    sphereBox: Shape.types.SPHERE | Shape.types.BOX,
    planeBox: Shape.types.PLANE | Shape.types.BOX,
    convexConvex: Shape.types.CONVEXPOLYHEDRON,
    sphereConvex: Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON,
    planeConvex: Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON,
    boxConvex: Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON,
    sphereHeightfield: Shape.types.SPHERE | Shape.types.HEIGHTFIELD,
    boxHeightfield: Shape.types.BOX | Shape.types.HEIGHTFIELD,
    convexHeightfield: Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD,
    sphereParticle: Shape.types.PARTICLE | Shape.types.SPHERE,
    planeParticle: Shape.types.PLANE | Shape.types.PARTICLE,
    boxParticle: Shape.types.BOX | Shape.types.PARTICLE,
    convexParticle: Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON,
    cylinderCylinder: Shape.types.CYLINDER,
    sphereCylinder: Shape.types.SPHERE | Shape.types.CYLINDER,
    planeCylinder: Shape.types.PLANE | Shape.types.CYLINDER,
    boxCylinder: Shape.types.BOX | Shape.types.CYLINDER,
    convexCylinder: Shape.types.CONVEXPOLYHEDRON | Shape.types.CYLINDER,
    heightfieldCylinder: Shape.types.HEIGHTFIELD | Shape.types.CYLINDER,
    particleCylinder: Shape.types.PARTICLE | Shape.types.CYLINDER,
    sphereTrimesh: Shape.types.SPHERE | Shape.types.TRIMESH,
    planeTrimesh: Shape.types.PLANE | Shape.types.TRIMESH
};
class Narrowphase {
    get[COLLISION_TYPES.sphereSphere]() {
        return this.sphereSphere
    }
    get[COLLISION_TYPES.spherePlane]() {
        return this.spherePlane
    }
    get[COLLISION_TYPES.boxBox]() {
        return this.boxBox
    }
    get[COLLISION_TYPES.sphereBox]() {
        return this.sphereBox
    }
    get[COLLISION_TYPES.planeBox]() {
        return this.planeBox
    }
    get[COLLISION_TYPES.convexConvex]() {
        return this.convexConvex
    }
    get[COLLISION_TYPES.sphereConvex]() {
        return this.sphereConvex
    }
    get[COLLISION_TYPES.planeConvex]() {
        return this.planeConvex
    }
    get[COLLISION_TYPES.boxConvex]() {
        return this.boxConvex
    }
    get[COLLISION_TYPES.sphereHeightfield]() {
        return this.sphereHeightfield
    }
    get[COLLISION_TYPES.boxHeightfield]() {
        return this.boxHeightfield
    }
    get[COLLISION_TYPES.convexHeightfield]() {
        return this.convexHeightfield
    }
    get[COLLISION_TYPES.sphereParticle]() {
        return this.sphereParticle
    }
    get[COLLISION_TYPES.planeParticle]() {
        return this.planeParticle
    }
    get[COLLISION_TYPES.boxParticle]() {
        return this.boxParticle
    }
    get[COLLISION_TYPES.convexParticle]() {
        return this.convexParticle
    }
    get[COLLISION_TYPES.cylinderCylinder]() {
        return this.convexConvex
    }
    get[COLLISION_TYPES.sphereCylinder]() {
        return this.sphereConvex
    }
    get[COLLISION_TYPES.planeCylinder]() {
        return this.planeConvex
    }
    get[COLLISION_TYPES.boxCylinder]() {
        return this.boxConvex
    }
    get[COLLISION_TYPES.convexCylinder]() {
        return this.convexConvex
    }
    get[COLLISION_TYPES.heightfieldCylinder]() {
        return this.heightfieldCylinder
    }
    get[COLLISION_TYPES.particleCylinder]() {
        return this.particleCylinder
    }
    get[COLLISION_TYPES.sphereTrimesh]() {
        return this.sphereTrimesh
    }
    get[COLLISION_TYPES.planeTrimesh]() {
        return this.planeTrimesh
    }
    constructor(o) {
        this.contactPointPool = [],
        this.frictionEquationPool = [],
        this.result = [],
        this.frictionResult = [],
        this.v3pool = new Vec3Pool,
        this.world = o,
        this.currentContactMaterial = o.defaultContactMaterial,
        this.enableFrictionReduction = !1
    }
    createContactEquation(o, c, h, _, b, _e) {
        let nt;
        this.contactPointPool.length ? (nt = this.contactPointPool.pop(),
        nt.bi = o,
        nt.bj = c) : nt = new ContactEquation(o,c),
        nt.enabled = o.collisionResponse && c.collisionResponse && h.collisionResponse && _.collisionResponse;
        const it = this.currentContactMaterial;
        nt.restitution = it.restitution,
        nt.setSpookParams(it.contactEquationStiffness, it.contactEquationRelaxation, this.world.dt);
        const at = h.material || o.material
          , ut = _.material || c.material;
        return at && ut && at.restitution >= 0 && ut.restitution >= 0 && (nt.restitution = at.restitution * ut.restitution),
        nt.si = b || h,
        nt.sj = _e || _,
        nt
    }
    createFrictionEquationsFromContact(o, c) {
        const h = o.bi
          , _ = o.bj
          , b = o.si
          , _e = o.sj
          , nt = this.world
          , it = this.currentContactMaterial;
        let at = it.friction;
        const ut = b.material || h.material
          , pt = _e.material || _.material;
        if (ut && pt && ut.friction >= 0 && pt.friction >= 0 && (at = ut.friction * pt.friction),
        at > 0) {
            const ht = at * nt.gravity.length();
            let _t = h.invMass + _.invMass;
            _t > 0 && (_t = 1 / _t);
            const vt = this.frictionEquationPool
              , bt = vt.length ? vt.pop() : new FrictionEquation(h,_,ht * _t)
              , St = vt.length ? vt.pop() : new FrictionEquation(h,_,ht * _t);
            return bt.bi = St.bi = h,
            bt.bj = St.bj = _,
            bt.minForce = St.minForce = -ht * _t,
            bt.maxForce = St.maxForce = ht * _t,
            bt.ri.copy(o.ri),
            bt.rj.copy(o.rj),
            St.ri.copy(o.ri),
            St.rj.copy(o.rj),
            o.ni.tangents(bt.t, St.t),
            bt.setSpookParams(it.frictionEquationStiffness, it.frictionEquationRelaxation, nt.dt),
            St.setSpookParams(it.frictionEquationStiffness, it.frictionEquationRelaxation, nt.dt),
            bt.enabled = St.enabled = o.enabled,
            c.push(bt, St),
            !0
        }
        return !1
    }
    createFrictionFromAverage(o) {
        let c = this.result[this.result.length - 1];
        if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || o === 1)
            return;
        const h = this.frictionResult[this.frictionResult.length - 2]
          , _ = this.frictionResult[this.frictionResult.length - 1];
        averageNormal.setZero(),
        averageContactPointA.setZero(),
        averageContactPointB.setZero();
        const b = c.bi;
        c.bj;
        for (let nt = 0; nt !== o; nt++)
            c = this.result[this.result.length - 1 - nt],
            c.bi !== b ? (averageNormal.vadd(c.ni, averageNormal),
            averageContactPointA.vadd(c.ri, averageContactPointA),
            averageContactPointB.vadd(c.rj, averageContactPointB)) : (averageNormal.vsub(c.ni, averageNormal),
            averageContactPointA.vadd(c.rj, averageContactPointA),
            averageContactPointB.vadd(c.ri, averageContactPointB));
        const _e = 1 / o;
        averageContactPointA.scale(_e, h.ri),
        averageContactPointB.scale(_e, h.rj),
        _.ri.copy(h.ri),
        _.rj.copy(h.rj),
        averageNormal.normalize(),
        averageNormal.tangents(h.t, _.t)
    }
    getContacts(o, c, h, _, b, _e, nt) {
        this.contactPointPool = b,
        this.frictionEquationPool = nt,
        this.result = _,
        this.frictionResult = _e;
        const it = tmpQuat1
          , at = tmpQuat2
          , ut = tmpVec1
          , pt = tmpVec2;
        for (let ht = 0, _t = o.length; ht !== _t; ht++) {
            const vt = o[ht]
              , bt = c[ht];
            let St = null;
            vt.material && bt.material && (St = h.getContactMaterial(vt.material, bt.material) || null);
            const At = vt.type & Body.KINEMATIC && bt.type & Body.STATIC || vt.type & Body.STATIC && bt.type & Body.KINEMATIC || vt.type & Body.KINEMATIC && bt.type & Body.KINEMATIC;
            for (let Et = 0; Et < vt.shapes.length; Et++) {
                vt.quaternion.mult(vt.shapeOrientations[Et], it),
                vt.quaternion.vmult(vt.shapeOffsets[Et], ut),
                ut.vadd(vt.position, ut);
                const Pt = vt.shapes[Et];
                for (let It = 0; It < bt.shapes.length; It++) {
                    bt.quaternion.mult(bt.shapeOrientations[It], at),
                    bt.quaternion.vmult(bt.shapeOffsets[It], pt),
                    pt.vadd(bt.position, pt);
                    const Dt = bt.shapes[It];
                    if (!(Pt.collisionFilterMask & Dt.collisionFilterGroup && Dt.collisionFilterMask & Pt.collisionFilterGroup) || ut.distanceTo(pt) > Pt.boundingSphereRadius + Dt.boundingSphereRadius)
                        continue;
                    let Gt = null;
                    Pt.material && Dt.material && (Gt = h.getContactMaterial(Pt.material, Dt.material) || null),
                    this.currentContactMaterial = Gt || St || h.defaultContactMaterial;
                    const Bt = this[Pt.type | Dt.type];
                    if (Bt) {
                        let kt = !1;
                        kt = Pt.type < Dt.type ? Bt.call(this, Pt, Dt, ut, pt, it, at, vt, bt, Pt, Dt, At) : Bt.call(this, Dt, Pt, pt, ut, at, it, bt, vt, Pt, Dt, At),
                        kt && At && (h.shapeOverlapKeeper.set(Pt.id, Dt.id),
                        h.bodyOverlapKeeper.set(vt.id, bt.id))
                    }
                }
            }
        }
    }
    sphereSphere(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        if (pt)
            return h.distanceSquared(_) < (o.radius + c.radius) ** 2;
        const ht = this.createContactEquation(nt, it, o, c, at, ut);
        _.vsub(h, ht.ni),
        ht.ni.normalize(),
        ht.ri.copy(ht.ni),
        ht.rj.copy(ht.ni),
        ht.ri.scale(o.radius, ht.ri),
        ht.rj.scale(-c.radius, ht.rj),
        ht.ri.vadd(h, ht.ri),
        ht.ri.vsub(nt.position, ht.ri),
        ht.rj.vadd(_, ht.rj),
        ht.rj.vsub(it.position, ht.rj),
        this.result.push(ht),
        this.createFrictionEquationsFromContact(ht, this.frictionResult)
    }
    spherePlane(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = this.createContactEquation(nt, it, o, c, at, ut);
        if (ht.ni.set(0, 0, 1),
        _e.vmult(ht.ni, ht.ni),
        ht.ni.negate(ht.ni),
        ht.ni.normalize(),
        ht.ni.scale(o.radius, ht.ri),
        h.vsub(_, point_on_plane_to_sphere),
        ht.ni.scale(ht.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho),
        point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, ht.rj),
        -point_on_plane_to_sphere.dot(ht.ni) <= o.radius) {
            if (pt)
                return !0;
            const _t = ht.ri
              , vt = ht.rj;
            _t.vadd(h, _t),
            _t.vsub(nt.position, _t),
            vt.vadd(_, vt),
            vt.vsub(it.position, vt),
            this.result.push(ht),
            this.createFrictionEquationsFromContact(ht, this.frictionResult)
        }
    }
    boxBox(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return o.convexPolyhedronRepresentation.material = o.material,
        c.convexPolyhedronRepresentation.material = c.material,
        o.convexPolyhedronRepresentation.collisionResponse = o.collisionResponse,
        c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse,
        this.convexConvex(o.convexPolyhedronRepresentation, c.convexPolyhedronRepresentation, h, _, b, _e, nt, it, o, c, pt)
    }
    sphereBox(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = this.v3pool
          , _t = sphereBox_sides;
        h.vsub(_, box_to_sphere),
        c.getSideNormals(_t, _e);
        const vt = o.radius;
        let bt = !1;
        const St = sphereBox_side_ns
          , At = sphereBox_side_ns1
          , Et = sphereBox_side_ns2;
        let Pt = null
          , It = 0
          , Dt = 0
          , Gt = 0
          , Bt = null;
        for (let ar = 0, hr = _t.length; ar !== hr && bt === !1; ar++) {
            const gr = sphereBox_ns;
            gr.copy(_t[ar]);
            const dr = gr.length();
            gr.normalize();
            const cr = box_to_sphere.dot(gr);
            if (cr < dr + vt && cr > 0) {
                const Ar = sphereBox_ns1
                  , wr = sphereBox_ns2;
                Ar.copy(_t[(ar + 1) % 3]),
                wr.copy(_t[(ar + 2) % 3]);
                const Rr = Ar.length()
                  , Cr = wr.length();
                Ar.normalize(),
                wr.normalize();
                const tr = box_to_sphere.dot(Ar)
                  , fr = box_to_sphere.dot(wr);
                if (tr < Rr && tr > -Rr && fr < Cr && fr > -Cr) {
                    const vr = Math.abs(cr - dr - vt);
                    if ((Bt === null || vr < Bt) && (Bt = vr,
                    Dt = tr,
                    Gt = fr,
                    Pt = dr,
                    St.copy(gr),
                    At.copy(Ar),
                    Et.copy(wr),
                    It++,
                    pt))
                        return !0
                }
            }
        }
        if (It) {
            bt = !0;
            const ar = this.createContactEquation(nt, it, o, c, at, ut);
            St.scale(-vt, ar.ri),
            ar.ni.copy(St),
            ar.ni.negate(ar.ni),
            St.scale(Pt, St),
            At.scale(Dt, At),
            St.vadd(At, St),
            Et.scale(Gt, Et),
            St.vadd(Et, ar.rj),
            ar.ri.vadd(h, ar.ri),
            ar.ri.vsub(nt.position, ar.ri),
            ar.rj.vadd(_, ar.rj),
            ar.rj.vsub(it.position, ar.rj),
            this.result.push(ar),
            this.createFrictionEquationsFromContact(ar, this.frictionResult)
        }
        let kt = ht.get();
        const Ut = sphereBox_sphere_to_corner;
        for (let ar = 0; ar !== 2 && !bt; ar++)
            for (let hr = 0; hr !== 2 && !bt; hr++)
                for (let gr = 0; gr !== 2 && !bt; gr++)
                    if (kt.set(0, 0, 0),
                    ar ? kt.vadd(_t[0], kt) : kt.vsub(_t[0], kt),
                    hr ? kt.vadd(_t[1], kt) : kt.vsub(_t[1], kt),
                    gr ? kt.vadd(_t[2], kt) : kt.vsub(_t[2], kt),
                    _.vadd(kt, Ut),
                    Ut.vsub(h, Ut),
                    Ut.lengthSquared() < vt * vt) {
                        if (pt)
                            return !0;
                        bt = !0;
                        const dr = this.createContactEquation(nt, it, o, c, at, ut);
                        dr.ri.copy(Ut),
                        dr.ri.normalize(),
                        dr.ni.copy(dr.ri),
                        dr.ri.scale(vt, dr.ri),
                        dr.rj.copy(kt),
                        dr.ri.vadd(h, dr.ri),
                        dr.ri.vsub(nt.position, dr.ri),
                        dr.rj.vadd(_, dr.rj),
                        dr.rj.vsub(it.position, dr.rj),
                        this.result.push(dr),
                        this.createFrictionEquationsFromContact(dr, this.frictionResult)
                    }
        ht.release(kt),
        kt = null;
        const Ht = ht.get()
          , Kt = ht.get()
          , Jt = ht.get()
          , or = ht.get()
          , ir = ht.get()
          , lr = _t.length;
        for (let ar = 0; ar !== lr && !bt; ar++)
            for (let hr = 0; hr !== lr && !bt; hr++)
                if (ar % 3 != hr % 3) {
                    _t[hr].cross(_t[ar], Ht),
                    Ht.normalize(),
                    _t[ar].vadd(_t[hr], Kt),
                    Jt.copy(h),
                    Jt.vsub(Kt, Jt),
                    Jt.vsub(_, Jt);
                    const gr = Jt.dot(Ht);
                    Ht.scale(gr, or);
                    let dr = 0;
                    for (; dr === ar % 3 || dr === hr % 3; )
                        dr++;
                    ir.copy(h),
                    ir.vsub(or, ir),
                    ir.vsub(Kt, ir),
                    ir.vsub(_, ir);
                    const cr = Math.abs(gr)
                      , Ar = ir.length();
                    if (cr < _t[dr].length() && Ar < vt) {
                        if (pt)
                            return !0;
                        bt = !0;
                        const wr = this.createContactEquation(nt, it, o, c, at, ut);
                        Kt.vadd(or, wr.rj),
                        wr.rj.copy(wr.rj),
                        ir.negate(wr.ni),
                        wr.ni.normalize(),
                        wr.ri.copy(wr.rj),
                        wr.ri.vadd(_, wr.ri),
                        wr.ri.vsub(h, wr.ri),
                        wr.ri.normalize(),
                        wr.ri.scale(vt, wr.ri),
                        wr.ri.vadd(h, wr.ri),
                        wr.ri.vsub(nt.position, wr.ri),
                        wr.rj.vadd(_, wr.rj),
                        wr.rj.vsub(it.position, wr.rj),
                        this.result.push(wr),
                        this.createFrictionEquationsFromContact(wr, this.frictionResult)
                    }
                }
        ht.release(Ht, Kt, Jt, or, ir)
    }
    planeBox(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return c.convexPolyhedronRepresentation.material = c.material,
        c.convexPolyhedronRepresentation.collisionResponse = c.collisionResponse,
        c.convexPolyhedronRepresentation.id = c.id,
        this.planeConvex(o, c.convexPolyhedronRepresentation, h, _, b, _e, nt, it, o, c, pt)
    }
    convexConvex(o, c, h, _, b, _e, nt, it, at, ut, pt, ht, _t) {
        const vt = convexConvex_sepAxis;
        if (!(h.distanceTo(_) > o.boundingSphereRadius + c.boundingSphereRadius) && o.findSeparatingAxis(c, h, b, _, _e, vt, ht, _t)) {
            const bt = []
              , St = convexConvex_q;
            o.clipAgainstHull(h, b, c, _, _e, vt, -100, 100, bt);
            let At = 0;
            for (let Et = 0; Et !== bt.length; Et++) {
                if (pt)
                    return !0;
                const Pt = this.createContactEquation(nt, it, o, c, at, ut)
                  , It = Pt.ri
                  , Dt = Pt.rj;
                vt.negate(Pt.ni),
                bt[Et].normal.negate(St),
                St.scale(bt[Et].depth, St),
                bt[Et].point.vadd(St, It),
                Dt.copy(bt[Et].point),
                It.vsub(h, It),
                Dt.vsub(_, Dt),
                It.vadd(h, It),
                It.vsub(nt.position, It),
                Dt.vadd(_, Dt),
                Dt.vsub(it.position, Dt),
                this.result.push(Pt),
                At++,
                this.enableFrictionReduction || this.createFrictionEquationsFromContact(Pt, this.frictionResult)
            }
            this.enableFrictionReduction && At && this.createFrictionFromAverage(At)
        }
    }
    sphereConvex(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = this.v3pool;
        h.vsub(_, convex_to_sphere);
        const _t = c.faceNormals
          , vt = c.faces
          , bt = c.vertices
          , St = o.radius;
        let At = !1;
        for (let Et = 0; Et !== bt.length; Et++) {
            const Pt = bt[Et]
              , It = sphereConvex_worldCorner;
            _e.vmult(Pt, It),
            _.vadd(It, It);
            const Dt = sphereConvex_sphereToCorner;
            if (It.vsub(h, Dt),
            Dt.lengthSquared() < St * St) {
                if (pt)
                    return !0;
                At = !0;
                const Gt = this.createContactEquation(nt, it, o, c, at, ut);
                return Gt.ri.copy(Dt),
                Gt.ri.normalize(),
                Gt.ni.copy(Gt.ri),
                Gt.ri.scale(St, Gt.ri),
                It.vsub(_, Gt.rj),
                Gt.ri.vadd(h, Gt.ri),
                Gt.ri.vsub(nt.position, Gt.ri),
                Gt.rj.vadd(_, Gt.rj),
                Gt.rj.vsub(it.position, Gt.rj),
                this.result.push(Gt),
                void this.createFrictionEquationsFromContact(Gt, this.frictionResult)
            }
        }
        for (let Et = 0, Pt = vt.length; Et !== Pt && At === !1; Et++) {
            const It = _t[Et]
              , Dt = vt[Et]
              , Gt = sphereConvex_worldNormal;
            _e.vmult(It, Gt);
            const Bt = sphereConvex_worldPoint;
            _e.vmult(bt[Dt[0]], Bt),
            Bt.vadd(_, Bt);
            const kt = sphereConvex_worldSpherePointClosestToPlane;
            Gt.scale(-St, kt),
            h.vadd(kt, kt);
            const Ut = sphereConvex_penetrationVec;
            kt.vsub(Bt, Ut);
            const Ht = Ut.dot(Gt)
              , Kt = sphereConvex_sphereToWorldPoint;
            if (h.vsub(Bt, Kt),
            Ht < 0 && Kt.dot(Gt) > 0) {
                const Jt = [];
                for (let or = 0, ir = Dt.length; or !== ir; or++) {
                    const lr = ht.get();
                    _e.vmult(bt[Dt[or]], lr),
                    _.vadd(lr, lr),
                    Jt.push(lr)
                }
                if (pointInPolygon(Jt, Gt, h)) {
                    if (pt)
                        return !0;
                    At = !0;
                    const or = this.createContactEquation(nt, it, o, c, at, ut);
                    Gt.scale(-St, or.ri),
                    Gt.negate(or.ni);
                    const ir = ht.get();
                    Gt.scale(-Ht, ir);
                    const lr = ht.get();
                    Gt.scale(-St, lr),
                    h.vsub(_, or.rj),
                    or.rj.vadd(lr, or.rj),
                    or.rj.vadd(ir, or.rj),
                    or.rj.vadd(_, or.rj),
                    or.rj.vsub(it.position, or.rj),
                    or.ri.vadd(h, or.ri),
                    or.ri.vsub(nt.position, or.ri),
                    ht.release(ir),
                    ht.release(lr),
                    this.result.push(or),
                    this.createFrictionEquationsFromContact(or, this.frictionResult);
                    for (let ar = 0, hr = Jt.length; ar !== hr; ar++)
                        ht.release(Jt[ar]);
                    return
                }
                for (let or = 0; or !== Dt.length; or++) {
                    const ir = ht.get()
                      , lr = ht.get();
                    _e.vmult(bt[Dt[(or + 1) % Dt.length]], ir),
                    _e.vmult(bt[Dt[(or + 2) % Dt.length]], lr),
                    _.vadd(ir, ir),
                    _.vadd(lr, lr);
                    const ar = sphereConvex_edge;
                    lr.vsub(ir, ar);
                    const hr = sphereConvex_edgeUnit;
                    ar.unit(hr);
                    const gr = ht.get()
                      , dr = ht.get();
                    h.vsub(ir, dr);
                    const cr = dr.dot(hr);
                    hr.scale(cr, gr),
                    gr.vadd(ir, gr);
                    const Ar = ht.get();
                    if (gr.vsub(h, Ar),
                    cr > 0 && cr * cr < ar.lengthSquared() && Ar.lengthSquared() < St * St) {
                        if (pt)
                            return !0;
                        const wr = this.createContactEquation(nt, it, o, c, at, ut);
                        gr.vsub(_, wr.rj),
                        gr.vsub(h, wr.ni),
                        wr.ni.normalize(),
                        wr.ni.scale(St, wr.ri),
                        wr.rj.vadd(_, wr.rj),
                        wr.rj.vsub(it.position, wr.rj),
                        wr.ri.vadd(h, wr.ri),
                        wr.ri.vsub(nt.position, wr.ri),
                        this.result.push(wr),
                        this.createFrictionEquationsFromContact(wr, this.frictionResult);
                        for (let Rr = 0, Cr = Jt.length; Rr !== Cr; Rr++)
                            ht.release(Jt[Rr]);
                        return ht.release(ir),
                        ht.release(lr),
                        ht.release(gr),
                        ht.release(Ar),
                        void ht.release(dr)
                    }
                    ht.release(ir),
                    ht.release(lr),
                    ht.release(gr),
                    ht.release(Ar),
                    ht.release(dr)
                }
                for (let or = 0, ir = Jt.length; or !== ir; or++)
                    ht.release(Jt[or])
            }
        }
    }
    planeConvex(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = planeConvex_v
          , _t = planeConvex_normal;
        _t.set(0, 0, 1),
        b.vmult(_t, _t);
        let vt = 0;
        const bt = planeConvex_relpos;
        for (let St = 0; St !== c.vertices.length; St++)
            if (ht.copy(c.vertices[St]),
            _e.vmult(ht, ht),
            _.vadd(ht, ht),
            ht.vsub(h, bt),
            _t.dot(bt) <= 0) {
                if (pt)
                    return !0;
                const At = this.createContactEquation(nt, it, o, c, at, ut)
                  , Et = planeConvex_projected;
                _t.scale(_t.dot(bt), Et),
                ht.vsub(Et, Et),
                Et.vsub(h, At.ri),
                At.ni.copy(_t),
                ht.vsub(_, At.rj),
                At.ri.vadd(h, At.ri),
                At.ri.vsub(nt.position, At.ri),
                At.rj.vadd(_, At.rj),
                At.rj.vsub(it.position, At.rj),
                this.result.push(At),
                vt++,
                this.enableFrictionReduction || this.createFrictionEquationsFromContact(At, this.frictionResult)
            }
        this.enableFrictionReduction && vt && this.createFrictionFromAverage(vt)
    }
    boxConvex(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return o.convexPolyhedronRepresentation.material = o.material,
        o.convexPolyhedronRepresentation.collisionResponse = o.collisionResponse,
        this.convexConvex(o.convexPolyhedronRepresentation, c, h, _, b, _e, nt, it, o, c, pt)
    }
    sphereHeightfield(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = c.data
          , _t = o.radius
          , vt = c.elementSize
          , bt = sphereHeightfield_tmp2
          , St = sphereHeightfield_tmp1;
        cannon_es_Transform.pointToLocalFrame(_, _e, h, St);
        let At = Math.floor((St.x - _t) / vt) - 1
          , Et = Math.ceil((St.x + _t) / vt) + 1
          , Pt = Math.floor((St.y - _t) / vt) - 1
          , It = Math.ceil((St.y + _t) / vt) + 1;
        if (Et < 0 || It < 0 || At > ht.length || Pt > ht[0].length)
            return;
        At < 0 && (At = 0),
        Et < 0 && (Et = 0),
        Pt < 0 && (Pt = 0),
        It < 0 && (It = 0),
        At >= ht.length && (At = ht.length - 1),
        Et >= ht.length && (Et = ht.length - 1),
        It >= ht[0].length && (It = ht[0].length - 1),
        Pt >= ht[0].length && (Pt = ht[0].length - 1);
        const Dt = [];
        c.getRectMinMax(At, Pt, Et, It, Dt);
        const Gt = Dt[0]
          , Bt = Dt[1];
        if (St.z - _t > Bt || St.z + _t < Gt)
            return;
        const kt = this.result;
        for (let Ut = At; Ut < Et; Ut++)
            for (let Ht = Pt; Ht < It; Ht++) {
                const Kt = kt.length;
                let Jt = !1;
                if (c.getConvexTrianglePillar(Ut, Ht, !1),
                cannon_es_Transform.pointToWorldFrame(_, _e, c.pillarOffset, bt),
                h.distanceTo(bt) < c.pillarConvex.boundingSphereRadius + o.boundingSphereRadius && (Jt = this.sphereConvex(o, c.pillarConvex, h, bt, b, _e, nt, it, o, c, pt)),
                pt && Jt || (c.getConvexTrianglePillar(Ut, Ht, !0),
                cannon_es_Transform.pointToWorldFrame(_, _e, c.pillarOffset, bt),
                h.distanceTo(bt) < c.pillarConvex.boundingSphereRadius + o.boundingSphereRadius && (Jt = this.sphereConvex(o, c.pillarConvex, h, bt, b, _e, nt, it, o, c, pt)),
                pt && Jt))
                    return !0;
                if (kt.length - Kt > 2)
                    return
            }
    }
    boxHeightfield(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return o.convexPolyhedronRepresentation.material = o.material,
        o.convexPolyhedronRepresentation.collisionResponse = o.collisionResponse,
        this.convexHeightfield(o.convexPolyhedronRepresentation, c, h, _, b, _e, nt, it, o, c, pt)
    }
    convexHeightfield(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = c.data
          , _t = c.elementSize
          , vt = o.boundingSphereRadius
          , bt = convexHeightfield_tmp2
          , St = convexHeightfield_faceList
          , At = convexHeightfield_tmp1;
        cannon_es_Transform.pointToLocalFrame(_, _e, h, At);
        let Et = Math.floor((At.x - vt) / _t) - 1
          , Pt = Math.ceil((At.x + vt) / _t) + 1
          , It = Math.floor((At.y - vt) / _t) - 1
          , Dt = Math.ceil((At.y + vt) / _t) + 1;
        if (Pt < 0 || Dt < 0 || Et > ht.length || It > ht[0].length)
            return;
        Et < 0 && (Et = 0),
        Pt < 0 && (Pt = 0),
        It < 0 && (It = 0),
        Dt < 0 && (Dt = 0),
        Et >= ht.length && (Et = ht.length - 1),
        Pt >= ht.length && (Pt = ht.length - 1),
        Dt >= ht[0].length && (Dt = ht[0].length - 1),
        It >= ht[0].length && (It = ht[0].length - 1);
        const Gt = [];
        c.getRectMinMax(Et, It, Pt, Dt, Gt);
        const Bt = Gt[0]
          , kt = Gt[1];
        if (!(At.z - vt > kt || At.z + vt < Bt))
            for (let Ut = Et; Ut < Pt; Ut++)
                for (let Ht = It; Ht < Dt; Ht++) {
                    let Kt = !1;
                    if (c.getConvexTrianglePillar(Ut, Ht, !1),
                    cannon_es_Transform.pointToWorldFrame(_, _e, c.pillarOffset, bt),
                    h.distanceTo(bt) < c.pillarConvex.boundingSphereRadius + o.boundingSphereRadius && (Kt = this.convexConvex(o, c.pillarConvex, h, bt, b, _e, nt, it, null, null, pt, St, null)),
                    pt && Kt || (c.getConvexTrianglePillar(Ut, Ht, !0),
                    cannon_es_Transform.pointToWorldFrame(_, _e, c.pillarOffset, bt),
                    h.distanceTo(bt) < c.pillarConvex.boundingSphereRadius + o.boundingSphereRadius && (Kt = this.convexConvex(o, c.pillarConvex, h, bt, b, _e, nt, it, null, null, pt, St, null)),
                    pt && Kt))
                        return !0
                }
    }
    sphereParticle(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = particleSphere_normal;
        if (ht.set(0, 0, 1),
        _.vsub(h, ht),
        ht.lengthSquared() <= o.radius * o.radius) {
            if (pt)
                return !0;
            const _t = this.createContactEquation(it, nt, c, o, at, ut);
            ht.normalize(),
            _t.rj.copy(ht),
            _t.rj.scale(o.radius, _t.rj),
            _t.ni.copy(ht),
            _t.ni.negate(_t.ni),
            _t.ri.set(0, 0, 0),
            this.result.push(_t),
            this.createFrictionEquationsFromContact(_t, this.frictionResult)
        }
    }
    planeParticle(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = particlePlane_normal;
        ht.set(0, 0, 1),
        nt.quaternion.vmult(ht, ht);
        const _t = particlePlane_relpos;
        if (_.vsub(nt.position, _t),
        ht.dot(_t) <= 0) {
            if (pt)
                return !0;
            const vt = this.createContactEquation(it, nt, c, o, at, ut);
            vt.ni.copy(ht),
            vt.ni.negate(vt.ni),
            vt.ri.set(0, 0, 0);
            const bt = particlePlane_projected;
            ht.scale(ht.dot(_), bt),
            _.vsub(bt, bt),
            vt.rj.copy(bt),
            this.result.push(vt),
            this.createFrictionEquationsFromContact(vt, this.frictionResult)
        }
    }
    boxParticle(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return o.convexPolyhedronRepresentation.material = o.material,
        o.convexPolyhedronRepresentation.collisionResponse = o.collisionResponse,
        this.convexParticle(o.convexPolyhedronRepresentation, c, h, _, b, _e, nt, it, o, c, pt)
    }
    convexParticle(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        let ht = -1;
        const _t = convexParticle_penetratedFaceNormal
          , vt = convexParticle_worldPenetrationVec;
        let bt = null;
        const St = convexParticle_local;
        if (St.copy(_),
        St.vsub(h, St),
        b.conjugate(cqj),
        cqj.vmult(St, St),
        o.pointIsInside(St)) {
            o.worldVerticesNeedsUpdate && o.computeWorldVertices(h, b),
            o.worldFaceNormalsNeedsUpdate && o.computeWorldFaceNormals(b);
            for (let At = 0, Et = o.faces.length; At !== Et; At++) {
                const Pt = [o.worldVertices[o.faces[At][0]]]
                  , It = o.worldFaceNormals[At];
                _.vsub(Pt[0], convexParticle_vertexToParticle);
                const Dt = -It.dot(convexParticle_vertexToParticle);
                if (bt === null || Math.abs(Dt) < Math.abs(bt)) {
                    if (pt)
                        return !0;
                    bt = Dt,
                    ht = At,
                    _t.copy(It)
                }
            }
            if (ht !== -1) {
                const At = this.createContactEquation(it, nt, c, o, at, ut);
                _t.scale(bt, vt),
                vt.vadd(_, vt),
                vt.vsub(h, vt),
                At.rj.copy(vt),
                _t.negate(At.ni),
                At.ri.set(0, 0, 0);
                const Et = At.ri
                  , Pt = At.rj;
                Et.vadd(_, Et),
                Et.vsub(it.position, Et),
                Pt.vadd(h, Pt),
                Pt.vsub(nt.position, Pt),
                this.result.push(At),
                this.createFrictionEquationsFromContact(At, this.frictionResult)
            } else
                console.warn("Point found inside convex, but did not find penetrating face!")
        }
    }
    heightfieldCylinder(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return this.convexHeightfield(c, o, _, h, _e, b, it, nt, at, ut, pt)
    }
    particleCylinder(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        return this.convexParticle(c, o, _, h, _e, b, it, nt, at, ut, pt)
    }
    sphereTrimesh(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = sphereTrimesh_edgeVertexA
          , _t = sphereTrimesh_edgeVertexB
          , vt = sphereTrimesh_edgeVector
          , bt = sphereTrimesh_edgeVectorUnit
          , St = sphereTrimesh_localSpherePos
          , At = sphereTrimesh_tmp
          , Et = sphereTrimesh_localSphereAABB
          , Pt = sphereTrimesh_v2
          , It = sphereTrimesh_relpos
          , Dt = sphereTrimesh_triangles;
        cannon_es_Transform.pointToLocalFrame(_, _e, h, St);
        const Gt = o.radius;
        Et.lowerBound.set(St.x - Gt, St.y - Gt, St.z - Gt),
        Et.upperBound.set(St.x + Gt, St.y + Gt, St.z + Gt),
        c.getTrianglesInAABB(Et, Dt);
        const Bt = sphereTrimesh_v
          , kt = o.radius * o.radius;
        for (let or = 0; or < Dt.length; or++)
            for (let ir = 0; ir < 3; ir++)
                if (c.getVertex(c.indices[3 * Dt[or] + ir], Bt),
                Bt.vsub(St, It),
                It.lengthSquared() <= kt) {
                    if (Pt.copy(Bt),
                    cannon_es_Transform.pointToWorldFrame(_, _e, Pt, Bt),
                    Bt.vsub(h, It),
                    pt)
                        return !0;
                    let lr = this.createContactEquation(nt, it, o, c, at, ut);
                    lr.ni.copy(It),
                    lr.ni.normalize(),
                    lr.ri.copy(lr.ni),
                    lr.ri.scale(o.radius, lr.ri),
                    lr.ri.vadd(h, lr.ri),
                    lr.ri.vsub(nt.position, lr.ri),
                    lr.rj.copy(Bt),
                    lr.rj.vsub(it.position, lr.rj),
                    this.result.push(lr),
                    this.createFrictionEquationsFromContact(lr, this.frictionResult)
                }
        for (let or = 0; or < Dt.length; or++)
            for (let ir = 0; ir < 3; ir++) {
                c.getVertex(c.indices[3 * Dt[or] + ir], ht),
                c.getVertex(c.indices[3 * Dt[or] + (ir + 1) % 3], _t),
                _t.vsub(ht, vt),
                St.vsub(_t, At);
                const lr = At.dot(vt);
                St.vsub(ht, At);
                let ar = At.dot(vt);
                if (ar > 0 && lr < 0 && (St.vsub(ht, At),
                bt.copy(vt),
                bt.normalize(),
                ar = At.dot(bt),
                bt.scale(ar, At),
                At.vadd(ht, At),
                At.distanceTo(St) < o.radius)) {
                    if (pt)
                        return !0;
                    const hr = this.createContactEquation(nt, it, o, c, at, ut);
                    At.vsub(St, hr.ni),
                    hr.ni.normalize(),
                    hr.ni.scale(o.radius, hr.ri),
                    hr.ri.vadd(h, hr.ri),
                    hr.ri.vsub(nt.position, hr.ri),
                    cannon_es_Transform.pointToWorldFrame(_, _e, At, At),
                    At.vsub(it.position, hr.rj),
                    cannon_es_Transform.vectorToWorldFrame(_e, hr.ni, hr.ni),
                    cannon_es_Transform.vectorToWorldFrame(_e, hr.ri, hr.ri),
                    this.result.push(hr),
                    this.createFrictionEquationsFromContact(hr, this.frictionResult)
                }
            }
        const Ut = sphereTrimesh_va
          , Ht = sphereTrimesh_vb
          , Kt = sphereTrimesh_vc
          , Jt = sphereTrimesh_normal;
        for (let or = 0, ir = Dt.length; or !== ir; or++) {
            c.getTriangleVertices(Dt[or], Ut, Ht, Kt),
            c.getNormal(Dt[or], Jt),
            St.vsub(Ut, At);
            let lr = At.dot(Jt);
            if (Jt.scale(lr, At),
            St.vsub(At, At),
            lr = At.distanceTo(St),
            Ray.pointInTriangle(At, Ut, Ht, Kt) && lr < o.radius) {
                if (pt)
                    return !0;
                let ar = this.createContactEquation(nt, it, o, c, at, ut);
                At.vsub(St, ar.ni),
                ar.ni.normalize(),
                ar.ni.scale(o.radius, ar.ri),
                ar.ri.vadd(h, ar.ri),
                ar.ri.vsub(nt.position, ar.ri),
                cannon_es_Transform.pointToWorldFrame(_, _e, At, At),
                At.vsub(it.position, ar.rj),
                cannon_es_Transform.vectorToWorldFrame(_e, ar.ni, ar.ni),
                cannon_es_Transform.vectorToWorldFrame(_e, ar.ri, ar.ri),
                this.result.push(ar),
                this.createFrictionEquationsFromContact(ar, this.frictionResult)
            }
        }
        Dt.length = 0
    }
    planeTrimesh(o, c, h, _, b, _e, nt, it, at, ut, pt) {
        const ht = new Vec3
          , _t = planeTrimesh_normal;
        _t.set(0, 0, 1),
        b.vmult(_t, _t);
        for (let vt = 0; vt < c.vertices.length / 3; vt++) {
            c.getVertex(vt, ht);
            const bt = new Vec3;
            bt.copy(ht),
            cannon_es_Transform.pointToWorldFrame(_, _e, bt, ht);
            const St = planeTrimesh_relpos;
            if (ht.vsub(h, St),
            _t.dot(St) <= 0) {
                if (pt)
                    return !0;
                const At = this.createContactEquation(nt, it, o, c, at, ut);
                At.ni.copy(_t);
                const Et = planeTrimesh_projected;
                _t.scale(St.dot(_t), Et),
                ht.vsub(Et, Et),
                At.ri.copy(Et),
                At.ri.vsub(nt.position, At.ri),
                At.rj.copy(ht),
                At.rj.vsub(it.position, At.rj),
                this.result.push(At),
                this.createFrictionEquationsFromContact(At, this.frictionResult)
            }
        }
    }
}
const averageNormal = new Vec3
  , averageContactPointA = new Vec3
  , averageContactPointB = new Vec3
  , tmpVec1 = new Vec3
  , tmpVec2 = new Vec3
  , tmpQuat1 = new Quaternion
  , tmpQuat2 = new Quaternion
  , planeTrimesh_normal = new Vec3
  , planeTrimesh_relpos = new Vec3
  , planeTrimesh_projected = new Vec3
  , sphereTrimesh_normal = new Vec3
  , sphereTrimesh_relpos = new Vec3;
new Vec3;
const sphereTrimesh_v = new Vec3
  , sphereTrimesh_v2 = new Vec3
  , sphereTrimesh_edgeVertexA = new Vec3
  , sphereTrimesh_edgeVertexB = new Vec3
  , sphereTrimesh_edgeVector = new Vec3
  , sphereTrimesh_edgeVectorUnit = new Vec3
  , sphereTrimesh_localSpherePos = new Vec3
  , sphereTrimesh_tmp = new Vec3
  , sphereTrimesh_va = new Vec3
  , sphereTrimesh_vb = new Vec3
  , sphereTrimesh_vc = new Vec3
  , sphereTrimesh_localSphereAABB = new AABB
  , sphereTrimesh_triangles = []
  , point_on_plane_to_sphere = new Vec3
  , plane_to_sphere_ortho = new Vec3
  , pointInPolygon_edge = new Vec3
  , pointInPolygon_edge_x_normal = new Vec3
  , pointInPolygon_vtp = new Vec3;
function pointInPolygon(d, o, c) {
    let h = null;
    const _ = d.length;
    for (let b = 0; b !== _; b++) {
        const _e = d[b]
          , nt = pointInPolygon_edge;
        d[(b + 1) % _].vsub(_e, nt);
        const it = pointInPolygon_edge_x_normal;
        nt.cross(o, it);
        const at = pointInPolygon_vtp;
        c.vsub(_e, at);
        const ut = it.dot(at);
        if (!(h === null || ut > 0 && h === !0 || ut <= 0 && h === !1))
            return !1;
        h === null && (h = ut > 0)
    }
    return !0
}
const box_to_sphere = new Vec3
  , sphereBox_ns = new Vec3
  , sphereBox_ns1 = new Vec3
  , sphereBox_ns2 = new Vec3
  , sphereBox_sides = [new Vec3, new Vec3, new Vec3, new Vec3, new Vec3, new Vec3]
  , sphereBox_sphere_to_corner = new Vec3
  , sphereBox_side_ns = new Vec3
  , sphereBox_side_ns1 = new Vec3
  , sphereBox_side_ns2 = new Vec3
  , convex_to_sphere = new Vec3
  , sphereConvex_edge = new Vec3
  , sphereConvex_edgeUnit = new Vec3
  , sphereConvex_sphereToCorner = new Vec3
  , sphereConvex_worldCorner = new Vec3
  , sphereConvex_worldNormal = new Vec3
  , sphereConvex_worldPoint = new Vec3
  , sphereConvex_worldSpherePointClosestToPlane = new Vec3
  , sphereConvex_penetrationVec = new Vec3
  , sphereConvex_sphereToWorldPoint = new Vec3;
new Vec3,
new Vec3;
const planeConvex_v = new Vec3
  , planeConvex_normal = new Vec3
  , planeConvex_relpos = new Vec3
  , planeConvex_projected = new Vec3
  , convexConvex_sepAxis = new Vec3
  , convexConvex_q = new Vec3
  , particlePlane_normal = new Vec3
  , particlePlane_relpos = new Vec3
  , particlePlane_projected = new Vec3
  , particleSphere_normal = new Vec3
  , cqj = new Quaternion
  , convexParticle_local = new Vec3;
new Vec3;
const convexParticle_penetratedFaceNormal = new Vec3
  , convexParticle_vertexToParticle = new Vec3
  , convexParticle_worldPenetrationVec = new Vec3
  , convexHeightfield_tmp1 = new Vec3
  , convexHeightfield_tmp2 = new Vec3
  , convexHeightfield_faceList = [0]
  , sphereHeightfield_tmp1 = new Vec3
  , sphereHeightfield_tmp2 = new Vec3;
class OverlapKeeper {
    constructor() {
        this.current = [],
        this.previous = []
    }
    getKey(o, c) {
        if (c < o) {
            const h = c;
            c = o,
            o = h
        }
        return o << 16 | c
    }
    set(o, c) {
        const h = this.getKey(o, c)
          , _ = this.current;
        let b = 0;
        for (; h > _[b]; )
            b++;
        if (h !== _[b]) {
            for (let _e = _.length - 1; _e >= b; _e--)
                _[_e + 1] = _[_e];
            _[b] = h
        }
    }
    tick() {
        const o = this.current;
        this.current = this.previous,
        this.previous = o,
        this.current.length = 0
    }
    getDiff(o, c) {
        const h = this.current
          , _ = this.previous
          , b = h.length
          , _e = _.length;
        let nt = 0;
        for (let it = 0; it < b; it++) {
            let at = !1;
            const ut = h[it];
            for (; ut > _[nt]; )
                nt++;
            at = ut === _[nt],
            at || unpackAndPush(o, ut)
        }
        nt = 0;
        for (let it = 0; it < _e; it++) {
            let at = !1;
            const ut = _[it];
            for (; ut > h[nt]; )
                nt++;
            at = h[nt] === ut,
            at || unpackAndPush(c, ut)
        }
    }
}
function unpackAndPush(d, o) {
    d.push((4294901760 & o) >> 16, 65535 & o)
}
const getKey = (d, o) => d < o ? `${d}-${o}` : `${o}-${d}`;
class TupleDictionary {
    constructor() {
        this.data = {
            keys: []
        }
    }
    get(o, c) {
        const h = getKey(o, c);
        return this.data[h]
    }
    set(o, c, h) {
        const _ = getKey(o, c);
        this.get(o, c) || this.data.keys.push(_),
        this.data[_] = h
    }
    delete(o, c) {
        const h = getKey(o, c)
          , _ = this.data.keys.indexOf(h);
        _ !== -1 && this.data.keys.splice(_, 1),
        delete this.data[h]
    }
    reset() {
        const o = this.data
          , c = o.keys;
        for (; c.length > 0; )
            delete o[c.pop()]
    }
}
class World extends EventTarget {
    constructor(o) {
        o === void 0 && (o = {}),
        super(),
        this.dt = -1,
        this.allowSleep = !!o.allowSleep,
        this.contacts = [],
        this.frictionEquations = [],
        this.quatNormalizeSkip = o.quatNormalizeSkip !== void 0 ? o.quatNormalizeSkip : 0,
        this.quatNormalizeFast = o.quatNormalizeFast !== void 0 && o.quatNormalizeFast,
        this.time = 0,
        this.stepnumber = 0,
        this.default_dt = 1 / 60,
        this.nextId = 0,
        this.gravity = new Vec3,
        o.gravity && this.gravity.copy(o.gravity),
        this.broadphase = o.broadphase !== void 0 ? o.broadphase : new NaiveBroadphase,
        this.bodies = [],
        this.hasActiveBodies = !1,
        this.solver = o.solver !== void 0 ? o.solver : new GSSolver,
        this.constraints = [],
        this.narrowphase = new Narrowphase(this),
        this.collisionMatrix = new ArrayCollisionMatrix,
        this.collisionMatrixPrevious = new ArrayCollisionMatrix,
        this.bodyOverlapKeeper = new OverlapKeeper,
        this.shapeOverlapKeeper = new OverlapKeeper,
        this.contactmaterials = [],
        this.contactMaterialTable = new TupleDictionary,
        this.defaultMaterial = new cannon_es_Material("default"),
        this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial,this.defaultMaterial,{
            friction: .3,
            restitution: 0
        }),
        this.doProfiling = !1,
        this.profile = {
            solve: 0,
            makeContactConstraints: 0,
            broadphase: 0,
            integrate: 0,
            narrowphase: 0
        },
        this.accumulator = 0,
        this.subsystems = [],
        this.addBodyEvent = {
            type: "addBody",
            body: null
        },
        this.removeBodyEvent = {
            type: "removeBody",
            body: null
        },
        this.idToBodyMap = {},
        this.broadphase.setWorld(this)
    }
    getContactMaterial(o, c) {
        return this.contactMaterialTable.get(o.id, c.id)
    }
    collisionMatrixTick() {
        const o = this.collisionMatrixPrevious;
        this.collisionMatrixPrevious = this.collisionMatrix,
        this.collisionMatrix = o,
        this.collisionMatrix.reset(),
        this.bodyOverlapKeeper.tick(),
        this.shapeOverlapKeeper.tick()
    }
    addConstraint(o) {
        this.constraints.push(o)
    }
    removeConstraint(o) {
        const c = this.constraints.indexOf(o);
        c !== -1 && this.constraints.splice(c, 1)
    }
    rayTest(o, c, h) {
        h instanceof RaycastResult ? this.raycastClosest(o, c, {
            skipBackfaces: !0
        }, h) : this.raycastAll(o, c, {
            skipBackfaces: !0
        }, h)
    }
    raycastAll(o, c, h, _) {
        return h === void 0 && (h = {}),
        h.mode = Ray.ALL,
        h.from = o,
        h.to = c,
        h.callback = _,
        tmpRay.intersectWorld(this, h)
    }
    raycastAny(o, c, h, _) {
        return h === void 0 && (h = {}),
        h.mode = Ray.ANY,
        h.from = o,
        h.to = c,
        h.result = _,
        tmpRay.intersectWorld(this, h)
    }
    raycastClosest(o, c, h, _) {
        return h === void 0 && (h = {}),
        h.mode = Ray.CLOSEST,
        h.from = o,
        h.to = c,
        h.result = _,
        tmpRay.intersectWorld(this, h)
    }
    addBody(o) {
        this.bodies.includes(o) || (o.index = this.bodies.length,
        this.bodies.push(o),
        o.world = this,
        o.initPosition.copy(o.position),
        o.initVelocity.copy(o.velocity),
        o.timeLastSleepy = this.time,
        o instanceof Body && (o.initAngularVelocity.copy(o.angularVelocity),
        o.initQuaternion.copy(o.quaternion)),
        this.collisionMatrix.setNumObjects(this.bodies.length),
        this.addBodyEvent.body = o,
        this.idToBodyMap[o.id] = o,
        this.dispatchEvent(this.addBodyEvent))
    }
    removeBody(o) {
        o.world = null;
        const c = this.bodies.length - 1
          , h = this.bodies
          , _ = h.indexOf(o);
        if (_ !== -1) {
            h.splice(_, 1);
            for (let b = 0; b !== h.length; b++)
                h[b].index = b;
            this.collisionMatrix.setNumObjects(c),
            this.removeBodyEvent.body = o,
            delete this.idToBodyMap[o.id],
            this.dispatchEvent(this.removeBodyEvent)
        }
    }
    getBodyById(o) {
        return this.idToBodyMap[o]
    }
    getShapeById(o) {
        const c = this.bodies;
        for (let h = 0; h < c.length; h++) {
            const _ = c[h].shapes;
            for (let b = 0; b < _.length; b++) {
                const _e = _[b];
                if (_e.id === o)
                    return _e
            }
        }
        return null
    }
    addContactMaterial(o) {
        this.contactmaterials.push(o),
        this.contactMaterialTable.set(o.materials[0].id, o.materials[1].id, o)
    }
    removeContactMaterial(o) {
        const c = this.contactmaterials.indexOf(o);
        c !== -1 && (this.contactmaterials.splice(c, 1),
        this.contactMaterialTable.delete(o.materials[0].id, o.materials[1].id))
    }
    fixedStep(o, c) {
        o === void 0 && (o = 1 / 60),
        c === void 0 && (c = 10);
        const h = cannon_es_performance.now() / 1e3;
        if (this.lastCallTime) {
            const _ = h - this.lastCallTime;
            this.step(o, _, c)
        } else
            this.step(o, void 0, c);
        this.lastCallTime = h
    }
    step(o, c, h) {
        if (h === void 0 && (h = 10),
        c === void 0)
            this.internalStep(o),
            this.time += o;
        else {
            this.accumulator += c;
            const _ = cannon_es_performance.now();
            let b = 0;
            for (; this.accumulator >= o && b < h && (this.internalStep(o),
            this.accumulator -= o,
            b++,
            !(cannon_es_performance.now() - _ > 1e3 * o)); )
                ;
            this.accumulator = this.accumulator % o;
            const _e = this.accumulator / o;
            for (let nt = 0; nt !== this.bodies.length; nt++) {
                const it = this.bodies[nt];
                it.previousPosition.lerp(it.position, _e, it.interpolatedPosition),
                it.previousQuaternion.slerp(it.quaternion, _e, it.interpolatedQuaternion),
                it.previousQuaternion.normalize()
            }
            this.time += c
        }
    }
    internalStep(o) {
        this.dt = o;
        const c = this.contacts
          , h = World_step_p1
          , _ = World_step_p2
          , b = this.bodies.length
          , _e = this.bodies
          , nt = this.solver
          , it = this.gravity
          , at = this.doProfiling
          , ut = this.profile
          , pt = Body.DYNAMIC;
        let ht = -1 / 0;
        const _t = this.constraints
          , vt = World_step_frictionEquationPool;
        it.length();
        const bt = it.x
          , St = it.y
          , At = it.z;
        let Et = 0;
        for (at && (ht = cannon_es_performance.now()),
        Et = 0; Et !== b; Et++) {
            const Jt = _e[Et];
            if (Jt.type === pt) {
                const or = Jt.force
                  , ir = Jt.mass;
                or.x += ir * bt,
                or.y += ir * St,
                or.z += ir * At
            }
        }
        for (let Jt = 0, or = this.subsystems.length; Jt !== or; Jt++)
            this.subsystems[Jt].update();
        at && (ht = cannon_es_performance.now()),
        h.length = 0,
        _.length = 0,
        this.broadphase.collisionPairs(this, h, _),
        at && (ut.broadphase = cannon_es_performance.now() - ht);
        let Pt = _t.length;
        for (Et = 0; Et !== Pt; Et++) {
            const Jt = _t[Et];
            if (!Jt.collideConnected)
                for (let or = h.length - 1; or >= 0; or -= 1)
                    (Jt.bodyA === h[or] && Jt.bodyB === _[or] || Jt.bodyB === h[or] && Jt.bodyA === _[or]) && (h.splice(or, 1),
                    _.splice(or, 1))
        }
        this.collisionMatrixTick(),
        at && (ht = cannon_es_performance.now());
        const It = World_step_oldContacts
          , Dt = c.length;
        for (Et = 0; Et !== Dt; Et++)
            It.push(c[Et]);
        c.length = 0;
        const Gt = this.frictionEquations.length;
        for (Et = 0; Et !== Gt; Et++)
            vt.push(this.frictionEquations[Et]);
        for (this.frictionEquations.length = 0,
        this.narrowphase.getContacts(h, _, this, c, It, this.frictionEquations, vt),
        at && (ut.narrowphase = cannon_es_performance.now() - ht),
        at && (ht = cannon_es_performance.now()),
        Et = 0; Et < this.frictionEquations.length; Et++)
            nt.addEquation(this.frictionEquations[Et]);
        const Bt = c.length;
        for (let Jt = 0; Jt !== Bt; Jt++) {
            const or = c[Jt]
              , ir = or.bi
              , lr = or.bj
              , ar = or.si
              , hr = or.sj;
            let gr;
            gr = ir.material && lr.material && this.getContactMaterial(ir.material, lr.material) || this.defaultContactMaterial,
            gr.friction,
            ir.material && lr.material && (ir.material.friction >= 0 && lr.material.friction >= 0 && (ir.material.friction,
            lr.material.friction),
            ir.material.restitution >= 0 && lr.material.restitution >= 0 && (or.restitution = ir.material.restitution * lr.material.restitution)),
            nt.addEquation(or),
            ir.allowSleep && ir.type === Body.DYNAMIC && ir.sleepState === Body.SLEEPING && lr.sleepState === Body.AWAKE && lr.type !== Body.STATIC && lr.velocity.lengthSquared() + lr.angularVelocity.lengthSquared() >= 2 * lr.sleepSpeedLimit ** 2 && (ir.wakeUpAfterNarrowphase = !0),
            lr.allowSleep && lr.type === Body.DYNAMIC && lr.sleepState === Body.SLEEPING && ir.sleepState === Body.AWAKE && ir.type !== Body.STATIC && ir.velocity.lengthSquared() + ir.angularVelocity.lengthSquared() >= 2 * ir.sleepSpeedLimit ** 2 && (lr.wakeUpAfterNarrowphase = !0),
            this.collisionMatrix.set(ir, lr, !0),
            this.collisionMatrixPrevious.get(ir, lr) || (World_step_collideEvent.body = lr,
            World_step_collideEvent.contact = or,
            ir.dispatchEvent(World_step_collideEvent),
            World_step_collideEvent.body = ir,
            lr.dispatchEvent(World_step_collideEvent)),
            this.bodyOverlapKeeper.set(ir.id, lr.id),
            this.shapeOverlapKeeper.set(ar.id, hr.id)
        }
        for (this.emitContactEvents(),
        at && (ut.makeContactConstraints = cannon_es_performance.now() - ht,
        ht = cannon_es_performance.now()),
        Et = 0; Et !== b; Et++) {
            const Jt = _e[Et];
            Jt.wakeUpAfterNarrowphase && (Jt.wakeUp(),
            Jt.wakeUpAfterNarrowphase = !1)
        }
        for (Pt = _t.length,
        Et = 0; Et !== Pt; Et++) {
            const Jt = _t[Et];
            Jt.update();
            for (let or = 0, ir = Jt.equations.length; or !== ir; or++) {
                const lr = Jt.equations[or];
                nt.addEquation(lr)
            }
        }
        nt.solve(o, this),
        at && (ut.solve = cannon_es_performance.now() - ht),
        nt.removeAllEquations();
        const kt = Math.pow;
        for (Et = 0; Et !== b; Et++) {
            const Jt = _e[Et];
            if (Jt.type & pt) {
                const or = kt(1 - Jt.linearDamping, o)
                  , ir = Jt.velocity;
                ir.scale(or, ir);
                const lr = Jt.angularVelocity;
                if (lr) {
                    const ar = kt(1 - Jt.angularDamping, o);
                    lr.scale(ar, lr)
                }
            }
        }
        this.dispatchEvent(World_step_preStepEvent),
        at && (ht = cannon_es_performance.now());
        const Ut = this.stepnumber % (this.quatNormalizeSkip + 1) == 0
          , Ht = this.quatNormalizeFast;
        for (Et = 0; Et !== b; Et++)
            _e[Et].integrate(o, Ut, Ht);
        this.clearForces(),
        this.broadphase.dirty = !0,
        at && (ut.integrate = cannon_es_performance.now() - ht),
        this.stepnumber += 1,
        this.dispatchEvent(World_step_postStepEvent);
        let Kt = !0;
        if (this.allowSleep)
            for (Kt = !1,
            Et = 0; Et !== b; Et++) {
                const Jt = _e[Et];
                Jt.sleepTick(this.time),
                Jt.sleepState !== Body.SLEEPING && (Kt = !0)
            }
        this.hasActiveBodies = Kt
    }
    emitContactEvents() {
        const o = this.hasAnyEventListener("beginContact")
          , c = this.hasAnyEventListener("endContact");
        if ((o || c) && this.bodyOverlapKeeper.getDiff(additions, removals),
        o) {
            for (let b = 0, _e = additions.length; b < _e; b += 2)
                beginContactEvent.bodyA = this.getBodyById(additions[b]),
                beginContactEvent.bodyB = this.getBodyById(additions[b + 1]),
                this.dispatchEvent(beginContactEvent);
            beginContactEvent.bodyA = beginContactEvent.bodyB = null
        }
        if (c) {
            for (let b = 0, _e = removals.length; b < _e; b += 2)
                endContactEvent.bodyA = this.getBodyById(removals[b]),
                endContactEvent.bodyB = this.getBodyById(removals[b + 1]),
                this.dispatchEvent(endContactEvent);
            endContactEvent.bodyA = endContactEvent.bodyB = null
        }
        additions.length = removals.length = 0;
        const h = this.hasAnyEventListener("beginShapeContact")
          , _ = this.hasAnyEventListener("endShapeContact");
        if ((h || _) && this.shapeOverlapKeeper.getDiff(additions, removals),
        h) {
            for (let b = 0, _e = additions.length; b < _e; b += 2) {
                const nt = this.getShapeById(additions[b])
                  , it = this.getShapeById(additions[b + 1]);
                beginShapeContactEvent.shapeA = nt,
                beginShapeContactEvent.shapeB = it,
                nt && (beginShapeContactEvent.bodyA = nt.body),
                it && (beginShapeContactEvent.bodyB = it.body),
                this.dispatchEvent(beginShapeContactEvent)
            }
            beginShapeContactEvent.bodyA = beginShapeContactEvent.bodyB = beginShapeContactEvent.shapeA = beginShapeContactEvent.shapeB = null
        }
        if (_) {
            for (let b = 0, _e = removals.length; b < _e; b += 2) {
                const nt = this.getShapeById(removals[b])
                  , it = this.getShapeById(removals[b + 1]);
                endShapeContactEvent.shapeA = nt,
                endShapeContactEvent.shapeB = it,
                nt && (endShapeContactEvent.bodyA = nt.body),
                it && (endShapeContactEvent.bodyB = it.body),
                this.dispatchEvent(endShapeContactEvent)
            }
            endShapeContactEvent.bodyA = endShapeContactEvent.bodyB = endShapeContactEvent.shapeA = endShapeContactEvent.shapeB = null
        }
    }
    clearForces() {
        const o = this.bodies
          , c = o.length;
        for (let h = 0; h !== c; h++) {
            const _ = o[h];
            _.force,
            _.torque,
            _.force.set(0, 0, 0),
            _.torque.set(0, 0, 0)
        }
    }
}
new AABB;
const tmpRay = new Ray
  , cannon_es_performance = globalThis.performance || {};
if (!cannon_es_performance.now) {
    let d = Date.now();
    cannon_es_performance.timing && cannon_es_performance.timing.navigationStart && (d = cannon_es_performance.timing.navigationStart),
    cannon_es_performance.now = () => Date.now() - d
}
new Vec3;
const World_step_postStepEvent = {
    type: "postStep"
}
  , World_step_preStepEvent = {
    type: "preStep"
}
  , World_step_collideEvent = {
    type: Body.COLLIDE_EVENT_NAME,
    body: null,
    contact: null
}
  , World_step_oldContacts = []
  , World_step_frictionEquationPool = []
  , World_step_p1 = []
  , World_step_p2 = []
  , additions = []
  , removals = []
  , beginContactEvent = {
    type: "beginContact",
    bodyA: null,
    bodyB: null
}
  , endContactEvent = {
    type: "endContact",
    bodyA: null,
    bodyB: null
}
  , beginShapeContactEvent = {
    type: "beginShapeContact",
    bodyA: null,
    bodyB: null,
    shapeA: null,
    shapeB: null
}
  , endShapeContactEvent = {
    type: "endShapeContact",
    bodyA: null,
    bodyB: null,
    shapeA: null,
    shapeB: null
};
var ConvexHull = function() {
    var d, o, c, h = new three_module.Pq0;
    function _() {
        this.tolerance = -1,
        this.faces = [],
        this.newFaces = [],
        this.assigned = new it,
        this.unassigned = new it,
        this.vertices = []
    }
    function b() {
        this.normal = new three_module.Pq0,
        this.midpoint = new three_module.Pq0,
        this.area = 0,
        this.constant = 0,
        this.outside = null,
        this.mark = 0,
        this.edge = null
    }
    function _e(at, ut) {
        this.vertex = at,
        this.prev = null,
        this.next = null,
        this.twin = null,
        this.face = ut
    }
    function nt(at, ut) {
        this.point = at,
        this.index = ut,
        this.prev = null,
        this.next = null,
        this.face = null
    }
    function it() {
        this.head = null,
        this.tail = null
    }
    return Object.assign(_.prototype, {
        toJSON: function() {
            const at = this.faces.map(vt => vt.toArray())
              , ut = Array.from(new Set(at.flat())).sort()
              , pt = [];
            for (let vt = 0; vt < ut.length; vt++)
                pt.push(this.vertices[ut[vt]].point.x, this.vertices[ut[vt]].point.y, this.vertices[ut[vt]].point.z);
            const ht = new Map;
            for (let vt = 0; vt < ut.length; vt++)
                ht.set(ut[vt], vt);
            const _t = [];
            for (let vt = 0; vt < at.length; vt++)
                _t.push([ht.get(at[vt][0]), ht.get(at[vt][1]), ht.get(at[vt][2])]);
            return [pt, _t]
        },
        setFromPoints: function(at) {
            Array.isArray(at) !== !0 && console.error("THREE.ConvexHull: Points parameter is not an array."),
            at.length < 4 && console.error("THREE.ConvexHull: The algorithm needs at least four points."),
            this.makeEmpty();
            for (var ut = 0, pt = at.length; ut < pt; ut++)
                this.vertices.push(new nt(at[ut],ut));
            return this.compute(),
            this
        },
        setFromObject: function(at) {
            var ut = [];
            return at.updateMatrixWorld(!0),
            at.traverse(function(pt) {
                var ht, _t, vt, bt = pt.geometry;
                if (bt !== void 0 && (bt.isGeometry && (bt = bt.toBufferGeometry ? bt.toBufferGeometry() : new BufferGeometry().fromGeometry(bt)),
                bt.isBufferGeometry)) {
                    var St = bt.attributes.position;
                    if (St !== void 0)
                        for (ht = 0,
                        _t = St.count; ht < _t; ht++)
                            (vt = new three_module.Pq0).fromBufferAttribute(St, ht).applyMatrix4(pt.matrixWorld),
                            ut.push(vt)
                }
            }),
            this.setFromPoints(ut)
        },
        containsPoint: function(at) {
            for (var ut = this.faces, pt = 0, ht = ut.length; pt < ht; pt++)
                if (ut[pt].distanceToPoint(at) > this.tolerance)
                    return !1;
            return !0
        },
        intersectRay: function(at, ut) {
            for (var pt = this.faces, ht = -1 / 0, _t = 1 / 0, vt = 0, bt = pt.length; vt < bt; vt++) {
                var St = pt[vt]
                  , At = St.distanceToPoint(at.origin)
                  , Et = St.normal.dot(at.direction);
                if (At > 0 && Et >= 0)
                    return null;
                var Pt = Et !== 0 ? -At / Et : 0;
                if (!(Pt <= 0) && (Et > 0 ? _t = Math.min(Pt, _t) : ht = Math.max(Pt, ht),
                ht > _t))
                    return null
            }
            return ht !== -1 / 0 ? at.at(ht, ut) : at.at(_t, ut),
            ut
        },
        intersectsRay: function(at) {
            return this.intersectRay(at, h) !== null
        },
        makeEmpty: function() {
            return this.faces = [],
            this.vertices = [],
            this
        },
        addVertexToFace: function(at, ut) {
            return at.face = ut,
            ut.outside === null ? this.assigned.append(at) : this.assigned.insertBefore(ut.outside, at),
            ut.outside = at,
            this
        },
        removeVertexFromFace: function(at, ut) {
            return at === ut.outside && (at.next !== null && at.next.face === ut ? ut.outside = at.next : ut.outside = null),
            this.assigned.remove(at),
            this
        },
        removeAllVerticesFromFace: function(at) {
            if (at.outside !== null) {
                for (var ut = at.outside, pt = at.outside; pt.next !== null && pt.next.face === at; )
                    pt = pt.next;
                return this.assigned.removeSubList(ut, pt),
                ut.prev = pt.next = null,
                at.outside = null,
                ut
            }
        },
        deleteFaceVertices: function(at, ut) {
            var pt = this.removeAllVerticesFromFace(at);
            if (pt !== void 0)
                if (ut === void 0)
                    this.unassigned.appendChain(pt);
                else {
                    var ht = pt;
                    do {
                        var _t = ht.next;
                        ut.distanceToPoint(ht.point) > this.tolerance ? this.addVertexToFace(ht, ut) : this.unassigned.append(ht),
                        ht = _t
                    } while (ht !== null)
                }
            return this
        },
        resolveUnassignedPoints: function(at) {
            if (this.unassigned.isEmpty() === !1) {
                var ut = this.unassigned.first();
                do {
                    for (var pt = ut.next, ht = this.tolerance, _t = null, vt = 0; vt < at.length; vt++) {
                        var bt = at[vt];
                        if (bt.mark === 0) {
                            var St = bt.distanceToPoint(ut.point);
                            if (St > ht && (ht = St,
                            _t = bt),
                            ht > 1e3 * this.tolerance)
                                break
                        }
                    }
                    _t !== null && this.addVertexToFace(ut, _t),
                    ut = pt
                } while (ut !== null)
            }
            return this
        },
        computeExtremes: function() {
            var at, ut, pt, ht = new three_module.Pq0, _t = new three_module.Pq0, vt = [], bt = [];
            for (at = 0; at < 3; at++)
                vt[at] = bt[at] = this.vertices[0];
            for (ht.copy(this.vertices[0].point),
            _t.copy(this.vertices[0].point),
            at = 0,
            ut = this.vertices.length; at < ut; at++) {
                var St = this.vertices[at]
                  , At = St.point;
                for (pt = 0; pt < 3; pt++)
                    At.getComponent(pt) < ht.getComponent(pt) && (ht.setComponent(pt, At.getComponent(pt)),
                    vt[pt] = St);
                for (pt = 0; pt < 3; pt++)
                    At.getComponent(pt) > _t.getComponent(pt) && (_t.setComponent(pt, At.getComponent(pt)),
                    bt[pt] = St)
            }
            return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(ht.x), Math.abs(_t.x)) + Math.max(Math.abs(ht.y), Math.abs(_t.y)) + Math.max(Math.abs(ht.z), Math.abs(_t.z))),
            {
                min: vt,
                max: bt
            }
        },
        computeInitialHull: function() {
            d === void 0 && (d = new three_module.cZY,
            o = new three_module.Zcv,
            c = new three_module.Pq0);
            var at, ut, pt, ht, _t, vt, bt, St, At, Et = this.vertices, Pt = this.computeExtremes(), It = Pt.min, Dt = Pt.max, Gt = 0, Bt = 0;
            for (vt = 0; vt < 3; vt++)
                (At = Dt[vt].point.getComponent(vt) - It[vt].point.getComponent(vt)) > Gt && (Gt = At,
                Bt = vt);
            for (ut = It[Bt],
            pt = Dt[Bt],
            Gt = 0,
            d.set(ut.point, pt.point),
            vt = 0,
            bt = this.vertices.length; vt < bt; vt++)
                (at = Et[vt]) !== ut && at !== pt && (d.closestPointToPoint(at.point, !0, c),
                (At = c.distanceToSquared(at.point)) > Gt && (Gt = At,
                ht = at));
            for (Gt = -1,
            o.setFromCoplanarPoints(ut.point, pt.point, ht.point),
            vt = 0,
            bt = this.vertices.length; vt < bt; vt++)
                (at = Et[vt]) !== ut && at !== pt && at !== ht && (At = Math.abs(o.distanceToPoint(at.point))) > Gt && (Gt = At,
                _t = at);
            var kt = [];
            if (o.distanceToPoint(_t.point) < 0)
                for (kt.push(b.create(ut, pt, ht), b.create(_t, pt, ut), b.create(_t, ht, pt), b.create(_t, ut, ht)),
                vt = 0; vt < 3; vt++)
                    St = (vt + 1) % 3,
                    kt[vt + 1].getEdge(2).setTwin(kt[0].getEdge(St)),
                    kt[vt + 1].getEdge(1).setTwin(kt[St + 1].getEdge(0));
            else
                for (kt.push(b.create(ut, ht, pt), b.create(_t, ut, pt), b.create(_t, pt, ht), b.create(_t, ht, ut)),
                vt = 0; vt < 3; vt++)
                    St = (vt + 1) % 3,
                    kt[vt + 1].getEdge(2).setTwin(kt[0].getEdge((3 - vt) % 3)),
                    kt[vt + 1].getEdge(0).setTwin(kt[St + 1].getEdge(1));
            for (vt = 0; vt < 4; vt++)
                this.faces.push(kt[vt]);
            for (vt = 0,
            bt = Et.length; vt < bt; vt++)
                if ((at = Et[vt]) !== ut && at !== pt && at !== ht && at !== _t) {
                    Gt = this.tolerance;
                    var Ut = null;
                    for (St = 0; St < 4; St++)
                        (At = this.faces[St].distanceToPoint(at.point)) > Gt && (Gt = At,
                        Ut = this.faces[St]);
                    Ut !== null && this.addVertexToFace(at, Ut)
                }
            return this
        },
        reindexFaces: function() {
            for (var at = [], ut = 0; ut < this.faces.length; ut++) {
                var pt = this.faces[ut];
                pt.mark === 0 && at.push(pt)
            }
            return this.faces = at,
            this
        },
        nextVertexToAdd: function() {
            if (this.assigned.isEmpty() === !1) {
                var at, ut = 0, pt = this.assigned.first().face, ht = pt.outside;
                do {
                    var _t = pt.distanceToPoint(ht.point);
                    _t > ut && (ut = _t,
                    at = ht),
                    ht = ht.next
                } while (ht !== null && ht.face === pt);
                return at
            }
        },
        computeHorizon: function(at, ut, pt, ht) {
            var _t;
            this.deleteFaceVertices(pt),
            pt.mark = 1,
            _t = ut === null ? ut = pt.getEdge(0) : ut.next;
            do {
                var vt = _t.twin
                  , bt = vt.face;
                bt.mark === 0 && (bt.distanceToPoint(at) > this.tolerance ? this.computeHorizon(at, vt, bt, ht) : ht.push(_t)),
                _t = _t.next
            } while (_t !== ut);
            return this
        },
        addAdjoiningFace: function(at, ut) {
            var pt = b.create(at, ut.tail(), ut.head());
            return this.faces.push(pt),
            pt.getEdge(-1).setTwin(ut.twin),
            pt.getEdge(0)
        },
        addNewFaces: function(at, ut) {
            this.newFaces = [];
            for (var pt = null, ht = null, _t = 0; _t < ut.length; _t++) {
                var vt = ut[_t]
                  , bt = this.addAdjoiningFace(at, vt);
                pt === null ? pt = bt : bt.next.setTwin(ht),
                this.newFaces.push(bt.face),
                ht = bt
            }
            return pt.next.setTwin(ht),
            this
        },
        addVertexToHull: function(at) {
            var ut = [];
            return this.unassigned.clear(),
            this.removeVertexFromFace(at, at.face),
            this.computeHorizon(at.point, null, at.face, ut),
            this.addNewFaces(at, ut),
            this.resolveUnassignedPoints(this.newFaces),
            this
        },
        cleanup: function() {
            return this.assigned.clear(),
            this.unassigned.clear(),
            this.newFaces = [],
            this
        },
        compute: function() {
            var at;
            for (this.computeInitialHull(); (at = this.nextVertexToAdd()) !== void 0; )
                this.addVertexToHull(at);
            return this.reindexFaces(),
            this.cleanup(),
            this
        }
    }),
    Object.assign(b, {
        create: function(at, ut, pt) {
            var ht = new b
              , _t = new _e(at,ht)
              , vt = new _e(ut,ht)
              , bt = new _e(pt,ht);
            return _t.next = bt.prev = vt,
            vt.next = _t.prev = bt,
            bt.next = vt.prev = _t,
            ht.edge = _t,
            ht.compute()
        }
    }),
    Object.assign(b.prototype, {
        toArray: function() {
            const at = [];
            let ut = this.edge;
            do
                at.push(ut.head().index),
                ut = ut.next;
            while (ut !== this.edge);
            return at
        },
        getEdge: function(at) {
            for (var ut = this.edge; at > 0; )
                ut = ut.next,
                at--;
            for (; at < 0; )
                ut = ut.prev,
                at++;
            return ut
        },
        compute: function() {
            var at;
            return function() {
                at === void 0 && (at = new three_module.lMl);
                var ut = this.edge.tail()
                  , pt = this.edge.head()
                  , ht = this.edge.next.head();
                return at.set(ut.point, pt.point, ht.point),
                at.getNormal(this.normal),
                at.getMidpoint(this.midpoint),
                this.area = at.getArea(),
                this.constant = this.normal.dot(this.midpoint),
                this
            }
        }(),
        distanceToPoint: function(at) {
            return this.normal.dot(at) - this.constant
        }
    }),
    Object.assign(_e.prototype, {
        head: function() {
            return this.vertex
        },
        tail: function() {
            return this.prev ? this.prev.vertex : null
        },
        length: function() {
            var at = this.head()
              , ut = this.tail();
            return ut !== null ? ut.point.distanceTo(at.point) : -1
        },
        lengthSquared: function() {
            var at = this.head()
              , ut = this.tail();
            return ut !== null ? ut.point.distanceToSquared(at.point) : -1
        },
        setTwin: function(at) {
            return this.twin = at,
            at.twin = this,
            this
        }
    }),
    Object.assign(it.prototype, {
        first: function() {
            return this.head
        },
        last: function() {
            return this.tail
        },
        clear: function() {
            return this.head = this.tail = null,
            this
        },
        insertBefore: function(at, ut) {
            return ut.prev = at.prev,
            ut.next = at,
            ut.prev === null ? this.head = ut : ut.prev.next = ut,
            at.prev = ut,
            this
        },
        insertAfter: function(at, ut) {
            return ut.prev = at,
            ut.next = at.next,
            ut.next === null ? this.tail = ut : ut.next.prev = ut,
            at.next = ut,
            this
        },
        append: function(at) {
            return this.head === null ? this.head = at : this.tail.next = at,
            at.prev = this.tail,
            at.next = null,
            this.tail = at,
            this
        },
        appendChain: function(at) {
            for (this.head === null ? this.head = at : this.tail.next = at,
            at.prev = this.tail; at.next !== null; )
                at = at.next;
            return this.tail = at,
            this
        },
        remove: function(at) {
            return at.prev === null ? this.head = at.next : at.prev.next = at.next,
            at.next === null ? this.tail = at.prev : at.next.prev = at.prev,
            this
        },
        removeSubList: function(at, ut) {
            return at.prev === null ? this.head = ut.next : at.prev.next = ut.next,
            ut.next === null ? this.tail = at.prev : ut.next.prev = at.prev,
            this
        },
        isEmpty: function() {
            return this.head === null
        }
    }),
    _
}();
const three_to_cannon_modern_v1 = new three_module.Pq0
  , _v2 = new three_module.Pq0
  , three_to_cannon_modern_q1 = new three_module.PTz;
function getGeometry(d) {
    const o = getMeshes(d);
    if (o.length === 0)
        return null;
    if (o.length === 1)
        return normalizeGeometry(o[0]);
    let c;
    const h = [];
    for (; c = o.pop(); )
        h.push(simplifyGeometry(normalizeGeometry(c)));
    return three_to_cannon_modern_mergeBufferGeometries(h)
}
function normalizeGeometry(d) {
    let o = d.geometry;
    return o = o.toBufferGeometry ? o.toBufferGeometry() : o.clone(),
    d.updateMatrixWorld(),
    d.matrixWorld.decompose(three_to_cannon_modern_v1, three_to_cannon_modern_q1, _v2),
    o.scale(_v2.x, _v2.y, _v2.z),
    o
}
function three_to_cannon_modern_mergeBufferGeometries(d) {
    let o = 0;
    for (let _ = 0; _ < d.length; _++) {
        const b = d[_].attributes.position;
        b && b.itemSize === 3 && (o += b.count)
    }
    const c = new Float32Array(3 * o);
    let h = 0;
    for (let _ = 0; _ < d.length; _++) {
        const b = d[_].attributes.position;
        if (b && b.itemSize === 3)
            for (let _e = 0; _e < b.count; _e++)
                c[h++] = b.getX(_e),
                c[h++] = b.getY(_e),
                c[h++] = b.getZ(_e)
    }
    return new three_module.LoY().setAttribute("position", new three_module.THS(c,3))
}
function getVertices(d) {
    const o = d.attributes.position
      , c = new Float32Array(3 * o.count);
    for (let h = 0; h < o.count; h++)
        c[3 * h] = o.getX(h),
        c[3 * h + 1] = o.getY(h),
        c[3 * h + 2] = o.getZ(h);
    return c
}
function getMeshes(d) {
    const o = [];
    return d.traverse(function(c) {
        c.isMesh && o.push(c)
    }),
    o
}
function getComponent(d, o) {
    switch (o) {
    case "x":
        return d.x;
    case "y":
        return d.y;
    case "z":
        return d.z
    }
    throw new Error(`Unexpected component ${o}`)
}
function simplifyGeometry(d, o=1e-4) {
    o = Math.max(o, Number.EPSILON);
    const c = {}
      , h = d.getIndex()
      , _ = d.getAttribute("position")
      , b = h ? h.count : _.count;
    let _e = 0;
    const nt = []
      , it = []
      , at = Math.log10(1 / o)
      , ut = Math.pow(10, at);
    for (let _t = 0; _t < b; _t++) {
        const vt = h ? h.getX(_t) : _t;
        let bt = "";
        bt += ~~(_.getX(vt) * ut) + ",",
        bt += ~~(_.getY(vt) * ut) + ",",
        bt += ~~(_.getZ(vt) * ut) + ",",
        bt in c ? nt.push(c[bt]) : (it.push(_.getX(vt)),
        it.push(_.getY(vt)),
        it.push(_.getZ(vt)),
        c[bt] = _e,
        nt.push(_e),
        _e++)
    }
    const pt = new three_module.THS(new Float32Array(it),_.itemSize,_.normalized)
      , ht = new three_module.LoY;
    return ht.setAttribute("position", pt),
    ht.setIndex(nt),
    ht
}
const PI_2 = Math.PI / 2;
var ShapeType;
(function(d) {
    d.BOX = "Box",
    d.CYLINDER = "Cylinder",
    d.SPHERE = "Sphere",
    d.HULL = "ConvexPolyhedron",
    d.MESH = "Trimesh"
}
)(ShapeType || (ShapeType = {}));
const getShapeParameters = function(d, o={}) {
    let c;
    if (o.type === ShapeType.BOX)
        return getBoundingBoxParameters(d);
    if (o.type === ShapeType.CYLINDER)
        return getBoundingCylinderParameters(d, o);
    if (o.type === ShapeType.SPHERE)
        return getBoundingSphereParameters(d, o);
    if (o.type === ShapeType.HULL)
        return getConvexPolyhedronParameters(d);
    if (o.type === ShapeType.MESH)
        return c = getGeometry(d),
        c ? getTrimeshParameters(c) : null;
    if (o.type)
        throw new Error(`[CANNON.getShapeParameters] Invalid type "${o.type}".`);
    if (c = getGeometry(d),
    !c)
        return null;
    switch (c.type) {
    case "BoxGeometry":
    case "BoxBufferGeometry":
        return getBoxParameters(c);
    case "CylinderGeometry":
    case "CylinderBufferGeometry":
        return getCylinderParameters(c);
    case "PlaneGeometry":
    case "PlaneBufferGeometry":
        return getPlaneParameters(c);
    case "SphereGeometry":
    case "SphereBufferGeometry":
        return getSphereParameters(c);
    case "TubeGeometry":
    case "BufferGeometry":
        return getBoundingBoxParameters(d);
    default:
        return console.warn('Unrecognized geometry: "%s". Using bounding box as shape.', c.type),
        getBoxParameters(c)
    }
}
  , threeToCannon = function(d, o={}) {
    const c = getShapeParameters(d, o);
    if (!c)
        return null;
    const {type: h, params: _, offset: b, orientation: _e} = c;
    let nt;
    return nt = h === ShapeType.BOX ? createBox$1(_) : h === ShapeType.CYLINDER ? createCylinder(_) : h === ShapeType.SPHERE ? createSphere(_) : h === ShapeType.HULL ? createConvexPolyhedron(_) : createTrimesh(_),
    {
        shape: nt,
        offset: b,
        orientation: _e
    }
};
function createBox$1(d) {
    const {x: o, y: c, z: h} = d;
    return new Box(new Vec3(o,c,h))
}
function createCylinder(d) {
    const {radiusTop: o, radiusBottom: c, height: h, segments: _} = d
      , b = new Cylinder(o,c,h,_);
    return b.radiusTop = c,
    b.radiusBottom = c,
    b.height = h,
    b.numSegments = _,
    b
}
function createSphere(d) {
    return new Sphere(d.radius)
}
function createConvexPolyhedron(d) {
    const {faces: o, vertices: c} = d
      , h = [];
    for (let _ = 0; _ < c.length; _ += 3)
        h.push(new Vec3(c[_],c[_ + 1],c[_ + 2]));
    return new ConvexPolyhedron({
        faces: o,
        vertices: h
    })
}
function createTrimesh(d) {
    const {vertices: o, indices: c} = d;
    return new Trimesh(o,c)
}
function getBoxParameters(d) {
    if (!getVertices(d).length)
        return null;
    d.computeBoundingBox();
    const o = d.boundingBox;
    return {
        type: ShapeType.BOX,
        params: {
            x: (o.max.x - o.min.x) / 2,
            y: (o.max.y - o.min.y) / 2,
            z: (o.max.z - o.min.z) / 2
        }
    }
}
function getBoundingBoxParameters(d) {
    const o = d.clone();
    o.quaternion.set(0, 0, 0, 1),
    o.updateMatrixWorld();
    const c = new three_module.NRn().setFromObject(o);
    if (!isFinite(c.min.lengthSq()))
        return null;
    const h = c.translate(o.position.negate()).getCenter(new three_module.Pq0);
    return {
        type: ShapeType.BOX,
        params: {
            x: (c.max.x - c.min.x) / 2,
            y: (c.max.y - c.min.y) / 2,
            z: (c.max.z - c.min.z) / 2
        },
        offset: h.lengthSq() ? new Vec3(h.x,h.y,h.z) : void 0
    }
}
function getConvexPolyhedronParameters(d) {
    const o = getGeometry(d);
    if (!o)
        return null;
    const c = 1e-4;
    for (let b = 0; b < o.attributes.position.count; b++)
        o.attributes.position.setXYZ(b, o.attributes.position.getX(b) + (Math.random() - .5) * c, o.attributes.position.getY(b) + (Math.random() - .5) * c, o.attributes.position.getZ(b) + (Math.random() - .5) * c);
    const [h,_] = new ConvexHull().setFromObject(new three_module.eaF(o)).toJSON();
    return {
        type: ShapeType.HULL,
        params: {
            vertices: new Float32Array(h),
            faces: _
        }
    }
}
function getCylinderParameters(d) {
    const o = d.parameters;
    return {
        type: ShapeType.CYLINDER,
        params: {
            radiusTop: o.radiusTop,
            radiusBottom: o.radiusBottom,
            height: o.height,
            segments: o.radialSegments
        },
        orientation: new Quaternion().setFromEuler(three_module.cj9.degToRad(-90), 0, 0, "XYZ").normalize()
    }
}
function getBoundingCylinderParameters(d, o) {
    const c = ["x", "y", "z"]
      , h = o.cylinderAxis || "y"
      , _ = c.splice(c.indexOf(h), 1) && c
      , b = new three_module.NRn().setFromObject(d);
    if (!isFinite(b.min.lengthSq()))
        return null;
    const _e = b.max[h] - b.min[h]
      , nt = .5 * Math.max(getComponent(b.max, _[0]) - getComponent(b.min, _[0]), getComponent(b.max, _[1]) - getComponent(b.min, _[1]))
      , it = h === "y" ? PI_2 : 0
      , at = h === "z" ? PI_2 : 0;
    return {
        type: ShapeType.CYLINDER,
        params: {
            radiusTop: nt,
            radiusBottom: nt,
            height: _e,
            segments: 12
        },
        orientation: new Quaternion().setFromEuler(it, at, 0, "XYZ").normalize()
    }
}
function getPlaneParameters(d) {
    d.computeBoundingBox();
    const o = d.boundingBox;
    return {
        type: ShapeType.BOX,
        params: {
            x: (o.max.x - o.min.x) / 2 || .1,
            y: (o.max.y - o.min.y) / 2 || .1,
            z: (o.max.z - o.min.z) / 2 || .1
        }
    }
}
function getSphereParameters(d) {
    return {
        type: ShapeType.SPHERE,
        params: {
            radius: d.parameters.radius
        }
    }
}
function getBoundingSphereParameters(d, o) {
    if (o.sphereRadius)
        return {
            type: ShapeType.SPHERE,
            params: {
                radius: o.sphereRadius
            }
        };
    const c = getGeometry(d);
    return c ? (c.computeBoundingSphere(),
    {
        type: ShapeType.SPHERE,
        params: {
            radius: c.boundingSphere.radius
        }
    }) : null
}
function getTrimeshParameters(d) {
    const o = getVertices(d);
    if (!o.length)
        return null;
    const c = new Uint32Array(o.length);
    for (let h = 0; h < o.length; h++)
        c[h] = h;
    return {
        type: ShapeType.MESH,
        params: {
            vertices: o,
            indices: c
        }
    }
}
var CannonPhysicsPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, CannonPhysicsPlugin_1;
let CannonPhysicsPlugin = CannonPhysicsPlugin_1 = class extends AViewerPlugin {
    constructor(d=!1) {
        super(),
        this._world = new World,
        this.enabled = !0,
        this.nextSteps = 0,
        this.stepPhysics = {
            stepCount: 100,
            delta: .1,
            step: () => {
                this.nextSteps = this.stepPhysics.stepCount
            }
        },
        this.makeRootBodies = () => {
            var _;
            (_ = this._viewer) === null || _ === void 0 || _.scene.modelRoot.children.forEach(b => {
                this.makeBody(b)
            }
            )
        }
        ,
        this._bodyMeshMap = new Map,
        this._movementPlane = new three_module.eaF(new three_module.bdM(100,100),new three_module.V9B({
            color: 65280,
            side: three_module.$EB
        })),
        this.enabled = d,
        this._world.gravity.set(0, -9.81, 0);
        const o = new cannon_es_Plane
          , c = new Body({
            mass: 0,
            position: new Vec3(0,-2,0)
        });
        c.addShape(o),
        c.quaternion.setFromEuler(-Math.PI / 2, 0, 0),
        this._ground = c,
        this._world.addBody(c);
        const h = new Sphere(.1);
        this._jointBody = new Body({
            mass: 0
        }),
        this._jointBody.addShape(h),
        this._jointBody.collisionFilterGroup = 0,
        this._jointBody.collisionFilterMask = 0,
        this._world.addBody(this._jointBody)
    }
    async onAdded(d) {
        await super.onAdded(d);
        const o = new three_module.Pq0
          , c = new three_module.Pq0
          , h = new three_module.Pq0
          , _ = new three_module.PTz
          , b = new three_module.PTz
          , _e = new three_module.kn4
          , nt = new three_module.kn4;
        let it = !1
          , at = !1;
        function ut(pt) {
            const ht = d.canvas.getBoundingClientRect()
              , _t = new three_module.I9Y;
            return _t.x = (pt.clientX - ht.x) / ht.width * 2 - 1,
            _t.y = -(pt.clientY - ht.y) / ht.height * 2 + 1,
            _t
        }
        d.addEventListener("preFrame", () => {
            const pt = d.getPlugin(GroundPlugin)
              , ht = d.getPlugin(FrameFadePlugin);
            if (!this.enabled) {
                if (!(this.nextSteps > 0))
                    return pt && it && (pt.enableRefreshTransform = !0,
                    it = !1),
                    ht && at && (ht.enable(CannonPhysicsPlugin_1.PluginType),
                    at = !1),
                    void (this._dirty = !1);
                this.enabled = !0
            }
            if (pt && pt.enableRefreshTransform && !it && (pt.enableRefreshTransform = !1,
            it = !0),
            ht && !at && ht.disable(CannonPhysicsPlugin_1.PluginType),
            this.nextSteps > 0)
                for (let vt = 0; vt < this.stepPhysics.stepCount; vt++)
                    this._world.step(this.stepPhysics.delta);
            else
                this._world.fixedStep();
            this._dirty = !1;
            let _t = !1;
            for (const vt of this._world.bodies) {
                if (vt.mass === 0)
                    continue;
                const bt = this._bodyMeshMap.get(vt);
                if (bt && (bt.updateMatrixWorld(),
                bt.getWorldPosition(c),
                bt.getWorldQuaternion(b),
                bt.getWorldScale(h),
                c.manhattanDistanceTo(o.copy(vt.position)) > 0 && (_t = !0),
                b.angleTo(_.copy(vt.quaternion)) > 0 && (_t = !0),
                _t)) {
                    if (_e.compose(o, _, h),
                    !bt.parent)
                        throw new Error("no parent");
                    nt.copy(bt.parent.matrixWorld).invert(),
                    nt.multiply(_e),
                    nt.decompose(o, _, h),
                    bt.position.copy(o),
                    bt.quaternion.copy(_)
                }
            }
            this._dirty = _t,
            d.setDirty(),
            d.renderer.resetShadows(),
            pt == null || pt.bakeShadows(),
            this.nextSteps > 0 && (this.enabled = !1,
            this.nextSteps = 0)
        }
        ),
        d.scene.addEventListener("update", pt => {
            this._bodyMeshMap.forEach( (ht, _t) => {
                _t.velocity.set(0, 0, 0),
                _t.angularVelocity.set(0, 0, 0)
            }
            )
        }
        ),
        d.scene.addEventListener("addSceneObject", pt => {
            var ht;
            const _t = (ht = pt.object) === null || ht === void 0 ? void 0 : ht.modelObject;
            _t && _t.traverse(vt => {
                const bt = vt.uiConfig;
                bt && Array.isArray(bt.children) && !vt.isWidget && (bt.children.push({
                    type: "folder",
                    label: "Physics",
                    children: [{
                        type: "button",
                        label: "Make Body",
                        value: () => this.makeBody(vt)
                    }, {
                        type: "number",
                        label: "Mass",
                        hidden: () => !vt._physicsBody,
                        getValue: () => {
                            var St, At;
                            return (At = (St = vt._physicsBody) === null || St === void 0 ? void 0 : St.mass) !== null && At !== void 0 ? At : 0
                        }
                        ,
                        setValue: St => {
                            vt._physicsBody && (vt._physicsBody.mass = St)
                        }
                    }]
                }),
                vt.userData.physicsMass !== void 0 && this.makeBody(vt))
            }
            )
        }
        ),
        d.canvas.addEventListener("pointerdown", pt => {
            if (!this.enabled || !pt.isPrimary)
                return;
            d.getPlugin(PickingPlugin) && (d.getPlugin(PickingPlugin).enabled = !1);
            const ht = ut(pt)
              , _t = new three_module.tBo;
            _t.setFromCamera(ht, d.scene.activeCamera.cameraObject);
            const vt = _t.intersectObjects([...this._bodyMeshMap.values()], !0);
            if (!vt.length)
                return;
            let bt, St = null, At = vt[0];
            for (const It of vt) {
                for (St = It.object,
                At = It; !(St == null || St.visible && St.material); )
                    St = St.parent;
                if (St)
                    break
            }
            if (!St)
                return;
            for (; St.parent && !bt; ) {
                for (const [It,Dt] of this._bodyMeshMap.entries())
                    if (Dt === St) {
                        It.mass > 0 && (bt = It);
                        break
                    }
                St = St.parent
            }
            if (!bt)
                return;
            d.scene.activeCamera.setInteractions(!1, CannonPhysicsPlugin_1.PluginType),
            this._movementPlane.position.copy(At.point),
            this._movementPlane.lookAt(d.scene.activeCamera.cameraObject.getWorldPosition(new three_module.Pq0));
            const Et = new Vec3().copy(At.point).vsub(bt.position)
              , Pt = bt.quaternion.inverse().vmult(Et);
            this._jointBody.position.copy(At.point),
            this._jointConstraint = new PointToPointConstraint(bt,Pt,this._jointBody,new Vec3(0,0,0)),
            this._world.addConstraint(this._jointConstraint)
        }
        ),
        d.canvas.addEventListener("pointermove", pt => {
            if (!this.enabled || !pt.isPrimary || !this._jointConstraint)
                return;
            const ht = ut(pt)
              , _t = new three_module.tBo;
            _t.setFromCamera(ht, d.scene.activeCamera.cameraObject);
            const vt = _t.intersectObject(this._movementPlane);
            if (!vt.length)
                return;
            const bt = vt[0];
            this._jointBody.position.copy(bt.point),
            this._jointConstraint.update()
        }
        ),
        d.canvas.addEventListener("pointerup", pt => {
            this.enabled && pt.isPrimary && (d.getPlugin(PickingPlugin) && (d.getPlugin(PickingPlugin).enabled = !0),
            d.scene.activeCamera.setInteractions(!0, CannonPhysicsPlugin_1.PluginType),
            this._jointConstraint && (this._world.removeConstraint(this._jointConstraint),
            this._jointConstraint = void 0))
        }
        )
    }
    makeBody(d) {
        if (d.isLight || d._physicsBody)
            return;
        const o = [];
        let c = 0;
        if (d.updateMatrixWorld(),
        d.traverse(it => {
            var at;
            const ut = it;
            if (!ut.isMesh || !ut.material || !ut.visible)
                return;
            if (ut._physicsShape)
                return void o.push(ut._physicsShape);
            if (c += (at = ut.userData.physicsMass) !== null && at !== void 0 ? at : 1,
            ut.addEventListener("objectUpdate", () => {
                ut.userData.physicsMass === 0 && (this._ground.position.y = ut.position.y,
                this._bodyMeshMap.forEach( (ht, _t) => {
                    _t.velocity.set(0, 0, 0),
                    _t.angularVelocity.set(0, 0, 0),
                    _t.force.set(0, 0, 0),
                    _t.torque.set(0, 0, 0)
                }
                ))
            }
            ),
            ut.userData.physicsMass === 0)
                return;
            const pt = threeToCannon(ut, {
                type: ShapeType.HULL
            });
            pt ? (o.push([pt.shape, ut]),
            ut._physicsShape = pt.shape) : console.warn("Failed to convert mesh to cannon shape", ut)
        }
        ),
        !o.length)
            return;
        const h = new Body({
            mass: c,
            angularVelocity: new Vec3(0,0,0),
            velocity: new Vec3(0,0,0)
        })
          , _ = new three_module.Pq0
          , b = new three_module.PTz
          , _e = new three_module.Pq0
          , nt = new three_module.kn4;
        for (const [it,at] of o)
            at !== d ? (at.updateMatrixWorld(),
            nt.copy(d.matrixWorld).invert(),
            nt.multiply(at.matrixWorld),
            nt.decompose(_, b, _e),
            h.addShape(it, new Vec3(..._.toArray()), new Quaternion(...b.toArray()))) : h.addShape(it);
        h.position.set(...d.getWorldPosition(_).toArray()),
        h.quaternion.set(...d.getWorldQuaternion(b).toArray()),
        h.angularVelocity.set(0, 0, 0),
        h.velocity.set(0, 0, 0),
        d.addEventListener("objectUpdate", () => {
            h.position.set(...d.getWorldPosition(_).toArray()),
            h.quaternion.set(...d.getWorldQuaternion(b).toArray()),
            h.angularVelocity.set(0, 0, 0),
            h.velocity.set(0, 0, 0)
        }
        ),
        this._world.addBody(h),
        this._bodyMeshMap.set(h, d),
        d._physicsBody = h,
        d.setDirty({
            sceneUpdate: !0,
            updateGround: !1,
            frameFade: !1,
            refreshUi: !0
        })
    }
}
;
CannonPhysicsPlugin.PluginType = "CannonPhysics",
CannonPhysicsPlugin_decorate([uiToggle("Enabled", d => ({
    onChange: () => {}
})), serialize()], CannonPhysicsPlugin.prototype, "enabled", void 0),
CannonPhysicsPlugin_decorate([uiConfig()], CannonPhysicsPlugin.prototype, "stepPhysics", void 0),
CannonPhysicsPlugin_decorate([uiButton("Make Root Bodies")], CannonPhysicsPlugin.prototype, "makeRootBodies", void 0),
CannonPhysicsPlugin = CannonPhysicsPlugin_1 = CannonPhysicsPlugin_decorate([uiFolder("Physics (dev)")], CannonPhysicsPlugin);
class SimplexNoise {
    constructor(o=Math) {
        this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]],
        this.grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1], [0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1], [1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1], [-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1], [1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1], [-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1], [1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0], [-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]],
        this.p = [];
        for (let c = 0; c < 256; c++)
            this.p[c] = Math.floor(256 * o.random());
        this.perm = [];
        for (let c = 0; c < 512; c++)
            this.perm[c] = this.p[255 & c];
        this.simplex = [[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0], [0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0], [1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0], [2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]]
    }
    dot(o, c, h) {
        return o[0] * c + o[1] * h
    }
    dot3(o, c, h, _) {
        return o[0] * c + o[1] * h + o[2] * _
    }
    dot4(o, c, h, _, b) {
        return o[0] * c + o[1] * h + o[2] * _ + o[3] * b
    }
    noise(o, c) {
        let h, _, b;
        const _e = (o + c) * (.5 * (Math.sqrt(3) - 1))
          , nt = Math.floor(o + _e)
          , it = Math.floor(c + _e)
          , at = (3 - Math.sqrt(3)) / 6
          , ut = (nt + it) * at
          , pt = o - (nt - ut)
          , ht = c - (it - ut);
        let _t, vt;
        pt > ht ? (_t = 1,
        vt = 0) : (_t = 0,
        vt = 1);
        const bt = pt - _t + at
          , St = ht - vt + at
          , At = pt - 1 + 2 * at
          , Et = ht - 1 + 2 * at
          , Pt = 255 & nt
          , It = 255 & it
          , Dt = this.perm[Pt + this.perm[It]] % 12
          , Gt = this.perm[Pt + _t + this.perm[It + vt]] % 12
          , Bt = this.perm[Pt + 1 + this.perm[It + 1]] % 12;
        let kt = .5 - pt * pt - ht * ht;
        kt < 0 ? h = 0 : (kt *= kt,
        h = kt * kt * this.dot(this.grad3[Dt], pt, ht));
        let Ut = .5 - bt * bt - St * St;
        Ut < 0 ? _ = 0 : (Ut *= Ut,
        _ = Ut * Ut * this.dot(this.grad3[Gt], bt, St));
        let Ht = .5 - At * At - Et * Et;
        return Ht < 0 ? b = 0 : (Ht *= Ht,
        b = Ht * Ht * this.dot(this.grad3[Bt], At, Et)),
        70 * (h + _ + b)
    }
    noise3d(o, c, h) {
        let _, b, _e, nt;
        const it = (o + c + h) * .3333333333333333
          , at = Math.floor(o + it)
          , ut = Math.floor(c + it)
          , pt = Math.floor(h + it)
          , ht = 1 / 6
          , _t = (at + ut + pt) * ht
          , vt = o - (at - _t)
          , bt = c - (ut - _t)
          , St = h - (pt - _t);
        let At, Et, Pt, It, Dt, Gt;
        vt >= bt ? bt >= St ? (At = 1,
        Et = 0,
        Pt = 0,
        It = 1,
        Dt = 1,
        Gt = 0) : vt >= St ? (At = 1,
        Et = 0,
        Pt = 0,
        It = 1,
        Dt = 0,
        Gt = 1) : (At = 0,
        Et = 0,
        Pt = 1,
        It = 1,
        Dt = 0,
        Gt = 1) : bt < St ? (At = 0,
        Et = 0,
        Pt = 1,
        It = 0,
        Dt = 1,
        Gt = 1) : vt < St ? (At = 0,
        Et = 1,
        Pt = 0,
        It = 0,
        Dt = 1,
        Gt = 1) : (At = 0,
        Et = 1,
        Pt = 0,
        It = 1,
        Dt = 1,
        Gt = 0);
        const Bt = vt - At + ht
          , kt = bt - Et + ht
          , Ut = St - Pt + ht
          , Ht = vt - It + 2 * ht
          , Kt = bt - Dt + 2 * ht
          , Jt = St - Gt + 2 * ht
          , or = vt - 1 + .5
          , ir = bt - 1 + .5
          , lr = St - 1 + .5
          , ar = 255 & at
          , hr = 255 & ut
          , gr = 255 & pt
          , dr = this.perm[ar + this.perm[hr + this.perm[gr]]] % 12
          , cr = this.perm[ar + At + this.perm[hr + Et + this.perm[gr + Pt]]] % 12
          , Ar = this.perm[ar + It + this.perm[hr + Dt + this.perm[gr + Gt]]] % 12
          , wr = this.perm[ar + 1 + this.perm[hr + 1 + this.perm[gr + 1]]] % 12;
        let Rr = .6 - vt * vt - bt * bt - St * St;
        Rr < 0 ? _ = 0 : (Rr *= Rr,
        _ = Rr * Rr * this.dot3(this.grad3[dr], vt, bt, St));
        let Cr = .6 - Bt * Bt - kt * kt - Ut * Ut;
        Cr < 0 ? b = 0 : (Cr *= Cr,
        b = Cr * Cr * this.dot3(this.grad3[cr], Bt, kt, Ut));
        let tr = .6 - Ht * Ht - Kt * Kt - Jt * Jt;
        tr < 0 ? _e = 0 : (tr *= tr,
        _e = tr * tr * this.dot3(this.grad3[Ar], Ht, Kt, Jt));
        let fr = .6 - or * or - ir * ir - lr * lr;
        return fr < 0 ? nt = 0 : (fr *= fr,
        nt = fr * fr * this.dot3(this.grad3[wr], or, ir, lr)),
        32 * (_ + b + _e + nt)
    }
    noise4d(o, c, h, _) {
        const b = this.grad4
          , _e = this.simplex
          , nt = this.perm
          , it = (Math.sqrt(5) - 1) / 4
          , at = (5 - Math.sqrt(5)) / 20;
        let ut, pt, ht, _t, vt;
        const bt = (o + c + h + _) * it
          , St = Math.floor(o + bt)
          , At = Math.floor(c + bt)
          , Et = Math.floor(h + bt)
          , Pt = Math.floor(_ + bt)
          , It = (St + At + Et + Pt) * at
          , Dt = o - (St - It)
          , Gt = c - (At - It)
          , Bt = h - (Et - It)
          , kt = _ - (Pt - It)
          , Ut = (Dt > Gt ? 32 : 0) + (Dt > Bt ? 16 : 0) + (Gt > Bt ? 8 : 0) + (Dt > kt ? 4 : 0) + (Gt > kt ? 2 : 0) + (Bt > kt ? 1 : 0)
          , Ht = _e[Ut][0] >= 3 ? 1 : 0
          , Kt = _e[Ut][1] >= 3 ? 1 : 0
          , Jt = _e[Ut][2] >= 3 ? 1 : 0
          , or = _e[Ut][3] >= 3 ? 1 : 0
          , ir = _e[Ut][0] >= 2 ? 1 : 0
          , lr = _e[Ut][1] >= 2 ? 1 : 0
          , ar = _e[Ut][2] >= 2 ? 1 : 0
          , hr = _e[Ut][3] >= 2 ? 1 : 0
          , gr = _e[Ut][0] >= 1 ? 1 : 0
          , dr = _e[Ut][1] >= 1 ? 1 : 0
          , cr = _e[Ut][2] >= 1 ? 1 : 0
          , Ar = _e[Ut][3] >= 1 ? 1 : 0
          , wr = Dt - Ht + at
          , Rr = Gt - Kt + at
          , Cr = Bt - Jt + at
          , tr = kt - or + at
          , fr = Dt - ir + 2 * at
          , vr = Gt - lr + 2 * at
          , Zr = Bt - ar + 2 * at
          , rn = kt - hr + 2 * at
          , hn = Dt - gr + 3 * at
          , Nn = Gt - dr + 3 * at
          , Wn = Bt - cr + 3 * at
          , qn = kt - Ar + 3 * at
          , mo = Dt - 1 + 4 * at
          , Ur = Gt - 1 + 4 * at
          , nn = Bt - 1 + 4 * at
          , xn = kt - 1 + 4 * at
          , ur = 255 & St
          , pr = 255 & At
          , Ir = 255 & Et
          , jr = 255 & Pt
          , Qr = nt[ur + nt[pr + nt[Ir + nt[jr]]]] % 32
          , Or = nt[ur + Ht + nt[pr + Kt + nt[Ir + Jt + nt[jr + or]]]] % 32
          , qr = nt[ur + ir + nt[pr + lr + nt[Ir + ar + nt[jr + hr]]]] % 32
          , gn = nt[ur + gr + nt[pr + dr + nt[Ir + cr + nt[jr + Ar]]]] % 32
          , Mn = nt[ur + 1 + nt[pr + 1 + nt[Ir + 1 + nt[jr + 1]]]] % 32;
        let Tn = .6 - Dt * Dt - Gt * Gt - Bt * Bt - kt * kt;
        Tn < 0 ? ut = 0 : (Tn *= Tn,
        ut = Tn * Tn * this.dot4(b[Qr], Dt, Gt, Bt, kt));
        let wn = .6 - wr * wr - Rr * Rr - Cr * Cr - tr * tr;
        wn < 0 ? pt = 0 : (wn *= wn,
        pt = wn * wn * this.dot4(b[Or], wr, Rr, Cr, tr));
        let Cn = .6 - fr * fr - vr * vr - Zr * Zr - rn * rn;
        Cn < 0 ? ht = 0 : (Cn *= Cn,
        ht = Cn * Cn * this.dot4(b[qr], fr, vr, Zr, rn));
        let fn = .6 - hn * hn - Nn * Nn - Wn * Wn - qn * qn;
        fn < 0 ? _t = 0 : (fn *= fn,
        _t = fn * fn * this.dot4(b[gn], hn, Nn, Wn, qn));
        let bn = .6 - mo * mo - Ur * Ur - nn * nn - xn * xn;
        return bn < 0 ? vt = 0 : (bn *= bn,
        vt = bn * bn * this.dot4(b[Mn], mo, Ur, nn, xn)),
        27 * (ut + pt + ht + _t + vt)
    }
}
var WaveGroundPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, WaveGroundPlugin_1;
let WaveGroundPlugin = WaveGroundPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !1,
        this.noiseScale = 1.8,
        this.amplitude = .5,
        this.paused = !1,
        this._preFrame = () => {
            var h;
            this._viewer && this.enabled && (this.paused || (this._makeRoughGround(this._planeMesh.geometry, this.noiseScale, this.amplitude),
            (h = this._viewer) === null || h === void 0 || h.setDirty()))
        }
        ,
        this._noise = new SimplexNoise;
        const d = new three_module.bdM(1,1,100,100)
          , o = new MeshStandardMaterial2({
            color: 16777215,
            side: three_module.$EB
        })
          , c = new three_module.eaF(d,o);
        c.receiveShadow = !0,
        c.rotation.x = -.5 * Math.PI,
        c.position.x = 0,
        c.position.y = -1,
        c.position.z = 0,
        c.scale.setScalar(10),
        this._planeMesh = c,
        this.planeMesh = c
    }
    async onAdded(d) {
        await super.onAdded(d),
        d.addEventListener("preFrame", this._preFrame),
        this.enabled && await this.onEnable()
    }
    async onEnable() {
        var d, o;
        const c = this._viewer;
        if (!c)
            return;
        const h = c.getPluginByType("Ground")
          , _ = c.getPlugin(FrameFadePlugin);
        if (!this.enabled)
            return this._planeMesh.visible = !1,
            _ && _.enable(WaveGroundPlugin_1.PluginType),
            (d = this._viewer) === null || d === void 0 || d.setDirty(),
            void (h && h.mesh && h.setGeometry(void 0));
        if (_ && _.disable(WaveGroundPlugin_1.PluginType),
        h && h.mesh)
            h.setGeometry(this._planeMesh.geometry),
            h.material && (h.material.side = three_module.$EB,
            h.material.fog = !0),
            this.planeMesh = h.mesh.modelObject;
        else {
            const b = (o = c.scene.getObjectByName("WaveGroundPlugin_root")) !== null && o !== void 0 ? o : (await c.createObject3D(void 0, !0)).modelObject;
            b.name = "WaveGroundPlugin_root",
            b.clear(),
            this.planeMesh = this._planeMesh,
            b.add(this.planeMesh)
        }
        this.planeMesh.visible = !0
    }
    async onRemove(d) {
        return d.removeEventListener("preFrame", this._preFrame),
        this.planeMesh = this._planeMesh,
        this._planeMesh.geometry.dispose(),
        this._planeMesh.removeFromParent(),
        super.onRemove(d)
    }
    _makeRoughGround(d, o=1, c=1) {
        const h = Date.now()
          , _ = 30 * o
          , b = .01 * c
          , _e = d.attributes.position
          , nt = _e.count;
        for (let it = 0; it < nt; it++) {
            const at = _e.getX(it)
              , ut = _e.getY(it)
              , pt = _e.getZ(it)
              , ht = 5 * this._noise.noise3d(at * _ * .1 + 3e-4 * h, ut * _ * .1 + 3e-4 * h, pt * _ * .1 + 3e-4 * h) * b + 4 * this._noise.noise3d(at * _ * .2 + 12e-5 * h, ut * _ * .2 + 15e-5 * h, pt * _ * .2 + 15e-5 * h) * b + 4 * this._noise.noise3d(at * _ * .09 + 15e-5 * h, ut * _ * .12 + 9e-5 * h, pt * _ * .15 + 15e-5 * h) * b;
            _e.setZ(it, ht / 3)
        }
        _e.needsUpdate = !0,
        d.computeVertexNormals()
    }
}
;
WaveGroundPlugin.PluginType = "WaveGroundPlugin",
WaveGroundPlugin_decorate([uiToggle(), serialize(), x$1(WaveGroundPlugin.prototype.onEnable)], WaveGroundPlugin.prototype, "enabled", void 0),
WaveGroundPlugin_decorate([uiSlider("Noise scale", [0, 2]), serialize()], WaveGroundPlugin.prototype, "noiseScale", void 0),
WaveGroundPlugin_decorate([uiSlider("Amplitude", [0, 2]), serialize()], WaveGroundPlugin.prototype, "amplitude", void 0),
WaveGroundPlugin_decorate([uiToggle("Paused"), serialize()], WaveGroundPlugin.prototype, "paused", void 0),
WaveGroundPlugin = WaveGroundPlugin_1 = WaveGroundPlugin_decorate([uiFolder("Wave Ground")], WaveGroundPlugin);
const Visible = 0
  , Deleted = 1
  , ConvexHull_v1 = new three_module.Pq0
  , _line3 = new three_module.cZY
  , ConvexHull_plane = new three_module.Zcv
  , ConvexHull_closestPoint = new three_module.Pq0
  , _triangle = new three_module.lMl;
class ConvexHull_ConvexHull {
    constructor() {
        this.tolerance = -1,
        this.faces = [],
        this.newFaces = [],
        this.assigned = new VertexList,
        this.unassigned = new VertexList,
        this.vertices = []
    }
    setFromPoints(o) {
        if (o.length >= 4) {
            this.makeEmpty();
            for (let c = 0, h = o.length; c < h; c++)
                this.vertices.push(new VertexNode(o[c]));
            this.compute()
        }
        return this
    }
    setFromObject(o) {
        const c = [];
        return o.updateMatrixWorld(!0),
        o.traverse(function(h) {
            const _ = h.geometry;
            if (_ !== void 0) {
                const b = _.attributes.position;
                if (b !== void 0)
                    for (let _e = 0, nt = b.count; _e < nt; _e++) {
                        const it = new three_module.Pq0;
                        it.fromBufferAttribute(b, _e).applyMatrix4(h.matrixWorld),
                        c.push(it)
                    }
            }
        }),
        this.setFromPoints(c)
    }
    containsPoint(o) {
        const c = this.faces;
        for (let h = 0, _ = c.length; h < _; h++)
            if (c[h].distanceToPoint(o) > this.tolerance)
                return !1;
        return !0
    }
    intersectRay(o, c) {
        const h = this.faces;
        let _ = -1 / 0
          , b = 1 / 0;
        for (let _e = 0, nt = h.length; _e < nt; _e++) {
            const it = h[_e]
              , at = it.distanceToPoint(o.origin)
              , ut = it.normal.dot(o.direction);
            if (at > 0 && ut >= 0)
                return null;
            const pt = ut !== 0 ? -at / ut : 0;
            if (!(pt <= 0) && (ut > 0 ? b = Math.min(pt, b) : _ = Math.max(pt, _),
            _ > b))
                return null
        }
        return _ !== -1 / 0 ? o.at(_, c) : o.at(b, c),
        c
    }
    intersectsRay(o) {
        return this.intersectRay(o, ConvexHull_v1) !== null
    }
    makeEmpty() {
        return this.faces = [],
        this.vertices = [],
        this
    }
    addVertexToFace(o, c) {
        return o.face = c,
        c.outside === null ? this.assigned.append(o) : this.assigned.insertBefore(c.outside, o),
        c.outside = o,
        this
    }
    removeVertexFromFace(o, c) {
        return o === c.outside && (o.next !== null && o.next.face === c ? c.outside = o.next : c.outside = null),
        this.assigned.remove(o),
        this
    }
    removeAllVerticesFromFace(o) {
        if (o.outside !== null) {
            const c = o.outside;
            let h = o.outside;
            for (; h.next !== null && h.next.face === o; )
                h = h.next;
            return this.assigned.removeSubList(c, h),
            c.prev = h.next = null,
            o.outside = null,
            c
        }
    }
    deleteFaceVertices(o, c) {
        const h = this.removeAllVerticesFromFace(o);
        if (h !== void 0)
            if (c === void 0)
                this.unassigned.appendChain(h);
            else {
                let _ = h;
                do {
                    const b = _.next;
                    c.distanceToPoint(_.point) > this.tolerance ? this.addVertexToFace(_, c) : this.unassigned.append(_),
                    _ = b
                } while (_ !== null)
            }
        return this
    }
    resolveUnassignedPoints(o) {
        if (this.unassigned.isEmpty() === !1) {
            let c = this.unassigned.first();
            do {
                const h = c.next;
                let _ = this.tolerance
                  , b = null;
                for (let _e = 0; _e < o.length; _e++) {
                    const nt = o[_e];
                    if (nt.mark === Visible) {
                        const it = nt.distanceToPoint(c.point);
                        if (it > _ && (_ = it,
                        b = nt),
                        _ > 1e3 * this.tolerance)
                            break
                    }
                }
                b !== null && this.addVertexToFace(c, b),
                c = h
            } while (c !== null)
        }
        return this
    }
    computeExtremes() {
        const o = new three_module.Pq0
          , c = new three_module.Pq0
          , h = []
          , _ = [];
        for (let b = 0; b < 3; b++)
            h[b] = _[b] = this.vertices[0];
        o.copy(this.vertices[0].point),
        c.copy(this.vertices[0].point);
        for (let b = 0, _e = this.vertices.length; b < _e; b++) {
            const nt = this.vertices[b]
              , it = nt.point;
            for (let at = 0; at < 3; at++)
                it.getComponent(at) < o.getComponent(at) && (o.setComponent(at, it.getComponent(at)),
                h[at] = nt);
            for (let at = 0; at < 3; at++)
                it.getComponent(at) > c.getComponent(at) && (c.setComponent(at, it.getComponent(at)),
                _[at] = nt)
        }
        return this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(o.x), Math.abs(c.x)) + Math.max(Math.abs(o.y), Math.abs(c.y)) + Math.max(Math.abs(o.z), Math.abs(c.z))),
        {
            min: h,
            max: _
        }
    }
    computeInitialHull() {
        const o = this.vertices
          , c = this.computeExtremes()
          , h = c.min
          , _ = c.max;
        let b = 0
          , _e = 0;
        for (let ht = 0; ht < 3; ht++) {
            const _t = _[ht].point.getComponent(ht) - h[ht].point.getComponent(ht);
            _t > b && (b = _t,
            _e = ht)
        }
        const nt = h[_e]
          , it = _[_e];
        let at, ut;
        b = 0,
        _line3.set(nt.point, it.point);
        for (let ht = 0, _t = this.vertices.length; ht < _t; ht++) {
            const vt = o[ht];
            if (vt !== nt && vt !== it) {
                _line3.closestPointToPoint(vt.point, !0, ConvexHull_closestPoint);
                const bt = ConvexHull_closestPoint.distanceToSquared(vt.point);
                bt > b && (b = bt,
                at = vt)
            }
        }
        b = -1,
        ConvexHull_plane.setFromCoplanarPoints(nt.point, it.point, at.point);
        for (let ht = 0, _t = this.vertices.length; ht < _t; ht++) {
            const vt = o[ht];
            if (vt !== nt && vt !== it && vt !== at) {
                const bt = Math.abs(ConvexHull_plane.distanceToPoint(vt.point));
                bt > b && (b = bt,
                ut = vt)
            }
        }
        const pt = [];
        if (ConvexHull_plane.distanceToPoint(ut.point) < 0) {
            pt.push(Face.create(nt, it, at), Face.create(ut, it, nt), Face.create(ut, at, it), Face.create(ut, nt, at));
            for (let ht = 0; ht < 3; ht++) {
                const _t = (ht + 1) % 3;
                pt[ht + 1].getEdge(2).setTwin(pt[0].getEdge(_t)),
                pt[ht + 1].getEdge(1).setTwin(pt[_t + 1].getEdge(0))
            }
        } else {
            pt.push(Face.create(nt, at, it), Face.create(ut, nt, it), Face.create(ut, it, at), Face.create(ut, at, nt));
            for (let ht = 0; ht < 3; ht++) {
                const _t = (ht + 1) % 3;
                pt[ht + 1].getEdge(2).setTwin(pt[0].getEdge((3 - ht) % 3)),
                pt[ht + 1].getEdge(0).setTwin(pt[_t + 1].getEdge(1))
            }
        }
        for (let ht = 0; ht < 4; ht++)
            this.faces.push(pt[ht]);
        for (let ht = 0, _t = o.length; ht < _t; ht++) {
            const vt = o[ht];
            if (vt !== nt && vt !== it && vt !== at && vt !== ut) {
                b = this.tolerance;
                let bt = null;
                for (let St = 0; St < 4; St++) {
                    const At = this.faces[St].distanceToPoint(vt.point);
                    At > b && (b = At,
                    bt = this.faces[St])
                }
                bt !== null && this.addVertexToFace(vt, bt)
            }
        }
        return this
    }
    reindexFaces() {
        const o = [];
        for (let c = 0; c < this.faces.length; c++) {
            const h = this.faces[c];
            h.mark === Visible && o.push(h)
        }
        return this.faces = o,
        this
    }
    nextVertexToAdd() {
        if (this.assigned.isEmpty() === !1) {
            let o, c = 0;
            const h = this.assigned.first().face;
            let _ = h.outside;
            do {
                const b = h.distanceToPoint(_.point);
                b > c && (c = b,
                o = _),
                _ = _.next
            } while (_ !== null && _.face === h);
            return o
        }
    }
    computeHorizon(o, c, h, _) {
        let b;
        this.deleteFaceVertices(h),
        h.mark = Deleted,
        b = c === null ? c = h.getEdge(0) : c.next;
        do {
            const _e = b.twin
              , nt = _e.face;
            nt.mark === Visible && (nt.distanceToPoint(o) > this.tolerance ? this.computeHorizon(o, _e, nt, _) : _.push(b)),
            b = b.next
        } while (b !== c);
        return this
    }
    addAdjoiningFace(o, c) {
        const h = Face.create(o, c.tail(), c.head());
        return this.faces.push(h),
        h.getEdge(-1).setTwin(c.twin),
        h.getEdge(0)
    }
    addNewFaces(o, c) {
        this.newFaces = [];
        let h = null
          , _ = null;
        for (let b = 0; b < c.length; b++) {
            const _e = c[b]
              , nt = this.addAdjoiningFace(o, _e);
            h === null ? h = nt : nt.next.setTwin(_),
            this.newFaces.push(nt.face),
            _ = nt
        }
        return h.next.setTwin(_),
        this
    }
    addVertexToHull(o) {
        const c = [];
        return this.unassigned.clear(),
        this.removeVertexFromFace(o, o.face),
        this.computeHorizon(o.point, null, o.face, c),
        this.addNewFaces(o, c),
        this.resolveUnassignedPoints(this.newFaces),
        this
    }
    cleanup() {
        return this.assigned.clear(),
        this.unassigned.clear(),
        this.newFaces = [],
        this
    }
    compute() {
        let o;
        for (this.computeInitialHull(); (o = this.nextVertexToAdd()) !== void 0; )
            this.addVertexToHull(o);
        return this.reindexFaces(),
        this.cleanup(),
        this
    }
}
class Face {
    constructor() {
        this.normal = new three_module.Pq0,
        this.midpoint = new three_module.Pq0,
        this.area = 0,
        this.constant = 0,
        this.outside = null,
        this.mark = Visible,
        this.edge = null
    }
    static create(o, c, h) {
        const _ = new Face
          , b = new HalfEdge(o,_)
          , _e = new HalfEdge(c,_)
          , nt = new HalfEdge(h,_);
        return b.next = nt.prev = _e,
        _e.next = b.prev = nt,
        nt.next = _e.prev = b,
        _.edge = b,
        _.compute()
    }
    getEdge(o) {
        let c = this.edge;
        for (; o > 0; )
            c = c.next,
            o--;
        for (; o < 0; )
            c = c.prev,
            o++;
        return c
    }
    compute() {
        const o = this.edge.tail()
          , c = this.edge.head()
          , h = this.edge.next.head();
        return _triangle.set(o.point, c.point, h.point),
        _triangle.getNormal(this.normal),
        _triangle.getMidpoint(this.midpoint),
        this.area = _triangle.getArea(),
        this.constant = this.normal.dot(this.midpoint),
        this
    }
    distanceToPoint(o) {
        return this.normal.dot(o) - this.constant
    }
}
class HalfEdge {
    constructor(o, c) {
        this.vertex = o,
        this.prev = null,
        this.next = null,
        this.twin = null,
        this.face = c
    }
    head() {
        return this.vertex
    }
    tail() {
        return this.prev ? this.prev.vertex : null
    }
    length() {
        const o = this.head()
          , c = this.tail();
        return c !== null ? c.point.distanceTo(o.point) : -1
    }
    lengthSquared() {
        const o = this.head()
          , c = this.tail();
        return c !== null ? c.point.distanceToSquared(o.point) : -1
    }
    setTwin(o) {
        return this.twin = o,
        o.twin = this,
        this
    }
}
class VertexNode {
    constructor(o) {
        this.point = o,
        this.prev = null,
        this.next = null,
        this.face = null
    }
}
class VertexList {
    constructor() {
        this.head = null,
        this.tail = null
    }
    first() {
        return this.head
    }
    last() {
        return this.tail
    }
    clear() {
        return this.head = this.tail = null,
        this
    }
    insertBefore(o, c) {
        return c.prev = o.prev,
        c.next = o,
        c.prev === null ? this.head = c : c.prev.next = c,
        o.prev = c,
        this
    }
    insertAfter(o, c) {
        return c.prev = o,
        c.next = o.next,
        c.next === null ? this.tail = c : c.next.prev = c,
        o.next = c,
        this
    }
    append(o) {
        return this.head === null ? this.head = o : this.tail.next = o,
        o.prev = this.tail,
        o.next = null,
        this.tail = o,
        this
    }
    appendChain(o) {
        for (this.head === null ? this.head = o : this.tail.next = o,
        o.prev = this.tail; o.next !== null; )
            o = o.next;
        return this.tail = o,
        this
    }
    remove(o) {
        return o.prev === null ? this.head = o.next : o.prev.next = o.next,
        o.next === null ? this.tail = o.prev : o.next.prev = o.prev,
        this
    }
    removeSubList(o, c) {
        return o.prev === null ? this.head = c.next : o.prev.next = c.next,
        c.next === null ? this.tail = o.prev : c.next.prev = o.prev,
        this
    }
    isEmpty() {
        return this.head === null
    }
}
class ConvexGeometry extends three_module.LoY {
    constructor(o=[]) {
        super();
        const c = []
          , h = []
          , _ = new ConvexHull_ConvexHull().setFromPoints(o).faces;
        for (let b = 0; b < _.length; b++) {
            const _e = _[b];
            let nt = _e.edge;
            do {
                const it = nt.head().point;
                c.push(it.x, it.y, it.z),
                h.push(_e.normal.x, _e.normal.y, _e.normal.z),
                nt = nt.next
            } while (nt !== _e.edge)
        }
        this.setAttribute("position", new three_module.qtW(c,3)),
        this.setAttribute("normal", new three_module.qtW(h,3))
    }
}
var PosePlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let PosePlugin = class extends AViewerPlugin {
    constructor() {
        super(),
        this._debug = !1,
        this.enabled = !0,
        this.toJSON = void 0,
        this.autoUpdateGround = !0
    }
    computeStablePoses(d) {
        var o, c;
        const h = new ConvexHull_ConvexHull().setFromObject(d)
          , _ = this._computeCOM(h)
          , b = new three_module.Pq0
          , _e = new three_module.Pq0
          , nt = new three_module.Pq0
          , it = new three_module.Pq0
          , at = [];
        for (const ut of h.faces) {
            this._getFaceData(ut, b, _e, nt, it);
            const pt = new three_module.Pq0().copy(b)
              , ht = this._project(_, b, _e, nt, it)
              , _t = this._constructRotationTransform(_, ht, it)
              , vt = new three_module.kn4().copy(_t).invert()
              , bt = new three_module.Pq0().copy(_);
            bt.applyMatrix4(vt),
            b.applyMatrix4(vt),
            _e.applyMatrix4(vt),
            nt.applyMatrix4(vt);
            const St = new three_module.I9Y(bt.x,bt.y)
              , At = new three_module.I9Y(b.x,b.y)
              , Et = new three_module.I9Y(_e.x,_e.y)
              , Pt = new three_module.I9Y(nt.x,nt.y)
              , It = this._pointInTriangle(St, At, Et, Pt);
            if (It > 0) {
                const Dt = this._triArea(b, _e, nt)
                  , Gt = this._getMaxEdgeData(b, _e, nt)
                  , Bt = this._constructRotationTransform(_, ht, it, Gt.edgeVector);
                at.push({
                    distance: It,
                    faceNormal: it,
                    area: Dt,
                    face: ut,
                    maxEdgeLength: Gt.maxEdgeLength,
                    xform: Bt,
                    edgePoint: pt
                })
            }
        }
        return at.sort( (ut, pt) => pt.maxEdgeLength - ut.maxEdgeLength),
        this._debug && this._createDebugMeshes(_, h),
        d._stablePoses = at,
        d._poseIndex = -1,
        (c = (o = d.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0),
        at
    }
    setMostStablePose(d) {
        return this.setPose(d, 0)
    }
    setVerticalPose(d) {
        if (d._stablePoses || this.computeStablePoses(d),
        d._stablePoses)
            return this.setPose(d, d._stablePoses.length - 1)
    }
    setNextPose(d) {
        var o;
        return this.setPose(d, ((o = d._poseIndex) !== null && o !== void 0 ? o : -1) + 1)
    }
    setPreviousPose(d) {
        return this.setPose(d, (d._poseIndex || 0) - 1)
    }
    setOriginalPose(d) {
        delete d._poseIndex,
        d._stablePoses || this.computeStablePoses(d),
        d._stablePoses && this._syncPose(d, !0)
    }
    clearPoses(d) {
        var o, c, h, _, b;
        delete d._stablePoses,
        delete d._poseIndex,
        delete d._originalXform,
        (_ = (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(PickingPlugin)) === null || c === void 0 ? void 0 : c.uiConfig) === null || h === void 0 ? void 0 : h.uiRefresh) === null || _ === void 0 || _.call(h, "postFrame", !0),
        (b = this._viewer) === null || b === void 0 || b.setDirty()
    }
    setPose(d, o) {
        var c;
        if (d._stablePoses || this.computeStablePoses(d),
        !d._stablePoses)
            return;
        const h = (c = d._poseIndex) !== null && c !== void 0 ? c : -1;
        return o < 0 && (o = d._stablePoses.length - 1),
        o > d._stablePoses.length - 1 && (o = 0),
        o !== h ? (d._poseIndex = o,
        this._syncPose(d),
        () => h < 0 ? this.setOriginalPose(d) : this.setPose(d, h)) : void 0
    }
    async onAdded(d) {
        await super.onAdded(d),
        d.scene.addEventListener("addSceneObject", o => {
            var c;
            const h = (c = o.object) === null || c === void 0 ? void 0 : c.modelObject;
            if (!h)
                return;
            const _ = h.uiConfig;
            _ && Array.isArray(_.children) && _.children.push({
                type: "folder",
                label: "Poses",
                children: [{
                    type: "button",
                    label: "Compute Poses",
                    hidden: () => !!h._stablePoses,
                    value: () => this.computeStablePoses(h)
                }, {
                    type: "button",
                    label: "Original Pose",
                    hidden: () => !h._stablePoses,
                    value: () => this.setOriginalPose(h)
                }, {
                    type: "button",
                    label: "Stable Pose",
                    hidden: () => !h._stablePoses,
                    value: () => this.setMostStablePose(h)
                }, {
                    type: "button",
                    label: "Vertical Pose",
                    hidden: () => !h._stablePoses,
                    value: () => this.setVerticalPose(h)
                }, {
                    type: "button",
                    label: "Next Pose",
                    hidden: () => !h._stablePoses,
                    value: () => this.setNextPose(h)
                }, {
                    type: "button",
                    label: "Previous Pose",
                    hidden: () => !h._stablePoses,
                    value: () => this.setPreviousPose(h)
                }, {
                    type: "button",
                    label: "Clear Poses",
                    hidden: () => !h._stablePoses,
                    value: () => this.clearPoses(h)
                }]
            })
        }
        )
    }
    _getMaxEdgeData(d, o, c) {
        const h = d.distanceTo(o)
          , _ = o.distanceTo(c)
          , b = c.distanceTo(d);
        let _e = h;
        const nt = new three_module.Pq0;
        return h > _ ? h > b ? (_e = h,
        nt.copy(o).sub(d).normalize()) : (_e = b,
        nt.copy(d).sub(c).normalize()) : _ > b ? (_e = _,
        nt.copy(c).sub(o).normalize()) : (_e = b,
        nt.copy(d).sub(c).normalize()),
        {
            maxEdgeLength: _e,
            edgeVector: nt,
            edgePoint: new three_module.Pq0().copy(d)
        }
    }
    _getFaceData(d, o, c, h, _) {
        let b = d.edge
          , _e = b.head().point;
        o.set(_e.x, _e.y, _e.z),
        b = b.next,
        _e = b.head().point,
        c.set(_e.x, _e.y, _e.z),
        b = b.next,
        _e = b.head().point,
        h.set(_e.x, _e.y, _e.z),
        _ == null || _.copy(d.normal)
    }
    _computeCOM(d) {
        const o = new three_module.Pq0
          , c = new three_module.Pq0
          , h = new three_module.Pq0
          , _ = new three_module.Pq0
          , b = new three_module.Pq0;
        let _e = 0;
        for (const nt of d.faces) {
            this._getFaceData(nt, c, h, _),
            b.set(0, 0, 0),
            b.add(c).add(h).add(_).multiplyScalar(1 / 3),
            h.sub(c),
            _.sub(c);
            const it = .5 * h.cross(_).length();
            _e += it,
            b.multiplyScalar(it),
            o.add(b)
        }
        return o.multiplyScalar(1 / _e),
        o
    }
    _sign(d, o, c) {
        return (d.x - c.x) * (o.y - c.y) - (o.x - c.x) * (d.y - c.y)
    }
    _shortestDistance(d, o, c) {
        const h = new three_module.I9Y(o.y - c.y,c.x - o.x).normalize()
          , _ = new three_module.I9Y().copy(o).sub(d);
        return Math.abs(_.dot(h))
    }
    _pointInTriangle(d, o, c, h) {
        const _ = this._sign(d, o, c)
          , b = this._sign(d, c, h)
          , _e = this._sign(d, h, o);
        if (!(_ < 0 || b < 0 || _e < 0) || !(_ > 0 || b > 0 || _e > 0)) {
            const nt = this._shortestDistance(d, o, c)
              , it = this._shortestDistance(d, c, h)
              , at = this._shortestDistance(d, h, o);
            return Math.min(Math.min(nt, it), at)
        }
        return -1
    }
    _project(d, o, c, h, _) {
        const b = new three_module.Pq0().copy(_)
          , _e = new three_module.Pq0().copy(o).sub(d).dot(b);
        _e < 0 && b.negate();
        const nt = Math.abs(_e);
        return new three_module.Pq0().copy(d).addScaledVector(b, nt)
    }
    _constructRotationTransform(d, o, c, h) {
        const _ = new three_module.Pq0().copy(c)
          , b = new three_module.Pq0().copy(o).sub(d).dot(_);
        b > 0 && _.negate();
        const _e = new three_module.Pq0().copy(o).addScaledVector(_, Math.abs(b))
          , nt = h === void 0 ? new three_module.Pq0(1,1,0) : h;
        return new three_module.kn4().lookAt(o, _e, nt)
    }
    _triArea(d, o, c) {
        const h = new three_module.Pq0().copy(o).sub(d)
          , _ = new three_module.Pq0().copy(c).sub(d);
        return .5 * h.cross(_).length()
    }
    _createTriangleMesh() {
        const d = new three_module.LoY
          , o = new three_module.V9B({
            color: 16711680,
            side: three_module.$EB
        });
        return new three_module.eaF(d,o)
    }
    _updateTriangleMesh(d) {
        var o;
        this._triMesh.geometry.setAttribute("position", new three_module.THS(d,3)),
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    _syncPose(d, o=!1) {
        var c, h, _, b, _e, nt, it, at;
        if (d._stablePoses === void 0 || d._stablePoses.length == 0)
            return;
        const ut = new three_module.kn4;
        if (!o) {
            ut.lookAt(new three_module.Pq0, new three_module.Pq0(0,1,0), new three_module.Pq0(0,0,1));
            const ht = d._stablePoses[d._poseIndex || 0].xform
              , _t = new three_module.kn4().copy(ht).invert();
            ut.multiply(_t)
        }
        if (d._originalXform) {
            const ht = new three_module.Pq0
              , _t = new three_module.PTz
              , vt = new three_module.Pq0;
            d._originalXform.decompose(ht, _t, vt),
            d.position.copy(ht),
            d.quaternion.copy(_t),
            d.scale.copy(vt)
        } else
            d._originalXform = new three_module.kn4().copy(d.matrix);
        d.applyMatrix4(ut);
        const pt = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(GroundPlugin);
        if (this.autoUpdateGround)
            (h = this._viewer) === null || h === void 0 || h.scene.setDirty({
                sceneUpdate: !0
            }),
            pt.enableRefreshTransform = !0;
        else if (!o) {
            const ht = d._stablePoses[d._poseIndex || 0].edgePoint
              , _t = new three_module.Pq0().copy(ht);
            _t.applyMatrix4(ut);
            const vt = _t.y - pt.shadowBaker.attachedMesh.position.y;
            d.position.y -= vt
        }
        (_ = this._viewer) === null || _ === void 0 || _.setDirty(),
        (b = this._viewer) === null || b === void 0 || b.renderer.resetShadows(),
        pt == null || pt.bakeShadows(),
        (at = (nt = (_e = this._viewer) === null || _e === void 0 ? void 0 : _e.getPlugin(PickingPlugin)) === null || nt === void 0 ? void 0 : (it = nt.uiConfig).uiRefresh) === null || at === void 0 || at.call(it, "postFrame", !0)
    }
    async _createDebugMeshes(d, o) {
        var c;
        const h = [];
        for (const ut of o.vertices)
            h.push(new three_module.Pq0(ut.point.x,ut.point.y,ut.point.z));
        const _ = new ConvexGeometry(h)
          , b = new three_module.XJ7(_)
          , _e = new three_module.DXC(b);
        _e.material.opacity = .25,
        _e.material.transparent = !0,
        this._triMesh = this._createTriangleMesh();
        const nt = new three_module.Gu$(.025)
          , it = new three_module.eaF(nt,new three_module.uSd({
            color: 16776960
        }));
        it.position.copy(d);
        const at = (await ((c = this._viewer) === null || c === void 0 ? void 0 : c.createObject3D(void 0, !0))).modelObject;
        return at.add(this._triMesh),
        at.add(_e),
        at.add(it),
        at
    }
}
;
PosePlugin.PluginType = "PosePlugin",
PosePlugin_decorate([uiToggle()], PosePlugin.prototype, "autoUpdateGround", void 0),
PosePlugin = PosePlugin_decorate([uiFolder("Pose Plugin")], PosePlugin);
var tweakpane_image_plugin = __webpackgi_require__(282)
  , tweakpane = __webpackgi_require__(578);
const tweakpaneCheckParent = (d, o) => o.controller_.rackController.rack === d.controller_.parent
  , tweakPaneMoveToParentIndex = (d, o, c) => {
    var h, _;
    const b = d.controller_
      , _e = (_ = (h = b.parent) === null || h === void 0 ? void 0 : h.children) === null || _ === void 0 ? void 0 : _.indexOf(b);
    return !(tweakpaneCheckParent(d, o) && _e === c || (o.add(d, c),
    0))
}
  , tpFolderGenerator = (d, o, c, h) => {
    var _, b, _e, nt, it;
    let at = o.uiRef;
    at != null && at.controller_.viewProps.get("disposed") && (at = void 0);
    const ut = at == null ? void 0 : at.expanded;
    if (!at) {
        const St = d.addFolder({
            title: ""
        });
        at = St,
        at.on("fold", At => {
            var Et, Pt, It, Dt;
            let Gt = St.expanded;
            S$2(o, "expanded", Gt, !0),
            Gt = (Et = Ee$1(o.expanded)) !== null && Et !== void 0 ? Et : Gt,
            Gt !== St.expanded && (St.expanded = Gt),
            (Pt = o.uiRefresh) === null || Pt === void 0 || Pt.call(o, "postFrame", !0, 10),
            Gt ? (It = o.onExpand) === null || It === void 0 || It.call(o, o) : (Dt = o.onCollapse) === null || Dt === void 0 || Dt.call(o, o)
        }
        )
    }
    if (!at)
        return at;
    at.expanded = (b = (_ = Ee$1(o.expanded)) !== null && _ !== void 0 ? _ : ut) !== null && b !== void 0 && b;
    const pt = ((_e = o.children) !== null && _e !== void 0 ? _e : []).map(St => St && Ee$1(St)).flat(2).filter(St => St);
    let ht = 0;
    for (const St of pt) {
        if (Array.isArray(St) || typeof St != "object") {
            console.error("child is not an object", St);
            continue
        }
        let At = St.uiRef;
        At && At.controller_.viewProps.get("disposed") && (St.uiRef = void 0,
        St.uiRefresh = void 0),
        At = St.uiRef,
        At || (c.appendUiObject({
            uiConfig: St
        }, at),
        At = St.uiRef),
        At && tweakPaneMoveToParentIndex(At, at, ht++) && c.appendUiObject({
            uiConfig: St
        }, at)
    }
    let _t = at.children;
    for (; _t.length > ht; ) {
        const St = _t[_t.length - 1];
        at.remove(St),
        St.dispose(),
        _t = at.children
    }
    at.controller_.props.set("title", (nt = Ee$1(o.label)) !== null && nt !== void 0 ? nt : "");
    const vt = at.controller_.view.containerElement
      , bt = Ee$1(o.domChildren, []);
    if ((bt == null ? void 0 : bt.length) !== void 0) {
        const St = [];
        for (let At = 0; At < vt.children.length; At++) {
            const Et = vt.children[At];
            !((it = Et.dataset) === null || it === void 0) && it.tpCustomDOM && St.push(Et)
        }
        for (const At of St)
            vt.removeChild(At);
        for (const At of bt)
            At.parentElement !== vt && (vt.appendChild(At),
            At.dataset.tpCustomDOM = "true");
        at.controller_.foldable.cleanUpTransition()
    }
    return at
}
  , tpButtonInputGenerator = (d, o, c, h) => {
    var _, b;
    const [_e,nt] = (_ = o.property) !== null && _ !== void 0 ? _ : [void 0, void 0]
      , it = (b = Ee$1(o.label)) !== null && b !== void 0 ? b : nt;
    let at = o.uiRef;
    return at != null && at.controller_.viewProps.get("disposed") && (at = void 0),
    at || (at = d.addButton({
        title: ""
    }),
    at.on("click", async () => {
        const ut = [];
        o.prompt && ut.push(await c.prompt(...o.prompt));
        let pt = _e && nt ? _e[nt] : void 0
          , ht = _e;
        if (pt || (pt = o.value,
        ht = o),
        typeof pt == "function") {
            const _t = () => {
                var vt;
                c.removeEventListener("postFrame", _t);
                const bt = pt.call(ht ?? o, ...ut);
                typeof bt == "function" && ((vt = c.undoManager) === null || vt === void 0 || vt.record({
                    undo: () => {
                        var St;
                        bt.call(ht ?? o, ...ut),
                        (St = o.uiRefresh) === null || St === void 0 || St.call(o, void 0, !1)
                    }
                    ,
                    redo: () => {
                        var St;
                        pt.call(ht ?? o, ...ut),
                        (St = o.uiRefresh) === null || St === void 0 || St.call(o, void 0, !1)
                    }
                }))
            }
            ;
            c.addEventListener("postFrame", _t)
        } else
            console.warn("uiconfig.js: Invalid action type for button")
    }
    )),
    at && (at.title = (it ?? "click me") + ""),
    at
}
  , tpDropdownInputGenerator = (d, o, c, h) => {
    var _;
    const b = Object.fromEntries(((_ = Ee$1(o.children)) !== null && _ !== void 0 ? _ : []).map(_e => Ee$1(_e)).flat(2).filter(_e => _e).map(_e => {
        var nt;
        const it = Ee$1(_e.label);
        return [it, (nt = _e.value) !== null && nt !== void 0 ? nt : it]
    }
    ));
    return tpInputGenerator(d, o, c, {
        options: b,
        ...h ?? {}
    })
}
  , tpSliderInputGenerator = (d, o, c, h) => {
    var _, b;
    const _e = Ee$1(o.bounds)
      , nt = ((_ = _e == null ? void 0 : _e.length) !== null && _ !== void 0 ? _ : 0) >= 2 ? _e[1] : 1
      , it = ((b = _e == null ? void 0 : _e.length) !== null && b !== void 0 ? b : 0) >= 1 ? _e[0] : 0
      , at = o.stepSize || void 0;
    return tpInputGenerator(d, o, c, {
        min: it,
        max: nt,
        step: at,
        ...h ?? {}
    })
}
  , tpVecInputGenerator = (d, o, c, h) => {
    var _, b, _e;
    const nt = Ee$1(o.bounds);
    if (!nt || nt.length < 1)
        return tpInputGenerator(d, o, c, {
            ...h ?? {}
        });
    const it = ((_ = nt.length) !== null && _ !== void 0 ? _ : 0) >= 2 ? nt[1] : 1
      , at = ((b = nt.length) !== null && b !== void 0 ? b : 0) >= 1 ? nt[0] : 0
      , ut = {
        min: at,
        max: it,
        step: (_e = o.stepSize) !== null && _e !== void 0 ? _e : (it - at) / 100
    }
      , pt = {
        x: ut,
        y: ut
    };
    o.type !== "vec3" && o.type !== "vec4" || (pt.z = ut),
    o.type === "vec4" && (pt.w = ut);
    const ht = o.property;
    if (o.value === void 0 && ht && ht[0] && typeof ht[0] == "object" && ht[0][ht[1]] && Array.isArray(ht[0][ht[1]])) {
        const [_t,vt] = ht
          , bt = _t[vt]
          , St = bt.length
          , At = new (St === 2 ? three_module.I9Y : St === 3 ? three_module.Pq0 : three_module.IUQ)().fromArray(bt);
        o.value = At,
        o.property = void 0,
        o.onChange = [ () => {
            _t[vt] = At.toArray()
        }
        , ...Array.isArray(o.onChange) ? o.onChange : [o.onChange]].filter(Et => Et),
        o.label === void 0 && (o.label = vt)
    }
    return tpInputGenerator(d, o, c, {
        ...pt,
        ...h ?? {}
    })
}
  , tpColorInputGenerator = (d, o, c, h) => {
    var _;
    const b = o.property;
    if (o.value === void 0 && b && typeof b[0] == "object" && (!((_ = b[0][b[1]]) === null || _ === void 0) && _.isColor)) {
        const [_e,nt] = b
          , it = three_module.er$;
        Object.defineProperty(o, "value", {
            get: () => {
                const at = _e[nt];
                return at ? new three_module.Q1f(at).getHex(it) : 0
            }
            ,
            set: at => {
                const ut = _e[nt]
                  , pt = new three_module.Q1f().setHex(at, it);
                ut.isColor ? ut.copy(pt) : typeof ut == "number" ? _e[nt] = pt.getHex() : typeof ut == "string" && (_e[nt] = "#" + pt.getHexString()),
                typeof (_e == null ? void 0 : _e.setDirty) == "function" && _e.setDirty()
            }
        }),
        o.property = void 0,
        o.onChange = [...Array.isArray(o.onChange) ? o.onChange : [o.onChange]].filter(at => at),
        o.label === void 0 && (o.label = nt + "")
    }
    return (h = h ?? {}).view = "color",
    Ee$1(o.inlinePicker) && (h.picker = "inline"),
    tpInputGenerator(d, o, c, h)
}
  , tpInputGenerator = (d, o, c, h) => {
    var _, b, _e, nt, it, at, ut;
    let pt = Ee$1(o.property);
    if ((o.getValue || o.setValue) && pt && console.error("specify either property or value, or getValue and setValue", o),
    pt)
        o.value && console.warn("uiconfig.js: Both property and value are defined, value will be ignored", o);
    else if ((Object.hasOwn ? Object.hasOwn(o, "value") : o.hasOwnProperty("value")) || o.value !== void 0 || !o.getValue && !o.setValue || (Object.defineProperty(o, "value", {
        get: () => {
            var bt;
            return (bt = o.getValue) === null || bt === void 0 ? void 0 : bt.call(o)
        }
        ,
        set: bt => {
            var St;
            return (St = o.setValue) === null || St === void 0 ? void 0 : St.call(o, bt)
        }
    }),
    pt = [o, "value"]),
    pt || o.value === void 0 || (pt = [o, "value"]),
    !pt)
        return void console.error("cannot determine property", o);
    h = h ?? {};
    const ht = {
        label: (_ = Ee$1(o.label)) !== null && _ !== void 0 ? _ : pt[1],
        ...h
    };
    let _t = o.uiRef;
    _t != null && _t.controller_.viewProps.get("disposed") && (_t = void 0);
    let vt = !1;
    if (!_t && typeof pt[0] == "object" && pt[0]) {
        const [bt,St] = pt;
        try {
            if (o.isMonitor)
                _t = d.addMonitor(bt, St, ht);
            else {
                const At = {
                    tar: bt,
                    key: St,
                    __v: cloneVar(bt[St])
                };
                At.lastUndoVal = cloneVar(At.__v),
                Object.defineProperty(At, St, {
                    get: () => At.__v,
                    set: It => {
                        At.__v = It
                    }
                });
                const Et = It => {
                    var Dt;
                    [o.onChange].flat().forEach(Gt => typeof Gt == "function" && (Gt == null ? void 0 : Gt(It))),
                    typeof ((Dt = At.tar) === null || Dt === void 0 ? void 0 : Dt.setDirty) == "function" && At.tar.setDirty(It)
                }
                  , Pt = It => {
                    var Dt, Gt;
                    const Bt = At.tar[At.key];
                    let kt = At.__v;
                    const Ut = compare(Bt, kt);
                    if ((!Ut || It.last) && (Ut || (copyVal(At.tar, At.key, kt),
                    Et(It)),
                    It.last)) {
                        let Ht = At.lastUndoVal
                          , Kt = !1;
                        if (typeof kt == "string" && kt.length > 1e5 && (Kt = !0),
                        typeof Ht == "string" && Ht.length > 1e5 && (Kt = !0),
                        !(Kt || kt instanceof HTMLImageElement)) {
                            const Jt = compare(Ht, kt);
                            !((Dt = c.undoManager) === null || Dt === void 0) && Dt.options.debug && console.log("onchange", Ht, kt, Jt),
                            Jt || (kt = cloneVar(kt),
                            Ht = cloneVar(Ht),
                            (Gt = c.undoManager) === null || Gt === void 0 || Gt.record({
                                undo: () => {
                                    var or;
                                    copyVal(At.tar, At.key, Ht),
                                    Et({
                                        ...It,
                                        value: Ht
                                    }),
                                    (or = o.uiRefresh) === null || or === void 0 || or.call(o, void 0, !1)
                                }
                                ,
                                redo: () => {
                                    var or;
                                    copyVal(At.tar, At.key, kt),
                                    Et(It),
                                    (or = o.uiRefresh) === null || or === void 0 || or.call(o, void 0, !1)
                                }
                            }),
                            copyVal(At, "lastUndoVal", kt))
                        }
                    }
                }
                ;
                _t = d.addInput(At, St, ht).on("change", Pt),
                _t.__proxy1 = At,
                vt = !0
            }
        } catch (At) {
            if (!At.message.startsWith("No matching controller for"))
                throw At;
            _t = void 0
        }
    }
    if (_t) {
        for (const [bt,St] of Object.entries(ht)) {
            const At = _t.controller_;
            let Et = At.props.value(bt);
            if (Et !== void 0)
                Et.rawValue !== St && _t.controller_.props.set(bt, St);
            else {
                const Pt = At.valueController;
                Et = (_e = (b = Pt.props) === null || b === void 0 ? void 0 : b.value) === null || _e === void 0 ? void 0 : _e.call(b, bt);
                let It = St;
                const Dt = Et == null ? void 0 : Et.rawValue;
                let Gt = !1;
                bt === "options" && typeof It == "object" && !Array.isArray(It) && Array.isArray(Dt) && (It = Object.entries(It).map( ([Bt,kt]) => ({
                    text: Bt,
                    value: kt
                })),
                Gt = !0),
                Et === void 0 || Dt === It || Gt && _t.__lastOptions === St || (Pt.props.set(bt, It),
                Gt && ((it = (nt = Pt.view) === null || nt === void 0 ? void 0 : nt.update_) === null || it === void 0 || it.call(nt),
                _t.__lastOptions = St))
            }
        }
        if (o.type === "slider" && (ht.min !== void 0 && _t.controller_.valueController.sliderController.props.set("minValue", ht.min),
        ht.max !== void 0 && _t.controller_.valueController.sliderController.props.set("maxValue", ht.max)),
        (at = (_t == null ? void 0 : _t.controller_.valueController.view).inputElement) === null || at === void 0 || at.setAttribute("placeholder", (ut = Ee$1(o.placeholder)) !== null && ut !== void 0 ? ut : ""),
        _t.__proxy1 && !vt) {
            const bt = _t.__proxy1
              , [St,At] = pt;
            bt.tar = St,
            bt.key = At;
            const Et = St[At];
            copyVal(bt, "__v", Et),
            copyVal(bt, "lastUndoVal", Et)
        }
        _t.refresh()
    }
    return _t
}
;
function compare(d, o) {
    return typeof d == typeof o && (typeof d == "object" || Array.isArray(d) ? Array.isArray(d) ? d.length === o.length && d.every( (c, h) => compare(c, o[h])) : typeof d.equals == "function" ? !!d.equals(o) : d.toArray && o.toArray ? compare(d.toArray(), o.toArray()) : d === o : d === o)
}
function cloneVar(d) {
    return typeof d == "object" && d ? Array.isArray(d) ? [...d] : d.isObject3D || d.isMaterial ? d : typeof d.clone == "function" ? d.clone() : d : d
}
function copyVal(d, o, c) {
    typeof c.copy == "function" && d[o] ? d[o].copy(c) : d[o] = cloneVar(c)
}
class TweakpaneWrapper extends I$2 {
    constructor(o=!1, c=!1, h=!1, _=!0, b=document.body) {
        super(),
        this._refreshQueue = {
            preRender: [],
            postRender: [],
            preFrame: [],
            postFrame: []
        },
        this._lastModeTime = {
            preRender: 0,
            postRender: 0,
            preFrame: 0,
            postFrame: 0
        },
        this._typeGenerators = {
            panel: tpFolderGenerator,
            folder: tpFolderGenerator,
            input: tpInputGenerator,
            number: tpInputGenerator,
            slider: tpSliderInputGenerator,
            dropdown: tpDropdownInputGenerator,
            checkbox: tpInputGenerator,
            color: tpColorInputGenerator,
            vec: tpVecInputGenerator,
            vec2: tpVecInputGenerator,
            vec3: tpVecInputGenerator,
            vec4: tpVecInputGenerator,
            button: tpButtonInputGenerator,
            monitor: (nt, it, at, ut) => (it.isMonitor = !0,
            tpInputGenerator(nt, it, at, ut)),
            dummy: (nt, it, at, ut) => tpInputGenerator(nt, it, at, ut)
        },
        this.undoManager = new Q$2({
            bindHotKeys: !0,
            limit: 100,
            debug: !1
        }),
        this.alert = this.alert.bind(this),
        this.confirm = this.confirm.bind(this),
        this.prompt = this.prompt.bind(this),
        this._expand = o,
        this._limitedOptions = h;
        const _e = this._createUiContainer();
        b.appendChild(_e),
        this._container = b,
        this._pane = new tweakpane.Pane({
            title: "Configuration",
            container: _e
        }),
        this._pane.expanded = this._expand,
        _ && (this.addEventListener("postFrame", () => this.refreshQueue("postFrame")),
        setTimeout( () => {
            this.dispatchEvent({
                type: "postFrame"
            })
        }
        , 32))
    }
    refreshQueue(o) {
        const c = this._refreshQueue[o]
          , h = []
          , _ = g()
          , b = _ - this._lastModeTime[o];
        c.forEach(_e => {
            _e[2] > .001 ? (_e[2] -= b,
            h.push(_e)) : this._refreshUiObject(_e[0], _e[1], _e[2])
        }
        ),
        this._refreshQueue[o] = h,
        this._lastModeTime[o] = _
    }
    addToRefreshQueue(o, c) {
        var h;
        const _ = (h = c[0]) === null || h === void 0 ? void 0 : h.uiConfig
          , b = _ == null ? void 0 : _.uuid
          , _e = this._refreshQueue[o]
          , nt = _e.find(it => it[3] === b);
        nt ? nt[2] = Math.max(nt[2], c[2]) : _e.push([...c, b]),
        this._refreshQueue[o] = _e
    }
    dispose() {
        var o;
        (o = this._pane) === null || o === void 0 || o.dispose(),
        this._pane = void 0
    }
    appendUiObject(o, c) {
        o && this._appendUiObject(o, c)
    }
    appendChild(o) {
        this.appendUiObject({
            uiConfig: o
        })
    }
    _appendUiObject(o, c) {
        var h, _, b, _e;
        const {uiConfig: nt} = o ?? {};
        if (nt && (!this._limitedOptions || nt.limitedUi) && (c = c ?? this._pane,
        nt.type)) {
            nt.uuid || (nt.uuid = esm_browser_v4()),
            nt.uiRef && nt.uiRefType !== nt.type && this.removeUiConfig(nt);
            const it = (_ = (h = this._typeGenerators)[nt.type]) === null || _ === void 0 ? void 0 : _.call(h, c, nt, this);
            it && (it.hidden = (b = Ee$1(nt.hidden)) !== null && b !== void 0 && b,
            it.disabled = (_e = Ee$1(nt.disabled)) !== null && _e !== void 0 && _e),
            nt.uiRef = it,
            nt.uiRefType = it ? nt.type : void 0,
            nt.uiRefresh = (at="postFrame", ut=!1, pt=0) => {
                var ht;
                return this._uiObjectRefresh(at, (ht = o == null ? void 0 : o.uiConfig) !== null && ht !== void 0 ? ht : nt, c, ut, pt)
            }
            ,
            it == null || it.controller_.viewProps.handleDispose( () => {
                nt.uiRef = void 0,
                nt.uiRefType = void 0,
                nt.uiRefresh = void 0
            }
            )
        }
    }
    removeUiObject(o) {
        this.removeUiConfig(o == null ? void 0 : o.uiConfig)
    }
    removeUiConfig(o) {
        var c, h;
        o && o.uiRef && ((h = (c = o.uiRef).dispose) === null || h === void 0 || h.call(c),
        o.uiRef = void 0,
        o.uiRefType = void 0,
        o.uiRefresh = void 0)
    }
    _uiObjectRefresh(o, c, h, _, b) {
        (_ ? flattenUiConfig(c, h) : [{
            uiConfig: c,
            parentFolder: h
        }]).forEach(_e => {
            const nt = [{
                uiConfig: _e.uiConfig
            }, _e.parentFolder, b];
            o === "immediate" ? this._refreshUiObject(...nt) : this.addToRefreshQueue(o, nt)
        }
        )
    }
    _refreshUiObject(o, c, h=0) {
        this._appendUiObject(o, c),
        h > 1e-4 && console.error("no support for immediate delay")
    }
    _createUiContainer() {
        const o = ee$1({
            id: "tweakpaneUiContainer",
            addToBody: !1
        });
        return P$2($`
          :root{
            --tweakpane-ui-container-width: 300px;
          }
          @media only screen and (min-width: 1500px) {
            :root{
              --tweakpane-ui-container-width: 300px;
            }
          }
          @media only screen and (min-width: 2500px) {
            :root{
              --tweakpane-ui-container-width: 500px;
            }
          }
          #tweakpaneUiContainer {
            position: fixed;
            top: 0px;
            padding-right: 4px;
            padding-bottom: 10px;
            right: 10px;
            width: var(--tweakpane-ui-container-width);
            height: auto;
            overflow-y: scroll;
            z-index: 100;
            pointer-events: auto;
            max-height: calc(100% - 6rem);
            border-radius: 0.5rem;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "system-ui", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
          }
        `),
        o
    }
    async alert(o) {
        return alert(o)
    }
    async confirm(o) {
        return confirm(o)
    }
    async prompt(o, c, h=!0) {
        return prompt(o, c)
    }
}
function flattenUiConfig(d, o, c) {
    return c = c ?? [],
    d && d.uiRef && (c.push({
        uiConfig: d,
        parentFolder: o
    }),
    typeof d.children == "function" || [...d.children || []].forEach(h => {
        typeof h != "function" && h && (Array.isArray(h) ? h.forEach(_ => c = flattenUiConfig(_, d.uiRef, c)) : c = flattenUiConfig(h, d.uiRef, c))
    }
    )),
    c
}
const tpImageInputGenerator = d => (o, c, h, _) => {
    let b = c.property || c.__property;
    const _e = "placeholder";
    c.value === void 0 && (c.getValue || c.setValue) && (Object.defineProperty(c, "_value", {
        get: () => {
            var at;
            return (at = c.getValue) === null || at === void 0 ? void 0 : at.call(c)
        }
        ,
        set: at => {
            var ut;
            return (ut = c.setValue) === null || ut === void 0 ? void 0 : ut.call(c, at)
        }
    }),
    b = [c, "_value"]);
    const [nt,it] = b && typeof b[0] == "object" ? b : [c, "value"];
    if ((!(Object.hasOwn ? Object.hasOwn(c, "value") : c.hasOwnProperty("value")) || c.value === void 0) && b && typeof b[0] == "object") {
        const at = Xe$1("Render Target")
          , ut = Xe$1("Data Texture")
          , pt = Xe$1("CUBE Texture")
          , ht = Xe$1("Compressed Texture")
          , _t = {}
          , vt = {};
        Object.defineProperty(c, "value", {
            get: () => {
                var bt;
                let St, At = nt[it];
                if (At != null && At.get && (At = At.get()),
                !At)
                    return _e;
                if (At.isCompressedTexture && At.image && !At.image.tp_src && (At.image.tp_src = ht),
                At.isTexture ? (At.image && !At.image.tp_src && (At.image instanceof ImageBitmap || At.image instanceof HTMLImageElement || At.image instanceof HTMLVideoElement) ? At.image.tp_src = Ne$1(At.image, 160) : At.image && At.isRenderTargetTexture && !At.image.tp_src ? At.__target && (At.tp_src = d.renderer.renderTargetToDataUrl(At.__target, void 0, void 0, Array.isArray(At.__target.texture) ? At.__target.texture.indexOf(At) : void 0)) : At.image && !At.image.tp_src && (At.image.tp_src = textureToCanvas(At, 160, !1).toDataURL("image/png", 90)),
                !At.isRenderTargetTexture || At.image.tp_src || At.tp_src || (At.image.tp_src = at),
                At.isDataTexture && At.image && !At.image.tp_src && (At.image.tp_src = ut),
                At.image && (St = At.image.tp_src_uuid,
                St = St ? _t[St] : void 0,
                St || (St = At.image.tp_src || At.image.src)),
                At.tp_src && (St = At.tp_src)) : typeof At == "string" ? St = At : At.domainMin ? (St = At.texture,
                At.texture.image && !At.texture.image.tp_src && (At.texture.image.tp_src = pt),
                At.texture.image && (St = At.texture.image.tp_src_uuid,
                St = St ? _t[St] : void 0,
                St || (St = At.texture.image.tp_src || At.texture.image.src))) : At && console.error("unknown value", At),
                St || (St = _e),
                At.image && !At.image.tp_src_uuid) {
                    const Et = esm_browser_v4();
                    At.image.tp_src_uuid = Et,
                    vt[St] = Et
                }
                return typeof St == "string" && (St = (bt = _t[St]) !== null && bt !== void 0 ? bt : St),
                St
            }
            ,
            set: bt => {
                var St, At, Et, Pt, It, Dt, Gt, Bt, kt, Ut, Ht, Kt, Jt;
                const or = nt[it]
                  , ir = ar => {
                    var hr;
                    nt[it] = ar,
                    ar != null && ar.isTexture && (ar.flipY = ar.isDataTexture ? ar.flipY : (hr = or == null ? void 0 : or.flipY) === null || hr === void 0 || hr)
                }
                ;
                if (typeof bt == "string")
                    return void (typeof or == "string" && ir(bt));
                if (!bt)
                    return void (c.value = _e);
                if (bt.isPlaceholder)
                    return void (or && (ir(typeof or == "string" ? "" : null),
                    typeof (nt == null ? void 0 : nt.setDirty) == "function" && nt.setDirty()));
                let lr = bt.tp_src_uuid;
                if (lr || (lr = (St = bt.src) !== null && St !== void 0 ? St : bt.tp_src,
                lr = (At = vt[lr]) !== null && At !== void 0 ? At : lr,
                delete vt[lr],
                bt.tp_src_uuid = lr),
                lr && (_t[lr] = bt),
                typeof or != "string") {
                    if (!((or == null ? void 0 : or.image) === bt || ((Et = or == null ? void 0 : or.image) === null || Et === void 0 ? void 0 : Et.src) === bt.src || ((Pt = or == null ? void 0 : or.image) === null || Pt === void 0 ? void 0 : Pt.tp_src) === bt.tp_src && bt.tp_src != null || ((It = or == null ? void 0 : or.image) === null || It === void 0 ? void 0 : It.tp_src) === bt.src && bt.src != null || ((Dt = or == null ? void 0 : or.image) === null || Dt === void 0 ? void 0 : Dt.src) === bt.tp_src && bt.tp_src != null))
                        if (bt instanceof File) {
                            const ar = d == null ? void 0 : d.getPlugin(AssetManagerPlugin);
                            if (!ar)
                                throw "Viewer or AssetManagerPlugin not found";
                            (Gt = ar.importer) === null || Gt === void 0 || Gt.importSingle({
                                file: bt,
                                path: bt.src
                            }).then(hr => {
                                var gr, dr, cr, Ar;
                                if (hr) {
                                    hr.isDataTexture && (hr.needsUpdate = !0);
                                    const wr = (cr = (dr = (gr = bt.src) === null || gr === void 0 ? void 0 : gr.split("?")) === null || dr === void 0 ? void 0 : dr[0]) === null || cr === void 0 ? void 0 : cr.split(".").pop();
                                    hr.userData && (hr.userData.mimeType || (hr.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(wr) ? "jpeg" : "png"))),
                                    ir(hr),
                                    [c.onChange].flat().forEach(Rr => typeof Rr == "function" && (Rr == null ? void 0 : Rr())),
                                    typeof (nt == null ? void 0 : nt.setDirty) == "function" && nt.setDirty(),
                                    (Ar = c.uiRefresh) === null || Ar === void 0 || Ar.call(c, "postFrame", !1)
                                }
                            }
                            )
                        } else {
                            if (SVGTextureLoader.USE_CANVAS_TEXTURE && (!((Bt = bt.src) === null || Bt === void 0) && Bt.endsWith(".svg") || !((kt = bt.src) === null || kt === void 0) && kt.startsWith("data:image/svg"))) {
                                const dr = document.createElement("canvas");
                                SVGTextureLoader.CopyImageToCanvas(dr, bt),
                                bt = dr
                            }
                            const ar = new three_module.gPd(bt);
                            ar.assetType = "texture",
                            ar.needsUpdate = !0;
                            const hr = (Kt = (Ht = (Ut = bt.src) === null || Ut === void 0 ? void 0 : Ut.split("?")) === null || Ht === void 0 ? void 0 : Ht[0]) === null || Kt === void 0 ? void 0 : Kt.split(".").pop();
                            ar.userData.mimeType || (ar.userData.mimeType = "image/" + (["jpg", "jpeg"].includes(hr) ? "jpeg" : "png"));
                            const gr = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(it);
                            ar.colorSpace = gr ? three_module.Zr2 : three_module.er$,
                            ar.wrapS = three_module.GJx,
                            ar.wrapT = three_module.GJx,
                            ir(ar),
                            [c.onChange].flat().forEach(dr => typeof dr == "function" && (dr == null ? void 0 : dr())),
                            typeof (nt == null ? void 0 : nt.setDirty) == "function" && nt.setDirty(),
                            (Jt = c.uiRefresh) === null || Jt === void 0 || Jt.call(c, "postFrame", !1)
                        }
                } else
                    ir(lr)
            }
        }),
        c.__property = c.property,
        c.property = void 0,
        c.label === void 0 && (c.label = it)
    }
    return (_ = _ ?? {}).extensions = [".jpg", ".png", ".svg", ".hdr", ".exr", ".jpeg", ".bmp", ".gif", ".webp", ".cube", "ktx2"],
    _.imageFit === void 0 && (_.imageFit = "contain"),
    _.clickCallback === void 0 && (_.clickCallback = (at, ut) => {
        var pt;
        const ht = at == null ? void 0 : at.target
          , _t = ht == null ? void 0 : ht.getBoundingClientRect();
        if (!_t)
            return void ut.click();
        const vt = c.uiRef.controller_.valueController.value.rawValue
          , bt = vt === _e || vt != null && vt.isPlaceholder ? {} : {
            "remove image": () => {
                var At;
                c.uiRef.controller_.valueController.value.setRawValue("");
                const Et = typeof nt[it] == "string";
                nt[it] = Et ? "" : null,
                [c.onChange].flat().forEach(Pt => typeof Pt == "function" && (Pt == null ? void 0 : Pt())),
                typeof (nt == null ? void 0 : nt.setDirty) == "function" && nt.setDirty(),
                (At = c.uiRefresh) === null || At === void 0 || At.call(c, "postFrame", !1),
                CustomContextMenu.Remove()
            }
            ,
            "download image": async () => {
                var At, Et, Pt;
                CustomContextMenu.Remove();
                const It = nt[it];
                if (!It)
                    return;
                const Dt = (At = It == null ? void 0 : It.image) !== null && At !== void 0 ? At : c.uiRef.controller_.valueController.value.rawValue;
                let Gt = It.__rootBlob ? It.__rootBlob.objectUrl || URL.createObjectURL(It.__rootBlob) : ((Et = It.userData) === null || Et === void 0 ? void 0 : Et.rootPath) || (Dt == null ? void 0 : Dt.src);
                Dt && (Dt instanceof ImageBitmap || Dt instanceof HTMLImageElement || Dt instanceof HTMLVideoElement) && !Gt && (Gt = Ne$1(Dt));
                let Bt = It.__rootBlob ? It.__rootBlob.name || "image." + (It.__rootBlob.ext || "png") : null;
                if (!Gt && It.isRenderTargetTexture) {
                    const Ut = It.__target;
                    if (It.type === three_module.OUM)
                        Gt = d.renderer.renderTargetToDataUrl(Ut, "image/png", 90, Array.isArray(It.__target.texture) ? It.__target.texture.indexOf(It) : void 0),
                        Bt = "renderTarget.png";
                    else {
                        const Ht = new EXRExporter2().parse(d.renderer.rendererObject, Ut, {
                            textureIndex: Array.isArray(It.__target.texture) ? It.__target.texture.indexOf(It) : void 0
                        })
                          , Kt = new Blob([Ht],{
                            type: "image/x-exr"
                        });
                        if (!Kt)
                            return void console.error("cannot export render target", Dt, nt[it], nt, it, c);
                        Bt = "renderTarget.exr",
                        Gt = URL.createObjectURL(Kt)
                    }
                }
                if (!Gt && It.isDataTexture) {
                    const Ut = new EXRExporter2().parse(void 0, It)
                      , Ht = new Blob([Ut],{
                        type: "image/x-exr"
                    });
                    if (!Ht)
                        return void console.error("cannot export data texture", Dt, nt[it], nt, it, c);
                    Bt = "dataTexture.exr",
                    Gt = URL.createObjectURL(Ht)
                }
                if (!Gt)
                    return void console.error("cannot export image", Dt, nt[it], nt, it, c);
                const kt = document.createElement("a");
                document.body.appendChild(kt),
                kt.style.display = "none",
                kt.href = Gt,
                kt.download = Bt || (Gt.startsWith("data:") ? "image.png" : (Pt = Gt.split("/").pop()) !== null && Pt !== void 0 ? Pt : "image.png"),
                kt.target = "_blank",
                kt.click(),
                document.body.removeChild(kt)
            }
        }
          , St = CustomContextMenu.Create({
            ...bt,
            "set/replace image": () => {
                ut.click(),
                CustomContextMenu.Remove()
            }
            ,
            "from url": async () => {
                var At, Et;
                let Pt = "";
                if (Pt = await h.prompt("Load texture: Enter Image/Texture URL", Pt, !0),
                !Pt || !Pt.startsWith("http") && !Pt.startsWith("data:image"))
                    return Pt !== null && await h.alert("Loading Image: Invalid URL"),
                    void CustomContextMenu.Remove();
                Pt = Pt.trim();
                const It = nt[it];
                if (typeof It == "string")
                    nt[it] = Pt,
                    [c.onChange].flat().forEach(Dt => typeof Dt == "function" && (Dt == null ? void 0 : Dt())),
                    typeof (nt == null ? void 0 : nt.setDirty) == "function" && nt.setDirty(),
                    (At = c.uiRefresh) === null || At === void 0 || At.call(c, "postFrame", !1);
                else {
                    const Dt = d == null ? void 0 : d.getPlugin(AssetManagerPlugin);
                    if (!Dt)
                        throw "Viewer or AssetManagerPlugin not found";
                    (Et = Dt.importer) === null || Et === void 0 || Et.importSinglePath(Pt).then(Gt => {
                        var Bt;
                        if (Gt) {
                            Gt.isDataTexture ? Gt.needsUpdate = !0 : Gt && (It == null ? void 0 : It.flipY) !== void 0 && (Gt.flipY = It.flipY);
                            const kt = ["normalMap", "aoMap", "emissiveMap", "roughnessMap", "metalnessMap", "displacementMap", "bumpMap", "alphaMap"].includes(it);
                            Gt.colorSpace = kt ? three_module.Zr2 : three_module.er$,
                            nt[it] = Gt,
                            [c.onChange].flat().forEach(Ut => typeof Ut == "function" && (Ut == null ? void 0 : Ut())),
                            typeof (nt == null ? void 0 : nt.setDirty) == "function" && nt.setDirty(),
                            (Bt = c.uiRefresh) === null || Bt === void 0 || Bt.call(c, "postFrame", !1)
                        } else
                            console.warn("uiconfig-tweakpane: Failed to load texture", Pt)
                    }
                    )
                }
                CustomContextMenu.Remove()
            }
            ,
            cancel: () => {
                CustomContextMenu.Remove()
            }
        }, 2, _t.height + 8);
        (pt = ht.parentElement) === null || pt === void 0 || pt.appendChild(St),
        _t.y > .7 * document.body.clientHeight && (St.style.top = "auto",
        St.style.bottom = _t.height + 8 + "px")
    }
    ),
    _.view = "input-image",
    tpInputGenerator(o, c, h, _)
}
;
var tpTheme = __webpackgi_require__(367)
  , tpTheme_exported = {};
tpTheme.A && tpTheme.A.locals && (tpTheme_exported.locals = tpTheme.A.locals);
var tpTheme_refs = 0, tpTheme_update, tpTheme_options = {};
tpTheme_options.styleTagTransform = styleTagTransform_default(),
tpTheme_options.setAttributes = setAttributesWithoutAttributes_default(),
tpTheme_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
tpTheme_options.domAPI = styleDomAPI_default(),
tpTheme_options.insertStyleElement = insertStyleElement_default(),
tpTheme_exported.use = function(d) {
    return tpTheme_options.options = d || {},
    tpTheme_refs++ || (tpTheme_update = injectStylesIntoStyleTag_default()(tpTheme.A, tpTheme_options)),
    tpTheme_exported
}
,
tpTheme_exported.unuse = function() {
    tpTheme_refs > 0 && !--tpTheme_refs && (tpTheme_update(),
    tpTheme_update = null)
}
;
var ui_tpTheme = tpTheme_exported
  , TweakpaneUiPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class TweakpaneUiPlugin extends TweakpaneWrapper {
    constructor(o=!1, c=!1, h=!1, _, b) {
        var _e, nt;
        super(o, c, h, !1, (_e = _ ?? document.getElementById("tweakpaneMainPanelSlot")) !== null && _e !== void 0 ? _e : document.body),
        this.dependencies = [AssetManagerPlugin],
        this._preRender = () => this.refreshQueue("preRender"),
        this._postRender = () => this.refreshQueue("postRender"),
        this._postFrame = it => {
            this.dispatchEvent(it),
            this.refreshQueue("postFrame")
        }
        ,
        this._preFrame = () => this.refreshQueue("preFrame"),
        this._plugins = [],
        this._pane.registerPlugin(tweakpane_image_plugin),
        ui_tpTheme.use({
            target: this._container
        }),
        this.colorMode = (nt = b ?? (localStorage ? localStorage.getItem("tpTheme") : "blue")) !== null && nt !== void 0 ? nt : "blue"
    }
    async onAdded(o) {
        this._viewer = o,
        this._typeGenerators.image = tpImageInputGenerator(this._viewer),
        o.addEventListener("preRender", this._preRender),
        o.addEventListener("postRender", this._postRender),
        o.addEventListener("preFrame", this._preFrame),
        o.addEventListener("postFrame", this._postFrame)
    }
    async onDispose(o) {
        this.dispose()
    }
    async onRemove(o) {
        this._viewer = void 0,
        o.removeEventListener("preRender", this._preRender),
        o.removeEventListener("postRender", this._postRender),
        o.removeEventListener("preFrame", this._preFrame),
        o.removeEventListener("postFrame", this._postFrame),
        this.dispose()
    }
    setupPluginUi(o) {
        var c;
        const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPlugin(o);
        if (!h)
            return void console.warn("plugin not found:", o);
        this._plugins.push(h),
        h.uiConfig && (h.uiConfig.limitedUi = !0),
        h.uiConfig && h.uiConfig.hidden === void 0 && (h.uiConfig.hidden = !1),
        this._appendUiObject(h);
        const _ = h.uiConfig;
        if (_ != null && _.uiRef && h.toJSON) {
            const b = typeof h.toJSON == "function" ? h.toJSON() : null;
            h.resetDefaults = async () => {
                var it, at;
                await ((it = h.fromJSON) === null || it === void 0 ? void 0 : it.call(h, b)),
                (at = _.uiRefresh) === null || at === void 0 || at.call(_, "postFrame", !0)
            }
            ;
            const _e = _.uiRef.controller_.view.element
              , nt = ee$1({
                innerHTML: "&#8942;",
                classList: ["pluginOptionsButton"],
                elementTag: "button"
            });
            nt.onclick = it => {
                const at = {};
                typeof h.toJSON == "function" && (at["download preset"] = async () => {
                    var pt, ht;
                    const _t = (ht = (pt = this._viewer) === null || pt === void 0 ? void 0 : pt.getPlugin(AssetManagerPlugin)) === null || ht === void 0 ? void 0 : ht.exportPluginPreset(h);
                    await N$2(new Blob([JSON.stringify(_t, null, 2)],{
                        type: "application/json"
                    }), "preset." + h.constructor.PluginType + ".json"),
                    CustomContextMenu.Remove()
                }
                ),
                typeof h.fromJSON == "function" && (at["upload preset"] = async () => {
                    var pt, ht, _t;
                    CustomContextMenu.Remove();
                    const vt = await ge$1(!1, !1);
                    if (vt.length === 0)
                        return;
                    const bt = vt[0]
                      , St = await bt.text()
                      , At = JSON.parse(St);
                    await ((ht = (pt = this._viewer) === null || pt === void 0 ? void 0 : pt.getPlugin(AssetManagerPlugin)) === null || ht === void 0 ? void 0 : ht.importPluginPreset(At, h)),
                    (_t = _.uiRefresh) === null || _t === void 0 || _t.call(_, "postFrame", !0)
                }
                ,
                b && (at["reset defaults"] = async () => {
                    var pt, ht;
                    CustomContextMenu.Remove(),
                    await ((ht = (pt = h).resetDefaults) === null || ht === void 0 ? void 0 : ht.call(pt))
                }
                ));
                const ut = CustomContextMenu.Create(at, _e.clientWidth - 120, 12);
                _e.append(ut),
                it.preventDefault()
            }
            ,
            _e.appendChild(nt)
        }
        return _
    }
    setupPlugins(...o) {
        o.forEach(c => this.setupPluginUi(c))
    }
    refreshPluginsEnabled() {
        this._plugins.forEach(o => {
            var c;
            const h = o.uiConfig;
            h && (Ee$1(h.hidden) !== !0 ? (c = h.uiRefresh) === null || c === void 0 || c.call(h, "postFrame", !0) : h.uiRef && (h.uiRef.hidden = !0))
        }
        )
    }
    async alert(o) {
        return this._viewer ? this._viewer.alert(o) : super.alert(o)
    }
    async confirm(o) {
        return this._viewer ? this._viewer.confirm(o) : super.confirm(o)
    }
    async prompt(o, c, h=!0) {
        return this._viewer ? this._viewer.prompt(o, c, h) : super.prompt(o, c, h)
    }
    _colorModeChanged() {
        document.body.classList.remove("tpTheme-black", "tpTheme-white", "tpTheme-blue"),
        document.body.classList.add("tpTheme-" + this.colorMode),
        localStorage && localStorage.setItem("tpTheme", this.colorMode)
    }
}
TweakpaneUiPlugin.PluginType = "TweakpaneUi",
TweakpaneUiPlugin_decorate([x$1(TweakpaneUiPlugin.prototype._colorModeChanged)], TweakpaneUiPlugin.prototype, "colorMode", void 0);
class SimpleBackgroundEnvUiPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this._savedBg = !1,
        this.lastBgVal = null,
        this.uiConfig = {
            label: "Background / Environment",
            type: "folder",
            expanded: !1,
            limitedUi: !0,
            children: [{
                label: "Color",
                type: "color",
                inlinePicker: !0,
                property: [this, "sceneBackgroundColor"],
                limitedUi: !0
            }, () => ({
                label: "Image",
                property: [this, "sceneBackground"],
                type: "image",
                limitedUi: !0
            }), {
                label: "EnvMap BG",
                type: "checkbox",
                property: [this, "envmapBg"]
            }, () => ({
                type: "slider",
                label: "BG Intensity",
                getValue: () => {
                    var o, c;
                    return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.backgroundIntensity) !== null && c !== void 0 ? c : 1
                }
                ,
                setValue: o => {
                    this._viewer && (this._viewer.scene.backgroundIntensity = o)
                }
                ,
                bounds: [0, 16]
            }), {
                label: "Set Transparent BG",
                type: "button",
                hidden: () => !this._viewer || this._viewer.useRgbm,
                value: () => {
                    this._viewer && (this._viewer.scene.background = null,
                    this._viewer.scene.backgroundColor = null)
                }
            }, () => ({
                label: "Environment",
                getValue: () => {
                    var o;
                    return ((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.environment) || null
                }
                ,
                setValue: o => {
                    this._viewer && (this._viewer.scene.environment = o)
                }
                ,
                type: "image",
                limitedUi: !0
            }), {
                type: "slider",
                label: "Env Rotation",
                getValue: () => {
                    var o, c, h;
                    return (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.environment) === null || c === void 0 ? void 0 : c.rotation) !== null && h !== void 0 ? h : 0
                }
                ,
                setValue: o => {
                    var c, h;
                    const _ = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.environment;
                    _ && (_.rotation = o,
                    (h = this._viewer) === null || h === void 0 || h.scene.setDirty())
                }
                ,
                bounds: [0, 2 * Math.PI],
                limitedUi: !0
            }, {
                type: "slider",
                label: "Env Intensity",
                getValue: () => {
                    var o, c;
                    return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.envMapIntensity) !== null && c !== void 0 ? c : 1
                }
                ,
                setValue: o => {
                    var c;
                    !((c = this._viewer) === null || c === void 0) && c.scene && (this._viewer.scene.envMapIntensity = o)
                }
                ,
                bounds: [0, 4],
                limitedUi: !0
            }, () => ({
                label: "Environment1",
                getValue: () => {
                    var o;
                    return ((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.textureSlots.environment1) || null
                }
                ,
                setValue: o => {
                    this._viewer && (o.mapping === three_module.UTZ && (o.mapping = three_module.wfO,
                    o.needsUpdate = !0),
                    this._viewer.scene.textureSlots.environment1 = o)
                }
                ,
                type: "image"
            }), {
                type: "slider",
                label: "Env1 Rotation",
                hidden: () => {
                    var o;
                    return !(!((o = this._viewer) === null || o === void 0) && o.scene.textureSlots.environment1)
                }
                ,
                getValue: () => {
                    var o, c, h;
                    return (h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.textureSlots.environment1) === null || c === void 0 ? void 0 : c.rotation) !== null && h !== void 0 ? h : 0
                }
                ,
                setValue: o => {
                    var c, h;
                    const _ = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.textureSlots.environment1;
                    _ && (_.rotation = o,
                    (h = this._viewer) === null || h === void 0 || h.scene.setDirty())
                }
                ,
                bounds: [0, 2 * Math.PI]
            }, {
                type: "checkbox",
                label: "Fixed Env Direction",
                getValue: () => {
                    var o, c;
                    return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.fixedEnvMapDirection) !== null && c !== void 0 && c
                }
                ,
                setValue: o => {
                    this._viewer && (this._viewer.scene.fixedEnvMapDirection = o)
                }
            }]
        }
    }
    get sceneBackgroundColor() {
        var o, c;
        const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.backgroundColor) === null || c === void 0 ? void 0 : c.getHex(three_module.er$);
        return h !== void 0 && (this._savedBg = !0),
        h || 0
    }
    set sceneBackgroundColor(o) {
        this._viewer && this._savedBg && (this._viewer.scene.backgroundColor || (this._viewer.scene.backgroundColor = new three_module.Q1f),
        this._viewer.scene.backgroundColor.setHex(o),
        this._viewer.scene.setDirty())
    }
    get sceneBackground() {
        var o;
        const c = (o = this._viewer) === null || o === void 0 ? void 0 : o.scene.background;
        return c && (c.isTexture || c.assetType === "texture") ? c : null
    }
    set sceneBackground(o) {
        this._viewer && (this._viewer.scene.background = o)
    }
    get envmapBg() {
        var o, c, h;
        return ((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.background) === "environment" || ((c = this._viewer) === null || c === void 0 ? void 0 : c.scene.background) === ((h = this._viewer) === null || h === void 0 ? void 0 : h.scene.environment)
    }
    set envmapBg(o) {
        if (this._viewer)
            if (o) {
                const c = this._viewer.scene.background;
                c && c !== this._viewer.scene.environment && c !== "environment" && (this.lastBgVal = c),
                this._viewer.scene.background = "environment"
            } else
                this._viewer.scene.background !== this._viewer.scene.environment && this._viewer.scene.background !== "environment" || (this._viewer.scene.background = this.lastBgVal)
    }
    async onAdded(o) {
        await super.onAdded(o),
        this.lastBgVal = o.scene.background,
        o.scene.addEventListener("backgroundChanged", () => {
            var c, h;
            (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
        }
        ),
        o.scene.addEventListener("environmentChanged", () => {
            var c, h;
            (h = (c = this.uiConfig).uiRefresh) === null || h === void 0 || h.call(c, "postFrame", !0)
        }
        )
    }
}
SimpleBackgroundEnvUiPlugin.PluginType = "SimpleBackgroundEnvUiPlugin1";
class SimpleViewerUi extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this._uiConfig = {
            type: "folder",
            label: "Scene",
            children: [],
            onExpand: () => {
                var o, c;
                (c = (o = this._uiConfig).uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0)
            }
        },
        this._clearSceneButton = {
            type: "button",
            label: "Clear Scene",
            value: () => {
                var o;
                (o = this._viewer) === null || o === void 0 || o.scene.disposeSceneModels()
            }
        },
        this._sceneUpdate = this._sceneUpdate.bind(this)
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("sceneUpdate", this._sceneUpdate)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("sceneUpdate", this._sceneUpdate),
        super.onRemove(o)
    }
    setDirty() {
        var o;
        (o = this._viewer) === null || o === void 0 || o.setDirty()
    }
    get uiConfig() {
        return this._viewer ? (this._uiConfig.children = [this._clearSceneButton],
        this._uiConfig) : this._uiConfig
    }
    _sceneUpdate() {}
}
SimpleViewerUi.PluginType = "SimpleUi";
var tree = __webpackgi_require__(530)
  , tree_default = __webpackgi_require__.n(tree)
  , treejs = tree_default();
class HierarchyUiPlugin extends AViewerPlugin {
    constructor(o=!0) {
        super(),
        this.enabled = !0,
        this.toJSON = void 0,
        this.treeView = void 0,
        this.hierarchyDiv = ee$1({
            innerHTML: "",
            id: "tpHierarchyContainer",
            addToBody: !1
        }),
        this._resetting = !1,
        this._uiConfig = {
            type: "folder",
            label: "Hierarchy",
            children: []
        },
        this._buildData = (c, h) => (c.push({
            text: h.name || "unnamed",
            id: h.uuid,
            children: h.children.reduce(this._buildData, [])
        }),
        c),
        this._findVisible = (c, h) => (h.visible && (h.children.length < 1 ? c.push(h.uuid) : c.push(...h.children.reduce(this._findVisible, []))),
        c),
        this._setVisible = c => {
            var h;
            (h = this._viewer) === null || h === void 0 || h.doOnce("postFrame", () => {
                var _, b, _e;
                const nt = (_ = this._viewer) === null || _ === void 0 ? void 0 : _.scene.modelRoot;
                if (!nt || c == null)
                    return;
                const it = new Set;
                nt.traverse(at => {
                    at !== nt && (at.visible = c.includes(at.uuid),
                    at.visible && at.traverseAncestors(ut => it.add(ut)))
                }
                ),
                it.forEach(at => at.visible = !0),
                (_e = (b = this._viewer) === null || b === void 0 ? void 0 : b.scene) === null || _e === void 0 || _e.setDirty({
                    sceneUpdate: !0,
                    fromHierarchyPlugin: !0,
                    updateGround: !1
                })
            }
            )
        }
        ,
        this.enabled = o,
        this.reset = this.reset.bind(this),
        P$2($`
#tpHierarchyContainer{
  width: 100%;
  height: auto;
  background-color: transparent;
  color: var(--tp-container-foreground-color, hsl(230, 7%, 75%));
  margin-top: 0;
}
.treejs .treejs-switcher:before {
    border-top: 6px solid var(--tp-container-foreground-color, hsl(230, 7%, 75%)) !important;
}
        `)
    }
    _reset(o) {
        var c;
        if (o != null && o.fromHierarchyPlugin || o && !o.hierarchyChanged)
            return;
        for (; this.hierarchyDiv.firstChild; )
            this.hierarchyDiv.firstChild.remove();
        const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.modelRoot;
        if (!h)
            return;
        const _ = h.children.reduce(this._buildData, [])
          , b = h.children.reduce(this._findVisible, []);
        let _e = !1;
        return new Promise( (nt, it) => {
            this.treeView = new treejs(this.hierarchyDiv,{
                closeDepth: 1,
                data: _,
                loaded: function() {
                    this.values = b,
                    nt()
                },
                onChange: () => {
                    _e ? X$2(200).then( () => {
                        this.treeView && this._setVisible(this.treeView.values)
                    }
                    ) : _e = !0
                }
                ,
                onItemLabelClick: at => {
                    var ut;
                    const pt = (ut = this._viewer) === null || ut === void 0 ? void 0 : ut.scene.modelRoot.modelObject.getObjectByProperty("uuid", at);
                    pt && h.visible && pt.dispatchEvent({
                        type: "select",
                        value: pt,
                        ui: !0
                    })
                }
            })
        }
        )
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("sceneUpdate", this.reset),
        await this.reset()
    }
    async reset(o) {
        this._resetting || (this._resetting = !0,
        await X$2(500),
        await this._reset(o),
        this._resetting = !1)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("sceneUpdate", this.reset),
        super.onRemove(o)
    }
    async onDispose(o) {
        return super.onDispose(o)
    }
    get uiConfig() {
        return this._uiConfig.domChildren || (this._uiConfig.domChildren = [this.hierarchyDiv]),
        this._uiConfig
    }
}
HierarchyUiPlugin.PluginType = "HierarchyUiPlugin";
class LightsUiPlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.toJSON = void 0,
        this.enabled = !0,
        this.uiConfig = {
            type: "folder",
            label: "Lights",
            children: [{
                type: "button",
                label: "Add Directional Light",
                value: () => {
                    if (!this._viewer)
                        return;
                    const o = new DirectionalLight2;
                    o.position.set(0, 0, 0),
                    o.target.position.set(0, 0, -1).normalize(),
                    o.intensity = 2,
                    o.shadow.mapSize.set(1024, 1024),
                    this._viewer.scene.addLight(o)
                }
            }, {
                type: "button",
                label: "Add Ambient Light",
                value: () => {
                    if (!this._viewer)
                        return;
                    const o = new AmbientLight2;
                    o.intensity = 2,
                    this._viewer.scene.addLight(o)
                }
            }, {
                type: "button",
                label: "Add Point Light",
                value: () => {
                    if (!this._viewer)
                        return;
                    const o = new PointLight2;
                    o.position.set(3, 3, 3),
                    o.shadow.mapSize.set(1024, 1024),
                    o.intensity = 2,
                    this._viewer.scene.addLight(o)
                }
            }, {
                type: "button",
                label: "Add Spot Light",
                value: () => {
                    if (!this._viewer)
                        return;
                    const o = new SpotLight2;
                    o.position.set(3, 3, 3),
                    o.shadow.mapSize.set(1024, 1024),
                    o.intensity = 2,
                    o.lookAt(0, 0, 0),
                    this._viewer.scene.addLight(o)
                }
            }],
            limitedUi: !0
        },
        this.dependencies = [AssetManagerPlugin],
        this._sceneUpdate = o => {
            var c, h, _;
            if (!o.hierarchyChanged)
                return;
            const b = [];
            (c = this._viewer) === null || c === void 0 || c.traverseSceneObjects(_e => {
                if (!_e.lightObject)
                    return;
                const nt = _e.uiConfig;
                nt && !b.includes(nt) && b.push(nt)
            }
            ),
            [...this.uiConfig.children].forEach(_e => {
                (_e == null ? void 0 : _e.type) === "button" || b.includes(_e) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(_e), 1)
            }
            ),
            b.forEach(_e => {
                this.uiConfig.children.includes(_e) || this.uiConfig.children.push(_e)
            }
            ),
            (_ = (h = this.uiConfig).uiRefresh) === null || _ === void 0 || _.call(h, "postFrame", !0)
        }
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("sceneUpdate", this._sceneUpdate)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("sceneUpdate", this._sceneUpdate),
        super.onRemove(o)
    }
}
LightsUiPlugin.PluginType = "SimpleLightsUi";
class SceneCamerasUiPlugin extends AViewerPlugin {
    constructor() {
        super(),
        this.toJSON = void 0,
        this.enabled = !0,
        this.uiConfig = {
            type: "folder",
            label: "Cameras (Loaded)",
            children: [{
                type: "button",
                label: "Add Camera",
                value: () => {
                    var o;
                    if (!this._viewer)
                        return;
                    const c = this._viewer.createCamera(new three_module.ubm(45,1,.5,20));
                    this._viewer.scene.modelRoot.add(c.cameraObject),
                    c.setCameraOptions({
                        controlsMode: "orbit"
                    }),
                    c.position.set(2, 2, 2),
                    c.target.set(0, 0, 0),
                    c.positionUpdated(!0),
                    c.cameraObject.lookAt(0, 0, 0),
                    c.setDirty();
                    const h = this._viewer.getPluginByType("VirtualCamerasPlugin");
                    if (h) {
                        const _ = h.addCamera(c)
                          , b = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("debug");
                        b && b.addTexture("camera frame", () => _.target.texture, [40, 310, 300, 200])
                    }
                }
            }],
            limitedUi: !0
        },
        this.dependencies = [AssetManagerPlugin],
        this._sceneUpdate = o => {
            var c, h, _;
            if (!o.hierarchyChanged)
                return;
            const b = [];
            (c = this._viewer) === null || c === void 0 || c.traverseSceneObjects(_e => {
                if (!_e.cameraObject)
                    return;
                const nt = _e.uiConfig;
                nt && !b.includes(nt) && b.push(nt)
            }
            ),
            [...this.uiConfig.children].forEach(_e => {
                (_e == null ? void 0 : _e.type) === "button" || b.includes(_e) || this.uiConfig.children.splice(this.uiConfig.children.indexOf(_e), 1)
            }
            ),
            b.forEach(_e => {
                this.uiConfig.children.includes(_e) || this.uiConfig.children.push(_e)
            }
            ),
            (_ = (h = this.uiConfig).uiRefresh) === null || _ === void 0 || _.call(h, "postFrame", !0)
        }
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("sceneUpdate", this._sceneUpdate)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("sceneUpdate", this._sceneUpdate),
        super.onRemove(o)
    }
}
SceneCamerasUiPlugin.PluginType = "SimpleSceneCamerasUi";
var RendererUiPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, RendererUiPlugin_1;
let RendererUiPlugin = RendererUiPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this._serializeVersion = 1,
        this.mode = "full",
        this.width = 0,
        this.height = 0,
        this.scale = 1,
        this._sizeChanged = this._sizeChanged.bind(this),
        this._refresh = this._refresh.bind(this),
        this.refreshSize = this.refreshSize.bind(this)
    }
    refreshSize() {
        var d;
        this.enabled && (this._sizeChanged(),
        (d = this._viewer) === null || d === void 0 || d.setDirty())
    }
    _sizeChanged(d=!0) {
        if (!this._viewer || !this.enabled)
            return;
        if (this.mode === "full")
            return this._viewer.setSize({}),
            this._setScale(this.scale),
            void this._refresh();
        const o = {
            width: Math.floor(this.width),
            height: Math.floor(this.height)
        }
          , c = this._viewer.container.getBoundingClientRect()
          , h = {
            width: Math.floor(c.width),
            height: Math.floor(c.height)
        };
        let _ = 1;
        if (o.width > h.width) {
            const b = o.width;
            o.width = h.width;
            const _e = o.width / b;
            if (o.height = Math.floor(o.height * _e),
            _ /= _e,
            _ > RendererUiPlugin_1.MaxCanvasScale)
                return this.width = h.width * RendererUiPlugin_1.MaxCanvasScale,
                console.log("loop", this.width, h.width, _),
                void this._sizeChanged()
        }
        if (o.height > h.height) {
            const b = o.height;
            o.height = h.height;
            const _e = o.height / b;
            if (o.width = Math.floor(o.width * _e),
            _ /= _e,
            _ > RendererUiPlugin_1.MaxCanvasScale)
                return this.height = h.height * RendererUiPlugin_1.MaxCanvasScale,
                console.log("loop", this.width, h.width, this.height, h.height, _),
                void this._sizeChanged()
        }
        (o.width >= h.width || o.width < 1) && delete o.width,
        (o.height >= h.height || o.height < 1) && delete o.height,
        this._viewer.setSize(o),
        this._setScale(_),
        d && (this.scale = _),
        this._refresh()
    }
    _setScale(d) {
        this._viewer && (this._viewer.renderer.displayCanvasScaling = d)
    }
    _scaleChanged() {
        if (!this._viewer)
            return;
        const d = this.scale;
        if (Math.abs(d - this._viewer.renderer.displayCanvasScaling) < .01)
            return;
        if (this.mode === "full")
            return void this._sizeChanged();
        const o = this.width / this.height
          , c = this._viewer.container.getBoundingClientRect()
          , h = Math.floor(c.width * d)
          , _ = Math.floor(h / o);
        this.width = h,
        this.height = _,
        this._sizeChanged(!1)
    }
    async onAdded(d) {
        await super.onAdded(d);
        const o = d.canvas.clientWidth
          , c = d.canvas.clientHeight
          , h = d.renderer.displayCanvasScaling;
        this.width = o,
        this.height = c,
        this.scale = h,
        d.renderer.addEventListener("resize", this.refreshSize),
        this.addEventListener("deserialize", this.refreshSize),
        this._refresh()
    }
    async onRemove(d) {
        return this.removeEventListener("deserialize", this.refreshSize),
        d.renderer.removeEventListener("resize", this.refreshSize),
        super.onRemove(d)
    }
    _refresh() {
        var d, o;
        (o = (d = this.uiConfig) === null || d === void 0 ? void 0 : d.uiRefresh) === null || o === void 0 || o.call(d, "postFrame", !0)
    }
    fromJSON(d, o) {
        if (!d.mode)
            if (d.width || d.height) {
                const c = this._viewer.container.getBoundingClientRect();
                d.width || (d.width = c.width),
                d.height || (d.height = c.height),
                d.scale && (d.width *= d.scale,
                d.height *= d.scale,
                delete d.scale),
                d.width = Math.round(d.width),
                d.height = Math.round(d.height),
                d.mode = "custom"
            } else
                d.mode = "full";
        return super.fromJSON(d, o)
    }
    toJSON(d) {
        const o = super.toJSON(d);
        return o.mode === "full" && (delete o.width,
        delete o.height),
        o.mode === "custom" && delete o.scale,
        o
    }
}
;
RendererUiPlugin.PluginType = "RendererParamsUiPlugin",
RendererUiPlugin.MaxCanvasScale = 5,
RendererUiPlugin_decorate([serialize("version")], RendererUiPlugin.prototype, "_serializeVersion", void 0),
RendererUiPlugin_decorate([serialize(), uiDropdown("Mode", ["full", "custom"].map(d => ({
    label: d
}))), ze$1(RendererUiPlugin.prototype._sizeChanged)], RendererUiPlugin.prototype, "mode", void 0),
RendererUiPlugin_decorate([serialize(), uiSlider("Width", void 0, 1, d => ({
    onChange: () => d._sizeChanged(),
    hidden: () => d.mode === "full",
    bounds: () => {
        var o;
        return [10, Math.pow(2, Math.ceil(Math.log2(((o = d._viewer) === null || o === void 0 ? void 0 : o.container.getBoundingClientRect().width) || 1024) + 2))]
    }
}))], RendererUiPlugin.prototype, "width", void 0),
RendererUiPlugin_decorate([serialize(), uiSlider("Height", void 0, 1, d => ({
    onChange: () => d._sizeChanged(),
    hidden: () => d.mode === "full",
    bounds: () => {
        var o;
        return [10, Math.pow(2, Math.ceil(Math.log2(((o = d._viewer) === null || o === void 0 ? void 0 : o.container.getBoundingClientRect().height) || 1024) + 2))]
    }
}))], RendererUiPlugin.prototype, "height", void 0),
RendererUiPlugin_decorate([serialize(), x$1(RendererUiPlugin.prototype._scaleChanged), uiSlider("Scale", [.25, RendererUiPlugin.MaxCanvasScale], .001, d => ({
    disabled: () => d.mode === "custom"
}))], RendererUiPlugin.prototype, "scale", void 0),
RendererUiPlugin = RendererUiPlugin_1 = RendererUiPlugin_decorate([uiFolder("Renderer")], RendererUiPlugin);
class CameraUiPlugin extends AViewerPlugin {
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("activeCameraChange", this._refresh),
        o.scene.addEventListener("sceneUpdate", this._refresh)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("activeCameraChange", this._refresh),
        o.scene.removeEventListener("sceneUpdate", this._refresh),
        super.onRemove(o)
    }
    constructor() {
        super(),
        this.enabled = !0,
        this.serializeWithViewer = !1,
        this._refresh = this._refresh.bind(this)
    }
    toJSON(o) {
        var c;
        const h = super.toJSON(o);
        return h.activeCamera = (c = this._viewer) === null || c === void 0 ? void 0 : c.scene.activeCamera.toJSON(),
        h
    }
    fromJSON(o, c) {
        var h;
        return o.activeCamera && ((h = this._viewer) === null || h === void 0 || h.scene.activeCamera.fromJSON(o.activeCamera),
        delete (o = {
            ...o
        }).activeCamera),
        super.fromJSON(o, c)
    }
    _refresh() {
        var o, c;
        this._viewer && ((c = (o = this.uiConfig).uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0))
    }
    get uiConfig() {
        var o;
        return ((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.activeCamera.uiConfig) || {}
    }
}
CameraUiPlugin.PluginType = "CameraUiPlugin";
let Button = {
    create: d => {
        let o = "button" + (d.type ? " " + d.type : "")
          , c = utility.createDiv(o, d.text);
        return c.addEventListener("click", d.onClick),
        c
    }
};
var js_button = Button;
let Utility = {
    createElement: (d, o, c, h) => {
        let _ = document.createElement(d);
        if (o && (_.className = o),
        c && (_.innerHTML = c),
        h)
            for (let b in h)
                _.setAttribute(b, h[b]);
        return _
    }
    ,
    createDiv: (d, o, c) => Utility.createElement("div", d, o, c),
    createDomTree: d => {
        if (!d || !d.hasOwnProperty("dom"))
            return d;
        let o = d.dom;
        if (d.children)
            for (let c in d.children)
                d.children[c] && o.appendChild(Utility.createDomTree(d.children[c]));
        return o
    }
    ,
    removeElement: d => {
        d != null && d.parentNode.removeChild(d)
    }
    ,
    appendToBody: d => {
        document.body.appendChild(d)
    }
    ,
    makeIconHTML: d => {
        let o = "";
        return d == "ok" && (o = "#tick"),
        d == "error" && (o = "#cancel"),
        d == "info" && (o = "#info-button"),
        d == "caution" && (o = "#danger"),
        d == "min" && (o = "#line"),
        d == "close" && (o = "#close"),
        `<svg class="icon ${d}"><use xlink:href="${o}" /></svg>`
    }
    ,
    makeNftContent: d => {
        let o = null;
        if (d.type) {
            let c = null;
            c = typeof d.content == "string" ? Utility.createDiv("inner-content", d.content) : Utility.createDomTree({
                dom: Utility.createDiv("inner-content"),
                children: [d.content]
            }),
            o = d.type == "text" ? Utility.createDomTree({
                dom: Utility.createDiv("content text"),
                children: [c]
            }) : Utility.createDomTree({
                dom: Utility.createDiv("content"),
                children: [Utility.createDiv("state", Utility.makeIconHTML(d.type)), c]
            })
        } else
            typeof d.content == "string" && (o = Utility.createDiv("content", d.content));
        return o
    }
    ,
    standardizeButtons: (d, o) => {
        let c = [];
        if (o.buttons === void 0)
            return o.type != "caution" && o.type != "info" || c.push({
                key: 27,
                text: "Cancel",
                onClick: d.close.bind(d, "cancel")
            }),
            c.push({
                key: 13,
                text: "OK",
                type: "main",
                onClick: d.close.bind(d, "ok")
            }),
            c;
        c = o.buttons,
        c.constructor !== Array && (c = [c]);
        for (let h in c)
            !c[h].onClick && (c[h].onClick = d.close.bind(d, c[h].id));
        return c
    }
    ,
    makeButtons: d => {
        let o = [];
        if (d)
            for (let c in d)
                o.push(js_button.create({
                    text: d[c].text ? d[c].text : "OK",
                    type: d[c].normal ? null : "main",
                    onClick: d[c].onClick
                }));
        return Utility.createDomTree({
            dom: Utility.createDiv("button-wrapper"),
            children: o
        })
    }
    ,
    bindButtonKeyEvents: d => {
        let o = c => {
            for (let h in d)
                if (d[h].key === c.keyCode)
                    return void d[h].onClick()
        }
        ;
        return window.addEventListener("keydown", o),
        o
    }
    ,
    unbindButtonKeyEvents: d => {
        window.removeEventListener("keydown", d)
    }
};
var utility = Utility
  , animator = __webpackgi_require__(333);
let frames_frames = {
    "wwise-overlay-in-1": {
        opacity: "0"
    },
    "wwise-overlay-in-2": {
        opacity: "1"
    },
    "wwise-overlay-out-1": {
        opacity: "0"
    },
    "wwise-pop-in-1": {
        transform: "scale(0.5, 0.5)",
        "margin-top": "50px",
        opacity: ".5"
    },
    "wwise-pop-in-2": {
        transform: "scale(1, 1)",
        "margin-top": "0",
        opacity: "1"
    },
    "wwise-pop-in-3": {
        transform: "scale(1.05, 1.05)"
    },
    "wwise-pop-in-4": {
        transform: "scale(1, 1)"
    },
    "wwise-pop-out-1": {
        transform: "scale(0.25, 0.25)",
        "margin-top": "50px",
        opacity: "0"
    },
    "wwise-flip-in-1": {
        transform: "rotateX(60deg) scaleX(.5)",
        opacity: ".2"
    },
    "wwise-flip-in-2": {
        transform: "none",
        opacity: "1"
    },
    "wwise-flip-out-1": {
        transform: "rotateX(60deg) scaleX(.5)",
        opacity: "0"
    },
    "wwise-top-in-1": {
        transform: "translateY(-30vh)",
        opacity: ".5"
    },
    "wwise-top-in-2": {
        transform: "none",
        opacity: "1"
    },
    "wwise-top-out-1": {
        transform: "translateY(-30vh)",
        opacity: "0"
    },
    "wwise-bottom-in-1": {
        transform: "translateY(30vh)",
        opacity: ".5"
    },
    "wwise-bottom-in-2": {
        transform: "none",
        opacity: "1"
    },
    "wwise-bottom-out-1": {
        transform: "translateY(30vh)",
        opacity: "0"
    },
    "wwise-left-in-1": {
        transform: "translateX(-30vw)",
        opacity: ".5"
    },
    "wwise-left-in-2": {
        transform: "none",
        opacity: "1"
    },
    "wwise-left-out-1": {
        transform: "translateX(-30vw)",
        opacity: "0"
    },
    "wwise-right-in-1": {
        transform: "translateX(30vw)",
        opacity: ".5"
    },
    "wwise-right-in-2": {
        transform: "none",
        opacity: "1"
    },
    "wwise-right-out-1": {
        transform: "translateX(30vw)",
        opacity: "0"
    },
    "wwise-min-in-1": {
        "margin-top": "0",
        transform: "rotateX(-60deg) scale(0.2, 1.8) translateY(80vh)",
        opacity: ".2"
    },
    "wwise-min-in-2": {
        transform: "none",
        opacity: "1"
    },
    "wwise-min-out-1": {
        "margin-top": "30vh",
        transform: "rotateX(-60deg) scale(0.05, 2) translateY(30vh)",
        opacity: "0"
    }
};
var js_frames = frames_frames;
let animation_Animation = {};
animation_Animation.overlay_in = [new animator.Frame(js_frames["wwise-overlay-in-1"],0), new animator.Frame(js_frames["wwise-overlay-in-2"],400)],
animation_Animation.overlay_out = [new animator.Frame(js_frames["wwise-overlay-out-1"],300)],
animation_Animation.pop_in = [new animator.Frame(js_frames["wwise-pop-in-1"],0), new animator.Frame(js_frames["wwise-pop-in-2"],{
    duration: 200,
    "timing-function": "ease-in"
}), new animator.Frame(js_frames["wwise-pop-in-3"],{
    duration: 100,
    "timing-function": "linear"
}), new animator.Frame(js_frames["wwise-pop-in-4"],{
    duration: 100,
    "timing-function": "linear"
})],
animation_Animation.pop_out = [new animator.Frame(js_frames["wwise-pop-out-1"],{
    duration: 250,
    "timing-function": "ease-in"
})],
animation_Animation.flip_in = [new animator.Frame(js_frames["wwise-flip-in-1"],0), new animator.Frame(js_frames["wwise-flip-in-2"],500)],
animation_Animation.flip_out = [new animator.Frame(js_frames["wwise-flip-out-1"],400)],
animation_Animation.min_in = [new animator.Frame(js_frames["wwise-min-in-1"],0), new animator.Frame(js_frames["wwise-min-in-2"],350)],
animation_Animation.min_out = [new animator.Frame(js_frames["wwise-min-out-1"],400)];
let dirs = ["top", "bottom", "left", "right"];
for (let d in dirs) {
    let o = dirs[d];
    animation_Animation[o + "_in"] = [new animator.Frame(js_frames["wwise-" + o + "-in-1"],0), new animator.Frame(js_frames["wwise-" + o + "-in-2"],{
        duration: 400,
        "timing-function": "ease-out"
    })],
    animation_Animation[o + "_out"] = [new animator.Frame(js_frames["wwise-" + o + "-out-1"],{
        duration: 400,
        "timing-function": "ease-in"
    })]
}
var js_animation = animation_Animation;
let defaultOptions = {
    animation: "pop",
    topbar: {
        showClose: !0,
        showMin: !1
    },
    keepOverlay: !1,
    position: "center",
    overlay: !1,
    clickOverlayToClose: !0,
    removeBackground: !1,
    noRadius: !1,
    zIndex: null
};
class Window {
    static create(o, c) {
        let h = o.getElementsByClassName("title")[0];
        h && (h = h.innerHTML);
        let _ = o.getElementsByClassName("content")[0];
        return _ && (_ = _.innerHTML),
        utility.removeElement(o),
        c.title = h,
        c.content = _,
        new Window(c)
    }
    constructor(o) {
        this.options = JSON.parse(JSON.stringify(defaultOptions));
        for (let it in o)
            o[it] != null && (this.options[it] = o[it]);
        let c = this.options.position;
        if (c.indexOf(" ") == -1 && (c == "left" || c == "right" ? c += " center" : c = c == "top" || c == "bottom" ? "center " + c : c + " " + c),
        this.options.position = c,
        this.options.overlay) {
            let it = document.getElementsByClassName("wwise-overlay");
            it.length ? (this.overlay = it[0],
            this.hasOverlay = !0) : (this.overlay = utility.createDiv("wwise-overlay"),
            this.options.zIndex && (this.overlay.style.zIndex = this.options.zIndex)),
            this.overlayClickHandler = this.close.bind(this, void 0)
        } else
            this.options.clickOverlayToClose = !1;
        let h = "content";
        if (this.options.topbar) {
            let it = [];
            this.options.topbar.showMin && (it.push(utility.createDiv(null, utility.makeIconHTML("min"))),
            it[it.length - 1].addEventListener("click", this.min.bind(this))),
            this.options.topbar.showClose && (it.push(utility.createDiv(null, utility.makeIconHTML("close"))),
            it[it.length - 1].addEventListener("click", this.close.bind(this, void 0)));
            let at = null;
            at = typeof this.options.title == "string" ? utility.createDiv("title", this.options.title) : utility.createDomTree({
                dom: utility.createDiv("title"),
                children: [this.options.title]
            }),
            this.topbar = utility.createDomTree({
                dom: utility.createDiv("topbar"),
                children: [{
                    dom: utility.createDiv("control"),
                    children: it.map(ut => ({
                        dom: ut
                    }))
                }, {
                    dom: at
                }, {
                    dom: utility.createDiv("clear")
                }]
            })
        } else
            h += " no-topbar";
        typeof this.options.content == "string" ? this.content = utility.createDomTree({
            dom: utility.createDiv(h, this.options.content)
        }) : this.content = utility.createDomTree({
            dom: utility.createDiv(h),
            children: [this.options.content]
        }),
        this.options.removeBackground && (this.content.style.background = "initial"),
        this.window = utility.createDomTree({
            dom: utility.createDiv("wwise" + (this.options.noRadius ? " no-radius" : "")),
            children: [this.topbar, this.content]
        });
        let _ = utility.createDiv("wwise-wrapper");
        this.options.zIndex && (_.style.zIndex = this.options.zIndex),
        this.wrapper = utility.createDomTree({
            dom: _,
            children: [this.window]
        }),
        this.dom = utility.createDomTree({
            dom: utility.createDiv(),
            children: [this.wrapper]
        });
        let b = this.options.position.split(" ")
          , _e = -50
          , nt = -50;
        if (b[0] == "left" ? (_e = 0,
        this.wrapper.classList.add("left")) : b[0] == "right" ? (_e = -100,
        this.wrapper.classList.add("right")) : b[0] == "center" ? this.wrapper.classList.add("h-center") : this.wrapper.style.left = b[0],
        b[1] == "top" ? (nt = 0,
        this.wrapper.classList.add("top")) : b[1] == "bottom" ? (nt = -100,
        this.wrapper.classList.add("bottom")) : b[1] == "center" ? this.wrapper.classList.add("v-center") : this.wrapper.style.top = c[1],
        this.window.style.transform = `translate(${_e}%, ${nt}%)`,
        this.options.style)
            for (let it in this.options.style)
                this.window.style[it] = this.options.style[it];
        this.options.margin && (this.wrapper.style.margin = this.options.margin),
        this.options.draggable && this.draggable()
    }
    open(o) {
        if (this.opened)
            return;
        this.promise = new Promise(h => {
            this.promiseResolve = h
        }
        ),
        this.appendDoms(),
        this.opened = !0,
        this.options.clickOverlayToClose && (this.overlay.addEventListener("click", this.overlayClickHandler),
        this.overlay.addEventListener("touchstart", this.overlayClickHandler));
        let c = o ? "min" : this.options.animation;
        if (c) {
            c != "min" && c != "flip" || this.dom.classList.add("wwise-perspective");
            let h = [new animator.Queue(this.wrapper,js_animation[c + "_in"],{
                instant: !0,
                applyOnEnd: !0
            }).getPromise()];
            return this.options.overlay && !this.hasOverlay && h.push(new animator.Queue(this.overlay,js_animation.overlay_in,{
                instant: !0,
                applyOnEnd: !0
            }).getPromise()),
            Promise.all(h).then( () => {
                this.dom.classList.remove("wwise-perspective")
            }
            )
        }
        return Promise.resolve()
    }
    close(o) {
        if (!this.opened)
            return;
        this.opened = !1;
        let c = o ? "min" : this.options.animation;
        if (this.overlay && (this.overlay.removeEventListener("click", this.overlayClickHandler),
        this.overlay.removeEventListener("touchstart", this.overlayClickHandler)),
        c) {
            c != "min" && c != "flip" || this.dom.classList.add("wwise-perspective");
            let h = [new animator.Queue(this.wrapper,js_animation[c + "_out"],{
                instant: !0,
                applyOnEnd: !0
            }).getPromise()];
            return this.options.overlay && !this.options.keepOverlay && h.push(new animator.Queue(this.overlay,js_animation.overlay_out,{
                instant: !0,
                applyOnEnd: !0
            }).getPromise()),
            Promise.all(h).then( () => {
                this.removeDoms(),
                this.dom.classList.remove("wwise-perspective"),
                this.promiseResolve()
            }
            )
        }
        return this.removeDoms(),
        this.promiseResolve(),
        Promise.resolve()
    }
    min() {
        return this.close(!0)
    }
    resume() {
        return this.open(!0)
    }
    getPromise() {
        return this.promise
    }
    appendDoms() {
        this.options.overlay && !this.hasOverlay && (utility.appendToBody(this.overlay),
        document.body.classList.add("wwise-no-scroll"),
        this.overlay.addEventListener("touchstart", o => {
            o.preventDefault()
        }
        )),
        utility.appendToBody(this.dom)
    }
    removeDoms() {
        utility.removeElement(this.dom),
        !this.options.keepOverlay && this.overlay && (utility.removeElement(this.overlay),
        document.body.classList.remove("wwise-no-scroll"))
    }
    draggable(o=!0) {
        this.topbar && (o ? (this.draggableMouseMoveHandler = this.handleDraggableMouseMove.bind(this),
        this.draggableMouseDownHandler = this.handleDraggableMouseDown.bind(this),
        this.draggableMouseUpHandler = this.handleDraggableMouseUp.bind(this),
        this.draggableMouseOutHandler = this.handleDraggableMouseOut.bind(this),
        window.addEventListener("mousemove", this.draggableMouseMoveHandler),
        window.addEventListener("mouseout", this.draggableMouseOutHandler),
        this.topbar.addEventListener("mousedown", this.draggableMouseDownHandler),
        window.addEventListener("mouseup", this.draggableMouseUpHandler)) : (window.removeEventListener("mousemove", this.draggableMouseMoveHandler),
        window.removeEventListener("mouseout", this.draggableMouseOutHandler),
        this.topbar.removeEventListener("mousedown", this.draggableMouseDownHandler),
        window.removeEventListener("mouseup", this.draggableMouseUpHandler)))
    }
    handleDraggableMouseMove(o) {
        if (this.inDragging) {
            let c = {
                x: o.clientX - this.dragPrev.x,
                y: o.clientY - this.dragPrev.y
            }
              , h = window.getComputedStyle(this.wrapper)
              , _ = this.options.draggable
              , b = parseFloat(h.left)
              , _e = parseFloat(h.top);
            if (h.left.indexOf("%") != -1) {
                b = h.left,
                b = b.substr(0, b.length - 1),
                b = parseInt(b);
                let nt = window
                  , it = document
                  , at = it.documentElement
                  , ut = it.getElementsByTagName("body")[0];
                b = b * (nt.innerWidth || at.clientWidth || ut.clientWidth) / 100
            }
            if (h.top.indexOf("%") != -1) {
                _e = h.top,
                _e = _e.substr(0, _e.length - 1),
                _e = parseInt(_e);
                let nt = window
                  , it = document
                  , at = it.documentElement
                  , ut = it.getElementsByTagName("body")[0];
                _e = _e * (nt.innerHeight || at.clientHeight || ut.clientHeight) / 100
            }
            _ != 1 && _ != "horizontal" || (this.wrapper.style.left = b + c.x + "px"),
            _ != 1 && _ != "vertical" || (this.wrapper.style.top = _e + c.y + "px"),
            this.dragPrev = {
                x: o.clientX,
                y: o.clientY
            }
        }
    }
    handleDraggableMouseDown(o) {
        this.inDragging = !0,
        this.dragPrev = {
            x: o.clientX,
            y: o.clientY
        }
    }
    handleDraggableMouseUp(o) {
        this.inDragging = !1
    }
    handleDraggableMouseOut(o) {
        let c = o.relatedTarget;
        c && c.nodeName != "HTML" || (this.inDragging = !1)
    }
}
var js_window = Window;
class Modal {
    constructor(o) {
        let c = this.options = o;
        !c.type && (c.type = "ok");
        let h = {
            topbar: !1
        };
        h.content = this.constructContent({
            type: c.type,
            title: c.title,
            text: c.text,
            content: c.content,
            buttons: c.buttons
        }),
        h.overlay = !0,
        h.keepOverlay = c.keepOverlay,
        h.clickOverlayToClose = !1,
        h.animation = c.animation,
        h.zIndex = c.zIndex,
        this.wwise = new js_window(h)
    }
    constructContent(o) {
        let c = utility.createDiv("modal")
          , h = utility.createDomTree({
            dom: utility.createDiv("main " + o.type),
            children: [utility.createDiv(null, utility.makeIconHTML(o.type)), utility.createDiv("title", o.title), utility.createDiv("text", o.text)]
        });
        this.buttonArr = utility.standardizeButtons(this, o);
        let _ = utility.makeButtons(this.buttonArr)
          , b = null;
        o.content && (b = typeof o.content == "string" ? utility.createDiv(null, o.content) : o.content);
        let _e = null;
        return _.innerHTML && (_e = utility.createDomTree({
            dom: utility.createDiv("operation " + o.type),
            children: [_]
        })),
        b || _e || h.classList.add("no-op"),
        utility.createDomTree({
            dom: c,
            children: [h, b, _e]
        })
    }
    open() {
        if (this.wwise.opened)
            return;
        let o = this.wwise.open();
        return this.value = void 0,
        this.promise = new Promise(c => {
            this.promiseResolve = c
        }
        ),
        this.wwise.getPromise().then(this.handlePromiseResolve.bind(this)),
        this.keyHandler = utility.bindButtonKeyEvents(this.buttonArr),
        this.options.closeAfter && window.setTimeout( () => {
            this.close("timer")
        }
        , this.options.closeAfter),
        o
    }
    close(o) {
        if (this.wwise.opened)
            return this.value = o,
            utility.unbindButtonKeyEvents(this.keyHandler),
            this.wwise.close()
    }
    getPromise() {
        return this.promise
    }
    handlePromiseResolve() {
        this.promiseResolve(this.value)
    }
}
var js_modal = Modal;
let input_defaultOptions = {
    showCancel: !1,
    okText: "OK",
    cancelText: "Cancel",
    placeholder: "",
    validator: null
}
  , defaultWwiseOptions = {
    type: "info",
    keepOverlay: !1,
    title: "Input",
    text: "",
    zIndex: null
};
class Input {
    constructor(o) {
        this.options = JSON.parse(JSON.stringify(input_defaultOptions));
        for (let b in o)
            o[b] != null && (this.options[b] = o[b]);
        let c = this.options
          , h = JSON.parse(JSON.stringify(defaultWwiseOptions));
        for (let b in h)
            c.hasOwnProperty(b) && (h[b] = c[b]);
        let _ = [];
        c.showCancel && _.push({
            key: 27,
            text: c.cancelText,
            normal: !0,
            onClick: this.handleCancel.bind(this)
        }),
        _.push({
            key: 13,
            text: c.okText,
            onClick: this.handleOk.bind(this)
        }),
        h.buttons = _,
        this.input = utility.createElement("input", "input", null, {
            placeholder: c.placeholder
        }),
        this.error = utility.createDiv("error"),
        h.content = utility.createDomTree({
            dom: utility.createDiv("input-wrapper"),
            children: [this.input, this.error]
        }),
        this.modal = new js_modal(h)
    }
    handleCancel() {
        this.close().then(this.promiseReject.bind(this))
    }
    handleOk() {
        this.options.validator ? this.options.validator(this.input.value).then( () => {
            this.close().then(this.promiseResolve.bind(this, this.input.value))
        }
        , o => {
            this.error.innerText = o
        }
        ) : this.close().then(this.promiseResolve.bind(this, this.input.value))
    }
    open() {
        if (this.modal.wwise.opened)
            return;
        let o = this.modal.open();
        return this.input.value = "",
        this.error.innerText = "",
        this.input.focus(),
        this.promise = new Promise( (c, h) => {
            this.promiseResolve = c,
            this.promiseReject = h
        }
        ),
        o
    }
    close() {
        if (this.modal.wwise.opened)
            return this.modal.close()
    }
    getPromise() {
        return this.promise
    }
}
var input = Input
  , windowise = __webpackgi_require__(160)
  , windowise_exported = {};
windowise.A && windowise.A.locals && (windowise_exported.locals = windowise.A.locals);
var windowise_refs = 0, windowise_update, windowise_options = {};
windowise_options.styleTagTransform = styleTagTransform_default(),
windowise_options.setAttributes = setAttributesWithoutAttributes_default(),
windowise_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
windowise_options.domAPI = styleDomAPI_default(),
windowise_options.insertStyleElement = insertStyleElement_default(),
windowise_exported.use = function(d) {
    return windowise_options.options = d || {},
    windowise_refs++ || (windowise_update = injectStylesIntoStyleTag_default()(windowise.A, windowise_options)),
    windowise_exported
}
,
windowise_exported.unuse = function() {
    windowise_refs > 0 && !--windowise_refs && (windowise_update(),
    windowise_update = null)
}
;
var ui_windowise = windowise_exported;
class WindowiseDialogPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this._previousMappings = {}
    }
    async onAdded(o) {
        await super.onAdded(o),
        this._previousMappings = {
            alert: o.alert,
            confirm: o.confirm,
            prompt: o.prompt
        },
        utility.appendToBody = c => {
            c.style.zIndex = "350",
            o.container.appendChild(c)
        }
        ,
        utility.makeIconHTML = c => "",
        ui_windowise.use({
            target: o.container
        }),
        o.alert = async c => {
            const h = c == null ? void 0 : c.split(":")[0]
              , _ = new js_modal({
                type: "info",
                title: h ?? "&ndsp;",
                text: (c == null ? void 0 : c.replace(h + ":", "").replace(/(\r?\n)/gm, "<br>")) || "",
                buttons: [{
                    key: 13,
                    text: "OK",
                    type: "main",
                    id: "ok"
                }],
                animation: "overlay"
            });
            return _.open(),
            _.getPromise()
        }
        ,
        o.confirm = async c => {
            const h = c == null ? void 0 : c.split(":")[0]
              , _ = new js_modal({
                type: "info",
                title: h ?? "&ndsp;",
                text: (c == null ? void 0 : c.replace(h || "", "").replace(":", "")) || "",
                buttons: [{
                    id: "no",
                    key: 27,
                    text: "No",
                    normal: !0
                }, {
                    id: "yes",
                    key: 13,
                    text: "Yes"
                }],
                animation: "overlay"
            });
            return _.open(),
            await _.getPromise() === "yes"
        }
        ,
        o.prompt = async (c, h, _=!0) => {
            const b = c == null ? void 0 : c.split(":")[0]
              , _e = new input({
                type: "info",
                title: b ?? "&ndsp;",
                placeholder: h ?? "",
                showCancel: _,
                animation: "overlay",
                text: (c == null ? void 0 : c.replace(b || "", "").replace(":", "")) || ""
            });
            return _e.open(),
            await _e.getPromise().catch(async () => null)
        }
    }
    async onRemove(o) {
        return o.alert = this._previousMappings.alert,
        o.confirm = this._previousMappings.confirm,
        o.prompt = this._previousMappings.prompt,
        super.onRemove(o)
    }
}
WindowiseDialogPlugin.PluginType = "WindowiseDialogPlugin";
var editorModes = __webpackgi_require__(757)
  , editorModes_exported = {};
editorModes.A && editorModes.A.locals && (editorModes_exported.locals = editorModes.A.locals);
var editorModes_refs = 0, editorModes_update, editorModes_options = {};
editorModes_options.styleTagTransform = styleTagTransform_default(),
editorModes_options.setAttributes = setAttributesWithoutAttributes_default(),
editorModes_options.insert = function(d, o) {
    (o.target || document.head).appendChild(d)
}
,
editorModes_options.domAPI = styleDomAPI_default(),
editorModes_options.insertStyleElement = insertStyleElement_default(),
editorModes_exported.use = function(d) {
    return editorModes_options.options = d || {},
    editorModes_refs++ || (editorModes_update = injectStylesIntoStyleTag_default()(editorModes.A, editorModes_options)),
    editorModes_exported
}
,
editorModes_exported.unuse = function() {
    editorModes_refs > 0 && !--editorModes_refs && (editorModes_update(),
    editorModes_update = null)
}
;
var ui_editorModes = editorModes_exported;
function setupModesStyles() {
    ui_editorModes.use(),
    tippy_js_dist_tippy.use()
}
async function setupModesUi(d, o=void 0, c=[]) {
    var h, _;
    tippy_esm.setDefaultProps({
        theme: "editor",
        duration: 300,
        arrow: !0,
        appendTo: () => d.container
    });
    const b = ee$1({
        classList: ["mode-buttons-container", "button-bar"],
        addToBody: !0
    })
      , _e = ee$1({
        innerHTML: "",
        id: "webgi-logo",
        addToBody: !1
    });
    rt("logo-img") && (_e.style.backgroundImage = `url(${rt("logo-img")})`),
    _e.onclick = () => {
        window.open(rt("logo-link") || "https://webgi.xyz", "_blank")
    }
    ;
    const nt = `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
</svg>`;
    d.container.appendChild(_e),
    tippy_esm(_e, {
        placement: "right",
        content: "Powered by WebGi SDK"
    });
    const it = ee$1({
        innerHTML: nt,
        id: "fsToggle",
        classList: ["round-button"],
        addToBody: !1
    });
    it.dataset.tippyContent = "Full-Screen",
    (h = d.getPlugin(FullScreenPlugin)) === null || h === void 0 || h.addEventListener("enter", () => {
        it.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path d="M9 19L9 15M9 15L5 15M9 15L4 20M15 15L20 20M15 15V19M15 15H19M15 5V9M15 9L19 9M15 9L20 4M9 5L9 9M9 9L5 9M9 9L4 4" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`,
        it.dataset.tippyContent = "Exit Full-Screen"
    }
    ),
    (_ = d.getPlugin(FullScreenPlugin)) === null || _ === void 0 || _.addEventListener("exit", () => {
        it.innerHTML = nt,
        it.dataset.tippyContent = "Full-Screen"
    }
    ),
    it.onclick = () => {
        var At;
        (At = d.getPlugin(FullScreenPlugin)) === null || At === void 0 || At.toggle(d.container)
    }
    ,
    d.container.appendChild(it),
    tippy_esm(it, {
        placement: "left"
    });
    const at = ee$1({
        classList: ["button-bar", "util-buttons-container"],
        addToBody: !1
    });
    d.container.appendChild(at);
    const ut = [{
        id: "reset-settings",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="currentColor" viewBox="0 0 24 24">
 <path fill="currentColor" d="M19 8L15 12H18C18 15.31 15.31 18 12 18C11 18 10.03 17.75 9.2 17.3L7.74 18.76C8.97 19.54 10.43 20 12 20C16.42 20 20 16.42 20 12H23M6 12C6 8.69 8.69 6 12 6C13 6 13.97 6.25 14.8 6.7L16.26 5.24C15.03 4.46 13.57 4 12 4C7.58 4 4 7.58 4 12H1L5 16L9 12M14 12C14 13.11 13.11 14 12 14S10 13.11 10 12 10.9 10 12 10 14 10.9 14 12Z" />
</svg>`,
        tooltip: "Reset All Settings",
        onclick: async () => {
            var At;
            if (!await d.confirm("Reset settings: Are you sure you want to reset all plugin settings?"))
                return;
            const Et = bt.map(Pt => d.getPlugin(Pt));
            for (const Pt of Et)
                await ((At = Pt == null ? void 0 : Pt.resetDefaults) === null || At === void 0 ? void 0 : At.call(Pt))
        }
    }, {
        id: "clear-scene",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
 <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
</svg>`,
        tooltip: "Clear Scene",
        onclick: async () => {
            await d.confirm("Clear scene: Are you sure you want to clear the scene?") && d.scene.disposeSceneModels()
        }
    }, {
        id: "fit-scene",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
    <path fill="currentColor" d="M17 12C17 7.55 11.62 5.31 8.46 8.46C5.31 11.61 7.55 17 12 17C14.76 17 17 14.76 17 12M12 15C9.33 15 8 11.77 9.88 9.88C11.77 8 15 9.33 15 12C15 13.66 13.66 15 12 15M5 15H3V19C3 20.1 3.9 21 5 21H9V19H5M5 5H9V3H5C3.9 3 3 3.9 3 5V9H5M19 3H15V5H19V9H21V5C21 3.9 20.1 3 19 3M19 19H15V21H19C20.1 21 21 20.1 21 19V15H19" />
</svg>`,
        tooltip: "Fit Object/Scene",
        onclick: async () => {
            var At;
            await d.fitToView((At = d.getPlugin(PickingPlugin)) === null || At === void 0 ? void 0 : At.getSelectedObject())
        }
    }, {
        id: "loop-cam-views",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="currentColor" viewBox="0 0 24 24">
 <path fill="currentColor" d="M19 8L15 12H18C18 15.31 15.31 18 12 18C11 18 10.03 17.75 9.2 17.3L7.74 18.76C8.97 19.54 10.43 20 12 20C16.42 20 20 16.42 20 12H23M6 12C6 8.69 8.69 6 12 6C13 6 13.97 6.25 14.8 6.7L16.26 5.24C15.03 4.46 13.57 4 12 4C7.58 4 4 7.58 4 12H1L5 16L9 12M14 12C14 13.11 13.11 14 12 14S10 13.11 10 12 10.9 10 12 10 14 10.9 14 12Z" />
</svg>`,
        tooltip: "Loop Camera Views",
        toggle: !0,
        onclick: async () => {
            d.getPlugin(CameraViewPlugin) && (d.getPlugin(CameraViewPlugin).viewLooping = !d.getPlugin(CameraViewPlugin).viewLooping)
        }
    }, {
        id: "play-gltf",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
  <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>`,
        tooltip: "GLTF Animations",
        toggle: !0,
        onclick: async () => {
            var At;
            (At = d.getPlugin(GLTFAnimationPlugin)) === null || At === void 0 || At.playPauseAnimation()
        }
    }, {
        id: "auto-rotate-cc",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="currentColor" viewBox="0 0 24 24">
 <path fill="currentColor" d="M10,12L14,16L10,20V16.9C5.44,16.44 2,14.42 2,12C2,9.58 5.44,7.56 10,7.1V9.09C6.55,9.43 4,10.6 4,12C4,13.4 6.55,14.57 10,14.91V12M20,12C20,10.6 17.45,9.43 14,9.09V7.1C18.56,7.56 22,9.58 22,12C22,14.16 19.26,16 15.42,16.7L16.12,16L14.92,14.79C17.89,14.36 20,13.27 20,12M11,2H13V13L11,11V2M11,22V21L13,19V22H11Z" />
</svg>`,
        tooltip: "Auto rotate",
        toggle: !0,
        onclick: async () => {
            const At = d.scene.activeCamera.controls;
            At && At.autoRotate !== void 0 && (At.autoRotate = !At.autoRotate)
        }
    }, {
        id: "snapshot",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
</svg>`,
        tooltip: "Capture Snapshot",
        onclick: async () => {
            const At = d.getPlugin(CanvasSnipperPlugin);
            At ? await At.downloadSnapshot() : d.console.error("CanvasSnipperPlugin not added")
        }
    }, {
        id: "glb-export",
        icon: `<svg xmlns="http://www.w3.org/2000/svg" style="width:100%; height:100%;" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
</svg>`,
        tooltip: "Export GLB",
        onclick: async () => {
            const At = d.getPlugin(AssetExporterPlugin);
            At ? await (At == null ? void 0 : At.downloadSceneGlb()) : d.console.error("AssetExporterPlugin not added")
        }
    }];
    for (const At of ut) {
        const Et = ee$1({
            innerHTML: At.icon,
            id: At.id,
            classList: ["button-bar-button", "util-button"],
            addToBody: !1
        });
        Et.dataset.tippyContent = At.tooltip,
        Et.onclick = () => {
            At.toggle && Et.classList.toggle("button-bar-selected-box"),
            At.onclick()
        }
        ,
        at.appendChild(Et)
    }
    createSingleton(tippy_esm(".util-button"), {
        moveTransition: "transform 0.2s ease-out",
        placement: "top"
    });
    const pt = d.getPlugin(PickingPlugin)
      , ht = d.getPlugin(InteractionPromptPlugin);
    for (const [At,Et] of Object.entries(o ?? {})) {
        const Pt = c.find(It => It.title === At);
        Pt ? Pt.plugins.push(...Et) : c.push({
            title: At,
            plugins: [...Et]
        })
    }
    let _t = c[2]
      , vt = [];
    const bt = c.reduce( (At, Et) => At.concat(Et.plugins), []);
    function St(At, Et=!0) {
        var Pt;
        _t = At,
        pt && (pt.enabled = !0),
        ht && (["Plugins"].includes(_t.title) ? ht.enable("modesUi") : ht.disable("modesUi")),
        vt = [];
        for (const It of bt) {
            const Dt = d.getPlugin(It);
            if (!(Dt != null && Dt.uiConfig))
                continue;
            const Gt = At.plugins.includes(It);
            S$2(Dt.uiConfig, "hidden", !Gt, !0),
            Gt && vt.push(Dt)
        }
        for (const It of c)
            (Pt = It.div) === null || Pt === void 0 || Pt.classList[_t !== It ? "remove" : "add"]("mode-button-selected", "button-bar-selected");
        d.getPlugin(TweakpaneUiPlugin).refreshPluginsEnabled(),
        Et && window.dispatchEvent(new CustomEvent("webgi_editorModeChanged",{
            detail: {
                mode: At
            }
        }))
    }
    for (const At of c) {
        const Et = ee$1({
            innerHTML: At.title,
            classList: ["mode-button", "button-bar-button"]
        });
        Et.onclick = () => {
            St(At)
        }
        ,
        At.div = Et,
        b.appendChild(Et)
    }
    St(c[0]),
    window.webgi_setEditorMode = St,
    window.webgi_editorModes = c,
    pt == null || pt.addEventListener("selectedObjectChanged", () => {
        pt != null && pt.getSelectedObject() && !["Picking", "Modifiers", "Configurators"].includes(_t.title) && St(c.find(At => At.plugins.includes(PickingPlugin)))
    }
    )
}
class ExtrasUiPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.toJSON = void 0,
        this.showColorScheme = !0,
        this.uiConfig = {
            type: "folder",
            label: "Extras",
            limitedUi: !1,
            children: [ () => this.showColorScheme ? {
                label: "Color Scheme",
                type: "dropdown",
                children: ["black", "white", "blue"].map(o => ({
                    label: o
                })),
                getValue: () => {
                    var o, c;
                    return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPluginByType("TweakpaneUi")) === null || c === void 0 ? void 0 : c.colorMode
                }
                ,
                setValue: o => {
                    var c;
                    const h = (c = this._viewer) === null || c === void 0 ? void 0 : c.getPluginByType("TweakpaneUi");
                    h && (h.colorMode = o)
                }
            } : void 0, () => ({
                label: "Shadow type",
                type: "dropdown",
                children: [["Basic", three_module.bTm], ["PCF", three_module.QP0], ["PCFSoft", three_module.Wk7], ["VSM", three_module.RyA]].map(o => ({
                    label: o[0],
                    value: o[1]
                })),
                getValue: () => {
                    var o;
                    return (o = this._viewer) === null || o === void 0 ? void 0 : o.renderer.rendererObject.shadowMap.type
                }
                ,
                setValue: o => {
                    var c;
                    (c = this._viewer) === null || c === void 0 || c.doOnce("postFrame", () => {
                        this._viewer && (this._viewer.renderer.rendererObject.shadowMap.type = o,
                        this._viewer.renderer.resetShadows(),
                        this._viewer.renderer.reset(),
                        this._viewer.scene.setDirty({
                            sceneUpdate: !0,
                            frameFade: !1
                        }),
                        this._viewer.setDirty())
                    }
                    )
                }
            }), () => {
                var o;
                return {
                    label: (!((o = this._viewer) === null || o === void 0) && o.useRgbm ? "Disable" : "Enable") + " RGBM",
                    type: "button",
                    value: async () => {
                        var c, h;
                        await ((c = this._viewer) === null || c === void 0 ? void 0 : c.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && st("rgbm", !((h = this._viewer) === null || h === void 0) && h.useRgbm ? "no" : "yes", !0)
                    }
                }
            }
            , () => {
                var o;
                return {
                    label: (!((o = this._viewer) === null || o === void 0) && o.isAntialiased ? "Disable" : "Enable") + " MSAA",
                    type: "button",
                    value: async () => {
                        var c, h;
                        await ((c = this._viewer) === null || c === void 0 ? void 0 : c.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && st("msaa", !((h = this._viewer) === null || h === void 0) && h.isAntialiased ? "no" : "yes", !0)
                    }
                }
            }
            , () => {
                var o;
                return {
                    label: (!((o = this._viewer) === null || o === void 0) && o.useGBufferDepth ? "Disable" : "Enable") + " Depth(z) Prepass",
                    type: "button",
                    value: async () => {
                        var c, h;
                        await ((c = this._viewer) === null || c === void 0 ? void 0 : c.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && st("depthPrepass", !((h = this._viewer) === null || h === void 0) && h.useGBufferDepth ? "no" : "yes", !0)
                    }
                }
            }
            , () => {
                var o;
                return {
                    label: (!((o = this._viewer) === null || o === void 0) && o.getPluginByType("debug") ? "Disable" : "Enable") + " Debug",
                    type: "button",
                    value: async () => {
                        var c, h;
                        await ((c = this._viewer) === null || c === void 0 ? void 0 : c.confirm("Edit Extras: This will reload the webpage. Are you sure?")) && st("debug", !((h = this._viewer) === null || h === void 0) && h.getPluginByType("debug") ? null : "true", !0)
                    }
                }
            }
            , {
                label: "Clear local storage",
                type: "button",
                value: async () => {
                    var o;
                    await ((o = this._viewer) === null || o === void 0 ? void 0 : o.confirm("Edit Extras: This will clear all local storage. Are you sure?")) && localStorage.clear()
                }
            }, {
                label: "Clear caches",
                type: "button",
                value: async () => {
                    var o, c;
                    const h = (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(AssetManagerPlugin)) === null || c === void 0 ? void 0 : c.storage;
                    if (h instanceof Storage)
                        h.clear();
                    else if (h instanceof Cache) {
                        const _ = await h.keys();
                        await Promise.all(_.map(async b => h.delete(b)))
                    }
                    localStorage.clear()
                }
            }, {
                label: "Auto GPU instance all",
                type: "button",
                value: () => {
                    var o;
                    const c = new Set;
                    (o = this._viewer) === null || o === void 0 || o.scene.modelRoot.traverse(h => h.geometry && c.add(h.geometry)),
                    c.forEach(h => autoGPUInstanceMeshes(h))
                }
            }, {
                label: "Auto Center All Geometries",
                type: "button",
                value: () => {
                    var o;
                    const c = new Set;
                    (o = this._viewer) === null || o === void 0 || o.scene.modelRoot.traverse(h => h.geometry && c.add(h.geometry)),
                    c.forEach(h => {
                        const _ = new three_module.Pq0;
                        h.center(_),
                        _.negate();
                        const b = h.userData.__appliedMeshes;
                        b || console.error("No meshes found for geometry", h),
                        b == null || b.forEach(_e => {
                            _e.updateMatrix(),
                            _e.position.copy(_).applyMatrix4(_e.matrix),
                            _e.setDirty && _e.setDirty()
                        }
                        )
                    }
                    )
                }
            }]
        }
    }
}
ExtrasUiPlugin.PluginType = "ExtrasUiPlugin1";
var AHelperWidget_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class AHelperWidget extends three_module.B69 {
    constructor(o) {
        super(),
        this.modelObject = this,
        this.assetType = "widget",
        this.visible = !0,
        this.uiConfig = generateUiFolder("Widget", this),
        this.object = o,
        this.object.updateMatrixWorld(),
        this.object.updateProjectionMatrix && this.object.updateProjectionMatrix(),
        this.matrix = o.matrixWorld,
        this.matrixAutoUpdate = !1,
        this._objectUpdate = this._objectUpdate.bind(this),
        this.attach(o),
        this.traverse(c => {
            c.userData.__keepShadowDef = !0,
            c.castShadow = !1,
            c.receiveShadow = !1
        }
        )
    }
    dispose() {
        this.detach()
    }
    _objectUpdate() {
        this.object && this.update()
    }
    attach(o) {
        var c, h;
        return this.object && this.detach(),
        this.object = o,
        this.object && (this.update(),
        this.object.addEventListener("objectUpdate", this._objectUpdate),
        this.object.addEventListener("dispose", this.dispose),
        this.uiConfig && ((h = (c = this.object.uiConfig) === null || c === void 0 ? void 0 : c.children) === null || h === void 0 || h.push(this.uiConfig)),
        this.visible = !0),
        this
    }
    detach() {
        var o, c, h, _;
        if (this.object) {
            if (this.object.removeEventListener("objectUpdate", this._objectUpdate),
            this.object.removeEventListener("dispose", this.dispose),
            this.uiConfig) {
                const b = (c = (o = this.object.uiConfig) === null || o === void 0 ? void 0 : o.children) === null || c === void 0 ? void 0 : c.indexOf(this.uiConfig);
                b !== void 0 && b >= 0 && ((_ = (h = this.object.uiConfig) === null || h === void 0 ? void 0 : h.children) === null || _ === void 0 || _.splice(b, 1))
            }
            this.object = void 0,
            this.visible = !1
        }
        return this
    }
}
AHelperWidget_decorate([uiToggle()], AHelperWidget.prototype, "visible", void 0);
class ALightHelperWidget extends AHelperWidget {
    constructor(o) {
        super(o),
        this.light = o,
        this.traverse(c => {
            c.userData.__keepShadowDef = !0,
            c.castShadow = !1,
            c.receiveShadow = !1
        }
        )
    }
}
var DirectionalLightHelper2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class DirectionalLightHelper2 extends ALightHelperWidget {
    constructor(o, c, h) {
        super(o),
        this.lineWidth = 5,
        this.size = .5,
        this._v1 = new three_module.Pq0,
        this._v2 = new three_module.Pq0,
        this._v3 = new three_module.Pq0,
        this.color = h,
        c !== void 0 && (this.size = c);
        let _ = new LineGeometry;
        this.material = new LineMaterial({
            color: 16711680,
            linewidth: .005,
            vertexColors: !1,
            dashed: !1,
            alphaToCoverage: !0,
            toneMapped: !1,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
        }),
        this.lightPlane = new Line2(_,this.material),
        this.add(this.lightPlane),
        _ = new LineGeometry,
        _.setPositions([0, 0, 0, 0, 0, 1]),
        this.targetLine = new Line2(_,this.material),
        this.add(this.targetLine),
        this.update(),
        this.traverse(b => {
            b.userData.__keepShadowDef = !0,
            b.castShadow = !1,
            b.receiveShadow = !1
        }
        )
    }
    dispose() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose(),
        super.dispose()
    }
    update() {
        var o;
        this.light && this.lightPlane && (this._v1.setFromMatrixPosition(this.light.matrixWorld),
        this._v2.setFromMatrixPosition(this.light.target.matrixWorld),
        this._v3.subVectors(this._v2, this._v1),
        this.lightPlane.geometry.setPositions([-this.size, this.size, 0, this.size, this.size, 0, this.size, -this.size, 0, -this.size, -this.size, 0, -this.size, this.size, 0]),
        this.lightPlane.lookAt(this._v2),
        this.lightPlane.material = this.material,
        this.targetLine.material = this.material,
        this.material.color.set((o = this.color) !== null && o !== void 0 ? o : this.light.color),
        this.material.linewidth = .001 * this.lineWidth,
        this.targetLine.lookAt(this._v2),
        this.targetLine.scale.z = this.light.intensity / 3)
    }
    static Check(o) {
        return o.isDirectionalLight
    }
    static Create(o) {
        return new DirectionalLightHelper2(o)
    }
}
DirectionalLightHelper2_decorate([x$1(DirectionalLightHelper2.prototype.update)], DirectionalLightHelper2.prototype, "material", void 0),
DirectionalLightHelper2_decorate([x$1(DirectionalLightHelper2.prototype.update), uiSlider(void 0, [.1, 20], .01)], DirectionalLightHelper2.prototype, "lineWidth", void 0),
DirectionalLightHelper2_decorate([x$1(DirectionalLightHelper2.prototype.update), uiSlider(void 0, [.01, 10], .01)], DirectionalLightHelper2.prototype, "size", void 0);
var PointLightHelper2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class PointLightHelper2 extends ALightHelperWidget {
    constructor(o, c, h) {
        super(o),
        this.lineWidth = 5,
        this.size = .5,
        this.color = h,
        c !== void 0 && (this.size = c);
        const _ = new WireframeGeometry2(new three_module.Gu$(.5,4,2));
        this.material = new LineMaterial({
            color: 16711680,
            linewidth: .005,
            vertexColors: !1,
            dashed: !1,
            alphaToCoverage: !0,
            toneMapped: !1,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
        }),
        this.lightSphere = new Wireframe(_,this.material),
        this.lightSphere.computeLineDistances(),
        this.add(this.lightSphere),
        this.update(),
        this.traverse(b => {
            b.userData.__keepShadowDef = !0,
            b.castShadow = !1,
            b.receiveShadow = !1
        }
        )
    }
    dispose() {
        this.lightSphere.geometry.dispose(),
        this.lightSphere.material.dispose(),
        super.dispose()
    }
    update() {
        var o;
        this.light && this.lightSphere && (this.material.color.set((o = this.color) !== null && o !== void 0 ? o : this.light.color),
        this.material.linewidth = .001 * this.lineWidth,
        this.lightSphere.scale.setScalar(this.size))
    }
    static Check(o) {
        return o.isPointLight
    }
    static Create(o) {
        return new PointLightHelper2(o)
    }
}
PointLightHelper2_decorate([x$1(PointLightHelper2.prototype.update)], PointLightHelper2.prototype, "material", void 0),
PointLightHelper2_decorate([x$1(PointLightHelper2.prototype.update), uiSlider(void 0, [.1, 20], .01)], PointLightHelper2.prototype, "lineWidth", void 0),
PointLightHelper2_decorate([x$1(PointLightHelper2.prototype.update), uiSlider(void 0, [.01, 10], .01)], PointLightHelper2.prototype, "size", void 0);
var SpotLightHelper2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class SpotLightHelper2 extends ALightHelperWidget {
    constructor(o, c, h) {
        super(o),
        this.lineWidth = 5,
        this._v1 = new three_module.Pq0,
        this.color = h;
        let _ = new LineSegmentsGeometry;
        const b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let _e = 0, nt = 1, it = 32; _e < it; _e++,
        nt++) {
            const at = _e / it * Math.PI * 2
              , ut = nt / it * Math.PI * 2;
            b.push(Math.cos(at), Math.sin(at), 1, Math.cos(ut), Math.sin(ut), 1)
        }
        _.setPositions(b),
        this.material = new LineMaterial({
            color: 16711680,
            linewidth: .005,
            vertexColors: !1,
            dashed: !1,
            alphaToCoverage: !0,
            toneMapped: !1,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
        }),
        this.cone = new LineSegments2(_,this.material),
        this.add(this.cone),
        _ = new LineGeometry,
        _.setPositions([0, 0, 0, 0, 0, 1]),
        this.update(),
        this.traverse(_e => {
            _e.userData.__keepShadowDef = !0,
            _e.castShadow = !1,
            _e.receiveShadow = !1
        }
        )
    }
    dispose() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose(),
        super.dispose()
    }
    update() {
        var o;
        if (!this.light || !this.cone)
            return;
        this.light.updateWorldMatrix(!0, !1),
        this.light.target.updateWorldMatrix(!0, !1);
        const c = this.light.distance ? this.light.distance : 1e3
          , h = c * Math.tan(this.light.angle);
        this.cone.scale.set(h, h, c),
        this._v1.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(this._v1),
        this.material.color.set((o = this.color) !== null && o !== void 0 ? o : this.light.color),
        this.material.linewidth = .001 * this.lineWidth
    }
    static Check(o) {
        return o.isSpotLight
    }
    static Create(o) {
        return new SpotLightHelper2(o)
    }
}
SpotLightHelper2_decorate([x$1(SpotLightHelper2.prototype.update)], SpotLightHelper2.prototype, "material", void 0),
SpotLightHelper2_decorate([x$1(SpotLightHelper2.prototype.update), uiSlider(void 0, [.1, 20], .01)], SpotLightHelper2.prototype, "lineWidth", void 0);
class ACameraHelperWidget extends AHelperWidget {
    constructor(o) {
        super(o),
        this.camera = o,
        this.traverse(c => {
            c.userData.__keepShadowDef = !0,
            c.castShadow = !1,
            c.receiveShadow = !1
        }
        )
    }
}
class CameraHelper2 extends ACameraHelperWidget {
    constructor(o) {
        super(o),
        this._vector = new three_module.Pq0,
        this._camera = new three_module.i7d;
        const c = new LineSegmentsGeometry
          , h = new LineMaterial({
            color: 16777215,
            linewidth: .005,
            vertexColors: !0,
            dashed: !1,
            alphaToCoverage: !0,
            toneMapped: !1,
            transparent: !0,
            depthTest: !1,
            depthWrite: !1
        })
          , {vertices: _, colors: b, pointMap: _e} = generateVertices();
        c.setPositions(_),
        c.setColors(b),
        this.line = new LineSegments2(c,h),
        this.line.frustumCulled = !1,
        this.add(this.line),
        this.pointMap = _e,
        this.update();
        const nt = new three_module.Q1f(16755200)
          , it = new three_module.Q1f(16711680)
          , at = new three_module.Q1f(43775)
          , ut = new three_module.Q1f(16777215)
          , pt = new three_module.Q1f(3355443);
        this.setColors(nt, it, at, ut, pt)
    }
    setColors(o, c, h, _, b) {
        const _e = this.line.geometry
          , nt = _e.getAttribute("instanceColorStart")
          , it = _e.getAttribute("instanceColorEnd");
        function at(ut, pt) {
            nt.setXYZ(ut / 2, pt.r, pt.g, pt.b),
            it.setXYZ(ut / 2, pt.r, pt.g, pt.b)
        }
        at(0, o),
        at(2, o),
        at(4, o),
        at(6, o),
        at(8, o),
        at(10, o),
        at(12, o),
        at(14, o),
        at(16, o),
        at(18, o),
        at(20, o),
        at(22, o),
        at(24, c),
        at(26, c),
        at(28, c),
        at(30, c),
        at(32, h),
        at(34, h),
        at(36, h),
        at(38, _),
        at(40, b),
        at(42, b),
        at(44, b),
        at(46, b),
        at(48, b),
        nt.needsUpdate = !0,
        it.needsUpdate = !0
    }
    update() {
        if (!this.camera)
            return;
        const o = this.line.geometry
          , c = this.pointMap
          , {_camera: h, _vector: _} = this;
        h.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
        setPoint("c", c, o, h, 0, 0, -1, _),
        setPoint("t", c, o, h, 0, 0, 1, _),
        setPoint("n1", c, o, h, -1, -1, -1, _),
        setPoint("n2", c, o, h, 1, -1, -1, _),
        setPoint("n3", c, o, h, -1, 1, -1, _),
        setPoint("n4", c, o, h, 1, 1, -1, _),
        setPoint("f1", c, o, h, -1, -1, 1, _),
        setPoint("f2", c, o, h, 1, -1, 1, _),
        setPoint("f3", c, o, h, -1, 1, 1, _),
        setPoint("f4", c, o, h, 1, 1, 1, _),
        setPoint("u1", c, o, h, .7, 1.1, -1, _),
        setPoint("u2", c, o, h, -.7, 1.1, -1, _),
        setPoint("u3", c, o, h, 0, 2, -1, _),
        setPoint("cf1", c, o, h, -1, 0, 1, _),
        setPoint("cf2", c, o, h, 1, 0, 1, _),
        setPoint("cf3", c, o, h, 0, -1, 1, _),
        setPoint("cf4", c, o, h, 0, 1, 1, _),
        setPoint("cn1", c, o, h, -1, 0, -1, _),
        setPoint("cn2", c, o, h, 1, 0, -1, _),
        setPoint("cn3", c, o, h, 0, -1, -1, _),
        setPoint("cn4", c, o, h, 0, 1, -1, _),
        o.getAttribute("instanceStart").needsUpdate = !0,
        o.getAttribute("instanceEnd").needsUpdate = !0,
        o.computeBoundingBox(),
        o.computeBoundingSphere()
    }
    dispose() {
        this.line.geometry.dispose(),
        this.line.material.dispose(),
        super.dispose()
    }
    static Check(o) {
        return o.isCamera
    }
    static Create(o) {
        return new CameraHelper2(o)
    }
}
function setPoint(d, o, c, h, _, b, _e, nt) {
    nt.set(_, b, _e).unproject(h);
    const it = o[d];
    if (it !== void 0) {
        const at = c.getAttribute("instanceStart")
          , ut = c.getAttribute("instanceEnd");
        for (let pt = 0, ht = it.length; pt < ht; pt++) {
            const _t = Math.floor(it[pt] / 2);
            (it[pt] % 2 == 0 ? at : ut).setXYZ(_t, nt.x, nt.y, nt.z)
        }
    }
}
function generateVertices() {
    const d = []
      , o = []
      , c = {};
    function h(b, _e) {
        _(b),
        _(_e)
    }
    function _(b) {
        d.push(0, 0, 0),
        o.push(0, 0, 0),
        c[b] === void 0 && (c[b] = []),
        c[b].push(d.length / 3 - 1)
    }
    return h("n1", "n2"),
    h("n2", "n4"),
    h("n4", "n3"),
    h("n3", "n1"),
    h("f1", "f2"),
    h("f2", "f4"),
    h("f4", "f3"),
    h("f3", "f1"),
    h("n1", "f1"),
    h("n2", "f2"),
    h("n3", "f3"),
    h("n4", "f4"),
    h("p", "n1"),
    h("p", "n2"),
    h("p", "n3"),
    h("p", "n4"),
    h("u1", "u2"),
    h("u2", "u3"),
    h("u3", "u1"),
    h("c", "t"),
    h("p", "c"),
    h("cn1", "cn2"),
    h("cn3", "cn4"),
    h("cf1", "cf2"),
    h("cf3", "cf4"),
    {
        vertices: d,
        colors: o,
        pointMap: c
    }
}
var Object3DWidgetsPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class Object3DWidgetsPlugin extends AViewerPlugin {
    setDirty() {
        var o, c;
        (o = this.widgets) === null || o === void 0 || o.forEach(h => h.visible = this.enabled),
        (c = this._viewer) === null || c === void 0 || c.setDirty()
    }
    constructor(o=!0) {
        super(),
        this.enabled = !0,
        this.helpers = [DirectionalLightHelper2, SpotLightHelper2, PointLightHelper2, CameraHelper2],
        this.toJSON = null,
        this._addSceneObject = c => {
            const h = c.object;
            this._createWidgets(h == null ? void 0 : h.modelObject)
        }
        ,
        this.widgets = [],
        this.uiConfig = {
            type: "folder",
            label: "Widgets",
            children: [{
                type: "checkbox",
                label: "Visible",
                property: [this, "enabled"]
            }, {
                type: "button",
                label: "Refresh",
                value: () => this.refresh()
            }]
        },
        this.enabled = o
    }
    async onAdded(o) {
        await super.onAdded(o),
        o.scene.addEventListener("addSceneObject", this._addSceneObject)
    }
    async onRemove(o) {
        return o.scene.removeEventListener("addSceneObject", this._addSceneObject),
        this.widgets.forEach(c => c.dispose && c.dispose()),
        this.widgets = [],
        super.onRemove(o)
    }
    refresh() {
        var o;
        this._createWidgets((o = this._viewer) === null || o === void 0 ? void 0 : o.scene.modelRoot)
    }
    _createWidgets(o) {
        o == null || o.traverse(c => {
            const h = this.widgets.find(b => b.object === c);
            if (h)
                return void (h.update && h.update());
            this.helpers.filter(b => b.Check(c)).forEach(b => {
                var _e;
                const nt = b.Create(c);
                nt.visible = this.enabled,
                this.widgets.push(nt),
                (_e = this._viewer) === null || _e === void 0 || _e.scene.addWidget(nt)
            }
            )
        }
        )
    }
}
Object3DWidgetsPlugin.PluginType = "WidgetsPlugin",
Object3DWidgetsPlugin_decorate([x$1(Object3DWidgetsPlugin.prototype.setDirty)], Object3DWidgetsPlugin.prototype, "enabled", void 0);
var popper_lite_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles]
  , popper_lite_createPopper = popperGenerator({
    defaultModifiers: popper_lite_defaultModifiers
})
  , object_hash = __webpackgi_require__(516)
  , object_hash_default = __webpackgi_require__.n(object_hash);
function removeDuplicateGeometries(d) {
    const o = [];
    d.traverse(_ => {
        _.geometry && o.push(_)
    }
    );
    const c = {}
      , h = {};
    o.forEach(_ => {
        var b;
        if (!c[_.geometry.uuid]) {
            const it = _.geometry.toJSON().data
              , at = it ? object_hash_default()({
                a: it.attributes || {},
                b: it.index || []
            }) : "";
            c[_.geometry.uuid] = at
        }
        const _e = c[_.geometry.uuid]
          , nt = (b = h[_e]) !== null && b !== void 0 ? b : h[_e] = [];
        nt.includes(_) || nt.push(_)
    }
    ),
    Object.values(h).forEach(_ => {
        if (_.length < 2)
            return;
        const b = _[0].geometry;
        _.forEach( (_e, nt) => {
            nt < 1 || (_e.geometry.dispose(),
            _e.geometry = b)
        }
        )
    }
    )
}
const offset2 = new three_module.Pq0
  , targetDeltaX = new three_module.Pq0
  , targetDeltaY = new three_module.Pq0
  , targetDeltaZ = new three_module.Pq0
  , targetDelta = new three_module.Pq0
  , panOffset2 = new three_module.Pq0;
let scaleOffset = 1;
const upVec = new three_module.Pq0(0,1,0);
class OrbitControls2 extends OrbitControls {
    constructor(o, c) {
        super(o, c),
        this.throttleUpdate = 60,
        this.targetOffset = new three_module.Pq0(0,0,0);
        const h = this.update;
        this.update = () => this._update(h)
    }
    _update(o) {
        this.target.add(this.targetOffset),
        offset2.copy(this.object.position).sub(this.target),
        scaleOffset = offset2.length(),
        panOffset2.copy(this.target);
        const c = o();
        return panOffset2.sub(this.target),
        offset2.copy(this.object.position).sub(this.target),
        scaleOffset /= offset2.length(),
        this.target.add(panOffset2),
        this.object.position.copy(this.target).add(offset2),
        offset2.normalize(),
        targetDeltaX.crossVectors(upVec, offset2).normalize(),
        targetDeltaY.crossVectors(offset2, targetDeltaX).normalize(),
        targetDeltaZ.crossVectors(targetDeltaX, targetDeltaY).normalize().negate(),
        targetDeltaX.length() > .1 && this.object.up.crossVectors(offset2.clone().normalize(), targetDeltaX),
        this.enablePan && (targetDelta.set(0, 0, 0).addScaledVector(targetDeltaX, panOffset2.x).addScaledVector(targetDeltaY, panOffset2.y).addScaledVector(targetDeltaZ, panOffset2.z),
        this.targetOffset.add(targetDelta),
        this.targetOffset.multiplyScalar(1 / scaleOffset)),
        targetDelta.set(0, 0, 0).addScaledVector(targetDeltaX, -this.targetOffset.x).addScaledVector(targetDeltaY, -this.targetOffset.y).addScaledVector(targetDeltaZ, -this.targetOffset.z),
        this.object.lookAt(targetDelta.add(this.target)),
        this.object.updateMatrixWorld(),
        this.object.isCamera && this.object.updateProjectionMatrix(),
        this.target.sub(this.targetOffset),
        c
    }
}
const _raycaster = new three_module.tBo
  , _tempVector = new three_module.Pq0
  , _tempVector2 = new three_module.Pq0
  , _tempQuaternion = new three_module.PTz
  , _unit = {
    X: new three_module.Pq0(1,0,0),
    Y: new three_module.Pq0(0,1,0),
    Z: new three_module.Pq0(0,0,1)
}
  , TransformControls_changeEvent = {
    type: "change"
}
  , _mouseDownEvent = {
    type: "mouseDown"
}
  , _mouseUpEvent = {
    type: "mouseUp",
    mode: null
}
  , _objectChangeEvent = {
    type: "objectChange"
};
class TransformControls extends three_module.B69 {
    constructor(o, c) {
        super(),
        c === void 0 && (console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),
        c = document),
        this.isTransformControls = !0,
        this.visible = !1,
        this.domElement = c,
        this.domElement.style.touchAction = "none";
        const h = new TransformControlsGizmo;
        this._gizmo = h,
        this.add(h);
        const _ = new TransformControlsPlane;
        this._plane = _,
        this.add(_);
        const b = this;
        function _e(At, Et) {
            let Pt = Et;
            Object.defineProperty(b, At, {
                get: function() {
                    return Pt !== void 0 ? Pt : Et
                },
                set: function(It) {
                    Pt !== It && (Pt = It,
                    _[At] = It,
                    h[At] = It,
                    b.dispatchEvent({
                        type: At + "-changed",
                        value: It
                    }),
                    b.dispatchEvent(TransformControls_changeEvent))
                }
            }),
            b[At] = Et,
            _[At] = Et,
            h[At] = Et
        }
        _e("camera", o),
        _e("object", void 0),
        _e("enabled", !0),
        _e("axis", null),
        _e("mode", "translate"),
        _e("translationSnap", null),
        _e("rotationSnap", null),
        _e("scaleSnap", null),
        _e("space", "world"),
        _e("size", 1),
        _e("dragging", !1),
        _e("showX", !0),
        _e("showY", !0),
        _e("showZ", !0);
        const nt = new three_module.Pq0
          , it = new three_module.Pq0
          , at = new three_module.PTz
          , ut = new three_module.PTz
          , pt = new three_module.Pq0
          , ht = new three_module.PTz
          , _t = new three_module.Pq0
          , vt = new three_module.Pq0
          , bt = new three_module.Pq0
          , St = new three_module.Pq0;
        _e("worldPosition", nt),
        _e("worldPositionStart", it),
        _e("worldQuaternion", at),
        _e("worldQuaternionStart", ut),
        _e("cameraPosition", pt),
        _e("cameraQuaternion", ht),
        _e("pointStart", _t),
        _e("pointEnd", vt),
        _e("rotationAxis", bt),
        _e("rotationAngle", 0),
        _e("eye", St),
        this._offset = new three_module.Pq0,
        this._startNorm = new three_module.Pq0,
        this._endNorm = new three_module.Pq0,
        this._cameraScale = new three_module.Pq0,
        this._parentPosition = new three_module.Pq0,
        this._parentQuaternion = new three_module.PTz,
        this._parentQuaternionInv = new three_module.PTz,
        this._parentScale = new three_module.Pq0,
        this._worldScaleStart = new three_module.Pq0,
        this._worldQuaternionInv = new three_module.PTz,
        this._worldScale = new three_module.Pq0,
        this._positionStart = new three_module.Pq0,
        this._quaternionStart = new three_module.PTz,
        this._scaleStart = new three_module.Pq0,
        this._getPointer = getPointer.bind(this),
        this._onPointerDown = onPointerDown.bind(this),
        this._onPointerHover = onPointerHover.bind(this),
        this._onPointerMove = onPointerMove.bind(this),
        this._onPointerUp = onPointerUp.bind(this),
        this.domElement.addEventListener("pointerdown", this._onPointerDown),
        this.domElement.addEventListener("pointermove", this._onPointerHover),
        this.domElement.addEventListener("pointerup", this._onPointerUp)
    }
    updateMatrixWorld() {
        this.object !== void 0 && (this.object.updateMatrixWorld(),
        this.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale),
        this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale),
        this._parentQuaternionInv.copy(this._parentQuaternion).invert(),
        this._worldQuaternionInv.copy(this.worldQuaternion).invert()),
        this.camera.updateMatrixWorld(),
        this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale),
        this.camera.isOrthographicCamera ? this.camera.getWorldDirection(this.eye).negate() : this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),
        super.updateMatrixWorld(this)
    }
    pointerHover(o) {
        if (this.object === void 0 || this.dragging === !0 || o.buttons)
            return;
        _raycaster.setFromCamera(o, this.camera);
        const c = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
        this.axis = c ? c.object.name : null
    }
    pointerDown(o) {
        if (this.object !== void 0 && this.dragging !== !0 && o.button === 0 && this.axis !== null) {
            _raycaster.setFromCamera(o, this.camera);
            const c = intersectObjectWithRay(this._plane, _raycaster, !0);
            c && (this.object.updateMatrixWorld(),
            this.object.parent.updateMatrixWorld(),
            this._positionStart.copy(this.object.position),
            this._quaternionStart.copy(this.object.quaternion),
            this._scaleStart.copy(this.object.scale),
            this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart),
            this.pointStart.copy(c.point).sub(this.worldPositionStart)),
            this.dragging = !0,
            _mouseDownEvent.mode = this.mode,
            this.dispatchEvent(_mouseDownEvent)
        }
    }
    pointerMove(o) {
        const c = this.axis
          , h = this.mode
          , _ = this.object;
        let b = this.space;
        if (h === "scale" ? b = "local" : c !== "E" && c !== "XYZE" && c !== "XYZ" || (b = "world"),
        _ === void 0 || c === null || this.dragging === !1 || o.button !== -1)
            return;
        _raycaster.setFromCamera(o, this.camera);
        const _e = intersectObjectWithRay(this._plane, _raycaster, !0);
        if (_e) {
            if (this.pointEnd.copy(_e.point).sub(this.worldPositionStart),
            h === "translate")
                this._offset.copy(this.pointEnd).sub(this.pointStart),
                b === "local" && c !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv),
                c.indexOf("X") === -1 && (this._offset.x = 0),
                c.indexOf("Y") === -1 && (this._offset.y = 0),
                c.indexOf("Z") === -1 && (this._offset.z = 0),
                b === "local" && c !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),
                _.position.copy(this._offset).add(this._positionStart),
                this.translationSnap && (b === "local" && (_.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert()),
                c.search("X") !== -1 && (_.position.x = Math.round(_.position.x / this.translationSnap) * this.translationSnap),
                c.search("Y") !== -1 && (_.position.y = Math.round(_.position.y / this.translationSnap) * this.translationSnap),
                c.search("Z") !== -1 && (_.position.z = Math.round(_.position.z / this.translationSnap) * this.translationSnap),
                _.position.applyQuaternion(this._quaternionStart)),
                b === "world" && (_.parent && _.position.add(_tempVector.setFromMatrixPosition(_.parent.matrixWorld)),
                c.search("X") !== -1 && (_.position.x = Math.round(_.position.x / this.translationSnap) * this.translationSnap),
                c.search("Y") !== -1 && (_.position.y = Math.round(_.position.y / this.translationSnap) * this.translationSnap),
                c.search("Z") !== -1 && (_.position.z = Math.round(_.position.z / this.translationSnap) * this.translationSnap),
                _.parent && _.position.sub(_tempVector.setFromMatrixPosition(_.parent.matrixWorld))));
            else if (h === "scale") {
                if (c.search("XYZ") !== -1) {
                    let nt = this.pointEnd.length() / this.pointStart.length();
                    this.pointEnd.dot(this.pointStart) < 0 && (nt *= -1),
                    _tempVector2.set(nt, nt, nt)
                } else
                    _tempVector.copy(this.pointStart),
                    _tempVector2.copy(this.pointEnd),
                    _tempVector.applyQuaternion(this._worldQuaternionInv),
                    _tempVector2.applyQuaternion(this._worldQuaternionInv),
                    _tempVector2.divide(_tempVector),
                    c.search("X") === -1 && (_tempVector2.x = 1),
                    c.search("Y") === -1 && (_tempVector2.y = 1),
                    c.search("Z") === -1 && (_tempVector2.z = 1);
                _.scale.copy(this._scaleStart).multiply(_tempVector2),
                this.scaleSnap && (c.search("X") !== -1 && (_.scale.x = Math.round(_.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap),
                c.search("Y") !== -1 && (_.scale.y = Math.round(_.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap),
                c.search("Z") !== -1 && (_.scale.z = Math.round(_.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap))
            } else if (h === "rotate") {
                this._offset.copy(this.pointEnd).sub(this.pointStart);
                const nt = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
                let it = !1;
                c === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),
                this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * nt) : c !== "X" && c !== "Y" && c !== "Z" || (this.rotationAxis.copy(_unit[c]),
                _tempVector.copy(_unit[c]),
                b === "local" && _tempVector.applyQuaternion(this.worldQuaternion),
                _tempVector.cross(this.eye),
                _tempVector.length() === 0 ? it = !0 : this.rotationAngle = this._offset.dot(_tempVector.normalize()) * nt),
                (c === "E" || it) && (this.rotationAxis.copy(this.eye),
                this.rotationAngle = this.pointEnd.angleTo(this.pointStart),
                this._startNorm.copy(this.pointStart).normalize(),
                this._endNorm.copy(this.pointEnd).normalize(),
                this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1),
                this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap),
                b === "local" && c !== "E" && c !== "XYZE" ? (_.quaternion.copy(this._quaternionStart),
                _.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv),
                _.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)),
                _.quaternion.multiply(this._quaternionStart).normalize())
            }
            this.dispatchEvent(TransformControls_changeEvent),
            this.dispatchEvent(_objectChangeEvent)
        }
    }
    pointerUp(o) {
        o.button === 0 && (this.dragging && this.axis !== null && (_mouseUpEvent.mode = this.mode,
        this.dispatchEvent(_mouseUpEvent)),
        this.dragging = !1,
        this.axis = null)
    }
    dispose() {
        this.domElement.removeEventListener("pointerdown", this._onPointerDown),
        this.domElement.removeEventListener("pointermove", this._onPointerHover),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.traverse(function(o) {
            o.geometry && o.geometry.dispose(),
            o.material && o.material.dispose()
        })
    }
    attach(o) {
        return this.object = o,
        this.visible = !0,
        this
    }
    detach() {
        return this.object = void 0,
        this.visible = !1,
        this.axis = null,
        this
    }
    reset() {
        this.enabled && this.dragging && (this.object.position.copy(this._positionStart),
        this.object.quaternion.copy(this._quaternionStart),
        this.object.scale.copy(this._scaleStart),
        this.dispatchEvent(TransformControls_changeEvent),
        this.dispatchEvent(_objectChangeEvent),
        this.pointStart.copy(this.pointEnd))
    }
    getRaycaster() {
        return _raycaster
    }
    getMode() {
        return this.mode
    }
    setMode(o) {
        this.mode = o
    }
    setTranslationSnap(o) {
        this.translationSnap = o
    }
    setRotationSnap(o) {
        this.rotationSnap = o
    }
    setScaleSnap(o) {
        this.scaleSnap = o
    }
    setSize(o) {
        this.size = o
    }
    setSpace(o) {
        this.space = o
    }
}
function getPointer(d) {
    if (this.domElement.ownerDocument.pointerLockElement)
        return {
            x: 0,
            y: 0,
            button: d.button,
            buttons: d.buttons
        };
    {
        const o = this.domElement.getBoundingClientRect();
        return {
            x: (d.clientX - o.left) / o.width * 2 - 1,
            y: -(d.clientY - o.top) / o.height * 2 + 1,
            button: d.button,
            buttons: d.buttons
        }
    }
}
function onPointerHover(d) {
    if (this.enabled)
        switch (d.pointerType) {
        case "mouse":
        case "pen":
            this.pointerHover(this._getPointer(d))
        }
}
function onPointerDown(d) {
    this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(d.pointerId),
    this.domElement.addEventListener("pointermove", this._onPointerMove),
    this.pointerHover(this._getPointer(d)),
    this.pointerDown(this._getPointer(d)))
}
function onPointerMove(d) {
    this.enabled && this.pointerMove(this._getPointer(d))
}
function onPointerUp(d) {
    this.enabled && (this.domElement.releasePointerCapture(d.pointerId),
    this.domElement.removeEventListener("pointermove", this._onPointerMove),
    this.pointerUp(this._getPointer(d)))
}
function intersectObjectWithRay(d, o, c) {
    const h = o.intersectObject(d, !0);
    for (let _ = 0; _ < h.length; _++)
        if (h[_].object.visible || c)
            return h[_];
    return !1
}
TransformControls.ObjectConstructors = {
    MeshBasicMaterial: three_module.V9B,
    LineBasicMaterial: three_module.mrM
};
const _tempEuler = new three_module.O9p
  , _alignVector = new three_module.Pq0(0,1,0)
  , _zeroVector = new three_module.Pq0(0,0,0)
  , _lookAtMatrix = new three_module.kn4
  , _tempQuaternion2 = new three_module.PTz
  , _identityQuaternion = new three_module.PTz
  , _dirVector = new three_module.Pq0
  , _tempMatrix = new three_module.kn4
  , _unitX = new three_module.Pq0(1,0,0)
  , _unitY = new three_module.Pq0(0,1,0)
  , _unitZ = new three_module.Pq0(0,0,1)
  , TransformControls_v1 = new three_module.Pq0
  , TransformControls_v2 = new three_module.Pq0
  , _v3 = new three_module.Pq0;
class TransformControlsGizmo extends three_module.B69 {
    constructor() {
        super(),
        this.isTransformControlsGizmo = !0,
        this.type = "TransformControlsGizmo";
        const o = new TransformControls.ObjectConstructors.MeshBasicMaterial({
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            toneMapped: !1,
            transparent: !0
        })
          , c = new TransformControls.ObjectConstructors.LineBasicMaterial({
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            toneMapped: !1,
            transparent: !0
        })
          , h = o.clone();
        h.opacity = .15;
        const _ = c.clone();
        _.opacity = 1;
        const b = o.clone();
        b.color.setHex(15663205),
        b.opacity = .95;
        const _e = o.clone();
        _e.color.setHex(2014720),
        _e.opacity = .95;
        const nt = o.clone();
        nt.color.setHex(37885),
        nt.opacity = .95;
        const it = o.clone();
        it.color.setHex(16618689),
        it.__color = b.color.getHex();
        const at = o.clone();
        at.color.setHex(12516474),
        at.__color = _e.color.getHex();
        const ut = o.clone();
        ut.color.setHex(11397372),
        ut.__color = nt.color.getHex();
        const pt = o.clone();
        pt.color.setHex(15663205),
        pt.opacity = .75;
        const ht = o.clone();
        ht.color.setHex(2014720),
        ht.opacity = .75;
        const _t = o.clone();
        _t.color.setHex(37885),
        _t.opacity = .75;
        const vt = o.clone();
        vt.color.setHex(12893629),
        vt.opacity = .75;
        const bt = o.clone();
        bt.color.setHex(16777051),
        bt.opacity = .25;
        const St = o.clone();
        St.color.setHex(7895160),
        St.opacity = .75;
        const At = new three_module.Ho_(0,.04,.1,12);
        At.translate(0, .05, 0);
        const Et = new three_module.iNn(.08,.08,.08);
        Et.translate(0, .04, 0);
        const Pt = new three_module.LoY;
        Pt.setAttribute("position", new three_module.qtW([0, 0, 0, 1, 0, 0],3));
        const It = new three_module.Ho_(.0075,.0075,.5,3);
        function Dt(hr, gr) {
            const dr = new three_module.O3Y(hr,.0075,3,64,gr * Math.PI * 2);
            return dr.rotateY(Math.PI / 2),
            dr.rotateX(Math.PI / 2),
            dr
        }
        function Gt(hr, gr) {
            const dr = new three_module.O3Y(hr,.1,4,24,gr * Math.PI * 2);
            return dr.rotateY(Math.PI / 2),
            dr.rotateX(Math.PI / 2),
            dr
        }
        It.translate(0, .25, 0);
        const Bt = {
            X: [[new three_module.eaF(At,it), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new three_module.eaF(It,b), [0, 0, 0], [0, 0, -Math.PI / 2]]],
            Y: [[new three_module.eaF(At,at), [0, .5, 0]], [new three_module.eaF(It,_e)]],
            Z: [[new three_module.eaF(At,ut), [0, 0, .5], [Math.PI / 2, 0, 0]], [new three_module.eaF(It,nt), null, [Math.PI / 2, 0, 0]]],
            XYZ: [[new three_module.eaF(new three_module.Ufg(.1,2),vt.clone()), [0, 0, 0]]],
            XY: [[new three_module.eaF(new three_module.iNn(.2,.2,.01),_t.clone()), [.2, .2, 0]]],
            YZ: [[new three_module.eaF(new three_module.iNn(.2,.2,.01),pt.clone()), [0, .2, .2], [0, Math.PI / 2, 0]]],
            XZ: [[new three_module.eaF(new three_module.iNn(.2,.2,.01),ht.clone()), [.2, 0, .2], [-Math.PI / 2, 0, 0]]]
        }
          , kt = {
            X: [[new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [.3, 0, 0], [0, 0, -Math.PI / 2]]],
            Y: [[new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [0, .3, 0]]],
            Z: [[new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [0, 0, .3], [Math.PI / 2, 0, 0]]],
            XYZ: [[new three_module.eaF(new three_module.Ufg(.2,0),h)]],
            XY: [[new three_module.eaF(new three_module.iNn(.25,.25,.01),h), [.2, .2, 0]]],
            YZ: [[new three_module.eaF(new three_module.iNn(.25,.25,.01),h), [0, .2, .2], [0, Math.PI / 2, 0]]],
            XZ: [[new three_module.eaF(new three_module.iNn(.25,.25,.01),h), [.2, 0, .2], [-Math.PI / 2, 0, 0]]]
        }
          , Ut = {
            START: [[new three_module.eaF(new three_module.Ufg(.01,2),_), null, null, null, "helper"]],
            END: [[new three_module.eaF(new three_module.Ufg(.01,2),_), null, null, null, "helper"]],
            DELTA: [[new three_module.N1A(function() {
                const hr = new three_module.LoY;
                return hr.setAttribute("position", new three_module.qtW([0, 0, 0, 1, 1, 1],3)),
                hr
            }(),_), null, null, null, "helper"]],
            X: [[new three_module.N1A(Pt,_.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
            Y: [[new three_module.N1A(Pt,_.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
            Z: [[new three_module.N1A(Pt,_.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
        }
          , Ht = {
            XYZE: [[new three_module.eaF(new three_module.Gu$(.1,10,8),vt)], [new three_module.eaF(Dt(.5, 1),St), null, [0, Math.PI / 2, 0]]],
            X: [[new three_module.eaF(Dt(.5, .5),b)], [new three_module.eaF(It,b), [0, 0, 0], [0, 0, -Math.PI / 2]], [new three_module.eaF(At.clone().translate(.5, 0, 0),it), [0, 0, 0], [-Math.PI / 2, -Math.PI / 2, -Math.PI / 2]]],
            Y: [[new three_module.eaF(Dt(.5, .5),_e), null, [0, 0, -Math.PI / 2]], [new three_module.eaF(It,_e)], [new three_module.eaF(At.clone().rotateZ(-Math.PI / 2).translate(0, .5, 0),at), [0, 0, 0], [Math.PI / 2, 0, 0]]],
            Z: [[new three_module.eaF(Dt(.5, .5),nt), null, [0, Math.PI / 2, 0]], [new three_module.eaF(It,nt), null, [Math.PI / 2, 0, 0]], [new three_module.eaF(At.clone().rotateZ(-Math.PI).translate(0, 0, .5),ut), [0, 0, 0], [0, Math.PI / 2, 0]]]
        }
          , Kt = {
            AXIS: [[new three_module.N1A(Pt,_.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]]
        }
          , Jt = {
            XYZE: [[new three_module.eaF(new three_module.Gu$(.25,10,8),h)]],
            X: [[new three_module.eaF(Gt(.5, .5),h)]],
            Y: [[new three_module.eaF(Gt(.5, .5),h), [0, 0, 0], [0, 0, -Math.PI / 2]]],
            Z: [[new three_module.eaF(Gt(.5, .5),h), [0, 0, 0], [0, Math.PI / 2, 0]]]
        }
          , or = {
            X: [[new three_module.eaF(Et,it), [.5, 0, 0], [0, 0, -Math.PI / 2]], [new three_module.eaF(It,b), [0, 0, 0], [0, 0, -Math.PI / 2]]],
            Y: [[new three_module.eaF(Et,at), [0, .5, 0]], [new three_module.eaF(It,_e)]],
            Z: [[new three_module.eaF(Et,ut), [0, 0, .5], [Math.PI / 2, 0, 0]], [new three_module.eaF(It,nt), [0, 0, 0], [Math.PI / 2, 0, 0]]],
            XY: [[new three_module.eaF(new three_module.iNn(.15,.15,.01),_t), [.15, .15, 0]]],
            YZ: [[new three_module.eaF(new three_module.iNn(.15,.15,.01),pt), [0, .15, .15], [0, Math.PI / 2, 0]]],
            XZ: [[new three_module.eaF(new three_module.iNn(.15,.15,.01),ht), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
            XYZ: [[new three_module.eaF(new three_module.iNn(.1,.1,.1),vt.clone())]]
        }
          , ir = {
            X: [[new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [.3, 0, 0], [0, 0, -Math.PI / 2]], [new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [-.3, 0, 0], [0, 0, Math.PI / 2]]],
            Y: [[new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [0, .3, 0]], [new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [0, -.3, 0], [0, 0, Math.PI]]],
            Z: [[new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [0, 0, .3], [Math.PI / 2, 0, 0]], [new three_module.eaF(new three_module.Ho_(.2,0,.6,4),h), [0, 0, -.3], [-Math.PI / 2, 0, 0]]],
            XY: [[new three_module.eaF(new three_module.iNn(.2,.2,.01),h), [.15, .15, 0]]],
            YZ: [[new three_module.eaF(new three_module.iNn(.2,.2,.01),h), [0, .15, .15], [0, Math.PI / 2, 0]]],
            XZ: [[new three_module.eaF(new three_module.iNn(.2,.2,.01),h), [.15, 0, .15], [-Math.PI / 2, 0, 0]]],
            XYZ: [[new three_module.eaF(new three_module.iNn(.2,.2,.2),h), [0, 0, 0]]]
        }
          , lr = {
            X: [[new three_module.N1A(Pt,_.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
            Y: [[new three_module.N1A(Pt,_.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]],
            Z: [[new three_module.N1A(Pt,_.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]]
        };
        function ar(hr) {
            const gr = new three_module.B69;
            for (const dr in hr)
                for (let cr = hr[dr].length; cr--; ) {
                    const Ar = hr[dr][cr][0].clone()
                      , wr = hr[dr][cr][1]
                      , Rr = hr[dr][cr][2]
                      , Cr = hr[dr][cr][3]
                      , tr = hr[dr][cr][4];
                    Ar.name = dr,
                    Ar.tag = tr,
                    wr && Ar.position.set(wr[0], wr[1], wr[2]),
                    Rr && Ar.rotation.set(Rr[0], Rr[1], Rr[2]),
                    Cr && Ar.scale.set(Cr[0], Cr[1], Cr[2]),
                    Ar.updateMatrix();
                    const fr = Ar.geometry.clone();
                    fr.applyMatrix4(Ar.matrix),
                    Ar.geometry = fr,
                    Ar.renderOrder = 1 / 0,
                    Ar.position.set(0, 0, 0),
                    Ar.rotation.set(0, 0, 0),
                    Ar.scale.set(1, 1, 1),
                    gr.add(Ar)
                }
            return gr
        }
        this.gizmo = {},
        this.picker = {},
        this.helper = {},
        this.add(this.gizmo.translate = ar(Bt)),
        this.add(this.gizmo.rotate = ar(Ht)),
        this.add(this.gizmo.scale = ar(or)),
        this.add(this.picker.translate = ar(kt)),
        this.add(this.picker.rotate = ar(Jt)),
        this.add(this.picker.scale = ar(ir)),
        this.add(this.helper.translate = ar(Ut)),
        this.add(this.helper.rotate = ar(Kt)),
        this.add(this.helper.scale = ar(lr)),
        this.picker.translate.visible = !1,
        this.picker.rotate.visible = !1,
        this.picker.scale.visible = !1
    }
    updateMatrixWorld(o) {
        const c = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : _identityQuaternion;
        this.gizmo.translate.visible = this.mode === "translate",
        this.gizmo.rotate.visible = this.mode === "rotate",
        this.gizmo.scale.visible = this.mode === "scale",
        this.helper.translate.visible = this.mode === "translate",
        this.helper.rotate.visible = this.mode === "rotate",
        this.helper.scale.visible = this.mode === "scale";
        let h = [];
        h = h.concat(this.picker[this.mode].children),
        h = h.concat(this.gizmo[this.mode].children),
        h = h.concat(this.helper[this.mode].children);
        for (let _ = 0; _ < h.length; _++) {
            const b = h[_];
            let _e;
            b.visible = !0,
            b.rotation.set(0, 0, 0),
            b.position.copy(this.worldPosition),
            _e = this.camera.isOrthographicCamera ? (this.camera.top - this.camera.bottom) / this.camera.zoom : this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7),
            b.scale.set(1, 1, 1).multiplyScalar(_e * this.size / 4),
            b.tag !== "helper" ? (b.quaternion.copy(c),
            this.mode === "translate" || this.mode === "scale" ? (b.name === "X" && Math.abs(_alignVector.copy(_unitX).applyQuaternion(c).dot(this.eye)) > .99 && (b.scale.set(1e-10, 1e-10, 1e-10),
            b.visible = !1),
            b.name === "Y" && Math.abs(_alignVector.copy(_unitY).applyQuaternion(c).dot(this.eye)) > .99 && (b.scale.set(1e-10, 1e-10, 1e-10),
            b.visible = !1),
            b.name === "Z" && Math.abs(_alignVector.copy(_unitZ).applyQuaternion(c).dot(this.eye)) > .99 && (b.scale.set(1e-10, 1e-10, 1e-10),
            b.visible = !1),
            b.name === "XY" && Math.abs(_alignVector.copy(_unitZ).applyQuaternion(c).dot(this.eye)) < .2 && (b.scale.set(1e-10, 1e-10, 1e-10),
            b.visible = !1),
            b.name === "YZ" && Math.abs(_alignVector.copy(_unitX).applyQuaternion(c).dot(this.eye)) < .2 && (b.scale.set(1e-10, 1e-10, 1e-10),
            b.visible = !1),
            b.name === "XZ" && Math.abs(_alignVector.copy(_unitY).applyQuaternion(c).dot(this.eye)) < .2 && (b.scale.set(1e-10, 1e-10, 1e-10),
            b.visible = !1)) : this.mode === "rotate" && (_tempQuaternion2.copy(c),
            _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(c).invert()),
            b.name.search("E") !== -1 && b.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY)),
            b.name === "X" && (_tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z)),
            _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion),
            b.quaternion.copy(_tempQuaternion)),
            b.name === "Y" && (_tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z)),
            _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion),
            b.quaternion.copy(_tempQuaternion)),
            b.name === "Z" && (_tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x)),
            _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion),
            b.quaternion.copy(_tempQuaternion))),
            b.visible = b.visible && (b.name.indexOf("X") === -1 || this.showX),
            b.visible = b.visible && (b.name.indexOf("Y") === -1 || this.showY),
            b.visible = b.visible && (b.name.indexOf("Z") === -1 || this.showZ),
            b.visible = b.visible && (b.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ),
            b.material._color = b.material._color || b.material.color.clone(),
            b.material._opacity = b.material._opacity || b.material.opacity,
            b.material.color.copy(b.material._color),
            b.material.opacity = b.material._opacity,
            this.enabled && this.axis && (b.name === this.axis || this.axis.split("").some(function(nt) {
                return b.name === nt
            })) && (b.material.__color && b.material.color.setHex(b.material.__color),
            b.material.opacity = 1)) : (b.visible = !1,
            b.name === "AXIS" ? (b.visible = !!this.axis,
            this.axis === "X" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0)),
            b.quaternion.copy(c).multiply(_tempQuaternion),
            Math.abs(_alignVector.copy(_unitX).applyQuaternion(c).dot(this.eye)) > .9 && (b.visible = !1)),
            this.axis === "Y" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2)),
            b.quaternion.copy(c).multiply(_tempQuaternion),
            Math.abs(_alignVector.copy(_unitY).applyQuaternion(c).dot(this.eye)) > .9 && (b.visible = !1)),
            this.axis === "Z" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0)),
            b.quaternion.copy(c).multiply(_tempQuaternion),
            Math.abs(_alignVector.copy(_unitZ).applyQuaternion(c).dot(this.eye)) > .9 && (b.visible = !1)),
            this.axis === "XYZE" && (_tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0)),
            _alignVector.copy(this.rotationAxis),
            b.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY)),
            b.quaternion.multiply(_tempQuaternion),
            b.visible = this.dragging),
            this.axis === "E" && (b.visible = !1)) : b.name === "START" ? (b.position.copy(this.worldPositionStart),
            b.visible = this.dragging) : b.name === "END" ? (b.position.copy(this.worldPosition),
            b.visible = this.dragging) : b.name === "DELTA" ? (b.position.copy(this.worldPositionStart),
            b.quaternion.copy(this.worldQuaternionStart),
            _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),
            _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert()),
            b.scale.copy(_tempVector),
            b.visible = this.dragging) : (b.quaternion.copy(c),
            this.dragging ? b.position.copy(this.worldPositionStart) : b.position.copy(this.worldPosition),
            this.axis && (b.visible = this.axis.search(b.name) !== -1)))
        }
        super.updateMatrixWorld(o)
    }
}
class TransformControlsPlane extends three_module.eaF {
    constructor() {
        super(new three_module.bdM(1e5,1e5,2,2), new TransformControls.ObjectConstructors.MeshBasicMaterial({
            visible: !1,
            wireframe: !0,
            side: three_module.$EB,
            transparent: !0,
            opacity: .1,
            toneMapped: !1
        })),
        this.isTransformControlsPlane = !0,
        this.type = "TransformControlsPlane"
    }
    updateMatrixWorld(o) {
        let c = this.space;
        switch (this.position.copy(this.worldPosition),
        this.mode === "scale" && (c = "local"),
        TransformControls_v1.copy(_unitX).applyQuaternion(c === "local" ? this.worldQuaternion : _identityQuaternion),
        TransformControls_v2.copy(_unitY).applyQuaternion(c === "local" ? this.worldQuaternion : _identityQuaternion),
        _v3.copy(_unitZ).applyQuaternion(c === "local" ? this.worldQuaternion : _identityQuaternion),
        _alignVector.copy(TransformControls_v2),
        this.mode) {
        case "translate":
        case "scale":
            switch (this.axis) {
            case "X":
                _alignVector.copy(this.eye).cross(TransformControls_v1),
                _dirVector.copy(TransformControls_v1).cross(_alignVector);
                break;
            case "Y":
                _alignVector.copy(this.eye).cross(TransformControls_v2),
                _dirVector.copy(TransformControls_v2).cross(_alignVector);
                break;
            case "Z":
                _alignVector.copy(this.eye).cross(_v3),
                _dirVector.copy(_v3).cross(_alignVector);
                break;
            case "XY":
                _dirVector.copy(_v3);
                break;
            case "YZ":
                _dirVector.copy(TransformControls_v1);
                break;
            case "XZ":
                _alignVector.copy(_v3),
                _dirVector.copy(TransformControls_v2);
                break;
            case "XYZ":
            case "E":
                _dirVector.set(0, 0, 0)
            }
            break;
        default:
            _dirVector.set(0, 0, 0)
        }
        _dirVector.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (_tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector),
        this.quaternion.setFromRotationMatrix(_tempMatrix)),
        super.updateMatrixWorld(o)
    }
}
var TransformControls2_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let TransformControls2 = class extends TransformControls {
    setDirty(d) {
        this.dispatchEvent({
            ...d,
            type: "objectUpdate",
            object: this
        })
    }
    refreshUi() {
        var d, o;
        (o = (d = this.uiConfig) === null || d === void 0 ? void 0 : d.uiRefresh) === null || o === void 0 || o.call(d, "postFrame", !0, 1)
    }
    _keyDownListener(d) {
        if (this.enabled && this.object && !d.metaKey && !d.ctrlKey) {
            switch (d.code) {
            case "KeyQ":
                this.space = this.space === "local" ? "world" : "local";
                break;
            case "ShiftLeft":
                this.translationSnap = .5,
                this.rotationSnap = three_module.cj9.degToRad(15),
                this.scaleSnap = .25;
                break;
            case "KeyW":
                this.mode = "translate";
                break;
            case "KeyE":
                this.mode = "rotate";
                break;
            case "KeyR":
                this.mode = "scale";
                break;
            case "Equal":
            case "NumpadAdd":
            case "Plus":
                this.size = this.size + .1;
                break;
            case "Minus":
            case "NumpadSubtract":
            case "Underscore":
                this.size = Math.max(this.size - .1, .1);
                break;
            case "KeyX":
                this.showX = !this.showX;
                break;
            case "KeyY":
                this.showY = !this.showY;
                break;
            case "KeyZ":
                this.showZ = !this.showZ;
                break;
            case "Space":
                this.enabled = !this.enabled;
                break;
            default:
                return
            }
            this.setDirty({
                refreshScene: !0,
                frameFade: !0
            })
        }
    }
    _keyUpListener(d) {
        this.enabled && (d.code === "ShiftLeft" && (this.translationSnap = null,
        this.rotationSnap = null,
        this.scaleSnap = null),
        this.object && d.code)
    }
    constructor(d, o) {
        super(d, o),
        this.isWidget = !0,
        setupIModel(this),
        this.visible = !1,
        this.userData.bboxVisible = !1,
        this.size = 2,
        this.addEventListener("objectChange", () => {
            var c;
            (c = this.object) === null || c === void 0 || c.setDirty({
                fadeFrame: !1
            })
        }
        ),
        this.addEventListener("change", () => {
            this.setDirty({
                fadeFrame: !1
            })
        }
        ),
        this._keyUpListener = this._keyUpListener.bind(this),
        this._keyDownListener = this._keyDownListener.bind(this),
        window.addEventListener("keydown", this._keyDownListener),
        window.addEventListener("keyup", this._keyUpListener)
    }
    dispose() {
        window.removeEventListener("keydown", this._keyDownListener),
        window.removeEventListener("keyup", this._keyUpListener),
        super.dispose()
    }
    get modelObject() {
        return this
    }
}
;
TransformControls2_decorate([uiDropdown("Mode", ["translate", "rotate", "scale"].map(d => ({
    label: d
})))], TransformControls2.prototype, "mode", void 0),
TransformControls2_decorate([uiDropdown("Space", ["world", "local"].map(d => ({
    label: d
})))], TransformControls2.prototype, "space", void 0),
TransformControls2_decorate([uiSlider("Size", [.1, 10], .1)], TransformControls2.prototype, "size", void 0),
TransformControls2_decorate([uiToggle("Show X")], TransformControls2.prototype, "showX", void 0),
TransformControls2_decorate([uiToggle("Show Y")], TransformControls2.prototype, "showY", void 0),
TransformControls2_decorate([uiToggle("Show Z")], TransformControls2.prototype, "showZ", void 0),
TransformControls2 = TransformControls2_decorate([uiFolder("Transform Controls")], TransformControls2);
class CanvasRecorder extends I$2 {
    _setOptions(o) {
        var c, h;
        Object.assign(this._options, o),
        this._options.mimeType && this._options.mimeType !== "auto" || (this._options.mimeType = (c = CanvasRecorder.GetSupportedMimeTypes([], ["h264"], !0)) !== null && c !== void 0 ? c : CanvasRecorder.GetSupportedMimeTypes(void 0, void 0, !0)),
        this._options.mimeType && !(!((h = this._options.mimeType) === null || h === void 0) && h.startsWith("video/")) || window.MediaRecorder || (this._console.warn("MediaRecorder is not supported, switching to png"),
        this._options.mimeType = "image/png"),
        this._options.mimeType || console.warn(new Error("No supported mimetype found"))
    }
    setOptions(o) {
        this._setOptions(o)
    }
    constructor(o, c) {
        super(),
        this._state = "stopped",
        this._console = console,
        this._currentRecording = [],
        this._currentImages = [],
        this.stepMode = !1,
        this._resumeSyncTime = 0,
        this._frameCount = 0,
        this._onstop = _ => {
            var b;
            if (this._state = "stopped",
            this._recorder && this._currentRecording.length > 0) {
                const _e = new Blob(this._currentRecording,{
                    type: this._options.mimeType
                });
                (b = this._recordingCallback) === null || b === void 0 || b.call(this, _e)
            } else
                this._currentImages.length > 0 && (this._writeImages([...this._currentImages]),
                this._currentImages = []);
            this._recorder = void 0,
            this.dispatchEvent({
                type: "stop"
            })
        }
        ,
        this._onstart = _ => {
            var b;
            this._state = "recording",
            this._frameCount = 0,
            this.dispatchEvent({
                type: "start"
            }),
            this.stepMode && ((b = this._recorder) === null || b === void 0 || b.pause())
        }
        ,
        this._onresume = _ => {
            if (!this.stepMode)
                return;
            const b = () => {
                var nt;
                this._state === "recording" && ((nt = this._recorder) === null || nt === void 0 || nt.pause())
            }
              , _e = Math.min(this._resumeSyncTime - g(), 0) + 1e3 / this._options.frameRate;
            _e > 0 ? X$2(_e).then(b) : b()
        }
        ,
        this._onpause = _ => {}
        ,
        this._ondataavailable = _ => {
            _.data && _.data.size > 0 && this._currentRecording.push(_.data)
        }
        ,
        this._onerror = _ => {
            this._state = "error",
            this._console.error(_),
            this.dispatchEvent({
                type: "error",
                error: _
            }),
            this._recorder = void 0
        }
        ,
        this._canvas = o;
        const h = c == null ? void 0 : c.mimeType;
        this._options = {
            mimeType: h || "auto",
            frameRate: 30,
            stepMode: !1
        },
        this._setOptions(c || this._options)
    }
    isRecording() {
        return this._state === "recording"
    }
    start() {
        var o, c, h;
        if (this._state === "recording")
            return void this._console.log("Already recording canvas");
        if (this._state === "error" && (this._recorder = void 0,
        this._console.warn("Resetting from error state.")),
        this._recorder)
            return this._state === "paused" ? (this.dispatchEvent({
                type: "starting"
            }),
            void this._recorder.resume()) : void this._console.warn("Canvas recorder unknown state", this._state);
        if (this._state === "paused")
            return this.dispatchEvent({
                type: "starting"
            }),
            void (this._state = "recording");
        const _ = {
            mimeType: this._options.mimeType,
            videoBitsPerSecond: this._options.videoBitsPerSecond
        };
        if (this._currentRecording = [],
        this._currentImages = [],
        this._frameCount = 0,
        (o = _.mimeType) === null || o === void 0 ? void 0 : o.startsWith("video")) {
            if (!window.MediaRecorder)
                return this._console.error("MediaRecorder not supported, use image sequence"),
                void (this._state = "error");
            {
                const b = this._canvas.captureStream(this.stepMode ? 0 : this._options.frameRate)
                  , _e = (c = b.getVideoTracks()) === null || c === void 0 ? void 0 : c[0];
                this._track = _e,
                this._recorder = new window.MediaRecorder(b,_),
                this._recorder.onstop = this._onstop,
                this._recorder.ondataavailable = this._ondataavailable,
                this._recorder.onerror = this._onerror,
                this._recorder.onresume = this._onresume,
                this._recorder.onstart = this._onstart
            }
        }
        this.dispatchEvent({
            type: "starting"
        }),
        this._recorder ? (this._state = "recording",
        (h = this._recorder) === null || h === void 0 || h.start()) : window && window.showDirectoryPicker && window.showDirectoryPicker().then(async b => {
            const _e = await (b == null ? void 0 : b.getDirectoryHandle("i-" + Math.floor(Date.now()), {
                create: !0
            }));
            this._imgDirectory = _e,
            this._state = "recording",
            this._onstart({})
        }
        ).catch(b => {
            this._onerror({
                detail: b
            })
        }
        )
    }
    async requestFrame() {
        if (this._state !== "recording")
            return;
        this._frameCount++;
        const o = this._options.mimeType;
        if (!this._recorder && o.startsWith("image/")) {
            const c = this._canvas.toDataURL(o, 90);
            this._currentImages.push(["frame_" + String(this._frameCount).padStart(5, "0") + (o.includes("png") ? ".png" : ".jpg"), c]),
            this._currentImages.length > 60 && (this._writeImages([...this._currentImages]),
            this._currentImages = [])
        }
        this._recorder && this._track && this.stepMode && (this._resumeSyncTime = g(),
        this._track.requestFrame(),
        this._recorder.resume())
    }
    pause() {
        this._state !== "paused" && this._state !== "stopped" && (this._recorder ? this._recorder.pause() : this._state = "paused")
    }
    stop(o) {
        this._state !== "stopped" && (this._state !== "error" ? (this._recordingCallback = o,
        this.dispatchEvent({
            type: "stopping"
        }),
        this._recorder ? this._recorder.stop() : this._onstop({})) : this._console.error("Recorder in error state, cannot stop, call start again."))
    }
    get state() {
        return this._state
    }
    dispose() {
        this._recorder && this._state !== "error" ? this.stop(o => {
            this._console.warn("disposed with blob", o),
            this.dispose()
        }
        ) : this._recorder = void 0
    }
    async _writeImages(o) {
        if (!this._imgDirectory)
            return;
        const c = await Promise.all(o.map(async ([_,b]) => await (await fetch(b)).blob()))
          , h = [];
        for (let _ = 0; _ < o.length; _++) {
            const b = await this._imgDirectory.getFileHandle(o[_][0], {
                create: !0
            });
            h.push($e$1(b, c[_]))
        }
        await Promise.all(h)
    }
    static GetSupportedMimeTypes(o, c, h=!1) {
        if (!window.MediaRecorder)
            return h ? void 0 : [];
        const _ = ["webm", "ogg", "mp4", "x-matroska"].filter(nt => !o || o.length < 1 || o.includes(nt))
          , b = ["vp9", "vp9.0", "vp8", "vp8.0", "avc1", "av1", "h265", "h.265", "h264", "h.264", "opus"].filter(nt => !c || c.length < 1 || c.includes(nt))
          , _e = [];
        return _.forEach(nt => {
            const it = `video/${nt}`;
            b.forEach(at => {
                [`${it};codecs=${at}`, `${it};codecs:${at}`, `${it};codecs=${at.toUpperCase()}`, `${it};codecs:${at.toUpperCase()}`, `${it}`].forEach(ut => {
                    MediaRecorder.isTypeSupported(ut) && _e.push(ut)
                }
                )
            }
            )
        }
        ),
        h ? _e.length > 0 ? _e[0] : void 0 : _e
    }
}
class SphereSelectionWidget extends SelectionWidget {
    constructor() {
        super(),
        this.boundingScaleMultiplier = 1.2,
        this._initGeometry(new three_module.WBB(1,0))
    }
}
function deepAccessObject(d, o, c=!1) {
    for (typeof d == "string" && (d = d.split(".")); d.length > 0; ) {
        if (!o)
            return o;
        const h = d.splice(0, 1)[0];
        if (!(h.length < 1))
            if (Array.isArray(o))
                o = o[parseInt(h)];
            else {
                if (typeof o != "object" || !(h in o)) {
                    if (c)
                        throw new Error("invalid access, check " + h + " in " + o);
                    return
                }
                o = o[h]
            }
    }
    return o
}
function extractAnimationKey(d, o, c) {
    var h, _;
    let b = Array.from(((h = d.access) !== null && h !== void 0 ? h : "").split("."))
      , _e = (_ = d.targetObject) !== null && _ !== void 0 ? _ : o;
    const nt = b.pop();
    if (!nt || nt.length === 0)
        return {
            key: void 0,
            tar: _e
        };
    if ((c = c ?? (o == null ? void 0 : o._animGetters)) && b[0]in c) {
        const it = c[b[0]](b);
        it ? (_e = it.tar,
        b = b.slice(it.i + 1)) : _e = it
    }
    return _e = deepAccessObject(b, _e),
    _e && !(nt in _e) ? (console.error("invalid key", nt, _e, o, d),
    {
        key: void 0,
        tar: _e
    }) : {
        key: nt,
        tar: _e
    }
}
async function animateObject(d, o, c) {
    var h, _, b, _e;
    const {key: nt, tar: it} = extractAnimationKey(o, d)
      , at = o.animSet ? [animateSet(d, o.animSet, c, (h = o.animSetParallel) !== null && h !== void 0 && h)] : [];
    if (nt && it) {
        const ut = (_e = o.updater) !== null && _e !== void 0 ? _e : []
          , pt = async () => animateTarget$1(it, nt, {
            from: o.from,
            to: o.to,
            ease: typeof o.ease == "string" ? EasingFunctions[o.ease] : o.ease,
            duration: o.duration,
            ...o.options,
            onUpdate: ht => {
                var _t, vt;
                (vt = (_t = o.options).onUpdate) === null || vt === void 0 || vt.call(_t, ht),
                ut.forEach(bt => {
                    var St;
                    return (St = c[bt]) === null || St === void 0 ? void 0 : St.call(c)
                }
                )
            }
        }, void 0, !1);
        o.delay ? at.push(X$2(o.delay).then(pt)) : at.push(pt())
    } else
        (o.duration || o.delay) && at.push(X$2(((_ = o.delay) !== null && _ !== void 0 ? _ : 0) + ((b = o.duration) !== null && b !== void 0 ? b : 0)));
    return at.length === 1 ? at[0] : Promise.all(at)
}
async function animationObject_animate(d, o, c) {
    return typeof o.animate == "function" ? o.animate() : animateObject(d, o, c)
}
async function animateSet(d, o, c, h=!1) {
    if (h)
        return Promise.all(o.map(async _ => animationObject_animate(d, _, c)));
    for (const _ of o)
        await animationObject_animate(d, _, c)
}
const encoder = new TextEncoder
  , HOST_SERVICES = {
    appstream2: "appstream",
    cloudhsmv2: "cloudhsm",
    email: "ses",
    marketplace: "aws-marketplace",
    mobile: "AWSMobileHubService",
    pinpoint: "mobiletargeting",
    queue: "sqs",
    "git-codecommit": "codecommit",
    "mturk-requester-sandbox": "mturk-requester",
    "personalize-runtime": "personalize"
}
  , UNSIGNABLE_HEADERS = new Set(["authorization", "content-type", "content-length", "user-agent", "presigned-expires", "expect", "x-amzn-trace-id", "range", "connection"]);
class AwsClient {
    constructor({accessKeyId: o, secretAccessKey: c, sessionToken: h, service: _, region: b, cache: _e, retries: nt, initRetryMs: it}) {
        if (o == null)
            throw new TypeError("accessKeyId is a required option");
        if (c == null)
            throw new TypeError("secretAccessKey is a required option");
        this.accessKeyId = o,
        this.secretAccessKey = c,
        this.sessionToken = h,
        this.service = _,
        this.region = b,
        this.cache = _e || new Map,
        this.retries = nt ?? 10,
        this.initRetryMs = it || 50
    }
    async sign(o, c) {
        if (o instanceof Request) {
            const {method: b, url: _e, headers: nt, body: it} = o;
            (c = Object.assign({
                method: b,
                url: _e,
                headers: nt
            }, c)).body == null && nt.has("Content-Type") && (c.body = it != null && nt.has("X-Amz-Content-Sha256") ? it : await o.clone().arrayBuffer()),
            o = _e
        }
        const h = new AwsV4Signer(Object.assign({
            url: o.toString()
        }, c, this, c && c.aws))
          , _ = Object.assign({}, c, await h.sign());
        delete _.aws;
        try {
            return new Request(_.url.toString(),_)
        } catch (b) {
            if (b instanceof TypeError)
                return new Request(_.url.toString(),Object.assign({
                    duplex: "half"
                }, _));
            throw b
        }
    }
    async fetch(o, c) {
        for (let h = 0; h <= this.retries; h++) {
            const _ = fetch(await this.sign(o, c));
            if (h === this.retries)
                return _;
            const b = await _;
            if (b.status < 500 && b.status !== 429)
                return b;
            await new Promise(_e => setTimeout(_e, Math.random() * this.initRetryMs * Math.pow(2, h)))
        }
        throw new Error("An unknown error occurred, ensure retries is not negative")
    }
}
class AwsV4Signer {
    constructor({method: o, url: c, headers: h, body: _, accessKeyId: b, secretAccessKey: _e, sessionToken: nt, service: it, region: at, cache: ut, datetime: pt, signQuery: ht, appendSessionToken: _t, allHeaders: vt, singleEncode: bt}) {
        if (c == null)
            throw new TypeError("url is a required option");
        if (b == null)
            throw new TypeError("accessKeyId is a required option");
        if (_e == null)
            throw new TypeError("secretAccessKey is a required option");
        let St, At;
        this.method = o || (_ ? "POST" : "GET"),
        this.url = new URL(c),
        this.headers = new Headers(h || {}),
        this.body = _,
        this.accessKeyId = b,
        this.secretAccessKey = _e,
        this.sessionToken = nt,
        it && at || ([St,At] = guessServiceRegion(this.url, this.headers)),
        this.service = it || St || "",
        this.region = at || At || "us-east-1",
        this.cache = ut || new Map,
        this.datetime = pt || new Date().toISOString().replace(/[:-]|\.\d{3}/g, ""),
        this.signQuery = ht,
        this.appendSessionToken = _t || this.service === "iotdevicegateway",
        this.headers.delete("Host"),
        this.service !== "s3" || this.signQuery || this.headers.has("X-Amz-Content-Sha256") || this.headers.set("X-Amz-Content-Sha256", "UNSIGNED-PAYLOAD");
        const Et = this.signQuery ? this.url.searchParams : this.headers;
        if (Et.set("X-Amz-Date", this.datetime),
        this.sessionToken && !this.appendSessionToken && Et.set("X-Amz-Security-Token", this.sessionToken),
        this.signableHeaders = ["host", ...this.headers.keys()].filter(It => vt || !UNSIGNABLE_HEADERS.has(It)).sort(),
        this.signedHeaders = this.signableHeaders.join(";"),
        this.canonicalHeaders = this.signableHeaders.map(It => It + ":" + (It === "host" ? this.url.host : (this.headers.get(It) || "").replace(/\s+/g, " "))).join(`
`),
        this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, "aws4_request"].join("/"),
        this.signQuery && (this.service !== "s3" || Et.has("X-Amz-Expires") || Et.set("X-Amz-Expires", "86400"),
        Et.set("X-Amz-Algorithm", "AWS4-HMAC-SHA256"),
        Et.set("X-Amz-Credential", this.accessKeyId + "/" + this.credentialString),
        Et.set("X-Amz-SignedHeaders", this.signedHeaders)),
        this.service === "s3")
            try {
                this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, " "))
            } catch {
                this.encodedPath = this.url.pathname
            }
        else
            this.encodedPath = this.url.pathname.replace(/\/+/g, "/");
        bt || (this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, "/")),
        this.encodedPath = encodeRfc3986(this.encodedPath);
        const Pt = new Set;
        this.encodedSearch = [...this.url.searchParams].filter( ([It]) => {
            if (!It)
                return !1;
            if (this.service === "s3") {
                if (Pt.has(It))
                    return !1;
                Pt.add(It)
            }
            return !0
        }
        ).map(It => It.map(Dt => encodeRfc3986(encodeURIComponent(Dt)))).sort( ([It,Dt], [Gt,Bt]) => It < Gt ? -1 : It > Gt ? 1 : Dt < Bt ? -1 : Dt > Bt ? 1 : 0).map(It => It.join("=")).join("&")
    }
    async sign() {
        return this.signQuery ? (this.url.searchParams.set("X-Amz-Signature", await this.signature()),
        this.sessionToken && this.appendSessionToken && this.url.searchParams.set("X-Amz-Security-Token", this.sessionToken)) : this.headers.set("Authorization", await this.authHeader()),
        {
            method: this.method,
            url: this.url,
            headers: this.headers,
            body: this.body
        }
    }
    async authHeader() {
        return ["AWS4-HMAC-SHA256 Credential=" + this.accessKeyId + "/" + this.credentialString, "SignedHeaders=" + this.signedHeaders, "Signature=" + await this.signature()].join(", ")
    }
    async signature() {
        const o = this.datetime.slice(0, 8)
          , c = [this.secretAccessKey, o, this.region, this.service].join();
        let h = this.cache.get(c);
        if (!h) {
            const _ = await hmac("AWS4" + this.secretAccessKey, o)
              , b = await hmac(_, this.region)
              , _e = await hmac(b, this.service);
            h = await hmac(_e, "aws4_request"),
            this.cache.set(c, h)
        }
        return buf2hex(await hmac(h, await this.stringToSign()))
    }
    async stringToSign() {
        return ["AWS4-HMAC-SHA256", this.datetime, this.credentialString, buf2hex(await aws4fetch_esm_hash(await this.canonicalString()))].join(`
`)
    }
    async canonicalString() {
        return [this.method.toUpperCase(), this.encodedPath, this.encodedSearch, this.canonicalHeaders + `
`, this.signedHeaders, await this.hexBodyHash()].join(`
`)
    }
    async hexBodyHash() {
        let o = this.headers.get("X-Amz-Content-Sha256") || (this.service === "s3" && this.signQuery ? "UNSIGNED-PAYLOAD" : null);
        if (o == null) {
            if (this.body && typeof this.body != "string" && !("byteLength"in this.body))
                throw new Error("body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header");
            o = buf2hex(await aws4fetch_esm_hash(this.body || ""))
        }
        return o
    }
}
async function hmac(d, o) {
    const c = await crypto.subtle.importKey("raw", typeof d == "string" ? encoder.encode(d) : d, {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, !1, ["sign"]);
    return crypto.subtle.sign("HMAC", c, encoder.encode(o))
}
async function aws4fetch_esm_hash(d) {
    return crypto.subtle.digest("SHA-256", typeof d == "string" ? encoder.encode(d) : d)
}
const HEX_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
function buf2hex(d) {
    const o = new Uint8Array(d);
    let c = "";
    for (let h = 0; h < o.length; h++) {
        const _ = o[h];
        c += HEX_CHARS[_ >>> 4 & 15],
        c += HEX_CHARS[15 & _]
    }
    return c
}
function encodeRfc3986(d) {
    return d.replace(/[!'()*]/g, o => "%" + o.charCodeAt(0).toString(16).toUpperCase())
}
function guessServiceRegion(d, o) {
    const {hostname: c, pathname: h} = d;
    if (c.endsWith(".on.aws")) {
        const nt = c.match(/^[^.]{1,63}\.lambda-url\.([^.]{1,63})\.on\.aws$/);
        return nt != null ? ["lambda", nt[1] || ""] : ["", ""]
    }
    if (c.endsWith(".r2.cloudflarestorage.com"))
        return ["s3", "auto"];
    if (c.endsWith(".backblazeb2.com")) {
        const nt = c.match(/^(?:[^.]{1,63}\.)?s3\.([^.]{1,63})\.backblazeb2\.com$/);
        return nt != null ? ["s3", nt[1] || ""] : ["", ""]
    }
    const _ = c.replace("dualstack.", "").match(/([^.]{1,63})\.(?:([^.]{0,63})\.)?amazonaws\.com(?:\.cn)?$/);
    let b = _ && _[1] || ""
      , _e = _ && _[2];
    if (_e === "us-gov")
        _e = "us-gov-west-1";
    else if (_e === "s3" || _e === "s3-accelerate")
        _e = "us-east-1",
        b = "s3";
    else if (b === "iot")
        b = c.startsWith("iot.") ? "execute-api" : c.startsWith("data.jobs.iot.") ? "iot-jobs-data" : h === "/mqtt" ? "iotdevicegateway" : "iotdata";
    else if (b === "autoscaling") {
        const nt = (o.get("X-Amz-Target") || "").split(".")[0];
        nt === "AnyScaleFrontendService" ? b = "application-autoscaling" : nt === "AnyScaleScalingPlannerFrontendService" && (b = "autoscaling-plans")
    } else
        _e == null && b.startsWith("s3-") ? (_e = b.slice(3).replace(/^fips-|^external-1/, ""),
        b = "s3") : b.endsWith("-fips") ? b = b.slice(0, -5) : _e && /-\d$/.test(b) && !/-\d$/.test(_e) && ([b,_e] = [_e, b]);
    return [HOST_SERVICES[b] || b, _e || ""]
}
var AWSClientPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, AWSClientPlugin_1;
let AWSClientPlugin = AWSClientPlugin_1 = class extends AViewerPlugin {
    constructor() {
        super(),
        this.enabled = !0,
        this._connected = !1,
        this.dependencies = [FileTransferPlugin],
        this.accessKeyId = "",
        this.accessKeySecret = "",
        this.endpointURL = "",
        this.pathPrefix = "webgi",
        this.serializeSettings = !1,
        this.toggleConnection = () => {
            this._connected ? this.disconnect() : this.connect()
        }
        ,
        this.serializeWithViewer = !1,
        this.fetchFunction = fetch
    }
    connect() {
        this._connected && this.disconnect(),
        this._client = new AwsClient({
            accessKeyId: this.accessKeyId,
            secretAccessKey: this.accessKeySecret
        }),
        this._connected = !0,
        this.refreshUi()
    }
    refreshUi() {
        var d, o;
        (o = (d = this.uiConfig) === null || d === void 0 ? void 0 : d.uiRefresh) === null || o === void 0 || o.call(d, "postFrame", !0)
    }
    disconnect() {
        this._client = void 0,
        this._connected = !1,
        this.refreshUi()
    }
    get connected() {
        return this._connected
    }
    get client() {
        return this._client
    }
    toJSON(d) {
        return this.serializeSettings ? super.toJSON(d) : {
            type: this.constructor.PluginType
        }
    }
    async onAdded(d) {
        await super.onAdded(d);
        const o = d.getPlugin(FileTransferPlugin);
        o.actions.exportFile = async (c, h, _) => {
            if (!this._connected)
                return void await o.defaultActions.exportFile(c, h);
            const b = ot([this.endpointURL, this.pathPrefix, h])
              , _e = await this.fetch(b, {
                method: "PUT",
                body: c
            }, _);
            if (!_e.ok)
                return d.console.error("Error uploading file", _e),
                void await o.defaultActions.exportFile(c, h);
            this.dispatchEvent({
                type: "fileUpload",
                name: h,
                blob: c,
                response: _e,
                path: b
            }),
            d.console.log("File uploaded", _e)
        }
    }
    async fetch(d, o, c) {
        if (!this._client)
            throw new Error("Not connected");
        for (let h = 0; h <= this._client.retries; h++) {
            const _ = await sign2(this._client, d, o);
            let b = _.url.toString();
            AWSClientPlugin_1.USE_PROXY && b && !b.includes(AWSClientPlugin_1.PROXY_URL) && (b = AWSClientPlugin_1.PROXY_URL.replace("{path}", b));
            const _e = (0,
            this.fetchFunction)(b, _);
            if (h === this._client.retries)
                return _e;
            const nt = await _e;
            if (nt.status < 500 && nt.status !== 429)
                return nt;
            await X$2(Math.random() * this._client.initRetryMs * Math.pow(2, h))
        }
        throw new Error("An unknown error occurred, ensure retries is not negative")
    }
}
;
async function sign2(d, o, c) {
    if (o instanceof Request) {
        const {method: b, url: _e, headers: nt, body: it} = o;
        (c = Object.assign({
            method: b,
            url: _e,
            headers: nt
        }, c)).body == null && nt.has("Content-Type") && (c.body = it != null && nt.has("X-Amz-Content-Sha256") ? it : await o.clone().arrayBuffer()),
        o = _e,
        console.warn("WebGi AWSClientPlugin: There could be a bug in chrome with cloning Request objects, see https://bugs.chromium.org/p/chromium/issues/detail?id=1360943")
    }
    const h = new AwsV4Signer(Object.assign({
        url: o
    }, c, d, c && c.aws))
      , _ = Object.assign({}, c, await h.sign());
    return delete _.aws,
    _
}
AWSClientPlugin.PluginType = "AWSClientPlugin1",
AWSClientPlugin.USE_PROXY = !1,
AWSClientPlugin.PROXY_URL = "https://r2-s3-api.repalash.com/{path}",
AWSClientPlugin_decorate([serialize(), uiInput("Access Key ID", d => ({
    disabled: () => !d.enabled || d._connected
}))], AWSClientPlugin.prototype, "accessKeyId", void 0),
AWSClientPlugin_decorate([serialize(), uiInput("Access Key Secret", d => ({
    disabled: () => !d.enabled || d._connected
}))], AWSClientPlugin.prototype, "accessKeySecret", void 0),
AWSClientPlugin_decorate([serialize(), uiInput("Endpoint URL", d => ({
    disabled: () => !d.enabled || d._connected
}))], AWSClientPlugin.prototype, "endpointURL", void 0),
AWSClientPlugin_decorate([serialize(), uiInput("Path Prefix", d => ({
    disabled: () => !d.enabled
}))], AWSClientPlugin.prototype, "pathPrefix", void 0),
AWSClientPlugin_decorate([serialize(), uiToggle("Remember", d => ({
    disabled: () => !d.enabled || d._connected
}))], AWSClientPlugin.prototype, "serializeSettings", void 0),
AWSClientPlugin_decorate([uiButton(void 0, d => ({
    label: () => d._connected ? "Disconnect" : "Connect"
}))], AWSClientPlugin.prototype, "toggleConnection", void 0),
AWSClientPlugin = AWSClientPlugin_1 = AWSClientPlugin_decorate([uiFolder("S3 Connection")], AWSClientPlugin);
const supportsRequestStreams = ( () => {
    let d = !1
      , o = !1;
    const c = typeof globalThis.ReadableStream == "function"
      , h = typeof globalThis.Request == "function";
    return c && h && (o = new globalThis.Request("https://empty.invalid",{
        body: new globalThis.ReadableStream,
        method: "POST",
        get duplex() {
            return d = !0,
            "half"
        }
    }).headers.has("Content-Type")),
    d && !o
}
)()
  , defaultPresets = {
    Background: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/background",
        assets: ["gradient-radial-dark-blue.svg", "gradient-radial-grey.svg", "gradient-radial-red.svg", "gradient-radial-aqua.svg", "gradient-radial-green.svg", "gradient-radial-white.svg", "gradient-radial-coral.svg", "gradient-radial-fuchsia.svg", "gradient-radial-blue.svg", "gradient-radial-black.svg", "gradient-radial-light-blue.svg", "gradient-radial-gray.svg", "gradient-radial-beige.svg", "gradient-radial-antrasit.svg", "gradient-linear-light-blue.svg", "gradient-linear-gray.svg", "gradient-linear-beige.svg", "gradient-linear-antrasit.svg", "bg-1.jpg", "bg-2.png"].map(d => ({
            path: d
        }))
    }).assets,
    Environment: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment",
        assets: ["env-metal-1.hdr", "env-metal-2.hdr", "env-metal-3.hdr", "env-metal-4.hdr", "env-metal-5.hdr", "env-metal-6.hdr", "env-metal-7.hdr", "env-metal-8.hdr", "env-metal-9.hdr", "env-metal-10.hdr", "env-metal-11.hdr", "env-metal-12.hdr", "env-metal-13.hdr", "env-metal-14.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr", "env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "alps_field_1k.hdr", "paul_lobe_haus_1k.hdr", "derelict_highway_midday_1k.hdr", "neon_photostudio_1k.hdr", "studio_small_08_1k.hdr", "evening_meadow_1k.hdr", "st_peters_square_night_1k.hdr", "studio_small_07_1k.hdr", "moonless_golf_1k.hdr", "satara_night_1k.hdr", "venice_sunset_1k.hdr", "umhlanga_sunrise_1k.hdr", "studio_country_hall_1k.hdr"].map(d => ({
            path: d
        }))
    }).assets,
    GemEnvironment: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment",
        assets: ["env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr"].map(d => ({
            path: d
        }))
    }).assets,
    GemEnvironment2: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment",
        assets: ["env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr"].map(d => ({
            path: d
        }))
    }).assets,
    GemEnvironment3: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/environment",
        assets: ["env-gem-1.hdr", "env-gem-2.hdr", "env-gem-3.exr", "env-gem-4.exr", "env-metal-gem-1.hdr", "env-metal-gem-2.hdr"].map(d => ({
            path: d
        }))
    }).assets,
    Ground: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/ground",
        assets: ["ground-1.json", "ground-2.json", "ground-3.json", "g-1.json", "g-2.json", "g-3.json", "g-4.json", "g-5.json"].map(d => ({
            path: d
        }))
    }).assets,
    CameraViews: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/views",
        assets: ["views-1.json", "views-2.json"].map(d => ({
            path: d
        }))
    }).assets,
    MaterialConfiguration: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/material-conf",
        assets: ["gold-ceramic.json", "gold.json", "metal-diamond.json"].map(d => ({
            path: d
        }))
    }).assets,
    MaterialLibraries: new SimpleAssetList({
        basePath: "https://demo-assets.pixotronics.com/pixo/presets/material-lib",
        assets: ["metal.zip", "gem.zip"].map(d => ({
            path: d
        }))
    }).assets
};
function velocityPerSecond$1(d, o) {
    return o ? d * (1e3 / o) : 0
}
function inertia$1(d) {
    var o, c = d.from, h = c === void 0 ? 0 : c, _ = d.velocity, b = _ === void 0 ? 0 : _, _e = d.min, nt = d.max, it = d.power, at = it === void 0 ? .8 : it, ut = d.timeConstant, pt = ut === void 0 ? 750 : ut, ht = d.bounceStiffness, _t = ht === void 0 ? 500 : ht, vt = d.bounceDamping, bt = vt === void 0 ? 10 : vt, St = d.restDelta, At = St === void 0 ? 1 : St, Et = d.modifyTarget, Pt = d.driver, It = d.onUpdate, Dt = d.onComplete, Gt = d.onStop;
    function Bt(ar) {
        return _e !== void 0 && ar < _e || nt !== void 0 && ar > nt
    }
    function kt(ar) {
        return _e === void 0 ? nt : nt === void 0 || Math.abs(_e - ar) < Math.abs(nt - ar) ? _e : nt
    }
    function Ut(ar) {
        o == null || o.stop(),
        o = animate(__assign(__assign({}, ar), {
            driver: Pt,
            onUpdate: function(hr) {
                var gr;
                It == null || It(hr),
                (gr = ar.onUpdate) === null || gr === void 0 || gr.call(ar, hr)
            },
            onComplete: Dt,
            onStop: Gt
        }))
    }
    function Ht(ar) {
        Ut(__assign({
            type: "spring",
            stiffness: _t,
            damping: bt,
            restDelta: At
        }, ar))
    }
    if (Bt(h))
        Ht({
            from: h,
            velocity: b,
            to: kt(h)
        });
    else {
        var Kt = at * b + h;
        Et !== void 0 && (Kt = Et(Kt));
        var Jt, or, ir = kt(Kt), lr = ir === _e ? -1 : 1;
        Ut({
            type: "decay",
            from: h,
            velocity: b,
            timeConstant: pt,
            power: at,
            restDelta: At,
            modifyTarget: Et,
            onUpdate: Bt(Kt) ? function(ar) {
                Jt = or,
                or = ar,
                b = velocityPerSecond$1(ar - Jt, getFrameData().delta),
                (lr === 1 && ar > ir || lr === -1 && ar < ir) && Ht({
                    from: ar,
                    to: ir,
                    velocity: b
                })
            }
            : void 0
        })
    }
    return {
        stop: function() {
            return o == null ? void 0 : o.stop()
        }
    }
}
var radiansToDegrees = function(d) {
    return 180 * d / Math.PI
}
  , angle = function(d, o) {
    return o === void 0 && (o = zeroPoint),
    radiansToDegrees(Math.atan2(o.y - d.y, o.x - d.x))
}
  , applyOffset = function(d, o) {
    var c = !0;
    return o === void 0 && (o = d,
    c = !1),
    function(h) {
        return c ? h - d + o : (d = h,
        c = !0,
        o)
    }
}
  , identity = function(d) {
    return d
}
  , createAttractor = function(d) {
    return d === void 0 && (d = identity),
    function(o, c, h) {
        var _ = c - h
          , b = -(0 - o + 1) * (0 - d(Math.abs(_)));
        return _ <= 0 ? c + b : c - b
    }
}
  , attract = createAttractor()
  , attractExpo = createAttractor(Math.sqrt)
  , degreesToRadians = function(d) {
    return d * Math.PI / 180
}
  , isPoint = function(d) {
    return d.hasOwnProperty("x") && d.hasOwnProperty("y")
}
  , isPoint3D = function(d) {
    return isPoint(d) && d.hasOwnProperty("z")
}
  , distance1D = function(d, o) {
    return Math.abs(d - o)
};
function distance$1(d, o) {
    if (isNum(d) && isNum(o))
        return distance1D(d, o);
    if (isPoint(d) && isPoint(o)) {
        var c = distance1D(d.x, o.x)
          , h = distance1D(d.y, o.y)
          , _ = isPoint3D(d) && isPoint3D(o) ? distance1D(d.z, o.z) : 0;
        return Math.sqrt(Math.pow(c, 2) + Math.pow(h, 2) + Math.pow(_, 2))
    }
}
var pointFromVector = function(d, o, c) {
    return o = degreesToRadians(o),
    {
        x: c * Math.cos(o) + d.x,
        y: c * Math.sin(o) + d.y
    }
}
  , toDecimal = function(d, o) {
    return o === void 0 && (o = 2),
    o = Math.pow(10, o),
    Math.round(d * o) / o
}
  , smoothFrame = function(d, o, c, h) {
    return h === void 0 && (h = 0),
    toDecimal(d + c * (o - d) / Math.max(h, c))
}
  , smooth = function(d) {
    d === void 0 && (d = 50);
    var o = 0
      , c = 0;
    return function(h) {
        var _ = getFrameData().timestamp
          , b = _ !== c ? _ - c : 0
          , _e = b ? smoothFrame(o, h, b, d) : o;
        return c = _,
        o = _e,
        _e
    }
}
  , snap = function(d) {
    if (typeof d == "number")
        return function(h) {
            return Math.round(h / d) * d
        }
        ;
    var o = 0
      , c = d.length;
    return function(h) {
        var _ = Math.abs(d[0] - h);
        for (o = 1; o < c; o++) {
            var b = d[o]
              , _e = Math.abs(b - h);
            if (_e === 0)
                return b;
            if (_e > _)
                return d[o - 1];
            if (o === c - 1)
                return b;
            _ = _e
        }
    }
};
function velocityPerFrame(d, o) {
    return d / (1e3 / o)
}
var wrap = function(d, o, c) {
    var h = o - d;
    return ((c - d) % h + h) % h + d
}
  , cubic_bezier_a = function(d, o) {
    return 1 - 3 * o + 3 * d
}
  , cubic_bezier_b = function(d, o) {
    return 3 * o - 6 * d
}
  , cubic_bezier_c = function(d) {
    return 3 * d
}
  , calcBezier$1 = function(d, o, c) {
    return ((cubic_bezier_a(o, c) * d + cubic_bezier_b(o, c)) * d + cubic_bezier_c(o)) * d
}
  , getSlope = function(d, o, c) {
    return 3 * cubic_bezier_a(o, c) * d * d + 2 * cubic_bezier_b(o, c) * d + cubic_bezier_c(o)
}
  , subdivisionPrecision$1 = 1e-7
  , subdivisionMaxIterations$1 = 10;
function binarySubdivide$1(d, o, c, h, _) {
    var b, _e, nt = 0;
    do
        (b = calcBezier$1(_e = o + (c - o) / 2, h, _) - d) > 0 ? c = _e : o = _e;
    while (Math.abs(b) > subdivisionPrecision$1 && ++nt < subdivisionMaxIterations$1);
    return _e
}
var newtonIterations = 8
  , newtonMinSlope = .001;
function newtonRaphsonIterate(d, o, c, h) {
    for (var _ = 0; _ < newtonIterations; ++_) {
        var b = getSlope(o, c, h);
        if (b === 0)
            return o;
        o -= (calcBezier$1(o, c, h) - d) / b
    }
    return o
}
var kSplineTableSize = 11
  , kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier$1(d, o, c, h) {
    if (d === o && c === h)
        return linear;
    for (var _ = new Float32Array(kSplineTableSize), b = 0; b < kSplineTableSize; ++b)
        _[b] = calcBezier$1(b * kSampleStepSize, d, c);
    return function(_e) {
        return _e === 0 || _e === 1 ? _e : calcBezier$1(function(nt) {
            for (var it = 0, at = 1, ut = kSplineTableSize - 1; at !== ut && _[at] <= nt; ++at)
                it += kSampleStepSize;
            --at;
            var pt = it + (nt - _[at]) / (_[at + 1] - _[at]) * kSampleStepSize
              , ht = getSlope(pt, d, c);
            return ht >= newtonMinSlope ? newtonRaphsonIterate(nt, pt, d, c) : ht === 0 ? pt : binarySubdivide$1(nt, it, it + kSampleStepSize, d, c)
        }(_e), o, h)
    }
}
var steps_steps = function(d, o) {
    return o === void 0 && (o = "end"),
    function(c) {
        var h = (c = o === "end" ? Math.min(c, .999) : Math.max(c, .001)) * d
          , _ = o === "end" ? Math.floor(h) : Math.ceil(h);
        return clamp$1(0, 1, _ / d)
    }
};
const _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
function generateUUID() {
    const d = 4294967295 * Math.random() | 0
      , o = 4294967295 * Math.random() | 0
      , c = 4294967295 * Math.random() | 0
      , h = 4294967295 * Math.random() | 0;
    return (_lut[255 & d] + _lut[d >> 8 & 255] + _lut[d >> 16 & 255] + _lut[d >> 24 & 255] + "-" + _lut[255 & o] + _lut[o >> 8 & 255] + "-" + _lut[o >> 16 & 15 | 64] + _lut[o >> 24 & 255] + "-" + _lut[63 & c | 128] + _lut[c >> 8 & 255] + "-" + _lut[c >> 16 & 255] + _lut[c >> 24 & 255] + _lut[255 & h] + _lut[h >> 8 & 255] + _lut[h >> 16 & 255] + _lut[h >> 24 & 255]).toLowerCase()
}
var AnimationObjectPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
}, AnimationObject_1;
class AnimationObjectPlugin extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.animation = new AnimationObject( () => this._viewer),
        this.uiConfig = this.animation.uiConfig
    }
    async onAdded(o) {
        function c(h) {
            let _ = ""
              , b = 1;
            for (; b < h.length && (_ += h[b],
            h[b].endsWith("\\")); b++)
                _ = _.slice(0, -1),
                _ += ".";
            return [_, b]
        }
        await super.onAdded(o),
        o._animGetters = {
            objects: h => {
                if (h.length < 2 || !o)
                    return;
                const [_,b] = c(h);
                return {
                    tar: o.scene.getObjectByName(_),
                    i: b
                }
            }
            ,
            materials: h => {
                var _, b, _e;
                if (h.length < 2 || !o)
                    return;
                const [nt,it] = c(h);
                return {
                    tar: (_e = (b = (_ = o.assetManager) === null || _ === void 0 ? void 0 : _.materials) === null || b === void 0 ? void 0 : b.findMaterialsByName(nt)) === null || _e === void 0 ? void 0 : _e[0],
                    i: it
                }
            }
        }
    }
}
AnimationObjectPlugin.PluginType = "AnimationObjectPlugin",
AnimationObjectPlugin_decorate([serialize(), uiConfig()], AnimationObjectPlugin.prototype, "animation", void 0);
let AnimationObject = AnimationObject_1 = class {
    constructor(d) {
        this.target = d,
        this.uuid = generateUUID(),
        this.name = "",
        this.access = "",
        this.options = {},
        this.duration = 1e3,
        this.delay = 0,
        this.repeat = 1,
        this.repeatType = "mirror",
        this.ease = "easeInOutSine",
        this.updater = [],
        this.updateScene = !1,
        this.updateCamera = !1,
        this.updateViewer = !1,
        this.animSetParallel = !1,
        this.animSet = [],
        this.uiConfig = generateUiFolder("Animation Object", this, void 0, "folder", !0)
    }
    _onAccessChanged() {
        const d = Ee$1(this.target)
          , {key: o, tar: c} = extractAnimationKey(this, d);
        if (this.from = void 0,
        this.to = void 0,
        !o || !c)
            return void this.refreshUi();
        const h = c[o];
        if (h == null)
            return void this.refreshUi();
        const _ = () => {
            if (!h)
                return h;
            if (h.isColor)
                return "#" + h.getHexString();
            const b = typeof h.clone == "function" ? h.clone() : typeof h == "object" ? {
                ...h
            } : h;
            return console.log(b),
            b
        }
        ;
        this.from = _(),
        this.to = _(),
        this.refreshUi()
    }
    refreshUi() {
        var d, o;
        (o = (d = this.uiConfig) === null || d === void 0 ? void 0 : d.uiRefresh) === null || o === void 0 || o.call(d, "postFrame", !0, 1)
    }
    add(d) {
        this.animSet.push(d),
        d.parent = this,
        this.refreshUi()
    }
    remove(d) {
        const o = this.animSet.indexOf(d);
        o >= 0 && (this.animSet.splice(o, 1),
        d.parent = void 0,
        this.refreshUi())
    }
    async animate(d=!1) {
        typeof d != "boolean" && (d = !1);
        const o = Ee$1(this.target);
        if (!o)
            return void console.warn("AnimationObject: No viewer");
        d && (this.options.to = this.from,
        this.options.from = this.to),
        this.options.repeatType = this.repeatType,
        this.options.repeat = this.repeat,
        this.updater = [],
        this.updateScene && this.updater.push("scene"),
        this.updateCamera && this.updater.push("camera"),
        this.updateViewer && this.updater.push("viewer"),
        this.animSet.forEach(h => h.target = this.target),
        await animateObject(o, this, {
            viewer: () => o.setDirty(),
            renderer: () => o.renderer.reset(),
            scene: () => {
                o.scene.setDirty()
            }
            ,
            camera: () => o.scene.activeCamera.setDirty()
        }),
        delete this.options.to,
        delete this.options.from
    }
    async animateReverse() {
        await this.animate(!0)
    }
    async removeFromParent2() {
        const d = Ee$1(this.target);
        this.parent && d && await d.confirm(`Delete: Are you sure you want to delete the animation ${this.name}?`) && this.removeFromParent()
    }
    removeFromParent() {
        this.parent && this.parent.remove(this)
    }
    addAnimation() {
        this.add(new AnimationObject_1(this.target))
    }
}
;
AnimationObjectPlugin_decorate([serialize(), uiInput()], AnimationObject.prototype, "name", void 0),
AnimationObjectPlugin_decorate([serialize(), uiInput(), x$1(AnimationObject.prototype._onAccessChanged)], AnimationObject.prototype, "access", void 0),
AnimationObjectPlugin_decorate([uiConfig(), serialize()], AnimationObject.prototype, "from", void 0),
AnimationObjectPlugin_decorate([uiConfig(), serialize()], AnimationObject.prototype, "to", void 0),
AnimationObjectPlugin_decorate([serialize()], AnimationObject.prototype, "options", void 0),
AnimationObjectPlugin_decorate([serialize(), uiSlider(void 0, [0, 1e4], 1, d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "duration", void 0),
AnimationObjectPlugin_decorate([serialize(), uiSlider(void 0, [0, 1e4], 1, d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "delay", void 0),
AnimationObjectPlugin_decorate([serialize(), uiSlider(void 0, [0, 10], 1, d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "repeat", void 0),
AnimationObjectPlugin_decorate([serialize(), uiDropdown("repeatType", ["loop", "reverse", "mirror"].map(d => ({
    label: d
})), d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "repeatType", void 0),
AnimationObjectPlugin_decorate([serialize(), uiDropdown("ease", Object.keys(EasingFunctions).map(d => ({
    label: d
})), d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "ease", void 0),
AnimationObjectPlugin_decorate([serialize(), uiToggle(void 0, d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "updateScene", void 0),
AnimationObjectPlugin_decorate([serialize(), uiToggle(void 0, d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "updateCamera", void 0),
AnimationObjectPlugin_decorate([serialize(), uiToggle(void 0, d => ({
    hidden: () => d.from === void 0
}))], AnimationObject.prototype, "updateViewer", void 0),
AnimationObjectPlugin_decorate([uiButton("Animate")], AnimationObject.prototype, "animate", null),
AnimationObjectPlugin_decorate([uiButton("Animate Reverse")], AnimationObject.prototype, "animateReverse", null),
AnimationObjectPlugin_decorate([uiButton("Delete")], AnimationObject.prototype, "removeFromParent2", null),
AnimationObjectPlugin_decorate([serialize(), uiToggle()], AnimationObject.prototype, "animSetParallel", void 0),
AnimationObjectPlugin_decorate([serialize(), uiConfig()], AnimationObject.prototype, "animSet", void 0),
AnimationObjectPlugin_decorate([uiButton("Add Animation")], AnimationObject.prototype, "addAnimation", null),
AnimationObject = AnimationObject_1 = AnimationObjectPlugin_decorate([serializable("AnimationObject")], AnimationObject);
var GradientSvgPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let GradientSvgPlugin = class extends AViewerPlugin {
    constructor(d=!0) {
        super(),
        this.enabled = !0,
        this.dependencies = [],
        this.options = {
            id: generateUUID(),
            type: "linear",
            gradientUnits: "objectBoundingBox",
            linearOptions: {
                angle: 45,
                x1: 0,
                y1: 0,
                x2: 1,
                y2: 1
            },
            radialOptions: {
                cx: .5,
                cy: .5,
                r: .5,
                fx: .5,
                fy: .5,
                spreadMethod: "pad"
            }
        },
        this.type = "linear",
        this.gradientUnits = "objectBoundingBox",
        this.position1 = new three_module.I9Y(0,0),
        this.position2 = new three_module.I9Y(1,1),
        this.angle = 0,
        this.radius = .5,
        this.center = new three_module.I9Y(.5,.5),
        this.focus = new three_module.I9Y(.5,.5),
        this.spreadMethod = "pad",
        this._svgGradient = new SvgGradient,
        this._needsUpdate = !1,
        this.colors = [new three_module.Q1f(1,1,1), new three_module.Q1f(1,0,0)],
        this.color1 = this.colors[0],
        this.color2 = this.colors[1],
        this.applyToBackground = !1,
        this.autoRefresh = !0,
        this.enabled = d
    }
    _refreshOptions() {
        var d, o, c, h, _, b, _e, nt;
        this.options.type = this.type,
        this.options.gradientUnits = this.gradientUnits,
        this.options.linearOptions = {
            angle: this.angle,
            x1: (d = this.position1) === null || d === void 0 ? void 0 : d.x,
            y1: (o = this.position1) === null || o === void 0 ? void 0 : o.y,
            x2: (c = this.position2) === null || c === void 0 ? void 0 : c.x,
            y2: (h = this.position2) === null || h === void 0 ? void 0 : h.y
        },
        this.options.radialOptions = {
            cx: (_ = this.center) === null || _ === void 0 ? void 0 : _.x,
            cy: (b = this.center) === null || b === void 0 ? void 0 : b.y,
            r: this.radius,
            fx: (_e = this.focus) === null || _e === void 0 ? void 0 : _e.x,
            fy: (nt = this.focus) === null || nt === void 0 ? void 0 : nt.y,
            spreadMethod: this.spreadMethod
        },
        this.setDirty()
    }
    setDirty() {
        this._needsUpdate = !0
    }
    addColor() {
        this.colors.push(new three_module.Q1f),
        this.setDirty()
    }
    refreshSvg() {
        if ((!this.applyToBackground || this._viewer) && (this._refreshOptions(),
        this._needsUpdate = !1,
        this._svgElement = this._svgGradient.get(this.colors, this.options),
        this.applyToBackground)) {
            const d = `
            <svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
            <defs>
            ${this._svgElement.outerHTML}
            </defs>
            <rect width="100%" height="100%" fill="url(#${this.options.id})"/>
            </svg>
            `
              , o = B$2(d)
              , c = new Image;
            c.src = o;
            const h = new three_module.gPd(c);
            c.onload = () => {
                this._svgTexture === h && (this._svgTexture.needsUpdate = !0,
                this._viewer.scene.background = this._svgTexture,
                this._viewer.setDirty())
            }
            ,
            this._svgTexture && this._svgTexture.dispose(),
            this._svgTexture = h
        }
    }
    async onAdded(d) {
        await super.onAdded(d),
        d.addEventListener("postFrame", () => {
            this.enabled && this._needsUpdate && this.autoRefresh && this.refreshSvg()
        }
        )
    }
}
;
GradientSvgPlugin.PluginType = "GradientSvgPlugin",
GradientSvgPlugin_decorate([uiToggle()], GradientSvgPlugin.prototype, "enabled", void 0),
GradientSvgPlugin_decorate([serialize(), uiDropdown("type", ["linear", "radial"].map(d => ({
    label: d
}))), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "type", void 0),
GradientSvgPlugin_decorate([serialize(), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "gradientUnits", void 0),
GradientSvgPlugin_decorate([serialize(), uiVector("position1", [0, 1], .01, d => ({
    hidden: () => d.type !== "linear",
    onChange: () => d._refreshOptions()
})), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "position1", void 0),
GradientSvgPlugin_decorate([serialize(), uiVector("position2", [0, 1], .01, d => ({
    hidden: () => d.type !== "linear",
    onChange: () => d._refreshOptions()
})), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "position2", void 0),
GradientSvgPlugin_decorate([serialize(), uiSlider("angle", [0, 360], 1, d => ({
    hidden: () => d.type !== "linear"
})), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "angle", void 0),
GradientSvgPlugin_decorate([serialize(), uiSlider("radius", [0, 1], .01, d => ({
    hidden: () => d.type !== "radial"
})), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "radius", void 0),
GradientSvgPlugin_decorate([serialize(), uiVector("center", [0, 1], .01, d => ({
    hidden: () => d.type !== "radial",
    onChange: () => d._refreshOptions()
})), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "center", void 0),
GradientSvgPlugin_decorate([serialize(), uiVector("focus", [0, 1], .01, d => ({
    hidden: () => d.type !== "radial",
    onChange: () => d._refreshOptions()
})), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "focus", void 0),
GradientSvgPlugin_decorate([serialize(), x$1(GradientSvgPlugin.prototype._refreshOptions)], GradientSvgPlugin.prototype, "spreadMethod", void 0),
GradientSvgPlugin_decorate([serialize()], GradientSvgPlugin.prototype, "colors", void 0),
GradientSvgPlugin_decorate([uiColor(void 0, d => ({
    onChange: () => d.setDirty()
})), x$1(GradientSvgPlugin.prototype.setDirty)], GradientSvgPlugin.prototype, "color1", void 0),
GradientSvgPlugin_decorate([uiColor(void 0, d => ({
    onChange: () => d.setDirty()
})), x$1(GradientSvgPlugin.prototype.setDirty)], GradientSvgPlugin.prototype, "color2", void 0),
GradientSvgPlugin_decorate([serialize(), uiToggle(), x$1(GradientSvgPlugin.prototype.setDirty)], GradientSvgPlugin.prototype, "applyToBackground", void 0),
GradientSvgPlugin_decorate([uiButton()], GradientSvgPlugin.prototype, "refreshSvg", null),
GradientSvgPlugin_decorate([serialize()], GradientSvgPlugin.prototype, "autoRefresh", void 0),
GradientSvgPlugin = GradientSvgPlugin_decorate([uiFolder("Gradient SVG")], GradientSvgPlugin);
class SvgGradient {
    constructor() {}
    get(o, c) {
        return this.colors = o,
        this.options = c,
        this.createGradient()
    }
    createSvgElement(o) {
        return document.createElementNS("http://www.w3.org/2000/svg", o)
    }
    createColorStop(o, c, h) {
        const _ = this.createSvgElement("stop");
        return _.setAttribute("offset", c / h * 100 + "%"),
        _.setAttribute("stop-color", o),
        _
    }
    colorsToStops() {
        const o = this.colors;
        return o.map( (c, h) => {
            const _ = c.getStyle();
            return this.createColorStop(_, h, o.length)
        }
        )
    }
    createGradientElement() {
        const o = this.options
          , c = this.createSvgElement(`${o.type}Gradient`)
          , h = /((id)|([c|f|x|y|r][x|y|1|2]?)|(gradientUnits))/
          , _ = o[`${o.type}Options`]
          , b = {
            id: o.id,
            type: o.type,
            gradientUnits: o.gradientUnits,
            ..._
        };
        return Object.entries(b).filter(_e => h.test(_e[0])).forEach(_e => {
            _e[0] !== "type" && c.setAttribute(_e[0], _e[1])
        }
        ),
        b.angle && c.setAttribute("gradientTransform", `rotate(${b.angle})`),
        c
    }
    createGradient() {
        const o = this.createGradientElement();
        return this.colorsToStops().forEach(c => o.appendChild(c)),
        o
    }
}
var TransformControlsPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
class TransformControlsPlugin extends AViewerPlugin {
    setDirty() {
        var o, c;
        if (!this._viewer)
            return;
        const h = this._viewer.getPlugin(PickingPlugin)
          , _ = this.enabled;
        _ && h.widgetEnabled ? (h.enableWidget(!1),
        this._pickingWidgetDisabled = !0) : !_ && this._pickingWidgetDisabled && (h.enableWidget(!0),
        this._pickingWidgetDisabled = !1),
        this.transformControls && (_ && h.getSelectedObject() ? this.transformControls.attach(h.getSelectedObject()) : this.transformControls.detach()),
        this._viewer.setDirty(),
        (c = (o = this.uiConfig) === null || o === void 0 ? void 0 : o.uiRefresh) === null || c === void 0 || c.call(o, "postFrame", !0, 1)
    }
    constructor(o=!0) {
        super(),
        this.uiConfig = {
            type: "folder",
            label: "Transform Controls",
            children: [...generateUiConfig(this), () => {
                var c;
                return (c = this.transformControls) === null || c === void 0 ? void 0 : c.uiConfig
            }
            ]
        },
        this.enabled = !0,
        this._pickingWidgetDisabled = !1,
        this.toJSON = void 0,
        this.dependencies = [PickingPlugin],
        this._isInteracting = !1,
        this._transformState = {
            obj: null,
            position: new three_module.Pq0,
            rotation: new three_module.O9p,
            scale: new three_module.Pq0
        },
        this._activeCameraChange = () => {
            this.transformControls && this._viewer && (this.transformControls.camera = this._viewer.scene.activeCamera.cameraObject)
        }
        ,
        TransformControls.ObjectConstructors.MeshBasicMaterial = MeshBasicMaterial2,
        this.enabled = o
    }
    get undoManager() {
        var o, c;
        return (c = (o = this._viewer) === null || o === void 0 ? void 0 : o.getPlugin(TweakpaneUiPlugin)) === null || c === void 0 ? void 0 : c.undoManager
    }
    async onAdded(o) {
        await super.onAdded(o),
        this.setDirty(),
        this.transformControls = new TransformControls2(o.scene.activeCamera.cameraObject,o.canvas),
        this._activeCameraChange = this._activeCameraChange.bind(this),
        o.scene.addEventListener("activeCameraChange", this._activeCameraChange),
        this.transformControls.addEventListener("dragging-changed", c => {
            if (!(this != null && this._viewer))
                return;
            const h = this._viewer.scene.activeCamera.controls;
            typeof (h == null ? void 0 : h.stopDamping) == "function" && (h != null && h.enabled) && h.stopDamping(),
            this._viewer.scene.activeCamera.setInteractions(!c.value, TransformControlsPlugin.PluginType)
        }
        ),
        this.transformControls.addEventListener("axis-changed", c => {
            if (!(this != null && this._viewer))
                return;
            this._isInteracting = !!c.value;
            const h = this._viewer.scene.activeCamera.controls;
            typeof (h == null ? void 0 : h.stopDamping) == "function" && (h != null && h.enabled) && h.stopDamping(),
            this._viewer.setDirty()
        }
        ),
        o.scene.addSceneObject(this.transformControls, {
            addToRoot: !0
        }),
        o.getPlugin(PickingPlugin).addEventListener("selectedObjectChanged", c => {
            this.transformControls && (this.enabled ? c.object ? this.transformControls.attach(c.object) : this.transformControls.detach() : this.transformControls.object && this.transformControls.detach())
        }
        ),
        this.transformControls.addEventListener("mouseDown", () => {
            if (!this.transformControls)
                return;
            const c = this.transformControls.object;
            c && (this._transformState.obj = c,
            this._transformState.position = c.position.clone(),
            this._transformState.rotation = c.rotation.clone(),
            this._transformState.scale = c.scale.clone())
        }
        ),
        this.transformControls.addEventListener("mouseUp", () => {
            if (!this.transformControls)
                return;
            const c = this.transformControls.object;
            if (!c || this._transformState.obj !== c || !this.undoManager)
                return;
            const h = {
                translate: "position",
                rotate: "rotation",
                scale: "scale"
            }[this.transformControls.getMode()];
            if (!h || this._transformState[h].equals(c[h]))
                return;
            const _ = {
                last: this._transformState[h].clone(),
                current: c[h].clone(),
                set: b => {
                    var _e, nt;
                    c[h].copy(b),
                    c.updateMatrixWorld(!0),
                    (_e = this.transformControls) === null || _e === void 0 || _e.dispatchEvent({
                        type: "change"
                    }),
                    (nt = this.transformControls) === null || nt === void 0 || nt.dispatchEvent({
                        type: "objectChange"
                    })
                }
                ,
                undo: () => _.set(_.last),
                redo: () => _.set(_.current)
            };
            this.undoManager.record(_)
        }
        )
    }
    async onRemove(o) {
        o.scene.removeEventListener("activeCameraChange", this._activeCameraChange),
        this.transformControls && (this.transformControls.detach(),
        o.scene.remove(this.transformControls),
        this.transformControls.dispose()),
        this.transformControls = void 0,
        await super.onRemove(o)
    }
}
TransformControlsPlugin.PluginType = "TransformControlsPlugin",
TransformControlsPlugin_decorate([uiToggle(), x$1(TransformControlsPlugin.prototype.setDirty)], TransformControlsPlugin.prototype, "enabled", void 0);
var WatchHandsPlugin_decorate = function(d, o, c, h) {
    var _, b = arguments.length, _e = b < 3 ? o : h === null ? h = Object.getOwnPropertyDescriptor(o, c) : h;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        _e = Reflect.decorate(d, o, c, h);
    else
        for (var nt = d.length - 1; nt >= 0; nt--)
            (_ = d[nt]) && (_e = (b < 3 ? _(_e) : b > 3 ? _(o, c, _e) : _(o, c)) || _e);
    return b > 3 && _e && Object.defineProperty(o, c, _e),
    _e
};
let WatchHandsPlugin = class extends AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.dependencies = [],
        this.axis = "y",
        this.invertAxis = !1,
        this.analog = !0,
        this.hourOffset = 0,
        this.minuteOffset = 0,
        this.secondOffset = 0,
        this.hour = ".*hour.*",
        this.minute = ".*minute.*",
        this.second = ".*second.*",
        this.regex = !0,
        this.hands = [],
        this._lastEnabled = !0,
        this._preFrame = () => {
            var d, o, c, h;
            if (!this.enabled) {
                if (this._lastEnabled) {
                    if (this._lastEnabled = !1,
                    !this.hands.length)
                        return;
                    for (const at of this.hands)
                        at.object.rotation.fromArray(at.object.userData.initRotation),
                        at.object.updateMatrixWorld();
                    (d = this._viewer) === null || d === void 0 || d.renderer.resetShadows(),
                    (o = this._viewer) === null || o === void 0 || o.setDirty()
                }
                return
            }
            if (this._lastEnabled = !0,
            !this.hands.length)
                return;
            const _ = new Date
              , b = this.invertAxis ? -1 : 1
              , _e = b * (_.getSeconds() + (this.analog ? _.getMilliseconds() / 1e3 : 0) - this.secondOffset) * (2 * Math.PI) / 60
              , nt = b * (_.getMinutes() - this.minuteOffset) * (2 * Math.PI) / 60 + _e / 60
              , it = b * (_.getHours() - this.hourOffset) * (2 * Math.PI) / 12 + nt / 12;
            if (this.hands.find(at => at.type === "second" && Math.abs(_e - at.object.rotation[this.axis]) > .001)) {
                for (const at of this.hands)
                    at.type === "second" && (at.object.rotation[this.axis] = _e),
                    at.type === "minute" && (at.object.rotation[this.axis] = nt),
                    at.type === "hour" && (at.object.rotation[this.axis] = it);
                (c = this._viewer) === null || c === void 0 || c.renderer.resetShadows(),
                (h = this._viewer) === null || h === void 0 || h.setDirty()
            }
        }
        ,
        this._addSceneObject = async d => {
            const o = d.object;
            o && o.modelObject && this.refresh()
        }
    }
    async onAdded(d) {
        await super.onAdded(d),
        d.scene.addEventListener("addSceneObject", this._addSceneObject),
        d.addEventListener("preFrame", this._preFrame)
    }
    async onRemove(d) {
        await super.onRemove(d),
        d.scene.removeEventListener("addSceneObject", this._addSceneObject),
        d.removeEventListener("preFrame", this._preFrame)
    }
    refresh() {
        var d;
        this.hands = [],
        (d = this.viewer) === null || d === void 0 || d.scene.modelRoot.traverse(o => {
            let c = !1;
            o.traverseAncestors(h => {
                c || this.hands.find(_ => _.object === h) && (c = !0)
            }
            ),
            c || (o.name.match(this.regex ? new RegExp(this.hour) : this.hour) && (o.userData.initRotation || (o.userData.initRotation = o.rotation.toArray()),
            this.hands.push({
                type: "hour",
                object: o
            })),
            o.name.match(this.regex ? new RegExp(this.minute) : this.minute) && (o.userData.initRotation || (o.userData.initRotation = o.rotation.toArray()),
            this.hands.push({
                type: "minute",
                object: o
            })),
            o.name.match(this.regex ? new RegExp(this.second) : this.second) && (o.userData.initRotation || (o.userData.initRotation = o.rotation.toArray()),
            this.hands.push({
                type: "second",
                object: o
            })))
        }
        )
    }
}
;
WatchHandsPlugin.PluginType = "WatchHandsPlugin",
WatchHandsPlugin_decorate([uiToggle(), serialize()], WatchHandsPlugin.prototype, "enabled", void 0),
WatchHandsPlugin_decorate([uiDropdown(void 0, ["x", "y", "z"].map(d => ({
    label: d
}))), serialize()], WatchHandsPlugin.prototype, "axis", void 0),
WatchHandsPlugin_decorate([uiToggle(), serialize()], WatchHandsPlugin.prototype, "invertAxis", void 0),
WatchHandsPlugin_decorate([uiToggle(), serialize()], WatchHandsPlugin.prototype, "analog", void 0),
WatchHandsPlugin_decorate([uiSlider(void 0, [0, 12], .001), serialize()], WatchHandsPlugin.prototype, "hourOffset", void 0),
WatchHandsPlugin_decorate([uiSlider(void 0, [0, 60], .001), serialize()], WatchHandsPlugin.prototype, "minuteOffset", void 0),
WatchHandsPlugin_decorate([uiSlider(void 0, [0, 60], .001), serialize()], WatchHandsPlugin.prototype, "secondOffset", void 0),
WatchHandsPlugin_decorate([uiInput(), serialize()], WatchHandsPlugin.prototype, "hour", void 0),
WatchHandsPlugin_decorate([uiInput(), serialize()], WatchHandsPlugin.prototype, "minute", void 0),
WatchHandsPlugin_decorate([uiInput(), serialize()], WatchHandsPlugin.prototype, "second", void 0),
WatchHandsPlugin_decorate([uiToggle(), x$1("refresh"), serialize()], WatchHandsPlugin.prototype, "regex", void 0),
WatchHandsPlugin_decorate([uiButton()], WatchHandsPlugin.prototype, "refresh", null),
WatchHandsPlugin = WatchHandsPlugin_decorate([uiFolder("Watch Hands Time")], WatchHandsPlugin);
class CoreEditorApp extends ViewerApp {
    get editorInitialized() {
        return this._editorInitialized
    }
    constructor(o) {
        super(o),
        this._editorInitialized = !1,
        this.defaultModes = [{
            title: "Viewer",
            plugins: [RendererUiPlugin, CameraUiPlugin, PresetLibraryPlugin, DropzonePlugin]
        }, {
            title: "Picking",
            plugins: [HierarchyUiPlugin, PickingPlugin, TransformControlsPlugin, DiamondPlugin, MaterialLibraryPlugin, XAtlasPlugin, Object3DWidgetsPlugin]
        }, {
            title: "Scene",
            plugins: [SimpleBackgroundEnvUiPlugin, GroundPlugin, SimpleViewerUi, LightsUiPlugin, SceneCamerasUiPlugin, RandomizedDirectionalLightPlugin, HDRiGroundPlugin, ContactShadowGroundPlugin, GeometryGeneratorPlugin, GradientSvgPlugin]
        }, {
            title: "Anti-aliasing",
            plugins: [ProgressivePlugin, TemporalAAPlugin, VelocityBufferPlugin]
        }, {
            title: "Post Processing",
            plugins: [TonemapPlugin, OutlinePlugin, LUTPlugin, ChromaticAberrationPlugin, FilmicGrainPlugin, VignettePlugin, SSRPlugin, SSAOPlugin, BloomPlugin, DepthOfFieldPlugin, SSGIPlugin, SSContactShadows, SSBevelPlugin]
        }, {
            title: "Export",
            plugins: [AssetExporterPlugin, CanvasSnipperPlugin, CanvasRecorderPlugin, AWSClientPlugin, TransfrSharePlugin]
        }, {
            title: "Animations",
            plugins: [GLTFAnimationPlugin, CameraViewPlugin, AnimationObjectPlugin, ScrollableCameraViewPreviewPlugin, CannonPhysicsPlugin, PosePlugin]
        }, {
            title: "Modifiers",
            plugins: [ObjectRotationPlugin, ShapeTubeExtrudePlugin, SimpleTextPlugin, ParallaxMappingPlugin, CSGPluginBSP, CSGPluginBVH, ParallaxCameraControllerPlugin, MeshOptSimplifyModifierPlugin]
        }, {
            title: "Configurators",
            plugins: [SwitchNodePlugin, MaterialConfiguratorPlugin, GLTFKHRMaterialVariantsPlugin, VariationConfiguratorEditorUiPlugin]
        }, {
            title: "Plugins",
            plugins: [InteractionPromptPlugin, AnisotropyPlugin, FullScreenPlugin, CustomBumpMapPlugin, FrameFadePlugin, ClearcoatTintPlugin, ThinFilmLayerPlugin, FragmentClippingExtensionPlugin, NormalBufferPlugin, NoiseBumpMaterialPlugin, LoadingScreenPlugin, CSS3DRendererPlugin, Rhino3dmLoadPlugin, ModelStagePlugin, WatchHandsPlugin]
        }, {
            title: "Extras",
            plugins: [ExtrasUiPlugin, SnowFallPlugin, WaveGroundPlugin, VRPluginBasic, VirtualCamerasPlugin, RainbowDiamondPlugin, BeringRingAnimation]
        }],
        setupModesStyles();
        const c = this.scene.activeCamera.controls;
        c && (c.autoPushTarget2 = !0)
    }
    async setupUi(o, c) {
        await setupModesUi(this, o, c ?? this.defaultModes),
        this._editorInitialized = !0
    }
}
async function addEditorPlugins(d, {debug: o=!1, ground: c=!0, bloom: h=!0, depthTonemap: _=!0, importPopup: b=!0, caching: _e=!0, presetLibrary: nt=!0, switchNode: it=!0, materialConfigurator: at=!0}) {
    d.enabled = !1,
    KTX2LoadPlugin.SAVE_SOURCE_BLOBS = !0,
    o && await d.addPlugin(DebugPlugin),
    d.getPlugin(AssetManagerPlugin) || await d.addPlugin(AssetManagerPlugin, void 0, void 0, {
        storage: _e && window.caches ? await window.caches.open("webgi-cache-storage") : void 0
    }),
    await d.addPlugin(AssetExporterPlugin),
    await d.addPlugin(GLTFDracoExportPlugin),
    await d.addPlugin(GLTFSpecGlossinessConverterPlugin),
    await d.addPlugin(FileTransferPlugin),
    b && ((await d.addPlugin(LoadingScreenPlugin)).isEditor = !0),
    await d.addPlugin(WindowiseDialogPlugin),
    await d.addPlugin(VirtualCamerasPlugin, !1),
    await d.getOrAddPlugin(KTXLoadPlugin),
    await d.addPlugin(PopmotionPlugin),
    await d.getOrAddPlugin(DropzonePlugin),
    await d.addPlugin(CannonPhysicsPlugin),
    await d.addPlugin(TransformAnimationPlugin),
    await d.addPlugin(PickingPlugin, BoxSelectionWidget, !1, !0),
    await d.addPlugin(TransformControlsPlugin, !1),
    await addBasePlugins(d, {
        ground: c,
        bloom: h,
        depthTonemap: _
    }),
    (await d.getOrAddPlugin(FrameFadePlugin)).isEditor = !0,
    nt && await d.getOrAddPlugin(PresetLibraryPlugin),
    await d.getOrAddPlugin(DiamondPlugin),
    await d.addPlugin(OutlinePlugin),
    await d.addPlugin(ParallaxMappingPlugin, !1),
    await d.addPlugin(DeviceOrientationControlsPlugin),
    await d.addPlugin(FirstPersonControlsPlugin),
    await d.addPlugin(PointerLockControlsPlugin),
    await d.addPlugin(TrackballControlsPlugin),
    await d.addPlugin(CSS3DRendererPlugin, !1),
    await d.addPlugin(new ObjectRotationPlugin(!1)),
    await d.addPlugin(ShapeTubeExtrudePlugin),
    await d.addPlugin(SimpleTextPlugin),
    at && ((await d.addPlugin(MaterialConfiguratorPlugin)).enableEditContextMenus = !0),
    it && await d.addPlugin(SwitchNodePlugin),
    await d.addPlugin(VariationConfiguratorEditorUiPlugin),
    await d.addPlugin(MaterialLibraryPlugin),
    await d.addPlugin(CanvasRecorderPlugin),
    await d.addPlugin(CanvasSnipperPlugin),
    await d.addPlugin(HierarchyUiPlugin),
    await d.addPlugin(SimpleViewerUi),
    await d.addPlugin(LightsUiPlugin),
    await d.addPlugin(SceneCamerasUiPlugin),
    await d.addPlugin(RendererUiPlugin),
    await d.addPlugin(CameraUiPlugin),
    await d.addPlugin(SimpleBackgroundEnvUiPlugin),
    await d.addPlugin(Object3DWidgetsPlugin, !1),
    await d.addPlugin(GeometryGeneratorPlugin),
    await d.addPlugin(XAtlasPlugin),
    await d.addPlugin(ScrollableCameraViewPreviewPlugin, d.container, !1),
    await d.addPlugin(AWSClientPlugin),
    await d.addPlugin(RainbowDiamondPlugin),
    await d.addPlugin(TransfrSharePlugin),
    await d.addPlugin(GradientSvgPlugin),
    await d.addPlugin(AnimationObjectPlugin),
    await d.addPlugin(MeshOptSimplifyModifierPlugin),
    await d.addPlugin(SnowFallPlugin),
    await d.addPlugin(WaveGroundPlugin),
    await d.addPlugin(PosePlugin),
    await d.addPlugin(WatchHandsPlugin);
    const ut = await d.addPlugin(new TweakpaneUiPlugin(!we$1()));
    return d.renderer.refreshPipeline(),
    d.scene.addEventListener("textureAdded", pt => {
        pt.texture && d.setEnvironmentMap(pt.texture)
    }
    ),
    ut.setupPluginUi(FullScreenPlugin),
    ut.setupPluginUi(RendererUiPlugin),
    ut.setupPluginUi(CameraUiPlugin),
    ut.setupPluginUi(LoadingScreenPlugin),
    ut.setupPluginUi(DropzonePlugin),
    ut.setupPluginUi(SimpleBackgroundEnvUiPlugin),
    ut.setupPluginUi(AssetExporterPlugin),
    ut.setupPluginUi(GLTFAnimationPlugin),
    ut.setupPluginUi(RandomizedDirectionalLightPlugin),
    it && ut.setupPluginUi(SwitchNodePlugin),
    at && ut.setupPluginUi(MaterialConfiguratorPlugin),
    ut.setupPluginUi(CannonPhysicsPlugin),
    ut.setupPluginUi(HierarchyUiPlugin),
    ut.setupPluginUi(MaterialLibraryPlugin),
    ut.setupPluginUi(DiamondPlugin),
    ut.setupPluginUi(TransformControlsPlugin),
    ut.setupPluginUi(PickingPlugin),
    c && d.getPlugin(GroundPlugin) && ut.setupPluginUi(GroundPlugin),
    c && d.getPlugin(ContactShadowGroundPlugin) && ut.setupPluginUi(ContactShadowGroundPlugin),
    ut.setupPluginUi(SSRPlugin),
    ut.setupPluginUi(CameraViewPlugin),
    ut.setupPluginUi(CanvasRecorderPlugin),
    ut.setupPluginUi(TonemapPlugin),
    ut.setupPluginUi(OutlinePlugin),
    ut.setupPluginUi(ChromaticAberrationPlugin),
    ut.setupPluginUi(FilmicGrainPlugin),
    ut.setupPluginUi(LUTPlugin),
    ut.setupPluginUi(VignettePlugin),
    ut.setupPluginUi(DepthOfFieldPlugin),
    ut.setupPluginUi(SSAOPlugin),
    ut.setupPluginUi(NormalBufferPlugin),
    ut.setupPluginUi(SSBevelPlugin),
    ut.setupPluginUi(SimpleViewerUi),
    ut.setupPluginUi(ObjectRotationPlugin),
    ut.setupPluginUi(ShapeTubeExtrudePlugin),
    ut.setupPluginUi(ProgressivePlugin),
    ut.setupPluginUi(GradientSvgPlugin),
    ut.setupPluginUi(AnimationObjectPlugin),
    ut.setupPluginUi(LightsUiPlugin),
    ut.setupPluginUi(SceneCamerasUiPlugin),
    ut.setupPluginUi(ThinFilmLayerPlugin),
    ut.setupPluginUi(FragmentClippingExtensionPlugin),
    ut.setupPluginUi(NoiseBumpMaterialPlugin),
    h && ut.setupPluginUi(BloomPlugin),
    ut.setupPluginUi(CanvasSnipperPlugin),
    ut.setupPluginUi(AnisotropyPlugin),
    ut.setupPluginUi(TemporalAAPlugin),
    ut.setupPluginUi(HDRiGroundPlugin),
    ut.setupPluginUi(SSGIPlugin),
    ut.setupPluginUi(SSContactShadows),
    ut.setupPluginUi(SimpleTextPlugin),
    ut.setupPluginUi(FrameFadePlugin),
    ut.setupPluginUi(VelocityBufferPlugin),
    ut.setupPluginUi(ModelStagePlugin),
    nt && ut.setupPluginUi(PresetLibraryPlugin),
    ut.setupPluginUi(GLTFKHRMaterialVariantsPlugin),
    ut.setupPluginUi(CustomBumpMapPlugin),
    ut.setupPluginUi(ParallaxMappingPlugin),
    ut.setupPluginUi(CSS3DRendererPlugin),
    ut.setupPluginUi(AWSClientPlugin),
    ut.setupPluginUi(ScrollableCameraViewPreviewPlugin),
    ut.setupPluginUi(XAtlasPlugin),
    ut.setupPluginUi(VariationConfiguratorEditorUiPlugin),
    ut.setupPluginUi(ParallaxCameraControllerPlugin),
    ut.setupPluginUi(Object3DWidgetsPlugin),
    ut.setupPluginUi(Rhino3dmLoadPlugin),
    ut.setupPluginUi(VirtualCamerasPlugin),
    ut.setupPluginUi(GeometryGeneratorPlugin),
    ut.setupPluginUi(InteractionPromptPlugin),
    ut.setupPluginUi(RainbowDiamondPlugin),
    ut.setupPluginUi(TransfrSharePlugin),
    ut.setupPluginUi(MeshOptSimplifyModifierPlugin),
    ut.setupPluginUi(SnowFallPlugin),
    ut.setupPluginUi(WaveGroundPlugin),
    ut.setupPluginUi(PosePlugin),
    ut.setupPluginUi(WatchHandsPlugin),
    d.enabled = !0,
    d
}
async function setupSandboxWebGiEditor(d, {debug: o=!1, ground: c=!0, bloom: h=!0, depthTonemap: _=!0, importPopup: b=!0, caching: _e=!0}) {
    const nt = new ViewerApp(d);
    return await addEditorPlugins(nt, {
        debug: o,
        ground: c,
        bloom: h,
        depthTonemap: _,
        importPopup: b,
        caching: _e
    }),
    nt
}
async function setupCoreWebGiViewer(d, {debug: o=!1, ground: c=!0, bloom: h=!0, depthTonemap: _=!0, importPopup: b=!1, enableDrop: _e=!1, caching: nt=!0}={}) {
    const it = new ViewerApp(d);
    return o && await it.addPlugin(DebugPlugin),
    it.getPlugin(AssetManagerPlugin) || it.addPluginSync(AssetManagerPlugin, void 0, void 0, {
        storage: nt && window.caches ? await caches.open("webgi-cache-storage") : void 0
    }),
    await it.addPlugin(AssetManagerLoadingBarPlugin, !0),
    await addBasePlugins(it, {
        ground: c,
        bloom: h,
        depthTonemap: _,
        enableDrop: _e,
        importPopup: b
    }),
    await it.getOrAddPlugin(DiamondPlugin),
    it
}
var __webpackgi_exports__AAssetManagerProcessStatePlugin = __webpackgi_exports__.CZu
  , __webpackgi_exports__ACESFilmicToneMapping = __webpackgi_exports__.FV
  , __webpackgi_exports__ACameraControlsPlugin = __webpackgi_exports__.oK2
  , __webpackgi_exports__ACanvasRecorder = __webpackgi_exports__.SLH
  , __webpackgi_exports__ALL_WEBGI_EXTENSIONS = __webpackgi_exports__.yo9
  , __webpackgi_exports__AMaterialManager = __webpackgi_exports__.YJd
  , __webpackgi_exports__ARPlacementBox = __webpackgi_exports__.qnC
  , __webpackgi_exports__ARPlugin = __webpackgi_exports__.TtJ
  , __webpackgi_exports__ARTouchInputHelper = __webpackgi_exports__.rUH
  , __webpackgi_exports__AShaderMaterial2 = __webpackgi_exports__.oAs
  , __webpackgi_exports__AViewerPlugin = __webpackgi_exports__.$fV
  , __webpackgi_exports__AWSClientPlugin = __webpackgi_exports__.upe
  , __webpackgi_exports__AddBlendPass = __webpackgi_exports__.yPJ
  , __webpackgi_exports__AddEquation = __webpackgi_exports__.gO9
  , __webpackgi_exports__AddOperation = __webpackgi_exports__.XrR
  , __webpackgi_exports__AdditiveAnimationBlendMode = __webpackgi_exports__.DAe
  , __webpackgi_exports__AdditiveBlending = __webpackgi_exports__.EZo
  , __webpackgi_exports__AlphaFormat = __webpackgi_exports__.wrO
  , __webpackgi_exports__AlwaysCompare = __webpackgi_exports__.FFZ
  , __webpackgi_exports__AlwaysDepth = __webpackgi_exports__.lGu
  , __webpackgi_exports__AlwaysStencilFunc = __webpackgi_exports__.sKt
  , __webpackgi_exports__AmbientLight = __webpackgi_exports__.$p8
  , __webpackgi_exports__AmbientLight2 = __webpackgi_exports__.nJr
  , __webpackgi_exports__AnimationAction = __webpackgi_exports__.pPE
  , __webpackgi_exports__AnimationClip = __webpackgi_exports__.tz3
  , __webpackgi_exports__AnimationLoader = __webpackgi_exports__.kEx
  , __webpackgi_exports__AnimationMixer = __webpackgi_exports__.Iw4
  , __webpackgi_exports__AnimationObjectGroup = __webpackgi_exports__.P5j
  , __webpackgi_exports__AnimationUtils = __webpackgi_exports__.AKb
  , __webpackgi_exports__AnisotropyPlugin = __webpackgi_exports__.GXy
  , __webpackgi_exports__ArcCurve = __webpackgi_exports__.ibB
  , __webpackgi_exports__ArrayCamera = __webpackgi_exports__.nZQ
  , __webpackgi_exports__ArrowHelper = __webpackgi_exports__.E0M
  , __webpackgi_exports__AssetExporter = __webpackgi_exports__.GLG
  , __webpackgi_exports__AssetExporterPlugin = __webpackgi_exports__.$VP
  , __webpackgi_exports__AssetImporter = __webpackgi_exports__.NeI
  , __webpackgi_exports__AssetManagerBasicPopupPlugin = __webpackgi_exports__.rzc
  , __webpackgi_exports__AssetManagerLoadingBarPlugin = __webpackgi_exports__.Kiu
  , __webpackgi_exports__AssetManagerPlugin = __webpackgi_exports__.XDT
  , __webpackgi_exports__AsyncCompress = __webpackgi_exports__.XiN
  , __webpackgi_exports__AsyncDecompress = __webpackgi_exports__._I9
  , __webpackgi_exports__AsyncDeflate = __webpackgi_exports__.ShE
  , __webpackgi_exports__AsyncGunzip = __webpackgi_exports__.OXP
  , __webpackgi_exports__AsyncGzip = __webpackgi_exports__.JZ8
  , __webpackgi_exports__AsyncInflate = __webpackgi_exports__.gS4
  , __webpackgi_exports__AsyncUnzipInflate = __webpackgi_exports__.eFx
  , __webpackgi_exports__AsyncUnzlib = __webpackgi_exports__.peq
  , __webpackgi_exports__AsyncZipDeflate = __webpackgi_exports__.hw0
  , __webpackgi_exports__AsyncZlib = __webpackgi_exports__._DG
  , __webpackgi_exports__Audio = __webpackgi_exports__.fP5
  , __webpackgi_exports__AudioAnalyser = __webpackgi_exports__.CwR
  , __webpackgi_exports__AudioContext = __webpackgi_exports__.UtX
  , __webpackgi_exports__AudioListener = __webpackgi_exports__.Pf$
  , __webpackgi_exports__AudioLoader = __webpackgi_exports__.Am1
  , __webpackgi_exports__AxesHelper = __webpackgi_exports__.IzY
  , __webpackgi_exports__BackSide = __webpackgi_exports__.hsX
  , __webpackgi_exports__BackgroundPresetGroup = __webpackgi_exports__.XFr
  , __webpackgi_exports__BaseGroundPlugin = __webpackgi_exports__.Eh1
  , __webpackgi_exports__BaseRenderer = __webpackgi_exports__.RJS
  , __webpackgi_exports__BasicDepthPacking = __webpackgi_exports__.Rkk
  , __webpackgi_exports__BasicShadowMap = __webpackgi_exports__.bTm
  , __webpackgi_exports__BeringRingAnimation = __webpackgi_exports__.Otl
  , __webpackgi_exports__BlobLoader = __webpackgi_exports__.pOj
  , __webpackgi_exports__BloomPlugin = __webpackgi_exports__.jg0
  , __webpackgi_exports__Bone = __webpackgi_exports__.$Kf
  , __webpackgi_exports__BooleanKeyframeTrack = __webpackgi_exports__.YOZ
  , __webpackgi_exports__Box2 = __webpackgi_exports__.UtB
  , __webpackgi_exports__Box3 = __webpackgi_exports__.NRn
  , __webpackgi_exports__Box3B = __webpackgi_exports__.DYt
  , __webpackgi_exports__Box3Helper = __webpackgi_exports__.BND
  , __webpackgi_exports__BoxGeometry = __webpackgi_exports__.iNn
  , __webpackgi_exports__BoxHelper = __webpackgi_exports__.IWo
  , __webpackgi_exports__BoxSelectionWidget = __webpackgi_exports__.SYd
  , __webpackgi_exports__BufferAttribute = __webpackgi_exports__.THS
  , __webpackgi_exports__BufferGeometry = __webpackgi_exports__.LoY
  , __webpackgi_exports__BufferGeometryLoader = __webpackgi_exports__.SUR
  , __webpackgi_exports__ByteType = __webpackgi_exports__.tJf
  , __webpackgi_exports__CSGPluginBSP = __webpackgi_exports__.Y3u
  , __webpackgi_exports__CSGPluginBVH = __webpackgi_exports__.poD
  , __webpackgi_exports__CSGPluginBase = __webpackgi_exports__.gaG
  , __webpackgi_exports__CSS3DRendererPlugin = __webpackgi_exports__.z0x
  , __webpackgi_exports__Cache = __webpackgi_exports__.l2R
  , __webpackgi_exports__Camera = __webpackgi_exports__.i7d
  , __webpackgi_exports__CameraController = __webpackgi_exports__.mL7
  , __webpackgi_exports__CameraHelper = __webpackgi_exports__.WTh
  , __webpackgi_exports__CameraUiPlugin = __webpackgi_exports__.l5h
  , __webpackgi_exports__CameraView = __webpackgi_exports__.hzv
  , __webpackgi_exports__CameraViewControlPlugin = __webpackgi_exports__.f_U
  , __webpackgi_exports__CameraViewPlugin = __webpackgi_exports__.sxt
  , __webpackgi_exports__CannonPhysicsPlugin = __webpackgi_exports__.af0
  , __webpackgi_exports__CanvasMediaRecorder = __webpackgi_exports__.Phj
  , __webpackgi_exports__CanvasRecorder = __webpackgi_exports__.p5D
  , __webpackgi_exports__CanvasRecorderPlugin = __webpackgi_exports__.CS6
  , __webpackgi_exports__CanvasSnipper = __webpackgi_exports__.aKT
  , __webpackgi_exports__CanvasSnipperPlugin = __webpackgi_exports__.RzO
  , __webpackgi_exports__CanvasTexture = __webpackgi_exports__.GOR
  , __webpackgi_exports__CapsuleGeometry = __webpackgi_exports__.qU7
  , __webpackgi_exports__CatmullRomCurve3 = __webpackgi_exports__.B6O
  , __webpackgi_exports__ChromaticAberrationPlugin = __webpackgi_exports__.z1d
  , __webpackgi_exports__CineonToneMapping = __webpackgi_exports__.nNL
  , __webpackgi_exports__CircleGeometry = __webpackgi_exports__.tcD
  , __webpackgi_exports__ClampToEdgeWrapping = __webpackgi_exports__.ghU
  , __webpackgi_exports__ClearcoatTintPlugin = __webpackgi_exports__.Dk8
  , __webpackgi_exports__Clock = __webpackgi_exports__.zD7
  , __webpackgi_exports__Color = __webpackgi_exports__.Q1f
  , __webpackgi_exports__ColorKeyframeTrack = __webpackgi_exports__.T6I
  , __webpackgi_exports__ColorManagement = __webpackgi_exports__.ppV
  , __webpackgi_exports__CombinedPostPlugin = __webpackgi_exports__.FvD
  , __webpackgi_exports__Compress = __webpackgi_exports__.n3b
  , __webpackgi_exports__CompressedArrayTexture = __webpackgi_exports__.iOZ
  , __webpackgi_exports__CompressedCubeTexture = __webpackgi_exports__.c5h
  , __webpackgi_exports__CompressedTexture = __webpackgi_exports__.YSM
  , __webpackgi_exports__CompressedTextureLoader = __webpackgi_exports__.YRT
  , __webpackgi_exports__ConeGeometry = __webpackgi_exports__.qFE
  , __webpackgi_exports__ContactShadowGroundPlugin = __webpackgi_exports__.fCM
  , __webpackgi_exports__CoreEditorApp = __webpackgi_exports__.afc
  , __webpackgi_exports__CoreViewerApp = __webpackgi_exports__.hLJ
  , __webpackgi_exports__CubeCamera = __webpackgi_exports__.F1T
  , __webpackgi_exports__CubeNormalsCaptureHelper = __webpackgi_exports__.SXA
  , __webpackgi_exports__CubeReflectionMapping = __webpackgi_exports__.hy7
  , __webpackgi_exports__CubeRefractionMapping = __webpackgi_exports__.xFO
  , __webpackgi_exports__CubeTexture = __webpackgi_exports__.b4q
  , __webpackgi_exports__CubeTextureLoader = __webpackgi_exports__.ScU
  , __webpackgi_exports__CubeUVReflectionMapping = __webpackgi_exports__.Om
  , __webpackgi_exports__CubicBezierCurve = __webpackgi_exports__.Z0B
  , __webpackgi_exports__CubicBezierCurve3 = __webpackgi_exports__.s0K
  , __webpackgi_exports__CubicInterpolant = __webpackgi_exports__.Pdi
  , __webpackgi_exports__CullFaceBack = __webpackgi_exports__.Vb5
  , __webpackgi_exports__CullFaceFront = __webpackgi_exports__.Jnc
  , __webpackgi_exports__CullFaceFrontBack = __webpackgi_exports__.ywQ
  , __webpackgi_exports__CullFaceNone = __webpackgi_exports__.WNZ
  , __webpackgi_exports__Curve = __webpackgi_exports__.Ipv
  , __webpackgi_exports__CurvePath = __webpackgi_exports__.jGm
  , __webpackgi_exports__CustomAnimationHelper = __webpackgi_exports__.Ogy
  , __webpackgi_exports__CustomAnimationHelperPlugin = __webpackgi_exports__.xLk
  , __webpackgi_exports__CustomBlending = __webpackgi_exports__.bCz
  , __webpackgi_exports__CustomBumpMapPlugin = __webpackgi_exports__.bGG
  , __webpackgi_exports__CustomToneMapping = __webpackgi_exports__.g7M
  , __webpackgi_exports__CylinderGeometry = __webpackgi_exports__.Ho_
  , __webpackgi_exports__Cylindrical = __webpackgi_exports__.hjs
  , __webpackgi_exports__DRACOLoader2 = __webpackgi_exports__.Zn9
  , __webpackgi_exports__Damper = __webpackgi_exports__.AHf
  , __webpackgi_exports__Data3DTexture = __webpackgi_exports__.dYF
  , __webpackgi_exports__DataArrayTexture = __webpackgi_exports__.rFo
  , __webpackgi_exports__DataTexture = __webpackgi_exports__.GYF
  , __webpackgi_exports__DataTextureLoader = __webpackgi_exports__.BRH
  , __webpackgi_exports__DataUrlLoader = __webpackgi_exports__.psi
  , __webpackgi_exports__DataUtils = __webpackgi_exports__.GxU
  , __webpackgi_exports__DebugPlugin = __webpackgi_exports__.n2t
  , __webpackgi_exports__DecodeUTF8 = __webpackgi_exports__.yuL
  , __webpackgi_exports__Decompress = __webpackgi_exports__.YMq
  , __webpackgi_exports__DecrementStencilOp = __webpackgi_exports__.ROr
  , __webpackgi_exports__DecrementWrapStencilOp = __webpackgi_exports__.fJr
  , __webpackgi_exports__DefaultLoadingManager = __webpackgi_exports__.h_9
  , __webpackgi_exports__Deflate = __webpackgi_exports__.Gyi
  , __webpackgi_exports__DepthFormat = __webpackgi_exports__.zdS
  , __webpackgi_exports__DepthOfFieldPass = __webpackgi_exports__.WCV
  , __webpackgi_exports__DepthOfFieldPlugin = __webpackgi_exports__._Vf
  , __webpackgi_exports__DepthStencilFormat = __webpackgi_exports__.dcC
  , __webpackgi_exports__DepthTexture = __webpackgi_exports__.VCu
  , __webpackgi_exports__DeviceOrientationControls2 = __webpackgi_exports__.n1S
  , __webpackgi_exports__DeviceOrientationControlsPlugin = __webpackgi_exports__.sOF
  , __webpackgi_exports__DiamondMaterial = __webpackgi_exports__.aFP
  , __webpackgi_exports__DiamondPlugin = __webpackgi_exports__.GMU
  , __webpackgi_exports__DirectionalLight = __webpackgi_exports__.ZyN
  , __webpackgi_exports__DirectionalLight2 = __webpackgi_exports__.rFg
  , __webpackgi_exports__DirectionalLightHelper = __webpackgi_exports__.PFK
  , __webpackgi_exports__DiscreteInterpolant = __webpackgi_exports__.Yhb
  , __webpackgi_exports__DisplayP3ColorSpace = __webpackgi_exports__.V5c
  , __webpackgi_exports__DodecahedronGeometry = __webpackgi_exports__.nEu
  , __webpackgi_exports__DoubleSide = __webpackgi_exports__.$EB
  , __webpackgi_exports__Dropzone = __webpackgi_exports__.mRE
  , __webpackgi_exports__DropzonePlugin = __webpackgi_exports__.hSt
  , __webpackgi_exports__DstAlphaFactor = __webpackgi_exports__.hdd
  , __webpackgi_exports__DstColorFactor = __webpackgi_exports__.wn6
  , __webpackgi_exports__DynamicCopyUsage = __webpackgi_exports__.MOq
  , __webpackgi_exports__DynamicDrawUsage = __webpackgi_exports__.Vnu
  , __webpackgi_exports__DynamicReadUsage = __webpackgi_exports__.hIf
  , __webpackgi_exports__EXRExporter2 = __webpackgi_exports__.d5G
  , __webpackgi_exports__EXRLoadPlugin = __webpackgi_exports__.vr8
  , __webpackgi_exports__EasingFunctions = __webpackgi_exports__.JCs
  , __webpackgi_exports__EdgesGeometry = __webpackgi_exports__.TDQ
  , __webpackgi_exports__EffectComposer2 = __webpackgi_exports__.WYq
  , __webpackgi_exports__EllipseCurve = __webpackgi_exports__.S20
  , __webpackgi_exports__EllipseCurve3D = __webpackgi_exports__.LWT
  , __webpackgi_exports__EncodeUTF8 = __webpackgi_exports__.MJ1
  , __webpackgi_exports__EncoderMethod = __webpackgi_exports__.KDW
  , __webpackgi_exports__EnvironmentPresetGroup = __webpackgi_exports__.SQT
  , __webpackgi_exports__EqualCompare = __webpackgi_exports__.kO0
  , __webpackgi_exports__EqualDepth = __webpackgi_exports__.U3G
  , __webpackgi_exports__EqualStencilFunc = __webpackgi_exports__.jsO
  , __webpackgi_exports__EquirectangularReflectionMapping = __webpackgi_exports__.wfO
  , __webpackgi_exports__EquirectangularRefractionMapping = __webpackgi_exports__.uV5
  , __webpackgi_exports__Euler = __webpackgi_exports__.O9p
  , __webpackgi_exports__EventDispatcher = __webpackgi_exports__.Qev
  , __webpackgi_exports__ExtrasUiPlugin = __webpackgi_exports__.j8I
  , __webpackgi_exports__ExtrudeGeometry = __webpackgi_exports__.QCA
  , __webpackgi_exports__FBXLoadPlugin = __webpackgi_exports__.ol2
  , __webpackgi_exports__FFMPEGRecorder = __webpackgi_exports__.y74
  , __webpackgi_exports__FSShadowMaterial = __webpackgi_exports__.lT0
  , __webpackgi_exports__FileLoader = __webpackgi_exports__.Y9S
  , __webpackgi_exports__FileTransferPlugin = __webpackgi_exports__.ryq
  , __webpackgi_exports__FilmicGrainPlugin = __webpackgi_exports__.xcV
  , __webpackgi_exports__FirstPersonControls2 = __webpackgi_exports__.OMG
  , __webpackgi_exports__FirstPersonControlsPlugin = __webpackgi_exports__.Vkg
  , __webpackgi_exports__Float16BufferAttribute = __webpackgi_exports__.Oax
  , __webpackgi_exports__Float32BufferAttribute = __webpackgi_exports__.qtW
  , __webpackgi_exports__Float64BufferAttribute = __webpackgi_exports__.V58
  , __webpackgi_exports__FloatType = __webpackgi_exports__.RQf
  , __webpackgi_exports__Fog = __webpackgi_exports__.jUj
  , __webpackgi_exports__FogExp2 = __webpackgi_exports__.cRK
  , __webpackgi_exports__FragmentClippingExtensionPlugin = __webpackgi_exports__.ziY
  , __webpackgi_exports__FragmentClippingMode = __webpackgi_exports__.kzd
  , __webpackgi_exports__FrameFadePlugin = __webpackgi_exports__.VNy
  , __webpackgi_exports__FramebufferTexture = __webpackgi_exports__.Pem
  , __webpackgi_exports__FrontSide = __webpackgi_exports__.hB5
  , __webpackgi_exports__Frustum = __webpackgi_exports__.PPD
  , __webpackgi_exports__FullScreenPlugin = __webpackgi_exports__.BH6
  , __webpackgi_exports__GBufferPlugin = __webpackgi_exports__.HSI
  , __webpackgi_exports__GLBufferAttribute = __webpackgi_exports__.oh6
  , __webpackgi_exports__GLSL1 = __webpackgi_exports__.Wyr
  , __webpackgi_exports__GLSL3 = __webpackgi_exports__.Wdf
  , __webpackgi_exports__GLTFAnimationPlugin = __webpackgi_exports__.P3V
  , __webpackgi_exports__GLTFDracoExportPlugin = __webpackgi_exports__.s0N
  , __webpackgi_exports__GLTFDracoExporter = __webpackgi_exports__._Js
  , __webpackgi_exports__GLTFExporter2 = __webpackgi_exports__.xQA
  , __webpackgi_exports__GLTFExporterMaterialsVariantsExtensionExport = __webpackgi_exports__.Yeh
  , __webpackgi_exports__GLTFKHRMaterialVariantsPlugin = __webpackgi_exports__.N30
  , __webpackgi_exports__GLTFLoader2 = __webpackgi_exports__.P44
  , __webpackgi_exports__GLTFMaterialsVariantsExtensionImport = __webpackgi_exports__.MdZ
  , __webpackgi_exports__GLTFMeshGpuInstancingExporter = __webpackgi_exports__.Cc9
  , __webpackgi_exports__GLTFMeshOptPlugin = __webpackgi_exports__.HjZ
  , __webpackgi_exports__GLTFSpecGlossinessConverterPlugin = __webpackgi_exports__.UX5
  , __webpackgi_exports__GLTFWriter2 = __webpackgi_exports__.fGP
  , __webpackgi_exports__GammaCorrectionExtension = __webpackgi_exports__.T03
  , __webpackgi_exports__GammaCorrectionPlugin = __webpackgi_exports__.fPK
  , __webpackgi_exports__GemEnvironmentPresetGroup = __webpackgi_exports__.XpU
  , __webpackgi_exports__GenericBlendTexturePass = __webpackgi_exports__.hUz
  , __webpackgi_exports__GenericFilterPlugin = __webpackgi_exports__.pbu
  , __webpackgi_exports__GeometryGeneratorPlugin = __webpackgi_exports__.jhn
  , __webpackgi_exports__GreaterCompare = __webpackgi_exports__.eoi
  , __webpackgi_exports__GreaterDepth = __webpackgi_exports__.K52
  , __webpackgi_exports__GreaterEqualCompare = __webpackgi_exports__.gWB
  , __webpackgi_exports__GreaterEqualDepth = __webpackgi_exports__.Gwm
  , __webpackgi_exports__GreaterEqualStencilFunc = __webpackgi_exports__.TMh
  , __webpackgi_exports__GreaterStencilFunc = __webpackgi_exports__.RcT
  , __webpackgi_exports__GridHelper = __webpackgi_exports__.fTw
  , __webpackgi_exports__GroundPlugin = __webpackgi_exports__.Hx_
  , __webpackgi_exports__Group = __webpackgi_exports__.YJl
  , __webpackgi_exports__Gunzip = __webpackgi_exports__.asK
  , __webpackgi_exports__GyroInputDevice = __webpackgi_exports__._qo
  , __webpackgi_exports__Gzip = __webpackgi_exports__.Ne
  , __webpackgi_exports__HDRiGroundPlugin = __webpackgi_exports__.Guc
  , __webpackgi_exports__HalfFloatType = __webpackgi_exports__.ix0
  , __webpackgi_exports__HemisphereLight = __webpackgi_exports__.dth
  , __webpackgi_exports__HemisphereLightHelper = __webpackgi_exports__.R1W
  , __webpackgi_exports__HierarchyUiPlugin = __webpackgi_exports__.tcR
  , __webpackgi_exports__IcosahedronGeometry = __webpackgi_exports__.WBB
  , __webpackgi_exports__ImageBitmapLoader = __webpackgi_exports__.Kzg
  , __webpackgi_exports__ImageLoader = __webpackgi_exports__.$NF
  , __webpackgi_exports__ImageSequenceRecorder = __webpackgi_exports__.NuM
  , __webpackgi_exports__ImageUtils = __webpackgi_exports__.HgN
  , __webpackgi_exports__Importer = __webpackgi_exports__.l9C
  , __webpackgi_exports__IncrementStencilOp = __webpackgi_exports__.HLH
  , __webpackgi_exports__IncrementWrapStencilOp = __webpackgi_exports__.Ru$
  , __webpackgi_exports__Inflate = __webpackgi_exports__.ELl
  , __webpackgi_exports__InstancedBufferAttribute = __webpackgi_exports__.uWO
  , __webpackgi_exports__InstancedBufferGeometry = __webpackgi_exports__.CmU
  , __webpackgi_exports__InstancedInterleavedBuffer = __webpackgi_exports__.LuO
  , __webpackgi_exports__InstancedMesh = __webpackgi_exports__.ZLX
  , __webpackgi_exports__Int16BufferAttribute = __webpackgi_exports__.Hrb
  , __webpackgi_exports__Int32BufferAttribute = __webpackgi_exports__.vmz
  , __webpackgi_exports__Int8BufferAttribute = __webpackgi_exports__.wvS
  , __webpackgi_exports__IntType = __webpackgi_exports__.Yuy
  , __webpackgi_exports__InteractionPromptPlugin = __webpackgi_exports__.K5h
  , __webpackgi_exports__InterleavedBuffer = __webpackgi_exports__.eB$
  , __webpackgi_exports__InterleavedBufferAttribute = __webpackgi_exports__.eHs
  , __webpackgi_exports__Interpolant = __webpackgi_exports__.lGw
  , __webpackgi_exports__InterpolateDiscrete = __webpackgi_exports__.ljd
  , __webpackgi_exports__InterpolateLinear = __webpackgi_exports__.PJ3
  , __webpackgi_exports__InterpolateSmooth = __webpackgi_exports__.EQC
  , __webpackgi_exports__InvertStencilOp = __webpackgi_exports__.oVO
  , __webpackgi_exports__KHR_TEXTURE_BASISU = __webpackgi_exports__.Yj4
  , __webpackgi_exports__KTX2LoadPlugin = __webpackgi_exports__.ZPL
  , __webpackgi_exports__KTXLoadPlugin = __webpackgi_exports__.$16
  , __webpackgi_exports__KeepStencilOp = __webpackgi_exports__.VVr
  , __webpackgi_exports__KeyframeTrack = __webpackgi_exports__.UJ6
  , __webpackgi_exports__LOD = __webpackgi_exports__.UpK
  , __webpackgi_exports__LUTPlugin = __webpackgi_exports__.ZYb
  , __webpackgi_exports__LatheGeometry = __webpackgi_exports__.nzx
  , __webpackgi_exports__LayeredMaterialPlugin = __webpackgi_exports__.DLJ
  , __webpackgi_exports__Layers = __webpackgi_exports__.zgK
  , __webpackgi_exports__LessCompare = __webpackgi_exports__.vim
  , __webpackgi_exports__LessDepth = __webpackgi_exports__.brA
  , __webpackgi_exports__LessEqualCompare = __webpackgi_exports__.TiK
  , __webpackgi_exports__LessEqualDepth = __webpackgi_exports__.xSv
  , __webpackgi_exports__LessEqualStencilFunc = __webpackgi_exports__.CR7
  , __webpackgi_exports__LessStencilFunc = __webpackgi_exports__.kYr
  , __webpackgi_exports__Light = __webpackgi_exports__.veJ
  , __webpackgi_exports__LightProbe = __webpackgi_exports__.FZo
  , __webpackgi_exports__LightsUiPlugin = __webpackgi_exports__.Dvx
  , __webpackgi_exports__Line = __webpackgi_exports__.N1A
  , __webpackgi_exports__Line2 = __webpackgi_exports__.XkL
  , __webpackgi_exports__Line3 = __webpackgi_exports__.cZY
  , __webpackgi_exports__LineBasicMaterial = __webpackgi_exports__.mrM
  , __webpackgi_exports__LineCurve = __webpackgi_exports__.GZZ
  , __webpackgi_exports__LineCurve3 = __webpackgi_exports__.VnP
  , __webpackgi_exports__LineDashedMaterial = __webpackgi_exports__.Fvt
  , __webpackgi_exports__LineGeometry = __webpackgi_exports__.vK6
  , __webpackgi_exports__LineLoop = __webpackgi_exports__.FCc
  , __webpackgi_exports__LineMaterial = __webpackgi_exports__.GV4
  , __webpackgi_exports__LineSegments = __webpackgi_exports__.DXC
  , __webpackgi_exports__LineSegments2 = __webpackgi_exports__.bFd
  , __webpackgi_exports__LineSegmentsGeometry = __webpackgi_exports__.n31
  , __webpackgi_exports__LinearDisplayP3ColorSpace = __webpackgi_exports__.qIQ
  , __webpackgi_exports__LinearEncoding = __webpackgi_exports__.tgE
  , __webpackgi_exports__LinearFilter = __webpackgi_exports__.k6q
  , __webpackgi_exports__LinearInterpolant = __webpackgi_exports__.ezk
  , __webpackgi_exports__LinearMipMapLinearFilter = __webpackgi_exports__.NZq
  , __webpackgi_exports__LinearMipMapNearestFilter = __webpackgi_exports__.iUH
  , __webpackgi_exports__LinearMipmapLinearFilter = __webpackgi_exports__.$_I
  , __webpackgi_exports__LinearMipmapNearestFilter = __webpackgi_exports__.kRr
  , __webpackgi_exports__LinearSRGBColorSpace = __webpackgi_exports__.Zr2
  , __webpackgi_exports__LinearToneMapping = __webpackgi_exports__.kyO
  , __webpackgi_exports__LinearTransfer = __webpackgi_exports__.VxR
  , __webpackgi_exports__Loader = __webpackgi_exports__.aHM
  , __webpackgi_exports__LoaderUtils = __webpackgi_exports__.r6x
  , __webpackgi_exports__LoadingManager = __webpackgi_exports__.KPJ
  , __webpackgi_exports__LoadingScreenPlugin = __webpackgi_exports__.O0Q
  , __webpackgi_exports__LoopOnce = __webpackgi_exports__.G3T
  , __webpackgi_exports__LoopPingPong = __webpackgi_exports__.lc7
  , __webpackgi_exports__LoopRepeat = __webpackgi_exports__.aMy
  , __webpackgi_exports__LuminanceAlphaFormat = __webpackgi_exports__.CMB
  , __webpackgi_exports__LuminanceFormat = __webpackgi_exports__.Kzv
  , __webpackgi_exports__MOUSE = __webpackgi_exports__.kBv
  , __webpackgi_exports__MTLLoader2 = __webpackgi_exports__.T6P
  , __webpackgi_exports__Material = __webpackgi_exports__.imn
  , __webpackgi_exports__MaterialConfiguratorBasePlugin = __webpackgi_exports__.Bhh
  , __webpackgi_exports__MaterialConfiguratorPlugin = __webpackgi_exports__.q$N
  , __webpackgi_exports__MaterialExtender = __webpackgi_exports__.pzC
  , __webpackgi_exports__MaterialLibPresetGroupPresetGroup = __webpackgi_exports__.xbg
  , __webpackgi_exports__MaterialLibraryBasePlugin = __webpackgi_exports__.LTv
  , __webpackgi_exports__MaterialLibraryPlugin = __webpackgi_exports__.usO
  , __webpackgi_exports__MaterialLoader = __webpackgi_exports__.jut
  , __webpackgi_exports__MaterialManager = __webpackgi_exports__.Jxy
  , __webpackgi_exports__MaterialPresetPlugin = __webpackgi_exports__.Kmw
  , __webpackgi_exports__MaterialPreviewGenerator = __webpackgi_exports__.jR8
  , __webpackgi_exports__MathUtils = __webpackgi_exports__.cj9
  , __webpackgi_exports__Matrix3 = __webpackgi_exports__.dwI
  , __webpackgi_exports__Matrix4 = __webpackgi_exports__.kn4
  , __webpackgi_exports__MaxEquation = __webpackgi_exports__.$ei
  , __webpackgi_exports__Mesh = __webpackgi_exports__.eaF
  , __webpackgi_exports__MeshBasicMaterial = __webpackgi_exports__.V9B
  , __webpackgi_exports__MeshBasicMaterial2 = __webpackgi_exports__.NLY
  , __webpackgi_exports__MeshDepthMaterial = __webpackgi_exports__.CSG
  , __webpackgi_exports__MeshDistanceMaterial = __webpackgi_exports__.aVO
  , __webpackgi_exports__MeshLambertMaterial = __webpackgi_exports__.G_z
  , __webpackgi_exports__MeshMatcapMaterial = __webpackgi_exports__.FNr
  , __webpackgi_exports__MeshNormalMaterial = __webpackgi_exports__.qBx
  , __webpackgi_exports__MeshOptSimplifyModifierPlugin = __webpackgi_exports__.onB
  , __webpackgi_exports__MeshPhongMaterial = __webpackgi_exports__.tXL
  , __webpackgi_exports__MeshPhysicalMaterial = __webpackgi_exports__.uSd
  , __webpackgi_exports__MeshStandardMaterial = __webpackgi_exports__._4j
  , __webpackgi_exports__MeshStandardMaterial2 = __webpackgi_exports__.gCR
  , __webpackgi_exports__MeshToonMaterial = __webpackgi_exports__.Df
  , __webpackgi_exports__MinEquation = __webpackgi_exports__.znC
  , __webpackgi_exports__MirroredRepeatWrapping = __webpackgi_exports__.kTW
  , __webpackgi_exports__MixOperation = __webpackgi_exports__.KRh
  , __webpackgi_exports__ModelStagePlugin = __webpackgi_exports__.$iG
  , __webpackgi_exports__ModelStagePresetGroup = __webpackgi_exports__.eti
  , __webpackgi_exports__MouseInputDevice = __webpackgi_exports__.Um5
  , __webpackgi_exports__MultiFilterPlugin = __webpackgi_exports__.tF0
  , __webpackgi_exports__MultiplyBlending = __webpackgi_exports__.EdD
  , __webpackgi_exports__MultiplyOperation = __webpackgi_exports__.caT
  , __webpackgi_exports__NearestFilter = __webpackgi_exports__.hxR
  , __webpackgi_exports__NearestMipMapLinearFilter = __webpackgi_exports__.a$r
  , __webpackgi_exports__NearestMipMapNearestFilter = __webpackgi_exports__.$O9
  , __webpackgi_exports__NearestMipmapLinearFilter = __webpackgi_exports__.Cfg
  , __webpackgi_exports__NearestMipmapNearestFilter = __webpackgi_exports__.pHI
  , __webpackgi_exports__NeverCompare = __webpackgi_exports__.amv
  , __webpackgi_exports__NeverDepth = __webpackgi_exports__.eHc
  , __webpackgi_exports__NeverStencilFunc = __webpackgi_exports__.HPb
  , __webpackgi_exports__NoBlending = __webpackgi_exports__.XIg
  , __webpackgi_exports__NoColorSpace = __webpackgi_exports__.jf0
  , __webpackgi_exports__NoToneMapping = __webpackgi_exports__.y_p
  , __webpackgi_exports__NoiseBumpMaterialPlugin = __webpackgi_exports__.dFv
  , __webpackgi_exports__NormalAnimationBlendMode = __webpackgi_exports__.Ke9
  , __webpackgi_exports__NormalBlending = __webpackgi_exports__.NTi
  , __webpackgi_exports__NormalBufferPlugin = __webpackgi_exports__.nqf
  , __webpackgi_exports__NormalCaptureMaterial = __webpackgi_exports__.hws
  , __webpackgi_exports__NotEqualCompare = __webpackgi_exports__.jzd
  , __webpackgi_exports__NotEqualDepth = __webpackgi_exports__.bw0
  , __webpackgi_exports__NotEqualStencilFunc = __webpackgi_exports__.klZ
  , __webpackgi_exports__NumberKeyframeTrack = __webpackgi_exports__.Hit
  , __webpackgi_exports__OBJLoader2 = __webpackgi_exports__.DJz
  , __webpackgi_exports__ObjMtlLoadPlugin = __webpackgi_exports__.UwE
  , __webpackgi_exports__Object3D = __webpackgi_exports__.B69
  , __webpackgi_exports__Object3DModel = __webpackgi_exports__.QA8
  , __webpackgi_exports__Object3DWidgetsPlugin = __webpackgi_exports__.$xz
  , __webpackgi_exports__ObjectLoader = __webpackgi_exports__.XTe
  , __webpackgi_exports__ObjectLoader2 = __webpackgi_exports__.zjB
  , __webpackgi_exports__ObjectPicker = __webpackgi_exports__.sHL
  , __webpackgi_exports__ObjectProcessorMap = __webpackgi_exports__.Upe
  , __webpackgi_exports__ObjectRotationPlugin = __webpackgi_exports__.nEH
  , __webpackgi_exports__ObjectSpaceNormalMap = __webpackgi_exports__.vyJ
  , __webpackgi_exports__OctahedronGeometry = __webpackgi_exports__.Ufg
  , __webpackgi_exports__OneFactor = __webpackgi_exports__.qad
  , __webpackgi_exports__OneMinusDstAlphaFactor = __webpackgi_exports__.Nt7
  , __webpackgi_exports__OneMinusDstColorFactor = __webpackgi_exports__.aEY
  , __webpackgi_exports__OneMinusSrcAlphaFactor = __webpackgi_exports__.OuU
  , __webpackgi_exports__OneMinusSrcColorFactor = __webpackgi_exports__.LiQ
  , __webpackgi_exports__OrbitControls2 = __webpackgi_exports__.xYO
  , __webpackgi_exports__OrbitControls3 = __webpackgi_exports__.c07
  , __webpackgi_exports__OrthographicCamera = __webpackgi_exports__.qUd
  , __webpackgi_exports__OutlinePlugin = __webpackgi_exports__.I_i
  , __webpackgi_exports__P3Primaries = __webpackgi_exports__.wqq
  , __webpackgi_exports__PCFShadowMap = __webpackgi_exports__.QP0
  , __webpackgi_exports__PCFSoftShadowMap = __webpackgi_exports__.Wk7
  , __webpackgi_exports__PMREMGenerator = __webpackgi_exports__.BdL
  , __webpackgi_exports__PMREMGeneratorPlugin = __webpackgi_exports__.Q7O
  , __webpackgi_exports__ParallaxCameraControllerPlugin = __webpackgi_exports__.uxM
  , __webpackgi_exports__ParallaxMappingPlugin = __webpackgi_exports__.N9C
  , __webpackgi_exports__Path = __webpackgi_exports__.wAk
  , __webpackgi_exports__PerspectiveCamera = __webpackgi_exports__.ubm
  , __webpackgi_exports__PickingPlugin = __webpackgi_exports__.PG6
  , __webpackgi_exports__Plane = __webpackgi_exports__.Zcv
  , __webpackgi_exports__PlaneGeometry = __webpackgi_exports__.bdM
  , __webpackgi_exports__PlaneHelper = __webpackgi_exports__.ZM4
  , __webpackgi_exports__PluginPresetGroup = __webpackgi_exports__._EQ
  , __webpackgi_exports__PointLight = __webpackgi_exports__.HiM
  , __webpackgi_exports__PointLight2 = __webpackgi_exports__.RXx
  , __webpackgi_exports__PointLightHelper = __webpackgi_exports__.F1l
  , __webpackgi_exports__PointerDragHelper = __webpackgi_exports__.W_W
  , __webpackgi_exports__PointerLockControls2 = __webpackgi_exports__.FnS
  , __webpackgi_exports__PointerLockControlsPlugin = __webpackgi_exports__.oPt
  , __webpackgi_exports__Points = __webpackgi_exports__.ONl
  , __webpackgi_exports__PointsMaterial = __webpackgi_exports__.BH$
  , __webpackgi_exports__PolarGridHelper = __webpackgi_exports__.hzE
  , __webpackgi_exports__PolyhedronGeometry = __webpackgi_exports__.pFK
  , __webpackgi_exports__PopmotionPlugin = __webpackgi_exports__.j9d
  , __webpackgi_exports__PosePlugin = __webpackgi_exports__.DeC
  , __webpackgi_exports__PositionalAudio = __webpackgi_exports__.xZx
  , __webpackgi_exports__PresetGroup = __webpackgi_exports__.ZaL
  , __webpackgi_exports__PresetLibraryPlugin = __webpackgi_exports__.UwN
  , __webpackgi_exports__ProgressivePlugin = __webpackgi_exports__.hzf
  , __webpackgi_exports__PropertyBinding = __webpackgi_exports__.Nwf
  , __webpackgi_exports__PropertyMixer = __webpackgi_exports__.N2s
  , __webpackgi_exports__QuadraticBezierCurve = __webpackgi_exports__.dAo
  , __webpackgi_exports__QuadraticBezierCurve3 = __webpackgi_exports__.CV9
  , __webpackgi_exports__Quaternion = __webpackgi_exports__.PTz
  , __webpackgi_exports__QuaternionKeyframeTrack = __webpackgi_exports__.MBL
  , __webpackgi_exports__QuaternionLinearInterpolant = __webpackgi_exports__.GBG
  , __webpackgi_exports__RED_GREEN_RGTC2_Format = __webpackgi_exports__.HO_
  , __webpackgi_exports__RED_RGTC1_Format = __webpackgi_exports__.Kef
  , __webpackgi_exports__REVISION = __webpackgi_exports__.sPf
  , __webpackgi_exports__RGBADepthPacking = __webpackgi_exports__.N5j
  , __webpackgi_exports__RGBAFormat = __webpackgi_exports__.GWd
  , __webpackgi_exports__RGBAIntegerFormat = __webpackgi_exports__.c90
  , __webpackgi_exports__RGBA_ASTC_10x10_Format = __webpackgi_exports__.y3Z
  , __webpackgi_exports__RGBA_ASTC_10x5_Format = __webpackgi_exports__.uB5
  , __webpackgi_exports__RGBA_ASTC_10x6_Format = __webpackgi_exports__.lyL
  , __webpackgi_exports__RGBA_ASTC_10x8_Format = __webpackgi_exports__.bC7
  , __webpackgi_exports__RGBA_ASTC_12x10_Format = __webpackgi_exports__.ojs
  , __webpackgi_exports__RGBA_ASTC_12x12_Format = __webpackgi_exports__.S$4
  , __webpackgi_exports__RGBA_ASTC_4x4_Format = __webpackgi_exports__.qa3
  , __webpackgi_exports__RGBA_ASTC_5x4_Format = __webpackgi_exports__.B_h
  , __webpackgi_exports__RGBA_ASTC_5x5_Format = __webpackgi_exports__.czI
  , __webpackgi_exports__RGBA_ASTC_6x5_Format = __webpackgi_exports__.rSH
  , __webpackgi_exports__RGBA_ASTC_6x6_Format = __webpackgi_exports__.Qrf
  , __webpackgi_exports__RGBA_ASTC_8x5_Format = __webpackgi_exports__.psI
  , __webpackgi_exports__RGBA_ASTC_8x6_Format = __webpackgi_exports__.a5J
  , __webpackgi_exports__RGBA_ASTC_8x8_Format = __webpackgi_exports__._QJ
  , __webpackgi_exports__RGBA_BPTC_Format = __webpackgi_exports__.Fn
  , __webpackgi_exports__RGBA_ETC2_EAC_Format = __webpackgi_exports__.KDk
  , __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format = __webpackgi_exports__.pBf
  , __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format = __webpackgi_exports__.HXV
  , __webpackgi_exports__RGBA_S3TC_DXT1_Format = __webpackgi_exports__.Nz6
  , __webpackgi_exports__RGBA_S3TC_DXT3_Format = __webpackgi_exports__.jR7
  , __webpackgi_exports__RGBA_S3TC_DXT5_Format = __webpackgi_exports__.BXX
  , __webpackgi_exports__RGBM16ColorSpace = __webpackgi_exports__.DAr
  , __webpackgi_exports__RGBM16ColorSpace_ = __webpackgi_exports__.uC4
  , __webpackgi_exports__RGB_BPTC_SIGNED_Format = __webpackgi_exports__.H23
  , __webpackgi_exports__RGB_BPTC_UNSIGNED_Format = __webpackgi_exports__.W9U
  , __webpackgi_exports__RGB_ETC1_Format = __webpackgi_exports__.CVz
  , __webpackgi_exports__RGB_ETC2_Format = __webpackgi_exports__.Riy
  , __webpackgi_exports__RGB_PVRTC_2BPPV1_Format = __webpackgi_exports__.kTp
  , __webpackgi_exports__RGB_PVRTC_4BPPV1_Format = __webpackgi_exports__.k6Q
  , __webpackgi_exports__RGB_S3TC_DXT1_Format = __webpackgi_exports__.IE4
  , __webpackgi_exports__RGFormat = __webpackgi_exports__.paN
  , __webpackgi_exports__RGIntegerFormat = __webpackgi_exports__.TkQ
  , __webpackgi_exports__RainbowDiamondPlugin = __webpackgi_exports__.qa1
  , __webpackgi_exports__RandomizedDirectionalLight = __webpackgi_exports__.EZL
  , __webpackgi_exports__RandomizedDirectionalLightPlugin = __webpackgi_exports__.fMJ
  , __webpackgi_exports__RawShaderMaterial = __webpackgi_exports__.D$Q
  , __webpackgi_exports__Ray = __webpackgi_exports__.RlV
  , __webpackgi_exports__Raycaster = __webpackgi_exports__.tBo
  , __webpackgi_exports__Rec709Primaries = __webpackgi_exports__.z5
  , __webpackgi_exports__RectAreaLight = __webpackgi_exports__.ure
  , __webpackgi_exports__RedFormat = __webpackgi_exports__.VT0
  , __webpackgi_exports__RedIntegerFormat = __webpackgi_exports__.ZQM
  , __webpackgi_exports__Reflector2 = __webpackgi_exports__.TyI
  , __webpackgi_exports__ReinhardToneMapping = __webpackgi_exports__.Mjd
  , __webpackgi_exports__RenderTarget = __webpackgi_exports__.O0B
  , __webpackgi_exports__RendererUiPlugin = __webpackgi_exports__.FZz
  , __webpackgi_exports__RepeatWrapping = __webpackgi_exports__.GJx
  , __webpackgi_exports__ReplaceStencilOp = __webpackgi_exports__.kG0
  , __webpackgi_exports__ReverseSubtractEquation = __webpackgi_exports__.nST
  , __webpackgi_exports__Rhino3dmLoadPlugin = __webpackgi_exports__.AUf
  , __webpackgi_exports__Rhino3dmLoader2 = __webpackgi_exports__.oXQ
  , __webpackgi_exports__RingGeometry = __webpackgi_exports__.rKP
  , __webpackgi_exports__RootScene = __webpackgi_exports__.vMJ
  , __webpackgi_exports__SIGNED_RED_GREEN_RGTC2_Format = __webpackgi_exports__.CWW
  , __webpackgi_exports__SIGNED_RED_RGTC1_Format = __webpackgi_exports__.XG_
  , __webpackgi_exports__SRGBColorSpace = __webpackgi_exports__.er$
  , __webpackgi_exports__SRGBTransfer = __webpackgi_exports__.KLL
  , __webpackgi_exports__SSAOPlugin = __webpackgi_exports__.ye
  , __webpackgi_exports__SSBevelPass = __webpackgi_exports__.czS
  , __webpackgi_exports__SSBevelPlugin = __webpackgi_exports__.UG9
  , __webpackgi_exports__SSContactShadows = __webpackgi_exports__.aJo
  , __webpackgi_exports__SSGIPlugin = __webpackgi_exports__.uC9
  , __webpackgi_exports__SSRPlugin = __webpackgi_exports__.k9M
  , __webpackgi_exports__STLLoadPlugin = __webpackgi_exports__.fRH
  , __webpackgi_exports__Scene = __webpackgi_exports__.Z58
  , __webpackgi_exports__SceneCamerasUiPlugin = __webpackgi_exports__._I4
  , __webpackgi_exports__SceneLoopPlugin = __webpackgi_exports__.Sr
  , __webpackgi_exports__ScrollableCameraViewPlugin = __webpackgi_exports__.zx2
  , __webpackgi_exports__ScrollableCameraViewPreviewPlugin = __webpackgi_exports__.r1V
  , __webpackgi_exports__SelectionWidget = __webpackgi_exports__.tI0
  , __webpackgi_exports__ShaderChunk = __webpackgi_exports__.vxI
  , __webpackgi_exports__ShaderLib = __webpackgi_exports__.zkh
  , __webpackgi_exports__ShaderMaterial = __webpackgi_exports__.BKk
  , __webpackgi_exports__ShaderMaterial2 = __webpackgi_exports__.rNP
  , __webpackgi_exports__ShaderMaterialEncodingSupport = __webpackgi_exports__.DkA
  , __webpackgi_exports__ShaderPass2 = __webpackgi_exports__.rpH
  , __webpackgi_exports__ShadowMapBaker = __webpackgi_exports__.Q4F
  , __webpackgi_exports__ShadowMaterial = __webpackgi_exports__.q2
  , __webpackgi_exports__Shape = __webpackgi_exports__.ypk
  , __webpackgi_exports__ShapeGeometry = __webpackgi_exports__.MSw
  , __webpackgi_exports__ShapePath = __webpackgi_exports__.Ld9
  , __webpackgi_exports__ShapeTubeExtrudePlugin = __webpackgi_exports__.YOp
  , __webpackgi_exports__ShapeUtils = __webpackgi_exports__.xJ6
  , __webpackgi_exports__ShortType = __webpackgi_exports__.fBL
  , __webpackgi_exports__SimpleAssetList = __webpackgi_exports__.XTN
  , __webpackgi_exports__SimpleBackgroundEnvUiPlugin = __webpackgi_exports__.ZXl
  , __webpackgi_exports__SimpleDataSource = __webpackgi_exports__.O9e
  , __webpackgi_exports__SimpleEventDispatcher = __webpackgi_exports__.ILd
  , __webpackgi_exports__SimpleJSONExporter = __webpackgi_exports__.SQN
  , __webpackgi_exports__SimpleJSONLoader = __webpackgi_exports__.GDD
  , __webpackgi_exports__SimpleTextExporter = __webpackgi_exports__.HVh
  , __webpackgi_exports__SimpleTextPlugin = __webpackgi_exports__.X46
  , __webpackgi_exports__SimpleViewerUi = __webpackgi_exports__.hdr
  , __webpackgi_exports__SimplifyModifierPlugin = __webpackgi_exports__.CSJ
  , __webpackgi_exports__Skeleton = __webpackgi_exports__.EAD
  , __webpackgi_exports__SkeletonHelper = __webpackgi_exports__._xc
  , __webpackgi_exports__SkinnedMesh = __webpackgi_exports__.I46
  , __webpackgi_exports__SnowFallPlugin = __webpackgi_exports__.CSm
  , __webpackgi_exports__Source = __webpackgi_exports__.kLi
  , __webpackgi_exports__Sphere = __webpackgi_exports__.iyt
  , __webpackgi_exports__SphereGeometry = __webpackgi_exports__.Gu$
  , __webpackgi_exports__SphereSelectionWidget = __webpackgi_exports__.s6s
  , __webpackgi_exports__Spherical = __webpackgi_exports__.YHV
  , __webpackgi_exports__SphericalHarmonics3 = __webpackgi_exports__.xOk
  , __webpackgi_exports__SplineCurve = __webpackgi_exports__.xfg
  , __webpackgi_exports__SpotLight = __webpackgi_exports__.nCl
  , __webpackgi_exports__SpotLight2 = __webpackgi_exports__.Hs2
  , __webpackgi_exports__SpotLightHelper = __webpackgi_exports__.Fpm
  , __webpackgi_exports__Sprite = __webpackgi_exports__.kxk
  , __webpackgi_exports__SpriteMaterial = __webpackgi_exports__.RoJ
  , __webpackgi_exports__SrcAlphaFactor = __webpackgi_exports__.ie2
  , __webpackgi_exports__SrcAlphaSaturateFactor = __webpackgi_exports__.hgQ
  , __webpackgi_exports__SrcColorFactor = __webpackgi_exports__.f4X
  , __webpackgi_exports__StaticCopyUsage = __webpackgi_exports__.Hrq
  , __webpackgi_exports__StaticDrawUsage = __webpackgi_exports__.agE
  , __webpackgi_exports__StaticReadUsage = __webpackgi_exports__.uXQ
  , __webpackgi_exports__StereoCamera = __webpackgi_exports__.keZ
  , __webpackgi_exports__StreamCopyUsage = __webpackgi_exports__.rOG
  , __webpackgi_exports__StreamDrawUsage = __webpackgi_exports__.Ktl
  , __webpackgi_exports__StreamReadUsage = __webpackgi_exports__.uov
  , __webpackgi_exports__StringKeyframeTrack = __webpackgi_exports__.hZF
  , __webpackgi_exports__SubtractEquation = __webpackgi_exports__.FXf
  , __webpackgi_exports__SubtractiveBlending = __webpackgi_exports__.Kwu
  , __webpackgi_exports__SwitchNodeBasePlugin = __webpackgi_exports__.hv1
  , __webpackgi_exports__SwitchNodePlugin = __webpackgi_exports__.AqU
  , __webpackgi_exports__TOUCH = __webpackgi_exports__.wtR
  , __webpackgi_exports__TYPED_ARRAYS = __webpackgi_exports__.cGs
  , __webpackgi_exports__TangentSpaceNormalMap = __webpackgi_exports__.bI3
  , __webpackgi_exports__TemporalAAPlugin = __webpackgi_exports__.afA
  , __webpackgi_exports__TetrahedronGeometry = __webpackgi_exports__.Zpd
  , __webpackgi_exports__TextSVGOptions = __webpackgi_exports__.gO_
  , __webpackgi_exports__Texture = __webpackgi_exports__.gPd
  , __webpackgi_exports__TextureLoader = __webpackgi_exports__.Tap
  , __webpackgi_exports__ThinFilmLayerPlugin = __webpackgi_exports__.k4W
  , __webpackgi_exports__ThreeMaterialLoader = __webpackgi_exports__.ndu
  , __webpackgi_exports__TonemapPlugin = __webpackgi_exports__.el_
  , __webpackgi_exports__TorusGeometry = __webpackgi_exports__.O3Y
  , __webpackgi_exports__TorusKnotGeometry = __webpackgi_exports__.UPV
  , __webpackgi_exports__TrackballControlsPlugin = __webpackgi_exports__.iu6
  , __webpackgi_exports__TransformAnimationPlugin = __webpackgi_exports__.Ijk
  , __webpackgi_exports__TransformControls = __webpackgi_exports__.ZU6
  , __webpackgi_exports__TransformControls2 = __webpackgi_exports__.XXP
  , __webpackgi_exports__TransformControlsGizmo = __webpackgi_exports__.RQH
  , __webpackgi_exports__TransformControlsPlane = __webpackgi_exports__.tUF
  , __webpackgi_exports__TransfrSharePlugin = __webpackgi_exports__.Tww
  , __webpackgi_exports__Triangle = __webpackgi_exports__.lMl
  , __webpackgi_exports__TriangleFanDrawMode = __webpackgi_exports__.rYR
  , __webpackgi_exports__TriangleStripDrawMode = __webpackgi_exports__.O49
  , __webpackgi_exports__TrianglesDrawMode = __webpackgi_exports__.RJ4
  , __webpackgi_exports__TriplanarUVMappingPlugin = __webpackgi_exports__.CXS
  , __webpackgi_exports__TubeGeometry = __webpackgi_exports__.j6
  , __webpackgi_exports__TubeShapeGeometry = __webpackgi_exports__.G8g
  , __webpackgi_exports__TweakpaneUiPlugin = __webpackgi_exports__.SOP
  , __webpackgi_exports__TweakpaneWrapper = __webpackgi_exports__.e2_
  , __webpackgi_exports__TwoPassDoubleSide = __webpackgi_exports__.GTy
  , __webpackgi_exports__UChartOptions = __webpackgi_exports__.cOZ
  , __webpackgi_exports__UPackOptions = __webpackgi_exports__.XxD
  , __webpackgi_exports__UVMapping = __webpackgi_exports__.UTZ
  , __webpackgi_exports__Uint16BufferAttribute = __webpackgi_exports__.A$4
  , __webpackgi_exports__Uint32BufferAttribute = __webpackgi_exports__.MW4
  , __webpackgi_exports__Uint8BufferAttribute = __webpackgi_exports__.baL
  , __webpackgi_exports__Uint8ClampedBufferAttribute = __webpackgi_exports__.fc6
  , __webpackgi_exports__Uncharted2Tonemapping = __webpackgi_exports__.t7h
  , __webpackgi_exports__Uniform = __webpackgi_exports__.nc$
  , __webpackgi_exports__UniformsGroup = __webpackgi_exports__.dzP
  , __webpackgi_exports__UniformsLib = __webpackgi_exports__.fCn
  , __webpackgi_exports__UniformsUtils = __webpackgi_exports__.LlO
  , __webpackgi_exports__UnsignedByteType = __webpackgi_exports__.OUM
  , __webpackgi_exports__UnsignedInt248Type = __webpackgi_exports__.V3x
  , __webpackgi_exports__UnsignedIntType = __webpackgi_exports__.bkx
  , __webpackgi_exports__UnsignedShort4444Type = __webpackgi_exports__.Wew
  , __webpackgi_exports__UnsignedShort5551Type = __webpackgi_exports__.gJ2
  , __webpackgi_exports__UnsignedShortType = __webpackgi_exports__.cHt
  , __webpackgi_exports__Unzip = __webpackgi_exports__.HJp
  , __webpackgi_exports__UnzipInflate = __webpackgi_exports__.mMi
  , __webpackgi_exports__UnzipPassThrough = __webpackgi_exports__.XLH
  , __webpackgi_exports__Unzlib = __webpackgi_exports__.TWi
  , __webpackgi_exports__VJSONPresetGroup = __webpackgi_exports__.DcJ
  , __webpackgi_exports__VRPluginBasic = __webpackgi_exports__.Kmx
  , __webpackgi_exports__VSMShadowMap = __webpackgi_exports__.RyA
  , __webpackgi_exports__VariationConfiguratorEditorUiPlugin = __webpackgi_exports__.NPD
  , __webpackgi_exports__VariationConfiguratorGridUiPlugin = __webpackgi_exports__.Gpr
  , __webpackgi_exports__VariationConfiguratorPlugin = __webpackgi_exports__.mKI
  , __webpackgi_exports__Vector2 = __webpackgi_exports__.I9Y
  , __webpackgi_exports__Vector3 = __webpackgi_exports__.Pq0
  , __webpackgi_exports__Vector4 = __webpackgi_exports__.IUQ
  , __webpackgi_exports__VectorKeyframeTrack = __webpackgi_exports__.RiT
  , __webpackgi_exports__VelocityBufferPlugin = __webpackgi_exports__.Xkr
  , __webpackgi_exports__VideoTexture = __webpackgi_exports__.Nv2
  , __webpackgi_exports__ViewerApp = __webpackgi_exports__.EW5
  , __webpackgi_exports__ViewerState = __webpackgi_exports__.oJ0
  , __webpackgi_exports__VignettePlugin = __webpackgi_exports__.Q1b
  , __webpackgi_exports__VirtualCamerasPlugin = __webpackgi_exports__.jK_
  , __webpackgi_exports__WaveGroundPlugin = __webpackgi_exports__.gTm
  , __webpackgi_exports__WebGL1Renderer = __webpackgi_exports__.S3G
  , __webpackgi_exports__WebGL3DRenderTarget = __webpackgi_exports__.ALV
  , __webpackgi_exports__WebGLArrayRenderTarget = __webpackgi_exports__.y9J
  , __webpackgi_exports__WebGLCoordinateSystem = __webpackgi_exports__.TdN
  , __webpackgi_exports__WebGLCubeRenderTarget = __webpackgi_exports__.o6l
  , __webpackgi_exports__WebGLMultipleRenderTargets = __webpackgi_exports__.AT1
  , __webpackgi_exports__WebGLRenderTarget = __webpackgi_exports__.nWS
  , __webpackgi_exports__WebGLRenderer = __webpackgi_exports__.JeP
  , __webpackgi_exports__WebGLUtils = __webpackgi_exports__.hfX
  , __webpackgi_exports__WebGPUCoordinateSystem = __webpackgi_exports__.i7u
  , __webpackgi_exports__WebGiViewerElement = __webpackgi_exports__.b5D
  , __webpackgi_exports__WindowiseDialogPlugin = __webpackgi_exports__.Z1R
  , __webpackgi_exports__Wireframe = __webpackgi_exports__.pWZ
  , __webpackgi_exports__WireframeGeometry = __webpackgi_exports__.XJ7
  , __webpackgi_exports__WireframeGeometry2 = __webpackgi_exports__.r3D
  , __webpackgi_exports__WrapAroundEnding = __webpackgi_exports__.dhZ
  , __webpackgi_exports__XAtlasPlugin = __webpackgi_exports__.$Tl
  , __webpackgi_exports__ZeroCurvatureEnding = __webpackgi_exports__.rQf
  , __webpackgi_exports__ZeroFactor = __webpackgi_exports__.ojh
  , __webpackgi_exports__ZeroSlopeEnding = __webpackgi_exports__.h2z
  , __webpackgi_exports__ZeroStencilOp = __webpackgi_exports__.kqe
  , __webpackgi_exports__Zip = __webpackgi_exports__.qQr
  , __webpackgi_exports__ZipDeflate = __webpackgi_exports__.D8L
  , __webpackgi_exports__ZipLoader = __webpackgi_exports__.p9O
  , __webpackgi_exports__ZipPassThrough = __webpackgi_exports__.uZB
  , __webpackgi_exports__Zlib = __webpackgi_exports__.KK
  , __webpackgi_exports___SRGBAFormat = __webpackgi_exports__.Ua6
  , __webpackgi_exports__absMax = __webpackgi_exports__.TYE
  , __webpackgi_exports__addBasePlugins = __webpackgi_exports__.rQr
  , __webpackgi_exports__addBloomData = __webpackgi_exports__.$00
  , __webpackgi_exports__addDracoLoader = __webpackgi_exports__.ued
  , __webpackgi_exports__addEditorPlugins = __webpackgi_exports__.p$A
  , __webpackgi_exports__addGLTFExporter = __webpackgi_exports__.m2A
  , __webpackgi_exports__addGLTFLoader = __webpackgi_exports__.MqB
  , __webpackgi_exports__addLUTData = __webpackgi_exports__.Dv6
  , __webpackgi_exports__addRGBELoader = __webpackgi_exports__.f9i
  , __webpackgi_exports__addSSBevel = __webpackgi_exports__.qHA
  , __webpackgi_exports__aesGcmDecrypt = __webpackgi_exports__.sQz
  , __webpackgi_exports__aesGcmEncrypt = __webpackgi_exports__.G52
  , __webpackgi_exports__afterMain = __webpackgi_exports__.EP1
  , __webpackgi_exports__afterRead = __webpackgi_exports__.v5N
  , __webpackgi_exports__afterWrite = __webpackgi_exports__.SET
  , __webpackgi_exports__angle = __webpackgi_exports__.g7h
  , __webpackgi_exports__animate = __webpackgi_exports__.i0Z
  , __webpackgi_exports__animateAsync = __webpackgi_exports__.GcL
  , __webpackgi_exports__animateObject = __webpackgi_exports__.z67
  , __webpackgi_exports__animateSet = __webpackgi_exports__.im4
  , __webpackgi_exports__animateTarget = __webpackgi_exports__.$bx
  , __webpackgi_exports__anticipate = __webpackgi_exports__.btx
  , __webpackgi_exports__applyOffset = __webpackgi_exports__.M7c
  , __webpackgi_exports__applyStyles = __webpackgi_exports__.ZMO
  , __webpackgi_exports__arrayBufferToBase64 = __webpackgi_exports__.YiG
  , __webpackgi_exports__arrow = __webpackgi_exports__.UE8
  , __webpackgi_exports__attract = __webpackgi_exports__.uHr
  , __webpackgi_exports__attractExpo = __webpackgi_exports__.YYK
  , __webpackgi_exports__auto = __webpackgi_exports__.qZL
  , __webpackgi_exports__autoCenterObject3D = __webpackgi_exports__.XMb
  , __webpackgi_exports__autoGPUInstanceMeshes = __webpackgi_exports__.utC
  , __webpackgi_exports__autoScaleObject3D = __webpackgi_exports__.uO_
  , __webpackgi_exports__backIn = __webpackgi_exports__.dgX
  , __webpackgi_exports__backInOut = __webpackgi_exports__.ZZ5
  , __webpackgi_exports__backOut = __webpackgi_exports__.Szj
  , __webpackgi_exports__base64ToArrayBuffer = __webpackgi_exports__.Ms4
  , __webpackgi_exports__basePlacements = __webpackgi_exports__.OMj
  , __webpackgi_exports__basicMaterialPropList = __webpackgi_exports__.D7g
  , __webpackgi_exports__beforeMain = __webpackgi_exports__.LG_
  , __webpackgi_exports__beforeRead = __webpackgi_exports__.cis
  , __webpackgi_exports__beforeWrite = __webpackgi_exports__.pAB
  , __webpackgi_exports__blobToDataURL = __webpackgi_exports__.y80
  , __webpackgi_exports__bottom = __webpackgi_exports__.sQg
  , __webpackgi_exports__bounceIn = __webpackgi_exports__.ipZ
  , __webpackgi_exports__bounceInOut = __webpackgi_exports__.wmn
  , __webpackgi_exports__bounceOut = __webpackgi_exports__.Tel
  , __webpackgi_exports__buildCSGMeshBSP = __webpackgi_exports__.Q5
  , __webpackgi_exports__buildCSGMeshBVH = __webpackgi_exports__.b1j
  , __webpackgi_exports__cLinearToRGBM = __webpackgi_exports__.wzf
  , __webpackgi_exports__cRGBMToLinear = __webpackgi_exports__.Cq_
  , __webpackgi_exports__circIn = __webpackgi_exports__.poN
  , __webpackgi_exports__circInOut = __webpackgi_exports__.tnX
  , __webpackgi_exports__circOut = __webpackgi_exports__.yT
  , __webpackgi_exports__clamp = __webpackgi_exports__.qE8
  , __webpackgi_exports__clippingParents = __webpackgi_exports__.WYS
  , __webpackgi_exports__colorToDataUrl = __webpackgi_exports__.Cp1
  , __webpackgi_exports__combineDofShader = __webpackgi_exports__.mz1
  , __webpackgi_exports__compress = __webpackgi_exports__.Bc
  , __webpackgi_exports__compressSync = __webpackgi_exports__.oSR
  , __webpackgi_exports__computeAverageGeometryNormal = __webpackgi_exports__.KJu
  , __webpackgi_exports__computeEigenVectors = __webpackgi_exports__.G1I
  , __webpackgi_exports__computeGeometryCenter = __webpackgi_exports__.dXm
  , __webpackgi_exports__computeGeometrySize = __webpackgi_exports__.lRj
  , __webpackgi_exports__computeMikkTSpaceTangents = __webpackgi_exports__.WL9
  , __webpackgi_exports__computeMorphedAttributes = __webpackgi_exports__.OkM
  , __webpackgi_exports__computeOffsetMatrix = __webpackgi_exports__.kRU
  , __webpackgi_exports__computeScreenSpaceBoundingBox = __webpackgi_exports__.Xpo
  , __webpackgi_exports__computeStyles = __webpackgi_exports__.KCp
  , __webpackgi_exports__copyMaterialUserData = __webpackgi_exports__.a17
  , __webpackgi_exports__copyObject3DUserData = __webpackgi_exports__.prl
  , __webpackgi_exports__copyProps = __webpackgi_exports__.ij0
  , __webpackgi_exports__copyTextureUserData = __webpackgi_exports__.MjE
  , __webpackgi_exports__createAnticipate = __webpackgi_exports__.bhJ
  , __webpackgi_exports__createAttractor = __webpackgi_exports__.nMR
  , __webpackgi_exports__createBackIn = __webpackgi_exports__.p4x
  , __webpackgi_exports__createCanvasElement = __webpackgi_exports__.lPF
  , __webpackgi_exports__createDiv = __webpackgi_exports__.SwP
  , __webpackgi_exports__createExpoIn = __webpackgi_exports__.U2C
  , __webpackgi_exports__createGenericExtensionClass = __webpackgi_exports__.FOd
  , __webpackgi_exports__createIFrameCSS3DObject = __webpackgi_exports__.WOM
  , __webpackgi_exports__createImage = __webpackgi_exports__.mFw
  , __webpackgi_exports__createPopper = __webpackgi_exports__.n4h
  , __webpackgi_exports__createPopperBase = __webpackgi_exports__.eRo
  , __webpackgi_exports__createPopperLite = __webpackgi_exports__.LsR
  , __webpackgi_exports__createRenderTargetKey = __webpackgi_exports__.tJ
  , __webpackgi_exports__createScriptFromURL = __webpackgi_exports__.bES
  , __webpackgi_exports__createStyles = __webpackgi_exports__.rU
  , __webpackgi_exports__csgOperations = __webpackgi_exports__.omb
  , __webpackgi_exports__css = __webpackgi_exports__.AHW
  , __webpackgi_exports__cubicBezier = __webpackgi_exports__.AKs
  , __webpackgi_exports__dataTextureFromColor = __webpackgi_exports__.VxZ
  , __webpackgi_exports__dataTextureFromVec4 = __webpackgi_exports__.GRd
  , __webpackgi_exports__decay = __webpackgi_exports__.TVt
  , __webpackgi_exports__decompress = __webpackgi_exports__.mFv
  , __webpackgi_exports__decompressSync = __webpackgi_exports__.RqU
  , __webpackgi_exports__deepAccessObject = __webpackgi_exports__.UKN
  , __webpackgi_exports__deepCloneAttribute = __webpackgi_exports__.mmZ
  , __webpackgi_exports__defaultPresets = __webpackgi_exports__.Ikv
  , __webpackgi_exports__deflate = __webpackgi_exports__.Kcl
  , __webpackgi_exports__deflateSync = __webpackgi_exports__.pdh
  , __webpackgi_exports__degreesToRadians = __webpackgi_exports__.tRv
  , __webpackgi_exports__deinterleaveAttribute = __webpackgi_exports__.nNY
  , __webpackgi_exports__deinterleaveGeometry = __webpackgi_exports__.LK7
  , __webpackgi_exports__deserializeObject = __webpackgi_exports__.$q
  , __webpackgi_exports__deserializers = __webpackgi_exports__.vem
  , __webpackgi_exports__detectOverflow = __webpackgi_exports__.__B
  , __webpackgi_exports__diamondMaterialPropList = __webpackgi_exports__.BF2
  , __webpackgi_exports__distance = __webpackgi_exports__.IoC
  , __webpackgi_exports__downloadBlob = __webpackgi_exports__.WNF
  , __webpackgi_exports__downloadFile = __webpackgi_exports__.PE3
  , __webpackgi_exports__easeIn = __webpackgi_exports__.a6C
  , __webpackgi_exports__easeInOut = __webpackgi_exports__.am_
  , __webpackgi_exports__easeOut = __webpackgi_exports__.vTE
  , __webpackgi_exports__embedUrlRefs = __webpackgi_exports__.VAT
  , __webpackgi_exports__end = __webpackgi_exports__._N2
  , __webpackgi_exports__envMapBackground = __webpackgi_exports__.oib
  , __webpackgi_exports__escapeRegExp = __webpackgi_exports__.NtM
  , __webpackgi_exports__estimateBytesUsed = __webpackgi_exports__.ru_
  , __webpackgi_exports__eventListeners = __webpackgi_exports__.GcD
  , __webpackgi_exports__extractAnimationKey = __webpackgi_exports__.pJG
  , __webpackgi_exports__flattenUiConfig = __webpackgi_exports__.vxL
  , __webpackgi_exports__flip = __webpackgi_exports__.UUz
  , __webpackgi_exports__fontFormatExtensionMap = __webpackgi_exports__.mlk
  , __webpackgi_exports__generateUiConfig = __webpackgi_exports__.SVi
  , __webpackgi_exports__generateUiFolder = __webpackgi_exports__.QXJ
  , __webpackgi_exports__getFileHandle = __webpackgi_exports__.D01
  , __webpackgi_exports__getFilenameFromPath = __webpackgi_exports__.$7C
  , __webpackgi_exports__getKeyByValue = __webpackgi_exports__.cdn
  , __webpackgi_exports__getNewFileHandle = __webpackgi_exports__.vGk
  , __webpackgi_exports__getOrCall = __webpackgi_exports__.GPz
  , __webpackgi_exports__getPropertyDescriptor = __webpackgi_exports__.NxN
  , __webpackgi_exports__getTexelDecoding = __webpackgi_exports__.o7j
  , __webpackgi_exports__getTexelDecodingFunction = __webpackgi_exports__.yqR
  , __webpackgi_exports__getTextureDataType = __webpackgi_exports__.U_j
  , __webpackgi_exports__getTypedArray = __webpackgi_exports__.mB_
  , __webpackgi_exports__getUrlQueryParam = __webpackgi_exports__.d6c
  , __webpackgi_exports__glbEncryptionPreparser = __webpackgi_exports__.zhG
  , __webpackgi_exports__glsl = __webpackgi_exports__.HJb
  , __webpackgi_exports__gltfExporterMaterialsVariantsExtensionExport = __webpackgi_exports__.e5R
  , __webpackgi_exports__gunzip = __webpackgi_exports__.kdR
  , __webpackgi_exports__gunzipSync = __webpackgi_exports__.D85
  , __webpackgi_exports__gzip = __webpackgi_exports__.ZIX
  , __webpackgi_exports__gzipSync = __webpackgi_exports__.u3y
  , __webpackgi_exports__hide = __webpackgi_exports__.jDu
  , __webpackgi_exports__html = __webpackgi_exports__.qyt
  , __webpackgi_exports__htmlToCanvas = __webpackgi_exports__.Dtr
  , __webpackgi_exports__htmlToPng = __webpackgi_exports__.WKP
  , __webpackgi_exports__htmlToSvg = __webpackgi_exports__.fJV
  , __webpackgi_exports__iGeometryIgnoredUserData = __webpackgi_exports__.tC7
  , __webpackgi_exports__iMaterialIgnoredUserData = __webpackgi_exports__.Uan
  , __webpackgi_exports__iModelIgnoredUserData = __webpackgi_exports__.Uct
  , __webpackgi_exports__iTextureIgnoredUserData = __webpackgi_exports__.K_U
  , __webpackgi_exports__imageBitmapToBase64 = __webpackgi_exports__.BFA
  , __webpackgi_exports__imageDataToCanvas = __webpackgi_exports__.BHX
  , __webpackgi_exports__imageToCanvas = __webpackgi_exports__.Pee
  , __webpackgi_exports__imageUrlToImageData = __webpackgi_exports__.$If
  , __webpackgi_exports__includesAll = __webpackgi_exports__.RFY
  , __webpackgi_exports__inertia = __webpackgi_exports__.Buv
  , __webpackgi_exports__inflate = __webpackgi_exports__.UDz
  , __webpackgi_exports__inflateSync = __webpackgi_exports__.HMP
  , __webpackgi_exports__interleaveAttributes = __webpackgi_exports__.Zg4
  , __webpackgi_exports__interpolate = __webpackgi_exports__.GWP
  , __webpackgi_exports__isAnimatableType = __webpackgi_exports__.r58
  , __webpackgi_exports__isPoint = __webpackgi_exports__.fTC
  , __webpackgi_exports__isPoint3D = __webpackgi_exports__.YWz
  , __webpackgi_exports__isPropertyWritable = __webpackgi_exports__.eAs
  , __webpackgi_exports__keyframes = __webpackgi_exports__.i7C
  , __webpackgi_exports__khrMaterialsVariantsGLTF = __webpackgi_exports__.jFo
  , __webpackgi_exports__left = __webpackgi_exports__.kbd
  , __webpackgi_exports__lerpAngle = __webpackgi_exports__.nU8
  , __webpackgi_exports__lerpAngle2 = __webpackgi_exports__.NFx
  , __webpackgi_exports__linear = __webpackgi_exports__.sns
  , __webpackgi_exports__longestCommonPrefix = __webpackgi_exports__.S2G
  , __webpackgi_exports__main = __webpackgi_exports__.iW4
  , __webpackgi_exports__makeColorSvg = __webpackgi_exports__.Se$
  , __webpackgi_exports__makeColorSvgCircle = __webpackgi_exports__.Sop
  , __webpackgi_exports__makeFilter = __webpackgi_exports__.HNH
  , __webpackgi_exports__makeSamplerUi = __webpackgi_exports__.jGz
  , __webpackgi_exports__makeSetterFor = __webpackgi_exports__.ll7
  , __webpackgi_exports__makeTextSvg = __webpackgi_exports__.SrG
  , __webpackgi_exports__matDefine = __webpackgi_exports__.UGD
  , __webpackgi_exports__mergeAttributes = __webpackgi_exports__.KVf
  , __webpackgi_exports__mergeBufferAttributes = __webpackgi_exports__.gDN
  , __webpackgi_exports__mergeBufferGeometries = __webpackgi_exports__.h0o
  , __webpackgi_exports__mergeGeometries = __webpackgi_exports__.pPQ
  , __webpackgi_exports__mergeGroups = __webpackgi_exports__.hLo
  , __webpackgi_exports__mergeVertices = __webpackgi_exports__.ecu
  , __webpackgi_exports__mirrorEasing = __webpackgi_exports__.mhB
  , __webpackgi_exports__mix = __webpackgi_exports__.jhA
  , __webpackgi_exports__mixColor = __webpackgi_exports__.iou
  , __webpackgi_exports__mixComplex = __webpackgi_exports__.JL8
  , __webpackgi_exports__mobileAndTabletCheck = __webpackgi_exports__.G8Z
  , __webpackgi_exports__modifierPhases = __webpackgi_exports__.GMB
  , __webpackgi_exports__now = __webpackgi_exports__.tB5
  , __webpackgi_exports__objectHasOwn = __webpackgi_exports__.GnX
  , __webpackgi_exports__offset = __webpackgi_exports__.cYW
  , __webpackgi_exports__onChange = __webpackgi_exports__.k9K
  , __webpackgi_exports__onChange2 = __webpackgi_exports__.CTC
  , __webpackgi_exports__onChange3 = __webpackgi_exports__.JW6
  , __webpackgi_exports__parseFileExtension = __webpackgi_exports__.p7C
  , __webpackgi_exports__patchShaderEncodingSupport = __webpackgi_exports__.OId
  , __webpackgi_exports__pathJoin = __webpackgi_exports__.CN_
  , __webpackgi_exports__physicalMaterialPropList = __webpackgi_exports__.uaX
  , __webpackgi_exports__pipe = __webpackgi_exports__.FsL
  , __webpackgi_exports__pivotToBBoxCenter = __webpackgi_exports__.gtD
  , __webpackgi_exports__pivotToPoint = __webpackgi_exports__.wbL
  , __webpackgi_exports__placements = __webpackgi_exports__.DDu
  , __webpackgi_exports__pointFromVector = __webpackgi_exports__.O$W
  , __webpackgi_exports__popper = __webpackgi_exports__.xfb
  , __webpackgi_exports__popperGenerator = __webpackgi_exports__.UD3
  , __webpackgi_exports__popperOffsets = __webpackgi_exports__.ZoD
  , __webpackgi_exports__prettyScrollbar = __webpackgi_exports__.hQ_
  , __webpackgi_exports__preventOverflow = __webpackgi_exports__.V7C
  , __webpackgi_exports__processViewer = __webpackgi_exports__.Sow
  , __webpackgi_exports__progress = __webpackgi_exports__.qB0
  , __webpackgi_exports__radiansToDegrees = __webpackgi_exports__.nv6
  , __webpackgi_exports__read = __webpackgi_exports__.LF4
  , __webpackgi_exports__readFile = __webpackgi_exports__.TAg
  , __webpackgi_exports__reference = __webpackgi_exports__.irg
  , __webpackgi_exports__remoteWorkerURL = __webpackgi_exports__.Ei4
  , __webpackgi_exports__removeDuplicateGeometries = __webpackgi_exports__.Grb
  , __webpackgi_exports__replaceAll = __webpackgi_exports__.yhl
  , __webpackgi_exports__reverseEasing = __webpackgi_exports__.Gmo
  , __webpackgi_exports__right = __webpackgi_exports__.pGT
  , __webpackgi_exports__rotateDuplicatedMesh = __webpackgi_exports__.Gsh
  , __webpackgi_exports__sRGBEncoding = __webpackgi_exports__.S2Q
  , __webpackgi_exports__safeSetProperty = __webpackgi_exports__.pUp
  , __webpackgi_exports__serializable = __webpackgi_exports__.sU3
  , __webpackgi_exports__serialize = __webpackgi_exports__.lKg
  , __webpackgi_exports__serializeObject = __webpackgi_exports__.gwL
  , __webpackgi_exports__serializeTextureInExtras = __webpackgi_exports__.EBS
  , __webpackgi_exports__serializers = __webpackgi_exports__.YCG
  , __webpackgi_exports__setMeshGeometry = __webpackgi_exports__.gC
  , __webpackgi_exports__setMeshMaterial = __webpackgi_exports__.R5k
  , __webpackgi_exports__setThreeRendererMode = __webpackgi_exports__.zB$
  , __webpackgi_exports__setUrlQueryParam = __webpackgi_exports__.dGw
  , __webpackgi_exports__setupCoreWebGiViewer = __webpackgi_exports__.tNl
  , __webpackgi_exports__setupIModel = __webpackgi_exports__.AAd
  , __webpackgi_exports__setupModesStyles = __webpackgi_exports__.YFt
  , __webpackgi_exports__setupModesUi = __webpackgi_exports__.IRk
  , __webpackgi_exports__setupObject3dModel = __webpackgi_exports__.ZVX
  , __webpackgi_exports__setupSandboxWebGiEditor = __webpackgi_exports__.cTN
  , __webpackgi_exports__shaderReplaceString = __webpackgi_exports__.PlU
  , __webpackgi_exports__sign2 = __webpackgi_exports__.Mi5
  , __webpackgi_exports__slerp = __webpackgi_exports__.nuN
  , __webpackgi_exports__smooth = __webpackgi_exports__.Jp2
  , __webpackgi_exports__smoothFrame = __webpackgi_exports__.oDA
  , __webpackgi_exports__snap = __webpackgi_exports__.n$K
  , __webpackgi_exports__snapObject = __webpackgi_exports__.w4b
  , __webpackgi_exports__sphericalFromObject = __webpackgi_exports__.JVv
  , __webpackgi_exports__spring = __webpackgi_exports__.ozl
  , __webpackgi_exports__standardMaterialPropList = __webpackgi_exports__.asH
  , __webpackgi_exports__start = __webpackgi_exports__.niF
  , __webpackgi_exports__steps = __webpackgi_exports__.CiD
  , __webpackgi_exports__strFromU8 = __webpackgi_exports__.heq
  , __webpackgi_exports__strToU8 = __webpackgi_exports__._uk
  , __webpackgi_exports__supportsRequestStreams = __webpackgi_exports__.xrZ
  , __webpackgi_exports__svgToCanvas = __webpackgi_exports__.aUi
  , __webpackgi_exports__svgToPng = __webpackgi_exports__.Tmf
  , __webpackgi_exports__svgUrl = __webpackgi_exports__.AYr
  , __webpackgi_exports__texImageToCanvas = __webpackgi_exports__.SVO
  , __webpackgi_exports__textureDataToImageData = __webpackgi_exports__.mBH
  , __webpackgi_exports__textureToCanvas = __webpackgi_exports__.z73
  , __webpackgi_exports__textureToDataUrl = __webpackgi_exports__.cyN
  , __webpackgi_exports__timeout = __webpackgi_exports__.wRz
  , __webpackgi_exports__toCreasedNormals = __webpackgi_exports__.pbX
  , __webpackgi_exports__toDecimal = __webpackgi_exports__.nIf
  , __webpackgi_exports__toIndexedGeometry = __webpackgi_exports__.RY5
  , __webpackgi_exports__toTitleCase = __webpackgi_exports__.SnO
  , __webpackgi_exports__toTrianglesDrawMode = __webpackgi_exports__._cJ
  , __webpackgi_exports__top = __webpackgi_exports__.Mny
  , __webpackgi_exports__uiButton = __webpackgi_exports__.X0G
  , __webpackgi_exports__uiColor = __webpackgi_exports__.mBY
  , __webpackgi_exports__uiConfig = __webpackgi_exports__.rpQ
  , __webpackgi_exports__uiDropdown = __webpackgi_exports__.exO
  , __webpackgi_exports__uiFolder = __webpackgi_exports__.rsv
  , __webpackgi_exports__uiImage = __webpackgi_exports__.gpt
  , __webpackgi_exports__uiInput = __webpackgi_exports__.hEL
  , __webpackgi_exports__uiMonitor = __webpackgi_exports__.LIx
  , __webpackgi_exports__uiPanel = __webpackgi_exports__.Z5F
  , __webpackgi_exports__uiSlider = __webpackgi_exports__.Eiw
  , __webpackgi_exports__uiToggle = __webpackgi_exports__.Jx6
  , __webpackgi_exports__uiVector = __webpackgi_exports__.q00
  , __webpackgi_exports__uniform = __webpackgi_exports__.PiW
  , __webpackgi_exports__unzip = __webpackgi_exports__.$15
  , __webpackgi_exports__unzipSync = __webpackgi_exports__.AOo
  , __webpackgi_exports__unzlib = __webpackgi_exports__.VTi
  , __webpackgi_exports__unzlibSync = __webpackgi_exports__.a8Y
  , __webpackgi_exports__uploadFile = __webpackgi_exports__.QMY
  , __webpackgi_exports__vLinearToRGBM = __webpackgi_exports__.d5o
  , __webpackgi_exports__vRGBMToLinear = __webpackgi_exports__.Fxe
  , __webpackgi_exports__valueToUiType = __webpackgi_exports__.Nan
  , __webpackgi_exports__variationPlacements = __webpackgi_exports__.Ols
  , __webpackgi_exports__velocityPerFrame = __webpackgi_exports__.Ovn
  , __webpackgi_exports__velocityPerSecond = __webpackgi_exports__.fjO
  , __webpackgi_exports__verifyPermission = __webpackgi_exports__.pZl
  , __webpackgi_exports__viewport = __webpackgi_exports__.R9T
  , __webpackgi_exports__wrap = __webpackgi_exports__.LV7
  , __webpackgi_exports__write = __webpackgi_exports__.M98
  , __webpackgi_exports__writeFile = __webpackgi_exports__._h9
  , __webpackgi_exports__zip = __webpackgi_exports__.yU6
  , __webpackgi_exports__zipSync = __webpackgi_exports__.LaF
  , __webpackgi_exports__zlib = __webpackgi_exports__.w58
  , __webpackgi_exports__zlibSync = __webpackgi_exports__.$ax;
const WEBGI = Object.freeze(Object.defineProperty({
    __proto__: null,
    AAssetManagerProcessStatePlugin: __webpackgi_exports__AAssetManagerProcessStatePlugin,
    ACESFilmicToneMapping: __webpackgi_exports__ACESFilmicToneMapping,
    ACameraControlsPlugin: __webpackgi_exports__ACameraControlsPlugin,
    ACanvasRecorder: __webpackgi_exports__ACanvasRecorder,
    ALL_WEBGI_EXTENSIONS: __webpackgi_exports__ALL_WEBGI_EXTENSIONS,
    AMaterialManager: __webpackgi_exports__AMaterialManager,
    ARPlacementBox: __webpackgi_exports__ARPlacementBox,
    ARPlugin: __webpackgi_exports__ARPlugin,
    ARTouchInputHelper: __webpackgi_exports__ARTouchInputHelper,
    AShaderMaterial2: __webpackgi_exports__AShaderMaterial2,
    AViewerPlugin: __webpackgi_exports__AViewerPlugin,
    AWSClientPlugin: __webpackgi_exports__AWSClientPlugin,
    AddBlendPass: __webpackgi_exports__AddBlendPass,
    AddEquation: __webpackgi_exports__AddEquation,
    AddOperation: __webpackgi_exports__AddOperation,
    AdditiveAnimationBlendMode: __webpackgi_exports__AdditiveAnimationBlendMode,
    AdditiveBlending: __webpackgi_exports__AdditiveBlending,
    AlphaFormat: __webpackgi_exports__AlphaFormat,
    AlwaysCompare: __webpackgi_exports__AlwaysCompare,
    AlwaysDepth: __webpackgi_exports__AlwaysDepth,
    AlwaysStencilFunc: __webpackgi_exports__AlwaysStencilFunc,
    AmbientLight: __webpackgi_exports__AmbientLight,
    AmbientLight2: __webpackgi_exports__AmbientLight2,
    AnimationAction: __webpackgi_exports__AnimationAction,
    AnimationClip: __webpackgi_exports__AnimationClip,
    AnimationLoader: __webpackgi_exports__AnimationLoader,
    AnimationMixer: __webpackgi_exports__AnimationMixer,
    AnimationObjectGroup: __webpackgi_exports__AnimationObjectGroup,
    AnimationUtils: __webpackgi_exports__AnimationUtils,
    AnisotropyPlugin: __webpackgi_exports__AnisotropyPlugin,
    ArcCurve: __webpackgi_exports__ArcCurve,
    ArrayCamera: __webpackgi_exports__ArrayCamera,
    ArrowHelper: __webpackgi_exports__ArrowHelper,
    AssetExporter: __webpackgi_exports__AssetExporter,
    AssetExporterPlugin: __webpackgi_exports__AssetExporterPlugin,
    AssetImporter: __webpackgi_exports__AssetImporter,
    AssetManagerBasicPopupPlugin: __webpackgi_exports__AssetManagerBasicPopupPlugin,
    AssetManagerLoadingBarPlugin: __webpackgi_exports__AssetManagerLoadingBarPlugin,
    AssetManagerPlugin: __webpackgi_exports__AssetManagerPlugin,
    AsyncCompress: __webpackgi_exports__AsyncCompress,
    AsyncDecompress: __webpackgi_exports__AsyncDecompress,
    AsyncDeflate: __webpackgi_exports__AsyncDeflate,
    AsyncGunzip: __webpackgi_exports__AsyncGunzip,
    AsyncGzip: __webpackgi_exports__AsyncGzip,
    AsyncInflate: __webpackgi_exports__AsyncInflate,
    AsyncUnzipInflate: __webpackgi_exports__AsyncUnzipInflate,
    AsyncUnzlib: __webpackgi_exports__AsyncUnzlib,
    AsyncZipDeflate: __webpackgi_exports__AsyncZipDeflate,
    AsyncZlib: __webpackgi_exports__AsyncZlib,
    Audio: __webpackgi_exports__Audio,
    AudioAnalyser: __webpackgi_exports__AudioAnalyser,
    AudioContext: __webpackgi_exports__AudioContext,
    AudioListener: __webpackgi_exports__AudioListener,
    AudioLoader: __webpackgi_exports__AudioLoader,
    AxesHelper: __webpackgi_exports__AxesHelper,
    BackSide: __webpackgi_exports__BackSide,
    BackgroundPresetGroup: __webpackgi_exports__BackgroundPresetGroup,
    BaseGroundPlugin: __webpackgi_exports__BaseGroundPlugin,
    BaseRenderer: __webpackgi_exports__BaseRenderer,
    BasicDepthPacking: __webpackgi_exports__BasicDepthPacking,
    BasicShadowMap: __webpackgi_exports__BasicShadowMap,
    BeringRingAnimation: __webpackgi_exports__BeringRingAnimation,
    BlobLoader: __webpackgi_exports__BlobLoader,
    BloomPlugin: __webpackgi_exports__BloomPlugin,
    Bone: __webpackgi_exports__Bone,
    BooleanKeyframeTrack: __webpackgi_exports__BooleanKeyframeTrack,
    Box2: __webpackgi_exports__Box2,
    Box3: __webpackgi_exports__Box3,
    Box3B: __webpackgi_exports__Box3B,
    Box3Helper: __webpackgi_exports__Box3Helper,
    BoxGeometry: __webpackgi_exports__BoxGeometry,
    BoxHelper: __webpackgi_exports__BoxHelper,
    BoxSelectionWidget: __webpackgi_exports__BoxSelectionWidget,
    BufferAttribute: __webpackgi_exports__BufferAttribute,
    BufferGeometry: __webpackgi_exports__BufferGeometry,
    BufferGeometryLoader: __webpackgi_exports__BufferGeometryLoader,
    ByteType: __webpackgi_exports__ByteType,
    CSGPluginBSP: __webpackgi_exports__CSGPluginBSP,
    CSGPluginBVH: __webpackgi_exports__CSGPluginBVH,
    CSGPluginBase: __webpackgi_exports__CSGPluginBase,
    CSS3DRendererPlugin: __webpackgi_exports__CSS3DRendererPlugin,
    Cache: __webpackgi_exports__Cache,
    Camera: __webpackgi_exports__Camera,
    CameraController: __webpackgi_exports__CameraController,
    CameraHelper: __webpackgi_exports__CameraHelper,
    CameraUiPlugin: __webpackgi_exports__CameraUiPlugin,
    CameraView: __webpackgi_exports__CameraView,
    CameraViewControlPlugin: __webpackgi_exports__CameraViewControlPlugin,
    CameraViewPlugin: __webpackgi_exports__CameraViewPlugin,
    CannonPhysicsPlugin: __webpackgi_exports__CannonPhysicsPlugin,
    CanvasMediaRecorder: __webpackgi_exports__CanvasMediaRecorder,
    CanvasRecorder: __webpackgi_exports__CanvasRecorder,
    CanvasRecorderPlugin: __webpackgi_exports__CanvasRecorderPlugin,
    CanvasSnipper: __webpackgi_exports__CanvasSnipper,
    CanvasSnipperPlugin: __webpackgi_exports__CanvasSnipperPlugin,
    CanvasTexture: __webpackgi_exports__CanvasTexture,
    CapsuleGeometry: __webpackgi_exports__CapsuleGeometry,
    CatmullRomCurve3: __webpackgi_exports__CatmullRomCurve3,
    ChromaticAberrationPlugin: __webpackgi_exports__ChromaticAberrationPlugin,
    CineonToneMapping: __webpackgi_exports__CineonToneMapping,
    CircleGeometry: __webpackgi_exports__CircleGeometry,
    ClampToEdgeWrapping: __webpackgi_exports__ClampToEdgeWrapping,
    ClearcoatTintPlugin: __webpackgi_exports__ClearcoatTintPlugin,
    Clock: __webpackgi_exports__Clock,
    Color: __webpackgi_exports__Color,
    ColorKeyframeTrack: __webpackgi_exports__ColorKeyframeTrack,
    ColorManagement: __webpackgi_exports__ColorManagement,
    CombinedPostPlugin: __webpackgi_exports__CombinedPostPlugin,
    Compress: __webpackgi_exports__Compress,
    CompressedArrayTexture: __webpackgi_exports__CompressedArrayTexture,
    CompressedCubeTexture: __webpackgi_exports__CompressedCubeTexture,
    CompressedTexture: __webpackgi_exports__CompressedTexture,
    CompressedTextureLoader: __webpackgi_exports__CompressedTextureLoader,
    ConeGeometry: __webpackgi_exports__ConeGeometry,
    ContactShadowGroundPlugin: __webpackgi_exports__ContactShadowGroundPlugin,
    CoreEditorApp: __webpackgi_exports__CoreEditorApp,
    CoreViewerApp: __webpackgi_exports__CoreViewerApp,
    CubeCamera: __webpackgi_exports__CubeCamera,
    CubeNormalsCaptureHelper: __webpackgi_exports__CubeNormalsCaptureHelper,
    CubeReflectionMapping: __webpackgi_exports__CubeReflectionMapping,
    CubeRefractionMapping: __webpackgi_exports__CubeRefractionMapping,
    CubeTexture: __webpackgi_exports__CubeTexture,
    CubeTextureLoader: __webpackgi_exports__CubeTextureLoader,
    CubeUVReflectionMapping: __webpackgi_exports__CubeUVReflectionMapping,
    CubicBezierCurve: __webpackgi_exports__CubicBezierCurve,
    CubicBezierCurve3: __webpackgi_exports__CubicBezierCurve3,
    CubicInterpolant: __webpackgi_exports__CubicInterpolant,
    CullFaceBack: __webpackgi_exports__CullFaceBack,
    CullFaceFront: __webpackgi_exports__CullFaceFront,
    CullFaceFrontBack: __webpackgi_exports__CullFaceFrontBack,
    CullFaceNone: __webpackgi_exports__CullFaceNone,
    Curve: __webpackgi_exports__Curve,
    CurvePath: __webpackgi_exports__CurvePath,
    CustomAnimationHelper: __webpackgi_exports__CustomAnimationHelper,
    CustomAnimationHelperPlugin: __webpackgi_exports__CustomAnimationHelperPlugin,
    CustomBlending: __webpackgi_exports__CustomBlending,
    CustomBumpMapPlugin: __webpackgi_exports__CustomBumpMapPlugin,
    CustomToneMapping: __webpackgi_exports__CustomToneMapping,
    CylinderGeometry: __webpackgi_exports__CylinderGeometry,
    Cylindrical: __webpackgi_exports__Cylindrical,
    DRACOLoader2: __webpackgi_exports__DRACOLoader2,
    Damper: __webpackgi_exports__Damper,
    Data3DTexture: __webpackgi_exports__Data3DTexture,
    DataArrayTexture: __webpackgi_exports__DataArrayTexture,
    DataTexture: __webpackgi_exports__DataTexture,
    DataTextureLoader: __webpackgi_exports__DataTextureLoader,
    DataUrlLoader: __webpackgi_exports__DataUrlLoader,
    DataUtils: __webpackgi_exports__DataUtils,
    DebugPlugin: __webpackgi_exports__DebugPlugin,
    DecodeUTF8: __webpackgi_exports__DecodeUTF8,
    Decompress: __webpackgi_exports__Decompress,
    DecrementStencilOp: __webpackgi_exports__DecrementStencilOp,
    DecrementWrapStencilOp: __webpackgi_exports__DecrementWrapStencilOp,
    DefaultLoadingManager: __webpackgi_exports__DefaultLoadingManager,
    Deflate: __webpackgi_exports__Deflate,
    DepthFormat: __webpackgi_exports__DepthFormat,
    DepthOfFieldPass: __webpackgi_exports__DepthOfFieldPass,
    DepthOfFieldPlugin: __webpackgi_exports__DepthOfFieldPlugin,
    DepthStencilFormat: __webpackgi_exports__DepthStencilFormat,
    DepthTexture: __webpackgi_exports__DepthTexture,
    DeviceOrientationControls2: __webpackgi_exports__DeviceOrientationControls2,
    DeviceOrientationControlsPlugin: __webpackgi_exports__DeviceOrientationControlsPlugin,
    DiamondMaterial: __webpackgi_exports__DiamondMaterial,
    DiamondPlugin: __webpackgi_exports__DiamondPlugin,
    DirectionalLight: __webpackgi_exports__DirectionalLight,
    DirectionalLight2: __webpackgi_exports__DirectionalLight2,
    DirectionalLightHelper: __webpackgi_exports__DirectionalLightHelper,
    DiscreteInterpolant: __webpackgi_exports__DiscreteInterpolant,
    DisplayP3ColorSpace: __webpackgi_exports__DisplayP3ColorSpace,
    DodecahedronGeometry: __webpackgi_exports__DodecahedronGeometry,
    DoubleSide: __webpackgi_exports__DoubleSide,
    Dropzone: __webpackgi_exports__Dropzone,
    DropzonePlugin: __webpackgi_exports__DropzonePlugin,
    DstAlphaFactor: __webpackgi_exports__DstAlphaFactor,
    DstColorFactor: __webpackgi_exports__DstColorFactor,
    DynamicCopyUsage: __webpackgi_exports__DynamicCopyUsage,
    DynamicDrawUsage: __webpackgi_exports__DynamicDrawUsage,
    DynamicReadUsage: __webpackgi_exports__DynamicReadUsage,
    EXRExporter2: __webpackgi_exports__EXRExporter2,
    EXRLoadPlugin: __webpackgi_exports__EXRLoadPlugin,
    EasingFunctions: __webpackgi_exports__EasingFunctions,
    EdgesGeometry: __webpackgi_exports__EdgesGeometry,
    EffectComposer2: __webpackgi_exports__EffectComposer2,
    EllipseCurve: __webpackgi_exports__EllipseCurve,
    EllipseCurve3D: __webpackgi_exports__EllipseCurve3D,
    EncodeUTF8: __webpackgi_exports__EncodeUTF8,
    EncoderMethod: __webpackgi_exports__EncoderMethod,
    EnvironmentPresetGroup: __webpackgi_exports__EnvironmentPresetGroup,
    EqualCompare: __webpackgi_exports__EqualCompare,
    EqualDepth: __webpackgi_exports__EqualDepth,
    EqualStencilFunc: __webpackgi_exports__EqualStencilFunc,
    EquirectangularReflectionMapping: __webpackgi_exports__EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: __webpackgi_exports__EquirectangularRefractionMapping,
    Euler: __webpackgi_exports__Euler,
    EventDispatcher: __webpackgi_exports__EventDispatcher,
    ExtrasUiPlugin: __webpackgi_exports__ExtrasUiPlugin,
    ExtrudeGeometry: __webpackgi_exports__ExtrudeGeometry,
    FBXLoadPlugin: __webpackgi_exports__FBXLoadPlugin,
    FFMPEGRecorder: __webpackgi_exports__FFMPEGRecorder,
    FSShadowMaterial: __webpackgi_exports__FSShadowMaterial,
    FileLoader: __webpackgi_exports__FileLoader,
    FileTransferPlugin: __webpackgi_exports__FileTransferPlugin,
    FilmicGrainPlugin: __webpackgi_exports__FilmicGrainPlugin,
    FirstPersonControls2: __webpackgi_exports__FirstPersonControls2,
    FirstPersonControlsPlugin: __webpackgi_exports__FirstPersonControlsPlugin,
    Float16BufferAttribute: __webpackgi_exports__Float16BufferAttribute,
    Float32BufferAttribute: __webpackgi_exports__Float32BufferAttribute,
    Float64BufferAttribute: __webpackgi_exports__Float64BufferAttribute,
    FloatType: __webpackgi_exports__FloatType,
    Fog: __webpackgi_exports__Fog,
    FogExp2: __webpackgi_exports__FogExp2,
    FragmentClippingExtensionPlugin: __webpackgi_exports__FragmentClippingExtensionPlugin,
    FragmentClippingMode: __webpackgi_exports__FragmentClippingMode,
    FrameFadePlugin: __webpackgi_exports__FrameFadePlugin,
    FramebufferTexture: __webpackgi_exports__FramebufferTexture,
    FrontSide: __webpackgi_exports__FrontSide,
    Frustum: __webpackgi_exports__Frustum,
    FullScreenPlugin: __webpackgi_exports__FullScreenPlugin,
    GBufferPlugin: __webpackgi_exports__GBufferPlugin,
    GLBufferAttribute: __webpackgi_exports__GLBufferAttribute,
    GLSL1: __webpackgi_exports__GLSL1,
    GLSL3: __webpackgi_exports__GLSL3,
    GLTFAnimationPlugin: __webpackgi_exports__GLTFAnimationPlugin,
    GLTFDracoExportPlugin: __webpackgi_exports__GLTFDracoExportPlugin,
    GLTFDracoExporter: __webpackgi_exports__GLTFDracoExporter,
    GLTFExporter2: __webpackgi_exports__GLTFExporter2,
    GLTFExporterMaterialsVariantsExtensionExport: __webpackgi_exports__GLTFExporterMaterialsVariantsExtensionExport,
    GLTFKHRMaterialVariantsPlugin: __webpackgi_exports__GLTFKHRMaterialVariantsPlugin,
    GLTFLoader2: __webpackgi_exports__GLTFLoader2,
    GLTFMaterialsVariantsExtensionImport: __webpackgi_exports__GLTFMaterialsVariantsExtensionImport,
    GLTFMeshGpuInstancingExporter: __webpackgi_exports__GLTFMeshGpuInstancingExporter,
    GLTFMeshOptPlugin: __webpackgi_exports__GLTFMeshOptPlugin,
    GLTFSpecGlossinessConverterPlugin: __webpackgi_exports__GLTFSpecGlossinessConverterPlugin,
    GLTFWriter2: __webpackgi_exports__GLTFWriter2,
    GammaCorrectionExtension: __webpackgi_exports__GammaCorrectionExtension,
    GammaCorrectionPlugin: __webpackgi_exports__GammaCorrectionPlugin,
    GemEnvironmentPresetGroup: __webpackgi_exports__GemEnvironmentPresetGroup,
    GenericBlendTexturePass: __webpackgi_exports__GenericBlendTexturePass,
    GenericFilterPlugin: __webpackgi_exports__GenericFilterPlugin,
    GeometryGeneratorPlugin: __webpackgi_exports__GeometryGeneratorPlugin,
    GreaterCompare: __webpackgi_exports__GreaterCompare,
    GreaterDepth: __webpackgi_exports__GreaterDepth,
    GreaterEqualCompare: __webpackgi_exports__GreaterEqualCompare,
    GreaterEqualDepth: __webpackgi_exports__GreaterEqualDepth,
    GreaterEqualStencilFunc: __webpackgi_exports__GreaterEqualStencilFunc,
    GreaterStencilFunc: __webpackgi_exports__GreaterStencilFunc,
    GridHelper: __webpackgi_exports__GridHelper,
    GroundPlugin: __webpackgi_exports__GroundPlugin,
    Group: __webpackgi_exports__Group,
    Gunzip: __webpackgi_exports__Gunzip,
    GyroInputDevice: __webpackgi_exports__GyroInputDevice,
    Gzip: __webpackgi_exports__Gzip,
    HDRiGroundPlugin: __webpackgi_exports__HDRiGroundPlugin,
    HalfFloatType: __webpackgi_exports__HalfFloatType,
    HemisphereLight: __webpackgi_exports__HemisphereLight,
    HemisphereLightHelper: __webpackgi_exports__HemisphereLightHelper,
    HierarchyUiPlugin: __webpackgi_exports__HierarchyUiPlugin,
    IcosahedronGeometry: __webpackgi_exports__IcosahedronGeometry,
    ImageBitmapLoader: __webpackgi_exports__ImageBitmapLoader,
    ImageLoader: __webpackgi_exports__ImageLoader,
    ImageSequenceRecorder: __webpackgi_exports__ImageSequenceRecorder,
    ImageUtils: __webpackgi_exports__ImageUtils,
    Importer: __webpackgi_exports__Importer,
    IncrementStencilOp: __webpackgi_exports__IncrementStencilOp,
    IncrementWrapStencilOp: __webpackgi_exports__IncrementWrapStencilOp,
    Inflate: __webpackgi_exports__Inflate,
    InstancedBufferAttribute: __webpackgi_exports__InstancedBufferAttribute,
    InstancedBufferGeometry: __webpackgi_exports__InstancedBufferGeometry,
    InstancedInterleavedBuffer: __webpackgi_exports__InstancedInterleavedBuffer,
    InstancedMesh: __webpackgi_exports__InstancedMesh,
    Int16BufferAttribute: __webpackgi_exports__Int16BufferAttribute,
    Int32BufferAttribute: __webpackgi_exports__Int32BufferAttribute,
    Int8BufferAttribute: __webpackgi_exports__Int8BufferAttribute,
    IntType: __webpackgi_exports__IntType,
    InteractionPromptPlugin: __webpackgi_exports__InteractionPromptPlugin,
    InterleavedBuffer: __webpackgi_exports__InterleavedBuffer,
    InterleavedBufferAttribute: __webpackgi_exports__InterleavedBufferAttribute,
    Interpolant: __webpackgi_exports__Interpolant,
    InterpolateDiscrete: __webpackgi_exports__InterpolateDiscrete,
    InterpolateLinear: __webpackgi_exports__InterpolateLinear,
    InterpolateSmooth: __webpackgi_exports__InterpolateSmooth,
    InvertStencilOp: __webpackgi_exports__InvertStencilOp,
    KHR_TEXTURE_BASISU: __webpackgi_exports__KHR_TEXTURE_BASISU,
    KTX2LoadPlugin: __webpackgi_exports__KTX2LoadPlugin,
    KTXLoadPlugin: __webpackgi_exports__KTXLoadPlugin,
    KeepStencilOp: __webpackgi_exports__KeepStencilOp,
    KeyframeTrack: __webpackgi_exports__KeyframeTrack,
    LOD: __webpackgi_exports__LOD,
    LUTPlugin: __webpackgi_exports__LUTPlugin,
    LatheGeometry: __webpackgi_exports__LatheGeometry,
    LayeredMaterialPlugin: __webpackgi_exports__LayeredMaterialPlugin,
    Layers: __webpackgi_exports__Layers,
    LessCompare: __webpackgi_exports__LessCompare,
    LessDepth: __webpackgi_exports__LessDepth,
    LessEqualCompare: __webpackgi_exports__LessEqualCompare,
    LessEqualDepth: __webpackgi_exports__LessEqualDepth,
    LessEqualStencilFunc: __webpackgi_exports__LessEqualStencilFunc,
    LessStencilFunc: __webpackgi_exports__LessStencilFunc,
    Light: __webpackgi_exports__Light,
    LightProbe: __webpackgi_exports__LightProbe,
    LightsUiPlugin: __webpackgi_exports__LightsUiPlugin,
    Line: __webpackgi_exports__Line,
    Line2: __webpackgi_exports__Line2,
    Line3: __webpackgi_exports__Line3,
    LineBasicMaterial: __webpackgi_exports__LineBasicMaterial,
    LineCurve: __webpackgi_exports__LineCurve,
    LineCurve3: __webpackgi_exports__LineCurve3,
    LineDashedMaterial: __webpackgi_exports__LineDashedMaterial,
    LineGeometry: __webpackgi_exports__LineGeometry,
    LineLoop: __webpackgi_exports__LineLoop,
    LineMaterial: __webpackgi_exports__LineMaterial,
    LineSegments: __webpackgi_exports__LineSegments,
    LineSegments2: __webpackgi_exports__LineSegments2,
    LineSegmentsGeometry: __webpackgi_exports__LineSegmentsGeometry,
    LinearDisplayP3ColorSpace: __webpackgi_exports__LinearDisplayP3ColorSpace,
    LinearEncoding: __webpackgi_exports__LinearEncoding,
    LinearFilter: __webpackgi_exports__LinearFilter,
    LinearInterpolant: __webpackgi_exports__LinearInterpolant,
    LinearMipMapLinearFilter: __webpackgi_exports__LinearMipMapLinearFilter,
    LinearMipMapNearestFilter: __webpackgi_exports__LinearMipMapNearestFilter,
    LinearMipmapLinearFilter: __webpackgi_exports__LinearMipmapLinearFilter,
    LinearMipmapNearestFilter: __webpackgi_exports__LinearMipmapNearestFilter,
    LinearSRGBColorSpace: __webpackgi_exports__LinearSRGBColorSpace,
    LinearToneMapping: __webpackgi_exports__LinearToneMapping,
    LinearTransfer: __webpackgi_exports__LinearTransfer,
    Loader: __webpackgi_exports__Loader,
    LoaderUtils: __webpackgi_exports__LoaderUtils,
    LoadingManager: __webpackgi_exports__LoadingManager,
    LoadingScreenPlugin: __webpackgi_exports__LoadingScreenPlugin,
    LoopOnce: __webpackgi_exports__LoopOnce,
    LoopPingPong: __webpackgi_exports__LoopPingPong,
    LoopRepeat: __webpackgi_exports__LoopRepeat,
    LuminanceAlphaFormat: __webpackgi_exports__LuminanceAlphaFormat,
    LuminanceFormat: __webpackgi_exports__LuminanceFormat,
    MOUSE: __webpackgi_exports__MOUSE,
    MTLLoader2: __webpackgi_exports__MTLLoader2,
    Material: __webpackgi_exports__Material,
    MaterialConfiguratorBasePlugin: __webpackgi_exports__MaterialConfiguratorBasePlugin,
    MaterialConfiguratorPlugin: __webpackgi_exports__MaterialConfiguratorPlugin,
    MaterialExtender: __webpackgi_exports__MaterialExtender,
    MaterialLibPresetGroupPresetGroup: __webpackgi_exports__MaterialLibPresetGroupPresetGroup,
    MaterialLibraryBasePlugin: __webpackgi_exports__MaterialLibraryBasePlugin,
    MaterialLibraryPlugin: __webpackgi_exports__MaterialLibraryPlugin,
    MaterialLoader: __webpackgi_exports__MaterialLoader,
    MaterialManager: __webpackgi_exports__MaterialManager,
    MaterialPresetPlugin: __webpackgi_exports__MaterialPresetPlugin,
    MaterialPreviewGenerator: __webpackgi_exports__MaterialPreviewGenerator,
    MathUtils: __webpackgi_exports__MathUtils,
    Matrix3: __webpackgi_exports__Matrix3,
    Matrix4: __webpackgi_exports__Matrix4,
    MaxEquation: __webpackgi_exports__MaxEquation,
    Mesh: __webpackgi_exports__Mesh,
    MeshBasicMaterial: __webpackgi_exports__MeshBasicMaterial,
    MeshBasicMaterial2: __webpackgi_exports__MeshBasicMaterial2,
    MeshDepthMaterial: __webpackgi_exports__MeshDepthMaterial,
    MeshDistanceMaterial: __webpackgi_exports__MeshDistanceMaterial,
    MeshLambertMaterial: __webpackgi_exports__MeshLambertMaterial,
    MeshMatcapMaterial: __webpackgi_exports__MeshMatcapMaterial,
    MeshNormalMaterial: __webpackgi_exports__MeshNormalMaterial,
    MeshOptSimplifyModifierPlugin: __webpackgi_exports__MeshOptSimplifyModifierPlugin,
    MeshPhongMaterial: __webpackgi_exports__MeshPhongMaterial,
    MeshPhysicalMaterial: __webpackgi_exports__MeshPhysicalMaterial,
    MeshStandardMaterial: __webpackgi_exports__MeshStandardMaterial,
    MeshStandardMaterial2: __webpackgi_exports__MeshStandardMaterial2,
    MeshToonMaterial: __webpackgi_exports__MeshToonMaterial,
    MinEquation: __webpackgi_exports__MinEquation,
    MirroredRepeatWrapping: __webpackgi_exports__MirroredRepeatWrapping,
    MixOperation: __webpackgi_exports__MixOperation,
    ModelStagePlugin: __webpackgi_exports__ModelStagePlugin,
    ModelStagePresetGroup: __webpackgi_exports__ModelStagePresetGroup,
    MouseInputDevice: __webpackgi_exports__MouseInputDevice,
    MultiFilterPlugin: __webpackgi_exports__MultiFilterPlugin,
    MultiplyBlending: __webpackgi_exports__MultiplyBlending,
    MultiplyOperation: __webpackgi_exports__MultiplyOperation,
    NearestFilter: __webpackgi_exports__NearestFilter,
    NearestMipMapLinearFilter: __webpackgi_exports__NearestMipMapLinearFilter,
    NearestMipMapNearestFilter: __webpackgi_exports__NearestMipMapNearestFilter,
    NearestMipmapLinearFilter: __webpackgi_exports__NearestMipmapLinearFilter,
    NearestMipmapNearestFilter: __webpackgi_exports__NearestMipmapNearestFilter,
    NeverCompare: __webpackgi_exports__NeverCompare,
    NeverDepth: __webpackgi_exports__NeverDepth,
    NeverStencilFunc: __webpackgi_exports__NeverStencilFunc,
    NoBlending: __webpackgi_exports__NoBlending,
    NoColorSpace: __webpackgi_exports__NoColorSpace,
    NoToneMapping: __webpackgi_exports__NoToneMapping,
    NoiseBumpMaterialPlugin: __webpackgi_exports__NoiseBumpMaterialPlugin,
    NormalAnimationBlendMode: __webpackgi_exports__NormalAnimationBlendMode,
    NormalBlending: __webpackgi_exports__NormalBlending,
    NormalBufferPlugin: __webpackgi_exports__NormalBufferPlugin,
    NormalCaptureMaterial: __webpackgi_exports__NormalCaptureMaterial,
    NotEqualCompare: __webpackgi_exports__NotEqualCompare,
    NotEqualDepth: __webpackgi_exports__NotEqualDepth,
    NotEqualStencilFunc: __webpackgi_exports__NotEqualStencilFunc,
    NumberKeyframeTrack: __webpackgi_exports__NumberKeyframeTrack,
    OBJLoader2: __webpackgi_exports__OBJLoader2,
    ObjMtlLoadPlugin: __webpackgi_exports__ObjMtlLoadPlugin,
    Object3D: __webpackgi_exports__Object3D,
    Object3DModel: __webpackgi_exports__Object3DModel,
    Object3DWidgetsPlugin: __webpackgi_exports__Object3DWidgetsPlugin,
    ObjectLoader: __webpackgi_exports__ObjectLoader,
    ObjectLoader2: __webpackgi_exports__ObjectLoader2,
    ObjectPicker: __webpackgi_exports__ObjectPicker,
    ObjectProcessorMap: __webpackgi_exports__ObjectProcessorMap,
    ObjectRotationPlugin: __webpackgi_exports__ObjectRotationPlugin,
    ObjectSpaceNormalMap: __webpackgi_exports__ObjectSpaceNormalMap,
    OctahedronGeometry: __webpackgi_exports__OctahedronGeometry,
    OneFactor: __webpackgi_exports__OneFactor,
    OneMinusDstAlphaFactor: __webpackgi_exports__OneMinusDstAlphaFactor,
    OneMinusDstColorFactor: __webpackgi_exports__OneMinusDstColorFactor,
    OneMinusSrcAlphaFactor: __webpackgi_exports__OneMinusSrcAlphaFactor,
    OneMinusSrcColorFactor: __webpackgi_exports__OneMinusSrcColorFactor,
    OrbitControls2: __webpackgi_exports__OrbitControls2,
    OrbitControls3: __webpackgi_exports__OrbitControls3,
    OrthographicCamera: __webpackgi_exports__OrthographicCamera,
    OutlinePlugin: __webpackgi_exports__OutlinePlugin,
    P3Primaries: __webpackgi_exports__P3Primaries,
    PCFShadowMap: __webpackgi_exports__PCFShadowMap,
    PCFSoftShadowMap: __webpackgi_exports__PCFSoftShadowMap,
    PMREMGenerator: __webpackgi_exports__PMREMGenerator,
    PMREMGeneratorPlugin: __webpackgi_exports__PMREMGeneratorPlugin,
    ParallaxCameraControllerPlugin: __webpackgi_exports__ParallaxCameraControllerPlugin,
    ParallaxMappingPlugin: __webpackgi_exports__ParallaxMappingPlugin,
    Path: __webpackgi_exports__Path,
    PerspectiveCamera: __webpackgi_exports__PerspectiveCamera,
    PickingPlugin: __webpackgi_exports__PickingPlugin,
    Plane: __webpackgi_exports__Plane,
    PlaneGeometry: __webpackgi_exports__PlaneGeometry,
    PlaneHelper: __webpackgi_exports__PlaneHelper,
    PluginPresetGroup: __webpackgi_exports__PluginPresetGroup,
    PointLight: __webpackgi_exports__PointLight,
    PointLight2: __webpackgi_exports__PointLight2,
    PointLightHelper: __webpackgi_exports__PointLightHelper,
    PointerDragHelper: __webpackgi_exports__PointerDragHelper,
    PointerLockControls2: __webpackgi_exports__PointerLockControls2,
    PointerLockControlsPlugin: __webpackgi_exports__PointerLockControlsPlugin,
    Points: __webpackgi_exports__Points,
    PointsMaterial: __webpackgi_exports__PointsMaterial,
    PolarGridHelper: __webpackgi_exports__PolarGridHelper,
    PolyhedronGeometry: __webpackgi_exports__PolyhedronGeometry,
    PopmotionPlugin: __webpackgi_exports__PopmotionPlugin,
    PosePlugin: __webpackgi_exports__PosePlugin,
    PositionalAudio: __webpackgi_exports__PositionalAudio,
    PresetGroup: __webpackgi_exports__PresetGroup,
    PresetLibraryPlugin: __webpackgi_exports__PresetLibraryPlugin,
    ProgressivePlugin: __webpackgi_exports__ProgressivePlugin,
    PropertyBinding: __webpackgi_exports__PropertyBinding,
    PropertyMixer: __webpackgi_exports__PropertyMixer,
    QuadraticBezierCurve: __webpackgi_exports__QuadraticBezierCurve,
    QuadraticBezierCurve3: __webpackgi_exports__QuadraticBezierCurve3,
    Quaternion: __webpackgi_exports__Quaternion,
    QuaternionKeyframeTrack: __webpackgi_exports__QuaternionKeyframeTrack,
    QuaternionLinearInterpolant: __webpackgi_exports__QuaternionLinearInterpolant,
    RED_GREEN_RGTC2_Format: __webpackgi_exports__RED_GREEN_RGTC2_Format,
    RED_RGTC1_Format: __webpackgi_exports__RED_RGTC1_Format,
    REVISION: __webpackgi_exports__REVISION,
    RGBADepthPacking: __webpackgi_exports__RGBADepthPacking,
    RGBAFormat: __webpackgi_exports__RGBAFormat,
    RGBAIntegerFormat: __webpackgi_exports__RGBAIntegerFormat,
    RGBA_ASTC_10x10_Format: __webpackgi_exports__RGBA_ASTC_10x10_Format,
    RGBA_ASTC_10x5_Format: __webpackgi_exports__RGBA_ASTC_10x5_Format,
    RGBA_ASTC_10x6_Format: __webpackgi_exports__RGBA_ASTC_10x6_Format,
    RGBA_ASTC_10x8_Format: __webpackgi_exports__RGBA_ASTC_10x8_Format,
    RGBA_ASTC_12x10_Format: __webpackgi_exports__RGBA_ASTC_12x10_Format,
    RGBA_ASTC_12x12_Format: __webpackgi_exports__RGBA_ASTC_12x12_Format,
    RGBA_ASTC_4x4_Format: __webpackgi_exports__RGBA_ASTC_4x4_Format,
    RGBA_ASTC_5x4_Format: __webpackgi_exports__RGBA_ASTC_5x4_Format,
    RGBA_ASTC_5x5_Format: __webpackgi_exports__RGBA_ASTC_5x5_Format,
    RGBA_ASTC_6x5_Format: __webpackgi_exports__RGBA_ASTC_6x5_Format,
    RGBA_ASTC_6x6_Format: __webpackgi_exports__RGBA_ASTC_6x6_Format,
    RGBA_ASTC_8x5_Format: __webpackgi_exports__RGBA_ASTC_8x5_Format,
    RGBA_ASTC_8x6_Format: __webpackgi_exports__RGBA_ASTC_8x6_Format,
    RGBA_ASTC_8x8_Format: __webpackgi_exports__RGBA_ASTC_8x8_Format,
    RGBA_BPTC_Format: __webpackgi_exports__RGBA_BPTC_Format,
    RGBA_ETC2_EAC_Format: __webpackgi_exports__RGBA_ETC2_EAC_Format,
    RGBA_PVRTC_2BPPV1_Format: __webpackgi_exports__RGBA_PVRTC_2BPPV1_Format,
    RGBA_PVRTC_4BPPV1_Format: __webpackgi_exports__RGBA_PVRTC_4BPPV1_Format,
    RGBA_S3TC_DXT1_Format: __webpackgi_exports__RGBA_S3TC_DXT1_Format,
    RGBA_S3TC_DXT3_Format: __webpackgi_exports__RGBA_S3TC_DXT3_Format,
    RGBA_S3TC_DXT5_Format: __webpackgi_exports__RGBA_S3TC_DXT5_Format,
    RGBM16ColorSpace: __webpackgi_exports__RGBM16ColorSpace,
    RGBM16ColorSpace_: __webpackgi_exports__RGBM16ColorSpace_,
    RGB_BPTC_SIGNED_Format: __webpackgi_exports__RGB_BPTC_SIGNED_Format,
    RGB_BPTC_UNSIGNED_Format: __webpackgi_exports__RGB_BPTC_UNSIGNED_Format,
    RGB_ETC1_Format: __webpackgi_exports__RGB_ETC1_Format,
    RGB_ETC2_Format: __webpackgi_exports__RGB_ETC2_Format,
    RGB_PVRTC_2BPPV1_Format: __webpackgi_exports__RGB_PVRTC_2BPPV1_Format,
    RGB_PVRTC_4BPPV1_Format: __webpackgi_exports__RGB_PVRTC_4BPPV1_Format,
    RGB_S3TC_DXT1_Format: __webpackgi_exports__RGB_S3TC_DXT1_Format,
    RGFormat: __webpackgi_exports__RGFormat,
    RGIntegerFormat: __webpackgi_exports__RGIntegerFormat,
    RainbowDiamondPlugin: __webpackgi_exports__RainbowDiamondPlugin,
    RandomizedDirectionalLight: __webpackgi_exports__RandomizedDirectionalLight,
    RandomizedDirectionalLightPlugin: __webpackgi_exports__RandomizedDirectionalLightPlugin,
    RawShaderMaterial: __webpackgi_exports__RawShaderMaterial,
    Ray: __webpackgi_exports__Ray,
    Raycaster: __webpackgi_exports__Raycaster,
    Rec709Primaries: __webpackgi_exports__Rec709Primaries,
    RectAreaLight: __webpackgi_exports__RectAreaLight,
    RedFormat: __webpackgi_exports__RedFormat,
    RedIntegerFormat: __webpackgi_exports__RedIntegerFormat,
    Reflector2: __webpackgi_exports__Reflector2,
    ReinhardToneMapping: __webpackgi_exports__ReinhardToneMapping,
    RenderTarget: __webpackgi_exports__RenderTarget,
    RendererUiPlugin: __webpackgi_exports__RendererUiPlugin,
    RepeatWrapping: __webpackgi_exports__RepeatWrapping,
    ReplaceStencilOp: __webpackgi_exports__ReplaceStencilOp,
    ReverseSubtractEquation: __webpackgi_exports__ReverseSubtractEquation,
    Rhino3dmLoadPlugin: __webpackgi_exports__Rhino3dmLoadPlugin,
    Rhino3dmLoader2: __webpackgi_exports__Rhino3dmLoader2,
    RingGeometry: __webpackgi_exports__RingGeometry,
    RootScene: __webpackgi_exports__RootScene,
    SIGNED_RED_GREEN_RGTC2_Format: __webpackgi_exports__SIGNED_RED_GREEN_RGTC2_Format,
    SIGNED_RED_RGTC1_Format: __webpackgi_exports__SIGNED_RED_RGTC1_Format,
    SRGBColorSpace: __webpackgi_exports__SRGBColorSpace,
    SRGBTransfer: __webpackgi_exports__SRGBTransfer,
    SSAOPlugin: __webpackgi_exports__SSAOPlugin,
    SSBevelPass: __webpackgi_exports__SSBevelPass,
    SSBevelPlugin: __webpackgi_exports__SSBevelPlugin,
    SSContactShadows: __webpackgi_exports__SSContactShadows,
    SSGIPlugin: __webpackgi_exports__SSGIPlugin,
    SSRPlugin: __webpackgi_exports__SSRPlugin,
    STLLoadPlugin: __webpackgi_exports__STLLoadPlugin,
    Scene: __webpackgi_exports__Scene,
    SceneCamerasUiPlugin: __webpackgi_exports__SceneCamerasUiPlugin,
    SceneLoopPlugin: __webpackgi_exports__SceneLoopPlugin,
    ScrollableCameraViewPlugin: __webpackgi_exports__ScrollableCameraViewPlugin,
    ScrollableCameraViewPreviewPlugin: __webpackgi_exports__ScrollableCameraViewPreviewPlugin,
    SelectionWidget: __webpackgi_exports__SelectionWidget,
    ShaderChunk: __webpackgi_exports__ShaderChunk,
    ShaderLib: __webpackgi_exports__ShaderLib,
    ShaderMaterial: __webpackgi_exports__ShaderMaterial,
    ShaderMaterial2: __webpackgi_exports__ShaderMaterial2,
    ShaderMaterialEncodingSupport: __webpackgi_exports__ShaderMaterialEncodingSupport,
    ShaderPass2: __webpackgi_exports__ShaderPass2,
    ShadowMapBaker: __webpackgi_exports__ShadowMapBaker,
    ShadowMaterial: __webpackgi_exports__ShadowMaterial,
    Shape: __webpackgi_exports__Shape,
    ShapeGeometry: __webpackgi_exports__ShapeGeometry,
    ShapePath: __webpackgi_exports__ShapePath,
    ShapeTubeExtrudePlugin: __webpackgi_exports__ShapeTubeExtrudePlugin,
    ShapeUtils: __webpackgi_exports__ShapeUtils,
    ShortType: __webpackgi_exports__ShortType,
    SimpleAssetList: __webpackgi_exports__SimpleAssetList,
    SimpleBackgroundEnvUiPlugin: __webpackgi_exports__SimpleBackgroundEnvUiPlugin,
    SimpleDataSource: __webpackgi_exports__SimpleDataSource,
    SimpleEventDispatcher: __webpackgi_exports__SimpleEventDispatcher,
    SimpleJSONExporter: __webpackgi_exports__SimpleJSONExporter,
    SimpleJSONLoader: __webpackgi_exports__SimpleJSONLoader,
    SimpleTextExporter: __webpackgi_exports__SimpleTextExporter,
    SimpleTextPlugin: __webpackgi_exports__SimpleTextPlugin,
    SimpleViewerUi: __webpackgi_exports__SimpleViewerUi,
    SimplifyModifierPlugin: __webpackgi_exports__SimplifyModifierPlugin,
    Skeleton: __webpackgi_exports__Skeleton,
    SkeletonHelper: __webpackgi_exports__SkeletonHelper,
    SkinnedMesh: __webpackgi_exports__SkinnedMesh,
    SnowFallPlugin: __webpackgi_exports__SnowFallPlugin,
    Source: __webpackgi_exports__Source,
    Sphere: __webpackgi_exports__Sphere,
    SphereGeometry: __webpackgi_exports__SphereGeometry,
    SphereSelectionWidget: __webpackgi_exports__SphereSelectionWidget,
    Spherical: __webpackgi_exports__Spherical,
    SphericalHarmonics3: __webpackgi_exports__SphericalHarmonics3,
    SplineCurve: __webpackgi_exports__SplineCurve,
    SpotLight: __webpackgi_exports__SpotLight,
    SpotLight2: __webpackgi_exports__SpotLight2,
    SpotLightHelper: __webpackgi_exports__SpotLightHelper,
    Sprite: __webpackgi_exports__Sprite,
    SpriteMaterial: __webpackgi_exports__SpriteMaterial,
    SrcAlphaFactor: __webpackgi_exports__SrcAlphaFactor,
    SrcAlphaSaturateFactor: __webpackgi_exports__SrcAlphaSaturateFactor,
    SrcColorFactor: __webpackgi_exports__SrcColorFactor,
    StaticCopyUsage: __webpackgi_exports__StaticCopyUsage,
    StaticDrawUsage: __webpackgi_exports__StaticDrawUsage,
    StaticReadUsage: __webpackgi_exports__StaticReadUsage,
    StereoCamera: __webpackgi_exports__StereoCamera,
    StreamCopyUsage: __webpackgi_exports__StreamCopyUsage,
    StreamDrawUsage: __webpackgi_exports__StreamDrawUsage,
    StreamReadUsage: __webpackgi_exports__StreamReadUsage,
    StringKeyframeTrack: __webpackgi_exports__StringKeyframeTrack,
    SubtractEquation: __webpackgi_exports__SubtractEquation,
    SubtractiveBlending: __webpackgi_exports__SubtractiveBlending,
    SwitchNodeBasePlugin: __webpackgi_exports__SwitchNodeBasePlugin,
    SwitchNodePlugin: __webpackgi_exports__SwitchNodePlugin,
    TOUCH: __webpackgi_exports__TOUCH,
    TYPED_ARRAYS: __webpackgi_exports__TYPED_ARRAYS,
    TangentSpaceNormalMap: __webpackgi_exports__TangentSpaceNormalMap,
    TemporalAAPlugin: __webpackgi_exports__TemporalAAPlugin,
    TetrahedronGeometry: __webpackgi_exports__TetrahedronGeometry,
    TextSVGOptions: __webpackgi_exports__TextSVGOptions,
    Texture: __webpackgi_exports__Texture,
    TextureLoader: __webpackgi_exports__TextureLoader,
    ThinFilmLayerPlugin: __webpackgi_exports__ThinFilmLayerPlugin,
    ThreeMaterialLoader: __webpackgi_exports__ThreeMaterialLoader,
    TonemapPlugin: __webpackgi_exports__TonemapPlugin,
    TorusGeometry: __webpackgi_exports__TorusGeometry,
    TorusKnotGeometry: __webpackgi_exports__TorusKnotGeometry,
    TrackballControlsPlugin: __webpackgi_exports__TrackballControlsPlugin,
    TransformAnimationPlugin: __webpackgi_exports__TransformAnimationPlugin,
    TransformControls: __webpackgi_exports__TransformControls,
    TransformControls2: __webpackgi_exports__TransformControls2,
    TransformControlsGizmo: __webpackgi_exports__TransformControlsGizmo,
    TransformControlsPlane: __webpackgi_exports__TransformControlsPlane,
    TransfrSharePlugin: __webpackgi_exports__TransfrSharePlugin,
    Triangle: __webpackgi_exports__Triangle,
    TriangleFanDrawMode: __webpackgi_exports__TriangleFanDrawMode,
    TriangleStripDrawMode: __webpackgi_exports__TriangleStripDrawMode,
    TrianglesDrawMode: __webpackgi_exports__TrianglesDrawMode,
    TriplanarUVMappingPlugin: __webpackgi_exports__TriplanarUVMappingPlugin,
    TubeGeometry: __webpackgi_exports__TubeGeometry,
    TubeShapeGeometry: __webpackgi_exports__TubeShapeGeometry,
    TweakpaneUiPlugin: __webpackgi_exports__TweakpaneUiPlugin,
    TweakpaneWrapper: __webpackgi_exports__TweakpaneWrapper,
    TwoPassDoubleSide: __webpackgi_exports__TwoPassDoubleSide,
    UChartOptions: __webpackgi_exports__UChartOptions,
    UPackOptions: __webpackgi_exports__UPackOptions,
    UVMapping: __webpackgi_exports__UVMapping,
    Uint16BufferAttribute: __webpackgi_exports__Uint16BufferAttribute,
    Uint32BufferAttribute: __webpackgi_exports__Uint32BufferAttribute,
    Uint8BufferAttribute: __webpackgi_exports__Uint8BufferAttribute,
    Uint8ClampedBufferAttribute: __webpackgi_exports__Uint8ClampedBufferAttribute,
    Uncharted2Tonemapping: __webpackgi_exports__Uncharted2Tonemapping,
    Uniform: __webpackgi_exports__Uniform,
    UniformsGroup: __webpackgi_exports__UniformsGroup,
    UniformsLib: __webpackgi_exports__UniformsLib,
    UniformsUtils: __webpackgi_exports__UniformsUtils,
    UnsignedByteType: __webpackgi_exports__UnsignedByteType,
    UnsignedInt248Type: __webpackgi_exports__UnsignedInt248Type,
    UnsignedIntType: __webpackgi_exports__UnsignedIntType,
    UnsignedShort4444Type: __webpackgi_exports__UnsignedShort4444Type,
    UnsignedShort5551Type: __webpackgi_exports__UnsignedShort5551Type,
    UnsignedShortType: __webpackgi_exports__UnsignedShortType,
    Unzip: __webpackgi_exports__Unzip,
    UnzipInflate: __webpackgi_exports__UnzipInflate,
    UnzipPassThrough: __webpackgi_exports__UnzipPassThrough,
    Unzlib: __webpackgi_exports__Unzlib,
    VJSONPresetGroup: __webpackgi_exports__VJSONPresetGroup,
    VRPluginBasic: __webpackgi_exports__VRPluginBasic,
    VSMShadowMap: __webpackgi_exports__VSMShadowMap,
    VariationConfiguratorEditorUiPlugin: __webpackgi_exports__VariationConfiguratorEditorUiPlugin,
    VariationConfiguratorGridUiPlugin: __webpackgi_exports__VariationConfiguratorGridUiPlugin,
    VariationConfiguratorPlugin: __webpackgi_exports__VariationConfiguratorPlugin,
    Vector2: __webpackgi_exports__Vector2,
    Vector3: __webpackgi_exports__Vector3,
    Vector4: __webpackgi_exports__Vector4,
    VectorKeyframeTrack: __webpackgi_exports__VectorKeyframeTrack,
    VelocityBufferPlugin: __webpackgi_exports__VelocityBufferPlugin,
    VideoTexture: __webpackgi_exports__VideoTexture,
    ViewerApp: __webpackgi_exports__ViewerApp,
    ViewerState: __webpackgi_exports__ViewerState,
    VignettePlugin: __webpackgi_exports__VignettePlugin,
    VirtualCamerasPlugin: __webpackgi_exports__VirtualCamerasPlugin,
    WaveGroundPlugin: __webpackgi_exports__WaveGroundPlugin,
    WebGL1Renderer: __webpackgi_exports__WebGL1Renderer,
    WebGL3DRenderTarget: __webpackgi_exports__WebGL3DRenderTarget,
    WebGLArrayRenderTarget: __webpackgi_exports__WebGLArrayRenderTarget,
    WebGLCoordinateSystem: __webpackgi_exports__WebGLCoordinateSystem,
    WebGLCubeRenderTarget: __webpackgi_exports__WebGLCubeRenderTarget,
    WebGLMultipleRenderTargets: __webpackgi_exports__WebGLMultipleRenderTargets,
    WebGLRenderTarget: __webpackgi_exports__WebGLRenderTarget,
    WebGLRenderer: __webpackgi_exports__WebGLRenderer,
    WebGLUtils: __webpackgi_exports__WebGLUtils,
    WebGPUCoordinateSystem: __webpackgi_exports__WebGPUCoordinateSystem,
    WebGiViewerElement: __webpackgi_exports__WebGiViewerElement,
    WindowiseDialogPlugin: __webpackgi_exports__WindowiseDialogPlugin,
    Wireframe: __webpackgi_exports__Wireframe,
    WireframeGeometry: __webpackgi_exports__WireframeGeometry,
    WireframeGeometry2: __webpackgi_exports__WireframeGeometry2,
    WrapAroundEnding: __webpackgi_exports__WrapAroundEnding,
    XAtlasPlugin: __webpackgi_exports__XAtlasPlugin,
    ZeroCurvatureEnding: __webpackgi_exports__ZeroCurvatureEnding,
    ZeroFactor: __webpackgi_exports__ZeroFactor,
    ZeroSlopeEnding: __webpackgi_exports__ZeroSlopeEnding,
    ZeroStencilOp: __webpackgi_exports__ZeroStencilOp,
    Zip: __webpackgi_exports__Zip,
    ZipDeflate: __webpackgi_exports__ZipDeflate,
    ZipLoader: __webpackgi_exports__ZipLoader,
    ZipPassThrough: __webpackgi_exports__ZipPassThrough,
    Zlib: __webpackgi_exports__Zlib,
    _SRGBAFormat: __webpackgi_exports___SRGBAFormat,
    absMax: __webpackgi_exports__absMax,
    addBasePlugins: __webpackgi_exports__addBasePlugins,
    addBloomData: __webpackgi_exports__addBloomData,
    addDracoLoader: __webpackgi_exports__addDracoLoader,
    addEditorPlugins: __webpackgi_exports__addEditorPlugins,
    addGLTFExporter: __webpackgi_exports__addGLTFExporter,
    addGLTFLoader: __webpackgi_exports__addGLTFLoader,
    addLUTData: __webpackgi_exports__addLUTData,
    addRGBELoader: __webpackgi_exports__addRGBELoader,
    addSSBevel: __webpackgi_exports__addSSBevel,
    aesGcmDecrypt: __webpackgi_exports__aesGcmDecrypt,
    aesGcmEncrypt: __webpackgi_exports__aesGcmEncrypt,
    afterMain: __webpackgi_exports__afterMain,
    afterRead: __webpackgi_exports__afterRead,
    afterWrite: __webpackgi_exports__afterWrite,
    angle: __webpackgi_exports__angle,
    animate: __webpackgi_exports__animate,
    animateAsync: __webpackgi_exports__animateAsync,
    animateObject: __webpackgi_exports__animateObject,
    animateSet: __webpackgi_exports__animateSet,
    animateTarget: __webpackgi_exports__animateTarget,
    anticipate: __webpackgi_exports__anticipate,
    applyOffset: __webpackgi_exports__applyOffset,
    applyStyles: __webpackgi_exports__applyStyles,
    arrayBufferToBase64: __webpackgi_exports__arrayBufferToBase64,
    arrow: __webpackgi_exports__arrow,
    attract: __webpackgi_exports__attract,
    attractExpo: __webpackgi_exports__attractExpo,
    auto: __webpackgi_exports__auto,
    autoCenterObject3D: __webpackgi_exports__autoCenterObject3D,
    autoGPUInstanceMeshes: __webpackgi_exports__autoGPUInstanceMeshes,
    autoScaleObject3D: __webpackgi_exports__autoScaleObject3D,
    backIn: __webpackgi_exports__backIn,
    backInOut: __webpackgi_exports__backInOut,
    backOut: __webpackgi_exports__backOut,
    base64ToArrayBuffer: __webpackgi_exports__base64ToArrayBuffer,
    basePlacements: __webpackgi_exports__basePlacements,
    basicMaterialPropList: __webpackgi_exports__basicMaterialPropList,
    beforeMain: __webpackgi_exports__beforeMain,
    beforeRead: __webpackgi_exports__beforeRead,
    beforeWrite: __webpackgi_exports__beforeWrite,
    blobToDataURL: __webpackgi_exports__blobToDataURL,
    bottom: __webpackgi_exports__bottom,
    bounceIn: __webpackgi_exports__bounceIn,
    bounceInOut: __webpackgi_exports__bounceInOut,
    bounceOut: __webpackgi_exports__bounceOut,
    buildCSGMeshBSP: __webpackgi_exports__buildCSGMeshBSP,
    buildCSGMeshBVH: __webpackgi_exports__buildCSGMeshBVH,
    cLinearToRGBM: __webpackgi_exports__cLinearToRGBM,
    cRGBMToLinear: __webpackgi_exports__cRGBMToLinear,
    circIn: __webpackgi_exports__circIn,
    circInOut: __webpackgi_exports__circInOut,
    circOut: __webpackgi_exports__circOut,
    clamp: __webpackgi_exports__clamp,
    clippingParents: __webpackgi_exports__clippingParents,
    colorToDataUrl: __webpackgi_exports__colorToDataUrl,
    combineDofShader: __webpackgi_exports__combineDofShader,
    compress: __webpackgi_exports__compress,
    compressSync: __webpackgi_exports__compressSync,
    computeAverageGeometryNormal: __webpackgi_exports__computeAverageGeometryNormal,
    computeEigenVectors: __webpackgi_exports__computeEigenVectors,
    computeGeometryCenter: __webpackgi_exports__computeGeometryCenter,
    computeGeometrySize: __webpackgi_exports__computeGeometrySize,
    computeMikkTSpaceTangents: __webpackgi_exports__computeMikkTSpaceTangents,
    computeMorphedAttributes: __webpackgi_exports__computeMorphedAttributes,
    computeOffsetMatrix: __webpackgi_exports__computeOffsetMatrix,
    computeScreenSpaceBoundingBox: __webpackgi_exports__computeScreenSpaceBoundingBox,
    computeStyles: __webpackgi_exports__computeStyles,
    copyMaterialUserData: __webpackgi_exports__copyMaterialUserData,
    copyObject3DUserData: __webpackgi_exports__copyObject3DUserData,
    copyProps: __webpackgi_exports__copyProps,
    copyTextureUserData: __webpackgi_exports__copyTextureUserData,
    createAnticipate: __webpackgi_exports__createAnticipate,
    createAttractor: __webpackgi_exports__createAttractor,
    createBackIn: __webpackgi_exports__createBackIn,
    createCanvasElement: __webpackgi_exports__createCanvasElement,
    createDiv: __webpackgi_exports__createDiv,
    createExpoIn: __webpackgi_exports__createExpoIn,
    createGenericExtensionClass: __webpackgi_exports__createGenericExtensionClass,
    createIFrameCSS3DObject: __webpackgi_exports__createIFrameCSS3DObject,
    createImage: __webpackgi_exports__createImage,
    createPopper: __webpackgi_exports__createPopper,
    createPopperBase: __webpackgi_exports__createPopperBase,
    createPopperLite: __webpackgi_exports__createPopperLite,
    createRenderTargetKey: __webpackgi_exports__createRenderTargetKey,
    createScriptFromURL: __webpackgi_exports__createScriptFromURL,
    createStyles: __webpackgi_exports__createStyles,
    csgOperations: __webpackgi_exports__csgOperations,
    css: __webpackgi_exports__css,
    cubicBezier: __webpackgi_exports__cubicBezier,
    dataTextureFromColor: __webpackgi_exports__dataTextureFromColor,
    dataTextureFromVec4: __webpackgi_exports__dataTextureFromVec4,
    decay: __webpackgi_exports__decay,
    decompress: __webpackgi_exports__decompress,
    decompressSync: __webpackgi_exports__decompressSync,
    deepAccessObject: __webpackgi_exports__deepAccessObject,
    deepCloneAttribute: __webpackgi_exports__deepCloneAttribute,
    defaultPresets: __webpackgi_exports__defaultPresets,
    deflate: __webpackgi_exports__deflate,
    deflateSync: __webpackgi_exports__deflateSync,
    degreesToRadians: __webpackgi_exports__degreesToRadians,
    deinterleaveAttribute: __webpackgi_exports__deinterleaveAttribute,
    deinterleaveGeometry: __webpackgi_exports__deinterleaveGeometry,
    deserializeObject: __webpackgi_exports__deserializeObject,
    deserializers: __webpackgi_exports__deserializers,
    detectOverflow: __webpackgi_exports__detectOverflow,
    diamondMaterialPropList: __webpackgi_exports__diamondMaterialPropList,
    distance: __webpackgi_exports__distance,
    downloadBlob: __webpackgi_exports__downloadBlob,
    downloadFile: __webpackgi_exports__downloadFile,
    easeIn: __webpackgi_exports__easeIn,
    easeInOut: __webpackgi_exports__easeInOut,
    easeOut: __webpackgi_exports__easeOut,
    embedUrlRefs: __webpackgi_exports__embedUrlRefs,
    end: __webpackgi_exports__end,
    envMapBackground: __webpackgi_exports__envMapBackground,
    escapeRegExp: __webpackgi_exports__escapeRegExp,
    estimateBytesUsed: __webpackgi_exports__estimateBytesUsed,
    eventListeners: __webpackgi_exports__eventListeners,
    extractAnimationKey: __webpackgi_exports__extractAnimationKey,
    flattenUiConfig: __webpackgi_exports__flattenUiConfig,
    flip: __webpackgi_exports__flip,
    fontFormatExtensionMap: __webpackgi_exports__fontFormatExtensionMap,
    generateUiConfig: __webpackgi_exports__generateUiConfig,
    generateUiFolder: __webpackgi_exports__generateUiFolder,
    getFileHandle: __webpackgi_exports__getFileHandle,
    getFilenameFromPath: __webpackgi_exports__getFilenameFromPath,
    getKeyByValue: __webpackgi_exports__getKeyByValue,
    getNewFileHandle: __webpackgi_exports__getNewFileHandle,
    getOrCall: __webpackgi_exports__getOrCall,
    getPropertyDescriptor: __webpackgi_exports__getPropertyDescriptor,
    getTexelDecoding: __webpackgi_exports__getTexelDecoding,
    getTexelDecodingFunction: __webpackgi_exports__getTexelDecodingFunction,
    getTextureDataType: __webpackgi_exports__getTextureDataType,
    getTypedArray: __webpackgi_exports__getTypedArray,
    getUrlQueryParam: __webpackgi_exports__getUrlQueryParam,
    glbEncryptionPreparser: __webpackgi_exports__glbEncryptionPreparser,
    glsl: __webpackgi_exports__glsl,
    gltfExporterMaterialsVariantsExtensionExport: __webpackgi_exports__gltfExporterMaterialsVariantsExtensionExport,
    gunzip: __webpackgi_exports__gunzip,
    gunzipSync: __webpackgi_exports__gunzipSync,
    gzip: __webpackgi_exports__gzip,
    gzipSync: __webpackgi_exports__gzipSync,
    hide: __webpackgi_exports__hide,
    html: __webpackgi_exports__html,
    htmlToCanvas: __webpackgi_exports__htmlToCanvas,
    htmlToPng: __webpackgi_exports__htmlToPng,
    htmlToSvg: __webpackgi_exports__htmlToSvg,
    iGeometryIgnoredUserData: __webpackgi_exports__iGeometryIgnoredUserData,
    iMaterialIgnoredUserData: __webpackgi_exports__iMaterialIgnoredUserData,
    iModelIgnoredUserData: __webpackgi_exports__iModelIgnoredUserData,
    iTextureIgnoredUserData: __webpackgi_exports__iTextureIgnoredUserData,
    imageBitmapToBase64: __webpackgi_exports__imageBitmapToBase64,
    imageDataToCanvas: __webpackgi_exports__imageDataToCanvas,
    imageToCanvas: __webpackgi_exports__imageToCanvas,
    imageUrlToImageData: __webpackgi_exports__imageUrlToImageData,
    includesAll: __webpackgi_exports__includesAll,
    inertia: __webpackgi_exports__inertia,
    inflate: __webpackgi_exports__inflate,
    inflateSync: __webpackgi_exports__inflateSync,
    interleaveAttributes: __webpackgi_exports__interleaveAttributes,
    interpolate: __webpackgi_exports__interpolate,
    isAnimatableType: __webpackgi_exports__isAnimatableType,
    isPoint: __webpackgi_exports__isPoint,
    isPoint3D: __webpackgi_exports__isPoint3D,
    isPropertyWritable: __webpackgi_exports__isPropertyWritable,
    keyframes: __webpackgi_exports__keyframes,
    khrMaterialsVariantsGLTF: __webpackgi_exports__khrMaterialsVariantsGLTF,
    left: __webpackgi_exports__left,
    lerpAngle: __webpackgi_exports__lerpAngle,
    lerpAngle2: __webpackgi_exports__lerpAngle2,
    linear: __webpackgi_exports__linear,
    longestCommonPrefix: __webpackgi_exports__longestCommonPrefix,
    main: __webpackgi_exports__main,
    makeColorSvg: __webpackgi_exports__makeColorSvg,
    makeColorSvgCircle: __webpackgi_exports__makeColorSvgCircle,
    makeFilter: __webpackgi_exports__makeFilter,
    makeSamplerUi: __webpackgi_exports__makeSamplerUi,
    makeSetterFor: __webpackgi_exports__makeSetterFor,
    makeTextSvg: __webpackgi_exports__makeTextSvg,
    matDefine: __webpackgi_exports__matDefine,
    mergeAttributes: __webpackgi_exports__mergeAttributes,
    mergeBufferAttributes: __webpackgi_exports__mergeBufferAttributes,
    mergeBufferGeometries: __webpackgi_exports__mergeBufferGeometries,
    mergeGeometries: __webpackgi_exports__mergeGeometries,
    mergeGroups: __webpackgi_exports__mergeGroups,
    mergeVertices: __webpackgi_exports__mergeVertices,
    mirrorEasing: __webpackgi_exports__mirrorEasing,
    mix: __webpackgi_exports__mix,
    mixColor: __webpackgi_exports__mixColor,
    mixComplex: __webpackgi_exports__mixComplex,
    mobileAndTabletCheck: __webpackgi_exports__mobileAndTabletCheck,
    modifierPhases: __webpackgi_exports__modifierPhases,
    now: __webpackgi_exports__now,
    objectHasOwn: __webpackgi_exports__objectHasOwn,
    offset: __webpackgi_exports__offset,
    onChange: __webpackgi_exports__onChange,
    onChange2: __webpackgi_exports__onChange2,
    onChange3: __webpackgi_exports__onChange3,
    parseFileExtension: __webpackgi_exports__parseFileExtension,
    patchShaderEncodingSupport: __webpackgi_exports__patchShaderEncodingSupport,
    pathJoin: __webpackgi_exports__pathJoin,
    physicalMaterialPropList: __webpackgi_exports__physicalMaterialPropList,
    pipe: __webpackgi_exports__pipe,
    pivotToBBoxCenter: __webpackgi_exports__pivotToBBoxCenter,
    pivotToPoint: __webpackgi_exports__pivotToPoint,
    placements: __webpackgi_exports__placements,
    pointFromVector: __webpackgi_exports__pointFromVector,
    popper: __webpackgi_exports__popper,
    popperGenerator: __webpackgi_exports__popperGenerator,
    popperOffsets: __webpackgi_exports__popperOffsets,
    prettyScrollbar: __webpackgi_exports__prettyScrollbar,
    preventOverflow: __webpackgi_exports__preventOverflow,
    processViewer: __webpackgi_exports__processViewer,
    progress: __webpackgi_exports__progress,
    radiansToDegrees: __webpackgi_exports__radiansToDegrees,
    read: __webpackgi_exports__read,
    readFile: __webpackgi_exports__readFile,
    reference: __webpackgi_exports__reference,
    remoteWorkerURL: __webpackgi_exports__remoteWorkerURL,
    removeDuplicateGeometries: __webpackgi_exports__removeDuplicateGeometries,
    replaceAll: __webpackgi_exports__replaceAll,
    reverseEasing: __webpackgi_exports__reverseEasing,
    right: __webpackgi_exports__right,
    rotateDuplicatedMesh: __webpackgi_exports__rotateDuplicatedMesh,
    sRGBEncoding: __webpackgi_exports__sRGBEncoding,
    safeSetProperty: __webpackgi_exports__safeSetProperty,
    serializable: __webpackgi_exports__serializable,
    serialize: __webpackgi_exports__serialize,
    serializeObject: __webpackgi_exports__serializeObject,
    serializeTextureInExtras: __webpackgi_exports__serializeTextureInExtras,
    serializers: __webpackgi_exports__serializers,
    setMeshGeometry: __webpackgi_exports__setMeshGeometry,
    setMeshMaterial: __webpackgi_exports__setMeshMaterial,
    setThreeRendererMode: __webpackgi_exports__setThreeRendererMode,
    setUrlQueryParam: __webpackgi_exports__setUrlQueryParam,
    setupCoreWebGiViewer: __webpackgi_exports__setupCoreWebGiViewer,
    setupIModel: __webpackgi_exports__setupIModel,
    setupModesStyles: __webpackgi_exports__setupModesStyles,
    setupModesUi: __webpackgi_exports__setupModesUi,
    setupObject3dModel: __webpackgi_exports__setupObject3dModel,
    setupSandboxWebGiEditor: __webpackgi_exports__setupSandboxWebGiEditor,
    shaderReplaceString: __webpackgi_exports__shaderReplaceString,
    sign2: __webpackgi_exports__sign2,
    slerp: __webpackgi_exports__slerp,
    smooth: __webpackgi_exports__smooth,
    smoothFrame: __webpackgi_exports__smoothFrame,
    snap: __webpackgi_exports__snap,
    snapObject: __webpackgi_exports__snapObject,
    sphericalFromObject: __webpackgi_exports__sphericalFromObject,
    spring: __webpackgi_exports__spring,
    standardMaterialPropList: __webpackgi_exports__standardMaterialPropList,
    start: __webpackgi_exports__start,
    steps: __webpackgi_exports__steps,
    strFromU8: __webpackgi_exports__strFromU8,
    strToU8: __webpackgi_exports__strToU8,
    supportsRequestStreams: __webpackgi_exports__supportsRequestStreams,
    svgToCanvas: __webpackgi_exports__svgToCanvas,
    svgToPng: __webpackgi_exports__svgToPng,
    svgUrl: __webpackgi_exports__svgUrl,
    texImageToCanvas: __webpackgi_exports__texImageToCanvas,
    textureDataToImageData: __webpackgi_exports__textureDataToImageData,
    textureToCanvas: __webpackgi_exports__textureToCanvas,
    textureToDataUrl: __webpackgi_exports__textureToDataUrl,
    timeout: __webpackgi_exports__timeout,
    toCreasedNormals: __webpackgi_exports__toCreasedNormals,
    toDecimal: __webpackgi_exports__toDecimal,
    toIndexedGeometry: __webpackgi_exports__toIndexedGeometry,
    toTitleCase: __webpackgi_exports__toTitleCase,
    toTrianglesDrawMode: __webpackgi_exports__toTrianglesDrawMode,
    top: __webpackgi_exports__top,
    uiButton: __webpackgi_exports__uiButton,
    uiColor: __webpackgi_exports__uiColor,
    uiConfig: __webpackgi_exports__uiConfig,
    uiDropdown: __webpackgi_exports__uiDropdown,
    uiFolder: __webpackgi_exports__uiFolder,
    uiImage: __webpackgi_exports__uiImage,
    uiInput: __webpackgi_exports__uiInput,
    uiMonitor: __webpackgi_exports__uiMonitor,
    uiPanel: __webpackgi_exports__uiPanel,
    uiSlider: __webpackgi_exports__uiSlider,
    uiToggle: __webpackgi_exports__uiToggle,
    uiVector: __webpackgi_exports__uiVector,
    uniform: __webpackgi_exports__uniform,
    unzip: __webpackgi_exports__unzip,
    unzipSync: __webpackgi_exports__unzipSync,
    unzlib: __webpackgi_exports__unzlib,
    unzlibSync: __webpackgi_exports__unzlibSync,
    uploadFile: __webpackgi_exports__uploadFile,
    vLinearToRGBM: __webpackgi_exports__vLinearToRGBM,
    vRGBMToLinear: __webpackgi_exports__vRGBMToLinear,
    valueToUiType: __webpackgi_exports__valueToUiType,
    variationPlacements: __webpackgi_exports__variationPlacements,
    velocityPerFrame: __webpackgi_exports__velocityPerFrame,
    velocityPerSecond: __webpackgi_exports__velocityPerSecond,
    verifyPermission: __webpackgi_exports__verifyPermission,
    viewport: __webpackgi_exports__viewport,
    wrap: __webpackgi_exports__wrap,
    write: __webpackgi_exports__write,
    writeFile: __webpackgi_exports__writeFile,
    zip: __webpackgi_exports__zip,
    zipSync: __webpackgi_exports__zipSync,
    zlib: __webpackgi_exports__zlib,
    zlibSync: __webpackgi_exports__zlibSync
}, Symbol.toStringTag, {
    value: "Module"
}))
  , w0 = class w0 extends __webpackgi_exports__AViewerPlugin {
    constructor() {
        super(...arguments),
        this.enabled = !0,
        this.materials = [],
        this.presets = {},
        this.getMaterialPresetByName = o => !this.presets || this.presets.length == 0 ? null : this.presets[o.type].find(c => c.path.split("/").pop() == o.name)
    }
    async onAdded(o) {
        await super.onAdded(o)
    }
    loadPresets(o, c) {
        this.presets = o,
        this.basePath = c,
        this.dispatchEvent({
            type: "deserialize"
        })
    }
    exportPresets() {
        return {
            materials: this.materials,
            type: w0.PluginType
        }
    }
    async fromJSON(o, c) {
        if (!super.fromJSON(o, c))
            return null;
        const h = o.materials;
        if (!h)
            return null;
        const _ = [];
        for (const b of h)
            _.push(this.apply(b.name, b.path));
        return await Promise.all(_),
        this.dispatchEvent({
            type: "deserialize"
        }),
        this
    }
    async apply(o, c) {
        var nt, it, at, ut, pt;
        const h = (nt = this._viewer) == null ? void 0 : nt.getManager()
          , _ = (at = await ((it = h == null ? void 0 : h.importer) == null ? void 0 : it.importSinglePath(c))) == null ? void 0 : at.clone();
        if (!_)
            return "Unable to load material";
        _.name = o;
        const b = new Set;
        (pt = (ut = this._viewer) == null ? void 0 : ut.scene) == null || pt.traverse(ht => {
            ht.isMesh && ht.material.name === o && b.add(ht)
        }
        ),
        b.forEach(ht => {
            var _t;
            (_t = ht == null ? void 0 : ht.setMaterial) == null || _t.call(ht, _),
            ht.material.name = o
        }
        );
        const _e = this.materials.findIndex(ht => ht.name === o);
        _e !== -1 ? this.materials[_e] = {
            name: o,
            path: c
        } : this.materials.push({
            name: o,
            path: c
        })
    }
}
;
w0.PluginType = "MaterialPresetPlugin";
let MaterialPresetPlugin = w0;
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {}
  , react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$1 = Symbol.for("react.element")
  , n$1 = Symbol.for("react.portal")
  , p$2 = Symbol.for("react.fragment")
  , q$1 = Symbol.for("react.strict_mode")
  , r = Symbol.for("react.profiler")
  , t = Symbol.for("react.provider")
  , u = Symbol.for("react.context")
  , v$2 = Symbol.for("react.forward_ref")
  , w = Symbol.for("react.suspense")
  , x = Symbol.for("react.memo")
  , y = Symbol.for("react.lazy")
  , z$1 = Symbol.iterator;
function A$1(d) {
    return d === null || typeof d != "object" ? null : (d = z$1 && d[z$1] || d["@@iterator"],
    typeof d == "function" ? d : null)
}
var B$1 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$1 = Object.assign
  , D$1 = {};
function E$1(d, o, c) {
    this.props = d,
    this.context = o,
    this.refs = D$1,
    this.updater = c || B$1
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(d, o) {
    if (typeof d != "object" && typeof d != "function" && d != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, d, o, "setState")
}
;
E$1.prototype.forceUpdate = function(d) {
    this.updater.enqueueForceUpdate(this, d, "forceUpdate")
}
;
function F() {}
F.prototype = E$1.prototype;
function G$1(d, o, c) {
    this.props = d,
    this.context = o,
    this.refs = D$1,
    this.updater = c || B$1
}
var H$1 = G$1.prototype = new F;
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray
  , J = Object.prototype.hasOwnProperty
  , K$1 = {
    current: null
}
  , L$1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$1(d, o, c) {
    var h, _ = {}, b = null, _e = null;
    if (o != null)
        for (h in o.ref !== void 0 && (_e = o.ref),
        o.key !== void 0 && (b = "" + o.key),
        o)
            J.call(o, h) && !L$1.hasOwnProperty(h) && (_[h] = o[h]);
    var nt = arguments.length - 2;
    if (nt === 1)
        _.children = c;
    else if (1 < nt) {
        for (var it = Array(nt), at = 0; at < nt; at++)
            it[at] = arguments[at + 2];
        _.children = it
    }
    if (d && d.defaultProps)
        for (h in nt = d.defaultProps,
        nt)
            _[h] === void 0 && (_[h] = nt[h]);
    return {
        $$typeof: l$1,
        type: d,
        key: b,
        ref: _e,
        props: _,
        _owner: K$1.current
    }
}
function N$1(d, o) {
    return {
        $$typeof: l$1,
        type: d.type,
        key: o,
        ref: d.ref,
        props: d.props,
        _owner: d._owner
    }
}
function O$1(d) {
    return typeof d == "object" && d !== null && d.$$typeof === l$1
}
function escape$1(d) {
    var o = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + d.replace(/[=:]/g, function(c) {
        return o[c]
    })
}
var P$1 = /\/+/g;
function Q$1(d, o) {
    return typeof d == "object" && d !== null && d.key != null ? escape$1("" + d.key) : o.toString(36)
}
function R$1(d, o, c, h, _) {
    var b = typeof d;
    (b === "undefined" || b === "boolean") && (d = null);
    var _e = !1;
    if (d === null)
        _e = !0;
    else
        switch (b) {
        case "string":
        case "number":
            _e = !0;
            break;
        case "object":
            switch (d.$$typeof) {
            case l$1:
            case n$1:
                _e = !0
            }
        }
    if (_e)
        return _e = d,
        _ = _(_e),
        d = h === "" ? "." + Q$1(_e, 0) : h,
        I$1(_) ? (c = "",
        d != null && (c = d.replace(P$1, "$&/") + "/"),
        R$1(_, o, c, "", function(at) {
            return at
        })) : _ != null && (O$1(_) && (_ = N$1(_, c + (!_.key || _e && _e.key === _.key ? "" : ("" + _.key).replace(P$1, "$&/") + "/") + d)),
        o.push(_)),
        1;
    if (_e = 0,
    h = h === "" ? "." : h + ":",
    I$1(d))
        for (var nt = 0; nt < d.length; nt++) {
            b = d[nt];
            var it = h + Q$1(b, nt);
            _e += R$1(b, o, c, it, _)
        }
    else if (it = A$1(d),
    typeof it == "function")
        for (d = it.call(d),
        nt = 0; !(b = d.next()).done; )
            b = b.value,
            it = h + Q$1(b, nt++),
            _e += R$1(b, o, c, it, _);
    else if (b === "object")
        throw o = String(d),
        Error("Objects are not valid as a React child (found: " + (o === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : o) + "). If you meant to render a collection of children, use an array instead.");
    return _e
}
function S$1(d, o, c) {
    if (d == null)
        return d;
    var h = []
      , _ = 0;
    return R$1(d, h, "", "", function(b) {
        return o.call(c, b, _++)
    }),
    h
}
function T$1(d) {
    if (d._status === -1) {
        var o = d._result;
        o = o(),
        o.then(function(c) {
            (d._status === 0 || d._status === -1) && (d._status = 1,
            d._result = c)
        }, function(c) {
            (d._status === 0 || d._status === -1) && (d._status = 2,
            d._result = c)
        }),
        d._status === -1 && (d._status = 0,
        d._result = o)
    }
    if (d._status === 1)
        return d._result.default;
    throw d._result
}
var U$1 = {
    current: null
}
  , V$1 = {
    transition: null
}
  , W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1
};
function X$1() {
    throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.Children = {
    map: S$1,
    forEach: function(d, o, c) {
        S$1(d, function() {
            o.apply(this, arguments)
        }, c)
    },
    count: function(d) {
        var o = 0;
        return S$1(d, function() {
            o++
        }),
        o
    },
    toArray: function(d) {
        return S$1(d, function(o) {
            return o
        }) || []
    },
    only: function(d) {
        if (!O$1(d))
            throw Error("React.Children.only expected to receive a single React element child.");
        return d
    }
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$2;
react_production_min.Profiler = r;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$1;
react_production_min.cloneElement = function(d, o, c) {
    if (d == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + d + ".");
    var h = C$1({}, d.props)
      , _ = d.key
      , b = d.ref
      , _e = d._owner;
    if (o != null) {
        if (o.ref !== void 0 && (b = o.ref,
        _e = K$1.current),
        o.key !== void 0 && (_ = "" + o.key),
        d.type && d.type.defaultProps)
            var nt = d.type.defaultProps;
        for (it in o)
            J.call(o, it) && !L$1.hasOwnProperty(it) && (h[it] = o[it] === void 0 && nt !== void 0 ? nt[it] : o[it])
    }
    var it = arguments.length - 2;
    if (it === 1)
        h.children = c;
    else if (1 < it) {
        nt = Array(it);
        for (var at = 0; at < it; at++)
            nt[at] = arguments[at + 2];
        h.children = nt
    }
    return {
        $$typeof: l$1,
        type: d.type,
        key: _,
        ref: b,
        props: h,
        _owner: _e
    }
}
;
react_production_min.createContext = function(d) {
    return d = {
        $$typeof: u,
        _currentValue: d,
        _currentValue2: d,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    d.Provider = {
        $$typeof: t,
        _context: d
    },
    d.Consumer = d
}
;
react_production_min.createElement = M$1;
react_production_min.createFactory = function(d) {
    var o = M$1.bind(null, d);
    return o.type = d,
    o
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(d) {
    return {
        $$typeof: v$2,
        render: d
    }
}
;
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(d) {
    return {
        $$typeof: y,
        _payload: {
            _status: -1,
            _result: d
        },
        _init: T$1
    }
}
;
react_production_min.memo = function(d, o) {
    return {
        $$typeof: x,
        type: d,
        compare: o === void 0 ? null : o
    }
}
;
react_production_min.startTransition = function(d) {
    var o = V$1.transition;
    V$1.transition = {};
    try {
        d()
    } finally {
        V$1.transition = o
    }
}
;
react_production_min.unstable_act = X$1;
react_production_min.useCallback = function(d, o) {
    return U$1.current.useCallback(d, o)
}
;
react_production_min.useContext = function(d) {
    return U$1.current.useContext(d)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(d) {
    return U$1.current.useDeferredValue(d)
}
;
react_production_min.useEffect = function(d, o) {
    return U$1.current.useEffect(d, o)
}
;
react_production_min.useId = function() {
    return U$1.current.useId()
}
;
react_production_min.useImperativeHandle = function(d, o, c) {
    return U$1.current.useImperativeHandle(d, o, c)
}
;
react_production_min.useInsertionEffect = function(d, o) {
    return U$1.current.useInsertionEffect(d, o)
}
;
react_production_min.useLayoutEffect = function(d, o) {
    return U$1.current.useLayoutEffect(d, o)
}
;
react_production_min.useMemo = function(d, o) {
    return U$1.current.useMemo(d, o)
}
;
react_production_min.useReducer = function(d, o, c) {
    return U$1.current.useReducer(d, o, c)
}
;
react_production_min.useRef = function(d) {
    return U$1.current.useRef(d)
}
;
react_production_min.useState = function(d) {
    return U$1.current.useState(d)
}
;
react_production_min.useSyncExternalStore = function(d, o, c) {
    return U$1.current.useSyncExternalStore(d, o, c)
}
;
react_production_min.useTransition = function() {
    return U$1.current.useTransition()
}
;
react_production_min.version = "18.3.1";
react.exports = react_production_min;
var reactExports = react.exports;
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = reactExports
  , k = Symbol.for("react.element")
  , l = Symbol.for("react.fragment")
  , m$1 = Object.prototype.hasOwnProperty
  , n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q(d, o, c) {
    var h, _ = {}, b = null, _e = null;
    c !== void 0 && (b = "" + c),
    o.key !== void 0 && (b = "" + o.key),
    o.ref !== void 0 && (_e = o.ref);
    for (h in o)
        m$1.call(o, h) && !p$1.hasOwnProperty(h) && (_[h] = o[h]);
    if (d && d.defaultProps)
        for (h in o = d.defaultProps,
        o)
            _[h] === void 0 && (_[h] = o[h]);
    return {
        $$typeof: k,
        type: d,
        key: b,
        ref: _e,
        props: _,
        _owner: n.current
    }
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports
  , client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(d) {
    function o(gr, dr) {
        var cr = gr.length;
        gr.push(dr);
        e: for (; 0 < cr; ) {
            var Ar = cr - 1 >>> 1
              , wr = gr[Ar];
            if (0 < _(wr, dr))
                gr[Ar] = dr,
                gr[cr] = wr,
                cr = Ar;
            else
                break e
        }
    }
    function c(gr) {
        return gr.length === 0 ? null : gr[0]
    }
    function h(gr) {
        if (gr.length === 0)
            return null;
        var dr = gr[0]
          , cr = gr.pop();
        if (cr !== dr) {
            gr[0] = cr;
            e: for (var Ar = 0, wr = gr.length, Rr = wr >>> 1; Ar < Rr; ) {
                var Cr = 2 * (Ar + 1) - 1
                  , tr = gr[Cr]
                  , fr = Cr + 1
                  , vr = gr[fr];
                if (0 > _(tr, cr))
                    fr < wr && 0 > _(vr, tr) ? (gr[Ar] = vr,
                    gr[fr] = cr,
                    Ar = fr) : (gr[Ar] = tr,
                    gr[Cr] = cr,
                    Ar = Cr);
                else if (fr < wr && 0 > _(vr, cr))
                    gr[Ar] = vr,
                    gr[fr] = cr,
                    Ar = fr;
                else
                    break e
            }
        }
        return dr
    }
    function _(gr, dr) {
        var cr = gr.sortIndex - dr.sortIndex;
        return cr !== 0 ? cr : gr.id - dr.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var b = performance;
        d.unstable_now = function() {
            return b.now()
        }
    } else {
        var _e = Date
          , nt = _e.now();
        d.unstable_now = function() {
            return _e.now() - nt
        }
    }
    var it = []
      , at = []
      , ut = 1
      , pt = null
      , ht = 3
      , _t = !1
      , vt = !1
      , bt = !1
      , St = typeof setTimeout == "function" ? setTimeout : null
      , At = typeof clearTimeout == "function" ? clearTimeout : null
      , Et = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function Pt(gr) {
        for (var dr = c(at); dr !== null; ) {
            if (dr.callback === null)
                h(at);
            else if (dr.startTime <= gr)
                h(at),
                dr.sortIndex = dr.expirationTime,
                o(it, dr);
            else
                break;
            dr = c(at)
        }
    }
    function It(gr) {
        if (bt = !1,
        Pt(gr),
        !vt)
            if (c(it) !== null)
                vt = !0,
                ar(Dt);
            else {
                var dr = c(at);
                dr !== null && hr(It, dr.startTime - gr)
            }
    }
    function Dt(gr, dr) {
        vt = !1,
        bt && (bt = !1,
        At(kt),
        kt = -1),
        _t = !0;
        var cr = ht;
        try {
            for (Pt(dr),
            pt = c(it); pt !== null && (!(pt.expirationTime > dr) || gr && !Kt()); ) {
                var Ar = pt.callback;
                if (typeof Ar == "function") {
                    pt.callback = null,
                    ht = pt.priorityLevel;
                    var wr = Ar(pt.expirationTime <= dr);
                    dr = d.unstable_now(),
                    typeof wr == "function" ? pt.callback = wr : pt === c(it) && h(it),
                    Pt(dr)
                } else
                    h(it);
                pt = c(it)
            }
            if (pt !== null)
                var Rr = !0;
            else {
                var Cr = c(at);
                Cr !== null && hr(It, Cr.startTime - dr),
                Rr = !1
            }
            return Rr
        } finally {
            pt = null,
            ht = cr,
            _t = !1
        }
    }
    var Gt = !1
      , Bt = null
      , kt = -1
      , Ut = 5
      , Ht = -1;
    function Kt() {
        return !(d.unstable_now() - Ht < Ut)
    }
    function Jt() {
        if (Bt !== null) {
            var gr = d.unstable_now();
            Ht = gr;
            var dr = !0;
            try {
                dr = Bt(!0, gr)
            } finally {
                dr ? or() : (Gt = !1,
                Bt = null)
            }
        } else
            Gt = !1
    }
    var or;
    if (typeof Et == "function")
        or = function() {
            Et(Jt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var ir = new MessageChannel
          , lr = ir.port2;
        ir.port1.onmessage = Jt,
        or = function() {
            lr.postMessage(null)
        }
    } else
        or = function() {
            St(Jt, 0)
        }
        ;
    function ar(gr) {
        Bt = gr,
        Gt || (Gt = !0,
        or())
    }
    function hr(gr, dr) {
        kt = St(function() {
            gr(d.unstable_now())
        }, dr)
    }
    d.unstable_IdlePriority = 5,
    d.unstable_ImmediatePriority = 1,
    d.unstable_LowPriority = 4,
    d.unstable_NormalPriority = 3,
    d.unstable_Profiling = null,
    d.unstable_UserBlockingPriority = 2,
    d.unstable_cancelCallback = function(gr) {
        gr.callback = null
    }
    ,
    d.unstable_continueExecution = function() {
        vt || _t || (vt = !0,
        ar(Dt))
    }
    ,
    d.unstable_forceFrameRate = function(gr) {
        0 > gr || 125 < gr ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ut = 0 < gr ? Math.floor(1e3 / gr) : 5
    }
    ,
    d.unstable_getCurrentPriorityLevel = function() {
        return ht
    }
    ,
    d.unstable_getFirstCallbackNode = function() {
        return c(it)
    }
    ,
    d.unstable_next = function(gr) {
        switch (ht) {
        case 1:
        case 2:
        case 3:
            var dr = 3;
            break;
        default:
            dr = ht
        }
        var cr = ht;
        ht = dr;
        try {
            return gr()
        } finally {
            ht = cr
        }
    }
    ,
    d.unstable_pauseExecution = function() {}
    ,
    d.unstable_requestPaint = function() {}
    ,
    d.unstable_runWithPriority = function(gr, dr) {
        switch (gr) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            gr = 3
        }
        var cr = ht;
        ht = gr;
        try {
            return dr()
        } finally {
            ht = cr
        }
    }
    ,
    d.unstable_scheduleCallback = function(gr, dr, cr) {
        var Ar = d.unstable_now();
        switch (typeof cr == "object" && cr !== null ? (cr = cr.delay,
        cr = typeof cr == "number" && 0 < cr ? Ar + cr : Ar) : cr = Ar,
        gr) {
        case 1:
            var wr = -1;
            break;
        case 2:
            wr = 250;
            break;
        case 5:
            wr = 1073741823;
            break;
        case 4:
            wr = 1e4;
            break;
        default:
            wr = 5e3
        }
        return wr = cr + wr,
        gr = {
            id: ut++,
            callback: dr,
            priorityLevel: gr,
            startTime: cr,
            expirationTime: wr,
            sortIndex: -1
        },
        cr > Ar ? (gr.sortIndex = cr,
        o(at, gr),
        c(it) === null && gr === c(at) && (bt ? (At(kt),
        kt = -1) : bt = !0,
        hr(It, cr - Ar))) : (gr.sortIndex = wr,
        o(it, gr),
        vt || _t || (vt = !0,
        ar(Dt))),
        gr
    }
    ,
    d.unstable_shouldYield = Kt,
    d.unstable_wrapCallback = function(gr) {
        var dr = ht;
        return function() {
            var cr = ht;
            ht = dr;
            try {
                return gr.apply(this, arguments)
            } finally {
                ht = cr
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports
  , ca = schedulerExports;
function p(d) {
    for (var o = "https://reactjs.org/docs/error-decoder.html?invariant=" + d, c = 1; c < arguments.length; c++)
        o += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + d + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(d, o) {
    ha(d, o),
    ha(d + "Capture", o)
}
function ha(d, o) {
    for (ea[d] = o,
    d = 0; d < o.length; d++)
        da.add(o[d])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa(d) {
    return ja.call(ma, d) ? !0 : ja.call(la, d) ? !1 : ka.test(d) ? ma[d] = !0 : (la[d] = !0,
    !1)
}
function pa(d, o, c, h) {
    if (c !== null && c.type === 0)
        return !1;
    switch (typeof o) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return h ? !1 : c !== null ? !c.acceptsBooleans : (d = d.toLowerCase().slice(0, 5),
        d !== "data-" && d !== "aria-");
    default:
        return !1
    }
}
function qa(d, o, c, h) {
    if (o === null || typeof o > "u" || pa(d, o, c, h))
        return !0;
    if (h)
        return !1;
    if (c !== null)
        switch (c.type) {
        case 3:
            return !o;
        case 4:
            return o === !1;
        case 5:
            return isNaN(o);
        case 6:
            return isNaN(o) || 1 > o
        }
    return !1
}
function v$1(d, o, c, h, _, b, _e) {
    this.acceptsBooleans = o === 2 || o === 3 || o === 4,
    this.attributeName = h,
    this.attributeNamespace = _,
    this.mustUseProperty = c,
    this.propertyName = d,
    this.type = o,
    this.sanitizeURL = b,
    this.removeEmptyString = _e
}
var z = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(d) {
    z[d] = new v$1(d,0,!1,d,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(d) {
    var o = d[0];
    z[o] = new v$1(o,1,!1,d[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(d) {
    z[d] = new v$1(d,2,!1,d.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(d) {
    z[d] = new v$1(d,2,!1,d,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(d) {
    z[d] = new v$1(d,3,!1,d.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(d) {
    z[d] = new v$1(d,3,!0,d,null,!1,!1)
});
["capture", "download"].forEach(function(d) {
    z[d] = new v$1(d,4,!1,d,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(d) {
    z[d] = new v$1(d,6,!1,d,null,!1,!1)
});
["rowSpan", "start"].forEach(function(d) {
    z[d] = new v$1(d,5,!1,d.toLowerCase(),null,!1,!1)
});
var ra = /[\-:]([a-z])/g;
function sa(d) {
    return d[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(d) {
    var o = d.replace(ra, sa);
    z[o] = new v$1(o,1,!1,d,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(d) {
    var o = d.replace(ra, sa);
    z[o] = new v$1(o,1,!1,d,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(d) {
    var o = d.replace(ra, sa);
    z[o] = new v$1(o,1,!1,d,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(d) {
    z[d] = new v$1(d,1,!1,d.toLowerCase(),null,!1,!1)
});
z.xlinkHref = new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(d) {
    z[d] = new v$1(d,1,!1,d.toLowerCase(),null,!0,!0)
});
function ta(d, o, c, h) {
    var _ = z.hasOwnProperty(o) ? z[o] : null;
    (_ !== null ? _.type !== 0 : h || !(2 < o.length) || o[0] !== "o" && o[0] !== "O" || o[1] !== "n" && o[1] !== "N") && (qa(o, c, _, h) && (c = null),
    h || _ === null ? oa(o) && (c === null ? d.removeAttribute(o) : d.setAttribute(o, "" + c)) : _.mustUseProperty ? d[_.propertyName] = c === null ? _.type === 3 ? !1 : "" : c : (o = _.attributeName,
    h = _.attributeNamespace,
    c === null ? d.removeAttribute(o) : (_ = _.type,
    c = _ === 3 || _ === 4 && c === !0 ? "" : "" + c,
    h ? d.setAttributeNS(h, o, c) : d.setAttribute(o, c))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa = Symbol.for("react.suspense_list")
  , Ga = Symbol.for("react.memo")
  , Ha = Symbol.for("react.lazy")
  , Ia = Symbol.for("react.offscreen")
  , Ja = Symbol.iterator;
function Ka(d) {
    return d === null || typeof d != "object" ? null : (d = Ja && d[Ja] || d["@@iterator"],
    typeof d == "function" ? d : null)
}
var A = Object.assign, La;
function Ma(d) {
    if (La === void 0)
        try {
            throw Error()
        } catch (c) {
            var o = c.stack.trim().match(/\n( *(at )?)/);
            La = o && o[1] || ""
        }
    return `
` + La + d
}
var Na = !1;
function Oa(d, o) {
    if (!d || Na)
        return "";
    Na = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (o)
            if (o = function() {
                throw Error()
            }
            ,
            Object.defineProperty(o.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(o, [])
                } catch (at) {
                    var h = at
                }
                Reflect.construct(d, [], o)
            } else {
                try {
                    o.call()
                } catch (at) {
                    h = at
                }
                d.call(o.prototype)
            }
        else {
            try {
                throw Error()
            } catch (at) {
                h = at
            }
            d()
        }
    } catch (at) {
        if (at && h && typeof at.stack == "string") {
            for (var _ = at.stack.split(`
`), b = h.stack.split(`
`), _e = _.length - 1, nt = b.length - 1; 1 <= _e && 0 <= nt && _[_e] !== b[nt]; )
                nt--;
            for (; 1 <= _e && 0 <= nt; _e--,
            nt--)
                if (_[_e] !== b[nt]) {
                    if (_e !== 1 || nt !== 1)
                        do
                            if (_e--,
                            nt--,
                            0 > nt || _[_e] !== b[nt]) {
                                var it = `
` + _[_e].replace(" at new ", " at ");
                                return d.displayName && it.includes("<anonymous>") && (it = it.replace("<anonymous>", d.displayName)),
                                it
                            }
                        while (1 <= _e && 0 <= nt);
                    break
                }
        }
    } finally {
        Na = !1,
        Error.prepareStackTrace = c
    }
    return (d = d ? d.displayName || d.name : "") ? Ma(d) : ""
}
function Pa(d) {
    switch (d.tag) {
    case 5:
        return Ma(d.type);
    case 16:
        return Ma("Lazy");
    case 13:
        return Ma("Suspense");
    case 19:
        return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
        return d = Oa(d.type, !1),
        d;
    case 11:
        return d = Oa(d.type.render, !1),
        d;
    case 1:
        return d = Oa(d.type, !0),
        d;
    default:
        return ""
    }
}
function Qa(d) {
    if (d == null)
        return null;
    if (typeof d == "function")
        return d.displayName || d.name || null;
    if (typeof d == "string")
        return d;
    switch (d) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa:
        return "SuspenseList"
    }
    if (typeof d == "object")
        switch (d.$$typeof) {
        case Ca:
            return (d.displayName || "Context") + ".Consumer";
        case Ba:
            return (d._context.displayName || "Context") + ".Provider";
        case Da:
            var o = d.render;
            return d = d.displayName,
            d || (d = o.displayName || o.name || "",
            d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef"),
            d;
        case Ga:
            return o = d.displayName || null,
            o !== null ? o : Qa(d.type) || "Memo";
        case Ha:
            o = d._payload,
            d = d._init;
            try {
                return Qa(d(o))
            } catch {}
        }
    return null
}
function Ra(d) {
    var o = d.type;
    switch (d.tag) {
    case 24:
        return "Cache";
    case 9:
        return (o.displayName || "Context") + ".Consumer";
    case 10:
        return (o._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return d = o.render,
        d = d.displayName || d.name || "",
        o.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return o;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa(o);
    case 8:
        return o === za ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof o == "function")
            return o.displayName || o.name || null;
        if (typeof o == "string")
            return o
    }
    return null
}
function Sa(d) {
    switch (typeof d) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return d;
    case "object":
        return d;
    default:
        return ""
    }
}
function Ta(d) {
    var o = d.type;
    return (d = d.nodeName) && d.toLowerCase() === "input" && (o === "checkbox" || o === "radio")
}
function Ua(d) {
    var o = Ta(d) ? "checked" : "value"
      , c = Object.getOwnPropertyDescriptor(d.constructor.prototype, o)
      , h = "" + d[o];
    if (!d.hasOwnProperty(o) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
        var _ = c.get
          , b = c.set;
        return Object.defineProperty(d, o, {
            configurable: !0,
            get: function() {
                return _.call(this)
            },
            set: function(_e) {
                h = "" + _e,
                b.call(this, _e)
            }
        }),
        Object.defineProperty(d, o, {
            enumerable: c.enumerable
        }),
        {
            getValue: function() {
                return h
            },
            setValue: function(_e) {
                h = "" + _e
            },
            stopTracking: function() {
                d._valueTracker = null,
                delete d[o]
            }
        }
    }
}
function Va(d) {
    d._valueTracker || (d._valueTracker = Ua(d))
}
function Wa(d) {
    if (!d)
        return !1;
    var o = d._valueTracker;
    if (!o)
        return !0;
    var c = o.getValue()
      , h = "";
    return d && (h = Ta(d) ? d.checked ? "true" : "false" : d.value),
    d = h,
    d !== c ? (o.setValue(d),
    !0) : !1
}
function Xa(d) {
    if (d = d || (typeof document < "u" ? document : void 0),
    typeof d > "u")
        return null;
    try {
        return d.activeElement || d.body
    } catch {
        return d.body
    }
}
function Ya(d, o) {
    var c = o.checked;
    return A({}, o, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: c ?? d._wrapperState.initialChecked
    })
}
function Za(d, o) {
    var c = o.defaultValue == null ? "" : o.defaultValue
      , h = o.checked != null ? o.checked : o.defaultChecked;
    c = Sa(o.value != null ? o.value : c),
    d._wrapperState = {
        initialChecked: h,
        initialValue: c,
        controlled: o.type === "checkbox" || o.type === "radio" ? o.checked != null : o.value != null
    }
}
function ab(d, o) {
    o = o.checked,
    o != null && ta(d, "checked", o, !1)
}
function bb(d, o) {
    ab(d, o);
    var c = Sa(o.value)
      , h = o.type;
    if (c != null)
        h === "number" ? (c === 0 && d.value === "" || d.value != c) && (d.value = "" + c) : d.value !== "" + c && (d.value = "" + c);
    else if (h === "submit" || h === "reset") {
        d.removeAttribute("value");
        return
    }
    o.hasOwnProperty("value") ? cb(d, o.type, c) : o.hasOwnProperty("defaultValue") && cb(d, o.type, Sa(o.defaultValue)),
    o.checked == null && o.defaultChecked != null && (d.defaultChecked = !!o.defaultChecked)
}
function db(d, o, c) {
    if (o.hasOwnProperty("value") || o.hasOwnProperty("defaultValue")) {
        var h = o.type;
        if (!(h !== "submit" && h !== "reset" || o.value !== void 0 && o.value !== null))
            return;
        o = "" + d._wrapperState.initialValue,
        c || o === d.value || (d.value = o),
        d.defaultValue = o
    }
    c = d.name,
    c !== "" && (d.name = ""),
    d.defaultChecked = !!d._wrapperState.initialChecked,
    c !== "" && (d.name = c)
}
function cb(d, o, c) {
    (o !== "number" || Xa(d.ownerDocument) !== d) && (c == null ? d.defaultValue = "" + d._wrapperState.initialValue : d.defaultValue !== "" + c && (d.defaultValue = "" + c))
}
var eb = Array.isArray;
function fb(d, o, c, h) {
    if (d = d.options,
    o) {
        o = {};
        for (var _ = 0; _ < c.length; _++)
            o["$" + c[_]] = !0;
        for (c = 0; c < d.length; c++)
            _ = o.hasOwnProperty("$" + d[c].value),
            d[c].selected !== _ && (d[c].selected = _),
            _ && h && (d[c].defaultSelected = !0)
    } else {
        for (c = "" + Sa(c),
        o = null,
        _ = 0; _ < d.length; _++) {
            if (d[_].value === c) {
                d[_].selected = !0,
                h && (d[_].defaultSelected = !0);
                return
            }
            o !== null || d[_].disabled || (o = d[_])
        }
        o !== null && (o.selected = !0)
    }
}
function gb(d, o) {
    if (o.dangerouslySetInnerHTML != null)
        throw Error(p(91));
    return A({}, o, {
        value: void 0,
        defaultValue: void 0,
        children: "" + d._wrapperState.initialValue
    })
}
function hb(d, o) {
    var c = o.value;
    if (c == null) {
        if (c = o.children,
        o = o.defaultValue,
        c != null) {
            if (o != null)
                throw Error(p(92));
            if (eb(c)) {
                if (1 < c.length)
                    throw Error(p(93));
                c = c[0]
            }
            o = c
        }
        o == null && (o = ""),
        c = o
    }
    d._wrapperState = {
        initialValue: Sa(c)
    }
}
function ib(d, o) {
    var c = Sa(o.value)
      , h = Sa(o.defaultValue);
    c != null && (c = "" + c,
    c !== d.value && (d.value = c),
    o.defaultValue == null && d.defaultValue !== c && (d.defaultValue = c)),
    h != null && (d.defaultValue = "" + h)
}
function jb(d) {
    var o = d.textContent;
    o === d._wrapperState.initialValue && o !== "" && o !== null && (d.value = o)
}
function kb(d) {
    switch (d) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(d, o) {
    return d == null || d === "http://www.w3.org/1999/xhtml" ? kb(o) : d === "http://www.w3.org/2000/svg" && o === "foreignObject" ? "http://www.w3.org/1999/xhtml" : d
}
var mb, nb = function(d) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(o, c, h, _) {
        MSApp.execUnsafeLocalFunction(function() {
            return d(o, c, h, _)
        })
    }
    : d
}(function(d, o) {
    if (d.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in d)
        d.innerHTML = o;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + o.valueOf().toString() + "</svg>",
        o = mb.firstChild; d.firstChild; )
            d.removeChild(d.firstChild);
        for (; o.firstChild; )
            d.appendChild(o.firstChild)
    }
});
function ob(d, o) {
    if (o) {
        var c = d.firstChild;
        if (c && c === d.lastChild && c.nodeType === 3) {
            c.nodeValue = o;
            return
        }
    }
    d.textContent = o
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(d) {
    qb.forEach(function(o) {
        o = o + d.charAt(0).toUpperCase() + d.substring(1),
        pb[o] = pb[d]
    })
});
function rb(d, o, c) {
    return o == null || typeof o == "boolean" || o === "" ? "" : c || typeof o != "number" || o === 0 || pb.hasOwnProperty(d) && pb[d] ? ("" + o).trim() : o + "px"
}
function sb(d, o) {
    d = d.style;
    for (var c in o)
        if (o.hasOwnProperty(c)) {
            var h = c.indexOf("--") === 0
              , _ = rb(c, o[c], h);
            c === "float" && (c = "cssFloat"),
            h ? d.setProperty(c, _) : d[c] = _
        }
}
var tb = A({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(d, o) {
    if (o) {
        if (tb[d] && (o.children != null || o.dangerouslySetInnerHTML != null))
            throw Error(p(137, d));
        if (o.dangerouslySetInnerHTML != null) {
            if (o.children != null)
                throw Error(p(60));
            if (typeof o.dangerouslySetInnerHTML != "object" || !("__html"in o.dangerouslySetInnerHTML))
                throw Error(p(61))
        }
        if (o.style != null && typeof o.style != "object")
            throw Error(p(62))
    }
}
function vb(d, o) {
    if (d.indexOf("-") === -1)
        return typeof o.is == "string";
    switch (d) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(d) {
    return d = d.target || d.srcElement || window,
    d.correspondingUseElement && (d = d.correspondingUseElement),
    d.nodeType === 3 ? d.parentNode : d
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(d) {
    if (d = Cb(d)) {
        if (typeof yb != "function")
            throw Error(p(280));
        var o = d.stateNode;
        o && (o = Db(o),
        yb(d.stateNode, d.type, o))
    }
}
function Eb(d) {
    zb ? Ab ? Ab.push(d) : Ab = [d] : zb = d
}
function Fb() {
    if (zb) {
        var d = zb
          , o = Ab;
        if (Ab = zb = null,
        Bb(d),
        o)
            for (d = 0; d < o.length; d++)
                Bb(o[d])
    }
}
function Gb(d, o) {
    return d(o)
}
function Hb() {}
var Ib = !1;
function Jb(d, o, c) {
    if (Ib)
        return d(o, c);
    Ib = !0;
    try {
        return Gb(d, o, c)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(d, o) {
    var c = d.stateNode;
    if (c === null)
        return null;
    var h = Db(c);
    if (h === null)
        return null;
    c = h[o];
    e: switch (o) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (h = !h.disabled) || (d = d.type,
        h = !(d === "button" || d === "input" || d === "select" || d === "textarea")),
        d = !h;
        break e;
    default:
        d = !1
    }
    if (d)
        return null;
    if (c && typeof c != "function")
        throw Error(p(231, o, typeof c));
    return c
}
var Lb = !1;
if (ia)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch (d) {
        Lb = !1
    }
function Nb(d, o, c, h, _, b, _e, nt, it) {
    var at = Array.prototype.slice.call(arguments, 3);
    try {
        o.apply(c, at)
    } catch (ut) {
        this.onError(ut)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(d) {
        Ob = !0,
        Pb = d
    }
};
function Tb(d, o, c, h, _, b, _e, nt, it) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(d, o, c, h, _, b, _e, nt, it) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var at = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p(198));
        Qb || (Qb = !0,
        Rb = at)
    }
}
function Vb(d) {
    var o = d
      , c = d;
    if (d.alternate)
        for (; o.return; )
            o = o.return;
    else {
        d = o;
        do
            o = d,
            o.flags & 4098 && (c = o.return),
            d = o.return;
        while (d)
    }
    return o.tag === 3 ? c : null
}
function Wb(d) {
    if (d.tag === 13) {
        var o = d.memoizedState;
        if (o === null && (d = d.alternate,
        d !== null && (o = d.memoizedState)),
        o !== null)
            return o.dehydrated
    }
    return null
}
function Xb(d) {
    if (Vb(d) !== d)
        throw Error(p(188))
}
function Yb(d) {
    var o = d.alternate;
    if (!o) {
        if (o = Vb(d),
        o === null)
            throw Error(p(188));
        return o !== d ? null : d
    }
    for (var c = d, h = o; ; ) {
        var _ = c.return;
        if (_ === null)
            break;
        var b = _.alternate;
        if (b === null) {
            if (h = _.return,
            h !== null) {
                c = h;
                continue
            }
            break
        }
        if (_.child === b.child) {
            for (b = _.child; b; ) {
                if (b === c)
                    return Xb(_),
                    d;
                if (b === h)
                    return Xb(_),
                    o;
                b = b.sibling
            }
            throw Error(p(188))
        }
        if (c.return !== h.return)
            c = _,
            h = b;
        else {
            for (var _e = !1, nt = _.child; nt; ) {
                if (nt === c) {
                    _e = !0,
                    c = _,
                    h = b;
                    break
                }
                if (nt === h) {
                    _e = !0,
                    h = _,
                    c = b;
                    break
                }
                nt = nt.sibling
            }
            if (!_e) {
                for (nt = b.child; nt; ) {
                    if (nt === c) {
                        _e = !0,
                        c = b,
                        h = _;
                        break
                    }
                    if (nt === h) {
                        _e = !0,
                        h = b,
                        c = _;
                        break
                    }
                    nt = nt.sibling
                }
                if (!_e)
                    throw Error(p(189))
            }
        }
        if (c.alternate !== h)
            throw Error(p(190))
    }
    if (c.tag !== 3)
        throw Error(p(188));
    return c.stateNode.current === c ? d : o
}
function Zb(d) {
    return d = Yb(d),
    d !== null ? $b(d) : null
}
function $b(d) {
    if (d.tag === 5 || d.tag === 6)
        return d;
    for (d = d.child; d !== null; ) {
        var o = $b(d);
        if (o !== null)
            return o;
        d = d.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc = ca.unstable_requestPaint
  , B = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc = ca.unstable_ImmediatePriority
  , gc = ca.unstable_UserBlockingPriority
  , hc = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc = null
  , lc = null;
function mc(d) {
    if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
            lc.onCommitFiberRoot(kc, d, void 0, (d.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc = Math.log
  , qc = Math.LN2;
function nc(d) {
    return d >>>= 0,
    d === 0 ? 32 : 31 - (pc(d) / qc | 0) | 0
}
var rc = 64
  , sc = 4194304;
function tc(d) {
    switch (d & -d) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return d & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return d & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return d
    }
}
function uc(d, o) {
    var c = d.pendingLanes;
    if (c === 0)
        return 0;
    var h = 0
      , _ = d.suspendedLanes
      , b = d.pingedLanes
      , _e = c & 268435455;
    if (_e !== 0) {
        var nt = _e & ~_;
        nt !== 0 ? h = tc(nt) : (b &= _e,
        b !== 0 && (h = tc(b)))
    } else
        _e = c & ~_,
        _e !== 0 ? h = tc(_e) : b !== 0 && (h = tc(b));
    if (h === 0)
        return 0;
    if (o !== 0 && o !== h && !(o & _) && (_ = h & -h,
    b = o & -o,
    _ >= b || _ === 16 && (b & 4194240) !== 0))
        return o;
    if (h & 4 && (h |= c & 16),
    o = d.entangledLanes,
    o !== 0)
        for (d = d.entanglements,
        o &= h; 0 < o; )
            c = 31 - oc(o),
            _ = 1 << c,
            h |= d[c],
            o &= ~_;
    return h
}
function vc(d, o) {
    switch (d) {
    case 1:
    case 2:
    case 4:
        return o + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return o + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc(d, o) {
    for (var c = d.suspendedLanes, h = d.pingedLanes, _ = d.expirationTimes, b = d.pendingLanes; 0 < b; ) {
        var _e = 31 - oc(b)
          , nt = 1 << _e
          , it = _[_e];
        it === -1 ? (!(nt & c) || nt & h) && (_[_e] = vc(nt, o)) : it <= o && (d.expiredLanes |= nt),
        b &= ~nt
    }
}
function xc(d) {
    return d = d.pendingLanes & -1073741825,
    d !== 0 ? d : d & 1073741824 ? 1073741824 : 0
}
function yc() {
    var d = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    d
}
function zc(d) {
    for (var o = [], c = 0; 31 > c; c++)
        o.push(d);
    return o
}
function Ac(d, o, c) {
    d.pendingLanes |= o,
    o !== 536870912 && (d.suspendedLanes = 0,
    d.pingedLanes = 0),
    d = d.eventTimes,
    o = 31 - oc(o),
    d[o] = c
}
function Bc(d, o) {
    var c = d.pendingLanes & ~o;
    d.pendingLanes = o,
    d.suspendedLanes = 0,
    d.pingedLanes = 0,
    d.expiredLanes &= o,
    d.mutableReadLanes &= o,
    d.entangledLanes &= o,
    o = d.entanglements;
    var h = d.eventTimes;
    for (d = d.expirationTimes; 0 < c; ) {
        var _ = 31 - oc(c)
          , b = 1 << _;
        o[_] = 0,
        h[_] = -1,
        d[_] = -1,
        c &= ~b
    }
}
function Cc(d, o) {
    var c = d.entangledLanes |= o;
    for (d = d.entanglements; c; ) {
        var h = 31 - oc(c)
          , _ = 1 << h;
        _ & o | d[h] & o && (d[h] |= o),
        c &= ~_
    }
}
var C = 0;
function Dc(d) {
    return d &= -d,
    1 < d ? 4 < d ? d & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(d, o) {
    switch (d) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc.delete(o.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete(o.pointerId)
    }
}
function Tc(d, o, c, h, _, b) {
    return d === null || d.nativeEvent !== b ? (d = {
        blockedOn: o,
        domEventName: c,
        eventSystemFlags: h,
        nativeEvent: b,
        targetContainers: [_]
    },
    o !== null && (o = Cb(o),
    o !== null && Fc(o)),
    d) : (d.eventSystemFlags |= h,
    o = d.targetContainers,
    _ !== null && o.indexOf(_) === -1 && o.push(_),
    d)
}
function Uc(d, o, c, h, _) {
    switch (o) {
    case "focusin":
        return Lc = Tc(Lc, d, o, c, h, _),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, d, o, c, h, _),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, d, o, c, h, _),
        !0;
    case "pointerover":
        var b = _.pointerId;
        return Oc.set(b, Tc(Oc.get(b) || null, d, o, c, h, _)),
        !0;
    case "gotpointercapture":
        return b = _.pointerId,
        Pc.set(b, Tc(Pc.get(b) || null, d, o, c, h, _)),
        !0
    }
    return !1
}
function Vc(d) {
    var o = Wc(d.target);
    if (o !== null) {
        var c = Vb(o);
        if (c !== null) {
            if (o = c.tag,
            o === 13) {
                if (o = Wb(c),
                o !== null) {
                    d.blockedOn = o,
                    Ic(d.priority, function() {
                        Gc(c)
                    });
                    return
                }
            } else if (o === 3 && c.stateNode.current.memoizedState.isDehydrated) {
                d.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
                return
            }
        }
    }
    d.blockedOn = null
}
function Xc(d) {
    if (d.blockedOn !== null)
        return !1;
    for (var o = d.targetContainers; 0 < o.length; ) {
        var c = Yc(d.domEventName, d.eventSystemFlags, o[0], d.nativeEvent);
        if (c === null) {
            c = d.nativeEvent;
            var h = new c.constructor(c.type,c);
            wb = h,
            c.target.dispatchEvent(h),
            wb = null
        } else
            return o = Cb(c),
            o !== null && Fc(o),
            d.blockedOn = c,
            !1;
        o.shift()
    }
    return !0
}
function Zc(d, o, c) {
    Xc(d) && c.delete(o)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(d, o) {
    d.blockedOn === o && (d.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(d) {
    function o(_) {
        return ad(_, d)
    }
    if (0 < Kc.length) {
        ad(Kc[0], d);
        for (var c = 1; c < Kc.length; c++) {
            var h = Kc[c];
            h.blockedOn === d && (h.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, d),
    Mc !== null && ad(Mc, d),
    Nc !== null && ad(Nc, d),
    Oc.forEach(o),
    Pc.forEach(o),
    c = 0; c < Qc.length; c++)
        h = Qc[c],
        h.blockedOn === d && (h.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0],
    c.blockedOn === null); )
        Vc(c),
        c.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig
  , dd = !0;
function ed(d, o, c, h) {
    var _ = C
      , b = cd.transition;
    cd.transition = null;
    try {
        C = 1,
        fd(d, o, c, h)
    } finally {
        C = _,
        cd.transition = b
    }
}
function gd(d, o, c, h) {
    var _ = C
      , b = cd.transition;
    cd.transition = null;
    try {
        C = 4,
        fd(d, o, c, h)
    } finally {
        C = _,
        cd.transition = b
    }
}
function fd(d, o, c, h) {
    if (dd) {
        var _ = Yc(d, o, c, h);
        if (_ === null)
            hd(d, o, h, id$2, c),
            Sc(d, h);
        else if (Uc(_, d, o, c, h))
            h.stopPropagation();
        else if (Sc(d, h),
        o & 4 && -1 < Rc.indexOf(d)) {
            for (; _ !== null; ) {
                var b = Cb(_);
                if (b !== null && Ec(b),
                b = Yc(d, o, c, h),
                b === null && hd(d, o, h, id$2, c),
                b === _)
                    break;
                _ = b
            }
            _ !== null && h.stopPropagation()
        } else
            hd(d, o, h, null, c)
    }
}
var id$2 = null;
function Yc(d, o, c, h) {
    if (id$2 = null,
    d = xb(h),
    d = Wc(d),
    d !== null)
        if (o = Vb(d),
        o === null)
            d = null;
        else if (c = o.tag,
        c === 13) {
            if (d = Wb(o),
            d !== null)
                return d;
            d = null
        } else if (c === 3) {
            if (o.stateNode.current.memoizedState.isDehydrated)
                return o.tag === 3 ? o.stateNode.containerInfo : null;
            d = null
        } else
            o !== d && (d = null);
    return id$2 = d,
    null
}
function jd(d) {
    switch (d) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc:
            return 1;
        case gc:
            return 4;
        case hc:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var d, o = ld, c = o.length, h, _ = "value"in kd ? kd.value : kd.textContent, b = _.length;
    for (d = 0; d < c && o[d] === _[d]; d++)
        ;
    var _e = c - d;
    for (h = 1; h <= _e && o[c - h] === _[b - h]; h++)
        ;
    return md = _.slice(d, 1 < h ? 1 - h : void 0)
}
function od(d) {
    var o = d.keyCode;
    return "charCode"in d ? (d = d.charCode,
    d === 0 && o === 13 && (d = 13)) : d = o,
    d === 10 && (d = 13),
    32 <= d || d === 13 ? d : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(d) {
    function o(c, h, _, b, _e) {
        this._reactName = c,
        this._targetInst = _,
        this.type = h,
        this.nativeEvent = b,
        this.target = _e,
        this.currentTarget = null;
        for (var nt in d)
            d.hasOwnProperty(nt) && (c = d[nt],
            this[nt] = c ? c(b) : b[nt]);
        return this.isDefaultPrevented = (b.defaultPrevented != null ? b.defaultPrevented : b.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A(o.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var c = this.nativeEvent;
            c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var c = this.nativeEvent;
            c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    o
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(d) {
        return d.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(d) {
        return d.relatedTarget === void 0 ? d.fromElement === d.srcElement ? d.toElement : d.fromElement : d.relatedTarget
    },
    movementX: function(d) {
        return "movementX"in d ? d.movementX : (d !== yd && (yd && d.type === "mousemove" ? (wd = d.screenX - yd.screenX,
        xd = d.screenY - yd.screenY) : xd = wd = 0,
        yd = d),
        wd)
    },
    movementY: function(d) {
        return "movementY"in d ? d.movementY : xd
    }
}), Bd = rd(Ad), Cd = A({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A({}, sd, {
    clipboardData: function(d) {
        return "clipboardData"in d ? d.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(d) {
    var o = this.nativeEvent;
    return o.getModifierState ? o.getModifierState(d) : (d = Od[d]) ? !!o[d] : !1
}
function zd() {
    return Pd
}
var Qd = A({}, ud, {
    key: function(d) {
        if (d.key) {
            var o = Md[d.key] || d.key;
            if (o !== "Unidentified")
                return o
        }
        return d.type === "keypress" ? (d = od(d),
        d === 13 ? "Enter" : String.fromCharCode(d)) : d.type === "keydown" || d.type === "keyup" ? Nd[d.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(d) {
        return d.type === "keypress" ? od(d) : 0
    },
    keyCode: function(d) {
        return d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0
    },
    which: function(d) {
        return d.type === "keypress" ? od(d) : d.type === "keydown" || d.type === "keyup" ? d.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A({}, Ad, {
    deltaX: function(d) {
        return "deltaX"in d ? d.deltaX : "wheelDeltaX"in d ? -d.wheelDeltaX : 0
    },
    deltaY: function(d) {
        return "deltaY"in d ? d.deltaY : "wheelDeltaY"in d ? -d.wheelDeltaY : "wheelDelta"in d ? -d.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae = ia && "CompositionEvent"in window
  , be = null;
ia && "documentMode"in document && (be = document.documentMode);
var ce = ia && "TextEvent"in window && !be
  , de = ia && (!ae || be && 8 < be && 11 >= be)
  , ee = " "
  , fe = !1;
function ge(d, o) {
    switch (d) {
    case "keyup":
        return $d.indexOf(o.keyCode) !== -1;
    case "keydown":
        return o.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he(d) {
    return d = d.detail,
    typeof d == "object" && "data"in d ? d.data : null
}
var ie = !1;
function je(d, o) {
    switch (d) {
    case "compositionend":
        return he(o);
    case "keypress":
        return o.which !== 32 ? null : (fe = !0,
        ee);
    case "textInput":
        return d = o.data,
        d === ee && fe ? null : d;
    default:
        return null
    }
}
function ke(d, o) {
    if (ie)
        return d === "compositionend" || !ae && ge(d, o) ? (d = nd(),
        md = ld = kd = null,
        ie = !1,
        d) : null;
    switch (d) {
    case "paste":
        return null;
    case "keypress":
        if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
            if (o.char && 1 < o.char.length)
                return o.char;
            if (o.which)
                return String.fromCharCode(o.which)
        }
        return null;
    case "compositionend":
        return de && o.locale !== "ko" ? null : o.data;
    default:
        return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me(d) {
    var o = d && d.nodeName && d.nodeName.toLowerCase();
    return o === "input" ? !!le[d.type] : o === "textarea"
}
function ne(d, o, c, h) {
    Eb(h),
    o = oe(o, "onChange"),
    0 < o.length && (c = new td("onChange","change",null,c,h),
    d.push({
        event: c,
        listeners: o
    }))
}
var pe = null
  , qe = null;
function re(d) {
    se(d, 0)
}
function te(d) {
    var o = ue(d);
    if (Wa(o))
        return d
}
function ve(d, o) {
    if (d === "change")
        return o
}
var we = !1;
if (ia) {
    var xe;
    if (ia) {
        var ye = "oninput"in document;
        if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"),
            ye = typeof ze.oninput == "function"
        }
        xe = ye
    } else
        xe = !1;
    we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be),
    qe = pe = null)
}
function Be(d) {
    if (d.propertyName === "value" && te(qe)) {
        var o = [];
        ne(o, qe, d, xb(d)),
        Jb(re, o)
    }
}
function Ce(d, o, c) {
    d === "focusin" ? (Ae(),
    pe = o,
    qe = c,
    pe.attachEvent("onpropertychange", Be)) : d === "focusout" && Ae()
}
function De(d) {
    if (d === "selectionchange" || d === "keyup" || d === "keydown")
        return te(qe)
}
function Ee(d, o) {
    if (d === "click")
        return te(o)
}
function Fe(d, o) {
    if (d === "input" || d === "change")
        return te(o)
}
function Ge(d, o) {
    return d === o && (d !== 0 || 1 / d === 1 / o) || d !== d && o !== o
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(d, o) {
    if (He(d, o))
        return !0;
    if (typeof d != "object" || d === null || typeof o != "object" || o === null)
        return !1;
    var c = Object.keys(d)
      , h = Object.keys(o);
    if (c.length !== h.length)
        return !1;
    for (h = 0; h < c.length; h++) {
        var _ = c[h];
        if (!ja.call(o, _) || !He(d[_], o[_]))
            return !1
    }
    return !0
}
function Je(d) {
    for (; d && d.firstChild; )
        d = d.firstChild;
    return d
}
function Ke(d, o) {
    var c = Je(d);
    d = 0;
    for (var h; c; ) {
        if (c.nodeType === 3) {
            if (h = d + c.textContent.length,
            d <= o && h >= o)
                return {
                    node: c,
                    offset: o - d
                };
            d = h
        }
        e: {
            for (; c; ) {
                if (c.nextSibling) {
                    c = c.nextSibling;
                    break e
                }
                c = c.parentNode
            }
            c = void 0
        }
        c = Je(c)
    }
}
function Le(d, o) {
    return d && o ? d === o ? !0 : d && d.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Le(d, o.parentNode) : "contains"in d ? d.contains(o) : d.compareDocumentPosition ? !!(d.compareDocumentPosition(o) & 16) : !1 : !1
}
function Me() {
    for (var d = window, o = Xa(); o instanceof d.HTMLIFrameElement; ) {
        try {
            var c = typeof o.contentWindow.location.href == "string"
        } catch {
            c = !1
        }
        if (c)
            d = o.contentWindow;
        else
            break;
        o = Xa(d.document)
    }
    return o
}
function Ne(d) {
    var o = d && d.nodeName && d.nodeName.toLowerCase();
    return o && (o === "input" && (d.type === "text" || d.type === "search" || d.type === "tel" || d.type === "url" || d.type === "password") || o === "textarea" || d.contentEditable === "true")
}
function Oe(d) {
    var o = Me()
      , c = d.focusedElem
      , h = d.selectionRange;
    if (o !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
        if (h !== null && Ne(c)) {
            if (o = h.start,
            d = h.end,
            d === void 0 && (d = o),
            "selectionStart"in c)
                c.selectionStart = o,
                c.selectionEnd = Math.min(d, c.value.length);
            else if (d = (o = c.ownerDocument || document) && o.defaultView || window,
            d.getSelection) {
                d = d.getSelection();
                var _ = c.textContent.length
                  , b = Math.min(h.start, _);
                h = h.end === void 0 ? b : Math.min(h.end, _),
                !d.extend && b > h && (_ = h,
                h = b,
                b = _),
                _ = Ke(c, b);
                var _e = Ke(c, h);
                _ && _e && (d.rangeCount !== 1 || d.anchorNode !== _.node || d.anchorOffset !== _.offset || d.focusNode !== _e.node || d.focusOffset !== _e.offset) && (o = o.createRange(),
                o.setStart(_.node, _.offset),
                d.removeAllRanges(),
                b > h ? (d.addRange(o),
                d.extend(_e.node, _e.offset)) : (o.setEnd(_e.node, _e.offset),
                d.addRange(o)))
            }
        }
        for (o = [],
        d = c; d = d.parentNode; )
            d.nodeType === 1 && o.push({
                element: d,
                left: d.scrollLeft,
                top: d.scrollTop
            });
        for (typeof c.focus == "function" && c.focus(),
        c = 0; c < o.length; c++)
            d = o[c],
            d.element.scrollLeft = d.left,
            d.element.scrollTop = d.top
    }
}
var Pe = ia && "documentMode"in document && 11 >= document.documentMode
  , Qe = null
  , Re = null
  , Se = null
  , Te = !1;
function Ue(d, o, c) {
    var h = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Te || Qe == null || Qe !== Xa(h) || (h = Qe,
    "selectionStart"in h && Ne(h) ? h = {
        start: h.selectionStart,
        end: h.selectionEnd
    } : (h = (h.ownerDocument && h.ownerDocument.defaultView || window).getSelection(),
    h = {
        anchorNode: h.anchorNode,
        anchorOffset: h.anchorOffset,
        focusNode: h.focusNode,
        focusOffset: h.focusOffset
    }),
    Se && Ie(Se, h) || (Se = h,
    h = oe(Re, "onSelect"),
    0 < h.length && (o = new td("onSelect","select",null,o,c),
    d.push({
        event: o,
        listeners: h
    }),
    o.target = Qe)))
}
function Ve(d, o) {
    var c = {};
    return c[d.toLowerCase()] = o.toLowerCase(),
    c["Webkit" + d] = "webkit" + o,
    c["Moz" + d] = "moz" + o,
    c
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
}
  , Xe = {}
  , Ye = {};
ia && (Ye = document.createElement("div").style,
"AnimationEvent"in window || (delete We.animationend.animation,
delete We.animationiteration.animation,
delete We.animationstart.animation),
"TransitionEvent"in window || delete We.transitionend.transition);
function Ze(d) {
    if (Xe[d])
        return Xe[d];
    if (!We[d])
        return d;
    var o = We[d], c;
    for (c in o)
        if (o.hasOwnProperty(c) && c in Ye)
            return Xe[d] = o[c];
    return d
}
var $e = Ze("animationend")
  , af = Ze("animationiteration")
  , bf = Ze("animationstart")
  , cf = Ze("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(d, o) {
    df.set(d, o),
    fa(o, [d])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(d, o, c) {
    var h = d.type || "unknown-event";
    d.currentTarget = c,
    Ub(h, o, void 0, d),
    d.currentTarget = null
}
function se(d, o) {
    o = (o & 4) !== 0;
    for (var c = 0; c < d.length; c++) {
        var h = d[c]
          , _ = h.event;
        h = h.listeners;
        e: {
            var b = void 0;
            if (o)
                for (var _e = h.length - 1; 0 <= _e; _e--) {
                    var nt = h[_e]
                      , it = nt.instance
                      , at = nt.currentTarget;
                    if (nt = nt.listener,
                    it !== b && _.isPropagationStopped())
                        break e;
                    nf(_, nt, at),
                    b = it
                }
            else
                for (_e = 0; _e < h.length; _e++) {
                    if (nt = h[_e],
                    it = nt.instance,
                    at = nt.currentTarget,
                    nt = nt.listener,
                    it !== b && _.isPropagationStopped())
                        break e;
                    nf(_, nt, at),
                    b = it
                }
        }
    }
    if (Qb)
        throw d = Rb,
        Qb = !1,
        Rb = null,
        d
}
function D(d, o) {
    var c = o[of];
    c === void 0 && (c = o[of] = new Set);
    var h = d + "__bubble";
    c.has(h) || (pf(o, d, 2, !1),
    c.add(h))
}
function qf(d, o, c) {
    var h = 0;
    o && (h |= 4),
    pf(c, d, h, o)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(d) {
    if (!d[rf]) {
        d[rf] = !0,
        da.forEach(function(c) {
            c !== "selectionchange" && (mf.has(c) || qf(c, !1, d),
            qf(c, !0, d))
        });
        var o = d.nodeType === 9 ? d : d.ownerDocument;
        o === null || o[rf] || (o[rf] = !0,
        qf("selectionchange", !1, o))
    }
}
function pf(d, o, c, h) {
    switch (jd(o)) {
    case 1:
        var _ = ed;
        break;
    case 4:
        _ = gd;
        break;
    default:
        _ = fd
    }
    c = _.bind(null, o, c, d),
    _ = void 0,
    !Lb || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (_ = !0),
    h ? _ !== void 0 ? d.addEventListener(o, c, {
        capture: !0,
        passive: _
    }) : d.addEventListener(o, c, !0) : _ !== void 0 ? d.addEventListener(o, c, {
        passive: _
    }) : d.addEventListener(o, c, !1)
}
function hd(d, o, c, h, _) {
    var b = h;
    if (!(o & 1) && !(o & 2) && h !== null)
        e: for (; ; ) {
            if (h === null)
                return;
            var _e = h.tag;
            if (_e === 3 || _e === 4) {
                var nt = h.stateNode.containerInfo;
                if (nt === _ || nt.nodeType === 8 && nt.parentNode === _)
                    break;
                if (_e === 4)
                    for (_e = h.return; _e !== null; ) {
                        var it = _e.tag;
                        if ((it === 3 || it === 4) && (it = _e.stateNode.containerInfo,
                        it === _ || it.nodeType === 8 && it.parentNode === _))
                            return;
                        _e = _e.return
                    }
                for (; nt !== null; ) {
                    if (_e = Wc(nt),
                    _e === null)
                        return;
                    if (it = _e.tag,
                    it === 5 || it === 6) {
                        h = b = _e;
                        continue e
                    }
                    nt = nt.parentNode
                }
            }
            h = h.return
        }
    Jb(function() {
        var at = b
          , ut = xb(c)
          , pt = [];
        e: {
            var ht = df.get(d);
            if (ht !== void 0) {
                var _t = td
                  , vt = d;
                switch (d) {
                case "keypress":
                    if (od(c) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    _t = Rd;
                    break;
                case "focusin":
                    vt = "focus",
                    _t = Fd;
                    break;
                case "focusout":
                    vt = "blur",
                    _t = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    _t = Fd;
                    break;
                case "click":
                    if (c.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    _t = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    _t = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    _t = Vd;
                    break;
                case $e:
                case af:
                case bf:
                    _t = Hd;
                    break;
                case cf:
                    _t = Xd;
                    break;
                case "scroll":
                    _t = vd;
                    break;
                case "wheel":
                    _t = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    _t = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    _t = Td
                }
                var bt = (o & 4) !== 0
                  , St = !bt && d === "scroll"
                  , At = bt ? ht !== null ? ht + "Capture" : null : ht;
                bt = [];
                for (var Et = at, Pt; Et !== null; ) {
                    Pt = Et;
                    var It = Pt.stateNode;
                    if (Pt.tag === 5 && It !== null && (Pt = It,
                    At !== null && (It = Kb(Et, At),
                    It != null && bt.push(tf(Et, It, Pt)))),
                    St)
                        break;
                    Et = Et.return
                }
                0 < bt.length && (ht = new _t(ht,vt,null,c,ut),
                pt.push({
                    event: ht,
                    listeners: bt
                }))
            }
        }
        if (!(o & 7)) {
            e: {
                if (ht = d === "mouseover" || d === "pointerover",
                _t = d === "mouseout" || d === "pointerout",
                ht && c !== wb && (vt = c.relatedTarget || c.fromElement) && (Wc(vt) || vt[uf]))
                    break e;
                if ((_t || ht) && (ht = ut.window === ut ? ut : (ht = ut.ownerDocument) ? ht.defaultView || ht.parentWindow : window,
                _t ? (vt = c.relatedTarget || c.toElement,
                _t = at,
                vt = vt ? Wc(vt) : null,
                vt !== null && (St = Vb(vt),
                vt !== St || vt.tag !== 5 && vt.tag !== 6) && (vt = null)) : (_t = null,
                vt = at),
                _t !== vt)) {
                    if (bt = Bd,
                    It = "onMouseLeave",
                    At = "onMouseEnter",
                    Et = "mouse",
                    (d === "pointerout" || d === "pointerover") && (bt = Td,
                    It = "onPointerLeave",
                    At = "onPointerEnter",
                    Et = "pointer"),
                    St = _t == null ? ht : ue(_t),
                    Pt = vt == null ? ht : ue(vt),
                    ht = new bt(It,Et + "leave",_t,c,ut),
                    ht.target = St,
                    ht.relatedTarget = Pt,
                    It = null,
                    Wc(ut) === at && (bt = new bt(At,Et + "enter",vt,c,ut),
                    bt.target = Pt,
                    bt.relatedTarget = St,
                    It = bt),
                    St = It,
                    _t && vt)
                        t: {
                            for (bt = _t,
                            At = vt,
                            Et = 0,
                            Pt = bt; Pt; Pt = vf(Pt))
                                Et++;
                            for (Pt = 0,
                            It = At; It; It = vf(It))
                                Pt++;
                            for (; 0 < Et - Pt; )
                                bt = vf(bt),
                                Et--;
                            for (; 0 < Pt - Et; )
                                At = vf(At),
                                Pt--;
                            for (; Et--; ) {
                                if (bt === At || At !== null && bt === At.alternate)
                                    break t;
                                bt = vf(bt),
                                At = vf(At)
                            }
                            bt = null
                        }
                    else
                        bt = null;
                    _t !== null && wf(pt, ht, _t, bt, !1),
                    vt !== null && St !== null && wf(pt, St, vt, bt, !0)
                }
            }
            e: {
                if (ht = at ? ue(at) : window,
                _t = ht.nodeName && ht.nodeName.toLowerCase(),
                _t === "select" || _t === "input" && ht.type === "file")
                    var Dt = ve;
                else if (me(ht))
                    if (we)
                        Dt = Fe;
                    else {
                        Dt = De;
                        var Gt = Ce
                    }
                else
                    (_t = ht.nodeName) && _t.toLowerCase() === "input" && (ht.type === "checkbox" || ht.type === "radio") && (Dt = Ee);
                if (Dt && (Dt = Dt(d, at))) {
                    ne(pt, Dt, c, ut);
                    break e
                }
                Gt && Gt(d, ht, at),
                d === "focusout" && (Gt = ht._wrapperState) && Gt.controlled && ht.type === "number" && cb(ht, "number", ht.value)
            }
            switch (Gt = at ? ue(at) : window,
            d) {
            case "focusin":
                (me(Gt) || Gt.contentEditable === "true") && (Qe = Gt,
                Re = at,
                Se = null);
                break;
            case "focusout":
                Se = Re = Qe = null;
                break;
            case "mousedown":
                Te = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te = !1,
                Ue(pt, c, ut);
                break;
            case "selectionchange":
                if (Pe)
                    break;
            case "keydown":
            case "keyup":
                Ue(pt, c, ut)
            }
            var Bt;
            if (ae)
                e: {
                    switch (d) {
                    case "compositionstart":
                        var kt = "onCompositionStart";
                        break e;
                    case "compositionend":
                        kt = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        kt = "onCompositionUpdate";
                        break e
                    }
                    kt = void 0
                }
            else
                ie ? ge(d, c) && (kt = "onCompositionEnd") : d === "keydown" && c.keyCode === 229 && (kt = "onCompositionStart");
            kt && (de && c.locale !== "ko" && (ie || kt !== "onCompositionStart" ? kt === "onCompositionEnd" && ie && (Bt = nd()) : (kd = ut,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie = !0)),
            Gt = oe(at, kt),
            0 < Gt.length && (kt = new Ld(kt,d,null,c,ut),
            pt.push({
                event: kt,
                listeners: Gt
            }),
            Bt ? kt.data = Bt : (Bt = he(c),
            Bt !== null && (kt.data = Bt)))),
            (Bt = ce ? je(d, c) : ke(d, c)) && (at = oe(at, "onBeforeInput"),
            0 < at.length && (ut = new Ld("onBeforeInput","beforeinput",null,c,ut),
            pt.push({
                event: ut,
                listeners: at
            }),
            ut.data = Bt))
        }
        se(pt, o)
    })
}
function tf(d, o, c) {
    return {
        instance: d,
        listener: o,
        currentTarget: c
    }
}
function oe(d, o) {
    for (var c = o + "Capture", h = []; d !== null; ) {
        var _ = d
          , b = _.stateNode;
        _.tag === 5 && b !== null && (_ = b,
        b = Kb(d, c),
        b != null && h.unshift(tf(d, b, _)),
        b = Kb(d, o),
        b != null && h.push(tf(d, b, _))),
        d = d.return
    }
    return h
}
function vf(d) {
    if (d === null)
        return null;
    do
        d = d.return;
    while (d && d.tag !== 5);
    return d || null
}
function wf(d, o, c, h, _) {
    for (var b = o._reactName, _e = []; c !== null && c !== h; ) {
        var nt = c
          , it = nt.alternate
          , at = nt.stateNode;
        if (it !== null && it === h)
            break;
        nt.tag === 5 && at !== null && (nt = at,
        _ ? (it = Kb(c, b),
        it != null && _e.unshift(tf(c, it, nt))) : _ || (it = Kb(c, b),
        it != null && _e.push(tf(c, it, nt)))),
        c = c.return
    }
    _e.length !== 0 && d.push({
        event: o,
        listeners: _e
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(d) {
    return (typeof d == "string" ? d : "" + d).replace(xf, `
`).replace(yf, "")
}
function Af(d, o, c) {
    if (o = zf(o),
    zf(d) !== o && c)
        throw Error(p(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(d, o) {
    return d === "textarea" || d === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(d) {
    return Hf.resolve(null).then(d).catch(If)
}
: Ff;
function If(d) {
    setTimeout(function() {
        throw d
    })
}
function Kf(d, o) {
    var c = o
      , h = 0;
    do {
        var _ = c.nextSibling;
        if (d.removeChild(c),
        _ && _.nodeType === 8)
            if (c = _.data,
            c === "/$") {
                if (h === 0) {
                    d.removeChild(_),
                    bd(o);
                    return
                }
                h--
            } else
                c !== "$" && c !== "$?" && c !== "$!" || h++;
        c = _
    } while (c);
    bd(o)
}
function Lf(d) {
    for (; d != null; d = d.nextSibling) {
        var o = d.nodeType;
        if (o === 1 || o === 3)
            break;
        if (o === 8) {
            if (o = d.data,
            o === "$" || o === "$!" || o === "$?")
                break;
            if (o === "/$")
                return null
        }
    }
    return d
}
function Mf(d) {
    d = d.previousSibling;
    for (var o = 0; d; ) {
        if (d.nodeType === 8) {
            var c = d.data;
            if (c === "$" || c === "$!" || c === "$?") {
                if (o === 0)
                    return d;
                o--
            } else
                c === "/$" && o++
        }
        d = d.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(d) {
    var o = d[Of];
    if (o)
        return o;
    for (var c = d.parentNode; c; ) {
        if (o = c[uf] || c[Of]) {
            if (c = o.alternate,
            o.child !== null || c !== null && c.child !== null)
                for (d = Mf(d); d !== null; ) {
                    if (c = d[Of])
                        return c;
                    d = Mf(d)
                }
            return o
        }
        d = c,
        c = d.parentNode
    }
    return null
}
function Cb(d) {
    return d = d[Of] || d[uf],
    !d || d.tag !== 5 && d.tag !== 6 && d.tag !== 13 && d.tag !== 3 ? null : d
}
function ue(d) {
    if (d.tag === 5 || d.tag === 6)
        return d.stateNode;
    throw Error(p(33))
}
function Db(d) {
    return d[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(d) {
    return {
        current: d
    }
}
function E(d) {
    0 > Tf || (d.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G(d, o) {
    Tf++,
    Sf[Tf] = d.current,
    d.current = o
}
var Vf = {}
  , H = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(d, o) {
    var c = d.type.contextTypes;
    if (!c)
        return Vf;
    var h = d.stateNode;
    if (h && h.__reactInternalMemoizedUnmaskedChildContext === o)
        return h.__reactInternalMemoizedMaskedChildContext;
    var _ = {}, b;
    for (b in c)
        _[b] = o[b];
    return h && (d = d.stateNode,
    d.__reactInternalMemoizedUnmaskedChildContext = o,
    d.__reactInternalMemoizedMaskedChildContext = _),
    _
}
function Zf(d) {
    return d = d.childContextTypes,
    d != null
}
function $f() {
    E(Wf),
    E(H)
}
function ag(d, o, c) {
    if (H.current !== Vf)
        throw Error(p(168));
    G(H, o),
    G(Wf, c)
}
function bg(d, o, c) {
    var h = d.stateNode;
    if (o = o.childContextTypes,
    typeof h.getChildContext != "function")
        return c;
    h = h.getChildContext();
    for (var _ in h)
        if (!(_ in o))
            throw Error(p(108, Ra(d) || "Unknown", _));
    return A({}, c, h)
}
function cg(d) {
    return d = (d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H.current,
    G(H, d),
    G(Wf, Wf.current),
    !0
}
function dg(d, o, c) {
    var h = d.stateNode;
    if (!h)
        throw Error(p(169));
    c ? (d = bg(d, o, Xf),
    h.__reactInternalMemoizedMergedChildContext = d,
    E(Wf),
    E(H),
    G(H, d)) : E(Wf),
    G(Wf, c)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(d) {
    eg === null ? eg = [d] : eg.push(d)
}
function ig(d) {
    fg = !0,
    hg(d)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var d = 0
          , o = C;
        try {
            var c = eg;
            for (C = 1; d < c.length; d++) {
                var h = c[d];
                do
                    h = h(!0);
                while (h !== null)
            }
            eg = null,
            fg = !1
        } catch (_) {
            throw eg !== null && (eg = eg.slice(d + 1)),
            ac(fc, jg),
            _
        } finally {
            C = o,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(d, o) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = d,
    ng = o
}
function ug(d, o, c) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = d;
    var h = rg;
    d = sg;
    var _ = 32 - oc(h) - 1;
    h &= ~(1 << _),
    c += 1;
    var b = 32 - oc(o) + _;
    if (30 < b) {
        var _e = _ - _ % 5;
        b = (h & (1 << _e) - 1).toString(32),
        h >>= _e,
        _ -= _e,
        rg = 1 << 32 - oc(o) + _ | c << _ | h,
        sg = b + d
    } else
        rg = 1 << b | c << _ | h,
        sg = d
}
function vg(d) {
    d.return !== null && (tg(d, 1),
    ug(d, 1, 0))
}
function wg(d) {
    for (; d === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; d === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I = !1
  , zg = null;
function Ag(d, o) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED",
    c.stateNode = o,
    c.return = d,
    o = d.deletions,
    o === null ? (d.deletions = [c],
    d.flags |= 16) : o.push(c)
}
function Cg(d, o) {
    switch (d.tag) {
    case 5:
        var c = d.type;
        return o = o.nodeType !== 1 || c.toLowerCase() !== o.nodeName.toLowerCase() ? null : o,
        o !== null ? (d.stateNode = o,
        xg = d,
        yg = Lf(o.firstChild),
        !0) : !1;
    case 6:
        return o = d.pendingProps === "" || o.nodeType !== 3 ? null : o,
        o !== null ? (d.stateNode = o,
        xg = d,
        yg = null,
        !0) : !1;
    case 13:
        return o = o.nodeType !== 8 ? null : o,
        o !== null ? (c = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        d.memoizedState = {
            dehydrated: o,
            treeContext: c,
            retryLane: 1073741824
        },
        c = Bg(18, null, null, 0),
        c.stateNode = o,
        c.return = d,
        d.child = c,
        xg = d,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(d) {
    return (d.mode & 1) !== 0 && (d.flags & 128) === 0
}
function Eg(d) {
    if (I) {
        var o = yg;
        if (o) {
            var c = o;
            if (!Cg(d, o)) {
                if (Dg(d))
                    throw Error(p(418));
                o = Lf(c.nextSibling);
                var h = xg;
                o && Cg(d, o) ? Ag(h, c) : (d.flags = d.flags & -4097 | 2,
                I = !1,
                xg = d)
            }
        } else {
            if (Dg(d))
                throw Error(p(418));
            d.flags = d.flags & -4097 | 2,
            I = !1,
            xg = d
        }
    }
}
function Fg(d) {
    for (d = d.return; d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13; )
        d = d.return;
    xg = d
}
function Gg(d) {
    if (d !== xg)
        return !1;
    if (!I)
        return Fg(d),
        I = !0,
        !1;
    var o;
    if ((o = d.tag !== 3) && !(o = d.tag !== 5) && (o = d.type,
    o = o !== "head" && o !== "body" && !Ef(d.type, d.memoizedProps)),
    o && (o = yg)) {
        if (Dg(d))
            throw Hg(),
            Error(p(418));
        for (; o; )
            Ag(d, o),
            o = Lf(o.nextSibling)
    }
    if (Fg(d),
    d.tag === 13) {
        if (d = d.memoizedState,
        d = d !== null ? d.dehydrated : null,
        !d)
            throw Error(p(317));
        e: {
            for (d = d.nextSibling,
            o = 0; d; ) {
                if (d.nodeType === 8) {
                    var c = d.data;
                    if (c === "/$") {
                        if (o === 0) {
                            yg = Lf(d.nextSibling);
                            break e
                        }
                        o--
                    } else
                        c !== "$" && c !== "$!" && c !== "$?" || o++
                }
                d = d.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(d.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var d = yg; d; )
        d = Lf(d.nextSibling)
}
function Ig() {
    yg = xg = null,
    I = !1
}
function Jg(d) {
    zg === null ? zg = [d] : zg.push(d)
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(d, o, c) {
    if (d = c.ref,
    d !== null && typeof d != "function" && typeof d != "object") {
        if (c._owner) {
            if (c = c._owner,
            c) {
                if (c.tag !== 1)
                    throw Error(p(309));
                var h = c.stateNode
            }
            if (!h)
                throw Error(p(147, d));
            var _ = h
              , b = "" + d;
            return o !== null && o.ref !== null && typeof o.ref == "function" && o.ref._stringRef === b ? o.ref : (o = function(_e) {
                var nt = _.refs;
                _e === null ? delete nt[b] : nt[b] = _e
            }
            ,
            o._stringRef = b,
            o)
        }
        if (typeof d != "string")
            throw Error(p(284));
        if (!c._owner)
            throw Error(p(290, d))
    }
    return d
}
function Mg(d, o) {
    throw d = Object.prototype.toString.call(o),
    Error(p(31, d === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : d))
}
function Ng(d) {
    var o = d._init;
    return o(d._payload)
}
function Og(d) {
    function o(At, Et) {
        if (d) {
            var Pt = At.deletions;
            Pt === null ? (At.deletions = [Et],
            At.flags |= 16) : Pt.push(Et)
        }
    }
    function c(At, Et) {
        if (!d)
            return null;
        for (; Et !== null; )
            o(At, Et),
            Et = Et.sibling;
        return null
    }
    function h(At, Et) {
        for (At = new Map; Et !== null; )
            Et.key !== null ? At.set(Et.key, Et) : At.set(Et.index, Et),
            Et = Et.sibling;
        return At
    }
    function _(At, Et) {
        return At = Pg(At, Et),
        At.index = 0,
        At.sibling = null,
        At
    }
    function b(At, Et, Pt) {
        return At.index = Pt,
        d ? (Pt = At.alternate,
        Pt !== null ? (Pt = Pt.index,
        Pt < Et ? (At.flags |= 2,
        Et) : Pt) : (At.flags |= 2,
        Et)) : (At.flags |= 1048576,
        Et)
    }
    function _e(At) {
        return d && At.alternate === null && (At.flags |= 2),
        At
    }
    function nt(At, Et, Pt, It) {
        return Et === null || Et.tag !== 6 ? (Et = Qg(Pt, At.mode, It),
        Et.return = At,
        Et) : (Et = _(Et, Pt),
        Et.return = At,
        Et)
    }
    function it(At, Et, Pt, It) {
        var Dt = Pt.type;
        return Dt === ya ? ut(At, Et, Pt.props.children, It, Pt.key) : Et !== null && (Et.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === Ha && Ng(Dt) === Et.type) ? (It = _(Et, Pt.props),
        It.ref = Lg(At, Et, Pt),
        It.return = At,
        It) : (It = Rg(Pt.type, Pt.key, Pt.props, null, At.mode, It),
        It.ref = Lg(At, Et, Pt),
        It.return = At,
        It)
    }
    function at(At, Et, Pt, It) {
        return Et === null || Et.tag !== 4 || Et.stateNode.containerInfo !== Pt.containerInfo || Et.stateNode.implementation !== Pt.implementation ? (Et = Sg(Pt, At.mode, It),
        Et.return = At,
        Et) : (Et = _(Et, Pt.children || []),
        Et.return = At,
        Et)
    }
    function ut(At, Et, Pt, It, Dt) {
        return Et === null || Et.tag !== 7 ? (Et = Tg(Pt, At.mode, It, Dt),
        Et.return = At,
        Et) : (Et = _(Et, Pt),
        Et.return = At,
        Et)
    }
    function pt(At, Et, Pt) {
        if (typeof Et == "string" && Et !== "" || typeof Et == "number")
            return Et = Qg("" + Et, At.mode, Pt),
            Et.return = At,
            Et;
        if (typeof Et == "object" && Et !== null) {
            switch (Et.$$typeof) {
            case va:
                return Pt = Rg(Et.type, Et.key, Et.props, null, At.mode, Pt),
                Pt.ref = Lg(At, null, Et),
                Pt.return = At,
                Pt;
            case wa:
                return Et = Sg(Et, At.mode, Pt),
                Et.return = At,
                Et;
            case Ha:
                var It = Et._init;
                return pt(At, It(Et._payload), Pt)
            }
            if (eb(Et) || Ka(Et))
                return Et = Tg(Et, At.mode, Pt, null),
                Et.return = At,
                Et;
            Mg(At, Et)
        }
        return null
    }
    function ht(At, Et, Pt, It) {
        var Dt = Et !== null ? Et.key : null;
        if (typeof Pt == "string" && Pt !== "" || typeof Pt == "number")
            return Dt !== null ? null : nt(At, Et, "" + Pt, It);
        if (typeof Pt == "object" && Pt !== null) {
            switch (Pt.$$typeof) {
            case va:
                return Pt.key === Dt ? it(At, Et, Pt, It) : null;
            case wa:
                return Pt.key === Dt ? at(At, Et, Pt, It) : null;
            case Ha:
                return Dt = Pt._init,
                ht(At, Et, Dt(Pt._payload), It)
            }
            if (eb(Pt) || Ka(Pt))
                return Dt !== null ? null : ut(At, Et, Pt, It, null);
            Mg(At, Pt)
        }
        return null
    }
    function _t(At, Et, Pt, It, Dt) {
        if (typeof It == "string" && It !== "" || typeof It == "number")
            return At = At.get(Pt) || null,
            nt(Et, At, "" + It, Dt);
        if (typeof It == "object" && It !== null) {
            switch (It.$$typeof) {
            case va:
                return At = At.get(It.key === null ? Pt : It.key) || null,
                it(Et, At, It, Dt);
            case wa:
                return At = At.get(It.key === null ? Pt : It.key) || null,
                at(Et, At, It, Dt);
            case Ha:
                var Gt = It._init;
                return _t(At, Et, Pt, Gt(It._payload), Dt)
            }
            if (eb(It) || Ka(It))
                return At = At.get(Pt) || null,
                ut(Et, At, It, Dt, null);
            Mg(Et, It)
        }
        return null
    }
    function vt(At, Et, Pt, It) {
        for (var Dt = null, Gt = null, Bt = Et, kt = Et = 0, Ut = null; Bt !== null && kt < Pt.length; kt++) {
            Bt.index > kt ? (Ut = Bt,
            Bt = null) : Ut = Bt.sibling;
            var Ht = ht(At, Bt, Pt[kt], It);
            if (Ht === null) {
                Bt === null && (Bt = Ut);
                break
            }
            d && Bt && Ht.alternate === null && o(At, Bt),
            Et = b(Ht, Et, kt),
            Gt === null ? Dt = Ht : Gt.sibling = Ht,
            Gt = Ht,
            Bt = Ut
        }
        if (kt === Pt.length)
            return c(At, Bt),
            I && tg(At, kt),
            Dt;
        if (Bt === null) {
            for (; kt < Pt.length; kt++)
                Bt = pt(At, Pt[kt], It),
                Bt !== null && (Et = b(Bt, Et, kt),
                Gt === null ? Dt = Bt : Gt.sibling = Bt,
                Gt = Bt);
            return I && tg(At, kt),
            Dt
        }
        for (Bt = h(At, Bt); kt < Pt.length; kt++)
            Ut = _t(Bt, At, kt, Pt[kt], It),
            Ut !== null && (d && Ut.alternate !== null && Bt.delete(Ut.key === null ? kt : Ut.key),
            Et = b(Ut, Et, kt),
            Gt === null ? Dt = Ut : Gt.sibling = Ut,
            Gt = Ut);
        return d && Bt.forEach(function(Kt) {
            return o(At, Kt)
        }),
        I && tg(At, kt),
        Dt
    }
    function bt(At, Et, Pt, It) {
        var Dt = Ka(Pt);
        if (typeof Dt != "function")
            throw Error(p(150));
        if (Pt = Dt.call(Pt),
        Pt == null)
            throw Error(p(151));
        for (var Gt = Dt = null, Bt = Et, kt = Et = 0, Ut = null, Ht = Pt.next(); Bt !== null && !Ht.done; kt++,
        Ht = Pt.next()) {
            Bt.index > kt ? (Ut = Bt,
            Bt = null) : Ut = Bt.sibling;
            var Kt = ht(At, Bt, Ht.value, It);
            if (Kt === null) {
                Bt === null && (Bt = Ut);
                break
            }
            d && Bt && Kt.alternate === null && o(At, Bt),
            Et = b(Kt, Et, kt),
            Gt === null ? Dt = Kt : Gt.sibling = Kt,
            Gt = Kt,
            Bt = Ut
        }
        if (Ht.done)
            return c(At, Bt),
            I && tg(At, kt),
            Dt;
        if (Bt === null) {
            for (; !Ht.done; kt++,
            Ht = Pt.next())
                Ht = pt(At, Ht.value, It),
                Ht !== null && (Et = b(Ht, Et, kt),
                Gt === null ? Dt = Ht : Gt.sibling = Ht,
                Gt = Ht);
            return I && tg(At, kt),
            Dt
        }
        for (Bt = h(At, Bt); !Ht.done; kt++,
        Ht = Pt.next())
            Ht = _t(Bt, At, kt, Ht.value, It),
            Ht !== null && (d && Ht.alternate !== null && Bt.delete(Ht.key === null ? kt : Ht.key),
            Et = b(Ht, Et, kt),
            Gt === null ? Dt = Ht : Gt.sibling = Ht,
            Gt = Ht);
        return d && Bt.forEach(function(Jt) {
            return o(At, Jt)
        }),
        I && tg(At, kt),
        Dt
    }
    function St(At, Et, Pt, It) {
        if (typeof Pt == "object" && Pt !== null && Pt.type === ya && Pt.key === null && (Pt = Pt.props.children),
        typeof Pt == "object" && Pt !== null) {
            switch (Pt.$$typeof) {
            case va:
                e: {
                    for (var Dt = Pt.key, Gt = Et; Gt !== null; ) {
                        if (Gt.key === Dt) {
                            if (Dt = Pt.type,
                            Dt === ya) {
                                if (Gt.tag === 7) {
                                    c(At, Gt.sibling),
                                    Et = _(Gt, Pt.props.children),
                                    Et.return = At,
                                    At = Et;
                                    break e
                                }
                            } else if (Gt.elementType === Dt || typeof Dt == "object" && Dt !== null && Dt.$$typeof === Ha && Ng(Dt) === Gt.type) {
                                c(At, Gt.sibling),
                                Et = _(Gt, Pt.props),
                                Et.ref = Lg(At, Gt, Pt),
                                Et.return = At,
                                At = Et;
                                break e
                            }
                            c(At, Gt);
                            break
                        } else
                            o(At, Gt);
                        Gt = Gt.sibling
                    }
                    Pt.type === ya ? (Et = Tg(Pt.props.children, At.mode, It, Pt.key),
                    Et.return = At,
                    At = Et) : (It = Rg(Pt.type, Pt.key, Pt.props, null, At.mode, It),
                    It.ref = Lg(At, Et, Pt),
                    It.return = At,
                    At = It)
                }
                return _e(At);
            case wa:
                e: {
                    for (Gt = Pt.key; Et !== null; ) {
                        if (Et.key === Gt)
                            if (Et.tag === 4 && Et.stateNode.containerInfo === Pt.containerInfo && Et.stateNode.implementation === Pt.implementation) {
                                c(At, Et.sibling),
                                Et = _(Et, Pt.children || []),
                                Et.return = At,
                                At = Et;
                                break e
                            } else {
                                c(At, Et);
                                break
                            }
                        else
                            o(At, Et);
                        Et = Et.sibling
                    }
                    Et = Sg(Pt, At.mode, It),
                    Et.return = At,
                    At = Et
                }
                return _e(At);
            case Ha:
                return Gt = Pt._init,
                St(At, Et, Gt(Pt._payload), It)
            }
            if (eb(Pt))
                return vt(At, Et, Pt, It);
            if (Ka(Pt))
                return bt(At, Et, Pt, It);
            Mg(At, Pt)
        }
        return typeof Pt == "string" && Pt !== "" || typeof Pt == "number" ? (Pt = "" + Pt,
        Et !== null && Et.tag === 6 ? (c(At, Et.sibling),
        Et = _(Et, Pt),
        Et.return = At,
        At = Et) : (c(At, Et),
        Et = Qg(Pt, At.mode, It),
        Et.return = At,
        At = Et),
        _e(At)) : c(At, Et)
    }
    return St
}
var Ug = Og(!0)
  , Vg = Og(!1)
  , Wg = Uf(null)
  , Xg = null
  , Yg = null
  , Zg = null;
function $g() {
    Zg = Yg = Xg = null
}
function ah(d) {
    var o = Wg.current;
    E(Wg),
    d._currentValue = o
}
function bh(d, o, c) {
    for (; d !== null; ) {
        var h = d.alternate;
        if ((d.childLanes & o) !== o ? (d.childLanes |= o,
        h !== null && (h.childLanes |= o)) : h !== null && (h.childLanes & o) !== o && (h.childLanes |= o),
        d === c)
            break;
        d = d.return
    }
}
function ch(d, o) {
    Xg = d,
    Zg = Yg = null,
    d = d.dependencies,
    d !== null && d.firstContext !== null && (d.lanes & o && (dh = !0),
    d.firstContext = null)
}
function eh(d) {
    var o = d._currentValue;
    if (Zg !== d)
        if (d = {
            context: d,
            memoizedValue: o,
            next: null
        },
        Yg === null) {
            if (Xg === null)
                throw Error(p(308));
            Yg = d,
            Xg.dependencies = {
                lanes: 0,
                firstContext: d
            }
        } else
            Yg = Yg.next = d;
    return o
}
var fh = null;
function gh(d) {
    fh === null ? fh = [d] : fh.push(d)
}
function hh(d, o, c, h) {
    var _ = o.interleaved;
    return _ === null ? (c.next = c,
    gh(o)) : (c.next = _.next,
    _.next = c),
    o.interleaved = c,
    ih(d, h)
}
function ih(d, o) {
    d.lanes |= o;
    var c = d.alternate;
    for (c !== null && (c.lanes |= o),
    c = d,
    d = d.return; d !== null; )
        d.childLanes |= o,
        c = d.alternate,
        c !== null && (c.childLanes |= o),
        c = d,
        d = d.return;
    return c.tag === 3 ? c.stateNode : null
}
var jh = !1;
function kh(d) {
    d.updateQueue = {
        baseState: d.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function lh(d, o) {
    d = d.updateQueue,
    o.updateQueue === d && (o.updateQueue = {
        baseState: d.baseState,
        firstBaseUpdate: d.firstBaseUpdate,
        lastBaseUpdate: d.lastBaseUpdate,
        shared: d.shared,
        effects: d.effects
    })
}
function mh(d, o) {
    return {
        eventTime: d,
        lane: o,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function nh(d, o, c) {
    var h = d.updateQueue;
    if (h === null)
        return null;
    if (h = h.shared,
    K & 2) {
        var _ = h.pending;
        return _ === null ? o.next = o : (o.next = _.next,
        _.next = o),
        h.pending = o,
        ih(d, c)
    }
    return _ = h.interleaved,
    _ === null ? (o.next = o,
    gh(h)) : (o.next = _.next,
    _.next = o),
    h.interleaved = o,
    ih(d, c)
}
function oh(d, o, c) {
    if (o = o.updateQueue,
    o !== null && (o = o.shared,
    (c & 4194240) !== 0)) {
        var h = o.lanes;
        h &= d.pendingLanes,
        c |= h,
        o.lanes = c,
        Cc(d, c)
    }
}
function ph(d, o) {
    var c = d.updateQueue
      , h = d.alternate;
    if (h !== null && (h = h.updateQueue,
    c === h)) {
        var _ = null
          , b = null;
        if (c = c.firstBaseUpdate,
        c !== null) {
            do {
                var _e = {
                    eventTime: c.eventTime,
                    lane: c.lane,
                    tag: c.tag,
                    payload: c.payload,
                    callback: c.callback,
                    next: null
                };
                b === null ? _ = b = _e : b = b.next = _e,
                c = c.next
            } while (c !== null);
            b === null ? _ = b = o : b = b.next = o
        } else
            _ = b = o;
        c = {
            baseState: h.baseState,
            firstBaseUpdate: _,
            lastBaseUpdate: b,
            shared: h.shared,
            effects: h.effects
        },
        d.updateQueue = c;
        return
    }
    d = c.lastBaseUpdate,
    d === null ? c.firstBaseUpdate = o : d.next = o,
    c.lastBaseUpdate = o
}
function qh(d, o, c, h) {
    var _ = d.updateQueue;
    jh = !1;
    var b = _.firstBaseUpdate
      , _e = _.lastBaseUpdate
      , nt = _.shared.pending;
    if (nt !== null) {
        _.shared.pending = null;
        var it = nt
          , at = it.next;
        it.next = null,
        _e === null ? b = at : _e.next = at,
        _e = it;
        var ut = d.alternate;
        ut !== null && (ut = ut.updateQueue,
        nt = ut.lastBaseUpdate,
        nt !== _e && (nt === null ? ut.firstBaseUpdate = at : nt.next = at,
        ut.lastBaseUpdate = it))
    }
    if (b !== null) {
        var pt = _.baseState;
        _e = 0,
        ut = at = it = null,
        nt = b;
        do {
            var ht = nt.lane
              , _t = nt.eventTime;
            if ((h & ht) === ht) {
                ut !== null && (ut = ut.next = {
                    eventTime: _t,
                    lane: 0,
                    tag: nt.tag,
                    payload: nt.payload,
                    callback: nt.callback,
                    next: null
                });
                e: {
                    var vt = d
                      , bt = nt;
                    switch (ht = o,
                    _t = c,
                    bt.tag) {
                    case 1:
                        if (vt = bt.payload,
                        typeof vt == "function") {
                            pt = vt.call(_t, pt, ht);
                            break e
                        }
                        pt = vt;
                        break e;
                    case 3:
                        vt.flags = vt.flags & -65537 | 128;
                    case 0:
                        if (vt = bt.payload,
                        ht = typeof vt == "function" ? vt.call(_t, pt, ht) : vt,
                        ht == null)
                            break e;
                        pt = A({}, pt, ht);
                        break e;
                    case 2:
                        jh = !0
                    }
                }
                nt.callback !== null && nt.lane !== 0 && (d.flags |= 64,
                ht = _.effects,
                ht === null ? _.effects = [nt] : ht.push(nt))
            } else
                _t = {
                    eventTime: _t,
                    lane: ht,
                    tag: nt.tag,
                    payload: nt.payload,
                    callback: nt.callback,
                    next: null
                },
                ut === null ? (at = ut = _t,
                it = pt) : ut = ut.next = _t,
                _e |= ht;
            if (nt = nt.next,
            nt === null) {
                if (nt = _.shared.pending,
                nt === null)
                    break;
                ht = nt,
                nt = ht.next,
                ht.next = null,
                _.lastBaseUpdate = ht,
                _.shared.pending = null
            }
        } while (!0);
        if (ut === null && (it = pt),
        _.baseState = it,
        _.firstBaseUpdate = at,
        _.lastBaseUpdate = ut,
        o = _.shared.interleaved,
        o !== null) {
            _ = o;
            do
                _e |= _.lane,
                _ = _.next;
            while (_ !== o)
        } else
            b === null && (_.shared.lanes = 0);
        rh |= _e,
        d.lanes = _e,
        d.memoizedState = pt
    }
}
function sh(d, o, c) {
    if (d = o.effects,
    o.effects = null,
    d !== null)
        for (o = 0; o < d.length; o++) {
            var h = d[o]
              , _ = h.callback;
            if (_ !== null) {
                if (h.callback = null,
                h = c,
                typeof _ != "function")
                    throw Error(p(191, _));
                _.call(h)
            }
        }
}
var th = {}
  , uh = Uf(th)
  , vh$1 = Uf(th)
  , wh = Uf(th);
function xh(d) {
    if (d === th)
        throw Error(p(174));
    return d
}
function yh(d, o) {
    switch (G(wh, o),
    G(vh$1, d),
    G(uh, th),
    d = o.nodeType,
    d) {
    case 9:
    case 11:
        o = (o = o.documentElement) ? o.namespaceURI : lb(null, "");
        break;
    default:
        d = d === 8 ? o.parentNode : o,
        o = d.namespaceURI || null,
        d = d.tagName,
        o = lb(o, d)
    }
    E(uh),
    G(uh, o)
}
function zh() {
    E(uh),
    E(vh$1),
    E(wh)
}
function Ah(d) {
    xh(wh.current);
    var o = xh(uh.current)
      , c = lb(o, d.type);
    o !== c && (G(vh$1, d),
    G(uh, c))
}
function Bh(d) {
    vh$1.current === d && (E(uh),
    E(vh$1))
}
var L = Uf(0);
function Ch(d) {
    for (var o = d; o !== null; ) {
        if (o.tag === 13) {
            var c = o.memoizedState;
            if (c !== null && (c = c.dehydrated,
            c === null || c.data === "$?" || c.data === "$!"))
                return o
        } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
            if (o.flags & 128)
                return o
        } else if (o.child !== null) {
            o.child.return = o,
            o = o.child;
            continue
        }
        if (o === d)
            break;
        for (; o.sibling === null; ) {
            if (o.return === null || o.return === d)
                return null;
            o = o.return
        }
        o.sibling.return = o.return,
        o = o.sibling
    }
    return null
}
var Dh = [];
function Eh() {
    for (var d = 0; d < Dh.length; d++)
        Dh[d]._workInProgressVersionPrimary = null;
    Dh.length = 0
}
var Fh = ua.ReactCurrentDispatcher
  , Gh = ua.ReactCurrentBatchConfig
  , Hh = 0
  , M = null
  , N = null
  , O = null
  , Ih = !1
  , Jh = !1
  , Kh = 0
  , Lh = 0;
function P() {
    throw Error(p(321))
}
function Mh(d, o) {
    if (o === null)
        return !1;
    for (var c = 0; c < o.length && c < d.length; c++)
        if (!He(d[c], o[c]))
            return !1;
    return !0
}
function Nh(d, o, c, h, _, b) {
    if (Hh = b,
    M = o,
    o.memoizedState = null,
    o.updateQueue = null,
    o.lanes = 0,
    Fh.current = d === null || d.memoizedState === null ? Oh : Ph,
    d = c(h, _),
    Jh) {
        b = 0;
        do {
            if (Jh = !1,
            Kh = 0,
            25 <= b)
                throw Error(p(301));
            b += 1,
            O = N = null,
            o.updateQueue = null,
            Fh.current = Qh,
            d = c(h, _)
        } while (Jh)
    }
    if (Fh.current = Rh,
    o = N !== null && N.next !== null,
    Hh = 0,
    O = N = M = null,
    Ih = !1,
    o)
        throw Error(p(300));
    return d
}
function Sh() {
    var d = Kh !== 0;
    return Kh = 0,
    d
}
function Th() {
    var d = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return O === null ? M.memoizedState = O = d : O = O.next = d,
    O
}
function Uh() {
    if (N === null) {
        var d = M.alternate;
        d = d !== null ? d.memoizedState : null
    } else
        d = N.next;
    var o = O === null ? M.memoizedState : O.next;
    if (o !== null)
        O = o,
        N = d;
    else {
        if (d === null)
            throw Error(p(310));
        N = d,
        d = {
            memoizedState: N.memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null
        },
        O === null ? M.memoizedState = O = d : O = O.next = d
    }
    return O
}
function Vh(d, o) {
    return typeof o == "function" ? o(d) : o
}
function Wh(d) {
    var o = Uh()
      , c = o.queue;
    if (c === null)
        throw Error(p(311));
    c.lastRenderedReducer = d;
    var h = N
      , _ = h.baseQueue
      , b = c.pending;
    if (b !== null) {
        if (_ !== null) {
            var _e = _.next;
            _.next = b.next,
            b.next = _e
        }
        h.baseQueue = _ = b,
        c.pending = null
    }
    if (_ !== null) {
        b = _.next,
        h = h.baseState;
        var nt = _e = null
          , it = null
          , at = b;
        do {
            var ut = at.lane;
            if ((Hh & ut) === ut)
                it !== null && (it = it.next = {
                    lane: 0,
                    action: at.action,
                    hasEagerState: at.hasEagerState,
                    eagerState: at.eagerState,
                    next: null
                }),
                h = at.hasEagerState ? at.eagerState : d(h, at.action);
            else {
                var pt = {
                    lane: ut,
                    action: at.action,
                    hasEagerState: at.hasEagerState,
                    eagerState: at.eagerState,
                    next: null
                };
                it === null ? (nt = it = pt,
                _e = h) : it = it.next = pt,
                M.lanes |= ut,
                rh |= ut
            }
            at = at.next
        } while (at !== null && at !== b);
        it === null ? _e = h : it.next = nt,
        He(h, o.memoizedState) || (dh = !0),
        o.memoizedState = h,
        o.baseState = _e,
        o.baseQueue = it,
        c.lastRenderedState = h
    }
    if (d = c.interleaved,
    d !== null) {
        _ = d;
        do
            b = _.lane,
            M.lanes |= b,
            rh |= b,
            _ = _.next;
        while (_ !== d)
    } else
        _ === null && (c.lanes = 0);
    return [o.memoizedState, c.dispatch]
}
function Xh(d) {
    var o = Uh()
      , c = o.queue;
    if (c === null)
        throw Error(p(311));
    c.lastRenderedReducer = d;
    var h = c.dispatch
      , _ = c.pending
      , b = o.memoizedState;
    if (_ !== null) {
        c.pending = null;
        var _e = _ = _.next;
        do
            b = d(b, _e.action),
            _e = _e.next;
        while (_e !== _);
        He(b, o.memoizedState) || (dh = !0),
        o.memoizedState = b,
        o.baseQueue === null && (o.baseState = b),
        c.lastRenderedState = b
    }
    return [b, h]
}
function Yh() {}
function Zh(d, o) {
    var c = M
      , h = Uh()
      , _ = o()
      , b = !He(h.memoizedState, _);
    if (b && (h.memoizedState = _,
    dh = !0),
    h = h.queue,
    $h(ai.bind(null, c, h, d), [d]),
    h.getSnapshot !== o || b || O !== null && O.memoizedState.tag & 1) {
        if (c.flags |= 2048,
        bi(9, ci.bind(null, c, h, _, o), void 0, null),
        Q === null)
            throw Error(p(349));
        Hh & 30 || di(c, o, _)
    }
    return _
}
function di(d, o, c) {
    d.flags |= 16384,
    d = {
        getSnapshot: o,
        value: c
    },
    o = M.updateQueue,
    o === null ? (o = {
        lastEffect: null,
        stores: null
    },
    M.updateQueue = o,
    o.stores = [d]) : (c = o.stores,
    c === null ? o.stores = [d] : c.push(d))
}
function ci(d, o, c, h) {
    o.value = c,
    o.getSnapshot = h,
    ei(o) && fi(d)
}
function ai(d, o, c) {
    return c(function() {
        ei(o) && fi(d)
    })
}
function ei(d) {
    var o = d.getSnapshot;
    d = d.value;
    try {
        var c = o();
        return !He(d, c)
    } catch {
        return !0
    }
}
function fi(d) {
    var o = ih(d, 1);
    o !== null && gi(o, d, 1, -1)
}
function hi(d) {
    var o = Th();
    return typeof d == "function" && (d = d()),
    o.memoizedState = o.baseState = d,
    d = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Vh,
        lastRenderedState: d
    },
    o.queue = d,
    d = d.dispatch = ii.bind(null, M, d),
    [o.memoizedState, d]
}
function bi(d, o, c, h) {
    return d = {
        tag: d,
        create: o,
        destroy: c,
        deps: h,
        next: null
    },
    o = M.updateQueue,
    o === null ? (o = {
        lastEffect: null,
        stores: null
    },
    M.updateQueue = o,
    o.lastEffect = d.next = d) : (c = o.lastEffect,
    c === null ? o.lastEffect = d.next = d : (h = c.next,
    c.next = d,
    d.next = h,
    o.lastEffect = d)),
    d
}
function ji() {
    return Uh().memoizedState
}
function ki(d, o, c, h) {
    var _ = Th();
    M.flags |= d,
    _.memoizedState = bi(1 | o, c, void 0, h === void 0 ? null : h)
}
function li(d, o, c, h) {
    var _ = Uh();
    h = h === void 0 ? null : h;
    var b = void 0;
    if (N !== null) {
        var _e = N.memoizedState;
        if (b = _e.destroy,
        h !== null && Mh(h, _e.deps)) {
            _.memoizedState = bi(o, c, b, h);
            return
        }
    }
    M.flags |= d,
    _.memoizedState = bi(1 | o, c, b, h)
}
function mi(d, o) {
    return ki(8390656, 8, d, o)
}
function $h(d, o) {
    return li(2048, 8, d, o)
}
function ni(d, o) {
    return li(4, 2, d, o)
}
function oi(d, o) {
    return li(4, 4, d, o)
}
function pi(d, o) {
    if (typeof o == "function")
        return d = d(),
        o(d),
        function() {
            o(null)
        }
        ;
    if (o != null)
        return d = d(),
        o.current = d,
        function() {
            o.current = null
        }
}
function qi(d, o, c) {
    return c = c != null ? c.concat([d]) : null,
    li(4, 4, pi.bind(null, o, d), c)
}
function ri() {}
function si(d, o) {
    var c = Uh();
    o = o === void 0 ? null : o;
    var h = c.memoizedState;
    return h !== null && o !== null && Mh(o, h[1]) ? h[0] : (c.memoizedState = [d, o],
    d)
}
function ti(d, o) {
    var c = Uh();
    o = o === void 0 ? null : o;
    var h = c.memoizedState;
    return h !== null && o !== null && Mh(o, h[1]) ? h[0] : (d = d(),
    c.memoizedState = [d, o],
    d)
}
function ui(d, o, c) {
    return Hh & 21 ? (He(c, o) || (c = yc(),
    M.lanes |= c,
    rh |= c,
    d.baseState = !0),
    o) : (d.baseState && (d.baseState = !1,
    dh = !0),
    d.memoizedState = c)
}
function vi(d, o) {
    var c = C;
    C = c !== 0 && 4 > c ? c : 4,
    d(!0);
    var h = Gh.transition;
    Gh.transition = {};
    try {
        d(!1),
        o()
    } finally {
        C = c,
        Gh.transition = h
    }
}
function wi() {
    return Uh().memoizedState
}
function xi(d, o, c) {
    var h = yi(d);
    if (c = {
        lane: h,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    zi(d))
        Ai(o, c);
    else if (c = hh(d, o, c, h),
    c !== null) {
        var _ = R();
        gi(c, d, h, _),
        Bi(c, o, h)
    }
}
function ii(d, o, c) {
    var h = yi(d)
      , _ = {
        lane: h,
        action: c,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (zi(d))
        Ai(o, _);
    else {
        var b = d.alternate;
        if (d.lanes === 0 && (b === null || b.lanes === 0) && (b = o.lastRenderedReducer,
        b !== null))
            try {
                var _e = o.lastRenderedState
                  , nt = b(_e, c);
                if (_.hasEagerState = !0,
                _.eagerState = nt,
                He(nt, _e)) {
                    var it = o.interleaved;
                    it === null ? (_.next = _,
                    gh(o)) : (_.next = it.next,
                    it.next = _),
                    o.interleaved = _;
                    return
                }
            } catch {} finally {}
        c = hh(d, o, _, h),
        c !== null && (_ = R(),
        gi(c, d, h, _),
        Bi(c, o, h))
    }
}
function zi(d) {
    var o = d.alternate;
    return d === M || o !== null && o === M
}
function Ai(d, o) {
    Jh = Ih = !0;
    var c = d.pending;
    c === null ? o.next = o : (o.next = c.next,
    c.next = o),
    d.pending = o
}
function Bi(d, o, c) {
    if (c & 4194240) {
        var h = o.lanes;
        h &= d.pendingLanes,
        c |= h,
        o.lanes = c,
        Cc(d, c)
    }
}
var Rh = {
    readContext: eh,
    useCallback: P,
    useContext: P,
    useEffect: P,
    useImperativeHandle: P,
    useInsertionEffect: P,
    useLayoutEffect: P,
    useMemo: P,
    useReducer: P,
    useRef: P,
    useState: P,
    useDebugValue: P,
    useDeferredValue: P,
    useTransition: P,
    useMutableSource: P,
    useSyncExternalStore: P,
    useId: P,
    unstable_isNewReconciler: !1
}
  , Oh = {
    readContext: eh,
    useCallback: function(d, o) {
        return Th().memoizedState = [d, o === void 0 ? null : o],
        d
    },
    useContext: eh,
    useEffect: mi,
    useImperativeHandle: function(d, o, c) {
        return c = c != null ? c.concat([d]) : null,
        ki(4194308, 4, pi.bind(null, o, d), c)
    },
    useLayoutEffect: function(d, o) {
        return ki(4194308, 4, d, o)
    },
    useInsertionEffect: function(d, o) {
        return ki(4, 2, d, o)
    },
    useMemo: function(d, o) {
        var c = Th();
        return o = o === void 0 ? null : o,
        d = d(),
        c.memoizedState = [d, o],
        d
    },
    useReducer: function(d, o, c) {
        var h = Th();
        return o = c !== void 0 ? c(o) : o,
        h.memoizedState = h.baseState = o,
        d = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: d,
            lastRenderedState: o
        },
        h.queue = d,
        d = d.dispatch = xi.bind(null, M, d),
        [h.memoizedState, d]
    },
    useRef: function(d) {
        var o = Th();
        return d = {
            current: d
        },
        o.memoizedState = d
    },
    useState: hi,
    useDebugValue: ri,
    useDeferredValue: function(d) {
        return Th().memoizedState = d
    },
    useTransition: function() {
        var d = hi(!1)
          , o = d[0];
        return d = vi.bind(null, d[1]),
        Th().memoizedState = d,
        [o, d]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(d, o, c) {
        var h = M
          , _ = Th();
        if (I) {
            if (c === void 0)
                throw Error(p(407));
            c = c()
        } else {
            if (c = o(),
            Q === null)
                throw Error(p(349));
            Hh & 30 || di(h, o, c)
        }
        _.memoizedState = c;
        var b = {
            value: c,
            getSnapshot: o
        };
        return _.queue = b,
        mi(ai.bind(null, h, b, d), [d]),
        h.flags |= 2048,
        bi(9, ci.bind(null, h, b, c, o), void 0, null),
        c
    },
    useId: function() {
        var d = Th()
          , o = Q.identifierPrefix;
        if (I) {
            var c = sg
              , h = rg;
            c = (h & ~(1 << 32 - oc(h) - 1)).toString(32) + c,
            o = ":" + o + "R" + c,
            c = Kh++,
            0 < c && (o += "H" + c.toString(32)),
            o += ":"
        } else
            c = Lh++,
            o = ":" + o + "r" + c.toString(32) + ":";
        return d.memoizedState = o
    },
    unstable_isNewReconciler: !1
}
  , Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
        return Wh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(d) {
        var o = Uh();
        return ui(o, N.memoizedState, d)
    },
    useTransition: function() {
        var d = Wh(Vh)[0]
          , o = Uh().memoizedState;
        return [d, o]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
}
  , Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function() {
        return Xh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(d) {
        var o = Uh();
        return N === null ? o.memoizedState = d : ui(o, N.memoizedState, d)
    },
    useTransition: function() {
        var d = Xh(Vh)[0]
          , o = Uh().memoizedState;
        return [d, o]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
};
function Ci(d, o) {
    if (d && d.defaultProps) {
        o = A({}, o),
        d = d.defaultProps;
        for (var c in d)
            o[c] === void 0 && (o[c] = d[c]);
        return o
    }
    return o
}
function Di(d, o, c, h) {
    o = d.memoizedState,
    c = c(h, o),
    c = c == null ? o : A({}, o, c),
    d.memoizedState = c,
    d.lanes === 0 && (d.updateQueue.baseState = c)
}
var Ei = {
    isMounted: function(d) {
        return (d = d._reactInternals) ? Vb(d) === d : !1
    },
    enqueueSetState: function(d, o, c) {
        d = d._reactInternals;
        var h = R()
          , _ = yi(d)
          , b = mh(h, _);
        b.payload = o,
        c != null && (b.callback = c),
        o = nh(d, b, _),
        o !== null && (gi(o, d, _, h),
        oh(o, d, _))
    },
    enqueueReplaceState: function(d, o, c) {
        d = d._reactInternals;
        var h = R()
          , _ = yi(d)
          , b = mh(h, _);
        b.tag = 1,
        b.payload = o,
        c != null && (b.callback = c),
        o = nh(d, b, _),
        o !== null && (gi(o, d, _, h),
        oh(o, d, _))
    },
    enqueueForceUpdate: function(d, o) {
        d = d._reactInternals;
        var c = R()
          , h = yi(d)
          , _ = mh(c, h);
        _.tag = 2,
        o != null && (_.callback = o),
        o = nh(d, _, h),
        o !== null && (gi(o, d, h, c),
        oh(o, d, h))
    }
};
function Fi(d, o, c, h, _, b, _e) {
    return d = d.stateNode,
    typeof d.shouldComponentUpdate == "function" ? d.shouldComponentUpdate(h, b, _e) : o.prototype && o.prototype.isPureReactComponent ? !Ie(c, h) || !Ie(_, b) : !0
}
function Gi(d, o, c) {
    var h = !1
      , _ = Vf
      , b = o.contextType;
    return typeof b == "object" && b !== null ? b = eh(b) : (_ = Zf(o) ? Xf : H.current,
    h = o.contextTypes,
    b = (h = h != null) ? Yf(d, _) : Vf),
    o = new o(c,b),
    d.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null,
    o.updater = Ei,
    d.stateNode = o,
    o._reactInternals = d,
    h && (d = d.stateNode,
    d.__reactInternalMemoizedUnmaskedChildContext = _,
    d.__reactInternalMemoizedMaskedChildContext = b),
    o
}
function Hi(d, o, c, h) {
    d = o.state,
    typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(c, h),
    typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(c, h),
    o.state !== d && Ei.enqueueReplaceState(o, o.state, null)
}
function Ii(d, o, c, h) {
    var _ = d.stateNode;
    _.props = c,
    _.state = d.memoizedState,
    _.refs = {},
    kh(d);
    var b = o.contextType;
    typeof b == "object" && b !== null ? _.context = eh(b) : (b = Zf(o) ? Xf : H.current,
    _.context = Yf(d, b)),
    _.state = d.memoizedState,
    b = o.getDerivedStateFromProps,
    typeof b == "function" && (Di(d, o, b, c),
    _.state = d.memoizedState),
    typeof o.getDerivedStateFromProps == "function" || typeof _.getSnapshotBeforeUpdate == "function" || typeof _.UNSAFE_componentWillMount != "function" && typeof _.componentWillMount != "function" || (o = _.state,
    typeof _.componentWillMount == "function" && _.componentWillMount(),
    typeof _.UNSAFE_componentWillMount == "function" && _.UNSAFE_componentWillMount(),
    o !== _.state && Ei.enqueueReplaceState(_, _.state, null),
    qh(d, c, _, h),
    _.state = d.memoizedState),
    typeof _.componentDidMount == "function" && (d.flags |= 4194308)
}
function Ji(d, o) {
    try {
        var c = ""
          , h = o;
        do
            c += Pa(h),
            h = h.return;
        while (h);
        var _ = c
    } catch (b) {
        _ = `
Error generating stack: ` + b.message + `
` + b.stack
    }
    return {
        value: d,
        source: o,
        stack: _,
        digest: null
    }
}
function Ki(d, o, c) {
    return {
        value: d,
        source: null,
        stack: c ?? null,
        digest: o ?? null
    }
}
function Li(d, o) {
    try {
        console.error(o.value)
    } catch (c) {
        setTimeout(function() {
            throw c
        })
    }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;
function Ni(d, o, c) {
    c = mh(-1, c),
    c.tag = 3,
    c.payload = {
        element: null
    };
    var h = o.value;
    return c.callback = function() {
        Oi || (Oi = !0,
        Pi = h),
        Li(d, o)
    }
    ,
    c
}
function Qi(d, o, c) {
    c = mh(-1, c),
    c.tag = 3;
    var h = d.type.getDerivedStateFromError;
    if (typeof h == "function") {
        var _ = o.value;
        c.payload = function() {
            return h(_)
        }
        ,
        c.callback = function() {
            Li(d, o)
        }
    }
    var b = d.stateNode;
    return b !== null && typeof b.componentDidCatch == "function" && (c.callback = function() {
        Li(d, o),
        typeof h != "function" && (Ri === null ? Ri = new Set([this]) : Ri.add(this));
        var _e = o.stack;
        this.componentDidCatch(o.value, {
            componentStack: _e !== null ? _e : ""
        })
    }
    ),
    c
}
function Si(d, o, c) {
    var h = d.pingCache;
    if (h === null) {
        h = d.pingCache = new Mi;
        var _ = new Set;
        h.set(o, _)
    } else
        _ = h.get(o),
        _ === void 0 && (_ = new Set,
        h.set(o, _));
    _.has(c) || (_.add(c),
    d = Ti.bind(null, d, o, c),
    o.then(d, d))
}
function Ui(d) {
    do {
        var o;
        if ((o = d.tag === 13) && (o = d.memoizedState,
        o = o !== null ? o.dehydrated !== null : !0),
        o)
            return d;
        d = d.return
    } while (d !== null);
    return null
}
function Vi(d, o, c, h, _) {
    return d.mode & 1 ? (d.flags |= 65536,
    d.lanes = _,
    d) : (d === o ? d.flags |= 65536 : (d.flags |= 128,
    c.flags |= 131072,
    c.flags &= -52805,
    c.tag === 1 && (c.alternate === null ? c.tag = 17 : (o = mh(-1, 1),
    o.tag = 2,
    nh(c, o, 1))),
    c.lanes |= 1),
    d)
}
var Wi = ua.ReactCurrentOwner
  , dh = !1;
function Xi(d, o, c, h) {
    o.child = d === null ? Vg(o, null, c, h) : Ug(o, d.child, c, h)
}
function Yi(d, o, c, h, _) {
    c = c.render;
    var b = o.ref;
    return ch(o, _),
    h = Nh(d, o, c, h, b, _),
    c = Sh(),
    d !== null && !dh ? (o.updateQueue = d.updateQueue,
    o.flags &= -2053,
    d.lanes &= ~_,
    Zi(d, o, _)) : (I && c && vg(o),
    o.flags |= 1,
    Xi(d, o, h, _),
    o.child)
}
function $i(d, o, c, h, _) {
    if (d === null) {
        var b = c.type;
        return typeof b == "function" && !aj(b) && b.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (o.tag = 15,
        o.type = b,
        bj(d, o, b, h, _)) : (d = Rg(c.type, null, h, o, o.mode, _),
        d.ref = o.ref,
        d.return = o,
        o.child = d)
    }
    if (b = d.child,
    !(d.lanes & _)) {
        var _e = b.memoizedProps;
        if (c = c.compare,
        c = c !== null ? c : Ie,
        c(_e, h) && d.ref === o.ref)
            return Zi(d, o, _)
    }
    return o.flags |= 1,
    d = Pg(b, h),
    d.ref = o.ref,
    d.return = o,
    o.child = d
}
function bj(d, o, c, h, _) {
    if (d !== null) {
        var b = d.memoizedProps;
        if (Ie(b, h) && d.ref === o.ref)
            if (dh = !1,
            o.pendingProps = h = b,
            (d.lanes & _) !== 0)
                d.flags & 131072 && (dh = !0);
            else
                return o.lanes = d.lanes,
                Zi(d, o, _)
    }
    return cj(d, o, c, h, _)
}
function dj(d, o, c) {
    var h = o.pendingProps
      , _ = h.children
      , b = d !== null ? d.memoizedState : null;
    if (h.mode === "hidden")
        if (!(o.mode & 1))
            o.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G(ej, fj),
            fj |= c;
        else {
            if (!(c & 1073741824))
                return d = b !== null ? b.baseLanes | c : c,
                o.lanes = o.childLanes = 1073741824,
                o.memoizedState = {
                    baseLanes: d,
                    cachePool: null,
                    transitions: null
                },
                o.updateQueue = null,
                G(ej, fj),
                fj |= d,
                null;
            o.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            h = b !== null ? b.baseLanes : c,
            G(ej, fj),
            fj |= h
        }
    else
        b !== null ? (h = b.baseLanes | c,
        o.memoizedState = null) : h = c,
        G(ej, fj),
        fj |= h;
    return Xi(d, o, _, c),
    o.child
}
function gj(d, o) {
    var c = o.ref;
    (d === null && c !== null || d !== null && d.ref !== c) && (o.flags |= 512,
    o.flags |= 2097152)
}
function cj(d, o, c, h, _) {
    var b = Zf(c) ? Xf : H.current;
    return b = Yf(o, b),
    ch(o, _),
    c = Nh(d, o, c, h, b, _),
    h = Sh(),
    d !== null && !dh ? (o.updateQueue = d.updateQueue,
    o.flags &= -2053,
    d.lanes &= ~_,
    Zi(d, o, _)) : (I && h && vg(o),
    o.flags |= 1,
    Xi(d, o, c, _),
    o.child)
}
function hj(d, o, c, h, _) {
    if (Zf(c)) {
        var b = !0;
        cg(o)
    } else
        b = !1;
    if (ch(o, _),
    o.stateNode === null)
        ij(d, o),
        Gi(o, c, h),
        Ii(o, c, h, _),
        h = !0;
    else if (d === null) {
        var _e = o.stateNode
          , nt = o.memoizedProps;
        _e.props = nt;
        var it = _e.context
          , at = c.contextType;
        typeof at == "object" && at !== null ? at = eh(at) : (at = Zf(c) ? Xf : H.current,
        at = Yf(o, at));
        var ut = c.getDerivedStateFromProps
          , pt = typeof ut == "function" || typeof _e.getSnapshotBeforeUpdate == "function";
        pt || typeof _e.UNSAFE_componentWillReceiveProps != "function" && typeof _e.componentWillReceiveProps != "function" || (nt !== h || it !== at) && Hi(o, _e, h, at),
        jh = !1;
        var ht = o.memoizedState;
        _e.state = ht,
        qh(o, h, _e, _),
        it = o.memoizedState,
        nt !== h || ht !== it || Wf.current || jh ? (typeof ut == "function" && (Di(o, c, ut, h),
        it = o.memoizedState),
        (nt = jh || Fi(o, c, nt, h, ht, it, at)) ? (pt || typeof _e.UNSAFE_componentWillMount != "function" && typeof _e.componentWillMount != "function" || (typeof _e.componentWillMount == "function" && _e.componentWillMount(),
        typeof _e.UNSAFE_componentWillMount == "function" && _e.UNSAFE_componentWillMount()),
        typeof _e.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof _e.componentDidMount == "function" && (o.flags |= 4194308),
        o.memoizedProps = h,
        o.memoizedState = it),
        _e.props = h,
        _e.state = it,
        _e.context = at,
        h = nt) : (typeof _e.componentDidMount == "function" && (o.flags |= 4194308),
        h = !1)
    } else {
        _e = o.stateNode,
        lh(d, o),
        nt = o.memoizedProps,
        at = o.type === o.elementType ? nt : Ci(o.type, nt),
        _e.props = at,
        pt = o.pendingProps,
        ht = _e.context,
        it = c.contextType,
        typeof it == "object" && it !== null ? it = eh(it) : (it = Zf(c) ? Xf : H.current,
        it = Yf(o, it));
        var _t = c.getDerivedStateFromProps;
        (ut = typeof _t == "function" || typeof _e.getSnapshotBeforeUpdate == "function") || typeof _e.UNSAFE_componentWillReceiveProps != "function" && typeof _e.componentWillReceiveProps != "function" || (nt !== pt || ht !== it) && Hi(o, _e, h, it),
        jh = !1,
        ht = o.memoizedState,
        _e.state = ht,
        qh(o, h, _e, _);
        var vt = o.memoizedState;
        nt !== pt || ht !== vt || Wf.current || jh ? (typeof _t == "function" && (Di(o, c, _t, h),
        vt = o.memoizedState),
        (at = jh || Fi(o, c, at, h, ht, vt, it) || !1) ? (ut || typeof _e.UNSAFE_componentWillUpdate != "function" && typeof _e.componentWillUpdate != "function" || (typeof _e.componentWillUpdate == "function" && _e.componentWillUpdate(h, vt, it),
        typeof _e.UNSAFE_componentWillUpdate == "function" && _e.UNSAFE_componentWillUpdate(h, vt, it)),
        typeof _e.componentDidUpdate == "function" && (o.flags |= 4),
        typeof _e.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof _e.componentDidUpdate != "function" || nt === d.memoizedProps && ht === d.memoizedState || (o.flags |= 4),
        typeof _e.getSnapshotBeforeUpdate != "function" || nt === d.memoizedProps && ht === d.memoizedState || (o.flags |= 1024),
        o.memoizedProps = h,
        o.memoizedState = vt),
        _e.props = h,
        _e.state = vt,
        _e.context = it,
        h = at) : (typeof _e.componentDidUpdate != "function" || nt === d.memoizedProps && ht === d.memoizedState || (o.flags |= 4),
        typeof _e.getSnapshotBeforeUpdate != "function" || nt === d.memoizedProps && ht === d.memoizedState || (o.flags |= 1024),
        h = !1)
    }
    return jj(d, o, c, h, b, _)
}
function jj(d, o, c, h, _, b) {
    gj(d, o);
    var _e = (o.flags & 128) !== 0;
    if (!h && !_e)
        return _ && dg(o, c, !1),
        Zi(d, o, b);
    h = o.stateNode,
    Wi.current = o;
    var nt = _e && typeof c.getDerivedStateFromError != "function" ? null : h.render();
    return o.flags |= 1,
    d !== null && _e ? (o.child = Ug(o, d.child, null, b),
    o.child = Ug(o, null, nt, b)) : Xi(d, o, nt, b),
    o.memoizedState = h.state,
    _ && dg(o, c, !0),
    o.child
}
function kj(d) {
    var o = d.stateNode;
    o.pendingContext ? ag(d, o.pendingContext, o.pendingContext !== o.context) : o.context && ag(d, o.context, !1),
    yh(d, o.containerInfo)
}
function lj(d, o, c, h, _) {
    return Ig(),
    Jg(_),
    o.flags |= 256,
    Xi(d, o, c, h),
    o.child
}
var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function nj(d) {
    return {
        baseLanes: d,
        cachePool: null,
        transitions: null
    }
}
function oj(d, o, c) {
    var h = o.pendingProps, _ = L.current, b = !1, _e = (o.flags & 128) !== 0, nt;
    if ((nt = _e) || (nt = d !== null && d.memoizedState === null ? !1 : (_ & 2) !== 0),
    nt ? (b = !0,
    o.flags &= -129) : (d === null || d.memoizedState !== null) && (_ |= 1),
    G(L, _ & 1),
    d === null)
        return Eg(o),
        d = o.memoizedState,
        d !== null && (d = d.dehydrated,
        d !== null) ? (o.mode & 1 ? d.data === "$!" ? o.lanes = 8 : o.lanes = 1073741824 : o.lanes = 1,
        null) : (_e = h.children,
        d = h.fallback,
        b ? (h = o.mode,
        b = o.child,
        _e = {
            mode: "hidden",
            children: _e
        },
        !(h & 1) && b !== null ? (b.childLanes = 0,
        b.pendingProps = _e) : b = pj(_e, h, 0, null),
        d = Tg(d, h, c, null),
        b.return = o,
        d.return = o,
        b.sibling = d,
        o.child = b,
        o.child.memoizedState = nj(c),
        o.memoizedState = mj,
        d) : qj(o, _e));
    if (_ = d.memoizedState,
    _ !== null && (nt = _.dehydrated,
    nt !== null))
        return rj(d, o, _e, h, nt, _, c);
    if (b) {
        b = h.fallback,
        _e = o.mode,
        _ = d.child,
        nt = _.sibling;
        var it = {
            mode: "hidden",
            children: h.children
        };
        return !(_e & 1) && o.child !== _ ? (h = o.child,
        h.childLanes = 0,
        h.pendingProps = it,
        o.deletions = null) : (h = Pg(_, it),
        h.subtreeFlags = _.subtreeFlags & 14680064),
        nt !== null ? b = Pg(nt, b) : (b = Tg(b, _e, c, null),
        b.flags |= 2),
        b.return = o,
        h.return = o,
        h.sibling = b,
        o.child = h,
        h = b,
        b = o.child,
        _e = d.child.memoizedState,
        _e = _e === null ? nj(c) : {
            baseLanes: _e.baseLanes | c,
            cachePool: null,
            transitions: _e.transitions
        },
        b.memoizedState = _e,
        b.childLanes = d.childLanes & ~c,
        o.memoizedState = mj,
        h
    }
    return b = d.child,
    d = b.sibling,
    h = Pg(b, {
        mode: "visible",
        children: h.children
    }),
    !(o.mode & 1) && (h.lanes = c),
    h.return = o,
    h.sibling = null,
    d !== null && (c = o.deletions,
    c === null ? (o.deletions = [d],
    o.flags |= 16) : c.push(d)),
    o.child = h,
    o.memoizedState = null,
    h
}
function qj(d, o) {
    return o = pj({
        mode: "visible",
        children: o
    }, d.mode, 0, null),
    o.return = d,
    d.child = o
}
function sj(d, o, c, h) {
    return h !== null && Jg(h),
    Ug(o, d.child, null, c),
    d = qj(o, o.pendingProps.children),
    d.flags |= 2,
    o.memoizedState = null,
    d
}
function rj(d, o, c, h, _, b, _e) {
    if (c)
        return o.flags & 256 ? (o.flags &= -257,
        h = Ki(Error(p(422))),
        sj(d, o, _e, h)) : o.memoizedState !== null ? (o.child = d.child,
        o.flags |= 128,
        null) : (b = h.fallback,
        _ = o.mode,
        h = pj({
            mode: "visible",
            children: h.children
        }, _, 0, null),
        b = Tg(b, _, _e, null),
        b.flags |= 2,
        h.return = o,
        b.return = o,
        h.sibling = b,
        o.child = h,
        o.mode & 1 && Ug(o, d.child, null, _e),
        o.child.memoizedState = nj(_e),
        o.memoizedState = mj,
        b);
    if (!(o.mode & 1))
        return sj(d, o, _e, null);
    if (_.data === "$!") {
        if (h = _.nextSibling && _.nextSibling.dataset,
        h)
            var nt = h.dgst;
        return h = nt,
        b = Error(p(419)),
        h = Ki(b, h, void 0),
        sj(d, o, _e, h)
    }
    if (nt = (_e & d.childLanes) !== 0,
    dh || nt) {
        if (h = Q,
        h !== null) {
            switch (_e & -_e) {
            case 4:
                _ = 2;
                break;
            case 16:
                _ = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                _ = 32;
                break;
            case 536870912:
                _ = 268435456;
                break;
            default:
                _ = 0
            }
            _ = _ & (h.suspendedLanes | _e) ? 0 : _,
            _ !== 0 && _ !== b.retryLane && (b.retryLane = _,
            ih(d, _),
            gi(h, d, _, -1))
        }
        return tj(),
        h = Ki(Error(p(421))),
        sj(d, o, _e, h)
    }
    return _.data === "$?" ? (o.flags |= 128,
    o.child = d.child,
    o = uj.bind(null, d),
    _._reactRetry = o,
    null) : (d = b.treeContext,
    yg = Lf(_.nextSibling),
    xg = o,
    I = !0,
    zg = null,
    d !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = d.id,
    sg = d.overflow,
    qg = o),
    o = qj(o, h.children),
    o.flags |= 4096,
    o)
}
function vj(d, o, c) {
    d.lanes |= o;
    var h = d.alternate;
    h !== null && (h.lanes |= o),
    bh(d.return, o, c)
}
function wj(d, o, c, h, _) {
    var b = d.memoizedState;
    b === null ? d.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: h,
        tail: c,
        tailMode: _
    } : (b.isBackwards = o,
    b.rendering = null,
    b.renderingStartTime = 0,
    b.last = h,
    b.tail = c,
    b.tailMode = _)
}
function xj(d, o, c) {
    var h = o.pendingProps
      , _ = h.revealOrder
      , b = h.tail;
    if (Xi(d, o, h.children, c),
    h = L.current,
    h & 2)
        h = h & 1 | 2,
        o.flags |= 128;
    else {
        if (d !== null && d.flags & 128)
            e: for (d = o.child; d !== null; ) {
                if (d.tag === 13)
                    d.memoizedState !== null && vj(d, c, o);
                else if (d.tag === 19)
                    vj(d, c, o);
                else if (d.child !== null) {
                    d.child.return = d,
                    d = d.child;
                    continue
                }
                if (d === o)
                    break e;
                for (; d.sibling === null; ) {
                    if (d.return === null || d.return === o)
                        break e;
                    d = d.return
                }
                d.sibling.return = d.return,
                d = d.sibling
            }
        h &= 1
    }
    if (G(L, h),
    !(o.mode & 1))
        o.memoizedState = null;
    else
        switch (_) {
        case "forwards":
            for (c = o.child,
            _ = null; c !== null; )
                d = c.alternate,
                d !== null && Ch(d) === null && (_ = c),
                c = c.sibling;
            c = _,
            c === null ? (_ = o.child,
            o.child = null) : (_ = c.sibling,
            c.sibling = null),
            wj(o, !1, _, c, b);
            break;
        case "backwards":
            for (c = null,
            _ = o.child,
            o.child = null; _ !== null; ) {
                if (d = _.alternate,
                d !== null && Ch(d) === null) {
                    o.child = _;
                    break
                }
                d = _.sibling,
                _.sibling = c,
                c = _,
                _ = d
            }
            wj(o, !0, c, null, b);
            break;
        case "together":
            wj(o, !1, null, null, void 0);
            break;
        default:
            o.memoizedState = null
        }
    return o.child
}
function ij(d, o) {
    !(o.mode & 1) && d !== null && (d.alternate = null,
    o.alternate = null,
    o.flags |= 2)
}
function Zi(d, o, c) {
    if (d !== null && (o.dependencies = d.dependencies),
    rh |= o.lanes,
    !(c & o.childLanes))
        return null;
    if (d !== null && o.child !== d.child)
        throw Error(p(153));
    if (o.child !== null) {
        for (d = o.child,
        c = Pg(d, d.pendingProps),
        o.child = c,
        c.return = o; d.sibling !== null; )
            d = d.sibling,
            c = c.sibling = Pg(d, d.pendingProps),
            c.return = o;
        c.sibling = null
    }
    return o.child
}
function yj(d, o, c) {
    switch (o.tag) {
    case 3:
        kj(o),
        Ig();
        break;
    case 5:
        Ah(o);
        break;
    case 1:
        Zf(o.type) && cg(o);
        break;
    case 4:
        yh(o, o.stateNode.containerInfo);
        break;
    case 10:
        var h = o.type._context
          , _ = o.memoizedProps.value;
        G(Wg, h._currentValue),
        h._currentValue = _;
        break;
    case 13:
        if (h = o.memoizedState,
        h !== null)
            return h.dehydrated !== null ? (G(L, L.current & 1),
            o.flags |= 128,
            null) : c & o.child.childLanes ? oj(d, o, c) : (G(L, L.current & 1),
            d = Zi(d, o, c),
            d !== null ? d.sibling : null);
        G(L, L.current & 1);
        break;
    case 19:
        if (h = (c & o.childLanes) !== 0,
        d.flags & 128) {
            if (h)
                return xj(d, o, c);
            o.flags |= 128
        }
        if (_ = o.memoizedState,
        _ !== null && (_.rendering = null,
        _.tail = null,
        _.lastEffect = null),
        G(L, L.current),
        h)
            break;
        return null;
    case 22:
    case 23:
        return o.lanes = 0,
        dj(d, o, c)
    }
    return Zi(d, o, c)
}
var zj, Aj, Bj, Cj;
zj = function(d, o) {
    for (var c = o.child; c !== null; ) {
        if (c.tag === 5 || c.tag === 6)
            d.appendChild(c.stateNode);
        else if (c.tag !== 4 && c.child !== null) {
            c.child.return = c,
            c = c.child;
            continue
        }
        if (c === o)
            break;
        for (; c.sibling === null; ) {
            if (c.return === null || c.return === o)
                return;
            c = c.return
        }
        c.sibling.return = c.return,
        c = c.sibling
    }
}
;
Aj = function() {}
;
Bj = function(d, o, c, h) {
    var _ = d.memoizedProps;
    if (_ !== h) {
        d = o.stateNode,
        xh(uh.current);
        var b = null;
        switch (c) {
        case "input":
            _ = Ya(d, _),
            h = Ya(d, h),
            b = [];
            break;
        case "select":
            _ = A({}, _, {
                value: void 0
            }),
            h = A({}, h, {
                value: void 0
            }),
            b = [];
            break;
        case "textarea":
            _ = gb(d, _),
            h = gb(d, h),
            b = [];
            break;
        default:
            typeof _.onClick != "function" && typeof h.onClick == "function" && (d.onclick = Bf)
        }
        ub(c, h);
        var _e;
        c = null;
        for (at in _)
            if (!h.hasOwnProperty(at) && _.hasOwnProperty(at) && _[at] != null)
                if (at === "style") {
                    var nt = _[at];
                    for (_e in nt)
                        nt.hasOwnProperty(_e) && (c || (c = {}),
                        c[_e] = "")
                } else
                    at !== "dangerouslySetInnerHTML" && at !== "children" && at !== "suppressContentEditableWarning" && at !== "suppressHydrationWarning" && at !== "autoFocus" && (ea.hasOwnProperty(at) ? b || (b = []) : (b = b || []).push(at, null));
        for (at in h) {
            var it = h[at];
            if (nt = _ != null ? _[at] : void 0,
            h.hasOwnProperty(at) && it !== nt && (it != null || nt != null))
                if (at === "style")
                    if (nt) {
                        for (_e in nt)
                            !nt.hasOwnProperty(_e) || it && it.hasOwnProperty(_e) || (c || (c = {}),
                            c[_e] = "");
                        for (_e in it)
                            it.hasOwnProperty(_e) && nt[_e] !== it[_e] && (c || (c = {}),
                            c[_e] = it[_e])
                    } else
                        c || (b || (b = []),
                        b.push(at, c)),
                        c = it;
                else
                    at === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0,
                    nt = nt ? nt.__html : void 0,
                    it != null && nt !== it && (b = b || []).push(at, it)) : at === "children" ? typeof it != "string" && typeof it != "number" || (b = b || []).push(at, "" + it) : at !== "suppressContentEditableWarning" && at !== "suppressHydrationWarning" && (ea.hasOwnProperty(at) ? (it != null && at === "onScroll" && D("scroll", d),
                    b || nt === it || (b = [])) : (b = b || []).push(at, it))
        }
        c && (b = b || []).push("style", c);
        var at = b;
        (o.updateQueue = at) && (o.flags |= 4)
    }
}
;
Cj = function(d, o, c, h) {
    c !== h && (o.flags |= 4)
}
;
function Dj(d, o) {
    if (!I)
        switch (d.tailMode) {
        case "hidden":
            o = d.tail;
            for (var c = null; o !== null; )
                o.alternate !== null && (c = o),
                o = o.sibling;
            c === null ? d.tail = null : c.sibling = null;
            break;
        case "collapsed":
            c = d.tail;
            for (var h = null; c !== null; )
                c.alternate !== null && (h = c),
                c = c.sibling;
            h === null ? o || d.tail === null ? d.tail = null : d.tail.sibling = null : h.sibling = null
        }
}
function S(d) {
    var o = d.alternate !== null && d.alternate.child === d.child
      , c = 0
      , h = 0;
    if (o)
        for (var _ = d.child; _ !== null; )
            c |= _.lanes | _.childLanes,
            h |= _.subtreeFlags & 14680064,
            h |= _.flags & 14680064,
            _.return = d,
            _ = _.sibling;
    else
        for (_ = d.child; _ !== null; )
            c |= _.lanes | _.childLanes,
            h |= _.subtreeFlags,
            h |= _.flags,
            _.return = d,
            _ = _.sibling;
    return d.subtreeFlags |= h,
    d.childLanes = c,
    o
}
function Ej(d, o, c) {
    var h = o.pendingProps;
    switch (wg(o),
    o.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S(o),
        null;
    case 1:
        return Zf(o.type) && $f(),
        S(o),
        null;
    case 3:
        return h = o.stateNode,
        zh(),
        E(Wf),
        E(H),
        Eh(),
        h.pendingContext && (h.context = h.pendingContext,
        h.pendingContext = null),
        (d === null || d.child === null) && (Gg(o) ? o.flags |= 4 : d === null || d.memoizedState.isDehydrated && !(o.flags & 256) || (o.flags |= 1024,
        zg !== null && (Fj(zg),
        zg = null))),
        Aj(d, o),
        S(o),
        null;
    case 5:
        Bh(o);
        var _ = xh(wh.current);
        if (c = o.type,
        d !== null && o.stateNode != null)
            Bj(d, o, c, h, _),
            d.ref !== o.ref && (o.flags |= 512,
            o.flags |= 2097152);
        else {
            if (!h) {
                if (o.stateNode === null)
                    throw Error(p(166));
                return S(o),
                null
            }
            if (d = xh(uh.current),
            Gg(o)) {
                h = o.stateNode,
                c = o.type;
                var b = o.memoizedProps;
                switch (h[Of] = o,
                h[Pf] = b,
                d = (o.mode & 1) !== 0,
                c) {
                case "dialog":
                    D("cancel", h),
                    D("close", h);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D("load", h);
                    break;
                case "video":
                case "audio":
                    for (_ = 0; _ < lf.length; _++)
                        D(lf[_], h);
                    break;
                case "source":
                    D("error", h);
                    break;
                case "img":
                case "image":
                case "link":
                    D("error", h),
                    D("load", h);
                    break;
                case "details":
                    D("toggle", h);
                    break;
                case "input":
                    Za(h, b),
                    D("invalid", h);
                    break;
                case "select":
                    h._wrapperState = {
                        wasMultiple: !!b.multiple
                    },
                    D("invalid", h);
                    break;
                case "textarea":
                    hb(h, b),
                    D("invalid", h)
                }
                ub(c, b),
                _ = null;
                for (var _e in b)
                    if (b.hasOwnProperty(_e)) {
                        var nt = b[_e];
                        _e === "children" ? typeof nt == "string" ? h.textContent !== nt && (b.suppressHydrationWarning !== !0 && Af(h.textContent, nt, d),
                        _ = ["children", nt]) : typeof nt == "number" && h.textContent !== "" + nt && (b.suppressHydrationWarning !== !0 && Af(h.textContent, nt, d),
                        _ = ["children", "" + nt]) : ea.hasOwnProperty(_e) && nt != null && _e === "onScroll" && D("scroll", h)
                    }
                switch (c) {
                case "input":
                    Va(h),
                    db(h, b, !0);
                    break;
                case "textarea":
                    Va(h),
                    jb(h);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof b.onClick == "function" && (h.onclick = Bf)
                }
                h = _,
                o.updateQueue = h,
                h !== null && (o.flags |= 4)
            } else {
                _e = _.nodeType === 9 ? _ : _.ownerDocument,
                d === "http://www.w3.org/1999/xhtml" && (d = kb(c)),
                d === "http://www.w3.org/1999/xhtml" ? c === "script" ? (d = _e.createElement("div"),
                d.innerHTML = "<script><\/script>",
                d = d.removeChild(d.firstChild)) : typeof h.is == "string" ? d = _e.createElement(c, {
                    is: h.is
                }) : (d = _e.createElement(c),
                c === "select" && (_e = d,
                h.multiple ? _e.multiple = !0 : h.size && (_e.size = h.size))) : d = _e.createElementNS(d, c),
                d[Of] = o,
                d[Pf] = h,
                zj(d, o, !1, !1),
                o.stateNode = d;
                e: {
                    switch (_e = vb(c, h),
                    c) {
                    case "dialog":
                        D("cancel", d),
                        D("close", d),
                        _ = h;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D("load", d),
                        _ = h;
                        break;
                    case "video":
                    case "audio":
                        for (_ = 0; _ < lf.length; _++)
                            D(lf[_], d);
                        _ = h;
                        break;
                    case "source":
                        D("error", d),
                        _ = h;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D("error", d),
                        D("load", d),
                        _ = h;
                        break;
                    case "details":
                        D("toggle", d),
                        _ = h;
                        break;
                    case "input":
                        Za(d, h),
                        _ = Ya(d, h),
                        D("invalid", d);
                        break;
                    case "option":
                        _ = h;
                        break;
                    case "select":
                        d._wrapperState = {
                            wasMultiple: !!h.multiple
                        },
                        _ = A({}, h, {
                            value: void 0
                        }),
                        D("invalid", d);
                        break;
                    case "textarea":
                        hb(d, h),
                        _ = gb(d, h),
                        D("invalid", d);
                        break;
                    default:
                        _ = h
                    }
                    ub(c, _),
                    nt = _;
                    for (b in nt)
                        if (nt.hasOwnProperty(b)) {
                            var it = nt[b];
                            b === "style" ? sb(d, it) : b === "dangerouslySetInnerHTML" ? (it = it ? it.__html : void 0,
                            it != null && nb(d, it)) : b === "children" ? typeof it == "string" ? (c !== "textarea" || it !== "") && ob(d, it) : typeof it == "number" && ob(d, "" + it) : b !== "suppressContentEditableWarning" && b !== "suppressHydrationWarning" && b !== "autoFocus" && (ea.hasOwnProperty(b) ? it != null && b === "onScroll" && D("scroll", d) : it != null && ta(d, b, it, _e))
                        }
                    switch (c) {
                    case "input":
                        Va(d),
                        db(d, h, !1);
                        break;
                    case "textarea":
                        Va(d),
                        jb(d);
                        break;
                    case "option":
                        h.value != null && d.setAttribute("value", "" + Sa(h.value));
                        break;
                    case "select":
                        d.multiple = !!h.multiple,
                        b = h.value,
                        b != null ? fb(d, !!h.multiple, b, !1) : h.defaultValue != null && fb(d, !!h.multiple, h.defaultValue, !0);
                        break;
                    default:
                        typeof _.onClick == "function" && (d.onclick = Bf)
                    }
                    switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        h = !!h.autoFocus;
                        break e;
                    case "img":
                        h = !0;
                        break e;
                    default:
                        h = !1
                    }
                }
                h && (o.flags |= 4)
            }
            o.ref !== null && (o.flags |= 512,
            o.flags |= 2097152)
        }
        return S(o),
        null;
    case 6:
        if (d && o.stateNode != null)
            Cj(d, o, d.memoizedProps, h);
        else {
            if (typeof h != "string" && o.stateNode === null)
                throw Error(p(166));
            if (c = xh(wh.current),
            xh(uh.current),
            Gg(o)) {
                if (h = o.stateNode,
                c = o.memoizedProps,
                h[Of] = o,
                (b = h.nodeValue !== c) && (d = xg,
                d !== null))
                    switch (d.tag) {
                    case 3:
                        Af(h.nodeValue, c, (d.mode & 1) !== 0);
                        break;
                    case 5:
                        d.memoizedProps.suppressHydrationWarning !== !0 && Af(h.nodeValue, c, (d.mode & 1) !== 0)
                    }
                b && (o.flags |= 4)
            } else
                h = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(h),
                h[Of] = o,
                o.stateNode = h
        }
        return S(o),
        null;
    case 13:
        if (E(L),
        h = o.memoizedState,
        d === null || d.memoizedState !== null && d.memoizedState.dehydrated !== null) {
            if (I && yg !== null && o.mode & 1 && !(o.flags & 128))
                Hg(),
                Ig(),
                o.flags |= 98560,
                b = !1;
            else if (b = Gg(o),
            h !== null && h.dehydrated !== null) {
                if (d === null) {
                    if (!b)
                        throw Error(p(318));
                    if (b = o.memoizedState,
                    b = b !== null ? b.dehydrated : null,
                    !b)
                        throw Error(p(317));
                    b[Of] = o
                } else
                    Ig(),
                    !(o.flags & 128) && (o.memoizedState = null),
                    o.flags |= 4;
                S(o),
                b = !1
            } else
                zg !== null && (Fj(zg),
                zg = null),
                b = !0;
            if (!b)
                return o.flags & 65536 ? o : null
        }
        return o.flags & 128 ? (o.lanes = c,
        o) : (h = h !== null,
        h !== (d !== null && d.memoizedState !== null) && h && (o.child.flags |= 8192,
        o.mode & 1 && (d === null || L.current & 1 ? T === 0 && (T = 3) : tj())),
        o.updateQueue !== null && (o.flags |= 4),
        S(o),
        null);
    case 4:
        return zh(),
        Aj(d, o),
        d === null && sf(o.stateNode.containerInfo),
        S(o),
        null;
    case 10:
        return ah(o.type._context),
        S(o),
        null;
    case 17:
        return Zf(o.type) && $f(),
        S(o),
        null;
    case 19:
        if (E(L),
        b = o.memoizedState,
        b === null)
            return S(o),
            null;
        if (h = (o.flags & 128) !== 0,
        _e = b.rendering,
        _e === null)
            if (h)
                Dj(b, !1);
            else {
                if (T !== 0 || d !== null && d.flags & 128)
                    for (d = o.child; d !== null; ) {
                        if (_e = Ch(d),
                        _e !== null) {
                            for (o.flags |= 128,
                            Dj(b, !1),
                            h = _e.updateQueue,
                            h !== null && (o.updateQueue = h,
                            o.flags |= 4),
                            o.subtreeFlags = 0,
                            h = c,
                            c = o.child; c !== null; )
                                b = c,
                                d = h,
                                b.flags &= 14680066,
                                _e = b.alternate,
                                _e === null ? (b.childLanes = 0,
                                b.lanes = d,
                                b.child = null,
                                b.subtreeFlags = 0,
                                b.memoizedProps = null,
                                b.memoizedState = null,
                                b.updateQueue = null,
                                b.dependencies = null,
                                b.stateNode = null) : (b.childLanes = _e.childLanes,
                                b.lanes = _e.lanes,
                                b.child = _e.child,
                                b.subtreeFlags = 0,
                                b.deletions = null,
                                b.memoizedProps = _e.memoizedProps,
                                b.memoizedState = _e.memoizedState,
                                b.updateQueue = _e.updateQueue,
                                b.type = _e.type,
                                d = _e.dependencies,
                                b.dependencies = d === null ? null : {
                                    lanes: d.lanes,
                                    firstContext: d.firstContext
                                }),
                                c = c.sibling;
                            return G(L, L.current & 1 | 2),
                            o.child
                        }
                        d = d.sibling
                    }
                b.tail !== null && B() > Gj && (o.flags |= 128,
                h = !0,
                Dj(b, !1),
                o.lanes = 4194304)
            }
        else {
            if (!h)
                if (d = Ch(_e),
                d !== null) {
                    if (o.flags |= 128,
                    h = !0,
                    c = d.updateQueue,
                    c !== null && (o.updateQueue = c,
                    o.flags |= 4),
                    Dj(b, !0),
                    b.tail === null && b.tailMode === "hidden" && !_e.alternate && !I)
                        return S(o),
                        null
                } else
                    2 * B() - b.renderingStartTime > Gj && c !== 1073741824 && (o.flags |= 128,
                    h = !0,
                    Dj(b, !1),
                    o.lanes = 4194304);
            b.isBackwards ? (_e.sibling = o.child,
            o.child = _e) : (c = b.last,
            c !== null ? c.sibling = _e : o.child = _e,
            b.last = _e)
        }
        return b.tail !== null ? (o = b.tail,
        b.rendering = o,
        b.tail = o.sibling,
        b.renderingStartTime = B(),
        o.sibling = null,
        c = L.current,
        G(L, h ? c & 1 | 2 : c & 1),
        o) : (S(o),
        null);
    case 22:
    case 23:
        return Hj(),
        h = o.memoizedState !== null,
        d !== null && d.memoizedState !== null !== h && (o.flags |= 8192),
        h && o.mode & 1 ? fj & 1073741824 && (S(o),
        o.subtreeFlags & 6 && (o.flags |= 8192)) : S(o),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p(156, o.tag))
}
function Ij(d, o) {
    switch (wg(o),
    o.tag) {
    case 1:
        return Zf(o.type) && $f(),
        d = o.flags,
        d & 65536 ? (o.flags = d & -65537 | 128,
        o) : null;
    case 3:
        return zh(),
        E(Wf),
        E(H),
        Eh(),
        d = o.flags,
        d & 65536 && !(d & 128) ? (o.flags = d & -65537 | 128,
        o) : null;
    case 5:
        return Bh(o),
        null;
    case 13:
        if (E(L),
        d = o.memoizedState,
        d !== null && d.dehydrated !== null) {
            if (o.alternate === null)
                throw Error(p(340));
            Ig()
        }
        return d = o.flags,
        d & 65536 ? (o.flags = d & -65537 | 128,
        o) : null;
    case 19:
        return E(L),
        null;
    case 4:
        return zh(),
        null;
    case 10:
        return ah(o.type._context),
        null;
    case 22:
    case 23:
        return Hj(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Jj = !1
  , U = !1
  , Kj = typeof WeakSet == "function" ? WeakSet : Set
  , V = null;
function Lj(d, o) {
    var c = d.ref;
    if (c !== null)
        if (typeof c == "function")
            try {
                c(null)
            } catch (h) {
                W(d, o, h)
            }
        else
            c.current = null
}
function Mj(d, o, c) {
    try {
        c()
    } catch (h) {
        W(d, o, h)
    }
}
var Nj = !1;
function Oj(d, o) {
    if (Cf = dd,
    d = Me(),
    Ne(d)) {
        if ("selectionStart"in d)
            var c = {
                start: d.selectionStart,
                end: d.selectionEnd
            };
        else
            e: {
                c = (c = d.ownerDocument) && c.defaultView || window;
                var h = c.getSelection && c.getSelection();
                if (h && h.rangeCount !== 0) {
                    c = h.anchorNode;
                    var _ = h.anchorOffset
                      , b = h.focusNode;
                    h = h.focusOffset;
                    try {
                        c.nodeType,
                        b.nodeType
                    } catch {
                        c = null;
                        break e
                    }
                    var _e = 0
                      , nt = -1
                      , it = -1
                      , at = 0
                      , ut = 0
                      , pt = d
                      , ht = null;
                    t: for (; ; ) {
                        for (var _t; pt !== c || _ !== 0 && pt.nodeType !== 3 || (nt = _e + _),
                        pt !== b || h !== 0 && pt.nodeType !== 3 || (it = _e + h),
                        pt.nodeType === 3 && (_e += pt.nodeValue.length),
                        (_t = pt.firstChild) !== null; )
                            ht = pt,
                            pt = _t;
                        for (; ; ) {
                            if (pt === d)
                                break t;
                            if (ht === c && ++at === _ && (nt = _e),
                            ht === b && ++ut === h && (it = _e),
                            (_t = pt.nextSibling) !== null)
                                break;
                            pt = ht,
                            ht = pt.parentNode
                        }
                        pt = _t
                    }
                    c = nt === -1 || it === -1 ? null : {
                        start: nt,
                        end: it
                    }
                } else
                    c = null
            }
        c = c || {
            start: 0,
            end: 0
        }
    } else
        c = null;
    for (Df = {
        focusedElem: d,
        selectionRange: c
    },
    dd = !1,
    V = o; V !== null; )
        if (o = V,
        d = o.child,
        (o.subtreeFlags & 1028) !== 0 && d !== null)
            d.return = o,
            V = d;
        else
            for (; V !== null; ) {
                o = V;
                try {
                    var vt = o.alternate;
                    if (o.flags & 1024)
                        switch (o.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (vt !== null) {
                                var bt = vt.memoizedProps
                                  , St = vt.memoizedState
                                  , At = o.stateNode
                                  , Et = At.getSnapshotBeforeUpdate(o.elementType === o.type ? bt : Ci(o.type, bt), St);
                                At.__reactInternalSnapshotBeforeUpdate = Et
                            }
                            break;
                        case 3:
                            var Pt = o.stateNode.containerInfo;
                            Pt.nodeType === 1 ? Pt.textContent = "" : Pt.nodeType === 9 && Pt.documentElement && Pt.removeChild(Pt.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p(163))
                        }
                } catch (It) {
                    W(o, o.return, It)
                }
                if (d = o.sibling,
                d !== null) {
                    d.return = o.return,
                    V = d;
                    break
                }
                V = o.return
            }
    return vt = Nj,
    Nj = !1,
    vt
}
function Pj(d, o, c) {
    var h = o.updateQueue;
    if (h = h !== null ? h.lastEffect : null,
    h !== null) {
        var _ = h = h.next;
        do {
            if ((_.tag & d) === d) {
                var b = _.destroy;
                _.destroy = void 0,
                b !== void 0 && Mj(o, c, b)
            }
            _ = _.next
        } while (_ !== h)
    }
}
function Qj(d, o) {
    if (o = o.updateQueue,
    o = o !== null ? o.lastEffect : null,
    o !== null) {
        var c = o = o.next;
        do {
            if ((c.tag & d) === d) {
                var h = c.create;
                c.destroy = h()
            }
            c = c.next
        } while (c !== o)
    }
}
function Rj(d) {
    var o = d.ref;
    if (o !== null) {
        var c = d.stateNode;
        switch (d.tag) {
        case 5:
            d = c;
            break;
        default:
            d = c
        }
        typeof o == "function" ? o(d) : o.current = d
    }
}
function Sj(d) {
    var o = d.alternate;
    o !== null && (d.alternate = null,
    Sj(o)),
    d.child = null,
    d.deletions = null,
    d.sibling = null,
    d.tag === 5 && (o = d.stateNode,
    o !== null && (delete o[Of],
    delete o[Pf],
    delete o[of],
    delete o[Qf],
    delete o[Rf])),
    d.stateNode = null,
    d.return = null,
    d.dependencies = null,
    d.memoizedProps = null,
    d.memoizedState = null,
    d.pendingProps = null,
    d.stateNode = null,
    d.updateQueue = null
}
function Tj(d) {
    return d.tag === 5 || d.tag === 3 || d.tag === 4
}
function Uj(d) {
    e: for (; ; ) {
        for (; d.sibling === null; ) {
            if (d.return === null || Tj(d.return))
                return null;
            d = d.return
        }
        for (d.sibling.return = d.return,
        d = d.sibling; d.tag !== 5 && d.tag !== 6 && d.tag !== 18; ) {
            if (d.flags & 2 || d.child === null || d.tag === 4)
                continue e;
            d.child.return = d,
            d = d.child
        }
        if (!(d.flags & 2))
            return d.stateNode
    }
}
function Vj(d, o, c) {
    var h = d.tag;
    if (h === 5 || h === 6)
        d = d.stateNode,
        o ? c.nodeType === 8 ? c.parentNode.insertBefore(d, o) : c.insertBefore(d, o) : (c.nodeType === 8 ? (o = c.parentNode,
        o.insertBefore(d, c)) : (o = c,
        o.appendChild(d)),
        c = c._reactRootContainer,
        c != null || o.onclick !== null || (o.onclick = Bf));
    else if (h !== 4 && (d = d.child,
    d !== null))
        for (Vj(d, o, c),
        d = d.sibling; d !== null; )
            Vj(d, o, c),
            d = d.sibling
}
function Wj(d, o, c) {
    var h = d.tag;
    if (h === 5 || h === 6)
        d = d.stateNode,
        o ? c.insertBefore(d, o) : c.appendChild(d);
    else if (h !== 4 && (d = d.child,
    d !== null))
        for (Wj(d, o, c),
        d = d.sibling; d !== null; )
            Wj(d, o, c),
            d = d.sibling
}
var X = null
  , Xj = !1;
function Yj(d, o, c) {
    for (c = c.child; c !== null; )
        Zj(d, o, c),
        c = c.sibling
}
function Zj(d, o, c) {
    if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
            lc.onCommitFiberUnmount(kc, c)
        } catch {}
    switch (c.tag) {
    case 5:
        U || Lj(c, o);
    case 6:
        var h = X
          , _ = Xj;
        X = null,
        Yj(d, o, c),
        X = h,
        Xj = _,
        X !== null && (Xj ? (d = X,
        c = c.stateNode,
        d.nodeType === 8 ? d.parentNode.removeChild(c) : d.removeChild(c)) : X.removeChild(c.stateNode));
        break;
    case 18:
        X !== null && (Xj ? (d = X,
        c = c.stateNode,
        d.nodeType === 8 ? Kf(d.parentNode, c) : d.nodeType === 1 && Kf(d, c),
        bd(d)) : Kf(X, c.stateNode));
        break;
    case 4:
        h = X,
        _ = Xj,
        X = c.stateNode.containerInfo,
        Xj = !0,
        Yj(d, o, c),
        X = h,
        Xj = _;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U && (h = c.updateQueue,
        h !== null && (h = h.lastEffect,
        h !== null))) {
            _ = h = h.next;
            do {
                var b = _
                  , _e = b.destroy;
                b = b.tag,
                _e !== void 0 && (b & 2 || b & 4) && Mj(c, o, _e),
                _ = _.next
            } while (_ !== h)
        }
        Yj(d, o, c);
        break;
    case 1:
        if (!U && (Lj(c, o),
        h = c.stateNode,
        typeof h.componentWillUnmount == "function"))
            try {
                h.props = c.memoizedProps,
                h.state = c.memoizedState,
                h.componentWillUnmount()
            } catch (nt) {
                W(c, o, nt)
            }
        Yj(d, o, c);
        break;
    case 21:
        Yj(d, o, c);
        break;
    case 22:
        c.mode & 1 ? (U = (h = U) || c.memoizedState !== null,
        Yj(d, o, c),
        U = h) : Yj(d, o, c);
        break;
    default:
        Yj(d, o, c)
    }
}
function ak(d) {
    var o = d.updateQueue;
    if (o !== null) {
        d.updateQueue = null;
        var c = d.stateNode;
        c === null && (c = d.stateNode = new Kj),
        o.forEach(function(h) {
            var _ = bk.bind(null, d, h);
            c.has(h) || (c.add(h),
            h.then(_, _))
        })
    }
}
function ck(d, o) {
    var c = o.deletions;
    if (c !== null)
        for (var h = 0; h < c.length; h++) {
            var _ = c[h];
            try {
                var b = d
                  , _e = o
                  , nt = _e;
                e: for (; nt !== null; ) {
                    switch (nt.tag) {
                    case 5:
                        X = nt.stateNode,
                        Xj = !1;
                        break e;
                    case 3:
                        X = nt.stateNode.containerInfo,
                        Xj = !0;
                        break e;
                    case 4:
                        X = nt.stateNode.containerInfo,
                        Xj = !0;
                        break e
                    }
                    nt = nt.return
                }
                if (X === null)
                    throw Error(p(160));
                Zj(b, _e, _),
                X = null,
                Xj = !1;
                var it = _.alternate;
                it !== null && (it.return = null),
                _.return = null
            } catch (at) {
                W(_, o, at)
            }
        }
    if (o.subtreeFlags & 12854)
        for (o = o.child; o !== null; )
            dk(o, d),
            o = o.sibling
}
function dk(d, o) {
    var c = d.alternate
      , h = d.flags;
    switch (d.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ck(o, d),
        ek(d),
        h & 4) {
            try {
                Pj(3, d, d.return),
                Qj(3, d)
            } catch (bt) {
                W(d, d.return, bt)
            }
            try {
                Pj(5, d, d.return)
            } catch (bt) {
                W(d, d.return, bt)
            }
        }
        break;
    case 1:
        ck(o, d),
        ek(d),
        h & 512 && c !== null && Lj(c, c.return);
        break;
    case 5:
        if (ck(o, d),
        ek(d),
        h & 512 && c !== null && Lj(c, c.return),
        d.flags & 32) {
            var _ = d.stateNode;
            try {
                ob(_, "")
            } catch (bt) {
                W(d, d.return, bt)
            }
        }
        if (h & 4 && (_ = d.stateNode,
        _ != null)) {
            var b = d.memoizedProps
              , _e = c !== null ? c.memoizedProps : b
              , nt = d.type
              , it = d.updateQueue;
            if (d.updateQueue = null,
            it !== null)
                try {
                    nt === "input" && b.type === "radio" && b.name != null && ab(_, b),
                    vb(nt, _e);
                    var at = vb(nt, b);
                    for (_e = 0; _e < it.length; _e += 2) {
                        var ut = it[_e]
                          , pt = it[_e + 1];
                        ut === "style" ? sb(_, pt) : ut === "dangerouslySetInnerHTML" ? nb(_, pt) : ut === "children" ? ob(_, pt) : ta(_, ut, pt, at)
                    }
                    switch (nt) {
                    case "input":
                        bb(_, b);
                        break;
                    case "textarea":
                        ib(_, b);
                        break;
                    case "select":
                        var ht = _._wrapperState.wasMultiple;
                        _._wrapperState.wasMultiple = !!b.multiple;
                        var _t = b.value;
                        _t != null ? fb(_, !!b.multiple, _t, !1) : ht !== !!b.multiple && (b.defaultValue != null ? fb(_, !!b.multiple, b.defaultValue, !0) : fb(_, !!b.multiple, b.multiple ? [] : "", !1))
                    }
                    _[Pf] = b
                } catch (bt) {
                    W(d, d.return, bt)
                }
        }
        break;
    case 6:
        if (ck(o, d),
        ek(d),
        h & 4) {
            if (d.stateNode === null)
                throw Error(p(162));
            _ = d.stateNode,
            b = d.memoizedProps;
            try {
                _.nodeValue = b
            } catch (bt) {
                W(d, d.return, bt)
            }
        }
        break;
    case 3:
        if (ck(o, d),
        ek(d),
        h & 4 && c !== null && c.memoizedState.isDehydrated)
            try {
                bd(o.containerInfo)
            } catch (bt) {
                W(d, d.return, bt)
            }
        break;
    case 4:
        ck(o, d),
        ek(d);
        break;
    case 13:
        ck(o, d),
        ek(d),
        _ = d.child,
        _.flags & 8192 && (b = _.memoizedState !== null,
        _.stateNode.isHidden = b,
        !b || _.alternate !== null && _.alternate.memoizedState !== null || (fk = B())),
        h & 4 && ak(d);
        break;
    case 22:
        if (ut = c !== null && c.memoizedState !== null,
        d.mode & 1 ? (U = (at = U) || ut,
        ck(o, d),
        U = at) : ck(o, d),
        ek(d),
        h & 8192) {
            if (at = d.memoizedState !== null,
            (d.stateNode.isHidden = at) && !ut && d.mode & 1)
                for (V = d,
                ut = d.child; ut !== null; ) {
                    for (pt = V = ut; V !== null; ) {
                        switch (ht = V,
                        _t = ht.child,
                        ht.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Pj(4, ht, ht.return);
                            break;
                        case 1:
                            Lj(ht, ht.return);
                            var vt = ht.stateNode;
                            if (typeof vt.componentWillUnmount == "function") {
                                h = ht,
                                c = ht.return;
                                try {
                                    o = h,
                                    vt.props = o.memoizedProps,
                                    vt.state = o.memoizedState,
                                    vt.componentWillUnmount()
                                } catch (bt) {
                                    W(h, c, bt)
                                }
                            }
                            break;
                        case 5:
                            Lj(ht, ht.return);
                            break;
                        case 22:
                            if (ht.memoizedState !== null) {
                                gk(pt);
                                continue
                            }
                        }
                        _t !== null ? (_t.return = ht,
                        V = _t) : gk(pt)
                    }
                    ut = ut.sibling
                }
            e: for (ut = null,
            pt = d; ; ) {
                if (pt.tag === 5) {
                    if (ut === null) {
                        ut = pt;
                        try {
                            _ = pt.stateNode,
                            at ? (b = _.style,
                            typeof b.setProperty == "function" ? b.setProperty("display", "none", "important") : b.display = "none") : (nt = pt.stateNode,
                            it = pt.memoizedProps.style,
                            _e = it != null && it.hasOwnProperty("display") ? it.display : null,
                            nt.style.display = rb("display", _e))
                        } catch (bt) {
                            W(d, d.return, bt)
                        }
                    }
                } else if (pt.tag === 6) {
                    if (ut === null)
                        try {
                            pt.stateNode.nodeValue = at ? "" : pt.memoizedProps
                        } catch (bt) {
                            W(d, d.return, bt)
                        }
                } else if ((pt.tag !== 22 && pt.tag !== 23 || pt.memoizedState === null || pt === d) && pt.child !== null) {
                    pt.child.return = pt,
                    pt = pt.child;
                    continue
                }
                if (pt === d)
                    break e;
                for (; pt.sibling === null; ) {
                    if (pt.return === null || pt.return === d)
                        break e;
                    ut === pt && (ut = null),
                    pt = pt.return
                }
                ut === pt && (ut = null),
                pt.sibling.return = pt.return,
                pt = pt.sibling
            }
        }
        break;
    case 19:
        ck(o, d),
        ek(d),
        h & 4 && ak(d);
        break;
    case 21:
        break;
    default:
        ck(o, d),
        ek(d)
    }
}
function ek(d) {
    var o = d.flags;
    if (o & 2) {
        try {
            e: {
                for (var c = d.return; c !== null; ) {
                    if (Tj(c)) {
                        var h = c;
                        break e
                    }
                    c = c.return
                }
                throw Error(p(160))
            }
            switch (h.tag) {
            case 5:
                var _ = h.stateNode;
                h.flags & 32 && (ob(_, ""),
                h.flags &= -33);
                var b = Uj(d);
                Wj(d, b, _);
                break;
            case 3:
            case 4:
                var _e = h.stateNode.containerInfo
                  , nt = Uj(d);
                Vj(d, nt, _e);
                break;
            default:
                throw Error(p(161))
            }
        } catch (it) {
            W(d, d.return, it)
        }
        d.flags &= -3
    }
    o & 4096 && (d.flags &= -4097)
}
function hk(d, o, c) {
    V = d,
    ik(d)
}
function ik(d, o, c) {
    for (var h = (d.mode & 1) !== 0; V !== null; ) {
        var _ = V
          , b = _.child;
        if (_.tag === 22 && h) {
            var _e = _.memoizedState !== null || Jj;
            if (!_e) {
                var nt = _.alternate
                  , it = nt !== null && nt.memoizedState !== null || U;
                nt = Jj;
                var at = U;
                if (Jj = _e,
                (U = it) && !at)
                    for (V = _; V !== null; )
                        _e = V,
                        it = _e.child,
                        _e.tag === 22 && _e.memoizedState !== null ? jk(_) : it !== null ? (it.return = _e,
                        V = it) : jk(_);
                for (; b !== null; )
                    V = b,
                    ik(b),
                    b = b.sibling;
                V = _,
                Jj = nt,
                U = at
            }
            kk(d)
        } else
            _.subtreeFlags & 8772 && b !== null ? (b.return = _,
            V = b) : kk(d)
    }
}
function kk(d) {
    for (; V !== null; ) {
        var o = V;
        if (o.flags & 8772) {
            var c = o.alternate;
            try {
                if (o.flags & 8772)
                    switch (o.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U || Qj(5, o);
                        break;
                    case 1:
                        var h = o.stateNode;
                        if (o.flags & 4 && !U)
                            if (c === null)
                                h.componentDidMount();
                            else {
                                var _ = o.elementType === o.type ? c.memoizedProps : Ci(o.type, c.memoizedProps);
                                h.componentDidUpdate(_, c.memoizedState, h.__reactInternalSnapshotBeforeUpdate)
                            }
                        var b = o.updateQueue;
                        b !== null && sh(o, b, h);
                        break;
                    case 3:
                        var _e = o.updateQueue;
                        if (_e !== null) {
                            if (c = null,
                            o.child !== null)
                                switch (o.child.tag) {
                                case 5:
                                    c = o.child.stateNode;
                                    break;
                                case 1:
                                    c = o.child.stateNode
                                }
                            sh(o, _e, c)
                        }
                        break;
                    case 5:
                        var nt = o.stateNode;
                        if (c === null && o.flags & 4) {
                            c = nt;
                            var it = o.memoizedProps;
                            switch (o.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                it.autoFocus && c.focus();
                                break;
                            case "img":
                                it.src && (c.src = it.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (o.memoizedState === null) {
                            var at = o.alternate;
                            if (at !== null) {
                                var ut = at.memoizedState;
                                if (ut !== null) {
                                    var pt = ut.dehydrated;
                                    pt !== null && bd(pt)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p(163))
                    }
                U || o.flags & 512 && Rj(o)
            } catch (ht) {
                W(o, o.return, ht)
            }
        }
        if (o === d) {
            V = null;
            break
        }
        if (c = o.sibling,
        c !== null) {
            c.return = o.return,
            V = c;
            break
        }
        V = o.return
    }
}
function gk(d) {
    for (; V !== null; ) {
        var o = V;
        if (o === d) {
            V = null;
            break
        }
        var c = o.sibling;
        if (c !== null) {
            c.return = o.return,
            V = c;
            break
        }
        V = o.return
    }
}
function jk(d) {
    for (; V !== null; ) {
        var o = V;
        try {
            switch (o.tag) {
            case 0:
            case 11:
            case 15:
                var c = o.return;
                try {
                    Qj(4, o)
                } catch (it) {
                    W(o, c, it)
                }
                break;
            case 1:
                var h = o.stateNode;
                if (typeof h.componentDidMount == "function") {
                    var _ = o.return;
                    try {
                        h.componentDidMount()
                    } catch (it) {
                        W(o, _, it)
                    }
                }
                var b = o.return;
                try {
                    Rj(o)
                } catch (it) {
                    W(o, b, it)
                }
                break;
            case 5:
                var _e = o.return;
                try {
                    Rj(o)
                } catch (it) {
                    W(o, _e, it)
                }
            }
        } catch (it) {
            W(o, o.return, it)
        }
        if (o === d) {
            V = null;
            break
        }
        var nt = o.sibling;
        if (nt !== null) {
            nt.return = o.return,
            V = nt;
            break
        }
        V = o.return
    }
}
var lk = Math.ceil
  , mk = ua.ReactCurrentDispatcher
  , nk = ua.ReactCurrentOwner
  , ok = ua.ReactCurrentBatchConfig
  , K = 0
  , Q = null
  , Y = null
  , Z = 0
  , fj = 0
  , ej = Uf(0)
  , T = 0
  , pk = null
  , rh = 0
  , qk = 0
  , rk = 0
  , sk = null
  , tk = null
  , fk = 0
  , Gj = 1 / 0
  , uk = null
  , Oi = !1
  , Pi = null
  , Ri = null
  , vk = !1
  , wk = null
  , xk = 0
  , yk = 0
  , zk = null
  , Ak = -1
  , Bk = 0;
function R() {
    return K & 6 ? B() : Ak !== -1 ? Ak : Ak = B()
}
function yi(d) {
    return d.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Bk === 0 && (Bk = yc()),
    Bk) : (d = C,
    d !== 0 || (d = window.event,
    d = d === void 0 ? 16 : jd(d.type)),
    d) : 1
}
function gi(d, o, c, h) {
    if (50 < yk)
        throw yk = 0,
        zk = null,
        Error(p(185));
    Ac(d, c, h),
    (!(K & 2) || d !== Q) && (d === Q && (!(K & 2) && (qk |= c),
    T === 4 && Ck(d, Z)),
    Dk(d, h),
    c === 1 && K === 0 && !(o.mode & 1) && (Gj = B() + 500,
    fg && jg()))
}
function Dk(d, o) {
    var c = d.callbackNode;
    wc(d, o);
    var h = uc(d, d === Q ? Z : 0);
    if (h === 0)
        c !== null && bc(c),
        d.callbackNode = null,
        d.callbackPriority = 0;
    else if (o = h & -h,
    d.callbackPriority !== o) {
        if (c != null && bc(c),
        o === 1)
            d.tag === 0 ? ig(Ek.bind(null, d)) : hg(Ek.bind(null, d)),
            Jf(function() {
                !(K & 6) && jg()
            }),
            c = null;
        else {
            switch (Dc(h)) {
            case 1:
                c = fc;
                break;
            case 4:
                c = gc;
                break;
            case 16:
                c = hc;
                break;
            case 536870912:
                c = jc;
                break;
            default:
                c = hc
            }
            c = Fk(c, Gk.bind(null, d))
        }
        d.callbackPriority = o,
        d.callbackNode = c
    }
}
function Gk(d, o) {
    if (Ak = -1,
    Bk = 0,
    K & 6)
        throw Error(p(327));
    var c = d.callbackNode;
    if (Hk() && d.callbackNode !== c)
        return null;
    var h = uc(d, d === Q ? Z : 0);
    if (h === 0)
        return null;
    if (h & 30 || h & d.expiredLanes || o)
        o = Ik(d, h);
    else {
        o = h;
        var _ = K;
        K |= 2;
        var b = Jk();
        (Q !== d || Z !== o) && (uk = null,
        Gj = B() + 500,
        Kk(d, o));
        do
            try {
                Lk();
                break
            } catch (nt) {
                Mk(d, nt)
            }
        while (!0);
        $g(),
        mk.current = b,
        K = _,
        Y !== null ? o = 0 : (Q = null,
        Z = 0,
        o = T)
    }
    if (o !== 0) {
        if (o === 2 && (_ = xc(d),
        _ !== 0 && (h = _,
        o = Nk(d, _))),
        o === 1)
            throw c = pk,
            Kk(d, 0),
            Ck(d, h),
            Dk(d, B()),
            c;
        if (o === 6)
            Ck(d, h);
        else {
            if (_ = d.current.alternate,
            !(h & 30) && !Ok(_) && (o = Ik(d, h),
            o === 2 && (b = xc(d),
            b !== 0 && (h = b,
            o = Nk(d, b))),
            o === 1))
                throw c = pk,
                Kk(d, 0),
                Ck(d, h),
                Dk(d, B()),
                c;
            switch (d.finishedWork = _,
            d.finishedLanes = h,
            o) {
            case 0:
            case 1:
                throw Error(p(345));
            case 2:
                Pk(d, tk, uk);
                break;
            case 3:
                if (Ck(d, h),
                (h & 130023424) === h && (o = fk + 500 - B(),
                10 < o)) {
                    if (uc(d, 0) !== 0)
                        break;
                    if (_ = d.suspendedLanes,
                    (_ & h) !== h) {
                        R(),
                        d.pingedLanes |= d.suspendedLanes & _;
                        break
                    }
                    d.timeoutHandle = Ff(Pk.bind(null, d, tk, uk), o);
                    break
                }
                Pk(d, tk, uk);
                break;
            case 4:
                if (Ck(d, h),
                (h & 4194240) === h)
                    break;
                for (o = d.eventTimes,
                _ = -1; 0 < h; ) {
                    var _e = 31 - oc(h);
                    b = 1 << _e,
                    _e = o[_e],
                    _e > _ && (_ = _e),
                    h &= ~b
                }
                if (h = _,
                h = B() - h,
                h = (120 > h ? 120 : 480 > h ? 480 : 1080 > h ? 1080 : 1920 > h ? 1920 : 3e3 > h ? 3e3 : 4320 > h ? 4320 : 1960 * lk(h / 1960)) - h,
                10 < h) {
                    d.timeoutHandle = Ff(Pk.bind(null, d, tk, uk), h);
                    break
                }
                Pk(d, tk, uk);
                break;
            case 5:
                Pk(d, tk, uk);
                break;
            default:
                throw Error(p(329))
            }
        }
    }
    return Dk(d, B()),
    d.callbackNode === c ? Gk.bind(null, d) : null
}
function Nk(d, o) {
    var c = sk;
    return d.current.memoizedState.isDehydrated && (Kk(d, o).flags |= 256),
    d = Ik(d, o),
    d !== 2 && (o = tk,
    tk = c,
    o !== null && Fj(o)),
    d
}
function Fj(d) {
    tk === null ? tk = d : tk.push.apply(tk, d)
}
function Ok(d) {
    for (var o = d; ; ) {
        if (o.flags & 16384) {
            var c = o.updateQueue;
            if (c !== null && (c = c.stores,
            c !== null))
                for (var h = 0; h < c.length; h++) {
                    var _ = c[h]
                      , b = _.getSnapshot;
                    _ = _.value;
                    try {
                        if (!He(b(), _))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (c = o.child,
        o.subtreeFlags & 16384 && c !== null)
            c.return = o,
            o = c;
        else {
            if (o === d)
                break;
            for (; o.sibling === null; ) {
                if (o.return === null || o.return === d)
                    return !0;
                o = o.return
            }
            o.sibling.return = o.return,
            o = o.sibling
        }
    }
    return !0
}
function Ck(d, o) {
    for (o &= ~rk,
    o &= ~qk,
    d.suspendedLanes |= o,
    d.pingedLanes &= ~o,
    d = d.expirationTimes; 0 < o; ) {
        var c = 31 - oc(o)
          , h = 1 << c;
        d[c] = -1,
        o &= ~h
    }
}
function Ek(d) {
    if (K & 6)
        throw Error(p(327));
    Hk();
    var o = uc(d, 0);
    if (!(o & 1))
        return Dk(d, B()),
        null;
    var c = Ik(d, o);
    if (d.tag !== 0 && c === 2) {
        var h = xc(d);
        h !== 0 && (o = h,
        c = Nk(d, h))
    }
    if (c === 1)
        throw c = pk,
        Kk(d, 0),
        Ck(d, o),
        Dk(d, B()),
        c;
    if (c === 6)
        throw Error(p(345));
    return d.finishedWork = d.current.alternate,
    d.finishedLanes = o,
    Pk(d, tk, uk),
    Dk(d, B()),
    null
}
function Qk(d, o) {
    var c = K;
    K |= 1;
    try {
        return d(o)
    } finally {
        K = c,
        K === 0 && (Gj = B() + 500,
        fg && jg())
    }
}
function Rk(d) {
    wk !== null && wk.tag === 0 && !(K & 6) && Hk();
    var o = K;
    K |= 1;
    var c = ok.transition
      , h = C;
    try {
        if (ok.transition = null,
        C = 1,
        d)
            return d()
    } finally {
        C = h,
        ok.transition = c,
        K = o,
        !(K & 6) && jg()
    }
}
function Hj() {
    fj = ej.current,
    E(ej)
}
function Kk(d, o) {
    d.finishedWork = null,
    d.finishedLanes = 0;
    var c = d.timeoutHandle;
    if (c !== -1 && (d.timeoutHandle = -1,
    Gf(c)),
    Y !== null)
        for (c = Y.return; c !== null; ) {
            var h = c;
            switch (wg(h),
            h.tag) {
            case 1:
                h = h.type.childContextTypes,
                h != null && $f();
                break;
            case 3:
                zh(),
                E(Wf),
                E(H),
                Eh();
                break;
            case 5:
                Bh(h);
                break;
            case 4:
                zh();
                break;
            case 13:
                E(L);
                break;
            case 19:
                E(L);
                break;
            case 10:
                ah(h.type._context);
                break;
            case 22:
            case 23:
                Hj()
            }
            c = c.return
        }
    if (Q = d,
    Y = d = Pg(d.current, null),
    Z = fj = o,
    T = 0,
    pk = null,
    rk = qk = rh = 0,
    tk = sk = null,
    fh !== null) {
        for (o = 0; o < fh.length; o++)
            if (c = fh[o],
            h = c.interleaved,
            h !== null) {
                c.interleaved = null;
                var _ = h.next
                  , b = c.pending;
                if (b !== null) {
                    var _e = b.next;
                    b.next = _,
                    h.next = _e
                }
                c.pending = h
            }
        fh = null
    }
    return d
}
function Mk(d, o) {
    do {
        var c = Y;
        try {
            if ($g(),
            Fh.current = Rh,
            Ih) {
                for (var h = M.memoizedState; h !== null; ) {
                    var _ = h.queue;
                    _ !== null && (_.pending = null),
                    h = h.next
                }
                Ih = !1
            }
            if (Hh = 0,
            O = N = M = null,
            Jh = !1,
            Kh = 0,
            nk.current = null,
            c === null || c.return === null) {
                T = 1,
                pk = o,
                Y = null;
                break
            }
            e: {
                var b = d
                  , _e = c.return
                  , nt = c
                  , it = o;
                if (o = Z,
                nt.flags |= 32768,
                it !== null && typeof it == "object" && typeof it.then == "function") {
                    var at = it
                      , ut = nt
                      , pt = ut.tag;
                    if (!(ut.mode & 1) && (pt === 0 || pt === 11 || pt === 15)) {
                        var ht = ut.alternate;
                        ht ? (ut.updateQueue = ht.updateQueue,
                        ut.memoizedState = ht.memoizedState,
                        ut.lanes = ht.lanes) : (ut.updateQueue = null,
                        ut.memoizedState = null)
                    }
                    var _t = Ui(_e);
                    if (_t !== null) {
                        _t.flags &= -257,
                        Vi(_t, _e, nt, b, o),
                        _t.mode & 1 && Si(b, at, o),
                        o = _t,
                        it = at;
                        var vt = o.updateQueue;
                        if (vt === null) {
                            var bt = new Set;
                            bt.add(it),
                            o.updateQueue = bt
                        } else
                            vt.add(it);
                        break e
                    } else {
                        if (!(o & 1)) {
                            Si(b, at, o),
                            tj();
                            break e
                        }
                        it = Error(p(426))
                    }
                } else if (I && nt.mode & 1) {
                    var St = Ui(_e);
                    if (St !== null) {
                        !(St.flags & 65536) && (St.flags |= 256),
                        Vi(St, _e, nt, b, o),
                        Jg(Ji(it, nt));
                        break e
                    }
                }
                b = it = Ji(it, nt),
                T !== 4 && (T = 2),
                sk === null ? sk = [b] : sk.push(b),
                b = _e;
                do {
                    switch (b.tag) {
                    case 3:
                        b.flags |= 65536,
                        o &= -o,
                        b.lanes |= o;
                        var At = Ni(b, it, o);
                        ph(b, At);
                        break e;
                    case 1:
                        nt = it;
                        var Et = b.type
                          , Pt = b.stateNode;
                        if (!(b.flags & 128) && (typeof Et.getDerivedStateFromError == "function" || Pt !== null && typeof Pt.componentDidCatch == "function" && (Ri === null || !Ri.has(Pt)))) {
                            b.flags |= 65536,
                            o &= -o,
                            b.lanes |= o;
                            var It = Qi(b, nt, o);
                            ph(b, It);
                            break e
                        }
                    }
                    b = b.return
                } while (b !== null)
            }
            Sk(c)
        } catch (Dt) {
            o = Dt,
            Y === c && c !== null && (Y = c = c.return);
            continue
        }
        break
    } while (!0)
}
function Jk() {
    var d = mk.current;
    return mk.current = Rh,
    d === null ? Rh : d
}
function tj() {
    (T === 0 || T === 3 || T === 2) && (T = 4),
    Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z)
}
function Ik(d, o) {
    var c = K;
    K |= 2;
    var h = Jk();
    (Q !== d || Z !== o) && (uk = null,
    Kk(d, o));
    do
        try {
            Tk();
            break
        } catch (_) {
            Mk(d, _)
        }
    while (!0);
    if ($g(),
    K = c,
    mk.current = h,
    Y !== null)
        throw Error(p(261));
    return Q = null,
    Z = 0,
    T
}
function Tk() {
    for (; Y !== null; )
        Uk(Y)
}
function Lk() {
    for (; Y !== null && !cc(); )
        Uk(Y)
}
function Uk(d) {
    var o = Vk(d.alternate, d, fj);
    d.memoizedProps = d.pendingProps,
    o === null ? Sk(d) : Y = o,
    nk.current = null
}
function Sk(d) {
    var o = d;
    do {
        var c = o.alternate;
        if (d = o.return,
        o.flags & 32768) {
            if (c = Ij(c, o),
            c !== null) {
                c.flags &= 32767,
                Y = c;
                return
            }
            if (d !== null)
                d.flags |= 32768,
                d.subtreeFlags = 0,
                d.deletions = null;
            else {
                T = 6,
                Y = null;
                return
            }
        } else if (c = Ej(c, o, fj),
        c !== null) {
            Y = c;
            return
        }
        if (o = o.sibling,
        o !== null) {
            Y = o;
            return
        }
        Y = o = d
    } while (o !== null);
    T === 0 && (T = 5)
}
function Pk(d, o, c) {
    var h = C
      , _ = ok.transition;
    try {
        ok.transition = null,
        C = 1,
        Wk(d, o, c, h)
    } finally {
        ok.transition = _,
        C = h
    }
    return null
}
function Wk(d, o, c, h) {
    do
        Hk();
    while (wk !== null);
    if (K & 6)
        throw Error(p(327));
    c = d.finishedWork;
    var _ = d.finishedLanes;
    if (c === null)
        return null;
    if (d.finishedWork = null,
    d.finishedLanes = 0,
    c === d.current)
        throw Error(p(177));
    d.callbackNode = null,
    d.callbackPriority = 0;
    var b = c.lanes | c.childLanes;
    if (Bc(d, b),
    d === Q && (Y = Q = null,
    Z = 0),
    !(c.subtreeFlags & 2064) && !(c.flags & 2064) || vk || (vk = !0,
    Fk(hc, function() {
        return Hk(),
        null
    })),
    b = (c.flags & 15990) !== 0,
    c.subtreeFlags & 15990 || b) {
        b = ok.transition,
        ok.transition = null;
        var _e = C;
        C = 1;
        var nt = K;
        K |= 4,
        nk.current = null,
        Oj(d, c),
        dk(c, d),
        Oe(Df),
        dd = !!Cf,
        Df = Cf = null,
        d.current = c,
        hk(c),
        dc(),
        K = nt,
        C = _e,
        ok.transition = b
    } else
        d.current = c;
    if (vk && (vk = !1,
    wk = d,
    xk = _),
    b = d.pendingLanes,
    b === 0 && (Ri = null),
    mc(c.stateNode),
    Dk(d, B()),
    o !== null)
        for (h = d.onRecoverableError,
        c = 0; c < o.length; c++)
            _ = o[c],
            h(_.value, {
                componentStack: _.stack,
                digest: _.digest
            });
    if (Oi)
        throw Oi = !1,
        d = Pi,
        Pi = null,
        d;
    return xk & 1 && d.tag !== 0 && Hk(),
    b = d.pendingLanes,
    b & 1 ? d === zk ? yk++ : (yk = 0,
    zk = d) : yk = 0,
    jg(),
    null
}
function Hk() {
    if (wk !== null) {
        var d = Dc(xk)
          , o = ok.transition
          , c = C;
        try {
            if (ok.transition = null,
            C = 16 > d ? 16 : d,
            wk === null)
                var h = !1;
            else {
                if (d = wk,
                wk = null,
                xk = 0,
                K & 6)
                    throw Error(p(331));
                var _ = K;
                for (K |= 4,
                V = d.current; V !== null; ) {
                    var b = V
                      , _e = b.child;
                    if (V.flags & 16) {
                        var nt = b.deletions;
                        if (nt !== null) {
                            for (var it = 0; it < nt.length; it++) {
                                var at = nt[it];
                                for (V = at; V !== null; ) {
                                    var ut = V;
                                    switch (ut.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Pj(8, ut, b)
                                    }
                                    var pt = ut.child;
                                    if (pt !== null)
                                        pt.return = ut,
                                        V = pt;
                                    else
                                        for (; V !== null; ) {
                                            ut = V;
                                            var ht = ut.sibling
                                              , _t = ut.return;
                                            if (Sj(ut),
                                            ut === at) {
                                                V = null;
                                                break
                                            }
                                            if (ht !== null) {
                                                ht.return = _t,
                                                V = ht;
                                                break
                                            }
                                            V = _t
                                        }
                                }
                            }
                            var vt = b.alternate;
                            if (vt !== null) {
                                var bt = vt.child;
                                if (bt !== null) {
                                    vt.child = null;
                                    do {
                                        var St = bt.sibling;
                                        bt.sibling = null,
                                        bt = St
                                    } while (bt !== null)
                                }
                            }
                            V = b
                        }
                    }
                    if (b.subtreeFlags & 2064 && _e !== null)
                        _e.return = b,
                        V = _e;
                    else
                        e: for (; V !== null; ) {
                            if (b = V,
                            b.flags & 2048)
                                switch (b.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pj(9, b, b.return)
                                }
                            var At = b.sibling;
                            if (At !== null) {
                                At.return = b.return,
                                V = At;
                                break e
                            }
                            V = b.return
                        }
                }
                var Et = d.current;
                for (V = Et; V !== null; ) {
                    _e = V;
                    var Pt = _e.child;
                    if (_e.subtreeFlags & 2064 && Pt !== null)
                        Pt.return = _e,
                        V = Pt;
                    else
                        e: for (_e = Et; V !== null; ) {
                            if (nt = V,
                            nt.flags & 2048)
                                try {
                                    switch (nt.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(9, nt)
                                    }
                                } catch (Dt) {
                                    W(nt, nt.return, Dt)
                                }
                            if (nt === _e) {
                                V = null;
                                break e
                            }
                            var It = nt.sibling;
                            if (It !== null) {
                                It.return = nt.return,
                                V = It;
                                break e
                            }
                            V = nt.return
                        }
                }
                if (K = _,
                jg(),
                lc && typeof lc.onPostCommitFiberRoot == "function")
                    try {
                        lc.onPostCommitFiberRoot(kc, d)
                    } catch {}
                h = !0
            }
            return h
        } finally {
            C = c,
            ok.transition = o
        }
    }
    return !1
}
function Xk(d, o, c) {
    o = Ji(c, o),
    o = Ni(d, o, 1),
    d = nh(d, o, 1),
    o = R(),
    d !== null && (Ac(d, 1, o),
    Dk(d, o))
}
function W(d, o, c) {
    if (d.tag === 3)
        Xk(d, d, c);
    else
        for (; o !== null; ) {
            if (o.tag === 3) {
                Xk(o, d, c);
                break
            } else if (o.tag === 1) {
                var h = o.stateNode;
                if (typeof o.type.getDerivedStateFromError == "function" || typeof h.componentDidCatch == "function" && (Ri === null || !Ri.has(h))) {
                    d = Ji(c, d),
                    d = Qi(o, d, 1),
                    o = nh(o, d, 1),
                    d = R(),
                    o !== null && (Ac(o, 1, d),
                    Dk(o, d));
                    break
                }
            }
            o = o.return
        }
}
function Ti(d, o, c) {
    var h = d.pingCache;
    h !== null && h.delete(o),
    o = R(),
    d.pingedLanes |= d.suspendedLanes & c,
    Q === d && (Z & c) === c && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(d, 0) : rk |= c),
    Dk(d, o)
}
function Yk(d, o) {
    o === 0 && (d.mode & 1 ? (o = sc,
    sc <<= 1,
    !(sc & 130023424) && (sc = 4194304)) : o = 1);
    var c = R();
    d = ih(d, o),
    d !== null && (Ac(d, o, c),
    Dk(d, c))
}
function uj(d) {
    var o = d.memoizedState
      , c = 0;
    o !== null && (c = o.retryLane),
    Yk(d, c)
}
function bk(d, o) {
    var c = 0;
    switch (d.tag) {
    case 13:
        var h = d.stateNode
          , _ = d.memoizedState;
        _ !== null && (c = _.retryLane);
        break;
    case 19:
        h = d.stateNode;
        break;
    default:
        throw Error(p(314))
    }
    h !== null && h.delete(o),
    Yk(d, c)
}
var Vk;
Vk = function(d, o, c) {
    if (d !== null)
        if (d.memoizedProps !== o.pendingProps || Wf.current)
            dh = !0;
        else {
            if (!(d.lanes & c) && !(o.flags & 128))
                return dh = !1,
                yj(d, o, c);
            dh = !!(d.flags & 131072)
        }
    else
        dh = !1,
        I && o.flags & 1048576 && ug(o, ng, o.index);
    switch (o.lanes = 0,
    o.tag) {
    case 2:
        var h = o.type;
        ij(d, o),
        d = o.pendingProps;
        var _ = Yf(o, H.current);
        ch(o, c),
        _ = Nh(null, o, h, d, _, c);
        var b = Sh();
        return o.flags |= 1,
        typeof _ == "object" && _ !== null && typeof _.render == "function" && _.$$typeof === void 0 ? (o.tag = 1,
        o.memoizedState = null,
        o.updateQueue = null,
        Zf(h) ? (b = !0,
        cg(o)) : b = !1,
        o.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null,
        kh(o),
        _.updater = Ei,
        o.stateNode = _,
        _._reactInternals = o,
        Ii(o, h, d, c),
        o = jj(null, o, h, !0, b, c)) : (o.tag = 0,
        I && b && vg(o),
        Xi(null, o, _, c),
        o = o.child),
        o;
    case 16:
        h = o.elementType;
        e: {
            switch (ij(d, o),
            d = o.pendingProps,
            _ = h._init,
            h = _(h._payload),
            o.type = h,
            _ = o.tag = Zk(h),
            d = Ci(h, d),
            _) {
            case 0:
                o = cj(null, o, h, d, c);
                break e;
            case 1:
                o = hj(null, o, h, d, c);
                break e;
            case 11:
                o = Yi(null, o, h, d, c);
                break e;
            case 14:
                o = $i(null, o, h, Ci(h.type, d), c);
                break e
            }
            throw Error(p(306, h, ""))
        }
        return o;
    case 0:
        return h = o.type,
        _ = o.pendingProps,
        _ = o.elementType === h ? _ : Ci(h, _),
        cj(d, o, h, _, c);
    case 1:
        return h = o.type,
        _ = o.pendingProps,
        _ = o.elementType === h ? _ : Ci(h, _),
        hj(d, o, h, _, c);
    case 3:
        e: {
            if (kj(o),
            d === null)
                throw Error(p(387));
            h = o.pendingProps,
            b = o.memoizedState,
            _ = b.element,
            lh(d, o),
            qh(o, h, null, c);
            var _e = o.memoizedState;
            if (h = _e.element,
            b.isDehydrated)
                if (b = {
                    element: h,
                    isDehydrated: !1,
                    cache: _e.cache,
                    pendingSuspenseBoundaries: _e.pendingSuspenseBoundaries,
                    transitions: _e.transitions
                },
                o.updateQueue.baseState = b,
                o.memoizedState = b,
                o.flags & 256) {
                    _ = Ji(Error(p(423)), o),
                    o = lj(d, o, h, c, _);
                    break e
                } else if (h !== _) {
                    _ = Ji(Error(p(424)), o),
                    o = lj(d, o, h, c, _);
                    break e
                } else
                    for (yg = Lf(o.stateNode.containerInfo.firstChild),
                    xg = o,
                    I = !0,
                    zg = null,
                    c = Vg(o, null, h, c),
                    o.child = c; c; )
                        c.flags = c.flags & -3 | 4096,
                        c = c.sibling;
            else {
                if (Ig(),
                h === _) {
                    o = Zi(d, o, c);
                    break e
                }
                Xi(d, o, h, c)
            }
            o = o.child
        }
        return o;
    case 5:
        return Ah(o),
        d === null && Eg(o),
        h = o.type,
        _ = o.pendingProps,
        b = d !== null ? d.memoizedProps : null,
        _e = _.children,
        Ef(h, _) ? _e = null : b !== null && Ef(h, b) && (o.flags |= 32),
        gj(d, o),
        Xi(d, o, _e, c),
        o.child;
    case 6:
        return d === null && Eg(o),
        null;
    case 13:
        return oj(d, o, c);
    case 4:
        return yh(o, o.stateNode.containerInfo),
        h = o.pendingProps,
        d === null ? o.child = Ug(o, null, h, c) : Xi(d, o, h, c),
        o.child;
    case 11:
        return h = o.type,
        _ = o.pendingProps,
        _ = o.elementType === h ? _ : Ci(h, _),
        Yi(d, o, h, _, c);
    case 7:
        return Xi(d, o, o.pendingProps, c),
        o.child;
    case 8:
        return Xi(d, o, o.pendingProps.children, c),
        o.child;
    case 12:
        return Xi(d, o, o.pendingProps.children, c),
        o.child;
    case 10:
        e: {
            if (h = o.type._context,
            _ = o.pendingProps,
            b = o.memoizedProps,
            _e = _.value,
            G(Wg, h._currentValue),
            h._currentValue = _e,
            b !== null)
                if (He(b.value, _e)) {
                    if (b.children === _.children && !Wf.current) {
                        o = Zi(d, o, c);
                        break e
                    }
                } else
                    for (b = o.child,
                    b !== null && (b.return = o); b !== null; ) {
                        var nt = b.dependencies;
                        if (nt !== null) {
                            _e = b.child;
                            for (var it = nt.firstContext; it !== null; ) {
                                if (it.context === h) {
                                    if (b.tag === 1) {
                                        it = mh(-1, c & -c),
                                        it.tag = 2;
                                        var at = b.updateQueue;
                                        if (at !== null) {
                                            at = at.shared;
                                            var ut = at.pending;
                                            ut === null ? it.next = it : (it.next = ut.next,
                                            ut.next = it),
                                            at.pending = it
                                        }
                                    }
                                    b.lanes |= c,
                                    it = b.alternate,
                                    it !== null && (it.lanes |= c),
                                    bh(b.return, c, o),
                                    nt.lanes |= c;
                                    break
                                }
                                it = it.next
                            }
                        } else if (b.tag === 10)
                            _e = b.type === o.type ? null : b.child;
                        else if (b.tag === 18) {
                            if (_e = b.return,
                            _e === null)
                                throw Error(p(341));
                            _e.lanes |= c,
                            nt = _e.alternate,
                            nt !== null && (nt.lanes |= c),
                            bh(_e, c, o),
                            _e = b.sibling
                        } else
                            _e = b.child;
                        if (_e !== null)
                            _e.return = b;
                        else
                            for (_e = b; _e !== null; ) {
                                if (_e === o) {
                                    _e = null;
                                    break
                                }
                                if (b = _e.sibling,
                                b !== null) {
                                    b.return = _e.return,
                                    _e = b;
                                    break
                                }
                                _e = _e.return
                            }
                        b = _e
                    }
            Xi(d, o, _.children, c),
            o = o.child
        }
        return o;
    case 9:
        return _ = o.type,
        h = o.pendingProps.children,
        ch(o, c),
        _ = eh(_),
        h = h(_),
        o.flags |= 1,
        Xi(d, o, h, c),
        o.child;
    case 14:
        return h = o.type,
        _ = Ci(h, o.pendingProps),
        _ = Ci(h.type, _),
        $i(d, o, h, _, c);
    case 15:
        return bj(d, o, o.type, o.pendingProps, c);
    case 17:
        return h = o.type,
        _ = o.pendingProps,
        _ = o.elementType === h ? _ : Ci(h, _),
        ij(d, o),
        o.tag = 1,
        Zf(h) ? (d = !0,
        cg(o)) : d = !1,
        ch(o, c),
        Gi(o, h, _),
        Ii(o, h, _, c),
        jj(null, o, h, !0, d, c);
    case 19:
        return xj(d, o, c);
    case 22:
        return dj(d, o, c)
    }
    throw Error(p(156, o.tag))
}
;
function Fk(d, o) {
    return ac(d, o)
}
function $k(d, o, c, h) {
    this.tag = d,
    this.key = c,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = o,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = h,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(d, o, c, h) {
    return new $k(d,o,c,h)
}
function aj(d) {
    return d = d.prototype,
    !(!d || !d.isReactComponent)
}
function Zk(d) {
    if (typeof d == "function")
        return aj(d) ? 1 : 0;
    if (d != null) {
        if (d = d.$$typeof,
        d === Da)
            return 11;
        if (d === Ga)
            return 14
    }
    return 2
}
function Pg(d, o) {
    var c = d.alternate;
    return c === null ? (c = Bg(d.tag, o, d.key, d.mode),
    c.elementType = d.elementType,
    c.type = d.type,
    c.stateNode = d.stateNode,
    c.alternate = d,
    d.alternate = c) : (c.pendingProps = o,
    c.type = d.type,
    c.flags = 0,
    c.subtreeFlags = 0,
    c.deletions = null),
    c.flags = d.flags & 14680064,
    c.childLanes = d.childLanes,
    c.lanes = d.lanes,
    c.child = d.child,
    c.memoizedProps = d.memoizedProps,
    c.memoizedState = d.memoizedState,
    c.updateQueue = d.updateQueue,
    o = d.dependencies,
    c.dependencies = o === null ? null : {
        lanes: o.lanes,
        firstContext: o.firstContext
    },
    c.sibling = d.sibling,
    c.index = d.index,
    c.ref = d.ref,
    c
}
function Rg(d, o, c, h, _, b) {
    var _e = 2;
    if (h = d,
    typeof d == "function")
        aj(d) && (_e = 1);
    else if (typeof d == "string")
        _e = 5;
    else
        e: switch (d) {
        case ya:
            return Tg(c.children, _, b, o);
        case za:
            _e = 8,
            _ |= 8;
            break;
        case Aa:
            return d = Bg(12, c, o, _ | 2),
            d.elementType = Aa,
            d.lanes = b,
            d;
        case Ea:
            return d = Bg(13, c, o, _),
            d.elementType = Ea,
            d.lanes = b,
            d;
        case Fa:
            return d = Bg(19, c, o, _),
            d.elementType = Fa,
            d.lanes = b,
            d;
        case Ia:
            return pj(c, _, b, o);
        default:
            if (typeof d == "object" && d !== null)
                switch (d.$$typeof) {
                case Ba:
                    _e = 10;
                    break e;
                case Ca:
                    _e = 9;
                    break e;
                case Da:
                    _e = 11;
                    break e;
                case Ga:
                    _e = 14;
                    break e;
                case Ha:
                    _e = 16,
                    h = null;
                    break e
                }
            throw Error(p(130, d == null ? d : typeof d, ""))
        }
    return o = Bg(_e, c, o, _),
    o.elementType = d,
    o.type = h,
    o.lanes = b,
    o
}
function Tg(d, o, c, h) {
    return d = Bg(7, d, h, o),
    d.lanes = c,
    d
}
function pj(d, o, c, h) {
    return d = Bg(22, d, h, o),
    d.elementType = Ia,
    d.lanes = c,
    d.stateNode = {
        isHidden: !1
    },
    d
}
function Qg(d, o, c) {
    return d = Bg(6, d, null, o),
    d.lanes = c,
    d
}
function Sg(d, o, c) {
    return o = Bg(4, d.children !== null ? d.children : [], d.key, o),
    o.lanes = c,
    o.stateNode = {
        containerInfo: d.containerInfo,
        pendingChildren: null,
        implementation: d.implementation
    },
    o
}
function al(d, o, c, h, _) {
    this.tag = o,
    this.containerInfo = d,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = h,
    this.onRecoverableError = _,
    this.mutableSourceEagerHydrationData = null
}
function bl(d, o, c, h, _, b, _e, nt, it) {
    return d = new al(d,o,c,nt,it),
    o === 1 ? (o = 1,
    b === !0 && (o |= 8)) : o = 0,
    b = Bg(3, null, null, o),
    d.current = b,
    b.stateNode = d,
    b.memoizedState = {
        element: h,
        isDehydrated: c,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    kh(b),
    d
}
function cl(d, o, c) {
    var h = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: h == null ? null : "" + h,
        children: d,
        containerInfo: o,
        implementation: c
    }
}
function dl(d) {
    if (!d)
        return Vf;
    d = d._reactInternals;
    e: {
        if (Vb(d) !== d || d.tag !== 1)
            throw Error(p(170));
        var o = d;
        do {
            switch (o.tag) {
            case 3:
                o = o.stateNode.context;
                break e;
            case 1:
                if (Zf(o.type)) {
                    o = o.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            o = o.return
        } while (o !== null);
        throw Error(p(171))
    }
    if (d.tag === 1) {
        var c = d.type;
        if (Zf(c))
            return bg(d, c, o)
    }
    return o
}
function el(d, o, c, h, _, b, _e, nt, it) {
    return d = bl(c, h, !0, d, _, b, _e, nt, it),
    d.context = dl(null),
    c = d.current,
    h = R(),
    _ = yi(c),
    b = mh(h, _),
    b.callback = o ?? null,
    nh(c, b, _),
    d.current.lanes = _,
    Ac(d, _, h),
    Dk(d, h),
    d
}
function fl(d, o, c, h) {
    var _ = o.current
      , b = R()
      , _e = yi(_);
    return c = dl(c),
    o.context === null ? o.context = c : o.pendingContext = c,
    o = mh(b, _e),
    o.payload = {
        element: d
    },
    h = h === void 0 ? null : h,
    h !== null && (o.callback = h),
    d = nh(_, o, _e),
    d !== null && (gi(d, _, _e, b),
    oh(d, _, _e)),
    _e
}
function gl(d) {
    if (d = d.current,
    !d.child)
        return null;
    switch (d.child.tag) {
    case 5:
        return d.child.stateNode;
    default:
        return d.child.stateNode
    }
}
function hl(d, o) {
    if (d = d.memoizedState,
    d !== null && d.dehydrated !== null) {
        var c = d.retryLane;
        d.retryLane = c !== 0 && c < o ? c : o
    }
}
function il(d, o) {
    hl(d, o),
    (d = d.alternate) && hl(d, o)
}
function jl() {
    return null
}
var kl = typeof reportError == "function" ? reportError : function(d) {
    console.error(d)
}
;
function ll(d) {
    this._internalRoot = d
}
ml.prototype.render = ll.prototype.render = function(d) {
    var o = this._internalRoot;
    if (o === null)
        throw Error(p(409));
    fl(d, o, null, null)
}
;
ml.prototype.unmount = ll.prototype.unmount = function() {
    var d = this._internalRoot;
    if (d !== null) {
        this._internalRoot = null;
        var o = d.containerInfo;
        Rk(function() {
            fl(null, d, null, null)
        }),
        o[uf] = null
    }
}
;
function ml(d) {
    this._internalRoot = d
}
ml.prototype.unstable_scheduleHydration = function(d) {
    if (d) {
        var o = Hc();
        d = {
            blockedOn: null,
            target: d,
            priority: o
        };
        for (var c = 0; c < Qc.length && o !== 0 && o < Qc[c].priority; c++)
            ;
        Qc.splice(c, 0, d),
        c === 0 && Vc(d)
    }
}
;
function nl(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)
}
function ol(d) {
    return !(!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11 && (d.nodeType !== 8 || d.nodeValue !== " react-mount-point-unstable "))
}
function pl() {}
function ql(d, o, c, h, _) {
    if (_) {
        if (typeof h == "function") {
            var b = h;
            h = function() {
                var at = gl(_e);
                b.call(at)
            }
        }
        var _e = el(o, h, d, 0, null, !1, !1, "", pl);
        return d._reactRootContainer = _e,
        d[uf] = _e.current,
        sf(d.nodeType === 8 ? d.parentNode : d),
        Rk(),
        _e
    }
    for (; _ = d.lastChild; )
        d.removeChild(_);
    if (typeof h == "function") {
        var nt = h;
        h = function() {
            var at = gl(it);
            nt.call(at)
        }
    }
    var it = bl(d, 0, !1, null, null, !1, !1, "", pl);
    return d._reactRootContainer = it,
    d[uf] = it.current,
    sf(d.nodeType === 8 ? d.parentNode : d),
    Rk(function() {
        fl(o, it, c, h)
    }),
    it
}
function rl(d, o, c, h, _) {
    var b = c._reactRootContainer;
    if (b) {
        var _e = b;
        if (typeof _ == "function") {
            var nt = _;
            _ = function() {
                var it = gl(_e);
                nt.call(it)
            }
        }
        fl(o, _e, d, _)
    } else
        _e = ql(c, o, d, _, h);
    return gl(_e)
}
Ec = function(d) {
    switch (d.tag) {
    case 3:
        var o = d.stateNode;
        if (o.current.memoizedState.isDehydrated) {
            var c = tc(o.pendingLanes);
            c !== 0 && (Cc(o, c | 1),
            Dk(o, B()),
            !(K & 6) && (Gj = B() + 500,
            jg()))
        }
        break;
    case 13:
        Rk(function() {
            var h = ih(d, 1);
            if (h !== null) {
                var _ = R();
                gi(h, d, 1, _)
            }
        }),
        il(d, 1)
    }
}
;
Fc = function(d) {
    if (d.tag === 13) {
        var o = ih(d, 134217728);
        if (o !== null) {
            var c = R();
            gi(o, d, 134217728, c)
        }
        il(d, 134217728)
    }
}
;
Gc = function(d) {
    if (d.tag === 13) {
        var o = yi(d)
          , c = ih(d, o);
        if (c !== null) {
            var h = R();
            gi(c, d, o, h)
        }
        il(d, o)
    }
}
;
Hc = function() {
    return C
}
;
Ic = function(d, o) {
    var c = C;
    try {
        return C = d,
        o()
    } finally {
        C = c
    }
}
;
yb = function(d, o, c) {
    switch (o) {
    case "input":
        if (bb(d, c),
        o = c.name,
        c.type === "radio" && o != null) {
            for (c = d; c.parentNode; )
                c = c.parentNode;
            for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + o) + '][type="radio"]'),
            o = 0; o < c.length; o++) {
                var h = c[o];
                if (h !== d && h.form === d.form) {
                    var _ = Db(h);
                    if (!_)
                        throw Error(p(90));
                    Wa(h),
                    bb(h, _)
                }
            }
        }
        break;
    case "textarea":
        ib(d, c);
        break;
    case "select":
        o = c.value,
        o != null && fb(d, !!c.multiple, o, !1)
    }
}
;
Gb = Qk;
Hb = Rk;
var sl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Qk]
}
  , tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(d) {
        return d = Zb(d),
        d === null ? null : d.stateNode
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
        try {
            kc = vl.inject(ul),
            lc = vl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(d, o) {
    var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl(o))
        throw Error(p(200));
    return cl(d, o, null, c)
}
;
reactDom_production_min.createRoot = function(d, o) {
    if (!nl(d))
        throw Error(p(299));
    var c = !1
      , h = ""
      , _ = kl;
    return o != null && (o.unstable_strictMode === !0 && (c = !0),
    o.identifierPrefix !== void 0 && (h = o.identifierPrefix),
    o.onRecoverableError !== void 0 && (_ = o.onRecoverableError)),
    o = bl(d, 1, !1, null, null, c, !1, h, _),
    d[uf] = o.current,
    sf(d.nodeType === 8 ? d.parentNode : d),
    new ll(o)
}
;
reactDom_production_min.findDOMNode = function(d) {
    if (d == null)
        return null;
    if (d.nodeType === 1)
        return d;
    var o = d._reactInternals;
    if (o === void 0)
        throw typeof d.render == "function" ? Error(p(188)) : (d = Object.keys(d).join(","),
        Error(p(268, d)));
    return d = Zb(o),
    d = d === null ? null : d.stateNode,
    d
}
;
reactDom_production_min.flushSync = function(d) {
    return Rk(d)
}
;
reactDom_production_min.hydrate = function(d, o, c) {
    if (!ol(o))
        throw Error(p(200));
    return rl(null, d, o, !0, c)
}
;
reactDom_production_min.hydrateRoot = function(d, o, c) {
    if (!nl(d))
        throw Error(p(405));
    var h = c != null && c.hydratedSources || null
      , _ = !1
      , b = ""
      , _e = kl;
    if (c != null && (c.unstable_strictMode === !0 && (_ = !0),
    c.identifierPrefix !== void 0 && (b = c.identifierPrefix),
    c.onRecoverableError !== void 0 && (_e = c.onRecoverableError)),
    o = el(o, null, d, 1, c ?? null, _, !1, b, _e),
    d[uf] = o.current,
    sf(d),
    h)
        for (d = 0; d < h.length; d++)
            c = h[d],
            _ = c._getVersion,
            _ = _(c._source),
            o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [c, _] : o.mutableSourceEagerHydrationData.push(c, _);
    return new ml(o)
}
;
reactDom_production_min.render = function(d, o, c) {
    if (!ol(o))
        throw Error(p(200));
    return rl(null, d, o, !1, c)
}
;
reactDom_production_min.unmountComponentAtNode = function(d) {
    if (!ol(d))
        throw Error(p(40));
    return d._reactRootContainer ? (Rk(function() {
        rl(null, null, d, !1, function() {
            d._reactRootContainer = null,
            d[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(d, o, c, h) {
    if (!ol(c))
        throw Error(p(200));
    if (d == null || d._reactInternals === void 0)
        throw Error(p(38));
    return rl(d, o, c, !1, h)
}
;
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (d) {
            console.error(d)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports
  , m = reactDomExports;
client.createRoot = m.createRoot,
client.hydrateRoot = m.hydrateRoot;
const LEFT = "Left"
  , RIGHT = "Right"
  , UP = "Up"
  , DOWN = "Down"
  , defaultProps = {
    delta: 10,
    preventScrollOnSwipe: !1,
    rotationAngle: 0,
    trackMouse: !1,
    trackTouch: !0,
    swipeDuration: 1 / 0,
    touchEventOptions: {
        passive: !0
    }
}
  , initialState = {
    first: !0,
    initial: [0, 0],
    start: 0,
    swiping: !1,
    xy: [0, 0]
}
  , mouseMove = "mousemove"
  , mouseUp = "mouseup"
  , touchEnd = "touchend"
  , touchMove = "touchmove"
  , touchStart = "touchstart";
function getDirection(d, o, c, h) {
    return d > o ? c > 0 ? RIGHT : LEFT : h > 0 ? DOWN : UP
}
function rotateXYByAngle(d, o) {
    if (o === 0)
        return d;
    const c = Math.PI / 180 * o
      , h = d[0] * Math.cos(c) + d[1] * Math.sin(c)
      , _ = d[1] * Math.cos(c) - d[0] * Math.sin(c);
    return [h, _]
}
function getHandlers(d, o) {
    const c = ut => {
        const pt = "touches"in ut;
        pt && ut.touches.length > 1 || d( (ht, _t) => {
            _t.trackMouse && !pt && (document.addEventListener(mouseMove, h),
            document.addEventListener(mouseUp, _e));
            const {clientX: vt, clientY: bt} = pt ? ut.touches[0] : ut
              , St = rotateXYByAngle([vt, bt], _t.rotationAngle);
            return _t.onTouchStartOrOnMouseDown && _t.onTouchStartOrOnMouseDown({
                event: ut
            }),
            Object.assign(Object.assign(Object.assign({}, ht), initialState), {
                initial: St.slice(),
                xy: St,
                start: ut.timeStamp || 0
            })
        }
        )
    }
      , h = ut => {
        d( (pt, ht) => {
            const _t = "touches"in ut;
            if (_t && ut.touches.length > 1)
                return pt;
            if (ut.timeStamp - pt.start > ht.swipeDuration)
                return pt.swiping ? Object.assign(Object.assign({}, pt), {
                    swiping: !1
                }) : pt;
            const {clientX: vt, clientY: bt} = _t ? ut.touches[0] : ut
              , [St,At] = rotateXYByAngle([vt, bt], ht.rotationAngle)
              , Et = St - pt.xy[0]
              , Pt = At - pt.xy[1]
              , It = Math.abs(Et)
              , Dt = Math.abs(Pt)
              , Gt = (ut.timeStamp || 0) - pt.start
              , Bt = Math.sqrt(It * It + Dt * Dt) / (Gt || 1)
              , kt = [Et / (Gt || 1), Pt / (Gt || 1)]
              , Ut = getDirection(It, Dt, Et, Pt)
              , Ht = typeof ht.delta == "number" ? ht.delta : ht.delta[Ut.toLowerCase()] || defaultProps.delta;
            if (It < Ht && Dt < Ht && !pt.swiping)
                return pt;
            const Kt = {
                absX: It,
                absY: Dt,
                deltaX: Et,
                deltaY: Pt,
                dir: Ut,
                event: ut,
                first: pt.first,
                initial: pt.initial,
                velocity: Bt,
                vxvy: kt
            };
            Kt.first && ht.onSwipeStart && ht.onSwipeStart(Kt),
            ht.onSwiping && ht.onSwiping(Kt);
            let Jt = !1;
            return (ht.onSwiping || ht.onSwiped || ht[`onSwiped${Ut}`]) && (Jt = !0),
            Jt && ht.preventScrollOnSwipe && ht.trackTouch && ut.cancelable && ut.preventDefault(),
            Object.assign(Object.assign({}, pt), {
                first: !1,
                eventData: Kt,
                swiping: !0
            })
        }
        )
    }
      , _ = ut => {
        d( (pt, ht) => {
            let _t;
            if (pt.swiping && pt.eventData) {
                if (ut.timeStamp - pt.start < ht.swipeDuration) {
                    _t = Object.assign(Object.assign({}, pt.eventData), {
                        event: ut
                    }),
                    ht.onSwiped && ht.onSwiped(_t);
                    const vt = ht[`onSwiped${_t.dir}`];
                    vt && vt(_t)
                }
            } else
                ht.onTap && ht.onTap({
                    event: ut
                });
            return ht.onTouchEndOrOnMouseUp && ht.onTouchEndOrOnMouseUp({
                event: ut
            }),
            Object.assign(Object.assign(Object.assign({}, pt), initialState), {
                eventData: _t
            })
        }
        )
    }
      , b = () => {
        document.removeEventListener(mouseMove, h),
        document.removeEventListener(mouseUp, _e)
    }
      , _e = ut => {
        b(),
        _(ut)
    }
      , nt = (ut, pt) => {
        let ht = () => {}
        ;
        if (ut && ut.addEventListener) {
            const _t = Object.assign(Object.assign({}, defaultProps.touchEventOptions), pt.touchEventOptions)
              , vt = [[touchStart, c, _t], [touchMove, h, Object.assign(Object.assign({}, _t), pt.preventScrollOnSwipe ? {
                passive: !1
            } : {})], [touchEnd, _, _t]];
            vt.forEach( ([bt,St,At]) => ut.addEventListener(bt, St, At)),
            ht = () => vt.forEach( ([bt,St]) => ut.removeEventListener(bt, St))
        }
        return ht
    }
      , at = {
        ref: ut => {
            ut !== null && d( (pt, ht) => {
                if (pt.el === ut)
                    return pt;
                const _t = {};
                return pt.el && pt.el !== ut && pt.cleanUpTouch && (pt.cleanUpTouch(),
                _t.cleanUpTouch = void 0),
                ht.trackTouch && ut && (_t.cleanUpTouch = nt(ut, ht)),
                Object.assign(Object.assign(Object.assign({}, pt), {
                    el: ut
                }), _t)
            }
            )
        }
    };
    return o.trackMouse && (at.onMouseDown = c),
    [at, nt]
}
function updateTransientState(d, o, c, h) {
    return !o.trackTouch || !d.el ? (d.cleanUpTouch && d.cleanUpTouch(),
    Object.assign(Object.assign({}, d), {
        cleanUpTouch: void 0
    })) : d.cleanUpTouch ? o.preventScrollOnSwipe !== c.preventScrollOnSwipe || o.touchEventOptions.passive !== c.touchEventOptions.passive ? (d.cleanUpTouch(),
    Object.assign(Object.assign({}, d), {
        cleanUpTouch: h(d.el, o)
    })) : d : Object.assign(Object.assign({}, d), {
        cleanUpTouch: h(d.el, o)
    })
}
function useSwipeable(d) {
    const {trackMouse: o} = d
      , c = reactExports.useRef(Object.assign({}, initialState))
      , h = reactExports.useRef(Object.assign({}, defaultProps))
      , _ = reactExports.useRef(Object.assign({}, h.current));
    _.current = Object.assign({}, h.current),
    h.current = Object.assign(Object.assign({}, defaultProps), d);
    let b;
    for (b in defaultProps)
        h.current[b] === void 0 && (h.current[b] = defaultProps[b]);
    const [_e,nt] = reactExports.useMemo( () => getHandlers(it => c.current = it(c.current, h.current), {
        trackMouse: o
    }), [o]);
    return c.current = updateTransientState(c.current, h.current, _.current, nt),
    _e
}
const MotionConfigContext = reactExports.createContext({
    transformPagePoint: d => d,
    isStatic: !1,
    reducedMotion: "never"
})
  , MotionContext = reactExports.createContext({})
  , PresenceContext = reactExports.createContext(null)
  , isBrowser = typeof document < "u"
  , useIsomorphicLayoutEffect = isBrowser ? reactExports.useLayoutEffect : reactExports.useEffect
  , LazyContext = reactExports.createContext({
    strict: !1
})
  , camelToDash = d => d.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase()
  , optimizedAppearDataId = "framerAppearId"
  , optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId)
  , MotionGlobalConfig = {
    skipAnimations: !1,
    useManualTiming: !1
};
class Queue {
    constructor() {
        this.order = [],
        this.scheduled = new Set
    }
    add(o) {
        if (!this.scheduled.has(o))
            return this.scheduled.add(o),
            this.order.push(o),
            !0
    }
    remove(o) {
        const c = this.order.indexOf(o);
        c !== -1 && (this.order.splice(c, 1),
        this.scheduled.delete(o))
    }
    clear() {
        this.order.length = 0,
        this.scheduled.clear()
    }
}
function createRenderStep(d) {
    let o = new Queue
      , c = new Queue
      , h = 0
      , _ = !1
      , b = !1;
    const _e = new WeakSet
      , nt = {
        schedule: (it, at=!1, ut=!1) => {
            const pt = ut && _
              , ht = pt ? o : c;
            return at && _e.add(it),
            ht.add(it) && pt && _ && (h = o.order.length),
            it
        }
        ,
        cancel: it => {
            c.remove(it),
            _e.delete(it)
        }
        ,
        process: it => {
            if (_) {
                b = !0;
                return
            }
            if (_ = !0,
            [o,c] = [c, o],
            c.clear(),
            h = o.order.length,
            h)
                for (let at = 0; at < h; at++) {
                    const ut = o.order[at];
                    _e.has(ut) && (nt.schedule(ut),
                    d()),
                    ut(it)
                }
            _ = !1,
            b && (b = !1,
            nt.process(it))
        }
    };
    return nt
}
const stepsOrder = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"]
  , maxElapsed = 40;
function createRenderBatcher(d, o) {
    let c = !1
      , h = !0;
    const _ = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    }
      , b = stepsOrder.reduce( (pt, ht) => (pt[ht] = createRenderStep( () => c = !0),
    pt), {})
      , _e = pt => {
        b[pt].process(_)
    }
      , nt = () => {
        const pt = performance.now();
        c = !1,
        _.delta = h ? 1e3 / 60 : Math.max(Math.min(pt - _.timestamp, maxElapsed), 1),
        _.timestamp = pt,
        _.isProcessing = !0,
        stepsOrder.forEach(_e),
        _.isProcessing = !1,
        c && o && (h = !1,
        d(nt))
    }
      , it = () => {
        c = !0,
        h = !0,
        _.isProcessing || d(nt)
    }
    ;
    return {
        schedule: stepsOrder.reduce( (pt, ht) => {
            const _t = b[ht];
            return pt[ht] = (vt, bt=!1, St=!1) => (c || it(),
            _t.schedule(vt, bt, St)),
            pt
        }
        , {}),
        cancel: pt => stepsOrder.forEach(ht => b[ht].cancel(pt)),
        state: _,
        steps: b
    }
}
const {schedule: microtask, cancel: cancelMicrotask} = createRenderBatcher(queueMicrotask, !1);
function useVisualElement(d, o, c, h) {
    const {visualElement: _} = reactExports.useContext(MotionContext)
      , b = reactExports.useContext(LazyContext)
      , _e = reactExports.useContext(PresenceContext)
      , nt = reactExports.useContext(MotionConfigContext).reducedMotion
      , it = reactExports.useRef();
    h = h || b.renderer,
    !it.current && h && (it.current = h(d, {
        visualState: o,
        parent: _,
        props: c,
        presenceContext: _e,
        blockInitialAnimation: _e ? _e.initial === !1 : !1,
        reducedMotionConfig: nt
    }));
    const at = it.current;
    reactExports.useInsertionEffect( () => {
        at && at.update(c, _e)
    }
    );
    const ut = reactExports.useRef(!!(c[optimizedAppearDataAttribute] && !window.HandoffComplete));
    return useIsomorphicLayoutEffect( () => {
        at && (microtask.postRender(at.render),
        ut.current && at.animationState && at.animationState.animateChanges())
    }
    ),
    reactExports.useEffect( () => {
        at && (at.updateFeatures(),
        !ut.current && at.animationState && at.animationState.animateChanges(),
        ut.current && (ut.current = !1,
        window.HandoffComplete = !0))
    }
    ),
    at
}
function isRefObject(d) {
    return d && typeof d == "object" && Object.prototype.hasOwnProperty.call(d, "current")
}
function useMotionRef(d, o, c) {
    return reactExports.useCallback(h => {
        h && d.mount && d.mount(h),
        o && (h ? o.mount(h) : o.unmount()),
        c && (typeof c == "function" ? c(h) : isRefObject(c) && (c.current = h))
    }
    , [o])
}
function isVariantLabel(d) {
    return typeof d == "string" || Array.isArray(d)
}
function isAnimationControls(d) {
    return d !== null && typeof d == "object" && typeof d.start == "function"
}
const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"]
  , variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(d) {
    return isAnimationControls(d.animate) || variantProps.some(o => isVariantLabel(d[o]))
}
function isVariantNode(d) {
    return !!(isControllingVariants(d) || d.variants)
}
function getCurrentTreeVariants(d, o) {
    if (isControllingVariants(d)) {
        const {initial: c, animate: h} = d;
        return {
            initial: c === !1 || isVariantLabel(c) ? c : void 0,
            animate: isVariantLabel(h) ? h : void 0
        }
    }
    return d.inherit !== !1 ? o : {}
}
function useCreateMotionContext(d) {
    const {initial: o, animate: c} = getCurrentTreeVariants(d, reactExports.useContext(MotionContext));
    return reactExports.useMemo( () => ({
        initial: o,
        animate: c
    }), [variantLabelsAsDependency(o), variantLabelsAsDependency(c)])
}
function variantLabelsAsDependency(d) {
    return Array.isArray(d) ? d.join(" ") : d
}
const featureProps = {
    animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"]
}
  , featureDefinitions = {};
for (const d in featureProps)
    featureDefinitions[d] = {
        isEnabled: o => featureProps[d].some(c => !!o[c])
    };
function loadFeatures(d) {
    for (const o in d)
        featureDefinitions[o] = {
            ...featureDefinitions[o],
            ...d[o]
        }
}
const LayoutGroupContext = reactExports.createContext({})
  , SwitchLayoutGroupContext = reactExports.createContext({})
  , motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({preloadedFeatures: d, createVisualElement: o, useRender: c, useVisualState: h, Component: _}) {
    d && loadFeatures(d);
    function b(nt, it) {
        let at;
        const ut = {
            ...reactExports.useContext(MotionConfigContext),
            ...nt,
            layoutId: useLayoutId(nt)
        }
          , {isStatic: pt} = ut
          , ht = useCreateMotionContext(nt)
          , _t = h(nt, pt);
        if (!pt && isBrowser) {
            ht.visualElement = useVisualElement(_, _t, ut, o);
            const vt = reactExports.useContext(SwitchLayoutGroupContext)
              , bt = reactExports.useContext(LazyContext).strict;
            ht.visualElement && (at = ht.visualElement.loadFeatures(ut, bt, d, vt))
        }
        return jsxRuntimeExports.jsxs(MotionContext.Provider, {
            value: ht,
            children: [at && ht.visualElement ? jsxRuntimeExports.jsx(at, {
                visualElement: ht.visualElement,
                ...ut
            }) : null, c(_, nt, useMotionRef(_t, ht.visualElement, it), _t, pt, ht.visualElement)]
        })
    }
    const _e = reactExports.forwardRef(b);
    return _e[motionComponentSymbol] = _,
    _e
}
function useLayoutId({layoutId: d}) {
    const o = reactExports.useContext(LayoutGroupContext).id;
    return o && d !== void 0 ? o + "-" + d : d
}
function createMotionProxy(d) {
    function o(h, _={}) {
        return createMotionComponent(d(h, _))
    }
    if (typeof Proxy > "u")
        return o;
    const c = new Map;
    return new Proxy(o,{
        get: (h, _) => (c.has(_) || c.set(_, o(_)),
        c.get(_))
    })
}
const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function isSVGComponent(d) {
    return typeof d != "string" || d.includes("-") ? !1 : !!(lowercaseSVGElements.indexOf(d) > -1 || /[A-Z]/u.test(d))
}
const scaleCorrectors = {};
function addScaleCorrector(d) {
    Object.assign(scaleCorrectors, d)
}
const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"]
  , transformProps = new Set(transformPropOrder);
function isForcedMotionValue(d, {layout: o, layoutId: c}) {
    return transformProps.has(d) || d.startsWith("origin") || (o || c !== void 0) && (!!scaleCorrectors[d] || d === "opacity")
}
const isMotionValue = d => !!(d && d.getVelocity)
  , translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective"
}
  , numTransforms = transformPropOrder.length;
function buildTransform(d, {enableHardwareAcceleration: o=!0, allowTransformNone: c=!0}, h, _) {
    let b = "";
    for (let _e = 0; _e < numTransforms; _e++) {
        const nt = transformPropOrder[_e];
        if (d[nt] !== void 0) {
            const it = translateAlias[nt] || nt;
            b += `${it}(${d[nt]}) `
        }
    }
    return o && !d.z && (b += "translateZ(0)"),
    b = b.trim(),
    _ ? b = _(d, h ? "" : b) : c && h && (b = "none"),
    b
}
const checkStringStartsWith = d => o => typeof o == "string" && o.startsWith(d)
  , isCSSVariableName = checkStringStartsWith("--")
  , startsAsVariableToken = checkStringStartsWith("var(--")
  , isCSSVariableToken = d => startsAsVariableToken(d) ? singleCssVariableRegex.test(d.split("/*")[0].trim()) : !1
  , singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu
  , getValueAsType = (d, o) => o && typeof d == "number" ? o.transform(d) : d
  , clamp = (d, o, c) => c > o ? o : c < d ? d : c
  , number = {
    test: d => typeof d == "number",
    parse: parseFloat,
    transform: d => d
}
  , alpha = {
    ...number,
    transform: d => clamp(0, 1, d)
}
  , scale = {
    ...number,
    default: 1
}
  , sanitize = d => Math.round(d * 1e5) / 1e5
  , floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu
  , colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu
  , singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
function isString(d) {
    return typeof d == "string"
}
const createUnitType = d => ({
    test: o => isString(o) && o.endsWith(d) && o.split(" ").length === 1,
    parse: parseFloat,
    transform: o => `${o}${d}`
})
  , degrees = createUnitType("deg")
  , percent = createUnitType("%")
  , px = createUnitType("px")
  , vh = createUnitType("vh")
  , vw = createUnitType("vw")
  , progressPercentage = {
    ...percent,
    parse: d => percent.parse(d) / 100,
    transform: d => percent.transform(d * 100)
}
  , int = {
    ...number,
    transform: Math.round
}
  , numberValueTypes = {
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    size: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
    zIndex: int,
    backgroundPositionX: px,
    backgroundPositionY: px,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int
};
function buildHTMLStyles(d, o, c, h) {
    const {style: _, vars: b, transform: _e, transformOrigin: nt} = d;
    let it = !1
      , at = !1
      , ut = !0;
    for (const pt in o) {
        const ht = o[pt];
        if (isCSSVariableName(pt)) {
            b[pt] = ht;
            continue
        }
        const _t = numberValueTypes[pt]
          , vt = getValueAsType(ht, _t);
        if (transformProps.has(pt)) {
            if (it = !0,
            _e[pt] = vt,
            !ut)
                continue;
            ht !== (_t.default || 0) && (ut = !1)
        } else
            pt.startsWith("origin") ? (at = !0,
            nt[pt] = vt) : _[pt] = vt
    }
    if (o.transform || (it || h ? _.transform = buildTransform(d.transform, c, ut, h) : _.transform && (_.transform = "none")),
    at) {
        const {originX: pt="50%", originY: ht="50%", originZ: _t=0} = nt;
        _.transformOrigin = `${pt} ${ht} ${_t}`
    }
}
const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {}
});
function copyRawValuesOnly(d, o, c) {
    for (const h in o)
        !isMotionValue(o[h]) && !isForcedMotionValue(h, c) && (d[h] = o[h])
}
function useInitialMotionValues({transformTemplate: d}, o, c) {
    return reactExports.useMemo( () => {
        const h = createHtmlRenderState();
        return buildHTMLStyles(h, o, {
            enableHardwareAcceleration: !c
        }, d),
        Object.assign({}, h.vars, h.style)
    }
    , [o])
}
function useStyle(d, o, c) {
    const h = d.style || {}
      , _ = {};
    return copyRawValuesOnly(_, h, d),
    Object.assign(_, useInitialMotionValues(d, o, c)),
    _
}
function useHTMLProps(d, o, c) {
    const h = {}
      , _ = useStyle(d, o, c);
    return d.drag && d.dragListener !== !1 && (h.draggable = !1,
    _.userSelect = _.WebkitUserSelect = _.WebkitTouchCallout = "none",
    _.touchAction = d.drag === !0 ? "none" : `pan-${d.drag === "x" ? "y" : "x"}`),
    d.tabIndex === void 0 && (d.onTap || d.onTapStart || d.whileTap) && (h.tabIndex = 0),
    h.style = _,
    h
}
const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
function isValidMotionProp(d) {
    return d.startsWith("while") || d.startsWith("drag") && d !== "draggable" || d.startsWith("layout") || d.startsWith("onTap") || d.startsWith("onPan") || d.startsWith("onLayout") || validMotionProps.has(d)
}
let shouldForward = d => !isValidMotionProp(d);
function loadExternalIsValidProp(d) {
    d && (shouldForward = o => o.startsWith("on") ? !isValidMotionProp(o) : d(o))
}
try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
} catch (d) {}
function filterProps(d, o, c) {
    const h = {};
    for (const _ in d)
        _ === "values" && typeof d.values == "object" || (shouldForward(_) || c === !0 && isValidMotionProp(_) || !o && !isValidMotionProp(_) || d.draggable && _.startsWith("onDrag")) && (h[_] = d[_]);
    return h
}
function calcOrigin$1(d, o, c) {
    return typeof d == "string" ? d : px.transform(o + c * d)
}
function calcSVGTransformOrigin(d, o, c) {
    const h = calcOrigin$1(o, d.x, d.width)
      , _ = calcOrigin$1(c, d.y, d.height);
    return `${h} ${_}`
}
const dashKeys = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray"
}
  , camelKeys = {
    offset: "strokeDashoffset",
    array: "strokeDasharray"
};
function buildSVGPath(d, o, c=1, h=0, _=!0) {
    d.pathLength = 1;
    const b = _ ? dashKeys : camelKeys;
    d[b.offset] = px.transform(-h);
    const _e = px.transform(o)
      , nt = px.transform(c);
    d[b.array] = `${_e} ${nt}`
}
function buildSVGAttrs(d, {attrX: o, attrY: c, attrScale: h, originX: _, originY: b, pathLength: _e, pathSpacing: nt=1, pathOffset: it=0, ...at}, ut, pt, ht) {
    if (buildHTMLStyles(d, at, ut, ht),
    pt) {
        d.style.viewBox && (d.attrs.viewBox = d.style.viewBox);
        return
    }
    d.attrs = d.style,
    d.style = {};
    const {attrs: _t, style: vt, dimensions: bt} = d;
    _t.transform && (bt && (vt.transform = _t.transform),
    delete _t.transform),
    bt && (_ !== void 0 || b !== void 0 || vt.transform) && (vt.transformOrigin = calcSVGTransformOrigin(bt, _ !== void 0 ? _ : .5, b !== void 0 ? b : .5)),
    o !== void 0 && (_t.x = o),
    c !== void 0 && (_t.y = c),
    h !== void 0 && (_t.scale = h),
    _e !== void 0 && buildSVGPath(_t, _e, nt, it, !1)
}
const createSvgRenderState = () => ({
    ...createHtmlRenderState(),
    attrs: {}
})
  , isSVGTag = d => typeof d == "string" && d.toLowerCase() === "svg";
function useSVGProps(d, o, c, h) {
    const _ = reactExports.useMemo( () => {
        const b = createSvgRenderState();
        return buildSVGAttrs(b, o, {
            enableHardwareAcceleration: !1
        }, isSVGTag(h), d.transformTemplate),
        {
            ...b.attrs,
            style: {
                ...b.style
            }
        }
    }
    , [o]);
    if (d.style) {
        const b = {};
        copyRawValuesOnly(b, d.style, d),
        _.style = {
            ...b,
            ..._.style
        }
    }
    return _
}
function createUseRender(d=!1) {
    return (c, h, _, {latestValues: b}, _e) => {
        const it = (isSVGComponent(c) ? useSVGProps : useHTMLProps)(h, b, _e, c)
          , at = filterProps(h, typeof c == "string", d)
          , ut = c !== reactExports.Fragment ? {
            ...at,
            ...it,
            ref: _
        } : {}
          , {children: pt} = h
          , ht = reactExports.useMemo( () => isMotionValue(pt) ? pt.get() : pt, [pt]);
        return reactExports.createElement(c, {
            ...ut,
            children: ht
        })
    }
}
function renderHTML(d, {style: o, vars: c}, h, _) {
    Object.assign(d.style, o, _ && _.getProjectionStyles(h));
    for (const b in c)
        d.style.setProperty(b, c[b])
}
const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
function renderSVG(d, o, c, h) {
    renderHTML(d, o, void 0, h);
    for (const _ in o.attrs)
        d.setAttribute(camelCaseAttributes.has(_) ? _ : camelToDash(_), o.attrs[_])
}
function scrapeMotionValuesFromProps$1(d, o, c) {
    var h;
    const {style: _} = d
      , b = {};
    for (const _e in _)
        (isMotionValue(_[_e]) || o.style && isMotionValue(o.style[_e]) || isForcedMotionValue(_e, d) || ((h = c == null ? void 0 : c.getValue(_e)) === null || h === void 0 ? void 0 : h.liveStyle) !== void 0) && (b[_e] = _[_e]);
    return b
}
function scrapeMotionValuesFromProps(d, o, c) {
    const h = scrapeMotionValuesFromProps$1(d, o, c);
    for (const _ in d)
        if (isMotionValue(d[_]) || isMotionValue(o[_])) {
            const b = transformPropOrder.indexOf(_) !== -1 ? "attr" + _.charAt(0).toUpperCase() + _.substring(1) : _;
            h[b] = d[_]
        }
    return h
}
function resolveVariantFromProps(d, o, c, h={}, _={}) {
    return typeof o == "function" && (o = o(c !== void 0 ? c : d.custom, h, _)),
    typeof o == "string" && (o = d.variants && d.variants[o]),
    typeof o == "function" && (o = o(c !== void 0 ? c : d.custom, h, _)),
    o
}
function useConstant(d) {
    const o = reactExports.useRef(null);
    return o.current === null && (o.current = d()),
    o.current
}
const isKeyframesTarget = d => Array.isArray(d)
  , isCustomValue = d => !!(d && typeof d == "object" && d.mix && d.toValue)
  , resolveFinalValueInKeyframes = d => isKeyframesTarget(d) ? d[d.length - 1] || 0 : d;
function resolveMotionValue(d) {
    const o = isMotionValue(d) ? d.get() : d;
    return isCustomValue(o) ? o.toValue() : o
}
function makeState({scrapeMotionValuesFromProps: d, createRenderState: o, onMount: c}, h, _, b) {
    const _e = {
        latestValues: makeLatestValues(h, _, b, d),
        renderState: o()
    };
    return c && (_e.mount = nt => c(h, nt, _e)),
    _e
}
const makeUseVisualState = d => (o, c) => {
    const h = reactExports.useContext(MotionContext)
      , _ = reactExports.useContext(PresenceContext)
      , b = () => makeState(d, o, h, _);
    return c ? b() : useConstant(b)
}
;
function makeLatestValues(d, o, c, h) {
    const _ = {}
      , b = h(d, {});
    for (const ht in b)
        _[ht] = resolveMotionValue(b[ht]);
    let {initial: _e, animate: nt} = d;
    const it = isControllingVariants(d)
      , at = isVariantNode(d);
    o && at && !it && d.inherit !== !1 && (_e === void 0 && (_e = o.initial),
    nt === void 0 && (nt = o.animate));
    let ut = c ? c.initial === !1 : !1;
    ut = ut || _e === !1;
    const pt = ut ? nt : _e;
    return pt && typeof pt != "boolean" && !isAnimationControls(pt) && (Array.isArray(pt) ? pt : [pt]).forEach(_t => {
        const vt = resolveVariantFromProps(d, _t);
        if (!vt)
            return;
        const {transitionEnd: bt, transition: St, ...At} = vt;
        for (const Et in At) {
            let Pt = At[Et];
            if (Array.isArray(Pt)) {
                const It = ut ? Pt.length - 1 : 0;
                Pt = Pt[It]
            }
            Pt !== null && (_[Et] = Pt)
        }
        for (const Et in bt)
            _[Et] = bt[Et]
    }
    ),
    _
}
const noop = d => d
  , {schedule: frame, cancel: cancelFrame, state: frameData, steps} = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0)
  , svgMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (d, o, {renderState: c, latestValues: h}) => {
            frame.read( () => {
                try {
                    c.dimensions = typeof o.getBBox == "function" ? o.getBBox() : o.getBoundingClientRect()
                } catch {
                    c.dimensions = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    }
                }
            }
            ),
            frame.render( () => {
                buildSVGAttrs(c, h, {
                    enableHardwareAcceleration: !1
                }, isSVGTag(o.tagName), d.transformTemplate),
                renderSVG(o, c)
            }
            )
        }
    })
}
  , htmlMotionConfig = {
    useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
    })
};
function createDomMotionConfig(d, {forwardMotionProps: o=!1}, c, h) {
    return {
        ...isSVGComponent(d) ? svgMotionConfig : htmlMotionConfig,
        preloadedFeatures: c,
        useRender: createUseRender(o),
        createVisualElement: h,
        Component: d
    }
}
function addDomEvent(d, o, c, h={
    passive: !0
}) {
    return d.addEventListener(o, c, h),
    () => d.removeEventListener(o, c)
}
const isPrimaryPointer = d => d.pointerType === "mouse" ? typeof d.button != "number" || d.button <= 0 : d.isPrimary !== !1;
function extractEventInfo(d, o="page") {
    return {
        point: {
            x: d[`${o}X`],
            y: d[`${o}Y`]
        }
    }
}
const addPointerInfo = d => o => isPrimaryPointer(o) && d(o, extractEventInfo(o));
function addPointerEvent(d, o, c, h) {
    return addDomEvent(d, o, addPointerInfo(c), h)
}
const combineFunctions = (d, o) => c => o(d(c))
  , pipe = (...d) => d.reduce(combineFunctions);
function createLock(d) {
    let o = null;
    return () => {
        const c = () => {
            o = null
        }
        ;
        return o === null ? (o = d,
        c) : !1
    }
}
const globalHorizontalLock = createLock("dragHorizontal")
  , globalVerticalLock = createLock("dragVertical");
function getGlobalLock(d) {
    let o = !1;
    if (d === "y")
        o = globalVerticalLock();
    else if (d === "x")
        o = globalHorizontalLock();
    else {
        const c = globalHorizontalLock()
          , h = globalVerticalLock();
        c && h ? o = () => {
            c(),
            h()
        }
        : (c && c(),
        h && h())
    }
    return o
}
function isDragActive() {
    const d = getGlobalLock(!0);
    return d ? (d(),
    !1) : !0
}
class Feature {
    constructor(o) {
        this.isMounted = !1,
        this.node = o
    }
    update() {}
}
function addHoverEvent(d, o) {
    const c = o ? "pointerenter" : "pointerleave"
      , h = o ? "onHoverStart" : "onHoverEnd"
      , _ = (b, _e) => {
        if (b.pointerType === "touch" || isDragActive())
            return;
        const nt = d.getProps();
        d.animationState && nt.whileHover && d.animationState.setActive("whileHover", o);
        const it = nt[h];
        it && frame.postRender( () => it(b, _e))
    }
    ;
    return addPointerEvent(d.current, c, _, {
        passive: !d.getProps()[h]
    })
}
class HoverGesture extends Feature {
    mount() {
        this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1))
    }
    unmount() {}
}
class FocusGesture extends Feature {
    constructor() {
        super(...arguments),
        this.isActive = !1
    }
    onFocus() {
        let o = !1;
        try {
            o = this.node.current.matches(":focus-visible")
        } catch {
            o = !0
        }
        !o || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0),
        this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1),
        this.isActive = !1)
    }
    mount() {
        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}
const isNodeOrChild = (d, o) => o ? d === o ? !0 : isNodeOrChild(d, o.parentElement) : !1;
function fireSyntheticPointerEvent(d, o) {
    if (!o)
        return;
    const c = new PointerEvent("pointer" + d);
    o(c, extractEventInfo(c))
}
class PressGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removeStartListeners = noop,
        this.removeEndListeners = noop,
        this.removeAccessibleListeners = noop,
        this.startPointerPress = (o, c) => {
            if (this.isPressing)
                return;
            this.removeEndListeners();
            const h = this.node.getProps()
              , b = addPointerEvent(window, "pointerup", (nt, it) => {
                if (!this.checkPressEnd())
                    return;
                const {onTap: at, onTapCancel: ut, globalTapTarget: pt} = this.node.getProps()
                  , ht = !pt && !isNodeOrChild(this.node.current, nt.target) ? ut : at;
                ht && frame.update( () => ht(nt, it))
            }
            , {
                passive: !(h.onTap || h.onPointerUp)
            })
              , _e = addPointerEvent(window, "pointercancel", (nt, it) => this.cancelPress(nt, it), {
                passive: !(h.onTapCancel || h.onPointerCancel)
            });
            this.removeEndListeners = pipe(b, _e),
            this.startPress(o, c)
        }
        ,
        this.startAccessiblePress = () => {
            const o = b => {
                if (b.key !== "Enter" || this.isPressing)
                    return;
                const _e = nt => {
                    nt.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (it, at) => {
                        const {onTap: ut} = this.node.getProps();
                        ut && frame.postRender( () => ut(it, at))
                    }
                    )
                }
                ;
                this.removeEndListeners(),
                this.removeEndListeners = addDomEvent(this.node.current, "keyup", _e),
                fireSyntheticPointerEvent("down", (nt, it) => {
                    this.startPress(nt, it)
                }
                )
            }
              , c = addDomEvent(this.node.current, "keydown", o)
              , h = () => {
                this.isPressing && fireSyntheticPointerEvent("cancel", (b, _e) => this.cancelPress(b, _e))
            }
              , _ = addDomEvent(this.node.current, "blur", h);
            this.removeAccessibleListeners = pipe(c, _)
        }
    }
    startPress(o, c) {
        this.isPressing = !0;
        const {onTapStart: h, whileTap: _} = this.node.getProps();
        _ && this.node.animationState && this.node.animationState.setActive("whileTap", !0),
        h && frame.postRender( () => h(o, c))
    }
    checkPressEnd() {
        return this.removeEndListeners(),
        this.isPressing = !1,
        this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1),
        !isDragActive()
    }
    cancelPress(o, c) {
        if (!this.checkPressEnd())
            return;
        const {onTapCancel: h} = this.node.getProps();
        h && frame.postRender( () => h(o, c))
    }
    mount() {
        const o = this.node.getProps()
          , c = addPointerEvent(o.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
            passive: !(o.onTapStart || o.onPointerStart)
        })
          , h = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = pipe(c, h)
    }
    unmount() {
        this.removeStartListeners(),
        this.removeEndListeners(),
        this.removeAccessibleListeners()
    }
}
const observerCallbacks = new WeakMap
  , observers = new WeakMap
  , fireObserverCallback = d => {
    const o = observerCallbacks.get(d.target);
    o && o(d)
}
  , fireAllObserverCallbacks = d => {
    d.forEach(fireObserverCallback)
}
;
function initIntersectionObserver({root: d, ...o}) {
    const c = d || document;
    observers.has(c) || observers.set(c, {});
    const h = observers.get(c)
      , _ = JSON.stringify(o);
    return h[_] || (h[_] = new IntersectionObserver(fireAllObserverCallbacks,{
        root: d,
        ...o
    })),
    h[_]
}
function observeIntersection(d, o, c) {
    const h = initIntersectionObserver(o);
    return observerCallbacks.set(d, c),
    h.observe(d),
    () => {
        observerCallbacks.delete(d),
        h.unobserve(d)
    }
}
const thresholdNames = {
    some: 0,
    all: 1
};
class InViewFeature extends Feature {
    constructor() {
        super(...arguments),
        this.hasEnteredView = !1,
        this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {viewport: o={}} = this.node.getProps()
          , {root: c, margin: h, amount: _="some", once: b} = o
          , _e = {
            root: c ? c.current : void 0,
            rootMargin: h,
            threshold: typeof _ == "number" ? _ : thresholdNames[_]
        }
          , nt = it => {
            const {isIntersecting: at} = it;
            if (this.isInView === at || (this.isInView = at,
            b && !at && this.hasEnteredView))
                return;
            at && (this.hasEnteredView = !0),
            this.node.animationState && this.node.animationState.setActive("whileInView", at);
            const {onViewportEnter: ut, onViewportLeave: pt} = this.node.getProps()
              , ht = at ? ut : pt;
            ht && ht(it)
        }
        ;
        return observeIntersection(this.node.current, _e, nt)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u")
            return;
        const {props: o, prevProps: c} = this.node;
        ["amount", "margin", "root"].some(hasViewportOptionChanged(o, c)) && this.startObserver()
    }
    unmount() {}
}
function hasViewportOptionChanged({viewport: d={}}, {viewport: o={}}={}) {
    return c => d[c] !== o[c]
}
const gestureAnimations = {
    inView: {
        Feature: InViewFeature
    },
    tap: {
        Feature: PressGesture
    },
    focus: {
        Feature: FocusGesture
    },
    hover: {
        Feature: HoverGesture
    }
};
function shallowCompare(d, o) {
    if (!Array.isArray(o))
        return !1;
    const c = o.length;
    if (c !== d.length)
        return !1;
    for (let h = 0; h < c; h++)
        if (o[h] !== d[h])
            return !1;
    return !0
}
function getCurrent(d) {
    const o = {};
    return d.values.forEach( (c, h) => o[h] = c.get()),
    o
}
function getVelocity$1(d) {
    const o = {};
    return d.values.forEach( (c, h) => o[h] = c.getVelocity()),
    o
}
function resolveVariant(d, o, c) {
    const h = d.getProps();
    return resolveVariantFromProps(h, o, c !== void 0 ? c : h.custom, getCurrent(d), getVelocity$1(d))
}
const secondsToMilliseconds = d => d * 1e3
  , millisecondsToSeconds = d => d / 1e3
  , underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
}
  , criticallyDampedSpring = d => ({
    type: "spring",
    stiffness: 550,
    damping: d === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
})
  , keyframesTransition = {
    type: "keyframes",
    duration: .8
}
  , ease = {
    type: "keyframes",
    ease: [.25, .1, .35, 1],
    duration: .3
}
  , getDefaultTransition = (d, {keyframes: o}) => o.length > 2 ? keyframesTransition : transformProps.has(d) ? d.startsWith("scale") ? criticallyDampedSpring(o[1]) : underDampedSpring : ease;
function isTransitionDefined({when: d, delay: o, delayChildren: c, staggerChildren: h, staggerDirection: _, repeat: b, repeatType: _e, repeatDelay: nt, from: it, elapsed: at, ...ut}) {
    return !!Object.keys(ut).length
}
function getValueTransition(d, o) {
    return d[o] || d.default || d
}
const isNotNull = d => d !== null;
function getFinalKeyframe(d, {repeat: o, repeatType: c="loop"}, h) {
    const _ = d.filter(isNotNull)
      , b = o && c !== "loop" && o % 2 === 1 ? 0 : _.length - 1;
    return !b || h === void 0 ? _[b] : h
}
let now;
function clearTime() {
    now = void 0
}
const time = {
    now: () => (now === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()),
    now),
    set: d => {
        now = d,
        queueMicrotask(clearTime)
    }
}
  , isZeroValueString = d => /^0[^.\s]+$/u.test(d);
function isNone(d) {
    return typeof d == "number" ? d === 0 : d !== null ? d === "none" || d === "0" || isZeroValueString(d) : !0
}
let invariant = noop;
const isNumericalString = d => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(d)
  , splitCSSVariableRegex = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(d) {
    const o = splitCSSVariableRegex.exec(d);
    if (!o)
        return [, ];
    const [,c,h,_] = o;
    return [`--${c ?? h}`, _]
}
function getVariableValue(d, o, c=1) {
    const [h,_] = parseCSSVariable(d);
    if (!h)
        return;
    const b = window.getComputedStyle(o).getPropertyValue(h);
    if (b) {
        const _e = b.trim();
        return isNumericalString(_e) ? parseFloat(_e) : _e
    }
    return isCSSVariableToken(_) ? getVariableValue(_, o, c + 1) : _
}
const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"])
  , isNumOrPxType = d => d === number || d === px
  , getPosFromMatrix = (d, o) => parseFloat(d.split(", ")[o])
  , getTranslateFromMatrix = (d, o) => (c, {transform: h}) => {
    if (h === "none" || !h)
        return 0;
    const _ = h.match(/^matrix3d\((.+)\)$/u);
    if (_)
        return getPosFromMatrix(_[1], o);
    {
        const b = h.match(/^matrix\((.+)\)$/u);
        return b ? getPosFromMatrix(b[1], d) : 0
    }
}
  , transformKeys = new Set(["x", "y", "z"])
  , nonTranslationalTransformKeys = transformPropOrder.filter(d => !transformKeys.has(d));
function removeNonTranslationalTransform(d) {
    const o = [];
    return nonTranslationalTransformKeys.forEach(c => {
        const h = d.getValue(c);
        h !== void 0 && (o.push([c, h.get()]),
        h.set(c.startsWith("scale") ? 1 : 0))
    }
    ),
    o
}
const positionalValues = {
    width: ({x: d}, {paddingLeft: o="0", paddingRight: c="0"}) => d.max - d.min - parseFloat(o) - parseFloat(c),
    height: ({y: d}, {paddingTop: o="0", paddingBottom: c="0"}) => d.max - d.min - parseFloat(o) - parseFloat(c),
    top: (d, {top: o}) => parseFloat(o),
    left: (d, {left: o}) => parseFloat(o),
    bottom: ({y: d}, {top: o}) => parseFloat(o) + (d.max - d.min),
    right: ({x: d}, {left: o}) => parseFloat(o) + (d.max - d.min),
    x: getTranslateFromMatrix(4, 13),
    y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const testValueType = d => o => o.test(d)
  , auto = {
    test: d => d === "auto",
    parse: d => d
}
  , dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto]
  , findDimensionValueType = d => dimensionValueTypes.find(testValueType(d))
  , toResolve = new Set;
let isScheduled = !1
  , anyNeedsMeasurement = !1;
function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
        const d = Array.from(toResolve).filter(h => h.needsMeasurement)
          , o = new Set(d.map(h => h.element))
          , c = new Map;
        o.forEach(h => {
            const _ = removeNonTranslationalTransform(h);
            _.length && (c.set(h, _),
            h.render())
        }
        ),
        d.forEach(h => h.measureInitialState()),
        o.forEach(h => {
            h.render();
            const _ = c.get(h);
            _ && _.forEach( ([b,_e]) => {
                var nt;
                (nt = h.getValue(b)) === null || nt === void 0 || nt.set(_e)
            }
            )
        }
        ),
        d.forEach(h => h.measureEndState()),
        d.forEach(h => {
            h.suspendedScrollY !== void 0 && window.scrollTo(0, h.suspendedScrollY)
        }
        )
    }
    anyNeedsMeasurement = !1,
    isScheduled = !1,
    toResolve.forEach(d => d.complete()),
    toResolve.clear()
}
function readAllKeyframes() {
    toResolve.forEach(d => {
        d.readKeyframes(),
        d.needsMeasurement && (anyNeedsMeasurement = !0)
    }
    )
}
function flushKeyframeResolvers() {
    readAllKeyframes(),
    measureAllKeyframes()
}
class KeyframeResolver {
    constructor(o, c, h, _, b, _e=!1) {
        this.isComplete = !1,
        this.isAsync = !1,
        this.needsMeasurement = !1,
        this.isScheduled = !1,
        this.unresolvedKeyframes = [...o],
        this.onComplete = c,
        this.name = h,
        this.motionValue = _,
        this.element = b,
        this.isAsync = _e
    }
    scheduleResolve() {
        this.isScheduled = !0,
        this.isAsync ? (toResolve.add(this),
        isScheduled || (isScheduled = !0,
        frame.read(readAllKeyframes),
        frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(),
        this.complete())
    }
    readKeyframes() {
        const {unresolvedKeyframes: o, name: c, element: h, motionValue: _} = this;
        for (let b = 0; b < o.length; b++)
            if (o[b] === null)
                if (b === 0) {
                    const _e = _ == null ? void 0 : _.get()
                      , nt = o[o.length - 1];
                    if (_e !== void 0)
                        o[0] = _e;
                    else if (h && c) {
                        const it = h.readValue(c, nt);
                        it != null && (o[0] = it)
                    }
                    o[0] === void 0 && (o[0] = nt),
                    _ && _e === void 0 && _.set(o[0])
                } else
                    o[b] = o[b - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0,
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
        toResolve.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1,
        toResolve.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const isColorString = (d, o) => c => !!(isString(c) && singleColorRegex.test(c) && c.startsWith(d) || o && Object.prototype.hasOwnProperty.call(c, o))
  , splitColor = (d, o, c) => h => {
    if (!isString(h))
        return h;
    const [_,b,_e,nt] = h.match(floatRegex);
    return {
        [d]: parseFloat(_),
        [o]: parseFloat(b),
        [c]: parseFloat(_e),
        alpha: nt !== void 0 ? parseFloat(nt) : 1
    }
}
  , clampRgbUnit = d => clamp(0, 255, d)
  , rgbUnit = {
    ...number,
    transform: d => Math.round(clampRgbUnit(d))
}
  , rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor("red", "green", "blue"),
    transform: ({red: d, green: o, blue: c, alpha: h=1}) => "rgba(" + rgbUnit.transform(d) + ", " + rgbUnit.transform(o) + ", " + rgbUnit.transform(c) + ", " + sanitize(alpha.transform(h)) + ")"
};
function parseHex(d) {
    let o = ""
      , c = ""
      , h = ""
      , _ = "";
    return d.length > 5 ? (o = d.substring(1, 3),
    c = d.substring(3, 5),
    h = d.substring(5, 7),
    _ = d.substring(7, 9)) : (o = d.substring(1, 2),
    c = d.substring(2, 3),
    h = d.substring(3, 4),
    _ = d.substring(4, 5),
    o += o,
    c += c,
    h += h,
    _ += _),
    {
        red: parseInt(o, 16),
        green: parseInt(c, 16),
        blue: parseInt(h, 16),
        alpha: _ ? parseInt(_, 16) / 255 : 1
    }
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform
}
  , hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor("hue", "saturation", "lightness"),
    transform: ({hue: d, saturation: o, lightness: c, alpha: h=1}) => "hsla(" + Math.round(d) + ", " + percent.transform(sanitize(o)) + ", " + percent.transform(sanitize(c)) + ", " + sanitize(alpha.transform(h)) + ")"
}
  , color = {
    test: d => rgba.test(d) || hex.test(d) || hsla.test(d),
    parse: d => rgba.test(d) ? rgba.parse(d) : hsla.test(d) ? hsla.parse(d) : hex.parse(d),
    transform: d => isString(d) ? d : d.hasOwnProperty("red") ? rgba.transform(d) : hsla.transform(d)
};
function test(d) {
    var o, c;
    return isNaN(d) && isString(d) && (((o = d.match(floatRegex)) === null || o === void 0 ? void 0 : o.length) || 0) + (((c = d.match(colorRegex)) === null || c === void 0 ? void 0 : c.length) || 0) > 0
}
const NUMBER_TOKEN = "number"
  , COLOR_TOKEN = "color"
  , VAR_TOKEN = "var"
  , VAR_FUNCTION_TOKEN = "var("
  , SPLIT_TOKEN = "${}"
  , complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(d) {
    const o = d.toString()
      , c = []
      , h = {
        color: [],
        number: [],
        var: []
    }
      , _ = [];
    let b = 0;
    const nt = o.replace(complexRegex, it => (color.test(it) ? (h.color.push(b),
    _.push(COLOR_TOKEN),
    c.push(color.parse(it))) : it.startsWith(VAR_FUNCTION_TOKEN) ? (h.var.push(b),
    _.push(VAR_TOKEN),
    c.push(it)) : (h.number.push(b),
    _.push(NUMBER_TOKEN),
    c.push(parseFloat(it))),
    ++b,
    SPLIT_TOKEN)).split(SPLIT_TOKEN);
    return {
        values: c,
        split: nt,
        indexes: h,
        types: _
    }
}
function parseComplexValue(d) {
    return analyseComplexValue(d).values
}
function createTransformer(d) {
    const {split: o, types: c} = analyseComplexValue(d)
      , h = o.length;
    return _ => {
        let b = "";
        for (let _e = 0; _e < h; _e++)
            if (b += o[_e],
            _[_e] !== void 0) {
                const nt = c[_e];
                nt === NUMBER_TOKEN ? b += sanitize(_[_e]) : nt === COLOR_TOKEN ? b += color.transform(_[_e]) : b += _[_e]
            }
        return b
    }
}
const convertNumbersToZero = d => typeof d == "number" ? 0 : d;
function getAnimatableNone$1(d) {
    const o = parseComplexValue(d);
    return createTransformer(d)(o.map(convertNumbersToZero))
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1
}
  , maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(d) {
    const [o,c] = d.slice(0, -1).split("(");
    if (o === "drop-shadow")
        return d;
    const [h] = c.match(floatRegex) || [];
    if (!h)
        return d;
    const _ = c.replace(h, "");
    let b = maxDefaults.has(o) ? 1 : 0;
    return h !== c && (b *= 100),
    o + "(" + b + _ + ")"
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu
  , filter = {
    ...complex,
    getAnimatableNone: d => {
        const o = d.match(functionRegex);
        return o ? o.map(applyDefaultFilter).join(" ") : d
    }
}
  , defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter
}
  , getDefaultValueType = d => defaultValueTypes[d];
function getAnimatableNone(d, o) {
    let c = getDefaultValueType(d);
    return c !== filter && (c = complex),
    c.getAnimatableNone ? c.getAnimatableNone(o) : void 0
}
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(d, o, c) {
    let h = 0, _;
    for (; h < d.length && !_; ) {
        const b = d[h];
        typeof b == "string" && !invalidTemplates.has(b) && (_ = d[h]),
        h++
    }
    if (_ && c)
        for (const b of o)
            d[b] = getAnimatableNone(c, _)
}
class DOMKeyframesResolver extends KeyframeResolver {
    constructor(o, c, h, _) {
        super(o, c, h, _, _ == null ? void 0 : _.owner, !0)
    }
    readKeyframes() {
        const {unresolvedKeyframes: o, element: c, name: h} = this;
        if (!c.current)
            return;
        super.readKeyframes();
        for (let it = 0; it < o.length; it++) {
            const at = o[it];
            if (typeof at == "string" && isCSSVariableToken(at)) {
                const ut = getVariableValue(at, c.current);
                ut !== void 0 && (o[it] = ut),
                it === o.length - 1 && (this.finalKeyframe = at)
            }
        }
        if (this.resolveNoneKeyframes(),
        !positionalKeys.has(h) || o.length !== 2)
            return;
        const [_,b] = o
          , _e = findDimensionValueType(_)
          , nt = findDimensionValueType(b);
        if (_e !== nt)
            if (isNumOrPxType(_e) && isNumOrPxType(nt))
                for (let it = 0; it < o.length; it++) {
                    const at = o[it];
                    typeof at == "string" && (o[it] = parseFloat(at))
                }
            else
                this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {unresolvedKeyframes: o, name: c} = this
          , h = [];
        for (let _ = 0; _ < o.length; _++)
            isNone(o[_]) && h.push(_);
        h.length && makeNoneKeyframesAnimatable(o, h, c)
    }
    measureInitialState() {
        const {element: o, unresolvedKeyframes: c, name: h} = this;
        if (!o.current)
            return;
        h === "height" && (this.suspendedScrollY = window.pageYOffset),
        this.measuredOrigin = positionalValues[h](o.measureViewportBox(), window.getComputedStyle(o.current)),
        c[0] = this.measuredOrigin;
        const _ = c[c.length - 1];
        _ !== void 0 && o.getValue(h, _).jump(_, !1)
    }
    measureEndState() {
        var o;
        const {element: c, name: h, unresolvedKeyframes: _} = this;
        if (!c.current)
            return;
        const b = c.getValue(h);
        b && b.jump(this.measuredOrigin, !1);
        const _e = _.length - 1
          , nt = _[_e];
        _[_e] = positionalValues[h](c.measureViewportBox(), window.getComputedStyle(c.current)),
        nt !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = nt),
        !((o = this.removedTransforms) === null || o === void 0) && o.length && this.removedTransforms.forEach( ([it,at]) => {
            c.getValue(it).set(at)
        }
        ),
        this.resolveNoneKeyframes()
    }
}
function memo(d) {
    let o;
    return () => (o === void 0 && (o = d()),
    o)
}
const isAnimatable = (d, o) => o === "zIndex" ? !1 : !!(typeof d == "number" || Array.isArray(d) || typeof d == "string" && (complex.test(d) || d === "0") && !d.startsWith("url("));
function hasKeyframesChanged(d) {
    const o = d[0];
    if (d.length === 1)
        return !0;
    for (let c = 0; c < d.length; c++)
        if (d[c] !== o)
            return !0
}
function canAnimate(d, o, c, h) {
    const _ = d[0];
    if (_ === null)
        return !1;
    const b = d[d.length - 1]
      , _e = isAnimatable(_, o)
      , nt = isAnimatable(b, o);
    return !_e || !nt ? !1 : hasKeyframesChanged(d) || c === "spring" && h
}
class BaseAnimation {
    constructor({autoplay: o=!0, delay: c=0, type: h="keyframes", repeat: _=0, repeatDelay: b=0, repeatType: _e="loop", ...nt}) {
        this.isStopped = !1,
        this.hasAttemptedResolve = !1,
        this.options = {
            autoplay: o,
            delay: c,
            type: h,
            repeat: _,
            repeatDelay: b,
            repeatType: _e,
            ...nt
        },
        this.updateFinishedPromise()
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && flushKeyframeResolvers(),
        this._resolved
    }
    onKeyframesResolved(o, c) {
        this.hasAttemptedResolve = !0;
        const {name: h, type: _, velocity: b, delay: _e, onComplete: nt, onUpdate: it, isGenerator: at} = this.options;
        if (!at && !canAnimate(o, h, _, b))
            if (_e)
                this.options.duration = 0;
            else {
                it == null || it(getFinalKeyframe(o, this.options, c)),
                nt == null || nt(),
                this.resolveFinishedPromise();
                return
            }
        const ut = this.initPlayback(o, c);
        ut !== !1 && (this._resolved = {
            keyframes: o,
            finalKeyframe: c,
            ...ut
        },
        this.onPostResolved())
    }
    onPostResolved() {}
    then(o, c) {
        return this.currentFinishedPromise.then(o, c)
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(o => {
            this.resolveFinishedPromise = o
        }
        )
    }
}
function velocityPerSecond(d, o) {
    return o ? d * (1e3 / o) : 0
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(d, o, c) {
    const h = Math.max(o - velocitySampleDuration, 0);
    return velocityPerSecond(c - d(h), o - h)
}
const safeMin = .001
  , minDuration = .01
  , maxDuration$1 = 10
  , minDamping = .05
  , maxDamping = 1;
function findSpring({duration: d=800, bounce: o=.25, velocity: c=0, mass: h=1}) {
    let _, b, _e = 1 - o;
    _e = clamp(minDamping, maxDamping, _e),
    d = clamp(minDuration, maxDuration$1, millisecondsToSeconds(d)),
    _e < 1 ? (_ = at => {
        const ut = at * _e
          , pt = ut * d
          , ht = ut - c
          , _t = calcAngularFreq(at, _e)
          , vt = Math.exp(-pt);
        return safeMin - ht / _t * vt
    }
    ,
    b = at => {
        const pt = at * _e * d
          , ht = pt * c + c
          , _t = Math.pow(_e, 2) * Math.pow(at, 2) * d
          , vt = Math.exp(-pt)
          , bt = calcAngularFreq(Math.pow(at, 2), _e);
        return (-_(at) + safeMin > 0 ? -1 : 1) * ((ht - _t) * vt) / bt
    }
    ) : (_ = at => {
        const ut = Math.exp(-at * d)
          , pt = (at - c) * d + 1;
        return -safeMin + ut * pt
    }
    ,
    b = at => {
        const ut = Math.exp(-at * d)
          , pt = (c - at) * (d * d);
        return ut * pt
    }
    );
    const nt = 5 / d
      , it = approximateRoot(_, b, nt);
    if (d = secondsToMilliseconds(d),
    isNaN(it))
        return {
            stiffness: 100,
            damping: 10,
            duration: d
        };
    {
        const at = Math.pow(it, 2) * h;
        return {
            stiffness: at,
            damping: _e * 2 * Math.sqrt(h * at),
            duration: d
        }
    }
}
const rootIterations = 12;
function approximateRoot(d, o, c) {
    let h = c;
    for (let _ = 1; _ < rootIterations; _++)
        h = h - d(h) / o(h);
    return h
}
function calcAngularFreq(d, o) {
    return d * Math.sqrt(1 - o * o)
}
const durationKeys = ["duration", "bounce"]
  , physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(d, o) {
    return o.some(c => d[c] !== void 0)
}
function getSpringOptions(d) {
    let o = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: !1,
        ...d
    };
    if (!isSpringType(d, physicsKeys) && isSpringType(d, durationKeys)) {
        const c = findSpring(d);
        o = {
            ...o,
            ...c,
            mass: 1
        },
        o.isResolvedFromDuration = !0
    }
    return o
}
function spring({keyframes: d, restDelta: o, restSpeed: c, ...h}) {
    const _ = d[0]
      , b = d[d.length - 1]
      , _e = {
        done: !1,
        value: _
    }
      , {stiffness: nt, damping: it, mass: at, duration: ut, velocity: pt, isResolvedFromDuration: ht} = getSpringOptions({
        ...h,
        velocity: -millisecondsToSeconds(h.velocity || 0)
    })
      , _t = pt || 0
      , vt = it / (2 * Math.sqrt(nt * at))
      , bt = b - _
      , St = millisecondsToSeconds(Math.sqrt(nt / at))
      , At = Math.abs(bt) < 5;
    c || (c = At ? .01 : 2),
    o || (o = At ? .005 : .5);
    let Et;
    if (vt < 1) {
        const Pt = calcAngularFreq(St, vt);
        Et = It => {
            const Dt = Math.exp(-vt * St * It);
            return b - Dt * ((_t + vt * St * bt) / Pt * Math.sin(Pt * It) + bt * Math.cos(Pt * It))
        }
    } else if (vt === 1)
        Et = Pt => b - Math.exp(-St * Pt) * (bt + (_t + St * bt) * Pt);
    else {
        const Pt = St * Math.sqrt(vt * vt - 1);
        Et = It => {
            const Dt = Math.exp(-vt * St * It)
              , Gt = Math.min(Pt * It, 300);
            return b - Dt * ((_t + vt * St * bt) * Math.sinh(Gt) + Pt * bt * Math.cosh(Gt)) / Pt
        }
    }
    return {
        calculatedDuration: ht && ut || null,
        next: Pt => {
            const It = Et(Pt);
            if (ht)
                _e.done = Pt >= ut;
            else {
                let Dt = _t;
                Pt !== 0 && (vt < 1 ? Dt = calcGeneratorVelocity(Et, Pt, It) : Dt = 0);
                const Gt = Math.abs(Dt) <= c
                  , Bt = Math.abs(b - It) <= o;
                _e.done = Gt && Bt
            }
            return _e.value = _e.done ? b : It,
            _e
        }
    }
}
function inertia({keyframes: d, velocity: o=0, power: c=.8, timeConstant: h=325, bounceDamping: _=10, bounceStiffness: b=500, modifyTarget: _e, min: nt, max: it, restDelta: at=.5, restSpeed: ut}) {
    const pt = d[0]
      , ht = {
        done: !1,
        value: pt
    }
      , _t = kt => nt !== void 0 && kt < nt || it !== void 0 && kt > it
      , vt = kt => nt === void 0 ? it : it === void 0 || Math.abs(nt - kt) < Math.abs(it - kt) ? nt : it;
    let bt = c * o;
    const St = pt + bt
      , At = _e === void 0 ? St : _e(St);
    At !== St && (bt = At - pt);
    const Et = kt => -bt * Math.exp(-kt / h)
      , Pt = kt => At + Et(kt)
      , It = kt => {
        const Ut = Et(kt)
          , Ht = Pt(kt);
        ht.done = Math.abs(Ut) <= at,
        ht.value = ht.done ? At : Ht
    }
    ;
    let Dt, Gt;
    const Bt = kt => {
        _t(ht.value) && (Dt = kt,
        Gt = spring({
            keyframes: [ht.value, vt(ht.value)],
            velocity: calcGeneratorVelocity(Pt, kt, ht.value),
            damping: _,
            stiffness: b,
            restDelta: at,
            restSpeed: ut
        }))
    }
    ;
    return Bt(0),
    {
        calculatedDuration: null,
        next: kt => {
            let Ut = !1;
            return !Gt && Dt === void 0 && (Ut = !0,
            It(kt),
            Bt(kt)),
            Dt !== void 0 && kt >= Dt ? Gt.next(kt - Dt) : (!Ut && It(kt),
            ht)
        }
    }
}
const calcBezier = (d, o, c) => (((1 - 3 * c + 3 * o) * d + (3 * c - 6 * o)) * d + 3 * o) * d
  , subdivisionPrecision = 1e-7
  , subdivisionMaxIterations = 12;
function binarySubdivide(d, o, c, h, _) {
    let b, _e, nt = 0;
    do
        _e = o + (c - o) / 2,
        b = calcBezier(_e, h, _) - d,
        b > 0 ? c = _e : o = _e;
    while (Math.abs(b) > subdivisionPrecision && ++nt < subdivisionMaxIterations);
    return _e
}
function cubicBezier(d, o, c, h) {
    if (d === o && c === h)
        return noop;
    const _ = b => binarySubdivide(b, 0, 1, d, c);
    return b => b === 0 || b === 1 ? b : calcBezier(_(b), o, h)
}
const easeIn = cubicBezier(.42, 0, 1, 1)
  , easeOut = cubicBezier(0, 0, .58, 1)
  , easeInOut = cubicBezier(.42, 0, .58, 1)
  , isEasingArray = d => Array.isArray(d) && typeof d[0] != "number"
  , mirrorEasing = d => o => o <= .5 ? d(2 * o) / 2 : (2 - d(2 * (1 - o))) / 2
  , reverseEasing = d => o => 1 - d(1 - o)
  , circIn = d => 1 - Math.sin(Math.acos(d))
  , circOut = reverseEasing(circIn)
  , circInOut = mirrorEasing(circIn)
  , backOut = cubicBezier(.33, 1.53, .69, .99)
  , backIn = reverseEasing(backOut)
  , backInOut = mirrorEasing(backIn)
  , anticipate = d => (d *= 2) < 1 ? .5 * backIn(d) : .5 * (2 - Math.pow(2, -10 * (d - 1)))
  , easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate
}
  , easingDefinitionToFunction = d => {
    if (Array.isArray(d)) {
        invariant(d.length === 4);
        const [o,c,h,_] = d;
        return cubicBezier(o, c, h, _)
    } else if (typeof d == "string")
        return invariant(easingLookup[d] !== void 0),
        easingLookup[d];
    return d
}
  , progress = (d, o, c) => {
    const h = o - d;
    return h === 0 ? 1 : (c - d) / h
}
  , mixNumber$1 = (d, o, c) => d + (o - d) * c;
function hueToRgb(d, o, c) {
    return c < 0 && (c += 1),
    c > 1 && (c -= 1),
    c < 1 / 6 ? d + (o - d) * 6 * c : c < 1 / 2 ? o : c < 2 / 3 ? d + (o - d) * (2 / 3 - c) * 6 : d
}
function hslaToRgba({hue: d, saturation: o, lightness: c, alpha: h}) {
    d /= 360,
    o /= 100,
    c /= 100;
    let _ = 0
      , b = 0
      , _e = 0;
    if (!o)
        _ = b = _e = c;
    else {
        const nt = c < .5 ? c * (1 + o) : c + o - c * o
          , it = 2 * c - nt;
        _ = hueToRgb(it, nt, d + 1 / 3),
        b = hueToRgb(it, nt, d),
        _e = hueToRgb(it, nt, d - 1 / 3)
    }
    return {
        red: Math.round(_ * 255),
        green: Math.round(b * 255),
        blue: Math.round(_e * 255),
        alpha: h
    }
}
const mixLinearColor = (d, o, c) => {
    const h = d * d
      , _ = c * (o * o - h) + h;
    return _ < 0 ? 0 : Math.sqrt(_)
}
  , colorTypes = [hex, rgba, hsla]
  , getColorType = d => colorTypes.find(o => o.test(d));
function asRGBA(d) {
    const o = getColorType(d);
    let c = o.parse(d);
    return o === hsla && (c = hslaToRgba(c)),
    c
}
const mixColor = (d, o) => {
    const c = asRGBA(d)
      , h = asRGBA(o)
      , _ = {
        ...c
    };
    return b => (_.red = mixLinearColor(c.red, h.red, b),
    _.green = mixLinearColor(c.green, h.green, b),
    _.blue = mixLinearColor(c.blue, h.blue, b),
    _.alpha = mixNumber$1(c.alpha, h.alpha, b),
    rgba.transform(_))
}
;
function mixImmediate(d, o) {
    return c => c > 0 ? o : d
}
function mixNumber(d, o) {
    return c => mixNumber$1(d, o, c)
}
function getMixer$1(d) {
    return typeof d == "number" ? mixNumber : typeof d == "string" ? isCSSVariableToken(d) ? mixImmediate : color.test(d) ? mixColor : mixComplex : Array.isArray(d) ? mixArray : typeof d == "object" ? color.test(d) ? mixColor : mixObject : mixImmediate
}
function mixArray(d, o) {
    const c = [...d]
      , h = c.length
      , _ = d.map( (b, _e) => getMixer$1(b)(b, o[_e]));
    return b => {
        for (let _e = 0; _e < h; _e++)
            c[_e] = _[_e](b);
        return c
    }
}
function mixObject(d, o) {
    const c = {
        ...d,
        ...o
    }
      , h = {};
    for (const _ in c)
        d[_] !== void 0 && o[_] !== void 0 && (h[_] = getMixer$1(d[_])(d[_], o[_]));
    return _ => {
        for (const b in h)
            c[b] = h[b](_);
        return c
    }
}
function matchOrder(d, o) {
    var c;
    const h = []
      , _ = {
        color: 0,
        var: 0,
        number: 0
    };
    for (let b = 0; b < o.values.length; b++) {
        const _e = o.types[b]
          , nt = d.indexes[_e][_[_e]]
          , it = (c = d.values[nt]) !== null && c !== void 0 ? c : 0;
        h[b] = it,
        _[_e]++
    }
    return h
}
const mixComplex = (d, o) => {
    const c = complex.createTransformer(o)
      , h = analyseComplexValue(d)
      , _ = analyseComplexValue(o);
    return h.indexes.var.length === _.indexes.var.length && h.indexes.color.length === _.indexes.color.length && h.indexes.number.length >= _.indexes.number.length ? pipe(mixArray(matchOrder(h, _), _.values), c) : mixImmediate(d, o)
}
;
function mix(d, o, c) {
    return typeof d == "number" && typeof o == "number" && typeof c == "number" ? mixNumber$1(d, o, c) : getMixer$1(d)(d, o)
}
function createMixers(d, o, c) {
    const h = []
      , _ = c || mix
      , b = d.length - 1;
    for (let _e = 0; _e < b; _e++) {
        let nt = _(d[_e], d[_e + 1]);
        if (o) {
            const it = Array.isArray(o) ? o[_e] || noop : o;
            nt = pipe(it, nt)
        }
        h.push(nt)
    }
    return h
}
function interpolate(d, o, {clamp: c=!0, ease: h, mixer: _}={}) {
    const b = d.length;
    if (invariant(b === o.length),
    b === 1)
        return () => o[0];
    if (b === 2 && d[0] === d[1])
        return () => o[1];
    d[0] > d[b - 1] && (d = [...d].reverse(),
    o = [...o].reverse());
    const _e = createMixers(o, h, _)
      , nt = _e.length
      , it = at => {
        let ut = 0;
        if (nt > 1)
            for (; ut < d.length - 2 && !(at < d[ut + 1]); ut++)
                ;
        const pt = progress(d[ut], d[ut + 1], at);
        return _e[ut](pt)
    }
    ;
    return c ? at => it(clamp(d[0], d[b - 1], at)) : it
}
function fillOffset(d, o) {
    const c = d[d.length - 1];
    for (let h = 1; h <= o; h++) {
        const _ = progress(0, o, h);
        d.push(mixNumber$1(c, 1, _))
    }
}
function defaultOffset(d) {
    const o = [0];
    return fillOffset(o, d.length - 1),
    o
}
function convertOffsetToTimes(d, o) {
    return d.map(c => c * o)
}
function defaultEasing(d, o) {
    return d.map( () => o || easeInOut).splice(0, d.length - 1)
}
function keyframes({duration: d=300, keyframes: o, times: c, ease: h="easeInOut"}) {
    const _ = isEasingArray(h) ? h.map(easingDefinitionToFunction) : easingDefinitionToFunction(h)
      , b = {
        done: !1,
        value: o[0]
    }
      , _e = convertOffsetToTimes(c && c.length === o.length ? c : defaultOffset(o), d)
      , nt = interpolate(_e, o, {
        ease: Array.isArray(_) ? _ : defaultEasing(o, _)
    });
    return {
        calculatedDuration: d,
        next: it => (b.value = nt(it),
        b.done = it >= d,
        b)
    }
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(d) {
    let o = 0;
    const c = 50;
    let h = d.next(o);
    for (; !h.done && o < maxGeneratorDuration; )
        o += c,
        h = d.next(o);
    return o >= maxGeneratorDuration ? 1 / 0 : o
}
const frameloopDriver = d => {
    const o = ({timestamp: c}) => d(c);
    return {
        start: () => frame.update(o, !0),
        stop: () => cancelFrame(o),
        now: () => frameData.isProcessing ? frameData.timestamp : time.now()
    }
}
  , generators = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring
}
  , percentToProgress = d => d / 100;
class MainThreadAnimation extends BaseAnimation {
    constructor({KeyframeResolver: o=KeyframeResolver, ...c}) {
        super(c),
        this.holdTime = null,
        this.startTime = null,
        this.cancelTime = null,
        this.currentTime = 0,
        this.playbackSpeed = 1,
        this.pendingPlayState = "running",
        this.state = "idle",
        this.stop = () => {
            if (this.resolver.cancel(),
            this.isStopped = !0,
            this.state === "idle")
                return;
            this.teardown();
            const {onStop: nt} = this.options;
            nt && nt()
        }
        ;
        const {name: h, motionValue: _, keyframes: b} = this.options
          , _e = (nt, it) => this.onKeyframesResolved(nt, it);
        h && _ && _.owner ? this.resolver = _.owner.resolveKeyframes(b, _e, h, _) : this.resolver = new o(b,_e,h,_),
        this.resolver.scheduleResolve()
    }
    initPlayback(o) {
        const {type: c="keyframes", repeat: h=0, repeatDelay: _=0, repeatType: b, velocity: _e=0} = this.options
          , nt = generators[c] || keyframes;
        let it, at;
        nt !== keyframes && typeof o[0] != "number" && (it = pipe(percentToProgress, mix(o[0], o[1])),
        o = [0, 100]);
        const ut = nt({
            ...this.options,
            keyframes: o
        });
        b === "mirror" && (at = nt({
            ...this.options,
            keyframes: [...o].reverse(),
            velocity: -_e
        })),
        ut.calculatedDuration === null && (ut.calculatedDuration = calcGeneratorDuration(ut));
        const {calculatedDuration: pt} = ut
          , ht = pt + _
          , _t = ht * (h + 1) - _;
        return {
            generator: ut,
            mirroredGenerator: at,
            mapPercentToKeyframes: it,
            calculatedDuration: pt,
            resolvedDuration: ht,
            totalDuration: _t
        }
    }
    onPostResolved() {
        const {autoplay: o=!0} = this.options;
        this.play(),
        this.pendingPlayState === "paused" || !o ? this.pause() : this.state = this.pendingPlayState
    }
    tick(o, c=!1) {
        const {resolved: h} = this;
        if (!h) {
            const {keyframes: kt} = this.options;
            return {
                done: !0,
                value: kt[kt.length - 1]
            }
        }
        const {finalKeyframe: _, generator: b, mirroredGenerator: _e, mapPercentToKeyframes: nt, keyframes: it, calculatedDuration: at, totalDuration: ut, resolvedDuration: pt} = h;
        if (this.startTime === null)
            return b.next(0);
        const {delay: ht, repeat: _t, repeatType: vt, repeatDelay: bt, onUpdate: St} = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, o) : this.speed < 0 && (this.startTime = Math.min(o - ut / this.speed, this.startTime)),
        c ? this.currentTime = o : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(o - this.startTime) * this.speed;
        const At = this.currentTime - ht * (this.speed >= 0 ? 1 : -1)
          , Et = this.speed >= 0 ? At < 0 : At > ut;
        this.currentTime = Math.max(At, 0),
        this.state === "finished" && this.holdTime === null && (this.currentTime = ut);
        let Pt = this.currentTime
          , It = b;
        if (_t) {
            const kt = Math.min(this.currentTime, ut) / pt;
            let Ut = Math.floor(kt)
              , Ht = kt % 1;
            !Ht && kt >= 1 && (Ht = 1),
            Ht === 1 && Ut--,
            Ut = Math.min(Ut, _t + 1),
            !!(Ut % 2) && (vt === "reverse" ? (Ht = 1 - Ht,
            bt && (Ht -= bt / pt)) : vt === "mirror" && (It = _e)),
            Pt = clamp(0, 1, Ht) * pt
        }
        const Dt = Et ? {
            done: !1,
            value: it[0]
        } : It.next(Pt);
        nt && (Dt.value = nt(Dt.value));
        let {done: Gt} = Dt;
        !Et && at !== null && (Gt = this.speed >= 0 ? this.currentTime >= ut : this.currentTime <= 0);
        const Bt = this.holdTime === null && (this.state === "finished" || this.state === "running" && Gt);
        return Bt && _ !== void 0 && (Dt.value = getFinalKeyframe(it, this.options, _)),
        St && St(Dt.value),
        Bt && this.finish(),
        Dt
    }
    get duration() {
        const {resolved: o} = this;
        return o ? millisecondsToSeconds(o.calculatedDuration) : 0
    }
    get time() {
        return millisecondsToSeconds(this.currentTime)
    }
    set time(o) {
        o = secondsToMilliseconds(o),
        this.currentTime = o,
        this.holdTime !== null || this.speed === 0 ? this.holdTime = o : this.driver && (this.startTime = this.driver.now() - o / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(o) {
        const c = this.playbackSpeed !== o;
        this.playbackSpeed = o,
        c && (this.time = millisecondsToSeconds(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(),
        !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped)
            return;
        const {driver: o=frameloopDriver, onPlay: c} = this.options;
        this.driver || (this.driver = o(_ => this.tick(_))),
        c && c();
        const h = this.driver.now();
        this.holdTime !== null ? this.startTime = h - this.holdTime : (!this.startTime || this.state === "finished") && (this.startTime = h),
        this.state === "finished" && this.updateFinishedPromise(),
        this.cancelTime = this.startTime,
        this.holdTime = null,
        this.state = "running",
        this.driver.start()
    }
    pause() {
        var o;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused",
        this.holdTime = (o = this.currentTime) !== null && o !== void 0 ? o : 0
    }
    complete() {
        this.state !== "running" && this.play(),
        this.pendingPlayState = this.state = "finished",
        this.holdTime = null
    }
    finish() {
        this.teardown(),
        this.state = "finished";
        const {onComplete: o} = this.options;
        o && o()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime),
        this.teardown(),
        this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle",
        this.stopDriver(),
        this.resolveFinishedPromise(),
        this.updateFinishedPromise(),
        this.startTime = this.cancelTime = null,
        this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(),
        this.driver = void 0)
    }
    sample(o) {
        return this.startTime = 0,
        this.tick(o, !0)
    }
}
function animateValue(d) {
    return new MainThreadAnimation(d)
}
const isBezierDefinition = d => Array.isArray(d) && typeof d[0] == "number";
function isWaapiSupportedEasing(d) {
    return !!(!d || typeof d == "string" && d in supportedWaapiEasing || isBezierDefinition(d) || Array.isArray(d) && d.every(isWaapiSupportedEasing))
}
const cubicBezierAsString = ([d,o,c,h]) => `cubic-bezier(${d}, ${o}, ${c}, ${h})`
  , supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, .65, .55, 1]),
    circOut: cubicBezierAsString([.55, 0, 1, .45]),
    backIn: cubicBezierAsString([.31, .01, .66, -.59]),
    backOut: cubicBezierAsString([.33, 1.53, .69, .99])
};
function mapEasingToNativeEasingWithDefault(d) {
    return mapEasingToNativeEasing(d) || supportedWaapiEasing.easeOut
}
function mapEasingToNativeEasing(d) {
    if (d)
        return isBezierDefinition(d) ? cubicBezierAsString(d) : Array.isArray(d) ? d.map(mapEasingToNativeEasingWithDefault) : supportedWaapiEasing[d]
}
function animateStyle(d, o, c, {delay: h=0, duration: _=300, repeat: b=0, repeatType: _e="loop", ease: nt, times: it}={}) {
    const at = {
        [o]: c
    };
    it && (at.offset = it);
    const ut = mapEasingToNativeEasing(nt);
    return Array.isArray(ut) && (at.easing = ut),
    d.animate(at, {
        delay: h,
        duration: _,
        easing: Array.isArray(ut) ? "linear" : ut,
        fill: "both",
        iterations: b + 1,
        direction: _e === "reverse" ? "alternate" : "normal"
    })
}
const supportsWaapi = memo( () => Object.hasOwnProperty.call(Element.prototype, "animate"))
  , acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"])
  , sampleDelta = 10
  , maxDuration = 2e4;
function requiresPregeneratedKeyframes(d) {
    return d.type === "spring" || d.name === "backgroundColor" || !isWaapiSupportedEasing(d.ease)
}
function pregenerateKeyframes(d, o) {
    const c = new MainThreadAnimation({
        ...o,
        keyframes: d,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let h = {
        done: !1,
        value: d[0]
    };
    const _ = [];
    let b = 0;
    for (; !h.done && b < maxDuration; )
        h = c.sample(b),
        _.push(h.value),
        b += sampleDelta;
    return {
        times: void 0,
        keyframes: _,
        duration: b - sampleDelta,
        ease: "linear"
    }
}
class AcceleratedAnimation extends BaseAnimation {
    constructor(o) {
        super(o);
        const {name: c, motionValue: h, keyframes: _} = this.options;
        this.resolver = new DOMKeyframesResolver(_, (b, _e) => this.onKeyframesResolved(b, _e),c,h),
        this.resolver.scheduleResolve()
    }
    initPlayback(o, c) {
        var h;
        let {duration: _=300, times: b, ease: _e, type: nt, motionValue: it, name: at} = this.options;
        if (!(!((h = it.owner) === null || h === void 0) && h.current))
            return !1;
        if (requiresPregeneratedKeyframes(this.options)) {
            const {onComplete: pt, onUpdate: ht, motionValue: _t, ...vt} = this.options
              , bt = pregenerateKeyframes(o, vt);
            o = bt.keyframes,
            o.length === 1 && (o[1] = o[0]),
            _ = bt.duration,
            b = bt.times,
            _e = bt.ease,
            nt = "keyframes"
        }
        const ut = animateStyle(it.owner.current, at, o, {
            ...this.options,
            duration: _,
            times: b,
            ease: _e
        });
        return ut.startTime = time.now(),
        this.pendingTimeline ? (ut.timeline = this.pendingTimeline,
        this.pendingTimeline = void 0) : ut.onfinish = () => {
            const {onComplete: pt} = this.options;
            it.set(getFinalKeyframe(o, this.options, c)),
            pt && pt(),
            this.cancel(),
            this.resolveFinishedPromise()
        }
        ,
        {
            animation: ut,
            duration: _,
            times: b,
            type: nt,
            ease: _e,
            keyframes: o
        }
    }
    get duration() {
        const {resolved: o} = this;
        if (!o)
            return 0;
        const {duration: c} = o;
        return millisecondsToSeconds(c)
    }
    get time() {
        const {resolved: o} = this;
        if (!o)
            return 0;
        const {animation: c} = o;
        return millisecondsToSeconds(c.currentTime || 0)
    }
    set time(o) {
        const {resolved: c} = this;
        if (!c)
            return;
        const {animation: h} = c;
        h.currentTime = secondsToMilliseconds(o)
    }
    get speed() {
        const {resolved: o} = this;
        if (!o)
            return 1;
        const {animation: c} = o;
        return c.playbackRate
    }
    set speed(o) {
        const {resolved: c} = this;
        if (!c)
            return;
        const {animation: h} = c;
        h.playbackRate = o
    }
    get state() {
        const {resolved: o} = this;
        if (!o)
            return "idle";
        const {animation: c} = o;
        return c.playState
    }
    attachTimeline(o) {
        if (!this._resolved)
            this.pendingTimeline = o;
        else {
            const {resolved: c} = this;
            if (!c)
                return noop;
            const {animation: h} = c;
            h.timeline = o,
            h.onfinish = null
        }
        return noop
    }
    play() {
        if (this.isStopped)
            return;
        const {resolved: o} = this;
        if (!o)
            return;
        const {animation: c} = o;
        c.playState === "finished" && this.updateFinishedPromise(),
        c.play()
    }
    pause() {
        const {resolved: o} = this;
        if (!o)
            return;
        const {animation: c} = o;
        c.pause()
    }
    stop() {
        if (this.resolver.cancel(),
        this.isStopped = !0,
        this.state === "idle")
            return;
        const {resolved: o} = this;
        if (!o)
            return;
        const {animation: c, keyframes: h, duration: _, type: b, ease: _e, times: nt} = o;
        if (!(c.playState === "idle" || c.playState === "finished")) {
            if (this.time) {
                const {motionValue: it, onUpdate: at, onComplete: ut, ...pt} = this.options
                  , ht = new MainThreadAnimation({
                    ...pt,
                    keyframes: h,
                    duration: _,
                    type: b,
                    ease: _e,
                    times: nt,
                    isGenerator: !0
                })
                  , _t = secondsToMilliseconds(this.time);
                it.setWithVelocity(ht.sample(_t - sampleDelta).value, ht.sample(_t).value, sampleDelta)
            }
            this.cancel()
        }
    }
    complete() {
        const {resolved: o} = this;
        o && o.animation.finish()
    }
    cancel() {
        const {resolved: o} = this;
        o && o.animation.cancel()
    }
    static supports(o) {
        const {motionValue: c, name: h, repeatDelay: _, repeatType: b, damping: _e, type: nt} = o;
        return supportsWaapi() && h && acceleratedValues.has(h) && c && c.owner && c.owner.current instanceof HTMLElement && !c.owner.getProps().onUpdate && !_ && b !== "mirror" && _e !== 0 && nt !== "inertia"
    }
}
const animateMotionValue = (d, o, c, h={}, _, b) => _e => {
    const nt = getValueTransition(h, d) || {}
      , it = nt.delay || h.delay || 0;
    let {elapsed: at=0} = h;
    at = at - secondsToMilliseconds(it);
    let ut = {
        keyframes: Array.isArray(c) ? c : [null, c],
        ease: "easeOut",
        velocity: o.getVelocity(),
        ...nt,
        delay: -at,
        onUpdate: ht => {
            o.set(ht),
            nt.onUpdate && nt.onUpdate(ht)
        }
        ,
        onComplete: () => {
            _e(),
            nt.onComplete && nt.onComplete()
        }
        ,
        name: d,
        motionValue: o,
        element: b ? void 0 : _
    };
    isTransitionDefined(nt) || (ut = {
        ...ut,
        ...getDefaultTransition(d, ut)
    }),
    ut.duration && (ut.duration = secondsToMilliseconds(ut.duration)),
    ut.repeatDelay && (ut.repeatDelay = secondsToMilliseconds(ut.repeatDelay)),
    ut.from !== void 0 && (ut.keyframes[0] = ut.from);
    let pt = !1;
    if ((ut.type === !1 || ut.duration === 0 && !ut.repeatDelay) && (ut.duration = 0,
    ut.delay === 0 && (pt = !0)),
    pt && !b && o.get() !== void 0) {
        const ht = getFinalKeyframe(ut.keyframes, nt);
        if (ht !== void 0) {
            frame.update( () => {
                ut.onUpdate(ht),
                ut.onComplete()
            }
            );
            return
        }
    }
    return !b && AcceleratedAnimation.supports(ut) ? new AcceleratedAnimation(ut) : new MainThreadAnimation(ut)
}
;
function isWillChangeMotionValue(d) {
    return !!(isMotionValue(d) && d.add)
}
function addUniqueItem(d, o) {
    d.indexOf(o) === -1 && d.push(o)
}
function removeItem(d, o) {
    const c = d.indexOf(o);
    c > -1 && d.splice(c, 1)
}
class SubscriptionManager {
    constructor() {
        this.subscriptions = []
    }
    add(o) {
        return addUniqueItem(this.subscriptions, o),
        () => removeItem(this.subscriptions, o)
    }
    notify(o, c, h) {
        const _ = this.subscriptions.length;
        if (_)
            if (_ === 1)
                this.subscriptions[0](o, c, h);
            else
                for (let b = 0; b < _; b++) {
                    const _e = this.subscriptions[b];
                    _e && _e(o, c, h)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const MAX_VELOCITY_DELTA = 30
  , isFloat = d => !isNaN(parseFloat(d))
  , collectMotionValues = {
    current: void 0
};
class MotionValue {
    constructor(o, c={}) {
        this.version = "11.1.9",
        this.canTrackVelocity = !1,
        this.events = {},
        this.updateAndNotify = (h, _=!0) => {
            const b = time.now();
            this.updatedAt !== b && this.setPrevFrameValue(),
            this.prev = this.current,
            this.setCurrent(h),
            this.current !== this.prev && this.events.change && this.events.change.notify(this.current),
            _ && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }
        ,
        this.hasAnimated = !1,
        this.setCurrent(o),
        this.canTrackVelocity = isFloat(this.current),
        this.owner = c.owner
    }
    setCurrent(o) {
        this.current = o,
        this.updatedAt = time.now()
    }
    setPrevFrameValue(o=this.current) {
        this.prevFrameValue = o,
        this.prevUpdatedAt = this.updatedAt
    }
    onChange(o) {
        return this.on("change", o)
    }
    on(o, c) {
        this.events[o] || (this.events[o] = new SubscriptionManager);
        const h = this.events[o].add(c);
        return o === "change" ? () => {
            h(),
            frame.read( () => {
                this.events.change.getSize() || this.stop()
            }
            )
        }
        : h
    }
    clearListeners() {
        for (const o in this.events)
            this.events[o].clear()
    }
    attach(o, c) {
        this.passiveEffect = o,
        this.stopPassiveEffect = c
    }
    set(o, c=!0) {
        !c || !this.passiveEffect ? this.updateAndNotify(o, c) : this.passiveEffect(o, this.updateAndNotify)
    }
    setWithVelocity(o, c, h) {
        this.set(c),
        this.prev = void 0,
        this.prevFrameValue = o,
        this.prevUpdatedAt = this.updatedAt - h
    }
    jump(o, c=!0) {
        this.updateAndNotify(o),
        this.prev = o,
        this.prevUpdatedAt = this.prevFrameValue = void 0,
        c && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return collectMotionValues.current && collectMotionValues.current.push(this),
        this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const o = time.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || o - this.updatedAt > MAX_VELOCITY_DELTA)
            return 0;
        const c = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
        return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), c)
    }
    start(o) {
        return this.stop(),
        new Promise(c => {
            this.hasAnimated = !0,
            this.animation = o(c),
            this.events.animationStart && this.events.animationStart.notify()
        }
        ).then( () => {
            this.events.animationComplete && this.events.animationComplete.notify(),
            this.clearAnimation()
        }
        )
    }
    stop() {
        this.animation && (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect()
    }
}
function motionValue(d, o) {
    return new MotionValue(d,o)
}
function setMotionValue(d, o, c) {
    d.hasValue(o) ? d.getValue(o).set(c) : d.addValue(o, motionValue(c))
}
function setTarget(d, o) {
    const c = resolveVariant(d, o);
    let {transitionEnd: h={}, transition: _={}, ...b} = c || {};
    b = {
        ...b,
        ...h
    };
    for (const _e in b) {
        const nt = resolveFinalValueInKeyframes(b[_e]);
        setMotionValue(d, _e, nt)
    }
}
function shouldBlockAnimation({protectedKeys: d, needsAnimating: o}, c) {
    const h = d.hasOwnProperty(c) && o[c] !== !0;
    return o[c] = !1,
    h
}
function animateTarget(d, o, {delay: c=0, transitionOverride: h, type: _}={}) {
    var b;
    let {transition: _e=d.getDefaultTransition(), transitionEnd: nt, ...it} = o;
    const at = d.getValue("willChange");
    h && (_e = h);
    const ut = []
      , pt = _ && d.animationState && d.animationState.getState()[_];
    for (const ht in it) {
        const _t = d.getValue(ht, (b = d.latestValues[ht]) !== null && b !== void 0 ? b : null)
          , vt = it[ht];
        if (vt === void 0 || pt && shouldBlockAnimation(pt, ht))
            continue;
        const bt = {
            delay: c,
            elapsed: 0,
            ...getValueTransition(_e || {}, ht)
        };
        let St = !1;
        if (window.HandoffAppearAnimations) {
            const Pt = d.getProps()[optimizedAppearDataAttribute];
            if (Pt) {
                const It = window.HandoffAppearAnimations(Pt, ht);
                It !== null && (bt.elapsed = It,
                St = !0)
            }
        }
        _t.start(animateMotionValue(ht, _t, vt, d.shouldReduceMotion && transformProps.has(ht) ? {
            type: !1
        } : bt, d, St));
        const At = _t.animation;
        At && (isWillChangeMotionValue(at) && (at.add(ht),
        At.then( () => at.remove(ht))),
        ut.push(At))
    }
    return nt && Promise.all(ut).then( () => {
        frame.update( () => {
            nt && setTarget(d, nt)
        }
        )
    }
    ),
    ut
}
function animateVariant(d, o, c={}) {
    var h;
    const _ = resolveVariant(d, o, c.type === "exit" ? (h = d.presenceContext) === null || h === void 0 ? void 0 : h.custom : void 0);
    let {transition: b=d.getDefaultTransition() || {}} = _ || {};
    c.transitionOverride && (b = c.transitionOverride);
    const _e = _ ? () => Promise.all(animateTarget(d, _, c)) : () => Promise.resolve()
      , nt = d.variantChildren && d.variantChildren.size ? (at=0) => {
        const {delayChildren: ut=0, staggerChildren: pt, staggerDirection: ht} = b;
        return animateChildren(d, o, ut + at, pt, ht, c)
    }
    : () => Promise.resolve()
      , {when: it} = b;
    if (it) {
        const [at,ut] = it === "beforeChildren" ? [_e, nt] : [nt, _e];
        return at().then( () => ut())
    } else
        return Promise.all([_e(), nt(c.delay)])
}
function animateChildren(d, o, c=0, h=0, _=1, b) {
    const _e = []
      , nt = (d.variantChildren.size - 1) * h
      , it = _ === 1 ? (at=0) => at * h : (at=0) => nt - at * h;
    return Array.from(d.variantChildren).sort(sortByTreeOrder).forEach( (at, ut) => {
        at.notify("AnimationStart", o),
        _e.push(animateVariant(at, o, {
            ...b,
            delay: c + it(ut)
        }).then( () => at.notify("AnimationComplete", o)))
    }
    ),
    Promise.all(_e)
}
function sortByTreeOrder(d, o) {
    return d.sortNodePosition(o)
}
function animateVisualElement(d, o, c={}) {
    d.notify("AnimationStart", o);
    let h;
    if (Array.isArray(o)) {
        const _ = o.map(b => animateVariant(d, b, c));
        h = Promise.all(_)
    } else if (typeof o == "string")
        h = animateVariant(d, o, c);
    else {
        const _ = typeof o == "function" ? resolveVariant(d, o, c.custom) : o;
        h = Promise.all(animateTarget(d, _, c))
    }
    return h.then( () => {
        frame.postRender( () => {
            d.notify("AnimationComplete", o)
        }
        )
    }
    )
}
const reversePriorityOrder = [...variantPriorityOrder].reverse()
  , numAnimationTypes = variantPriorityOrder.length;
function animateList(d) {
    return o => Promise.all(o.map( ({animation: c, options: h}) => animateVisualElement(d, c, h)))
}
function createAnimationState(d) {
    let o = animateList(d);
    const c = createState();
    let h = !0;
    const _ = it => (at, ut) => {
        var pt;
        const ht = resolveVariant(d, ut, it === "exit" ? (pt = d.presenceContext) === null || pt === void 0 ? void 0 : pt.custom : void 0);
        if (ht) {
            const {transition: _t, transitionEnd: vt, ...bt} = ht;
            at = {
                ...at,
                ...bt,
                ...vt
            }
        }
        return at
    }
    ;
    function b(it) {
        o = it(d)
    }
    function _e(it) {
        const at = d.getProps()
          , ut = d.getVariantContext(!0) || {}
          , pt = []
          , ht = new Set;
        let _t = {}
          , vt = 1 / 0;
        for (let St = 0; St < numAnimationTypes; St++) {
            const At = reversePriorityOrder[St]
              , Et = c[At]
              , Pt = at[At] !== void 0 ? at[At] : ut[At]
              , It = isVariantLabel(Pt)
              , Dt = At === it ? Et.isActive : null;
            Dt === !1 && (vt = St);
            let Gt = Pt === ut[At] && Pt !== at[At] && It;
            if (Gt && h && d.manuallyAnimateOnMount && (Gt = !1),
            Et.protectedKeys = {
                ..._t
            },
            !Et.isActive && Dt === null || !Pt && !Et.prevProp || isAnimationControls(Pt) || typeof Pt == "boolean")
                continue;
            let kt = checkVariantsDidChange(Et.prevProp, Pt) || At === it && Et.isActive && !Gt && It || St > vt && It
              , Ut = !1;
            const Ht = Array.isArray(Pt) ? Pt : [Pt];
            let Kt = Ht.reduce(_(At), {});
            Dt === !1 && (Kt = {});
            const {prevResolvedValues: Jt={}} = Et
              , or = {
                ...Jt,
                ...Kt
            }
              , ir = lr => {
                kt = !0,
                ht.has(lr) && (Ut = !0,
                ht.delete(lr)),
                Et.needsAnimating[lr] = !0;
                const ar = d.getValue(lr);
                ar && (ar.liveStyle = !1)
            }
            ;
            for (const lr in or) {
                const ar = Kt[lr]
                  , hr = Jt[lr];
                if (_t.hasOwnProperty(lr))
                    continue;
                let gr = !1;
                isKeyframesTarget(ar) && isKeyframesTarget(hr) ? gr = !shallowCompare(ar, hr) : gr = ar !== hr,
                gr ? ar != null ? ir(lr) : ht.add(lr) : ar !== void 0 && ht.has(lr) ? ir(lr) : Et.protectedKeys[lr] = !0
            }
            Et.prevProp = Pt,
            Et.prevResolvedValues = Kt,
            Et.isActive && (_t = {
                ..._t,
                ...Kt
            }),
            h && d.blockInitialAnimation && (kt = !1),
            kt && (!Gt || Ut) && pt.push(...Ht.map(lr => ({
                animation: lr,
                options: {
                    type: At
                }
            })))
        }
        if (ht.size) {
            const St = {};
            ht.forEach(At => {
                const Et = d.getBaseTarget(At)
                  , Pt = d.getValue(At);
                Pt && (Pt.liveStyle = !0),
                St[At] = Et ?? null
            }
            ),
            pt.push({
                animation: St
            })
        }
        let bt = !!pt.length;
        return h && (at.initial === !1 || at.initial === at.animate) && !d.manuallyAnimateOnMount && (bt = !1),
        h = !1,
        bt ? o(pt) : Promise.resolve()
    }
    function nt(it, at) {
        var ut;
        if (c[it].isActive === at)
            return Promise.resolve();
        (ut = d.variantChildren) === null || ut === void 0 || ut.forEach(ht => {
            var _t;
            return (_t = ht.animationState) === null || _t === void 0 ? void 0 : _t.setActive(it, at)
        }
        ),
        c[it].isActive = at;
        const pt = _e(it);
        for (const ht in c)
            c[ht].protectedKeys = {};
        return pt
    }
    return {
        animateChanges: _e,
        setActive: nt,
        setAnimateFunction: b,
        getState: () => c
    }
}
function checkVariantsDidChange(d, o) {
    return typeof o == "string" ? o !== d : Array.isArray(o) ? !shallowCompare(o, d) : !1
}
function createTypeState(d=!1) {
    return {
        isActive: d,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}
function createState() {
    return {
        animate: createTypeState(!0),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
    }
}
class AnimationFeature extends Feature {
    constructor(o) {
        super(o),
        o.animationState || (o.animationState = createAnimationState(o))
    }
    updateAnimationControlsSubscription() {
        const {animate: o} = this.node.getProps();
        this.unmount(),
        isAnimationControls(o) && (this.unmount = o.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {animate: o} = this.node.getProps()
          , {animate: c} = this.node.prevProps || {};
        o !== c && this.updateAnimationControlsSubscription()
    }
    unmount() {}
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
    constructor() {
        super(...arguments),
        this.id = id$1++
    }
    update() {
        if (!this.node.presenceContext)
            return;
        const {isPresent: o, onExitComplete: c} = this.node.presenceContext
          , {isPresent: h} = this.node.prevPresenceContext || {};
        if (!this.node.animationState || o === h)
            return;
        const _ = this.node.animationState.setActive("exit", !o);
        c && !o && _.then( () => c(this.id))
    }
    mount() {
        const {register: o} = this.node.presenceContext || {};
        o && (this.unmount = o(this.id))
    }
    unmount() {}
}
const animations = {
    animation: {
        Feature: AnimationFeature
    },
    exit: {
        Feature: ExitAnimationFeature
    }
}
  , distance = (d, o) => Math.abs(d - o);
function distance2D(d, o) {
    const c = distance(d.x, o.x)
      , h = distance(d.y, o.y);
    return Math.sqrt(c ** 2 + h ** 2)
}
class PanSession {
    constructor(o, c, {transformPagePoint: h, contextWindow: _, dragSnapToOrigin: b=!1}={}) {
        if (this.startEvent = null,
        this.lastMoveEvent = null,
        this.lastMoveEventInfo = null,
        this.handlers = {},
        this.contextWindow = window,
        this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const pt = getPanInfo(this.lastMoveEventInfo, this.history)
              , ht = this.startEvent !== null
              , _t = distance2D(pt.offset, {
                x: 0,
                y: 0
            }) >= 3;
            if (!ht && !_t)
                return;
            const {point: vt} = pt
              , {timestamp: bt} = frameData;
            this.history.push({
                ...vt,
                timestamp: bt
            });
            const {onStart: St, onMove: At} = this.handlers;
            ht || (St && St(this.lastMoveEvent, pt),
            this.startEvent = this.lastMoveEvent),
            At && At(this.lastMoveEvent, pt)
        }
        ,
        this.handlePointerMove = (pt, ht) => {
            this.lastMoveEvent = pt,
            this.lastMoveEventInfo = transformPoint(ht, this.transformPagePoint),
            frame.update(this.updatePoint, !0)
        }
        ,
        this.handlePointerUp = (pt, ht) => {
            this.end();
            const {onEnd: _t, onSessionEnd: vt, resumeAnimation: bt} = this.handlers;
            if (this.dragSnapToOrigin && bt && bt(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
                return;
            const St = getPanInfo(pt.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(ht, this.transformPagePoint), this.history);
            this.startEvent && _t && _t(pt, St),
            vt && vt(pt, St)
        }
        ,
        !isPrimaryPointer(o))
            return;
        this.dragSnapToOrigin = b,
        this.handlers = c,
        this.transformPagePoint = h,
        this.contextWindow = _ || window;
        const _e = extractEventInfo(o)
          , nt = transformPoint(_e, this.transformPagePoint)
          , {point: it} = nt
          , {timestamp: at} = frameData;
        this.history = [{
            ...it,
            timestamp: at
        }];
        const {onSessionStart: ut} = c;
        ut && ut(o, getPanInfo(nt, this.history)),
        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(o) {
        this.handlers = o
    }
    end() {
        this.removeListeners && this.removeListeners(),
        cancelFrame(this.updatePoint)
    }
}
function transformPoint(d, o) {
    return o ? {
        point: o(d.point)
    } : d
}
function subtractPoint(d, o) {
    return {
        x: d.x - o.x,
        y: d.y - o.y
    }
}
function getPanInfo({point: d}, o) {
    return {
        point: d,
        delta: subtractPoint(d, lastDevicePoint(o)),
        offset: subtractPoint(d, startDevicePoint(o)),
        velocity: getVelocity(o, .1)
    }
}
function startDevicePoint(d) {
    return d[0]
}
function lastDevicePoint(d) {
    return d[d.length - 1]
}
function getVelocity(d, o) {
    if (d.length < 2)
        return {
            x: 0,
            y: 0
        };
    let c = d.length - 1
      , h = null;
    const _ = lastDevicePoint(d);
    for (; c >= 0 && (h = d[c],
    !(_.timestamp - h.timestamp > secondsToMilliseconds(o))); )
        c--;
    if (!h)
        return {
            x: 0,
            y: 0
        };
    const b = millisecondsToSeconds(_.timestamp - h.timestamp);
    if (b === 0)
        return {
            x: 0,
            y: 0
        };
    const _e = {
        x: (_.x - h.x) / b,
        y: (_.y - h.y) / b
    };
    return _e.x === 1 / 0 && (_e.x = 0),
    _e.y === 1 / 0 && (_e.y = 0),
    _e
}
function calcLength(d) {
    return d.max - d.min
}
function isNear(d, o=0, c=.01) {
    return Math.abs(d - o) <= c
}
function calcAxisDelta(d, o, c, h=.5) {
    d.origin = h,
    d.originPoint = mixNumber$1(o.min, o.max, d.origin),
    d.scale = calcLength(c) / calcLength(o),
    (isNear(d.scale, 1, 1e-4) || isNaN(d.scale)) && (d.scale = 1),
    d.translate = mixNumber$1(c.min, c.max, d.origin) - d.originPoint,
    (isNear(d.translate) || isNaN(d.translate)) && (d.translate = 0)
}
function calcBoxDelta(d, o, c, h) {
    calcAxisDelta(d.x, o.x, c.x, h ? h.originX : void 0),
    calcAxisDelta(d.y, o.y, c.y, h ? h.originY : void 0)
}
function calcRelativeAxis(d, o, c) {
    d.min = c.min + o.min,
    d.max = d.min + calcLength(o)
}
function calcRelativeBox(d, o, c) {
    calcRelativeAxis(d.x, o.x, c.x),
    calcRelativeAxis(d.y, o.y, c.y)
}
function calcRelativeAxisPosition(d, o, c) {
    d.min = o.min - c.min,
    d.max = d.min + calcLength(o)
}
function calcRelativePosition(d, o, c) {
    calcRelativeAxisPosition(d.x, o.x, c.x),
    calcRelativeAxisPosition(d.y, o.y, c.y)
}
function applyConstraints(d, {min: o, max: c}, h) {
    return o !== void 0 && d < o ? d = h ? mixNumber$1(o, d, h.min) : Math.max(d, o) : c !== void 0 && d > c && (d = h ? mixNumber$1(c, d, h.max) : Math.min(d, c)),
    d
}
function calcRelativeAxisConstraints(d, o, c) {
    return {
        min: o !== void 0 ? d.min + o : void 0,
        max: c !== void 0 ? d.max + c - (d.max - d.min) : void 0
    }
}
function calcRelativeConstraints(d, {top: o, left: c, bottom: h, right: _}) {
    return {
        x: calcRelativeAxisConstraints(d.x, c, _),
        y: calcRelativeAxisConstraints(d.y, o, h)
    }
}
function calcViewportAxisConstraints(d, o) {
    let c = o.min - d.min
      , h = o.max - d.max;
    return o.max - o.min < d.max - d.min && ([c,h] = [h, c]),
    {
        min: c,
        max: h
    }
}
function calcViewportConstraints(d, o) {
    return {
        x: calcViewportAxisConstraints(d.x, o.x),
        y: calcViewportAxisConstraints(d.y, o.y)
    }
}
function calcOrigin(d, o) {
    let c = .5;
    const h = calcLength(d)
      , _ = calcLength(o);
    return _ > h ? c = progress(o.min, o.max - h, d.min) : h > _ && (c = progress(d.min, d.max - _, o.min)),
    clamp(0, 1, c)
}
function rebaseAxisConstraints(d, o) {
    const c = {};
    return o.min !== void 0 && (c.min = o.min - d.min),
    o.max !== void 0 && (c.max = o.max - d.min),
    c
}
const defaultElastic = .35;
function resolveDragElastic(d=defaultElastic) {
    return d === !1 ? d = 0 : d === !0 && (d = defaultElastic),
    {
        x: resolveAxisElastic(d, "left", "right"),
        y: resolveAxisElastic(d, "top", "bottom")
    }
}
function resolveAxisElastic(d, o, c) {
    return {
        min: resolvePointElastic(d, o),
        max: resolvePointElastic(d, c)
    }
}
function resolvePointElastic(d, o) {
    return typeof d == "number" ? d : d[o] || 0
}
const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
})
  , createDelta = () => ({
    x: createAxisDelta(),
    y: createAxisDelta()
})
  , createAxis = () => ({
    min: 0,
    max: 0
})
  , createBox = () => ({
    x: createAxis(),
    y: createAxis()
});
function eachAxis(d) {
    return [d("x"), d("y")]
}
function convertBoundingBoxToBox({top: d, left: o, right: c, bottom: h}) {
    return {
        x: {
            min: o,
            max: c
        },
        y: {
            min: d,
            max: h
        }
    }
}
function convertBoxToBoundingBox({x: d, y: o}) {
    return {
        top: o.min,
        right: d.max,
        bottom: o.max,
        left: d.min
    }
}
function transformBoxPoints(d, o) {
    if (!o)
        return d;
    const c = o({
        x: d.left,
        y: d.top
    })
      , h = o({
        x: d.right,
        y: d.bottom
    });
    return {
        top: c.y,
        left: c.x,
        bottom: h.y,
        right: h.x
    }
}
function isIdentityScale(d) {
    return d === void 0 || d === 1
}
function hasScale({scale: d, scaleX: o, scaleY: c}) {
    return !isIdentityScale(d) || !isIdentityScale(o) || !isIdentityScale(c)
}
function hasTransform(d) {
    return hasScale(d) || has2DTranslate(d) || d.z || d.rotate || d.rotateX || d.rotateY || d.skewX || d.skewY
}
function has2DTranslate(d) {
    return is2DTranslate(d.x) || is2DTranslate(d.y)
}
function is2DTranslate(d) {
    return d && d !== "0%"
}
function scalePoint(d, o, c) {
    const h = d - c
      , _ = o * h;
    return c + _
}
function applyPointDelta(d, o, c, h, _) {
    return _ !== void 0 && (d = scalePoint(d, _, h)),
    scalePoint(d, c, h) + o
}
function applyAxisDelta(d, o=0, c=1, h, _) {
    d.min = applyPointDelta(d.min, o, c, h, _),
    d.max = applyPointDelta(d.max, o, c, h, _)
}
function applyBoxDelta(d, {x: o, y: c}) {
    applyAxisDelta(d.x, o.translate, o.scale, o.originPoint),
    applyAxisDelta(d.y, c.translate, c.scale, c.originPoint)
}
function applyTreeDeltas(d, o, c, h=!1) {
    const _ = c.length;
    if (!_)
        return;
    o.x = o.y = 1;
    let b, _e;
    for (let nt = 0; nt < _; nt++) {
        b = c[nt],
        _e = b.projectionDelta;
        const it = b.instance;
        it && it.style && it.style.display === "contents" || (h && b.options.layoutScroll && b.scroll && b !== b.root && transformBox(d, {
            x: -b.scroll.offset.x,
            y: -b.scroll.offset.y
        }),
        _e && (o.x *= _e.x.scale,
        o.y *= _e.y.scale,
        applyBoxDelta(d, _e)),
        h && hasTransform(b.latestValues) && transformBox(d, b.latestValues))
    }
    o.x = snapToDefault(o.x),
    o.y = snapToDefault(o.y)
}
function snapToDefault(d) {
    return Number.isInteger(d) || d > 1.0000000000001 || d < .999999999999 ? d : 1
}
function translateAxis(d, o) {
    d.min = d.min + o,
    d.max = d.max + o
}
function transformAxis(d, o, [c,h,_]) {
    const b = o[_] !== void 0 ? o[_] : .5
      , _e = mixNumber$1(d.min, d.max, b);
    applyAxisDelta(d, o[c], o[h], _e, o.scale)
}
const xKeys$1 = ["x", "scaleX", "originX"]
  , yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(d, o) {
    transformAxis(d.x, o, xKeys$1),
    transformAxis(d.y, o, yKeys$1)
}
function measureViewportBox(d, o) {
    return convertBoundingBoxToBox(transformBoxPoints(d.getBoundingClientRect(), o))
}
function measurePageBox(d, o, c) {
    const h = measureViewportBox(d, c)
      , {scroll: _} = o;
    return _ && (translateAxis(h.x, _.offset.x),
    translateAxis(h.y, _.offset.y)),
    h
}
const getContextWindow = ({current: d}) => d ? d.ownerDocument.defaultView : null
  , elementDragControls = new WeakMap;
class VisualElementDragControls {
    constructor(o) {
        this.openGlobalLock = null,
        this.isDragging = !1,
        this.currentDirection = null,
        this.originPoint = {
            x: 0,
            y: 0
        },
        this.constraints = !1,
        this.hasMutatedConstraints = !1,
        this.elastic = createBox(),
        this.visualElement = o
    }
    start(o, {snapToCursor: c=!1}={}) {
        const {presenceContext: h} = this.visualElement;
        if (h && h.isPresent === !1)
            return;
        const _ = ut => {
            const {dragSnapToOrigin: pt} = this.getProps();
            pt ? this.pauseAnimation() : this.stopAnimation(),
            c && this.snapToCursor(extractEventInfo(ut, "page").point)
        }
          , b = (ut, pt) => {
            const {drag: ht, dragPropagation: _t, onDragStart: vt} = this.getProps();
            if (ht && !_t && (this.openGlobalLock && this.openGlobalLock(),
            this.openGlobalLock = getGlobalLock(ht),
            !this.openGlobalLock))
                return;
            this.isDragging = !0,
            this.currentDirection = null,
            this.resolveConstraints(),
            this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0,
            this.visualElement.projection.target = void 0),
            eachAxis(St => {
                let At = this.getAxisMotionValue(St).get() || 0;
                if (percent.test(At)) {
                    const {projection: Et} = this.visualElement;
                    if (Et && Et.layout) {
                        const Pt = Et.layout.layoutBox[St];
                        Pt && (At = calcLength(Pt) * (parseFloat(At) / 100))
                    }
                }
                this.originPoint[St] = At
            }
            ),
            vt && frame.postRender( () => vt(ut, pt));
            const {animationState: bt} = this.visualElement;
            bt && bt.setActive("whileDrag", !0)
        }
          , _e = (ut, pt) => {
            const {dragPropagation: ht, dragDirectionLock: _t, onDirectionLock: vt, onDrag: bt} = this.getProps();
            if (!ht && !this.openGlobalLock)
                return;
            const {offset: St} = pt;
            if (_t && this.currentDirection === null) {
                this.currentDirection = getCurrentDirection(St),
                this.currentDirection !== null && vt && vt(this.currentDirection);
                return
            }
            this.updateAxis("x", pt.point, St),
            this.updateAxis("y", pt.point, St),
            this.visualElement.render(),
            bt && bt(ut, pt)
        }
          , nt = (ut, pt) => this.stop(ut, pt)
          , it = () => eachAxis(ut => {
            var pt;
            return this.getAnimationState(ut) === "paused" && ((pt = this.getAxisMotionValue(ut).animation) === null || pt === void 0 ? void 0 : pt.play())
        }
        )
          , {dragSnapToOrigin: at} = this.getProps();
        this.panSession = new PanSession(o,{
            onSessionStart: _,
            onStart: b,
            onMove: _e,
            onSessionEnd: nt,
            resumeAnimation: it
        },{
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: at,
            contextWindow: getContextWindow(this.visualElement)
        })
    }
    stop(o, c) {
        const h = this.isDragging;
        if (this.cancel(),
        !h)
            return;
        const {velocity: _} = c;
        this.startAnimation(_);
        const {onDragEnd: b} = this.getProps();
        b && frame.postRender( () => b(o, c))
    }
    cancel() {
        this.isDragging = !1;
        const {projection: o, animationState: c} = this.visualElement;
        o && (o.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        this.panSession = void 0;
        const {dragPropagation: h} = this.getProps();
        !h && this.openGlobalLock && (this.openGlobalLock(),
        this.openGlobalLock = null),
        c && c.setActive("whileDrag", !1)
    }
    updateAxis(o, c, h) {
        const {drag: _} = this.getProps();
        if (!h || !shouldDrag(o, _, this.currentDirection))
            return;
        const b = this.getAxisMotionValue(o);
        let _e = this.originPoint[o] + h[o];
        this.constraints && this.constraints[o] && (_e = applyConstraints(_e, this.constraints[o], this.elastic[o])),
        b.set(_e)
    }
    resolveConstraints() {
        var o;
        const {dragConstraints: c, dragElastic: h} = this.getProps()
          , _ = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (o = this.visualElement.projection) === null || o === void 0 ? void 0 : o.layout
          , b = this.constraints;
        c && isRefObject(c) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : c && _ ? this.constraints = calcRelativeConstraints(_.layoutBox, c) : this.constraints = !1,
        this.elastic = resolveDragElastic(h),
        b !== this.constraints && _ && this.constraints && !this.hasMutatedConstraints && eachAxis(_e => {
            this.constraints !== !1 && this.getAxisMotionValue(_e) && (this.constraints[_e] = rebaseAxisConstraints(_.layoutBox[_e], this.constraints[_e]))
        }
        )
    }
    resolveRefConstraints() {
        const {dragConstraints: o, onMeasureDragConstraints: c} = this.getProps();
        if (!o || !isRefObject(o))
            return !1;
        const h = o.current
          , {projection: _} = this.visualElement;
        if (!_ || !_.layout)
            return !1;
        const b = measurePageBox(h, _.root, this.visualElement.getTransformPagePoint());
        let _e = calcViewportConstraints(_.layout.layoutBox, b);
        if (c) {
            const nt = c(convertBoxToBoundingBox(_e));
            this.hasMutatedConstraints = !!nt,
            nt && (_e = convertBoundingBoxToBox(nt))
        }
        return _e
    }
    startAnimation(o) {
        const {drag: c, dragMomentum: h, dragElastic: _, dragTransition: b, dragSnapToOrigin: _e, onDragTransitionEnd: nt} = this.getProps()
          , it = this.constraints || {}
          , at = eachAxis(ut => {
            if (!shouldDrag(ut, c, this.currentDirection))
                return;
            let pt = it && it[ut] || {};
            _e && (pt = {
                min: 0,
                max: 0
            });
            const ht = _ ? 200 : 1e6
              , _t = _ ? 40 : 1e7
              , vt = {
                type: "inertia",
                velocity: h ? o[ut] : 0,
                bounceStiffness: ht,
                bounceDamping: _t,
                timeConstant: 750,
                restDelta: 1,
                restSpeed: 10,
                ...b,
                ...pt
            };
            return this.startAxisValueAnimation(ut, vt)
        }
        );
        return Promise.all(at).then(nt)
    }
    startAxisValueAnimation(o, c) {
        const h = this.getAxisMotionValue(o);
        return h.start(animateMotionValue(o, h, 0, c, this.visualElement))
    }
    stopAnimation() {
        eachAxis(o => this.getAxisMotionValue(o).stop())
    }
    pauseAnimation() {
        eachAxis(o => {
            var c;
            return (c = this.getAxisMotionValue(o).animation) === null || c === void 0 ? void 0 : c.pause()
        }
        )
    }
    getAnimationState(o) {
        var c;
        return (c = this.getAxisMotionValue(o).animation) === null || c === void 0 ? void 0 : c.state
    }
    getAxisMotionValue(o) {
        const c = `_drag${o.toUpperCase()}`
          , h = this.visualElement.getProps()
          , _ = h[c];
        return _ || this.visualElement.getValue(o, (h.initial ? h.initial[o] : void 0) || 0)
    }
    snapToCursor(o) {
        eachAxis(c => {
            const {drag: h} = this.getProps();
            if (!shouldDrag(c, h, this.currentDirection))
                return;
            const {projection: _} = this.visualElement
              , b = this.getAxisMotionValue(c);
            if (_ && _.layout) {
                const {min: _e, max: nt} = _.layout.layoutBox[c];
                b.set(o[c] - mixNumber$1(_e, nt, .5))
            }
        }
        )
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current)
            return;
        const {drag: o, dragConstraints: c} = this.getProps()
          , {projection: h} = this.visualElement;
        if (!isRefObject(c) || !h || !this.constraints)
            return;
        this.stopAnimation();
        const _ = {
            x: 0,
            y: 0
        };
        eachAxis(_e => {
            const nt = this.getAxisMotionValue(_e);
            if (nt && this.constraints !== !1) {
                const it = nt.get();
                _[_e] = calcOrigin({
                    min: it,
                    max: it
                }, this.constraints[_e])
            }
        }
        );
        const {transformTemplate: b} = this.visualElement.getProps();
        this.visualElement.current.style.transform = b ? b({}, "") : "none",
        h.root && h.root.updateScroll(),
        h.updateLayout(),
        this.resolveConstraints(),
        eachAxis(_e => {
            if (!shouldDrag(_e, o, null))
                return;
            const nt = this.getAxisMotionValue(_e)
              , {min: it, max: at} = this.constraints[_e];
            nt.set(mixNumber$1(it, at, _[_e]))
        }
        )
    }
    addListeners() {
        if (!this.visualElement.current)
            return;
        elementDragControls.set(this.visualElement, this);
        const o = this.visualElement.current
          , c = addPointerEvent(o, "pointerdown", it => {
            const {drag: at, dragListener: ut=!0} = this.getProps();
            at && ut && this.start(it)
        }
        )
          , h = () => {
            const {dragConstraints: it} = this.getProps();
            isRefObject(it) && (this.constraints = this.resolveRefConstraints())
        }
          , {projection: _} = this.visualElement
          , b = _.addEventListener("measure", h);
        _ && !_.layout && (_.root && _.root.updateScroll(),
        _.updateLayout()),
        h();
        const _e = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints())
          , nt = _.addEventListener("didUpdate", ({delta: it, hasLayoutChanged: at}) => {
            this.isDragging && at && (eachAxis(ut => {
                const pt = this.getAxisMotionValue(ut);
                pt && (this.originPoint[ut] += it[ut].translate,
                pt.set(pt.get() + it[ut].translate))
            }
            ),
            this.visualElement.render())
        }
        );
        return () => {
            _e(),
            c(),
            b(),
            nt && nt()
        }
    }
    getProps() {
        const o = this.visualElement.getProps()
          , {drag: c=!1, dragDirectionLock: h=!1, dragPropagation: _=!1, dragConstraints: b=!1, dragElastic: _e=defaultElastic, dragMomentum: nt=!0} = o;
        return {
            ...o,
            drag: c,
            dragDirectionLock: h,
            dragPropagation: _,
            dragConstraints: b,
            dragElastic: _e,
            dragMomentum: nt
        }
    }
}
function shouldDrag(d, o, c) {
    return (o === !0 || o === d) && (c === null || c === d)
}
function getCurrentDirection(d, o=10) {
    let c = null;
    return Math.abs(d.y) > o ? c = "y" : Math.abs(d.x) > o && (c = "x"),
    c
}
class DragGesture extends Feature {
    constructor(o) {
        super(o),
        this.removeGroupControls = noop,
        this.removeListeners = noop,
        this.controls = new VisualElementDragControls(o)
    }
    mount() {
        const {dragControls: o} = this.node.getProps();
        o && (this.removeGroupControls = o.subscribe(this.controls)),
        this.removeListeners = this.controls.addListeners() || noop
    }
    unmount() {
        this.removeGroupControls(),
        this.removeListeners()
    }
}
const asyncHandler = d => (o, c) => {
    d && frame.postRender( () => d(o, c))
}
;
class PanGesture extends Feature {
    constructor() {
        super(...arguments),
        this.removePointerDownListener = noop
    }
    onPointerDown(o) {
        this.session = new PanSession(o,this.createPanHandlers(),{
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: getContextWindow(this.node)
        })
    }
    createPanHandlers() {
        const {onPanSessionStart: o, onPanStart: c, onPan: h, onPanEnd: _} = this.node.getProps();
        return {
            onSessionStart: asyncHandler(o),
            onStart: asyncHandler(c),
            onMove: h,
            onEnd: (b, _e) => {
                delete this.session,
                _ && frame.postRender( () => _(b, _e))
            }
        }
    }
    mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", o => this.onPointerDown(o))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(),
        this.session && this.session.end()
    }
}
function usePresence() {
    const d = reactExports.useContext(PresenceContext);
    if (d === null)
        return [!0, null];
    const {isPresent: o, onExitComplete: c, register: h} = d
      , _ = reactExports.useId();
    return reactExports.useEffect( () => h(_), []),
    !o && c ? [!1, () => c && c(_)] : [!0]
}
const globalProjectionState = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1
};
function pixelsToPercent(d, o) {
    return o.max === o.min ? 0 : d / (o.max - o.min) * 100
}
const correctBorderRadius = {
    correct: (d, o) => {
        if (!o.target)
            return d;
        if (typeof d == "string")
            if (px.test(d))
                d = parseFloat(d);
            else
                return d;
        const c = pixelsToPercent(d, o.target.x)
          , h = pixelsToPercent(d, o.target.y);
        return `${c}% ${h}%`
    }
}
  , correctBoxShadow = {
    correct: (d, {treeScale: o, projectionDelta: c}) => {
        const h = d
          , _ = complex.parse(d);
        if (_.length > 5)
            return h;
        const b = complex.createTransformer(d)
          , _e = typeof _[0] != "number" ? 1 : 0
          , nt = c.x.scale * o.x
          , it = c.y.scale * o.y;
        _[0 + _e] /= nt,
        _[1 + _e] /= it;
        const at = mixNumber$1(nt, it, .5);
        return typeof _[2 + _e] == "number" && (_[2 + _e] /= at),
        typeof _[3 + _e] == "number" && (_[3 + _e] /= at),
        b(_)
    }
};
class MeasureLayoutWithContext extends reactExports.Component {
    componentDidMount() {
        const {visualElement: o, layoutGroup: c, switchLayoutGroup: h, layoutId: _} = this.props
          , {projection: b} = o;
        addScaleCorrector(defaultScaleCorrectors),
        b && (c.group && c.group.add(b),
        h && h.register && _ && h.register(b),
        b.root.didUpdate(),
        b.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }
        ),
        b.setOptions({
            ...b.options,
            onExitComplete: () => this.safeToRemove()
        })),
        globalProjectionState.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(o) {
        const {layoutDependency: c, visualElement: h, drag: _, isPresent: b} = this.props
          , _e = h.projection;
        return _e && (_e.isPresent = b,
        _ || o.layoutDependency !== c || c === void 0 ? _e.willUpdate() : this.safeToRemove(),
        o.isPresent !== b && (b ? _e.promote() : _e.relegate() || frame.postRender( () => {
            const nt = _e.getStack();
            (!nt || !nt.members.length) && this.safeToRemove()
        }
        ))),
        null
    }
    componentDidUpdate() {
        const {projection: o} = this.props.visualElement;
        o && (o.root.didUpdate(),
        microtask.postRender( () => {
            !o.currentAnimation && o.isLead() && this.safeToRemove()
        }
        ))
    }
    componentWillUnmount() {
        const {visualElement: o, layoutGroup: c, switchLayoutGroup: h} = this.props
          , {projection: _} = o;
        _ && (_.scheduleCheckAfterUnmount(),
        c && c.group && c.group.remove(_),
        h && h.deregister && h.deregister(_))
    }
    safeToRemove() {
        const {safeToRemove: o} = this.props;
        o && o()
    }
    render() {
        return null
    }
}
function MeasureLayout(d) {
    const [o,c] = usePresence()
      , h = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
        ...d,
        layoutGroup: h,
        switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
        isPresent: o,
        safeToRemove: c
    })
}
const defaultScaleCorrectors = {
    borderRadius: {
        ...correctBorderRadius,
        applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow
}
  , borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"]
  , numBorders = borders.length
  , asNumber = d => typeof d == "string" ? parseFloat(d) : d
  , isPx = d => typeof d == "number" || px.test(d);
function mixValues(d, o, c, h, _, b) {
    _ ? (d.opacity = mixNumber$1(0, c.opacity !== void 0 ? c.opacity : 1, easeCrossfadeIn(h)),
    d.opacityExit = mixNumber$1(o.opacity !== void 0 ? o.opacity : 1, 0, easeCrossfadeOut(h))) : b && (d.opacity = mixNumber$1(o.opacity !== void 0 ? o.opacity : 1, c.opacity !== void 0 ? c.opacity : 1, h));
    for (let _e = 0; _e < numBorders; _e++) {
        const nt = `border${borders[_e]}Radius`;
        let it = getRadius(o, nt)
          , at = getRadius(c, nt);
        if (it === void 0 && at === void 0)
            continue;
        it || (it = 0),
        at || (at = 0),
        it === 0 || at === 0 || isPx(it) === isPx(at) ? (d[nt] = Math.max(mixNumber$1(asNumber(it), asNumber(at), h), 0),
        (percent.test(at) || percent.test(it)) && (d[nt] += "%")) : d[nt] = at
    }
    (o.rotate || c.rotate) && (d.rotate = mixNumber$1(o.rotate || 0, c.rotate || 0, h))
}
function getRadius(d, o) {
    return d[o] !== void 0 ? d[o] : d.borderRadius
}
const easeCrossfadeIn = compress(0, .5, circOut)
  , easeCrossfadeOut = compress(.5, .95, noop);
function compress(d, o, c) {
    return h => h < d ? 0 : h > o ? 1 : c(progress(d, o, h))
}
function copyAxisInto(d, o) {
    d.min = o.min,
    d.max = o.max
}
function copyBoxInto(d, o) {
    copyAxisInto(d.x, o.x),
    copyAxisInto(d.y, o.y)
}
function removePointDelta(d, o, c, h, _) {
    return d -= o,
    d = scalePoint(d, 1 / c, h),
    _ !== void 0 && (d = scalePoint(d, 1 / _, h)),
    d
}
function removeAxisDelta(d, o=0, c=1, h=.5, _, b=d, _e=d) {
    if (percent.test(o) && (o = parseFloat(o),
    o = mixNumber$1(_e.min, _e.max, o / 100) - _e.min),
    typeof o != "number")
        return;
    let nt = mixNumber$1(b.min, b.max, h);
    d === b && (nt -= o),
    d.min = removePointDelta(d.min, o, c, nt, _),
    d.max = removePointDelta(d.max, o, c, nt, _)
}
function removeAxisTransforms(d, o, [c,h,_], b, _e) {
    removeAxisDelta(d, o[c], o[h], o[_], o.scale, b, _e)
}
const xKeys = ["x", "scaleX", "originX"]
  , yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(d, o, c, h) {
    removeAxisTransforms(d.x, o, xKeys, c ? c.x : void 0, h ? h.x : void 0),
    removeAxisTransforms(d.y, o, yKeys, c ? c.y : void 0, h ? h.y : void 0)
}
function isAxisDeltaZero(d) {
    return d.translate === 0 && d.scale === 1
}
function isDeltaZero(d) {
    return isAxisDeltaZero(d.x) && isAxisDeltaZero(d.y)
}
function boxEquals(d, o) {
    return d.x.min === o.x.min && d.x.max === o.x.max && d.y.min === o.y.min && d.y.max === o.y.max
}
function boxEqualsRounded(d, o) {
    return Math.round(d.x.min) === Math.round(o.x.min) && Math.round(d.x.max) === Math.round(o.x.max) && Math.round(d.y.min) === Math.round(o.y.min) && Math.round(d.y.max) === Math.round(o.y.max)
}
function aspectRatio(d) {
    return calcLength(d.x) / calcLength(d.y)
}
class NodeStack {
    constructor() {
        this.members = []
    }
    add(o) {
        addUniqueItem(this.members, o),
        o.scheduleRender()
    }
    remove(o) {
        if (removeItem(this.members, o),
        o === this.prevLead && (this.prevLead = void 0),
        o === this.lead) {
            const c = this.members[this.members.length - 1];
            c && this.promote(c)
        }
    }
    relegate(o) {
        const c = this.members.findIndex(_ => o === _);
        if (c === 0)
            return !1;
        let h;
        for (let _ = c; _ >= 0; _--) {
            const b = this.members[_];
            if (b.isPresent !== !1) {
                h = b;
                break
            }
        }
        return h ? (this.promote(h),
        !0) : !1
    }
    promote(o, c) {
        const h = this.lead;
        if (o !== h && (this.prevLead = h,
        this.lead = o,
        o.show(),
        h)) {
            h.instance && h.scheduleRender(),
            o.scheduleRender(),
            o.resumeFrom = h,
            c && (o.resumeFrom.preserveOpacity = !0),
            h.snapshot && (o.snapshot = h.snapshot,
            o.snapshot.latestValues = h.animationValues || h.latestValues),
            o.root && o.root.isUpdating && (o.isLayoutDirty = !0);
            const {crossfade: _} = o.options;
            _ === !1 && h.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(o => {
            const {options: c, resumingFrom: h} = o;
            c.onExitComplete && c.onExitComplete(),
            h && h.options.onExitComplete && h.options.onExitComplete()
        }
        )
    }
    scheduleRender() {
        this.members.forEach(o => {
            o.instance && o.scheduleRender(!1)
        }
        )
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}
function buildProjectionTransform(d, o, c) {
    let h = "";
    const _ = d.x.translate / o.x
      , b = d.y.translate / o.y
      , _e = (c == null ? void 0 : c.z) || 0;
    if ((_ || b || _e) && (h = `translate3d(${_}px, ${b}px, ${_e}px) `),
    (o.x !== 1 || o.y !== 1) && (h += `scale(${1 / o.x}, ${1 / o.y}) `),
    c) {
        const {transformPerspective: at, rotate: ut, rotateX: pt, rotateY: ht, skewX: _t, skewY: vt} = c;
        at && (h = `perspective(${at}px) ${h}`),
        ut && (h += `rotate(${ut}deg) `),
        pt && (h += `rotateX(${pt}deg) `),
        ht && (h += `rotateY(${ht}deg) `),
        _t && (h += `skewX(${_t}deg) `),
        vt && (h += `skewY(${vt}deg) `)
    }
    const nt = d.x.scale * o.x
      , it = d.y.scale * o.y;
    return (nt !== 1 || it !== 1) && (h += `scale(${nt}, ${it})`),
    h || "none"
}
const compareByDepth = (d, o) => d.depth - o.depth;
class FlatTree {
    constructor() {
        this.children = [],
        this.isDirty = !1
    }
    add(o) {
        addUniqueItem(this.children, o),
        this.isDirty = !0
    }
    remove(o) {
        removeItem(this.children, o),
        this.isDirty = !0
    }
    forEach(o) {
        this.isDirty && this.children.sort(compareByDepth),
        this.isDirty = !1,
        this.children.forEach(o)
    }
}
function delay(d, o) {
    const c = time.now()
      , h = ({timestamp: _}) => {
        const b = _ - c;
        b >= o && (cancelFrame(h),
        d(b - o))
    }
    ;
    return frame.read(h, !0),
    () => cancelFrame(h)
}
function record(d) {
    window.MotionDebug && window.MotionDebug.record(d)
}
function isSVGElement(d) {
    return d instanceof SVGElement && d.tagName !== "svg"
}
function animateSingleValue(d, o, c) {
    const h = isMotionValue(d) ? d : motionValue(d);
    return h.start(animateMotionValue("", h, o, c)),
    h.animation
}
const transformAxes = ["", "X", "Y", "Z"]
  , hiddenVisibility = {
    visibility: "hidden"
}
  , animationTarget = 1e3;
let id = 0;
const projectionFrameData = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0
};
function resetDistortingTransform(d, o, c, h) {
    const {latestValues: _} = o;
    _[d] && (c[d] = _[d],
    o.setStaticValue(d, 0),
    h && (h[d] = 0))
}
function createProjectionNode({attachResizeListener: d, defaultParent: o, measureScroll: c, checkIsScrollRoot: h, resetTransform: _}) {
    return class {
        constructor(_e={}, nt=o == null ? void 0 : o()) {
            this.id = id++,
            this.animationId = 0,
            this.children = new Set,
            this.options = {},
            this.isTreeAnimating = !1,
            this.isAnimationBlocked = !1,
            this.isLayoutDirty = !1,
            this.isProjectionDirty = !1,
            this.isSharedProjectionDirty = !1,
            this.isTransformDirty = !1,
            this.updateManuallyBlocked = !1,
            this.updateBlockedByResize = !1,
            this.isUpdating = !1,
            this.isSVG = !1,
            this.needsReset = !1,
            this.shouldResetTransform = !1,
            this.treeScale = {
                x: 1,
                y: 1
            },
            this.eventHandlers = new Map,
            this.hasTreeAnimated = !1,
            this.updateScheduled = !1,
            this.projectionUpdateScheduled = !1,
            this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1,
                this.clearAllSnapshots())
            }
            ,
            this.updateProjection = () => {
                this.projectionUpdateScheduled = !1,
                projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0,
                this.nodes.forEach(propagateDirtyNodes),
                this.nodes.forEach(resolveTargetDelta),
                this.nodes.forEach(calcProjection),
                this.nodes.forEach(cleanDirtyNodes),
                record(projectionFrameData)
            }
            ,
            this.hasProjected = !1,
            this.isVisible = !0,
            this.animationProgress = 0,
            this.sharedNodes = new Map,
            this.latestValues = _e,
            this.root = nt ? nt.root || nt : this,
            this.path = nt ? [...nt.path, nt] : [],
            this.parent = nt,
            this.depth = nt ? nt.depth + 1 : 0;
            for (let it = 0; it < this.path.length; it++)
                this.path[it].shouldResetTransform = !0;
            this.root === this && (this.nodes = new FlatTree)
        }
        addEventListener(_e, nt) {
            return this.eventHandlers.has(_e) || this.eventHandlers.set(_e, new SubscriptionManager),
            this.eventHandlers.get(_e).add(nt)
        }
        notifyListeners(_e, ...nt) {
            const it = this.eventHandlers.get(_e);
            it && it.notify(...nt)
        }
        hasListeners(_e) {
            return this.eventHandlers.has(_e)
        }
        mount(_e, nt=this.root.hasTreeAnimated) {
            if (this.instance)
                return;
            this.isSVG = isSVGElement(_e),
            this.instance = _e;
            const {layoutId: it, layout: at, visualElement: ut} = this.options;
            if (ut && !ut.current && ut.mount(_e),
            this.root.nodes.add(this),
            this.parent && this.parent.children.add(this),
            nt && (at || it) && (this.isLayoutDirty = !0),
            d) {
                let pt;
                const ht = () => this.root.updateBlockedByResize = !1;
                d(_e, () => {
                    this.root.updateBlockedByResize = !0,
                    pt && pt(),
                    pt = delay(ht, 250),
                    globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1,
                    this.nodes.forEach(finishAnimation))
                }
                )
            }
            it && this.root.registerSharedNode(it, this),
            this.options.animate !== !1 && ut && (it || at) && this.addEventListener("didUpdate", ({delta: pt, hasLayoutChanged: ht, hasRelativeTargetChanged: _t, layout: vt}) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0,
                    this.relativeTarget = void 0;
                    return
                }
                const bt = this.options.transition || ut.getDefaultTransition() || defaultLayoutTransition
                  , {onLayoutAnimationStart: St, onLayoutAnimationComplete: At} = ut.getProps()
                  , Et = !this.targetLayout || !boxEqualsRounded(this.targetLayout, vt) || _t
                  , Pt = !ht && _t;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || Pt || ht && (Et || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom,
                    this.resumingFrom.resumingFrom = void 0),
                    this.setAnimationOrigin(pt, Pt);
                    const It = {
                        ...getValueTransition(bt, "layout"),
                        onPlay: St,
                        onComplete: At
                    };
                    (ut.shouldReduceMotion || this.options.layoutRoot) && (It.delay = 0,
                    It.type = !1),
                    this.startAnimation(It)
                } else
                    ht || finishAnimation(this),
                    this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = vt
            }
            )
        }
        unmount() {
            this.options.layoutId && this.willUpdate(),
            this.root.nodes.remove(this);
            const _e = this.getStack();
            _e && _e.remove(this),
            this.parent && this.parent.children.delete(this),
            this.instance = void 0,
            cancelFrame(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0,
            this.nodes && this.nodes.forEach(resetSkewAndRotation),
            this.animationId++)
        }
        getTransformTemplate() {
            const {visualElement: _e} = this.options;
            return _e && _e.getProps().transformTemplate
        }
        willUpdate(_e=!0) {
            if (this.root.hasTreeAnimated = !0,
            this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (!this.root.isUpdating && this.root.startUpdate(),
            this.isLayoutDirty)
                return;
            this.isLayoutDirty = !0;
            for (let ut = 0; ut < this.path.length; ut++) {
                const pt = this.path[ut];
                pt.shouldResetTransform = !0,
                pt.updateScroll("snapshot"),
                pt.options.layoutRoot && pt.willUpdate(!1)
            }
            const {layoutId: nt, layout: it} = this.options;
            if (nt === void 0 && !it)
                return;
            const at = this.getTransformTemplate();
            this.prevTransformTemplateValue = at ? at(this.latestValues, "") : void 0,
            this.updateSnapshot(),
            _e && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1,
            this.isUpdateBlocked()) {
                this.unblockUpdate(),
                this.clearAllSnapshots(),
                this.nodes.forEach(clearMeasurements);
                return
            }
            this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
            this.isUpdating = !1,
            window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(),
            this.nodes.forEach(resetTransformStyle),
            this.nodes.forEach(updateLayout),
            this.nodes.forEach(notifyLayoutUpdate),
            this.clearAllSnapshots();
            const nt = time.now();
            frameData.delta = clamp(0, 1e3 / 60, nt - frameData.timestamp),
            frameData.timestamp = nt,
            frameData.isProcessing = !0,
            steps.update.process(frameData),
            steps.preRender.process(frameData),
            steps.render.process(frameData),
            frameData.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0,
            microtask.read( () => this.update()))
        }
        clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot),
            this.sharedNodes.forEach(removeLeadSnapshots)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0,
            frame.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            frame.postRender( () => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            }
            )
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(),
            !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
                return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let it = 0; it < this.path.length; it++)
                    this.path[it].updateScroll();
            const _e = this.layout;
            this.layout = this.measure(!1),
            this.layoutCorrected = createBox(),
            this.isLayoutDirty = !1,
            this.projectionDelta = void 0,
            this.notifyListeners("measure", this.layout.layoutBox);
            const {visualElement: nt} = this.options;
            nt && nt.notify("LayoutMeasure", this.layout.layoutBox, _e ? _e.layoutBox : void 0)
        }
        updateScroll(_e="measure") {
            let nt = !!(this.options.layoutScroll && this.instance);
            this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === _e && (nt = !1),
            nt && (this.scroll = {
                animationId: this.root.animationId,
                phase: _e,
                isRoot: h(this.instance),
                offset: c(this.instance)
            })
        }
        resetTransform() {
            if (!_)
                return;
            const _e = this.isLayoutDirty || this.shouldResetTransform
              , nt = this.projectionDelta && !isDeltaZero(this.projectionDelta)
              , it = this.getTransformTemplate()
              , at = it ? it(this.latestValues, "") : void 0
              , ut = at !== this.prevTransformTemplateValue;
            _e && (nt || hasTransform(this.latestValues) || ut) && (_(this.instance, at),
            this.shouldResetTransform = !1,
            this.scheduleRender())
        }
        measure(_e=!0) {
            const nt = this.measurePageBox();
            let it = this.removeElementScroll(nt);
            return _e && (it = this.removeTransform(it)),
            roundBox(it),
            {
                animationId: this.root.animationId,
                measuredBox: nt,
                layoutBox: it,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            const {visualElement: _e} = this.options;
            if (!_e)
                return createBox();
            const nt = _e.measureViewportBox()
              , {scroll: it} = this.root;
            return it && (translateAxis(nt.x, it.offset.x),
            translateAxis(nt.y, it.offset.y)),
            nt
        }
        removeElementScroll(_e) {
            const nt = createBox();
            copyBoxInto(nt, _e);
            for (let it = 0; it < this.path.length; it++) {
                const at = this.path[it]
                  , {scroll: ut, options: pt} = at;
                if (at !== this.root && ut && pt.layoutScroll) {
                    if (ut.isRoot) {
                        copyBoxInto(nt, _e);
                        const {scroll: ht} = this.root;
                        ht && (translateAxis(nt.x, -ht.offset.x),
                        translateAxis(nt.y, -ht.offset.y))
                    }
                    translateAxis(nt.x, ut.offset.x),
                    translateAxis(nt.y, ut.offset.y)
                }
            }
            return nt
        }
        applyTransform(_e, nt=!1) {
            const it = createBox();
            copyBoxInto(it, _e);
            for (let at = 0; at < this.path.length; at++) {
                const ut = this.path[at];
                !nt && ut.options.layoutScroll && ut.scroll && ut !== ut.root && transformBox(it, {
                    x: -ut.scroll.offset.x,
                    y: -ut.scroll.offset.y
                }),
                hasTransform(ut.latestValues) && transformBox(it, ut.latestValues)
            }
            return hasTransform(this.latestValues) && transformBox(it, this.latestValues),
            it
        }
        removeTransform(_e) {
            const nt = createBox();
            copyBoxInto(nt, _e);
            for (let it = 0; it < this.path.length; it++) {
                const at = this.path[it];
                if (!at.instance || !hasTransform(at.latestValues))
                    continue;
                hasScale(at.latestValues) && at.updateSnapshot();
                const ut = createBox()
                  , pt = at.measurePageBox();
                copyBoxInto(ut, pt),
                removeBoxTransforms(nt, at.latestValues, at.snapshot ? at.snapshot.layoutBox : void 0, ut)
            }
            return hasTransform(this.latestValues) && removeBoxTransforms(nt, this.latestValues),
            nt
        }
        setTargetDelta(_e) {
            this.targetDelta = _e,
            this.root.scheduleUpdateProjection(),
            this.isProjectionDirty = !0
        }
        setOptions(_e) {
            this.options = {
                ...this.options,
                ..._e,
                crossfade: _e.crossfade !== void 0 ? _e.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0,
            this.layout = void 0,
            this.snapshot = void 0,
            this.prevTransformTemplateValue = void 0,
            this.targetDelta = void 0,
            this.target = void 0,
            this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(_e=!1) {
            var nt;
            const it = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = it.isProjectionDirty),
            this.isTransformDirty || (this.isTransformDirty = it.isTransformDirty),
            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = it.isSharedProjectionDirty);
            const at = !!this.resumingFrom || this !== it;
            if (!(_e || at && this.isSharedProjectionDirty || this.isProjectionDirty || !((nt = this.parent) === null || nt === void 0) && nt.isProjectionDirty || this.attemptToResolveRelativeTarget))
                return;
            const {layout: pt, layoutId: ht} = this.options;
            if (!(!this.layout || !(pt || ht))) {
                if (this.resolvedRelativeTargetAt = frameData.timestamp,
                !this.targetDelta && !this.relativeTarget) {
                    const _t = this.getClosestProjectingParent();
                    _t && _t.layout && this.animationProgress !== 1 ? (this.relativeParent = _t,
                    this.forceRelativeParentToResolveTarget(),
                    this.relativeTarget = createBox(),
                    this.relativeTargetOrigin = createBox(),
                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, _t.layout.layoutBox),
                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = createBox(),
                    this.targetWithTransforms = createBox()),
                    this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(),
                    calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox),
                    applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox),
                    this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const _t = this.getClosestProjectingParent();
                        _t && !!_t.resumingFrom == !!this.resumingFrom && !_t.options.layoutScroll && _t.target && this.animationProgress !== 1 ? (this.relativeParent = _t,
                        this.forceRelativeParentToResolveTarget(),
                        this.relativeTarget = createBox(),
                        this.relativeTargetOrigin = createBox(),
                        calcRelativePosition(this.relativeTargetOrigin, this.target, _t.target),
                        copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    projectionFrameData.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
                return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var _e;
            const nt = this.getLead()
              , it = !!this.resumingFrom || this !== nt;
            let at = !0;
            if ((this.isProjectionDirty || !((_e = this.parent) === null || _e === void 0) && _e.isProjectionDirty) && (at = !1),
            it && (this.isSharedProjectionDirty || this.isTransformDirty) && (at = !1),
            this.resolvedRelativeTargetAt === frameData.timestamp && (at = !1),
            at)
                return;
            const {layout: ut, layoutId: pt} = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation),
            this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0),
            !this.layout || !(ut || pt))
                return;
            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
            const ht = this.treeScale.x
              , _t = this.treeScale.y;
            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, it),
            nt.layout && !nt.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (nt.target = nt.layout.layoutBox,
            nt.targetWithTransforms = createBox());
            const {target: vt} = nt;
            if (!vt) {
                this.projectionTransform && (this.projectionDelta = createDelta(),
                this.projectionTransform = "none",
                this.scheduleRender());
                return
            }
            this.projectionDelta || (this.projectionDelta = createDelta(),
            this.projectionDeltaWithTransform = createDelta());
            const bt = this.projectionTransform;
            calcBoxDelta(this.projectionDelta, this.layoutCorrected, vt, this.latestValues),
            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale),
            (this.projectionTransform !== bt || this.treeScale.x !== ht || this.treeScale.y !== _t) && (this.hasProjected = !0,
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", vt)),
            projectionFrameData.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(_e=!0) {
            if (this.options.scheduleRender && this.options.scheduleRender(),
            _e) {
                const nt = this.getStack();
                nt && nt.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        setAnimationOrigin(_e, nt=!1) {
            const it = this.snapshot
              , at = it ? it.latestValues : {}
              , ut = {
                ...this.latestValues
            }
              , pt = createDelta();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0),
            this.attemptToResolveRelativeTarget = !nt;
            const ht = createBox()
              , _t = it ? it.source : void 0
              , vt = this.layout ? this.layout.source : void 0
              , bt = _t !== vt
              , St = this.getStack()
              , At = !St || St.members.length <= 1
              , Et = !!(bt && !At && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
            this.animationProgress = 0;
            let Pt;
            this.mixTargetDelta = It => {
                const Dt = It / 1e3;
                mixAxisDelta(pt.x, _e.x, Dt),
                mixAxisDelta(pt.y, _e.y, Dt),
                this.setTargetDelta(pt),
                this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(ht, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
                mixBox(this.relativeTarget, this.relativeTargetOrigin, ht, Dt),
                Pt && boxEquals(this.relativeTarget, Pt) && (this.isProjectionDirty = !1),
                Pt || (Pt = createBox()),
                copyBoxInto(Pt, this.relativeTarget)),
                bt && (this.animationValues = ut,
                mixValues(ut, at, this.latestValues, Dt, Et, At)),
                this.root.scheduleUpdateProjection(),
                this.scheduleRender(),
                this.animationProgress = Dt
            }
            ,
            this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(_e) {
            this.notifyListeners("animationStart"),
            this.currentAnimation && this.currentAnimation.stop(),
            this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(),
            this.pendingAnimation && (cancelFrame(this.pendingAnimation),
            this.pendingAnimation = void 0),
            this.pendingAnimation = frame.update( () => {
                globalProjectionState.hasAnimatedSinceResize = !0,
                this.currentAnimation = animateSingleValue(0, animationTarget, {
                    ..._e,
                    onUpdate: nt => {
                        this.mixTargetDelta(nt),
                        _e.onUpdate && _e.onUpdate(nt)
                    }
                    ,
                    onComplete: () => {
                        _e.onComplete && _e.onComplete(),
                        this.completeAnimation()
                    }
                }),
                this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation),
                this.pendingAnimation = void 0
            }
            )
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0,
            this.resumingFrom.preserveOpacity = void 0);
            const _e = this.getStack();
            _e && _e.exitAnimationComplete(),
            this.resumingFrom = this.currentAnimation = this.animationValues = void 0,
            this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
            this.currentAnimation.stop()),
            this.completeAnimation()
        }
        applyTransformsToTarget() {
            const _e = this.getLead();
            let {targetWithTransforms: nt, target: it, layout: at, latestValues: ut} = _e;
            if (!(!nt || !it || !at)) {
                if (this !== _e && this.layout && at && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, at.layoutBox)) {
                    it = this.target || createBox();
                    const pt = calcLength(this.layout.layoutBox.x);
                    it.x.min = _e.target.x.min,
                    it.x.max = it.x.min + pt;
                    const ht = calcLength(this.layout.layoutBox.y);
                    it.y.min = _e.target.y.min,
                    it.y.max = it.y.min + ht
                }
                copyBoxInto(nt, it),
                transformBox(nt, ut),
                calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, nt, ut)
            }
        }
        registerSharedNode(_e, nt) {
            this.sharedNodes.has(_e) || this.sharedNodes.set(_e, new NodeStack),
            this.sharedNodes.get(_e).add(nt);
            const at = nt.options.initialPromotionConfig;
            nt.promote({
                transition: at ? at.transition : void 0,
                preserveFollowOpacity: at && at.shouldPreserveFollowOpacity ? at.shouldPreserveFollowOpacity(nt) : void 0
            })
        }
        isLead() {
            const _e = this.getStack();
            return _e ? _e.lead === this : !0
        }
        getLead() {
            var _e;
            const {layoutId: nt} = this.options;
            return nt ? ((_e = this.getStack()) === null || _e === void 0 ? void 0 : _e.lead) || this : this
        }
        getPrevLead() {
            var _e;
            const {layoutId: nt} = this.options;
            return nt ? (_e = this.getStack()) === null || _e === void 0 ? void 0 : _e.prevLead : void 0
        }
        getStack() {
            const {layoutId: _e} = this.options;
            if (_e)
                return this.root.sharedNodes.get(_e)
        }
        promote({needsReset: _e, transition: nt, preserveFollowOpacity: it}={}) {
            const at = this.getStack();
            at && at.promote(this, it),
            _e && (this.projectionDelta = void 0,
            this.needsReset = !0),
            nt && this.setOptions({
                transition: nt
            })
        }
        relegate() {
            const _e = this.getStack();
            return _e ? _e.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {visualElement: _e} = this.options;
            if (!_e)
                return;
            let nt = !1;
            const {latestValues: it} = _e;
            if ((it.z || it.rotate || it.rotateX || it.rotateY || it.rotateZ || it.skewX || it.skewY) && (nt = !0),
            !nt)
                return;
            const at = {};
            it.z && resetDistortingTransform("z", _e, at, this.animationValues);
            for (let ut = 0; ut < transformAxes.length; ut++)
                resetDistortingTransform(`rotate${transformAxes[ut]}`, _e, at, this.animationValues),
                resetDistortingTransform(`skew${transformAxes[ut]}`, _e, at, this.animationValues);
            _e.render();
            for (const ut in at)
                _e.setStaticValue(ut, at[ut]),
                this.animationValues && (this.animationValues[ut] = at[ut]);
            _e.scheduleRender()
        }
        getProjectionStyles(_e) {
            var nt, it;
            if (!this.instance || this.isSVG)
                return;
            if (!this.isVisible)
                return hiddenVisibility;
            const at = {
                visibility: ""
            }
              , ut = this.getTransformTemplate();
            if (this.needsReset)
                return this.needsReset = !1,
                at.opacity = "",
                at.pointerEvents = resolveMotionValue(_e == null ? void 0 : _e.pointerEvents) || "",
                at.transform = ut ? ut(this.latestValues, "") : "none",
                at;
            const pt = this.getLead();
            if (!this.projectionDelta || !this.layout || !pt.target) {
                const bt = {};
                return this.options.layoutId && (bt.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1,
                bt.pointerEvents = resolveMotionValue(_e == null ? void 0 : _e.pointerEvents) || ""),
                this.hasProjected && !hasTransform(this.latestValues) && (bt.transform = ut ? ut({}, "") : "none",
                this.hasProjected = !1),
                bt
            }
            const ht = pt.animationValues || pt.latestValues;
            this.applyTransformsToTarget(),
            at.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, ht),
            ut && (at.transform = ut(ht, at.transform));
            const {x: _t, y: vt} = this.projectionDelta;
            at.transformOrigin = `${_t.origin * 100}% ${vt.origin * 100}% 0`,
            pt.animationValues ? at.opacity = pt === this ? (it = (nt = ht.opacity) !== null && nt !== void 0 ? nt : this.latestValues.opacity) !== null && it !== void 0 ? it : 1 : this.preserveOpacity ? this.latestValues.opacity : ht.opacityExit : at.opacity = pt === this ? ht.opacity !== void 0 ? ht.opacity : "" : ht.opacityExit !== void 0 ? ht.opacityExit : 0;
            for (const bt in scaleCorrectors) {
                if (ht[bt] === void 0)
                    continue;
                const {correct: St, applyTo: At} = scaleCorrectors[bt]
                  , Et = at.transform === "none" ? ht[bt] : St(ht[bt], pt);
                if (At) {
                    const Pt = At.length;
                    for (let It = 0; It < Pt; It++)
                        at[At[It]] = Et
                } else
                    at[bt] = Et
            }
            return this.options.layoutId && (at.pointerEvents = pt === this ? resolveMotionValue(_e == null ? void 0 : _e.pointerEvents) || "" : "none"),
            at
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(_e => {
                var nt;
                return (nt = _e.currentAnimation) === null || nt === void 0 ? void 0 : nt.stop()
            }
            ),
            this.root.nodes.forEach(clearMeasurements),
            this.root.sharedNodes.clear()
        }
    }
}
function updateLayout(d) {
    d.updateLayout()
}
function notifyLayoutUpdate(d) {
    var o;
    const c = ((o = d.resumeFrom) === null || o === void 0 ? void 0 : o.snapshot) || d.snapshot;
    if (d.isLead() && d.layout && c && d.hasListeners("didUpdate")) {
        const {layoutBox: h, measuredBox: _} = d.layout
          , {animationType: b} = d.options
          , _e = c.source !== d.layout.source;
        b === "size" ? eachAxis(pt => {
            const ht = _e ? c.measuredBox[pt] : c.layoutBox[pt]
              , _t = calcLength(ht);
            ht.min = h[pt].min,
            ht.max = ht.min + _t
        }
        ) : shouldAnimatePositionOnly(b, c.layoutBox, h) && eachAxis(pt => {
            const ht = _e ? c.measuredBox[pt] : c.layoutBox[pt]
              , _t = calcLength(h[pt]);
            ht.max = ht.min + _t,
            d.relativeTarget && !d.currentAnimation && (d.isProjectionDirty = !0,
            d.relativeTarget[pt].max = d.relativeTarget[pt].min + _t)
        }
        );
        const nt = createDelta();
        calcBoxDelta(nt, h, c.layoutBox);
        const it = createDelta();
        _e ? calcBoxDelta(it, d.applyTransform(_, !0), c.measuredBox) : calcBoxDelta(it, h, c.layoutBox);
        const at = !isDeltaZero(nt);
        let ut = !1;
        if (!d.resumeFrom) {
            const pt = d.getClosestProjectingParent();
            if (pt && !pt.resumeFrom) {
                const {snapshot: ht, layout: _t} = pt;
                if (ht && _t) {
                    const vt = createBox();
                    calcRelativePosition(vt, c.layoutBox, ht.layoutBox);
                    const bt = createBox();
                    calcRelativePosition(bt, h, _t.layoutBox),
                    boxEqualsRounded(vt, bt) || (ut = !0),
                    pt.options.layoutRoot && (d.relativeTarget = bt,
                    d.relativeTargetOrigin = vt,
                    d.relativeParent = pt)
                }
            }
        }
        d.notifyListeners("didUpdate", {
            layout: h,
            snapshot: c,
            delta: it,
            layoutDelta: nt,
            hasLayoutChanged: at,
            hasRelativeTargetChanged: ut
        })
    } else if (d.isLead()) {
        const {onExitComplete: h} = d.options;
        h && h()
    }
    d.options.transition = void 0
}
function propagateDirtyNodes(d) {
    projectionFrameData.totalNodes++,
    d.parent && (d.isProjecting() || (d.isProjectionDirty = d.parent.isProjectionDirty),
    d.isSharedProjectionDirty || (d.isSharedProjectionDirty = !!(d.isProjectionDirty || d.parent.isProjectionDirty || d.parent.isSharedProjectionDirty)),
    d.isTransformDirty || (d.isTransformDirty = d.parent.isTransformDirty))
}
function cleanDirtyNodes(d) {
    d.isProjectionDirty = d.isSharedProjectionDirty = d.isTransformDirty = !1
}
function clearSnapshot(d) {
    d.clearSnapshot()
}
function clearMeasurements(d) {
    d.clearMeasurements()
}
function clearIsLayoutDirty(d) {
    d.isLayoutDirty = !1
}
function resetTransformStyle(d) {
    const {visualElement: o} = d.options;
    o && o.getProps().onBeforeLayoutMeasure && o.notify("BeforeLayoutMeasure"),
    d.resetTransform()
}
function finishAnimation(d) {
    d.finishAnimation(),
    d.targetDelta = d.relativeTarget = d.target = void 0,
    d.isProjectionDirty = !0
}
function resolveTargetDelta(d) {
    d.resolveTargetDelta()
}
function calcProjection(d) {
    d.calcProjection()
}
function resetSkewAndRotation(d) {
    d.resetSkewAndRotation()
}
function removeLeadSnapshots(d) {
    d.removeLeadSnapshot()
}
function mixAxisDelta(d, o, c) {
    d.translate = mixNumber$1(o.translate, 0, c),
    d.scale = mixNumber$1(o.scale, 1, c),
    d.origin = o.origin,
    d.originPoint = o.originPoint
}
function mixAxis(d, o, c, h) {
    d.min = mixNumber$1(o.min, c.min, h),
    d.max = mixNumber$1(o.max, c.max, h)
}
function mixBox(d, o, c, h) {
    mixAxis(d.x, o.x, c.x, h),
    mixAxis(d.y, o.y, c.y, h)
}
function hasOpacityCrossfade(d) {
    return d.animationValues && d.animationValues.opacityExit !== void 0
}
const defaultLayoutTransition = {
    duration: .45,
    ease: [.4, 0, .1, 1]
}
  , userAgentContains = d => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(d)
  , roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(d) {
    d.min = roundPoint(d.min),
    d.max = roundPoint(d.max)
}
function roundBox(d) {
    roundAxis(d.x),
    roundAxis(d.y)
}
function shouldAnimatePositionOnly(d, o, c) {
    return d === "position" || d === "preserve-aspect" && !isNear(aspectRatio(o), aspectRatio(c), .2)
}
const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (d, o) => addDomEvent(d, "resize", o),
    measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
    }),
    checkIsScrollRoot: () => !0
})
  , rootProjectionNode = {
    current: void 0
}
  , HTMLProjectionNode = createProjectionNode({
    measureScroll: d => ({
        x: d.scrollLeft,
        y: d.scrollTop
    }),
    defaultParent: () => {
        if (!rootProjectionNode.current) {
            const d = new DocumentProjectionNode({});
            d.mount(window),
            d.setOptions({
                layoutScroll: !0
            }),
            rootProjectionNode.current = d
        }
        return rootProjectionNode.current
    }
    ,
    resetTransform: (d, o) => {
        d.style.transform = o !== void 0 ? o : "none"
    }
    ,
    checkIsScrollRoot: d => window.getComputedStyle(d).position === "fixed"
})
  , drag = {
    pan: {
        Feature: PanGesture
    },
    drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
}
  , prefersReducedMotion = {
    current: null
}
  , hasReducedMotionListener = {
    current: !1
};
function initPrefersReducedMotion() {
    if (hasReducedMotionListener.current = !0,
    !!isBrowser)
        if (window.matchMedia) {
            const d = window.matchMedia("(prefers-reduced-motion)")
              , o = () => prefersReducedMotion.current = d.matches;
            d.addListener(o),
            o()
        } else
            prefersReducedMotion.current = !1
}
function updateMotionValuesFromProps(d, o, c) {
    const {willChange: h} = o;
    for (const _ in o) {
        const b = o[_]
          , _e = c[_];
        if (isMotionValue(b))
            d.addValue(_, b),
            isWillChangeMotionValue(h) && h.add(_);
        else if (isMotionValue(_e))
            d.addValue(_, motionValue(b, {
                owner: d
            })),
            isWillChangeMotionValue(h) && h.remove(_);
        else if (_e !== b)
            if (d.hasValue(_)) {
                const nt = d.getValue(_);
                nt.liveStyle === !0 ? nt.jump(b) : nt.hasAnimated || nt.set(b)
            } else {
                const nt = d.getStaticValue(_);
                d.addValue(_, motionValue(nt !== void 0 ? nt : b, {
                    owner: d
                }))
            }
    }
    for (const _ in c)
        o[_] === void 0 && d.removeValue(_);
    return o
}
const visualElementStore = new WeakMap
  , valueTypes = [...dimensionValueTypes, color, complex]
  , findValueType = d => valueTypes.find(testValueType(d))
  , featureNames = Object.keys(featureDefinitions)
  , numFeatures = featureNames.length
  , propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]
  , numVariantProps = variantProps.length;
function getClosestProjectingNode(d) {
    if (d)
        return d.options.allowProjection !== !1 ? d.projection : getClosestProjectingNode(d.parent)
}
class VisualElement {
    scrapeMotionValuesFromProps(o, c, h) {
        return {}
    }
    constructor({parent: o, props: c, presenceContext: h, reducedMotionConfig: _, blockInitialAnimation: b, visualState: _e}, nt={}) {
        this.resolveKeyframes = (ht, _t, vt, bt) => new this.KeyframeResolver(ht,_t,vt,bt,this),
        this.current = null,
        this.children = new Set,
        this.isVariantNode = !1,
        this.isControllingVariants = !1,
        this.shouldReduceMotion = null,
        this.values = new Map,
        this.KeyframeResolver = KeyframeResolver,
        this.features = {},
        this.valueSubscriptions = new Map,
        this.prevMotionValues = {},
        this.events = {},
        this.propEventSubscriptions = {},
        this.notifyUpdate = () => this.notify("Update", this.latestValues),
        this.render = () => {
            this.current && (this.triggerBuild(),
            this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }
        ,
        this.scheduleRender = () => frame.render(this.render, !1, !0);
        const {latestValues: it, renderState: at} = _e;
        this.latestValues = it,
        this.baseTarget = {
            ...it
        },
        this.initialValues = c.initial ? {
            ...it
        } : {},
        this.renderState = at,
        this.parent = o,
        this.props = c,
        this.presenceContext = h,
        this.depth = o ? o.depth + 1 : 0,
        this.reducedMotionConfig = _,
        this.options = nt,
        this.blockInitialAnimation = !!b,
        this.isControllingVariants = isControllingVariants(c),
        this.isVariantNode = isVariantNode(c),
        this.isVariantNode && (this.variantChildren = new Set),
        this.manuallyAnimateOnMount = !!(o && o.current);
        const {willChange: ut, ...pt} = this.scrapeMotionValuesFromProps(c, {}, this);
        for (const ht in pt) {
            const _t = pt[ht];
            it[ht] !== void 0 && isMotionValue(_t) && (_t.set(it[ht], !1),
            isWillChangeMotionValue(ut) && ut.add(ht))
        }
    }
    mount(o) {
        this.current = o,
        visualElementStore.set(o, this),
        this.projection && !this.projection.instance && this.projection.mount(o),
        this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach( (c, h) => this.bindToMotionValue(h, c)),
        hasReducedMotionListener.current || initPrefersReducedMotion(),
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current,
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext)
    }
    unmount() {
        var o;
        visualElementStore.delete(this.current),
        this.projection && this.projection.unmount(),
        cancelFrame(this.notifyUpdate),
        cancelFrame(this.render),
        this.valueSubscriptions.forEach(c => c()),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
        for (const c in this.events)
            this.events[c].clear();
        for (const c in this.features)
            (o = this.features[c]) === null || o === void 0 || o.unmount();
        this.current = null
    }
    bindToMotionValue(o, c) {
        const h = transformProps.has(o)
          , _ = c.on("change", _e => {
            this.latestValues[o] = _e,
            this.props.onUpdate && frame.preRender(this.notifyUpdate),
            h && this.projection && (this.projection.isTransformDirty = !0)
        }
        )
          , b = c.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(o, () => {
            _(),
            b(),
            c.owner && c.stop()
        }
        )
    }
    sortNodePosition(o) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== o.type ? 0 : this.sortInstanceNodePosition(this.current, o.current)
    }
    loadFeatures({children: o, ...c}, h, _, b) {
        let _e, nt;
        for (let it = 0; it < numFeatures; it++) {
            const at = featureNames[it]
              , {isEnabled: ut, Feature: pt, ProjectionNode: ht, MeasureLayout: _t} = featureDefinitions[at];
            ht && (_e = ht),
            ut(c) && (!this.features[at] && pt && (this.features[at] = new pt(this)),
            _t && (nt = _t))
        }
        if ((this.type === "html" || this.type === "svg") && !this.projection && _e) {
            this.projection = new _e(this.latestValues,getClosestProjectingNode(this.parent));
            const {layoutId: it, layout: at, drag: ut, dragConstraints: pt, layoutScroll: ht, layoutRoot: _t} = c;
            this.projection.setOptions({
                layoutId: it,
                layout: at,
                alwaysMeasureLayout: !!ut || pt && isRefObject(pt),
                visualElement: this,
                scheduleRender: () => this.scheduleRender(),
                animationType: typeof at == "string" ? at : "both",
                initialPromotionConfig: b,
                layoutScroll: ht,
                layoutRoot: _t
            })
        }
        return nt
    }
    updateFeatures() {
        for (const o in this.features) {
            const c = this.features[o];
            c.isMounted ? c.update() : (c.mount(),
            c.isMounted = !0)
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox()
    }
    getStaticValue(o) {
        return this.latestValues[o]
    }
    setStaticValue(o, c) {
        this.latestValues[o] = c
    }
    update(o, c) {
        (o.transformTemplate || this.props.transformTemplate) && this.scheduleRender(),
        this.prevProps = this.props,
        this.props = o,
        this.prevPresenceContext = this.presenceContext,
        this.presenceContext = c;
        for (let h = 0; h < propEventHandlers.length; h++) {
            const _ = propEventHandlers[h];
            this.propEventSubscriptions[_] && (this.propEventSubscriptions[_](),
            delete this.propEventSubscriptions[_]);
            const b = "on" + _
              , _e = o[b];
            _e && (this.propEventSubscriptions[_] = this.on(_, _e))
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(o, this.prevProps, this), this.prevMotionValues),
        this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(o) {
        return this.props.variants ? this.props.variants[o] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    getVariantContext(o=!1) {
        if (o)
            return this.parent ? this.parent.getVariantContext() : void 0;
        if (!this.isControllingVariants) {
            const h = this.parent ? this.parent.getVariantContext() || {} : {};
            return this.props.initial !== void 0 && (h.initial = this.props.initial),
            h
        }
        const c = {};
        for (let h = 0; h < numVariantProps; h++) {
            const _ = variantProps[h]
              , b = this.props[_];
            (isVariantLabel(b) || b === !1) && (c[_] = b)
        }
        return c
    }
    addVariantChild(o) {
        const c = this.getClosestVariantNode();
        if (c)
            return c.variantChildren && c.variantChildren.add(o),
            () => c.variantChildren.delete(o)
    }
    addValue(o, c) {
        const h = this.values.get(o);
        c !== h && (h && this.removeValue(o),
        this.bindToMotionValue(o, c),
        this.values.set(o, c),
        this.latestValues[o] = c.get())
    }
    removeValue(o) {
        this.values.delete(o);
        const c = this.valueSubscriptions.get(o);
        c && (c(),
        this.valueSubscriptions.delete(o)),
        delete this.latestValues[o],
        this.removeValueFromRenderState(o, this.renderState)
    }
    hasValue(o) {
        return this.values.has(o)
    }
    getValue(o, c) {
        if (this.props.values && this.props.values[o])
            return this.props.values[o];
        let h = this.values.get(o);
        return h === void 0 && c !== void 0 && (h = motionValue(c === null ? void 0 : c, {
            owner: this
        }),
        this.addValue(o, h)),
        h
    }
    readValue(o, c) {
        var h;
        let _ = this.latestValues[o] !== void 0 || !this.current ? this.latestValues[o] : (h = this.getBaseTargetFromProps(this.props, o)) !== null && h !== void 0 ? h : this.readValueFromInstance(this.current, o, this.options);
        return _ != null && (typeof _ == "string" && (isNumericalString(_) || isZeroValueString(_)) ? _ = parseFloat(_) : !findValueType(_) && complex.test(c) && (_ = getAnimatableNone(o, c)),
        this.setBaseTarget(o, isMotionValue(_) ? _.get() : _)),
        isMotionValue(_) ? _.get() : _
    }
    setBaseTarget(o, c) {
        this.baseTarget[o] = c
    }
    getBaseTarget(o) {
        var c;
        const {initial: h} = this.props;
        let _;
        if (typeof h == "string" || typeof h == "object") {
            const _e = resolveVariantFromProps(this.props, h, (c = this.presenceContext) === null || c === void 0 ? void 0 : c.custom);
            _e && (_ = _e[o])
        }
        if (h && _ !== void 0)
            return _;
        const b = this.getBaseTargetFromProps(this.props, o);
        return b !== void 0 && !isMotionValue(b) ? b : this.initialValues[o] !== void 0 && _ === void 0 ? void 0 : this.baseTarget[o]
    }
    on(o, c) {
        return this.events[o] || (this.events[o] = new SubscriptionManager),
        this.events[o].add(c)
    }
    notify(o, ...c) {
        this.events[o] && this.events[o].notify(...c)
    }
}
class DOMVisualElement extends VisualElement {
    constructor() {
        super(...arguments),
        this.KeyframeResolver = DOMKeyframesResolver
    }
    sortInstanceNodePosition(o, c) {
        return o.compareDocumentPosition(c) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(o, c) {
        return o.style ? o.style[c] : void 0
    }
    removeValueFromRenderState(o, {vars: c, style: h}) {
        delete c[o],
        delete h[o]
    }
}
function getComputedStyle(d) {
    return window.getComputedStyle(d)
}
class HTMLVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "html"
    }
    readValueFromInstance(o, c) {
        if (transformProps.has(c)) {
            const h = getDefaultValueType(c);
            return h && h.default || 0
        } else {
            const h = getComputedStyle(o)
              , _ = (isCSSVariableName(c) ? h.getPropertyValue(c) : h[c]) || 0;
            return typeof _ == "string" ? _.trim() : _
        }
    }
    measureInstanceViewportBox(o, {transformPagePoint: c}) {
        return measureViewportBox(o, c)
    }
    build(o, c, h, _) {
        buildHTMLStyles(o, c, h, _.transformTemplate)
    }
    scrapeMotionValuesFromProps(o, c, h) {
        return scrapeMotionValuesFromProps$1(o, c, h)
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(),
        delete this.childSubscription);
        const {children: o} = this.props;
        isMotionValue(o) && (this.childSubscription = o.on("change", c => {
            this.current && (this.current.textContent = `${c}`)
        }
        ))
    }
    renderInstance(o, c, h, _) {
        renderHTML(o, c, h, _)
    }
}
class SVGVisualElement extends DOMVisualElement {
    constructor() {
        super(...arguments),
        this.type = "svg",
        this.isSVGTag = !1
    }
    getBaseTargetFromProps(o, c) {
        return o[c]
    }
    readValueFromInstance(o, c) {
        if (transformProps.has(c)) {
            const h = getDefaultValueType(c);
            return h && h.default || 0
        }
        return c = camelCaseAttributes.has(c) ? c : camelToDash(c),
        o.getAttribute(c)
    }
    measureInstanceViewportBox() {
        return createBox()
    }
    scrapeMotionValuesFromProps(o, c, h) {
        return scrapeMotionValuesFromProps(o, c, h)
    }
    build(o, c, h, _) {
        buildSVGAttrs(o, c, h, this.isSVGTag, _.transformTemplate)
    }
    renderInstance(o, c, h, _) {
        renderSVG(o, c, h, _)
    }
    mount(o) {
        this.isSVGTag = isSVGTag(o.tagName),
        super.mount(o)
    }
}
const createDomVisualElement = (d, o) => isSVGComponent(d) ? new SVGVisualElement(o,{
    enableHardwareAcceleration: !1
}) : new HTMLVisualElement(o,{
    allowProjection: d !== reactExports.Fragment,
    enableHardwareAcceleration: !0
})
  , layout = {
    layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
    }
}
  , preloadedFeatures = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout
}
  , motion = createMotionProxy( (d, o) => createDomMotionConfig(d, o, preloadedFeatures, createDomVisualElement));
function useIsMounted() {
    const d = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => (d.current = !0,
    () => {
        d.current = !1
    }
    ), []),
    d
}
function useForceUpdate() {
    const d = useIsMounted()
      , [o,c] = reactExports.useState(0)
      , h = reactExports.useCallback( () => {
        d.current && c(o + 1)
    }
    , [o]);
    return [reactExports.useCallback( () => frame.postRender(h), [h]), o]
}
class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(o) {
        const c = this.props.childRef.current;
        if (c && o.isPresent && !this.props.isPresent) {
            const h = this.props.sizeRef.current;
            h.height = c.offsetHeight || 0,
            h.width = c.offsetWidth || 0,
            h.top = c.offsetTop,
            h.left = c.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}
function PopChild({children: d, isPresent: o}) {
    const c = reactExports.useId()
      , h = reactExports.useRef(null)
      , _ = reactExports.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0
    })
      , {nonce: b} = reactExports.useContext(MotionConfigContext);
    return reactExports.useInsertionEffect( () => {
        const {width: _e, height: nt, top: it, left: at} = _.current;
        if (o || !h.current || !_e || !nt)
            return;
        h.current.dataset.motionPopId = c;
        const ut = document.createElement("style");
        return b && (ut.nonce = b),
        document.head.appendChild(ut),
        ut.sheet && ut.sheet.insertRule(`
          [data-motion-pop-id="${c}"] {
            position: absolute !important;
            width: ${_e}px !important;
            height: ${nt}px !important;
            top: ${it}px !important;
            left: ${at}px !important;
          }
        `),
        () => {
            document.head.removeChild(ut)
        }
    }
    , [o]),
    jsxRuntimeExports.jsx(PopChildMeasure, {
        isPresent: o,
        childRef: h,
        sizeRef: _,
        children: reactExports.cloneElement(d, {
            ref: h
        })
    })
}
const PresenceChild = ({children: d, initial: o, isPresent: c, onExitComplete: h, custom: _, presenceAffectsLayout: b, mode: _e}) => {
    const nt = useConstant(newChildrenMap)
      , it = reactExports.useId()
      , at = reactExports.useMemo( () => ({
        id: it,
        initial: o,
        isPresent: c,
        custom: _,
        onExitComplete: ut => {
            nt.set(ut, !0);
            for (const pt of nt.values())
                if (!pt)
                    return;
            h && h()
        }
        ,
        register: ut => (nt.set(ut, !1),
        () => nt.delete(ut))
    }), b ? [Math.random()] : [c]);
    return reactExports.useMemo( () => {
        nt.forEach( (ut, pt) => nt.set(pt, !1))
    }
    , [c]),
    reactExports.useEffect( () => {
        !c && !nt.size && h && h()
    }
    , [c]),
    _e === "popLayout" && (d = jsxRuntimeExports.jsx(PopChild, {
        isPresent: c,
        children: d
    })),
    jsxRuntimeExports.jsx(PresenceContext.Provider, {
        value: at,
        children: d
    })
}
;
function newChildrenMap() {
    return new Map
}
function useUnmountEffect(d) {
    return reactExports.useEffect( () => () => d(), [])
}
const getChildKey = d => d.key || "";
function updateChildLookup(d, o) {
    d.forEach(c => {
        const h = getChildKey(c);
        o.set(h, c)
    }
    )
}
function onlyElements(d) {
    const o = [];
    return reactExports.Children.forEach(d, c => {
        reactExports.isValidElement(c) && o.push(c)
    }
    ),
    o
}
const AnimatePresence = ({children: d, custom: o, initial: c=!0, onExitComplete: h, exitBeforeEnter: _, presenceAffectsLayout: b=!0, mode: _e="sync"}) => {
    const nt = reactExports.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0]
      , it = useIsMounted()
      , at = onlyElements(d);
    let ut = at;
    const pt = reactExports.useRef(new Map).current
      , ht = reactExports.useRef(ut)
      , _t = reactExports.useRef(new Map).current
      , vt = reactExports.useRef(!0);
    if (useIsomorphicLayoutEffect( () => {
        vt.current = !1,
        updateChildLookup(at, _t),
        ht.current = ut
    }
    ),
    useUnmountEffect( () => {
        vt.current = !0,
        _t.clear(),
        pt.clear()
    }
    ),
    vt.current)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: ut.map(Et => jsxRuntimeExports.jsx(PresenceChild, {
                isPresent: !0,
                initial: c ? void 0 : !1,
                presenceAffectsLayout: b,
                mode: _e,
                children: Et
            }, getChildKey(Et)))
        });
    ut = [...ut];
    const bt = ht.current.map(getChildKey)
      , St = at.map(getChildKey)
      , At = bt.length;
    for (let Et = 0; Et < At; Et++) {
        const Pt = bt[Et];
        St.indexOf(Pt) === -1 && !pt.has(Pt) && pt.set(Pt, void 0)
    }
    return _e === "wait" && pt.size && (ut = []),
    pt.forEach( (Et, Pt) => {
        if (St.indexOf(Pt) !== -1)
            return;
        const It = _t.get(Pt);
        if (!It)
            return;
        const Dt = bt.indexOf(Pt);
        let Gt = Et;
        if (!Gt) {
            const Bt = () => {
                pt.delete(Pt);
                const kt = Array.from(_t.keys()).filter(Ut => !St.includes(Ut));
                if (kt.forEach(Ut => _t.delete(Ut)),
                ht.current = at.filter(Ut => {
                    const Ht = getChildKey(Ut);
                    return Ht === Pt || kt.includes(Ht)
                }
                ),
                !pt.size) {
                    if (it.current === !1)
                        return;
                    nt(),
                    h && h()
                }
            }
            ;
            Gt = jsxRuntimeExports.jsx(PresenceChild, {
                isPresent: !1,
                onExitComplete: Bt,
                custom: o,
                presenceAffectsLayout: b,
                mode: _e,
                children: It
            }, getChildKey(It)),
            pt.set(Pt, Gt)
        }
        ut.splice(Dt, 0, Gt)
    }
    ),
    ut = ut.map(Et => {
        const Pt = Et.key;
        return pt.has(Pt) ? Et : jsxRuntimeExports.jsx(PresenceChild, {
            isPresent: !0,
            presenceAffectsLayout: b,
            mode: _e,
            children: Et
        }, getChildKey(Et))
    }
    ),
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: pt.size ? ut : ut.map(Et => reactExports.cloneElement(Et))
    })
}
;
function useMotionValue(d) {
    const o = useConstant( () => motionValue(d))
      , {isStatic: c} = reactExports.useContext(MotionConfigContext);
    if (c) {
        const [,h] = reactExports.useState(d);
        reactExports.useEffect( () => o.on("change", h), [])
    }
    return o
}
const isCustomValueType = d => d && typeof d == "object" && d.mix
  , getMixer = d => isCustomValueType(d) ? d.mix : void 0;
function transform(...d) {
    const o = !Array.isArray(d[0])
      , c = o ? 0 : -1
      , h = d[0 + c]
      , _ = d[1 + c]
      , b = d[2 + c]
      , _e = d[3 + c]
      , nt = interpolate(_, b, {
        mixer: getMixer(b[0]),
        ..._e
    });
    return o ? nt(h) : nt
}
function useCombineMotionValues(d, o) {
    const c = useMotionValue(o())
      , h = () => c.set(o());
    return h(),
    useIsomorphicLayoutEffect( () => {
        const _ = () => frame.preRender(h, !1, !0)
          , b = d.map(_e => _e.on("change", _));
        return () => {
            b.forEach(_e => _e()),
            cancelFrame(h)
        }
    }
    ),
    c
}
function useComputed(d) {
    collectMotionValues.current = [],
    d();
    const o = useCombineMotionValues(collectMotionValues.current, d);
    return collectMotionValues.current = void 0,
    o
}
function useTransform(d, o, c, h) {
    if (typeof d == "function")
        return useComputed(d);
    const _ = typeof o == "function" ? o : transform(o, c, h);
    return Array.isArray(d) ? useListTransform(d, _) : useListTransform([d], ([b]) => _(b))
}
function useListTransform(d, o) {
    const c = useConstant( () => []);
    return useCombineMotionValues(d, () => {
        c.length = 0;
        const h = d.length;
        for (let _ = 0; _ < h; _++)
            c[_] = d[_].get();
        return o(c)
    }
    )
}
function useSpring(d, o={}) {
    const {isStatic: c} = reactExports.useContext(MotionConfigContext)
      , h = reactExports.useRef(null)
      , _ = useMotionValue(isMotionValue(d) ? d.get() : d)
      , b = () => {
        h.current && h.current.stop()
    }
    ;
    return reactExports.useInsertionEffect( () => _.attach( (_e, nt) => {
        if (c)
            return nt(_e);
        const it = h.current;
        return it && it.time === 0 && it.sample(frameData.delta),
        b(),
        h.current = animateValue({
            keyframes: [_.get(), _e],
            velocity: _.getVelocity(),
            type: "spring",
            restDelta: .001,
            restSpeed: .01,
            ...o,
            onUpdate: nt
        }),
        _.get()
    }
    , b), [JSON.stringify(o)]),
    useIsomorphicLayoutEffect( () => {
        if (isMotionValue(d))
            return d.on("change", _e => _.set(parseFloat(_e)))
    }
    , [_]),
    _
}
const Uicontext = reactExports.createContext({})
  , useUi = () => reactExports.useContext(Uicontext);
function useSetupProvider(d) {
    const [o,c] = reactExports.useState(d.digitalZoom || 1)
      , [h,_] = reactExports.useState(d.cameraZoom || 1)
      , [b,_e] = reactExports.useState(d.image || "")
      , nt = d.handleStartAR || ( () => {}
    )
      , it = d.loadRing || ( () => {}
    )
      , at = d.viewer
      , ut = d.clickImage || ( () => {}
    )
      , pt = d.flipCamera || ( () => {}
    )
      , ht = d.rings || []
      , [_t,vt] = reactExports.useState(3);
    return {
        image: b,
        setImage: _e,
        digitalZoom: o,
        setDigitalZoom: c,
        handleStartAR: nt,
        cameraZoom: h,
        fingerIndex: _t,
        setCameraZoom: _,
        selectPreviousFinger: () => {
            vt(At => (At - 1 + 5) % 5)
        }
        ,
        selectNextFinger: () => {
            vt(At => (At + 1) % 5)
        }
        ,
        loadRing: it,
        clickImage: ut,
        flipCamera: pt,
        viewer: at,
        rings: ht
    }
}
function UiProvider({children: d, initialValues: o}) {
    const c = useSetupProvider(o);
    return reactExports.createElement(Uicontext.Provider, {
        value: c
    }, d)
}
function Spinner(d) {
    return jsxRuntimeExports.jsx("div", {
        className: "w-20 h-20 flex " + d.className,
        children: jsxRuntimeExports.jsx("span", {
            className: "spinner"
        })
    })
}
const RingOption = d => {
    const o = useSpring(useMotionValue(1), {
        duration: .1,
        mass: .1
    })
      , {loadRing: c, viewer: h, clickImage: _, setImage: b} = useUi()
      , [_e,nt] = reactExports.useState(!1)
      , it = reactExports.useCallback( () => {
        if (d.active) {
            h.renderEnabled = !1;
            const pt = _();
            b(pt);
            const ht = document.getElementById("ui-wrapper");
            ht && (ht.style.opacity = "0",
            setTimeout( () => {
                ht.style.pointerEvents = "none"
            }
            , 200));
            const _t = document.getElementById("share");
            _t && (_t.style.opacity = "1",
            setTimeout( () => {
                _t.style.pointerEvents = "auto"
            }
            , 200))
        }
    }
    , [d.active])
      , at = reactExports.useCallback( () => {
        d.active && o.set(1.4, !0)
    }
    , [d.active])
      , ut = reactExports.useCallback( () => {
        d.active && o.set(1.2, !0)
    }
    , [d.active]);
    return reactExports.useEffect( () => {
        d.active ? (o.set(1.2, !0),
        nt(!0),
        c(d.ringUrl, d.configUrl).then( () => {
            nt(!1)
        }
        )) : (nt(!1),
        o.set(1, !0))
    }
    , [d.active]),
    jsxRuntimeExports.jsxs(motion.div, {
        style: {
            scale: o
        },
        ref: d.refrence,
        className: "w-20 h-20 rounded-full px-2 flex justify-center items-center relative " + (d.active ? "pointer-events-auto" : "pointer-events-none"),
        onClick: it,
        onPointerDown: at,
        onPointerUp: ut,
        children: [_e && jsxRuntimeExports.jsx(Spinner, {
            className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 h-20 w-20 p-4"
        }), jsxRuntimeExports.jsx("div", {
            className: "w-14 h-14 bg-[#ffffff48] rounded-full overflow-hidden " + (d.active ? "bg-[#ffffff] " : "") + (_e ? "opacity-35" : "opacity-100"),
            children: jsxRuntimeExports.jsx("img", {
                src: d.icon,
                alt: "ring",
                className: "w-full h-full object-cover"
            })
        })]
    })
}
;
function RingsWrapper() {
    const d = reactExports.useRef(null)
      , o = reactExports.useRef(null)
      , c = useMotionValue(0)
      , [h,_] = reactExports.useState(!1)
      , {rings: b} = useUi()
      , [_e,nt] = reactExports.useState(0)
      , [it,at] = reactExports.useState(0)
      , [ut,pt] = reactExports.useState(Math.floor(b.length / 2));
    reactExports.useEffect( () => {
        !d.current || !o.current || (nt(d.current.clientWidth),
        at(o.current.clientWidth))
    }
    , [d.current, o.current]),
    reactExports.useEffect( () => {
        console.log(_e)
    }
    , [_e]);
    const ht = reactExports.useCallback(_t => {
        if (!d.current || h)
            return;
        const vt = d.current.getBoundingClientRect()
          , St = vt.left + vt.width / 2 - _t.clientX;
        let At = c.get() + St;
        At = Math.round(St / it) * it,
        c.set(At),
        console.log(At, "clicked");
        let Et = -Math.round(At / it) + Math.floor(b.length / 2);
        Et < 0 && (Et = 0),
        Et >= b.length && (Et = b.length - 1),
        pt(Et)
    }
    , [c, h, it, d.current]);
    return jsxRuntimeExports.jsxs("div", {
        className: "w-full flex justify-center items-center relative",
        children: [jsxRuntimeExports.jsx("div", {
            className: "absolute left-1/2 top-1/2 border-4 pointer-events-none border-primary rounded-full w-20 h-20 -translate-x-1/2 -translate-y-1/2 z-10"
        }), jsxRuntimeExports.jsx(motion.div, {
            onClick: ht,
            ref: d,
            drag: "x",
            _dragX: c,
            style: {
                x: c
            },
            dragConstraints: {
                left: -_e / 2 + it / 2,
                right: _e / 2 - it / 2
            },
            onDragTransitionEnd: () => {
                _(!1)
            }
            ,
            onDragStart: () => {
                _(!0)
            }
            ,
            dragTransition: {
                power: .1,
                timeConstant: 200,
                modifyTarget: _t => {
                    const vt = Math.round(_t / it) * it;
                    let bt = -Math.round(vt / it) + Math.floor(b.length / 2);
                    return bt < 0 && (bt = 0),
                    bt >= b.length && (bt = b.length - 1),
                    pt(bt),
                    vt
                }
            },
            className: "flex w-fit justify-center items-center p-3 px-0",
            children: b.map( (_t, vt) => jsxRuntimeExports.jsx(RingOption, {
                active: vt === ut,
                refrence: vt === 0 ? o : void 0,
                ringUrl: _t.ringUrl,
                configUrl: _t.configUrl,
                icon: _t.icon
            }, vt))
        })]
    })
}
const ConfigOption = d => {
    const o = reactExports.useRef(null);
    return jsxRuntimeExports.jsx("div", {
        id: d.selected ? "selectedOption" : "",
        ref: o,
        onClick: d.onClick,
        className: "flex justify-start items-center flex-col cursor-pointer relative md:h-unit-3xl md:w-unit-3xl h-[30px] w-[30px] shrink-0 " + d.className,
        children: jsxRuntimeExports.jsxs("div", {
            className: "relative w-full h-full" + (d.rect ? " w-32" : " "),
            children: [d.loading && jsxRuntimeExports.jsx(Spinner, {
                className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 h-full w-full p-1"
            }), jsxRuntimeExports.jsx("img", {
                src: d.src,
                className: "  object-fill rounded-full  outline-1 outline hover:outline-primary outline-transparent outline-default-300 transition-all duration-300 opacity-100 h-full  " + (d.selected ? " outline outline-primary " : "") + (d.loading ? " opacity-50" : "")
            })]
        })
    })
}
  , metals = [{
    name: "gold-white",
    materialUrl: "./materials/metal/gold-white-750.pmat",
    img: "./materials/metal/gold-white-750.pmat.png"
}, {
    name: "gold-yellow",
    materialUrl: "./materials/metal/gold-yellow-750.pmat",
    img: "./materials/metal/gold-yellow-750.pmat.png"
}, {
    name: "gold-rose",
    materialUrl: "./materials/metal/gold-rose-750.pmat",
    img: "./materials/metal/gold-rose-750.pmat.png"
}]
  , gems = [{
    name: "diamond",
    materialUrl: "./materials/gem/diamond-white-1.dmat",
    img: "./materials/gem/diamond-white-1.dmat.png"
}, {
    name: "ruby",
    materialUrl: "./materials/gem/ruby-1.dmat",
    img: "./materials/gem/ruby-1.dmat.png"
}, {
    name: "sapphire-yellow",
    materialUrl: "./materials/gem/sapphire-yellow.dmat",
    img: "./materials/gem/sapphire-yellow.dmat.png"
}, {
    name: "sapphire-blue",
    materialUrl: "./materials/gem/sapphire-blue.dmat",
    img: "./materials/gem/sapphire-blue.dmat.png"
}, {
    name: "emerald-1",
    materialUrl: "./materials/gem/emerald-1.dmat",
    img: "./materials/gem/emerald-1.dmat.png"
}]
  , Configurator = () => {
    const [d,o] = reactExports.useState("none")
      , {viewer: c} = useUi()
      , [h,_] = reactExports.useState("gold-white")
      , [b,_e] = reactExports.useState("diamond")
      , [nt,it] = reactExports.useState(!1)
      , at = async (ut, pt) => {
        if (!c)
            return;
        it(!0),
        pt === "metal" ? _(ut.name) : _e(ut.name);
        const ht = c.getPlugin("MaterialPresetPlugin");
        console.log(ht),
        ht && (await ht.apply(pt === "metal" ? "Metal" : "Gem", ut.materialUrl),
        it(!1))
    }
    ;
    return jsxRuntimeExports.jsx(AnimatePresence, {
        children: jsxRuntimeExports.jsxs(motion.div, {
            layout: !0,
            transition: {
                duration: .1,
                ease: "easeInOut"
            },
            className: "w-fit rounded-full p-2 px-4 flex justify-center items-center bg-[#00000055] gap-2",
            children: [d === "none" && jsxRuntimeExports.jsxs("div", {
                className: "w-full flex justify-center items-center gap-2",
                children: [jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        opacity: 0,
                        y: 20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        delay: .1 * 0
                    },
                    children: jsxRuntimeExports.jsx("img", {
                        src: "./icons/metal.svg",
                        alt: "camera",
                        className: "w-8 h-8 p-1 cursor-pointer",
                        onClick: () => o("metal")
                    })
                }), jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        opacity: 0,
                        y: 20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        delay: .1 * 1
                    },
                    children: jsxRuntimeExports.jsx("img", {
                        src: "./icons/diamond.svg",
                        alt: "camera",
                        className: "w-8 h-8 p-1 cursor-pointer",
                        onClick: () => o("gem")
                    })
                })]
            }), d === "metal" && jsxRuntimeExports.jsx("div", {
                className: "w-full flex justify-center items-center gap-2",
                children: metals.map( (ut, pt) => jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        opacity: 0,
                        y: 20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        delay: .1 * pt
                    },
                    children: jsxRuntimeExports.jsx(ConfigOption, {
                        selected: h === ut.name,
                        loading: h === ut.name && nt,
                        onClick: () => at(ut, "metal"),
                        src: ut.img,
                        name: ut.name
                    }, ut.name + pt)
                }, ut.name + pt + "container"))
            }), d === "gem" && jsxRuntimeExports.jsx("div", {
                className: "w-full flex justify-center items-center gap-2",
                children: gems.map( (ut, pt) => jsxRuntimeExports.jsx(motion.div, {
                    initial: {
                        opacity: 0,
                        y: 20
                    },
                    animate: {
                        opacity: 1,
                        y: 0
                    },
                    transition: {
                        delay: .1 * pt
                    },
                    children: jsxRuntimeExports.jsx(ConfigOption, {
                        selected: b === ut.name,
                        loading: b === ut.name && nt,
                        onClick: () => at(ut, "gem"),
                        src: ut.img,
                        name: ut.name
                    }, ut.name + pt)
                }, ut.name + pt + "container"))
            }), d !== "none" && jsxRuntimeExports.jsx("div", {
                className: "w-full flex justify-center items-center",
                children: jsxRuntimeExports.jsx("img", {
                    src: "./icons/cancel.svg",
                    alt: "close",
                    className: "w-8 h-8 cursor-pointer",
                    onClick: () => o("none")
                })
            })]
        })
    })
}
  , SettingsButton = d => jsxRuntimeExports.jsxs("div", {
    onClick: d.onClick,
    className: "flex flex-col justify-center items-center text-primary hover:text-secondary transition duration-200 " + (d.isActive ? "text-secondary" : ""),
    children: [jsxRuntimeExports.jsx("div", {
        className: "cursor-pointer " + (d.text ? "w-8 h-8" : "w-10 h-10 "),
        children: d.img
    }), d.text && jsxRuntimeExports.jsx("p", {
        className: " text-xs text-center",
        children: d.text
    })]
})
  , ArrowDownIcon = d => jsxRuntimeExports.jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 38 43",
    style: {
        width: "100%",
        height: "100%"
    },
    fill: "none",
    className: d.className,
    children: [jsxRuntimeExports.jsxs("g", {
        filter: "url(#a)",
        children: [jsxRuntimeExports.jsx("mask", {
            id: "b",
            x: 0,
            y: 3,
            maskUnits: "userSpaceOnUse",
            style: {
                maskType: "alpha"
            },
            children: jsxRuntimeExports.jsx("path", {
                fill: "#D9D9D9",
                d: "M.23 3.241h37.512v37.512H.23z"
            })
        }), jsxRuntimeExports.jsx("g", {
            mask: "url(#b)",
            children: jsxRuntimeExports.jsx("path", {
                fill: "currentColor",
                d: "m18.466 36.635-10.698-10.7 2.14-2.179 7.03 7.032V19.82h3.057v10.968l7.03-6.994 2.14 2.14-10.699 10.701Zm-1.528-19.872v-4.587h3.057v4.586h-3.057Zm0-7.644V6.062h3.057v3.057h-3.057Z"
            })
        })]
    }), jsxRuntimeExports.jsx("defs", {
        children: jsxRuntimeExports.jsxs("filter", {
            id: "a",
            x: 2.168,
            y: .462,
            colorInterpolationFilters: "sRGB",
            filterUnits: "userSpaceOnUse",
            children: [jsxRuntimeExports.jsx("feFlood", {
                floodOpacity: 0,
                result: "BackgroundImageFix"
            }), jsxRuntimeExports.jsx("feColorMatrix", {
                in: "SourceAlpha",
                result: "hardAlpha",
                values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
            }), jsxRuntimeExports.jsx("feOffset", {}), jsxRuntimeExports.jsx("feGaussianBlur", {
                stdDeviation: 2.8
            }), jsxRuntimeExports.jsx("feComposite", {
                in2: "hardAlpha",
                operator: "out"
            }), jsxRuntimeExports.jsx("feColorMatrix", {
                values: "0 0 0 0 0.0772917 0 0 0 0 0.08505 0 0 0 0 0.0875 0 0 0 1 0"
            }), jsxRuntimeExports.jsx("feBlend", {
                in2: "BackgroundImageFix",
                result: "effect1_dropShadow_196_816"
            }), jsxRuntimeExports.jsx("feBlend", {
                in: "SourceGraphic",
                in2: "effect1_dropShadow_196_816",
                result: "shape"
            })]
        })
    })]
})
  , Slider = d => jsxRuntimeExports.jsx(motion.div, {
    initial: {
        opacity: 0,
        y: 20
    },
    animate: {
        opacity: 1,
        y: 0
    },
    transition: {
        duration: .5,
        ease: "easeInOut"
    },
    className: "w-full px-4 text-white",
    children: jsxRuntimeExports.jsx("input", {
        type: "range",
        step: d.step,
        min: d.min,
        max: d.max,
        value: d.value,
        onChange: o => d.setSliderValue(Number(o.currentTarget.value)),
        className: "slider",
        id: "myRange"
    })
})
  , CameraIcon = () => jsxRuntimeExports.jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 53 56",
    style: {
        width: "100%",
        height: "100%"
    },
    children: [jsxRuntimeExports.jsxs("g", {
        filter: "url(#aa)",
        children: [jsxRuntimeExports.jsx("mask", {
            id: "bb",
            x: 0,
            y: 2,
            maskUnits: "userSpaceOnUse",
            style: {
                maskType: "alpha"
            },
            children: jsxRuntimeExports.jsx("path", {
                fill: "#D9D9D9",
                d: "M.395 2.973h51.609v51.618H.395z"
            })
        }), jsxRuntimeExports.jsx("g", {
            fill: "currentColor",
            mask: "url(#bb)",
            children: jsxRuntimeExports.jsx("path", {
                d: "M19.812 8.625c.33.247.738.37 1.227.37H31.36c.488 0 .896-.123 1.226-.37.33-.248.494-.554.494-.92 0-.367-.165-.673-.494-.92-.33-.247-.738-.37-1.226-.37H21.039c-.489 0-.897.123-1.227.37-.329.247-.494.553-.494.92 0 .366.165.672.494.92ZM26.499 24.756h14.556c-.883-2.317-2.263-4.335-4.137-6.056-1.874-1.72-4.02-2.9-6.435-3.538l-4.774 8.214a.827.827 0 0 0 0 .92c.186.306.449.46.79.46Zm-6.75 2.605c.186.306.448.46.788.46s.604-.154.79-.46l7.332-12.595a11.15 11.15 0 0 0-1.23-.152c-.454-.033-.864-.05-1.23-.05-2.19 0-4.232.415-6.124 1.245a17.264 17.264 0 0 0-5.03 3.338l4.704 8.214Zm-8.987 7.126h9.477c.336 0 .603-.153.802-.46.198-.306.204-.613.018-.92L13.804 20.55a16.75 16.75 0 0 0-2.605 4.608c-.623 1.672-.935 3.454-.935 5.346a15.86 15.86 0 0 0 .498 3.984Zm11.193 11.356 4.743-8.214c.186-.307.18-.613-.018-.92-.199-.306-.466-.46-.802-.46H11.344c.884 2.317 2.27 4.336 4.157 6.056 1.887 1.72 4.039 2.9 6.454 3.538Zm4.245.598c2.19 0 4.233-.415 6.125-1.245a17.264 17.264 0 0 0 5.03-3.337l-4.704-8.215c-.186-.306-.449-.46-.789-.46s-.603.154-.79.46l-7.293 12.56c.365.078.76.138 1.185.178.426.039.837.059 1.236.059Zm12.396-5.985a17.567 17.567 0 0 0 2.566-4.603c.649-1.708.973-3.49.973-5.35a15.86 15.86 0 0 0-.498-3.985H32.16c-.336 0-.603.153-.801.46-.199.306-.205.613-.019.92l7.256 12.558ZM26.194 49.43c-2.59 0-5.036-.496-7.337-1.489-2.3-.993-4.31-2.348-6.026-4.066-1.718-1.718-3.073-3.727-4.066-6.028-.992-2.3-1.489-4.746-1.489-7.337 0-2.623.498-5.08 1.492-7.37.995-2.291 2.35-4.294 4.063-6.008 1.713-1.713 3.722-3.068 6.026-4.063 2.303-.995 4.749-1.492 7.337-1.492 2.619 0 5.074.497 7.366 1.492s4.295 2.35 6.009 4.063c1.713 1.714 3.067 3.717 4.062 6.007.995 2.291 1.492 4.748 1.492 7.37 0 2.592-.497 5.039-1.492 7.341-.995 2.303-2.349 4.31-4.062 6.025-1.714 1.714-3.716 3.068-6.006 4.063-2.29.995-4.747 1.492-7.37 1.492Z"
            })
        })]
    }), jsxRuntimeExports.jsx("defs", {
        children: jsxRuntimeExports.jsxs("filter", {
            id: "aa",
            x: 1.676,
            y: .814,
            colorInterpolationFilters: "sRGB",
            filterUnits: "userSpaceOnUse",
            children: [jsxRuntimeExports.jsx("feFlood", {
                floodOpacity: 0,
                result: "BackgroundImageFix"
            }), jsxRuntimeExports.jsx("feColorMatrix", {
                in: "SourceAlpha",
                result: "hardAlpha",
                values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
            }), jsxRuntimeExports.jsx("feOffset", {}), jsxRuntimeExports.jsx("feGaussianBlur", {
                stdDeviation: 2.8
            }), jsxRuntimeExports.jsx("feComposite", {
                in2: "hardAlpha",
                operator: "out"
            }), jsxRuntimeExports.jsx("feColorMatrix", {
                values: "0 0 0 0 0.0772917 0 0 0 0 0.08505 0 0 0 0 0.0875 0 0 0 1 0"
            }), jsxRuntimeExports.jsx("feBlend", {
                in2: "BackgroundImageFix",
                result: "effect1_dropShadow_196_599"
            }), jsxRuntimeExports.jsx("feBlend", {
                in: "SourceGraphic",
                in2: "effect1_dropShadow_196_599",
                result: "shape"
            })]
        })
    })]
})
  , CameraZoomIcon = () => jsxRuntimeExports.jsx("svg", {
    className: "p-1",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 28 29",
    fill: "none",
    style: {
        width: "100%",
        height: "100%"
    },
    children: jsxRuntimeExports.jsx("path", {
        fill: "currentColor",
        d: "M14.22 10.036h10.718a11.59 11.59 0 0 0-3.046-4.458 11.12 11.12 0 0 0-4.739-2.605L13.64 9.02a.609.609 0 0 0 0 .677c.136.226.33.339.581.339Zm-4.97 1.918c.137.225.33.338.58.338.251 0 .445-.113.582-.338l5.399-9.272a8.218 8.218 0 0 0-.906-.112A12.54 12.54 0 0 0 14 2.533c-1.613 0-3.117.306-4.51.917a12.71 12.71 0 0 0-3.703 2.457l3.463 6.047ZM2.633 17.2h6.978c.248 0 .444-.113.59-.338a.592.592 0 0 0 .014-.677L4.873 6.939a12.334 12.334 0 0 0-1.918 3.392 11.178 11.178 0 0 0-.688 3.936 11.675 11.675 0 0 0 .366 2.933Zm8.242 8.36 3.492-6.047a.592.592 0 0 0-.014-.677c-.146-.226-.343-.339-.59-.339H3.062c.65 1.706 1.67 3.192 3.06 4.458a11.224 11.224 0 0 0 4.753 2.605ZM14 26c1.613 0 3.117-.306 4.51-.917a12.709 12.709 0 0 0 3.703-2.456l-3.463-6.048a.644.644 0 0 0-.58-.338.646.646 0 0 0-.582.338l-5.37 9.246c.268.058.56.102.872.131.313.03.617.044.91.044Zm9.127-4.406a12.933 12.933 0 0 0 1.89-3.389c.477-1.257.716-2.57.716-3.938a11.677 11.677 0 0 0-.366-2.934h-6.978c-.248 0-.444.113-.59.339a.592.592 0 0 0-.014.677l5.342 9.245ZM13.996 28.2c-1.908 0-3.709-.366-5.402-1.096a14.12 14.12 0 0 1-4.438-2.994 14.12 14.12 0 0 1-2.993-4.437A13.488 13.488 0 0 1 .067 14.27c0-1.93.366-3.74 1.098-5.426a14.172 14.172 0 0 1 2.991-4.422 14.126 14.126 0 0 1 4.437-2.991A13.482 13.482 0 0 1 13.995.333c1.929 0 3.737.366 5.425 1.099a14.167 14.167 0 0 1 4.424 2.991 14.173 14.173 0 0 1 2.99 4.422c.733 1.687 1.1 3.495 1.1 5.426 0 1.907-.367 3.709-1.1 5.404a14.131 14.131 0 0 1-2.99 4.435 14.172 14.172 0 0 1-4.423 2.991c-1.686.733-3.495 1.099-5.425 1.099Z"
    })
})
  , FlipCameraIcon = () => jsxRuntimeExports.jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    style: {
        width: "100%",
        height: "100%"
    },
    viewBox: "0 0 51 52",
    fill: "none",
    children: [jsxRuntimeExports.jsx("ellipse", {
        cx: 25.473,
        cy: 26.304,
        fill: "#000",
        fillOpacity: .4,
        rx: 25.473,
        ry: 25.478
    }), jsxRuntimeExports.jsx("g", {
        clipPath: "url(#a)",
        filter: "url(#b)",
        children: jsxRuntimeExports.jsx("path", {
            fill: "currentColor",
            d: "M33.538 13.254a.832.832 0 1 0-1.177 1.176l1.906 1.904H15.506a3.322 3.322 0 0 0-3.323 3.323v10.8a.83.83 0 1 0 1.661 0v-10.8a1.661 1.661 0 0 1 1.662-1.661h18.76L32.362 19.9a.832.832 0 0 0 1.177 1.177l3.322-3.324a.83.83 0 0 0 0-1.176l-3.322-3.323Zm1.903 21.358a1.661 1.661 0 0 0 1.662-1.662v-10.8a.831.831 0 0 1 1.661 0v10.8a3.324 3.324 0 0 1-3.323 3.323h-18.76l1.905 1.904a.832.832 0 0 1-1.176 1.177l-3.323-3.323a.83.83 0 0 1 0-1.177l3.323-3.323a.83.83 0 0 1 1.42.588.832.832 0 0 1-.244.589l-1.906 1.904h18.761Zm-4.984-8.308a4.985 4.985 0 0 1-8.508 3.525 4.985 4.985 0 1 1 8.508-3.525Zm-1.66 0a3.323 3.323 0 1 0-6.648 0 3.323 3.323 0 0 0 6.647 0Z"
        })
    }), jsxRuntimeExports.jsxs("defs", {
        children: [jsxRuntimeExports.jsx("clipPath", {
            id: "a",
            children: jsxRuntimeExports.jsx("path", {
                fill: "currentColor",
                d: "M8.86 9.688h33.226V42.92H8.86z"
            })
        }), jsxRuntimeExports.jsxs("filter", {
            id: "b",
            width: 37.781,
            height: 37.788,
            x: 6.583,
            y: 7.41,
            colorInterpolationFilters: "sRGB",
            filterUnits: "userSpaceOnUse",
            children: [jsxRuntimeExports.jsx("feFlood", {
                floodOpacity: 0,
                result: "BackgroundImageFix"
            }), jsxRuntimeExports.jsx("feColorMatrix", {
                in: "SourceAlpha",
                result: "hardAlpha",
                values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"
            }), jsxRuntimeExports.jsx("feOffset", {}), jsxRuntimeExports.jsx("feGaussianBlur", {
                stdDeviation: 2.8
            }), jsxRuntimeExports.jsx("feComposite", {
                in2: "hardAlpha",
                operator: "out"
            }), jsxRuntimeExports.jsx("feColorMatrix", {
                values: "0 0 0 0 0.0772917 0 0 0 0 0.08505 0 0 0 0 0.0875 0 0 0 1 0"
            }), jsxRuntimeExports.jsx("feBlend", {
                in2: "BackgroundImageFix",
                result: "effect1_dropShadow_196_793"
            }), jsxRuntimeExports.jsx("feBlend", {
                in: "SourceGraphic",
                in2: "effect1_dropShadow_196_793",
                result: "shape"
            })]
        })]
    })]
})
  , FingerSelectionIcon = () => jsxRuntimeExports.jsx("svg", {
    "data-slot": "icon",
    fill: "none",
    strokeWidth: "1.5",
    stroke: "currentColor",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-hidden": "true",
    children: jsxRuntimeExports.jsx("path", {
        strokeLinecap: "round",
        strokeLinejoin: "round",
        d: "M10.05 4.575a1.575 1.575 0 1 0-3.15 0v3m3.15-3v-1.5a1.575 1.575 0 0 1 3.15 0v1.5m-3.15 0 .075 5.925m3.075.75V4.575m0 0a1.575 1.575 0 0 1 3.15 0V15M6.9 7.575a1.575 1.575 0 1 0-3.15 0v8.175a6.75 6.75 0 0 0 6.75 6.75h2.018a5.25 5.25 0 0 0 3.712-1.538l1.732-1.732a5.25 5.25 0 0 0 1.538-3.712l.003-2.024a.668.668 0 0 1 .198-.471 1.575 1.575 0 1 0-2.228-2.228 3.818 3.818 0 0 0-1.12 2.687M6.9 7.575V12m6.27 4.318A4.49 4.49 0 0 1 16.35 15m.002 0h-.002"
    })
});
function SettingTabs({setShow: d}) {
    const [o,c] = reactExports.useState(0)
      , {setDigitalZoom: h, digitalZoom: _, cameraZoom: b, setCameraZoom: _e, flipCamera: nt, selectPreviousFinger: it, selectNextFinger: at} = useUi();
    return jsxRuntimeExports.jsxs("div", {
        className: "w-full h-full flex flex-col gap-6 justify-center items-center",
        children: [jsxRuntimeExports.jsxs("div", {
            className: "w-full flex justify-center items-center gap-4",
            children: [jsxRuntimeExports.jsx(SettingsButton, {
                img: jsxRuntimeExports.jsx(ArrowDownIcon, {}),
                text: "Hide",
                onClick: () => d(!1)
            }), jsxRuntimeExports.jsx(SettingsButton, {
                img: jsxRuntimeExports.jsx(CameraIcon, {}),
                text: "Digital Zoom",
                isActive: o === 0,
                onClick: () => c(0)
            }), jsxRuntimeExports.jsx(SettingsButton, {
                img: jsxRuntimeExports.jsx(CameraZoomIcon, {}),
                text: "Camera Zoom",
                isActive: o === 1,
                onClick: () => c(1)
            }), jsxRuntimeExports.jsx(SettingsButton, {
                img: jsxRuntimeExports.jsx(FingerSelectionIcon, {}),
                text: "Finger",
                isActive: o === 2,
                onClick: () => c(2)
            }), jsxRuntimeExports.jsx(SettingsButton, {
                onClick: nt,
                img: jsxRuntimeExports.jsx(FlipCameraIcon, {})
            })]
        }), jsxRuntimeExports.jsx(AnimatePresence, {
            children: jsxRuntimeExports.jsxs("div", {
                className: "h-10 w-full max-w-96",
                children: [o === 0 && jsxRuntimeExports.jsx(Slider, {
                    step: .1,
                    value: _,
                    setSliderValue: h,
                    min: 1,
                    max: 5
                }, "digital-zoom"), o === 1 && jsxRuntimeExports.jsx(Slider, {
                    step: .1,
                    value: b,
                    setSliderValue: _e,
                    min: 1,
                    max: 5
                }, "camera-zoom"), o === 2 && jsxRuntimeExports.jsxs("div", {
                    className: "flex justify-center items-center gap-4",
                    children: [jsxRuntimeExports.jsx("button", {
                        className: "p-2 rounded-md w-32 bg-gray-200",
                        onClick: it,
                        children: "Previous Finger"
                    }), jsxRuntimeExports.jsx("button", {
                        className: "p-2 rounded-md w-32 bg-gray-200",
                        onClick: at,
                        children: "Next Finger"
                    })]
                })]
            })
        })]
    })
}
const Settings = ({show: d, setShow: o}) => {
    const c = useSpring(useMotionValue(0), {
        duration: .2,
        mass: .1
    })
      , h = useTransform(c, [0, .3, 1], [0, 0, 1])
      , _ = useSpring(useMotionValue(100), {
        duration: .5,
        mass: .1
    })
      , b = reactExports.useRef(null);
    return reactExports.useEffect( () => {
        d ? (b.current && (b.current.style.pointerEvents = "auto"),
        setTimeout( () => {}
        , 400),
        c.set(1, !0),
        _.set(0, !0)) : (setTimeout( () => {
            b.current && (b.current.style.pointerEvents = "none")
        }
        , 400),
        c.set(0, !0),
        _.set(100, !0))
    }
    , [d]),
    jsxRuntimeExports.jsxs("div", {
        className: "w-full h-fit relative",
        children: [jsxRuntimeExports.jsx("div", {
            className: "absolute left-1/2 -translate-x-1/2 bottom-0 transition-all duration-200 ease-out " + (d ? "-translate-y-20 opacity-0 pointer-events-none" : "translate-y-0 opacity-100 pointer-events-auto"),
            children: jsxRuntimeExports.jsx(SettingsButton, {
                onClick: () => o(!0),
                img: jsxRuntimeExports.jsx(ArrowDownIcon, {
                    className: "rotate-180"
                }),
                text: "Show"
            })
        }), jsxRuntimeExports.jsxs(motion.div, {
            ref: b,
            style: {
                opacity: h,
                y: _
            },
            transition: {
                duration: .2,
                ease: "easeInOut"
            },
            className: "w-full h-full flex flex-col gap-4 justify-center items-center opacity-0 pointer-events-none",
            children: [jsxRuntimeExports.jsx(Configurator, {}), jsxRuntimeExports.jsx(SettingTabs, {
                setShow: o
            })]
        })]
    })
}
;
function Share() {
    const {viewer: d, image: o} = useUi()
      , c = reactExports.useCallback( () => {
        d.renderEnabled = !0;
        const _ = document.getElementById("ui-wrapper");
        _ && (_.style.opacity = "1",
        _.style.pointerEvents = "auto");
        const b = document.getElementById("share");
        b && (b.style.opacity = "0",
        b.style.pointerEvents = "none")
    }
    , [])
      , h = reactExports.useCallback(async () => {
        const _ = await (await fetch(o)).blob()
          , b = new File([_],"fileName.jpeg",{
            type: _.type
        });
        navigator.share({
            title: "Hello",
            text: "Check out this image!",
            files: [b]
        })
    }
    , [o]);
    return jsxRuntimeExports.jsxs("div", {
        className: "absolute z-10 opacity-0 gap-4 pointer-events-none w-full h-fit flex flex-col justify-center items-center bottom-7 transition-opacity duration-200",
        id: "share",
        children: [jsxRuntimeExports.jsx(SettingsButton, {
            onClick: c,
            img: jsxRuntimeExports.jsx(ArrowDownIcon, {
                className: "rotate-90"
            }),
            text: "back"
        }), jsxRuntimeExports.jsx("p", {
            className: "text-white",
            children: "Share this moment!"
        }), jsxRuntimeExports.jsx("button", {
            onClick: h,
            className: "w-40 h-10 bg-primary rounded-full active:bg-secondary text-black font-bold",
            children: "Share"
        })]
    })
}
const Logo = "" + new URL("icons/logo.webp",import.meta.url).href
  , Intro = d => {
    const {handleStartAR: o, viewer: c} = useUi()
      , h = reactExports.useRef(null)
      , [_,b] = reactExports.useState(!0)
      , [_e,nt] = reactExports.useState(!1)
      , [it,at] = reactExports.useState(!1)
      , ut = reactExports.useCallback( () => {
        b(!0),
        h.current && (h.current.style.pointerEvents = "none",
        h.current.style.backgroundColor = "#00000090");
        const pt = ht => {
            console.log("Error", ht.detail),
            b(!1),
            nt(!0),
            at(!1),
            h.current && (h.current.style.backgroundColor = "transparent",
            h.current.style.opacity = "1"),
            d.setShowUi(!1),
            window.removeEventListener("tryonRunTimeError", pt)
        }
        ;
        window.addEventListener("tryonRunTimeError", pt),
        o().then(ht => {
            if (!ht) {
                b(!1),
                nt(!0),
                h.current && (h.current.style.backgroundColor = "transparent"),
                console.error("AR did not start");
                return
            }
            console.log("AR started"),
            at(!0),
            nt(!1),
            b(!1),
            d.setShowUi(!0),
            h.current && (h.current.style.opacity = "0",
            setTimeout( () => {
                h.current.style.pointerEvents = "none"
            }
            , 200))
        }
        )
    }
    , [h.current]);
    return reactExports.useEffect( () => {
        if (!c)
            return;
        const pt = () => {
            b(!1),
            c.scene.removeEventListener("addSceneObject", pt)
        }
        ;
        c.scene.addEventListener("addSceneObject", pt)
    }
    , [c]),
    jsxRuntimeExports.jsxs("div", {
        ref: h,
        className: "absolute z-50 pointer-events-none flex justify-center items-center flex-col gap-8 py-12 w-full h-full top-0 transition-opacity duration-200",
        children: [jsxRuntimeExports.jsx("img", {
            src: Logo,
            alt: "logo",
            className: "w-48 h-32 object-contain"
        }), jsxRuntimeExports.jsx("div", {
            className: "flex-1"
        }), !it && jsxRuntimeExports.jsx("button", {
            onClick: ut,
            className: "w-fit h-10 rounded-full flex justify-center items-center text-black font-bold " + (_ ? " bg-transparent border-2 border-white transition-all duration-150 px-2 pointer-events-none " : "bg-primary px-14 pointer-events-auto"),
            children: _ ? jsxRuntimeExports.jsx(Spinner, {
                className: "h-6 w-6 text-secondary "
            }) : _e ? "Try Again" : "Start"
        })]
    })
}
;
function App() {
    const [d,o] = reactExports.useState(!1)
      , {setDigitalZoom: c} = useUi()
      , [h,_] = reactExports.useState(!1)
      , b = reactExports.useCallback( () => {
        c(1),
        console.log("User Swiped up!"),
        o(!0)
    }
    , [o])
      , _e = reactExports.useCallback( () => {
        console.log("User Swiped down!"),
        o(!1)
    }
    , [o])
      , nt = useSwipeable({
        trackMouse: !0,
        swipeDuration: 500,
        onSwipedUp: b,
        onSwipedDown: _e
    });
    return jsxRuntimeExports.jsxs("div", {
        className: "w-full h-dvh pointer-events-none overflow-hidden bg-transparent font-main font-light relative",
        children: [jsxRuntimeExports.jsx(Intro, {
            setShowUi: _
        }), h && jsxRuntimeExports.jsxs("div", {
            className: "w-full pointer-events-auto h-dvh overflow-hidden flex bg-transparent font-main font-light relative",
            children: [jsxRuntimeExports.jsx("div", {
                className: "absolute left-1/2 -translate-x-1/2 top-5",
                children: jsxRuntimeExports.jsx("img", {
                    src: "./icons/logo.webp",
                    alt: "logo",
                    className: "w-32 h-20 object-contain"
                })
            }), jsxRuntimeExports.jsx(Share, {}), jsxRuntimeExports.jsxs("div", {
                ...nt,
                className: "w-full h-full flex flex-col transition-opacity opacity-100",
                id: "ui-wrapper",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "flex-1 pointer-events-none"
                }), jsxRuntimeExports.jsx(Settings, {
                    show: d,
                    setShow: o
                }), jsxRuntimeExports.jsx(RingsWrapper, {})]
            })]
        })]
    })
}
const By = class By extends __webpackgi_exports__AViewerPlugin {
    constructor(o) {
        super(),
        this.enabled = !0,
        this._started = !1,
        this._fingerIndex = 0,
        this.start = async () => {
            var it;
            if (!this._viewer)
                return;
            const h = new URLSearchParams(window.location.search).has("disableInstore")
              , _ = window.ij_vto.InstoreRingTryonPlugin
              , b = _ && !h && await _.isAvailable();
            let _e = _;
            if (!b) {
                await ((it = this.viewer) == null ? void 0 : it.addPlugin(window.ij_vto.RingTryonUIPlugin));
                const {RingTryonPlugin: at} = window.ij_vto;
                _e = at
            }
            if (this._ringTryonPlugin = await this._viewer.getOrAddPlugin(_e),
            !this._ringTryonPlugin)
                return;
            this._started = this._ringTryonPlugin.running;
            const nt = this._started;
            if (nt || (await this._ringTryonPlugin.start(),
            this._started = this._ringTryonPlugin.running),
            !nt)
                return this._started;
            this._ringTryonPlugin.running && this._ringTryonPlugin.selectNextCamera()
        }
        ,
        this.loadRing = async (c, h) => {
            var _e, nt, it, at, ut, pt, ht, _t, vt;
            if (this._currentRingUrl = c,
            !this._viewer)
                return;
            (_e = this._viewer) == null || _e.scene.modelRoot.clear(),
            (it = (nt = this._viewer) == null ? void 0 : nt.getPlugin(__webpackgi_exports__DiamondPlugin)) == null || it.disposeAllCacheMaps(),
            console.log("loading ring", c, this._viewer);
            let _ = null;
            try {
                h && (_ = await fetch(h).then(bt => bt.json()))
            } catch (bt) {
                console.warn("Error loading ring config", bt)
            }
            const b = await ((pt = (ut = (at = this._viewer) == null ? void 0 : at.getManager()) == null ? void 0 : ut.importer) == null ? void 0 : pt.importSinglePath(c, {
                forceImport: !0
            }));
            if (b)
                if (this._currentRingUrl === c) {
                    _ && (this._ringTryonPlugin.modelScaleFactor = _.modelScaleFactor,
                    this._ringTryonPlugin.modelPosition = new __webpackgi_exports__Vector3(_.modelPosition.x,_.modelPosition.y,_.modelPosition.z),
                    this._ringTryonPlugin.modelRotation = new __webpackgi_exports__Vector3(_.modelRotation.x,_.modelRotation.y,_.modelRotation.z));
                    const bt = b.modelObject;
                    bt.userData.finger = this._fingerIndex,
                    (ht = this._viewer) == null || ht.scene.modelRoot.add(bt);
                    const St = (_t = this._viewer) == null ? void 0 : _t.getPlugin("MaterialPresetPlugin");
                    if (!St)
                        return;
                    await St.apply("Gem", "./materials/gem/diamond-white-1.dmat")
                } else
                    b.modelObject.dispose(),
                    (vt = b.dispose) == null || vt.call(b)
        }
        ,
        this.flipCamera = () => {
            var c;
            (c = this._ringTryonPlugin) == null || c.flipCamera()
        }
        ,
        this.clickImage = () => this._viewer ? this._viewer.canvas.toDataURL("image/jpeg") : void 0,
        this.ControlComponent = () => {
            const {digitalZoom: c, cameraZoom: h, fingerIndex: _} = useUi();
            return reactExports.useEffect( () => {
                this.digitalZoom = c
            }
            , [c]),
            reactExports.useEffect( () => {
                this.cameraZoom = h
            }
            , [h]),
            reactExports.useEffect( () => {
                this.fingerIndex = _
            }
            , [_]),
            jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
        }
        ,
        this.rings = o || []
    }
    get digitalZoom() {
        var o;
        return ((o = this._ringTryonPlugin) == null ? void 0 : o.videoScale) ?? 1
    }
    set digitalZoom(o) {
        this._ringTryonPlugin && (this._ringTryonPlugin.videoScale = o)
    }
    get cameraZoom() {
        var o;
        return ((o = this._ringTryonPlugin) == null ? void 0 : o.cameraZoom) ?? 1
    }
    set cameraZoom(o) {
        this._ringTryonPlugin && (this._ringTryonPlugin.cameraZoom = o)
    }
    set fingerIndex(o) {
        var c;
        this._fingerIndex = o,
        (c = this._ringTryonPlugin) == null || c.assignMainRingToFinger(o)
    }
    get fingerIndex() {
        return this._fingerIndex
    }
    async onAdded(o) {
        await super.onAdded(o);
        const c = this.createUiContainer();
        o.container.appendChild(c),
        client.createRoot(c).render(jsxRuntimeExports.jsxs(UiProvider, {
            initialValues: {
                handleStartAR: this.start,
                digitalZoom: this.digitalZoom,
                cameraZoom: this.cameraZoom,
                fingerIndex: this.fingerIndex,
                loadRing: this.loadRing,
                viewer: this._viewer,
                clickImage: this.clickImage,
                flipCamera: this.flipCamera,
                rings: this.rings
            },
            children: [jsxRuntimeExports.jsx(this.ControlComponent, {}), jsxRuntimeExports.jsx(App, {})]
        }))
    }
    createUiContainer() {
        const o = document.createElement("div");
        return o.id = "tryon-ui-wrapper",
        o.style.width = "100%",
        o.style.height = "100%",
        o.style.position = "absolute",
        o.style.top = "0",
        o.style.left = "0",
        o.style.zIndex = "100",
        o.style.pointerEvents = "none",
        o
    }
}
;
By.PluginType = "TryOnUiPlugin";
let TryOnUiPlugin = By;
const rings = [{
    icon: "./rings/1.png",
    ringUrl: "./rings/1.glb",
    configUrl: "./rings/1.json"
}, {
    icon: "./rings/2.png",
    ringUrl: "./rings/2.glb",
    configUrl: "./rings/2.json"
}, {
    icon: "./rings/3.png",
    ringUrl: "./rings/3.glb",
    configUrl: "./rings/3.json"
}, {
    icon: "./rings/4.png",
    ringUrl: "./rings/4.glb",
    configUrl: "./rings/4.json"
}, {
    icon: "./rings/5.png",
    ringUrl: "./rings/5.glb",
    configUrl: "./rings/5.json"
}, {
    icon: "./rings/6.png",
    ringUrl: "./rings/6.glb",
    configUrl: "./rings/6.json"
}, {
    icon: "./rings/7.png",
    ringUrl: "./rings/7.glb",
    configUrl: "./rings/7.json"
}];
async function setupViewer() {
    const {RingTryonPlugin: d, WebCameraBackgroundPlugin: o, WebCameraPlugin: c} = window.ij_vto
      , h = new __webpackgi_exports__ViewerApp({
        canvas: document.getElementById("webgi-canvas")
    })
      , _ = /iPad|iPhone|iPod/.test(navigator.userAgent)
      , b = _ ? Math.round(window.devicePixelRatio) : window.devicePixelRatio
      , _e = _ ? 1 : 1.5
      , nt = _ ? 1.4 : 1.5;
    h.renderer.displayCanvasScaling = __webpackgi_exports__MathUtils.clamp(b, _e, nt),
    +await h.addPlugin(MaterialPresetPlugin),
    await __webpackgi_exports__addBasePlugins(h),
    await h.renderer.refreshPipeline();
    const it = "./lightmap-r-2b.exr"
      , at = await h.addPlugin(__webpackgi_exports__DiamondPlugin);
    return at.envMap = await h.load(it),
    at.refreshEnvMaps(),
    h.renderEnabled = !1,
    await h.addPlugin(new TryOnUiPlugin(rings)),
    await h.load("./rings/2.glb"),
    await h.load("./rings/2.json"),
    await h.load("./tryon-2-web.json"),
    h.renderEnabled = !0,
    (__webpackgi_exports__getUrlQueryParam("debug") !== null || __webpackgi_exports__getUrlQueryParam("edit") !== null) && (await h.addPlugin(__webpackgi_exports__HierarchyUiPlugin),
    await h.addPlugin(__webpackgi_exports__PickingPlugin),
    await h.addPlugin(__webpackgi_exports__CameraUiPlugin),
    await h.addPlugin(__webpackgi_exports__RendererUiPlugin),
    (await h.addPlugin(__webpackgi_exports__TweakpaneUiPlugin)).setupPlugins(d, __webpackgi_exports__HierarchyUiPlugin, __webpackgi_exports__PickingPlugin, c, o, __webpackgi_exports__TonemapPlugin, __webpackgi_exports__CameraUiPlugin, __webpackgi_exports__RendererUiPlugin, __webpackgi_exports__SSRPlugin, __webpackgi_exports__SSAOPlugin, __webpackgi_exports__VignettePlugin, __webpackgi_exports__BloomPlugin, __webpackgi_exports__FilmicGrainPlugin, __webpackgi_exports__TemporalAAPlugin, __webpackgi_exports__DiamondPlugin, __webpackgi_exports__DepthOfFieldPlugin)),
    h
}
